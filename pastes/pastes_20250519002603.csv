id,title,username,language,date,content
eVjXCu0s,2025-05-18_stats.json,rdp_snitch,JSON,Sunday 18th of May 2025 07:18:16 PM CDT,"{
  ""ip"": {
    ""104.130.13.117"": 714,
    ""143.198.221.164"": 756,
    ""128.199.168.88"": 3207,
    ""143.198.129.146"": 360,
    ""167.172.131.118"": 639,
    ""172.111.244.66"": 756,
    ""143.198.126.238"": 570,
    ""157.245.159.1"": 288,
    ""157.245.150.219"": 426,
    ""216.122.187.31"": 51,
    ""45.227.254.155"": 6,
    ""88.214.25.123"": 6,
    ""198.235.24.67"": 9,
    ""80.94.95.203"": 6,
    ""162.243.90.201"": 9,
    ""23.226.79.165"": 3,
    ""167.172.153.78"": 24,
    ""147.135.222.78"": 3,
    ""167.71.129.166"": 9,
    ""147.185.132.36"": 9,
    ""203.55.131.3"": 30,
    ""102.88.21.216"": 3,
    ""147.185.132.22"": 9,
    ""165.154.11.121"": 3,
    ""92.53.15.193"": 3,
    ""45.227.254.130"": 3,
    ""194.165.16.162"": 6,
    ""160.191.89.28"": 24,
    ""98.159.109.24"": 15,
    ""103.97.93.115"": 18,
    ""159.223.73.74"": 9,
    ""185.156.73.12"": 3,
    ""45.227.254.152"": 6,
    ""92.63.197.197"": 6,
    ""198.235.24.251"": 9,
    ""77.83.207.193"": 3
  },
  ""asn"": {
    ""AS27357"": 714,
    ""AS14061"": 6297,
    ""AS9009"": 756,
    ""AS14315"": 51,
    ""AS267784"": 15,
    ""AS35042"": 6,
    ""AS396982"": 36,
    ""AS204428"": 6,
    ""AS53755"": 3,
    ""AS16276"": 3,
    ""AS50219"": 30,
    ""AS29465"": 3,
    ""AS135377"": 3,
    ""AS43612"": 3,
    ""AS48721"": 6,
    ""AS151858"": 24,
    ""AS63023"": 15,
    ""AS134053"": 18,
    ""AS210848"": 9,
    ""AS216341"": 3
  },
  ""isp"": {
    ""Rackspace Hosting"": 714,
    ""DigitalOcean, LLC"": 6297,
    ""Secure Internet LLC"": 756,
    ""Internet Utilities NA LLC"": 51,
    ""Flyservers S.A."": 21,
    ""NOC EMAIL: noc@one-host.net"": 6,
    ""Google LLC"": 36,
    ""SS-Net"": 6,
    ""Input Output Flood LLC"": 3,
    ""OVH SAS"": 3,
    ""LNK SYSTEMS MUNTENIA SRL"": 30,
    ""MTN NIGERIA Communication limited"": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Cabletel Dooel"": 3,
    ""GOLDEN"": 24,
    ""IDC"": 15,
    ""Ethernet Xpress Pvt. Ltd."": 18,
    ""OOO SibirInvest"": 3,
    ""Telkom Internet LTD"": 6,
    ""Optima LLC"": 3
  },
  ""org"": {
    ""Cloud Servers Cell 0001-0003 IAD3"": 714,
    ""DigitalOcean, LLC"": 6288,
    ""Internet Security - BE"": 756,
    ""Unknown"": 54,
    ""Xwin Universal LTD"": 15,
    ""ThinkTech Technology Industrial CO. Limited"": 6,
    ""Palo Alto Networks, Inc"": 36,
    ""Unmanaged LTD"": 6,
    ""Digital Ocean"": 9,
    ""Input Output Flood LLC"": 3,
    ""OVH"": 3,
    ""Valence Technology Co"": 30,
    ""MTN Nigeria"": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Flyservers S.A"": 6,
    ""Golden EGG Marketing Company Limited"": 24,
    ""IDC, Inc"": 15,
    ""Ethernet Xpress Pvt. Ltd."": 18,
    ""IP Kiktev Nikolay Vladimirovich"": 3,
    ""Korotkij Denis Aleksandrovich"": 6,
    ""Optima LLC"": 3
  },
  ""regionName"": {
    ""District of Columbia"": 714,
    ""South West"": 4686,
    ""California"": 411,
    ""New Jersey"": 1242,
    ""Brussels Capital"": 756,
    ""Karnataka"": 51,
    ""Vilnius"": 15,
    ""Kowloon City"": 6,
    ""Sofia-Capital"": 6,
    ""Arizona"": 3,
    ""\u00cele-de-France"": 3,
    ""England"": 9,
    ""North Holland"": 39,
    ""Lagos"": 6,
    ""Grad Skopje"": 3,
    ""Kaunas"": 6,
    ""Ho Chi Minh"": 24,
    ""Goa"": 18,
    ""Moscow"": 3
  },
  ""country"": {
    ""United States"": 2370,
    ""Singapore"": 4686,
    ""Belgium"": 756,
    ""India"": 69,
    ""Lithuania"": 21,
    ""Hong Kong"": 6,
    ""Bulgaria"": 6,
    ""France"": 3,
    ""United Kingdom"": 9,
    ""The Netherlands"": 39,
    ""Nigeria"": 6,
    ""North Macedonia"": 3,
    ""Vietnam"": 24,
    ""Russia"": 3
  },
  ""account"": {
    ""hello"": 7884,
    ""Test"": 33,
    ""ayLPrryqe"": 3,
    ""JtNpFz"": 3,
    ""bINFRR"": 3,
    ""Administr"": 12,
    ""uqPIUmlJy"": 3,
    ""BBVNWP"": 3,
    ""ZnDmsO"": 3,
    ""eltons"": 15,
    ""administr"": 15,
    ""JFcdFdHIq"": 3,
    ""TfngCn"": 3,
    ""XSEqcf"": 3,
    ""Administrator"": 3,
    ""(empty)"": 3,
    ""zYfssCQMa"": 3,
    ""DjScmt"": 3,
    ""PmEsmF"": 3
  },
  ""keyboard"": {
    ""Unknown"": 8001
  },
  ""client_build"": {
    ""Unknown"": 8001
  },
  ""client_name"": {
    ""Unknown"": 8001
  },
  ""ip_type"": {
    ""hosting"": 7113,
    ""hosting & proxy"": 765,
    ""Unknown"": 120,
    ""mobile & hosting"": 3
  }
}"
mjuQMdMX,2025-05-18_stats.json,rdp_snitch,JSON,Sunday 18th of May 2025 07:16:13 PM CDT,"{
  ""ip"": {
    ""104.130.13.117"": 476,
    ""143.198.221.164"": 504,
    ""128.199.168.88"": 2138,
    ""143.198.129.146"": 240,
    ""167.172.131.118"": 426,
    ""172.111.244.66"": 504,
    ""143.198.126.238"": 380,
    ""157.245.159.1"": 192,
    ""157.245.150.219"": 284,
    ""216.122.187.31"": 34,
    ""45.227.254.155"": 4,
    ""88.214.25.123"": 4,
    ""198.235.24.67"": 6,
    ""80.94.95.203"": 4,
    ""162.243.90.201"": 6,
    ""23.226.79.165"": 2,
    ""167.172.153.78"": 16,
    ""147.135.222.78"": 2,
    ""167.71.129.166"": 6,
    ""147.185.132.36"": 6,
    ""203.55.131.3"": 20,
    ""102.88.21.216"": 2,
    ""147.185.132.22"": 6,
    ""165.154.11.121"": 2,
    ""92.53.15.193"": 2,
    ""45.227.254.130"": 2,
    ""194.165.16.162"": 4,
    ""160.191.89.28"": 16,
    ""98.159.109.24"": 10,
    ""103.97.93.115"": 12,
    ""159.223.73.74"": 6,
    ""185.156.73.12"": 2,
    ""45.227.254.152"": 4,
    ""92.63.197.197"": 4,
    ""198.235.24.251"": 6,
    ""77.83.207.193"": 2
  },
  ""asn"": {
    ""AS27357"": 476,
    ""AS14061"": 4198,
    ""AS9009"": 504,
    ""AS14315"": 34,
    ""AS267784"": 10,
    ""AS35042"": 4,
    ""AS396982"": 24,
    ""AS204428"": 4,
    ""AS53755"": 2,
    ""AS16276"": 2,
    ""AS50219"": 20,
    ""AS29465"": 2,
    ""AS135377"": 2,
    ""AS43612"": 2,
    ""AS48721"": 4,
    ""AS151858"": 16,
    ""AS63023"": 10,
    ""AS134053"": 12,
    ""AS210848"": 6,
    ""AS216341"": 2
  },
  ""isp"": {
    ""Rackspace Hosting"": 476,
    ""DigitalOcean, LLC"": 4198,
    ""Secure Internet LLC"": 504,
    ""Internet Utilities NA LLC"": 34,
    ""Flyservers S.A."": 14,
    ""NOC EMAIL: noc@one-host.net"": 4,
    ""Google LLC"": 24,
    ""SS-Net"": 4,
    ""Input Output Flood LLC"": 2,
    ""OVH SAS"": 2,
    ""LNK SYSTEMS MUNTENIA SRL"": 20,
    ""MTN NIGERIA Communication limited"": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""Cabletel Dooel"": 2,
    ""GOLDEN"": 16,
    ""IDC"": 10,
    ""Ethernet Xpress Pvt. Ltd."": 12,
    ""OOO SibirInvest"": 2,
    ""Telkom Internet LTD"": 4,
    ""Optima LLC"": 2
  },
  ""org"": {
    ""Cloud Servers Cell 0001-0003 IAD3"": 476,
    ""DigitalOcean, LLC"": 4192,
    ""Internet Security - BE"": 504,
    ""Unknown"": 36,
    ""Xwin Universal LTD"": 10,
    ""ThinkTech Technology Industrial CO. Limited"": 4,
    ""Palo Alto Networks, Inc"": 24,
    ""Unmanaged LTD"": 4,
    ""Digital Ocean"": 6,
    ""Input Output Flood LLC"": 2,
    ""OVH"": 2,
    ""Valence Technology Co"": 20,
    ""MTN Nigeria"": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""Flyservers S.A"": 4,
    ""Golden EGG Marketing Company Limited"": 16,
    ""IDC, Inc"": 10,
    ""Ethernet Xpress Pvt. Ltd."": 12,
    ""IP Kiktev Nikolay Vladimirovich"": 2,
    ""Korotkij Denis Aleksandrovich"": 4,
    ""Optima LLC"": 2
  },
  ""regionName"": {
    ""District of Columbia"": 476,
    ""South West"": 3124,
    ""California"": 274,
    ""New Jersey"": 828,
    ""Brussels Capital"": 504,
    ""Karnataka"": 34,
    ""Vilnius"": 10,
    ""Kowloon City"": 4,
    ""Sofia-Capital"": 4,
    ""Arizona"": 2,
    ""\u00cele-de-France"": 2,
    ""England"": 6,
    ""North Holland"": 26,
    ""Lagos"": 4,
    ""Grad Skopje"": 2,
    ""Kaunas"": 4,
    ""Ho Chi Minh"": 16,
    ""Goa"": 12,
    ""Moscow"": 2
  },
  ""country"": {
    ""United States"": 1580,
    ""Singapore"": 3124,
    ""Belgium"": 504,
    ""India"": 46,
    ""Lithuania"": 14,
    ""Hong Kong"": 4,
    ""Bulgaria"": 4,
    ""France"": 2,
    ""United Kingdom"": 6,
    ""The Netherlands"": 26,
    ""Nigeria"": 4,
    ""North Macedonia"": 2,
    ""Vietnam"": 16,
    ""Russia"": 2
  },
  ""account"": {
    ""hello"": 5256,
    ""Test"": 22,
    ""ayLPrryqe"": 2,
    ""JtNpFz"": 2,
    ""bINFRR"": 2,
    ""Administr"": 8,
    ""uqPIUmlJy"": 2,
    ""BBVNWP"": 2,
    ""ZnDmsO"": 2,
    ""eltons"": 10,
    ""administr"": 10,
    ""JFcdFdHIq"": 2,
    ""TfngCn"": 2,
    ""XSEqcf"": 2,
    ""Administrator"": 2,
    ""(empty)"": 2,
    ""zYfssCQMa"": 2,
    ""DjScmt"": 2,
    ""PmEsmF"": 2
  },
  ""keyboard"": {
    ""Unknown"": 5334
  },
  ""client_build"": {
    ""Unknown"": 5334
  },
  ""client_name"": {
    ""Unknown"": 5334
  },
  ""ip_type"": {
    ""hosting"": 4742,
    ""hosting & proxy"": 510,
    ""Unknown"": 80,
    ""mobile & hosting"": 2
  }
}"
urT9AKa5,2025-05-18_stats.json,rdp_snitch,JSON,Sunday 18th of May 2025 07:15:09 PM CDT,"{
  ""ip"": {
    ""104.130.13.117"": 238,
    ""143.198.221.164"": 252,
    ""128.199.168.88"": 1069,
    ""143.198.129.146"": 120,
    ""167.172.131.118"": 213,
    ""172.111.244.66"": 252,
    ""143.198.126.238"": 190,
    ""157.245.159.1"": 96,
    ""157.245.150.219"": 142,
    ""216.122.187.31"": 17,
    ""45.227.254.155"": 2,
    ""88.214.25.123"": 2,
    ""198.235.24.67"": 3,
    ""80.94.95.203"": 2,
    ""162.243.90.201"": 3,
    ""23.226.79.165"": 1,
    ""167.172.153.78"": 8,
    ""147.135.222.78"": 1,
    ""167.71.129.166"": 3,
    ""147.185.132.36"": 3,
    ""203.55.131.3"": 10,
    ""102.88.21.216"": 1,
    ""147.185.132.22"": 3,
    ""165.154.11.121"": 1,
    ""92.53.15.193"": 1,
    ""45.227.254.130"": 1,
    ""194.165.16.162"": 2,
    ""160.191.89.28"": 8,
    ""98.159.109.24"": 5,
    ""103.97.93.115"": 6,
    ""159.223.73.74"": 3,
    ""185.156.73.12"": 1,
    ""45.227.254.152"": 2,
    ""92.63.197.197"": 2,
    ""198.235.24.251"": 3,
    ""77.83.207.193"": 1
  },
  ""asn"": {
    ""AS27357"": 238,
    ""AS14061"": 2099,
    ""AS9009"": 252,
    ""AS14315"": 17,
    ""AS267784"": 5,
    ""AS35042"": 2,
    ""AS396982"": 12,
    ""AS204428"": 2,
    ""AS53755"": 1,
    ""AS16276"": 1,
    ""AS50219"": 10,
    ""AS29465"": 1,
    ""AS135377"": 1,
    ""AS43612"": 1,
    ""AS48721"": 2,
    ""AS151858"": 8,
    ""AS63023"": 5,
    ""AS134053"": 6,
    ""AS210848"": 3,
    ""AS216341"": 1
  },
  ""isp"": {
    ""Rackspace Hosting"": 238,
    ""DigitalOcean, LLC"": 2099,
    ""Secure Internet LLC"": 252,
    ""Internet Utilities NA LLC"": 17,
    ""Flyservers S.A."": 7,
    ""NOC EMAIL: noc@one-host.net"": 2,
    ""Google LLC"": 12,
    ""SS-Net"": 2,
    ""Input Output Flood LLC"": 1,
    ""OVH SAS"": 1,
    ""LNK SYSTEMS MUNTENIA SRL"": 10,
    ""MTN NIGERIA Communication limited"": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""Cabletel Dooel"": 1,
    ""GOLDEN"": 8,
    ""IDC"": 5,
    ""Ethernet Xpress Pvt. Ltd."": 6,
    ""OOO SibirInvest"": 1,
    ""Telkom Internet LTD"": 2,
    ""Optima LLC"": 1
  },
  ""org"": {
    ""Cloud Servers Cell 0001-0003 IAD3"": 238,
    ""DigitalOcean, LLC"": 2096,
    ""Internet Security - BE"": 252,
    ""Unknown"": 18,
    ""Xwin Universal LTD"": 5,
    ""ThinkTech Technology Industrial CO. Limited"": 2,
    ""Palo Alto Networks, Inc"": 12,
    ""Unmanaged LTD"": 2,
    ""Digital Ocean"": 3,
    ""Input Output Flood LLC"": 1,
    ""OVH"": 1,
    ""Valence Technology Co"": 10,
    ""MTN Nigeria"": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""Flyservers S.A"": 2,
    ""Golden EGG Marketing Company Limited"": 8,
    ""IDC, Inc"": 5,
    ""Ethernet Xpress Pvt. Ltd."": 6,
    ""IP Kiktev Nikolay Vladimirovich"": 1,
    ""Korotkij Denis Aleksandrovich"": 2,
    ""Optima LLC"": 1
  },
  ""regionName"": {
    ""District of Columbia"": 238,
    ""South West"": 1562,
    ""California"": 137,
    ""New Jersey"": 414,
    ""Brussels Capital"": 252,
    ""Karnataka"": 17,
    ""Vilnius"": 5,
    ""Kowloon City"": 2,
    ""Sofia-Capital"": 2,
    ""Arizona"": 1,
    ""\u00cele-de-France"": 1,
    ""England"": 3,
    ""North Holland"": 13,
    ""Lagos"": 2,
    ""Grad Skopje"": 1,
    ""Kaunas"": 2,
    ""Ho Chi Minh"": 8,
    ""Goa"": 6,
    ""Moscow"": 1
  },
  ""country"": {
    ""United States"": 790,
    ""Singapore"": 1562,
    ""Belgium"": 252,
    ""India"": 23,
    ""Lithuania"": 7,
    ""Hong Kong"": 2,
    ""Bulgaria"": 2,
    ""France"": 1,
    ""United Kingdom"": 3,
    ""The Netherlands"": 13,
    ""Nigeria"": 2,
    ""North Macedonia"": 1,
    ""Vietnam"": 8,
    ""Russia"": 1
  },
  ""account"": {
    ""hello"": 2628,
    ""Test"": 11,
    ""ayLPrryqe"": 1,
    ""JtNpFz"": 1,
    ""bINFRR"": 1,
    ""Administr"": 4,
    ""uqPIUmlJy"": 1,
    ""BBVNWP"": 1,
    ""ZnDmsO"": 1,
    ""eltons"": 5,
    ""administr"": 5,
    ""JFcdFdHIq"": 1,
    ""TfngCn"": 1,
    ""XSEqcf"": 1,
    ""Administrator"": 1,
    ""(empty)"": 1,
    ""zYfssCQMa"": 1,
    ""DjScmt"": 1,
    ""PmEsmF"": 1
  },
  ""keyboard"": {
    ""Unknown"": 2667
  },
  ""client_build"": {
    ""Unknown"": 2667
  },
  ""client_name"": {
    ""Unknown"": 2667
  },
  ""ip_type"": {
    ""hosting"": 2371,
    ""hosting & proxy"": 255,
    ""Unknown"": 40,
    ""mobile & hosting"": 1
  }
}"
KAfSFdUj,Q2-trees,tensedtorch,Python,Sunday 18th of May 2025 06:21:37 PM CDT,"import math

class SegmentTreeForPrevNext:
    def __init__(self, n_elements: int):
        self.n = n_elements
        self.tree_leaf_start_idx = 1
        while self.tree_leaf_start_idx < self.n:
            self.tree_leaf_start_idx *= 2
        self.tree = [0] * (2 * self.tree_leaf_start_idx)

    def mark_malicious(self, original_idx: int):
        current_tree_node_idx = self.tree_leaf_start_idx + original_idx
        if self.tree[current_tree_node_idx] == 1:
            return
        self.tree[current_tree_node_idx] = 1
        while current_tree_node_idx > 1:
            current_tree_node_idx //= 2
            self.tree[current_tree_node_idx] = self.tree[current_tree_node_idx * 2] + self.tree[current_tree_node_idx * 2 + 1]

    def _find_rightmost_one_recursive(self, current_tree_node_idx: int,
                                       node_L: int, node_R: int,
                                       query_L: int, query_R: int) -> int:
        if query_L > query_R or node_L > query_R or node_R < query_L or self.tree[current_tree_node_idx] == 0:
            return -1
        if node_L == node_R:
            return node_L
        mid = (node_L + node_R) // 2
        res_right = self._find_rightmost_one_recursive(2 * current_tree_node_idx + 1, mid + 1, node_R, query_L, query_R)
        if res_right != -1:
            return res_right
        res_left = self._find_rightmost_one_recursive(2 * current_tree_node_idx, node_L, mid, query_L, query_R)
        return res_left

    def find_prev_malicious_site(self, original_idx: int) -> int:
        if original_idx == 0:
            return -1
        return self._find_rightmost_one_recursive(1, 0, self.tree_leaf_start_idx - 1, 0, original_idx - 1)

    def _find_leftmost_one_recursive(self, current_tree_node_idx: int,
                                      node_L: int, node_R: int,
                                      query_L: int, query_R: int) -> int:
        if query_L > query_R or node_L > query_R or node_R < query_L or self.tree[current_tree_node_idx] == 0:
            return -1
        if node_L == node_R:
            return node_L
        mid = (node_L + node_R) // 2
        res_left = self._find_leftmost_one_recursive(2 * current_tree_node_idx, node_L, mid, query_L, query_R)
        if res_left != -1:
            return res_left
        res_right = self._find_leftmost_one_recursive(2 * current_tree_node_idx + 1, mid + 1, node_R, query_L, query_R)
        return res_right

    def find_next_malicious_site(self, original_idx: int) -> int:
        if original_idx == self.n - 1:
            return self.n
        res = self._find_leftmost_one_recursive(1, 0, self.tree_leaf_start_idx - 1, original_idx + 1, self.n - 1)
        return res if res != -1 else self.n

def findMinimumTime(password: str, attackOrder: list[int], m: int) -> int:
    N = len(password)

    if N == 0:
        return 0

    if m == 0:
        return 1

    def count_substrings_from_length(k: int) -> int:
        if k <= 0:
            return 0
        return k * (k + 1) // 2

    seg_tree = SegmentTreeForPrevNext(N)
    current_total_clean_substrings = count_substrings_from_length(N)
    total_possible_substrings = current_total_clean_substrings

    for t, attack_pos_1_indexed in enumerate(attackOrder):
        time_step = t + 1
        attack_idx_0_based = attack_pos_1_indexed - 1

        prev_mal_idx = seg_tree.find_prev_malicious_site(attack_idx_0_based)
        next_mal_idx = seg_tree.find_next_malicious_site(attack_idx_0_based)

        len_old_segment = next_mal_idx - prev_mal_idx - 1
        current_total_clean_substrings -= count_substrings_from_length(len_old_segment)

        len_left_segment = attack_idx_0_based - prev_mal_idx - 1
        current_total_clean_substrings += count_substrings_from_length(len_left_segment)

        len_right_segment = next_mal_idx - attack_idx_0_based - 1
        current_total_clean_substrings += count_substrings_from_length(len_right_segment)

        seg_tree.mark_malicious(attack_idx_0_based)

        num_malicious_substrings = total_possible_substrings - current_total_clean_substrings
        if num_malicious_substrings >= m:
            return time_step

    return -1"
AMLs513X,Earnings schemes,smilezrblx,JavaScript,Sunday 18th of May 2025 06:20:06 PM CDT,CHECK >>>> https://t.me/LucasLEAK
v1r2jSW9,Q2,tensedtorch,Python,Sunday 18th of May 2025 06:17:53 PM CDT,"import bisect

def findMinimumTime(password: str, attackOrder: list[int], m: int) -> int:
    N = len(password)

    if N == 0:
        return 0

    if m == 0:
        return 1

    def count_substrings_from_length(k: int) -> int:
        if k <= 0:
            return 0
        return k * (k + 1) // 2

    malicious_sites_sorted = [-1, N] 

    current_total_clean_substrings = count_substrings_from_length(N)
    total_possible_substrings = current_total_clean_substrings

    for t, attack_pos_1_indexed in enumerate(attackOrder):
        time_step = t + 1
        attack_idx_0_based = attack_pos_1_indexed - 1

        insertion_idx = bisect.bisect_left(malicious_sites_sorted, attack_idx_0_based)
        
        prev_mal_idx = malicious_sites_sorted[insertion_idx - 1]
        next_mal_idx = malicious_sites_sorted[insertion_idx]

        len_old_segment = next_mal_idx - prev_mal_idx - 1
        current_total_clean_substrings -= count_substrings_from_length(len_old_segment)

        len_left_segment = attack_idx_0_based - prev_mal_idx - 1
        current_total_clean_substrings += count_substrings_from_length(len_left_segment)

        len_right_segment = next_mal_idx - attack_idx_0_based - 1
        current_total_clean_substrings += count_substrings_from_length(len_right_segment)
        
        malicious_sites_sorted.insert(insertion_idx, attack_idx_0_based)

        num_malicious_substrings = total_possible_substrings - current_total_clean_substrings
        if num_malicious_substrings >= m:
            return time_step
            
    return -1"
VrdukDeY,Untitled,boasssssss,JSON,Sunday 18th of May 2025 06:06:25 PM CDT,https://t.me/LucasLEAK
eQWJzXGQ,Untitled,Pearlkrabs0O_,JSON,Sunday 18th of May 2025 06:04:21 PM CDT,"{""nameless"": {""data"": {""url"": """", ""link"": {""hiji"": ""==wVrd1SQRTSvw2ZuwmZz9yL6MHc0RHa"", ""dua"": ""=MTballNwZEevw2ZuwmZz9yL6MHc0RHa"", ""tilu"": ""=g3M4c0MQRDRvw2ZuwmZz9yL6MHc0RHa"", ""opat"": ""==gZzgnVvw2ZuwmZz9yL6MHc0RHa"", ""lima"": ""==gV0NET3EzVvw2ZuwmZz9yL6MHc0RHa"", ""pw"": {""hiji"": ""=IlTShjYhxUQBlEMLR0UxJGbWxEMT52N4kmVvtUNp50cWNGduJGW6RFWrZ1V1AHR2M0a"", ""dua"": ""=IXeG12RJxGajJmRzt0dDt0V0gXYFNUNNJneUl3cSh1VjR3c2NWYrBVcDV0QVRUQORlc"", ""tilu"": ""=oVRJRFb5gEU4A1MVxkat5Gd4R3R2U2Z2YHSCNURxZkNC9mUQd0ZulUSRl1UlxGM5MjS"", ""opat"": ""=oUO0YEWaB3axQDTlJnZNdjdzMmWttkWyhjZxkFdEV2UiFmSDNzUC5GblJnYjlGT4kDd"", ""lima"": ""=8Ea14UU4IDWkFVMDtGMKN1MIt2NlN2SsNFcBRzVXlUQHNzQyIDaxM3QBl2Z2dWViZ1Y"", ""jumlah"": {""old-user"": ""0""}}}}}}"
YYB56N9Q,jadeaddons crashing create,ThouZands,Logtalk,Sunday 18th of May 2025 05:37:35 PM CDT,"[17:35:37] [main/INFO]: Loading Minecraft 1.20.1 with Fabric Loader 0.16.14
[17:35:37] [main/INFO]: Loading 95 mods:
	- create 0.5.1-j-build.1631+mc1.20.1
	   |-- com_google_code_findbugs_jsr305 3.0.2
	   |-- flywheel 0.6.11-4
	   |-- forgeconfigapiport 8.0.0
	   |-- milk 1.2.60
	   |    \-- dripstone_fluid_lib 3.0.2
	   |-- porting_lib_accessors 2.3.8+1.20.1
	   |    \-- porting_lib_core 2.3.8+1.20.1
	   |-- porting_lib_base 2.3.8+1.20.1
	   |    |-- com_electronwill_night-config_core 3.6.6
	   |    |-- com_electronwill_night-config_toml 3.6.6
	   |    |-- porting_lib_attributes 2.3.8+1.20.1
	   |    |-- porting_lib_common 2.3.8+1.20.1
	   |    |-- porting_lib_config 2.3.8+1.20.1
	   |    |-- porting_lib_core 2.3.8+1.20.1
	   |    |-- porting_lib_fluids 2.3.8+1.20.1
	   |    |-- porting_lib_gui_utils 2.3.8+1.20.1
	   |    |-- porting_lib_lazy_registration 2.3.8+1.20.1
	   |    |-- porting_lib_mixin_extensions 2.3.8+1.20.1
	   |    |-- porting_lib_utility 2.3.8+1.20.1
	   |    \-- reach-entity-attributes 2.4.0
	   |-- porting_lib_brewing 2.3.8+1.20.1
	   |    \-- porting_lib_core 2.3.8+1.20.1
	   |-- porting_lib_client_events 2.3.8+1.20.1
	   |    \-- porting_lib_core 2.3.8+1.20.1
	   |-- porting_lib_entity 2.3.8+1.20.1
	   |    |-- porting_lib_core 2.3.8+1.20.1
	   |    \-- porting_lib_mixin_extensions 2.3.8+1.20.1
	   |-- porting_lib_extensions 2.3.8+1.20.1
	   |    |-- porting_lib_attributes 2.3.8+1.20.1
	   |    |-- porting_lib_common 2.3.8+1.20.1
	   |    |-- porting_lib_core 2.3.8+1.20.1
	   |    \-- reach-entity-attributes 2.4.0
	   |-- porting_lib_models 2.3.8+1.20.1
	   |    |-- porting_lib_core 2.3.8+1.20.1
	   |    |-- porting_lib_fluids 2.3.8+1.20.1
	   |    \-- porting_lib_model_loader 2.3.8+1.20.1
	   |-- porting_lib_networking 2.3.8+1.20.1
	   |    \-- porting_lib_core 2.3.8+1.20.1
	   |-- porting_lib_obj_loader 2.3.8+1.20.1
	   |    |-- porting_lib_core 2.3.8+1.20.1
	   |    \-- porting_lib_model_loader 2.3.8+1.20.1
	   |-- porting_lib_tags 3.0
	   |    \-- porting_lib_core 2.3.8+1.20.1
	   |-- porting_lib_tool_actions 2.3.8+1.20.1
	   |    \-- porting_lib_core 2.3.8+1.20.1
	   |-- porting_lib_transfer 2.3.8+1.20.1
	   |    |-- porting_lib_core 2.3.8+1.20.1
	   |    \-- porting_lib_fluids 2.3.8+1.20.1
	   |-- reach-entity-attributes 2.4.0
	   \-- registrate-fabric 1.3.79-MC1.20.1
	        |-- com_google_code_findbugs_jsr305 3.0.2
	        |-- porting_lib_data 2.1.1090+1.20
	        |    \-- porting_lib_gametest 2.1.1090+1.20
	        \-- porting_lib_model_generators 2.1.1090+1.20
	             |-- porting_lib_gametest 2.1.1090+1.20
	             \-- porting_lib_model_materials 2.1.1090+1.20
	- fabric-api 0.92.5+1.20.1
	   |-- fabric-api-base 0.4.32+1802ada577
	   |-- fabric-api-lookup-api-v1 1.6.37+1802ada577
	   |-- fabric-biome-api-v1 13.0.14+1802ada577
	   |-- fabric-block-api-v1 1.0.12+1802ada577
	   |-- fabric-block-view-api-v2 1.0.3+924f046a77
	   |-- fabric-blockrenderlayer-v1 1.1.42+1802ada577
	   |-- fabric-client-tags-api-v1 1.1.3+1802ada577
	   |-- fabric-command-api-v1 1.2.35+f71b366f77
	   |-- fabric-command-api-v2 2.2.14+1802ada577
	   |-- fabric-commands-v0 0.2.52+df3654b377
	   |-- fabric-containers-v0 0.1.66+df3654b377
	   |-- fabric-content-registries-v0 4.0.13+1802ada577
	   |-- fabric-convention-tags-v1 1.5.6+1802ada577
	   |-- fabric-crash-report-info-v1 0.2.20+1802ada577
	   |-- fabric-data-attachment-api-v1 1.0.2+de0fd6d177
	   |-- fabric-data-generation-api-v1 12.3.6+1802ada577
	   |-- fabric-dimensions-v1 2.1.55+1802ada577
	   |-- fabric-entity-events-v1 1.6.1+1c78457f77
	   |-- fabric-events-interaction-v0 0.6.4+13a40c6677
	   |-- fabric-events-lifecycle-v0 0.2.64+df3654b377
	   |-- fabric-game-rule-api-v1 1.0.41+1802ada577
	   |-- fabric-item-api-v1 2.1.29+1802ada577
	   |-- fabric-item-group-api-v1 4.0.14+1802ada577
	   |-- fabric-key-binding-api-v1 1.0.38+1802ada577
	   |-- fabric-keybindings-v0 0.2.36+df3654b377
	   |-- fabric-lifecycle-events-v1 2.2.23+1802ada577
	   |-- fabric-loot-api-v2 1.2.3+1802ada577
	   |-- fabric-loot-tables-v1 1.1.47+9e7660c677
	   |-- fabric-message-api-v1 5.1.10+1802ada577
	   |-- fabric-mining-level-api-v1 2.1.52+1802ada577
	   |-- fabric-model-loading-api-v1 1.0.4+1802ada577
	   |-- fabric-models-v0 0.4.3+9386d8a777
	   |-- fabric-networking-api-v1 1.3.13+13a40c6677
	   |-- fabric-networking-v0 0.3.53+df3654b377
	   |-- fabric-object-builder-api-v1 11.1.5+e35120df77
	   |-- fabric-particles-v1 1.1.3+1802ada577
	   |-- fabric-recipe-api-v1 1.0.23+1802ada577
	   |-- fabric-registry-sync-v0 2.3.5+1802ada577
	   |-- fabric-renderer-api-v1 3.2.2+1802ada577
	   |-- fabric-renderer-indigo 1.5.3+85287f9f77
	   |-- fabric-renderer-registries-v1 3.2.47+df3654b377
	   |-- fabric-rendering-data-attachment-v1 0.3.39+92a0d36777
	   |-- fabric-rendering-fluids-v1 3.0.29+1802ada577
	   |-- fabric-rendering-v0 1.1.50+df3654b377
	   |-- fabric-rendering-v1 3.0.9+1802ada577
	   |-- fabric-resource-conditions-api-v1 2.3.9+1802ada577
	   |-- fabric-resource-loader-v0 0.11.12+fb82e9d777
	   |-- fabric-screen-api-v1 2.0.9+1802ada577
	   |-- fabric-screen-handler-api-v1 1.3.32+1802ada577
	   |-- fabric-sound-api-v1 1.0.14+1802ada577
	   |-- fabric-transfer-api-v1 3.3.6+8dd72ea377
	   \-- fabric-transitive-access-wideners-v1 4.3.2+1802ada577
	- fabricloader 0.16.14
	   \-- mixinextras 0.4.1
	- jade 11.12.3+fabric
	- jadeaddons 5.2.6
	- java 24
	- minecraft 1.20.1
[17:35:38] [main/INFO]: SpongePowered MIXIN Subsystem Version=0.8.7 Source=file:/C:/Users/thouzands/Desktop/UltimMC/libraries/net/fabricmc/sponge-mixin/0.15.5+mixin.0.8.7/sponge-mixin-0.15.5+mixin.0.8.7.jar Service=Knot/Fabric Env=CLIENT
[17:35:38] [main/INFO]: Compatibility level set to JAVA_17
[17:35:38] [main/WARN]: Error loading class: io/vram/frex/base/renderer/context/render/EntityBlockRenderContext (java.lang.ClassNotFoundException: io/vram/frex/base/renderer/context/render/EntityBlockRenderContext)
[17:35:38] [main/WARN]: @Mixin target io.vram.frex.base.renderer.context.render.EntityBlockRenderContext was not found porting_lib_base.mixins.json:client.frex.EntityBlockRenderContextMixin from mod porting_lib_base
[17:35:39] [main/INFO]: Initializing MixinExtras via com.llamalad7.mixinextras.service.MixinExtrasServiceImpl(version=0.4.1).
[17:35:43] [Datafixer Bootstrap/INFO]: 188 Datafixer optimizations took 139 milliseconds
[17:35:45] [main/WARN]: Unrecognized user type: local
[17:35:45] [Render thread/INFO]: [STDERR]: [LWJGL] [ThreadLocalUtil] Unsupported JNI version detected, this may result in a crash. Please inform LWJGL developers.
[17:35:45] [Render thread/INFO]: Environment: authHost='http://127.0.0.1:50398/authserver', accountsHost='http://127.0.0.1:53143/https/api.mojang.com', sessionHost='http://127.0.0.1:53143/https/sessionserver.mojang.com', servicesHost='http://127.0.0.1:53143/https/api.minecraftservices.com', name='PROD'
[17:35:45] [Render thread/INFO]: Setting user: thouzands
[17:35:47] [Render thread/INFO]: [Indigo] Registering Indigo renderer!
[17:35:47] [Render thread/INFO]: No shaders mod detected.
[17:35:48] [Render thread/INFO]: Backend library: LWJGL version 3.3.1 SNAPSHOT
[17:35:49] [Render thread/INFO]: Reloading ResourceManager: vanilla, fabric (create, dripstone_fluid_lib, fabric-api, fabric-api-base, fabric-api-lookup-api-v1, fabric-biome-api-v1, fabric-block-api-v1, fabric-block-view-api-v2, fabric-blockrenderlayer-v1, fabric-client-tags-api-v1, fabric-command-api-v1, fabric-command-api-v2, fabric-commands-v0, fabric-containers-v0, fabric-content-registries-v0, fabric-convention-tags-v1, fabric-crash-report-info-v1, fabric-data-attachment-api-v1, fabric-data-generation-api-v1, fabric-dimensions-v1, fabric-entity-events-v1, fabric-events-interaction-v0, fabric-events-lifecycle-v0, fabric-game-rule-api-v1, fabric-item-api-v1, fabric-item-group-api-v1, fabric-key-binding-api-v1, fabric-keybindings-v0, fabric-lifecycle-events-v1, fabric-loot-api-v2, fabric-loot-tables-v1, fabric-message-api-v1, fabric-mining-level-api-v1, fabric-model-loading-api-v1, fabric-models-v0, fabric-networking-api-v1, fabric-networking-v0, fabric-object-builder-api-v1, fabric-particles-v1, fabric-recipe-api-v1, fabric-registry-sync-v0, fabric-renderer-api-v1, fabric-renderer-indigo, fabric-renderer-registries-v1, fabric-rendering-data-attachment-v1, fabric-rendering-fluids-v1, fabric-rendering-v0, fabric-rendering-v1, fabric-resource-conditions-api-v1, fabric-resource-loader-v0, fabric-screen-api-v1, fabric-screen-handler-api-v1, fabric-sound-api-v1, fabric-transfer-api-v1, fabric-transitive-access-wideners-v1, fabricloader, flywheel, forgeconfigapiport, jade, jadeaddons, milk, porting_lib_accessors, porting_lib_attributes, porting_lib_base, porting_lib_brewing, porting_lib_client_events, porting_lib_common, porting_lib_config, porting_lib_core, porting_lib_data, porting_lib_entity, porting_lib_extensions, porting_lib_fluids, porting_lib_gametest, porting_lib_gui_utils, porting_lib_lazy_registration, porting_lib_mixin_extensions, porting_lib_model_generators, porting_lib_model_loader, porting_lib_model_materials, porting_lib_models, porting_lib_networking, porting_lib_obj_loader, porting_lib_tags, porting_lib_tool_actions, porting_lib_transfer, porting_lib_utility, reach-entity-attributes, registrate-fabric)
[17:35:49] [Worker-Main-4/INFO]: Found unifont_all_no_pua-15.0.06.hex, loading
[17:35:49] [Render thread/INFO]: Start loading plugin from Jade
[17:35:49] [Render thread/INFO]: Start loading plugin from Jade
[17:35:49] [Render thread/INFO]: Start loading plugin from Jade
[17:35:49] [Render thread/INFO]: Start loading plugin from Jade Addons
[17:35:49] [Render thread/INFO]: Start loading plugin from Jade Addons
[17:35:49] [Realms Notification Availability checker #1/ERROR]: Realms http code: 400 - raw body (message failed to parse): 
[17:35:51] [Render thread/WARN]: Missing sound for event: minecraft:item.goat_horn.play
[17:35:51] [Render thread/WARN]: Missing sound for event: minecraft:entity.goat.screaming.horn_break
[17:35:51] [Render thread/INFO]: OpenAL initialized on device OpenAL Soft on Headphones (ATH-M20xBT )
[17:35:51] [Render thread/INFO]: Sound engine started
[17:35:51] [Render thread/INFO]: Created: 2048x1024x4 minecraft:textures/atlas/blocks.png-atlas
[17:35:51] [Render thread/INFO]: Created: 256x256x4 minecraft:textures/atlas/signs.png-atlas
[17:35:51] [Render thread/INFO]: Created: 512x512x4 minecraft:textures/atlas/shield_patterns.png-atlas
[17:35:51] [Render thread/INFO]: Created: 512x512x4 minecraft:textures/atlas/banner_patterns.png-atlas
[17:35:51] [Render thread/INFO]: Created: 1024x1024x4 minecraft:textures/atlas/armor_trims.png-atlas
[17:35:51] [Render thread/INFO]: Created: 256x256x4 minecraft:textures/atlas/chest.png-atlas
[17:35:51] [Render thread/INFO]: Created: 128x64x4 minecraft:textures/atlas/decorated_pot.png-atlas
[17:35:51] [Render thread/INFO]: Created: 512x256x4 minecraft:textures/atlas/shulker_boxes.png-atlas
[17:35:51] [Render thread/INFO]: Created: 512x256x4 minecraft:textures/atlas/beds.png-atlas
[17:35:51] [Render thread/WARN]: Shader rendertype_entity_translucent_emissive could not find sampler named Sampler2 in the specified shader program.
[17:35:51] [Render thread/INFO]: Created: 512x256x0 minecraft:textures/atlas/particles.png-atlas
[17:35:51] [Render thread/INFO]: Created: 256x256x0 minecraft:textures/atlas/paintings.png-atlas
[17:35:51] [Render thread/INFO]: Created: 128x128x0 minecraft:textures/atlas/mob_effects.png-atlas
[17:35:51] [Render thread/INFO]: Loaded 51 train hat configurations.
[17:35:52] [Render thread/INFO]: Loaded all shader sources.
[17:35:52] [Realms Notification Availability checker #1/ERROR]: Realms http code: 400 - raw body (message failed to parse): 
[17:35:57] [Render thread/INFO]: Loaded 22 recipes
[17:35:57] [Render thread/INFO]: Loaded 2280 advancements
[17:35:58] [Render thread/INFO]: Applied 111 biome modifications to 58 of 64 new biomes in 7.317 ms
[17:35:58] [Server thread/INFO]: Starting integrated minecraft server version 1.20.1
[17:35:58] [Server thread/INFO]: Generating keypair
[17:35:59] [Server thread/INFO]: Preparing start region for dimension minecraft:overworld
[17:36:00] [Render thread/INFO]: Preparing spawn area: 0%
[17:36:00] [Render thread/INFO]: Preparing spawn area: 0%
[17:36:00] [Render thread/INFO]: Preparing spawn area: 0%
[17:36:00] [Render thread/INFO]: Preparing spawn area: 0%
[17:36:01] [Render thread/INFO]: Preparing spawn area: 0%
[17:36:01] [Render thread/INFO]: Time elapsed: 2481 ms
[17:36:01] [Server thread/INFO]: Changing view distance to 32, from 10
[17:36:01] [Server thread/INFO]: Changing simulation distance to 32, from 0
[17:36:02] [Server thread/INFO]: thouzands[local:E:a8044d2b] logged in with entity id 82 at (660.5359995427918, 189.25086072176535, 25.522869990383466)
[17:36:02] [Server thread/INFO]: Syncing config to thouzands (697a5aed-eb2b-39c3-8f81-25e8c4a9da64)
[17:36:02] [Server thread/INFO]: thouzands joined the game
[17:36:02] [Render thread/INFO]: Started 6 worker threads
[17:36:02] [Render thread/INFO]: Received config from the server: 
[17:36:02] [Render thread/INFO]: Loaded 2 advancements
[17:36:03] [Worker-Main-5/WARN]: Couldnt look up profile properties for com.mojang.authlib.GameProfile@4d6bea2c[id=697a5aed-eb2b-39c3-8f81-25e8c4a9da64,name=thouzands,properties={},legacy=false]
com.mojang.authlib.exceptions.AuthenticationUnavailableException: Cannot contact authentication server
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:119) ~[authlib-4.0.43.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:91) ~[authlib-4.0.43.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService.fillGameProfile(YggdrasilMinecraftSessionService.java:175) ~[authlib-4.0.43.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService$1.load(YggdrasilMinecraftSessionService.java:51) ~[authlib-4.0.43.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService$1.load(YggdrasilMinecraftSessionService.java:48) ~[authlib-4.0.43.jar:?]
	at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3533) ~[guava-31.1-jre.jar:?]
	at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2282) ~[guava-31.1-jre.jar:?]
	at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2159) ~[guava-31.1-jre.jar:?]
	at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2049) ~[guava-31.1-jre.jar:?]
	at com.google.common.cache.LocalCache.get(LocalCache.java:3966) ~[guava-31.1-jre.jar:?]
	at com.google.common.cache.LocalCache.getOrLoad(LocalCache.java:3989) ~[guava-31.1-jre.jar:?]
	at com.google.common.cache.LocalCache$LocalLoadingCache.get(LocalCache.java:4950) ~[guava-31.1-jre.jar:?]
	at com.google.common.cache.LocalCache$LocalLoadingCache.getUnchecked(LocalCache.java:4956) ~[guava-31.1-jre.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilMinecraftSessionService.fillProfileProperties(YggdrasilMinecraftSessionService.java:149) ~[authlib-4.0.43.jar:?]
	at net.minecraft.class_310.method_1539(class_310.java:2507) ~[client-intermediary.jar:?]
	at net.minecraft.class_1071.method_4653(class_1071.java:107) ~[client-intermediary.jar:?]
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.compute(ForkJoinTask.java:1735) ~[?:?]
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.compute(ForkJoinTask.java:1726) ~[?:?]
	at java.util.concurrent.ForkJoinTask$InterruptibleTask.exec(ForkJoinTask.java:1650) ~[?:?]
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:507) ~[?:?]
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1394) ~[?:?]
	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1970) ~[?:?]
	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:187) ~[?:?]
Caused by: com.mojang.authlib.exceptions.MinecraftClientException: Failed to read value Internal Server Error
	at com.mojang.authlib.minecraft.client.ObjectMapper.readValue(ObjectMapper.java:32) ~[authlib-4.0.43.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:97) ~[authlib-4.0.43.jar:?]
	... 22 more
Caused by: com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 1 column 1 path $
	at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:395) ~[gson-2.10.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:1214) ~[gson-2.10.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:1124) ~[gson-2.10.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:1034) ~[gson-2.10.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:969) ~[gson-2.10.jar:?]
	at com.mojang.authlib.minecraft.client.ObjectMapper.readValue(ObjectMapper.java:30) ~[authlib-4.0.43.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:97) ~[authlib-4.0.43.jar:?]
	... 22 more
Caused by: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 1 column 1 path $
	at com.google.gson.stream.JsonReader.beginObject(JsonReader.java:393) ~[gson-2.10.jar:?]
	at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:384) ~[gson-2.10.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:1214) ~[gson-2.10.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:1124) ~[gson-2.10.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:1034) ~[gson-2.10.jar:?]
	at com.google.gson.Gson.fromJson(Gson.java:969) ~[gson-2.10.jar:?]
	at com.mojang.authlib.minecraft.client.ObjectMapper.readValue(ObjectMapper.java:30) ~[authlib-4.0.43.jar:?]
	at com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService.makeRequest(YggdrasilAuthenticationService.java:97) ~[authlib-4.0.43.jar:?]
	... 22 more
[17:36:03] [Render thread/ERROR]: Mixin apply for mod jadeaddons failed jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons -> com.simibubi.create.content.equipment.goggles.GoggleOverlayRenderer: org.spongepowered.asm.mixin.injection.throwables.InvalidInjectionException Invalid descriptor on jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons->@Inject::jadeaddons$renderOverlay(Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V! Expected (Lnet/minecraft/class_332;FIILorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V but found (Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V [INJECT_APPLY Applicator Phase -> jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons -> Apply Injections ->  -> Inject -> jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons->@Inject::jadeaddons$renderOverlay(Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V]
org.spongepowered.asm.mixin.injection.throwables.InvalidInjectionException: Invalid descriptor on jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons->@Inject::jadeaddons$renderOverlay(Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V! Expected (Lnet/minecraft/class_332;FIILorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V but found (Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V [INJECT_APPLY Applicator Phase -> jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons -> Apply Injections ->  -> Inject -> jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons->@Inject::jadeaddons$renderOverlay(Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V]
	at org.spongepowered.asm.mixin.injection.callback.CallbackInjector.inject(CallbackInjector.java:560) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.injection.callback.CallbackInjector.inject(CallbackInjector.java:490) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.injection.code.Injector.inject(Injector.java:284) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.injection.struct.InjectionInfo.inject(InjectionInfo.java:508) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTargetContext.applyInjections(MixinTargetContext.java:1483) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinApplicatorStandard.applyInjections(MixinApplicatorStandard.java:752) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinApplicatorStandard.applyMixin(MixinApplicatorStandard.java:330) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinApplicatorStandard.apply(MixinApplicatorStandard.java:246) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.TargetClassContext.apply(TargetClassContext.java:437) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.TargetClassContext.applyMixins(TargetClassContext.java:418) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinProcessor.applyMixins(MixinProcessor.java:363) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTransformer.transformClass(MixinTransformer.java:234) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTransformer.transformClassBytes(MixinTransformer.java:202) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.getPostMixinClassByteArray(KnotClassDelegate.java:422) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.tryLoadClass(KnotClassDelegate.java:323) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.loadClass(KnotClassDelegate.java:218) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.KnotClassLoader.loadClass(KnotClassLoader.java:119) ~[fabric-loader-0.16.14.jar:?]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:490) ~[?:?]
	at com.simibubi.create.CreateClient.lambda$registerOverlays$4(CreateClient.java:135) ~[create-fabric-0.5.1-j-build.1631+mc1.20.1.jar:?]
	at net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback.lambda$static$0(HudRenderCallback.java:27) ~[fabric-rendering-v1-3.0.9+1802ada577-7eab44822c36f2cf.jar:?]
	at net.minecraft.class_329.handler$bap000$fabric-rendering-v1$render(class_329.java:2386) ~[client-intermediary.jar:?]
	at net.minecraft.class_329.method_1753(class_329.java:370) ~[client-intermediary.jar:?]
	at net.minecraft.class_757.method_3192(class_757.java:926) ~[client-intermediary.jar:?]
	at net.minecraft.class_310.method_1523(class_310.java:1219) ~[client-intermediary.jar:?]
	at net.minecraft.class_310.method_1514(class_310.java:802) ~[client-intermediary.jar:?]
	at net.minecraft.client.main.Main.main(Main.java:250) ~[minecraft-1.20.1-client.jar:?]
	at net.fabricmc.loader.impl.game.minecraft.MinecraftGameProvider.launch(MinecraftGameProvider.java:480) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.Knot.launch(Knot.java:74) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.KnotClient.main(KnotClient.java:23) ~[fabric-loader-0.16.14.jar:?]
	at jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104) ~[?:?]
	at java.lang.reflect.Method.invoke(Method.java:565) ~[?:?]
	at org.multimc.onesix.OneSixLauncher.launchWithMainClass(OneSixLauncher.java:243) ~[NewLaunch.jar:?]
	at org.multimc.onesix.OneSixLauncher.launch(OneSixLauncher.java:278) ~[NewLaunch.jar:?]
	at org.multimc.EntryPoint.listen(EntryPoint.java:143) ~[NewLaunch.jar:?]
	at org.multimc.EntryPoint.main(EntryPoint.java:34) ~[NewLaunch.jar:?]
[17:36:03] [Render thread/ERROR]: Unreported exception thrown!
java.lang.RuntimeException: Mixin transformation of com.simibubi.create.content.equipment.goggles.GoggleOverlayRenderer failed
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.getPostMixinClassByteArray(KnotClassDelegate.java:427) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.tryLoadClass(KnotClassDelegate.java:323) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.loadClass(KnotClassDelegate.java:218) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.KnotClassLoader.loadClass(KnotClassLoader.java:119) ~[fabric-loader-0.16.14.jar:?]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:490) ~[?:?]
	at com.simibubi.create.CreateClient.lambda$registerOverlays$4(CreateClient.java:135) ~[create-fabric-0.5.1-j-build.1631+mc1.20.1.jar:?]
	at net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback.lambda$static$0(HudRenderCallback.java:27) ~[fabric-rendering-v1-3.0.9+1802ada577-7eab44822c36f2cf.jar:?]
	at net.minecraft.class_329.handler$bap000$fabric-rendering-v1$render(class_329.java:2386) ~[client-intermediary.jar:?]
	at net.minecraft.class_329.method_1753(class_329.java:370) ~[client-intermediary.jar:?]
	at net.minecraft.class_757.method_3192(class_757.java:926) ~[client-intermediary.jar:?]
	at net.minecraft.class_310.method_1523(class_310.java:1219) ~[client-intermediary.jar:?]
	at net.minecraft.class_310.method_1514(class_310.java:802) ~[client-intermediary.jar:?]
	at net.minecraft.client.main.Main.main(Main.java:250) ~[minecraft-1.20.1-client.jar:?]
	at net.fabricmc.loader.impl.game.minecraft.MinecraftGameProvider.launch(MinecraftGameProvider.java:480) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.Knot.launch(Knot.java:74) ~[fabric-loader-0.16.14.jar:?]
	at net.fabricmc.loader.impl.launch.knot.KnotClient.main(KnotClient.java:23) ~[fabric-loader-0.16.14.jar:?]
	at jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:104) ~[?:?]
	at java.lang.reflect.Method.invoke(Method.java:565) ~[?:?]
	at org.multimc.onesix.OneSixLauncher.launchWithMainClass(OneSixLauncher.java:243) ~[NewLaunch.jar:?]
	at org.multimc.onesix.OneSixLauncher.launch(OneSixLauncher.java:278) ~[NewLaunch.jar:?]
	at org.multimc.EntryPoint.listen(EntryPoint.java:143) ~[NewLaunch.jar:?]
	at org.multimc.EntryPoint.main(EntryPoint.java:34) ~[NewLaunch.jar:?]
Caused by: org.spongepowered.asm.mixin.transformer.throwables.MixinTransformerError: An unexpected critical error was encountered
	at org.spongepowered.asm.mixin.transformer.MixinProcessor.applyMixins(MixinProcessor.java:392) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTransformer.transformClass(MixinTransformer.java:234) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTransformer.transformClassBytes(MixinTransformer.java:202) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.getPostMixinClassByteArray(KnotClassDelegate.java:422) ~[fabric-loader-0.16.14.jar:?]
	... 21 more
Caused by: org.spongepowered.asm.mixin.throwables.MixinApplyError: Mixin [jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons] from phase [DEFAULT] in config [jadeaddons.mixins.json] FAILED during APPLY
	at org.spongepowered.asm.mixin.transformer.MixinProcessor.handleMixinError(MixinProcessor.java:638) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinProcessor.handleMixinApplyError(MixinProcessor.java:589) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinProcessor.applyMixins(MixinProcessor.java:379) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTransformer.transformClass(MixinTransformer.java:234) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTransformer.transformClassBytes(MixinTransformer.java:202) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.getPostMixinClassByteArray(KnotClassDelegate.java:422) ~[fabric-loader-0.16.14.jar:?]
	... 21 more
Caused by: org.spongepowered.asm.mixin.injection.throwables.InvalidInjectionException: Invalid descriptor on jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons->@Inject::jadeaddons$renderOverlay(Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V! Expected (Lnet/minecraft/class_332;FIILorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V but found (Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V [INJECT_APPLY Applicator Phase -> jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons -> Apply Injections ->  -> Inject -> jadeaddons.mixins.json:create.GoggleOverlayRendererMixin from mod jadeaddons->@Inject::jadeaddons$renderOverlay(Lnet/minecraft/class_332;FLnet/minecraft/class_1041;Lorg/spongepowered/asm/mixin/injection/callback/CallbackInfo;)V]
	at org.spongepowered.asm.mixin.injection.callback.CallbackInjector.inject(CallbackInjector.java:560) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.injection.callback.CallbackInjector.inject(CallbackInjector.java:490) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.injection.code.Injector.inject(Injector.java:284) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.injection.struct.InjectionInfo.inject(InjectionInfo.java:508) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTargetContext.applyInjections(MixinTargetContext.java:1483) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinApplicatorStandard.applyInjections(MixinApplicatorStandard.java:752) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinApplicatorStandard.applyMixin(MixinApplicatorStandard.java:330) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinApplicatorStandard.apply(MixinApplicatorStandard.java:246) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.TargetClassContext.apply(TargetClassContext.java:437) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.TargetClassContext.applyMixins(TargetClassContext.java:418) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinProcessor.applyMixins(MixinProcessor.java:363) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTransformer.transformClass(MixinTransformer.java:234) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at org.spongepowered.asm.mixin.transformer.MixinTransformer.transformClassBytes(MixinTransformer.java:202) ~[sponge-mixin-0.15.5+mixin.0.8.7.jar:0.15.5+mixin.0.8.7]
	at net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.getPostMixinClassByteArray(KnotClassDelegate.java:422) ~[fabric-loader-0.16.14.jar:?]
	... 21 more
[17:36:03] [Server thread/INFO]: Stopping server
[17:36:03] [Server thread/INFO]: Saving players
[17:36:03] [Server thread/INFO]: Saving worlds
[17:36:04] [Server thread/INFO]: Saving chunks for level 'ServerLevel[New World]'/minecraft:overworld
[17:36:04] [Server thread/INFO]: Saving chunks for level 'ServerLevel[New World]'/minecraft:the_nether
[17:36:04] [Server thread/INFO]: Saving chunks for level 'ServerLevel[New World]'/minecraft:the_end
[17:36:04] [Server thread/INFO]: ThreadedAnvilChunkStorage (New World): All chunks are saved
[17:36:04] [Server thread/INFO]: ThreadedAnvilChunkStorage (DIM-1): All chunks are saved
[17:36:04] [Server thread/INFO]: ThreadedAnvilChunkStorage (DIM1): All chunks are saved
[17:36:04] [Server thread/INFO]: ThreadedAnvilChunkStorage: All dimensions are saved
"
X3bjFd2F,Q1,tensedtorch,Python,Sunday 18th of May 2025 05:36:13 PM CDT,"def findMinimumMachinesSize(machineCapacity: list[int]) -> int:
    n = len(machineCapacity)

    if n == 0:
        return 0
    if n == 1:
        return 1

    deduplicated_list = [machineCapacity[0]]
    for i in range(1, n):
        if machineCapacity[i] != deduplicated_list[-1]:
            deduplicated_list.append(machineCapacity[i])

    len_dl = len(deduplicated_list)

    if len_dl <= 2:
        return len_dl

    final_list = [deduplicated_list[0]]
    for i in range(1, len_dl - 1):
        prev_kept_val = final_list[-1]
        current_val = deduplicated_list[i]
        next_potential_val = deduplicated_list[i+1]

        is_collinear = False
        if (prev_kept_val <= current_val <= next_potential_val) or \
           (prev_kept_val >= current_val >= next_potential_val):
            is_collinear = True
        
        if not is_collinear:
            final_list.append(current_val)

    final_list.append(deduplicated_list[-1])
    
    return len(final_list)"
F5ghrSpQ,Super Ring,OFAS32_IL_IL,Lua,Sunday 18th of May 2025 05:34:48 PM CDT,"local Fluent = loadstring(game:HttpGet(""https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua""))()
local SaveManager = loadstring(game:HttpGet(""https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua""))()
local InterfaceManager = loadstring(game:HttpGet(""https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua""))()

local Window = Fluent:CreateWindow({
    Title = ""yurnyxs "" .. Fluent.Version,
    SubTitle = ""by yurnyxs"",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true, 
    Theme = ""Dark"",
    MinimizeKey = Enum.KeyCode.M
})

local Tabs = {
    Main = Window:AddTab({ Title = ""Main"", Icon = """" }),
    Settings = Window:AddTab({ Title = ""Settings"", Icon = ""settings"" })
}

local Options = Fluent.Options

-- เริ่มเขียนระบบหลัก
do
    local Players = game:GetService(""Players"")
    local RunService = game:GetService(""RunService"")

    local LocalPlayer = Players.LocalPlayer

    local rotationSpeed = 200
    local radius = 100

    local SETTINGS = {
        height = 20,
        attractionStrength = 500,
        updateInterval = 0.05,
        safeDistance = 5
    }

    local function IsValidPart(part)
        return part:IsA(""BasePart"")
            and not part.Anchored
            and not part:IsDescendantOf(LocalPlayer.Character)
    end

    local function TornadoEffect()
        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") then return end

        local humanoidRootPart = LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"")
        local tornadoCenter = humanoidRootPart.Position

        local parts = {}
        for _, part in ipairs(workspace:GetDescendants()) do
            if IsValidPart(part) then
                table.insert(parts, part)
            end
        end

        for _, part in ipairs(parts) do
            if part.Parent then
                local pos = part.Position
                local flatOffset = Vector3.new(pos.X, tornadoCenter.Y, pos.Z)
                local distance = (flatOffset - tornadoCenter).Magnitude
                local minDist = math.max(distance, SETTINGS.safeDistance)

                local angle = math.atan2(pos.Z - tornadoCenter.Z, pos.X - tornadoCenter.X)
                local newAngle = angle + math.rad(rotationSpeed) * SETTINGS.updateInterval

local targetPos = Vector3.new(
	tornadoCenter.X + math.cos(newAngle) * radius,
	tornadoCenter.Y + (SETTINGS.height * math.abs(math.sin((pos.Y - tornadoCenter.Y) / SETTINGS.height))),
	tornadoCenter.Z + math.sin(newAngle) * radius
)
                local directionToTarget = (targetPos - part.Position).Unit
                part.Velocity = directionToTarget * SETTINGS.attractionStrength
            end
        end
    end

    local TornadoRunning = false
    local TornadoThread = nil

    local Toggle = Tabs.Main:AddToggle(""MyToggle"", { Title = ""Tornado"", Default = false })

    Toggle:OnChanged(function(Value)
        if Value then
            TornadoRunning = true
            TornadoThread = task.spawn(function()
                while TornadoRunning do
                    pcall(TornadoEffect)
                    task.wait(SETTINGS.updateInterval)
                end
            end)
        else
            TornadoRunning = false
        end
    end)

    Options.MyToggle:SetValue(false)

    local Slider1 = Tabs.Main:AddSlider(""Slider1"", {
        Title = ""RotationSpeed"",
        Description = ""ความเร็วในการหมุน"",
        Default = 200,
        Min = 0,
        Max = 900,
        Rounding = 1,
        Callback = function(Value)
            rotationSpeed = tonumber(Value)
        end
    })

    Slider1:SetValue(rotationSpeed)

    local Slider2 = Tabs.Main:AddSlider(""Slider2"", {
        Title = ""Radius"",
        Description = ""รัศมีของพายุ"",
        Default = 100,
        Min = 0,
        Max = 900,
        Rounding = 0,
        Callback = function(Value)
            radius = tonumber(Value)
        end
    })

    Slider2:SetValue(radius)
end


SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder(""FluentScriptHub"")
SaveManager:SetFolder(""FluentScriptHub/specific-game"")
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
Window:SelectTab(1)
SaveManager:LoadAutoloadConfig()
"
Qk4mZ7JA,Untitled,15kilovolt,JavaScript,Sunday 18th of May 2025 05:22:48 PM CDT,"/* global Log Module */

/* MagicMirror²
 * Module: MMM-DBF
 *
 * By Marc Helpenstein <helpi9007@gmail.com>
 * MIT Licensed.
 */

Module.register(""MMM-DBF"", {
  defaults: {
    updateInterval: 60000, // 1 minute
    retryDelay: 30000, // 30 seconds
    station: ""Düsseldorf Hbf"",
    platform: """",
    via: """",
    showApp: false,
    showArrivalTime: false,
    showRealTime: false,
    onlyArrivalTime: false,
    onlyDepartureTime: true,
    numberOfResults: 10,
    hideLowDelay: false,
    withoutDestination: """",
    onlyDestination: """",
    train: """",
    height: ""600px"",
    width: ""400px"",
    setTableWidth: """",
    timeOption: ""time"", // time+countdown or countdown
    showDelayMsg: false,
  },

  requiresVersion: ""2.1.0"",

  /**
   * @description Helper function to generate API url
   *
   * @returns {String} url
   */
  generateUrl() {
    this.sendNotification(""GENERATING_URL"", { message: '[MMM-DBF] Generating URL from dbf.finalrewind.org ...'});
    let baseUrl = ""https://dbf.finalrewind.org/"";
    baseUrl += `${this.config.station}?&hide_opts=1`
    // All optional parameters follow here
    if (this.config.platform) {
      baseUrl += `&platforms=${this.config.platform}`;
    }
    if (this.config.via) {
      baseUrl += `&via=${this.config.via}`;
    }
    if (this.config.showArrivalTime) {
      baseUrl += ""&detailed=1"";
    }
    if (this.config.showRealTime) {
      baseUrl += ""&show_realtime=1"";
    }
    if (this.config.onlyArrivalTime) {
      baseUrl += ""&admode=arr"";
    }
    else if (this.config.onlyDepartureTime) {
      baseUrl += ""&admode=dep"";
    }
    if (this.config.hideLowDelay) {
      baseUrl += ""&hidelowdelay=1"";
    }
    return baseUrl;
  },

  /**
   * @description Calls updateIterval
   */
  start() {
    // Flag for check if module is loaded
    this.loaded = false;
    // Schedule update timer.
    this.getData();
    // Show that the module is running by issuing a notification
    this.sendNotification(""MODULE_LOADED"", { message: '[MMM-DBF] Module loaded.'});
  },

  /**
   * @description Gets data from dbf.finalrewind.org
   */
  async getData() {
    const self = this;
    const urlApi = `${this.generateUrl()}&mode=json&version=3`;
    const dataRequest = await fetch(urlApi);

    if (!dataRequest.ok) {
      // Show that the data request has an error
      this.sendNotification(""ERROR_DATA_REQUEST_NOT_OK"", { message: '[MMM-DBF] Data request is not okay.'});
      let message = `An error has occurred: ${dataRequest.status}`;
      if (dataRequest.status === 300) {
        message += "" - Ambiguous station name."";
      }
      throw new Error(message);
    }
    else {
      const data = await dataRequest.json();
      // Show that the data request is being processed
      this.sendNotification(""START_PROCESSING_DATA"", { message: '[MMM-DBF] Data processing started.'});
      self.processData(data);
    }
    self.scheduleUpdate(self.config.retryDelay);
  },

  /**
   * @description Schedule next update.
   * @param {int} delay - Milliseconds before next update.
   */
  scheduleUpdate(delay) {
    const self = this;
    let nextLoad = this.config.updateInterval;
    if (typeof delay !== ""undefined"" && delay >= 0) {
      nextLoad = delay;
    }
    setTimeout(() => {
      self.getData();
    }, nextLoad);

    if (!this.config.showApp) {
      // Show that the module is updating its content
      this.sendNotification(""UPDATING_DOM"", { message: '[MMM-DBF] DOM is being updated.'});
      this.updateDom();
    }
  },

  /**
   * @description Create App Frame or HTML table
   *
   * @returns {HTMLIframeElement}
   */
  getDom() {
    // Show that the module is updating its content
    this.sendNotification(""CREATING_DOM"", { message: '[MMM-DBF] DOM is being created.'});
    if (this.config.showApp) {
      // Show that the module is updating its content
    this.sendNotification(""CREATING_IFRAME"", { message: '[MMM-DBF] DOM is being created.'});
      const iframe = document.createElement(""IFRAME"");
      iframe.style = ""border:0"";
      iframe.width = this.config.width;
      iframe.height = this.config.height;
      iframe.src = this.generateUrl();
      // Show that the module has set up the iFrame
      this.sendNotification(""IFRAME_AND_URL_GENERATED"", { message: '[MMM-DBF] URL for iFrame successfully generated.'});
      return iframe;
    }
    // Show that the module is updating its content
    this.sendNotification(""CREATING_TABLE"", { message: '[MMM-DBF] Table in DOM is being created.'});
    const tableWrapper = document.createElement(""table"");
    this.sendNotification(""EMPTY_TABLE_CREATED"", { message: '[MMM-DBF] Empty table in DOM successfully created.'});
    tableWrapper.className = ""small mmm-dbf-table"";
    this.sendNotification(""CLASS_NAME_DEFINED"", { message: '[MMM-DBF] Class name ""small mmm-dbf-table"" successfully defined.'});
    if (this.dataRequest) {
      // The data request seems valid
      this.sendNotification(""DATA_REQUEST_AVAILABLE"", { message: '[MMM-DBF] The data request is available!'});
      if (!this.dataRequest.error) {
        // The data request does not have an error
        this.sendNotification(""DATA_REQUEST_VALID"", { message: '[MMM-DBF] The data request seems valid!'});
        if (this.config.setTableWidth) {
          // Set custom table width
          this.sendNotification(""SET_CUSTOM_TABLE_WIDTH"", { message: '[MMM-DBF] A custom table width shall be set!'});
          tableWrapper.style.width = this.config.setTableWidth;
          this.sendNotification(""CUSTOM_TABLE_WIDTH_SET"", { message: '[MMM-DBF] A custom table width was set!'});
        }
        const { departures } = this.dataRequest;
        this.sendNotification(""DEPARTURES_READ"", { message: '[MMM-DBF] Departures were successfully read out!'});
        const tableHead = this.createTableHeader(departures);
        tableWrapper.appendChild(tableHead);
        this.createTableContent(departures, tableWrapper);
        // Table content successfully generated
        this.sendNotification(""TABLE_CONTENT_GENERATED"", { message: '[MMM-DBF] Table content successfully generated.'});
      }
      else {
        // An error occurred which is being logged
        this.sendNotification(""DATA_REQUEST_ERROR_LOGGED"", { message: '[MMM-DBF] Error while performing data request was logged.'});
        Log.error(this.dataRequest.error);
      }
    }
    else {
      // The data request is empty somehow
      this.sendNotification(""DATA_REQUEST_EMPTY"", { message: '[MMM-DBF] The data request is empty!'});
    }
    return tableWrapper;
  },

  /**
   * @description Get the size for showing entrys
   * @param {Object[]} departures
   */
  getSize(departures) {
    if (departures.length < this.config.numberOfResults) {
      return departures.length;
    }
    return this.config.numberOfResults;
  },

  /**
   * @description Check delay exist
   * @param {Object[]} departures
   */
  checkDelayExist: function (departures) {
    for (let index = 0; index < this.getSize(departures); index++) {
      if (departures[index].delayDeparture) {
        if (this.config.hideLowDelay && departures[index].delayDeparture >= 5) {
          return true;
        }
        if (!this.config.hideLowDelay) {
          return true;
        }
      }
    }
    return false;
  },

  /**
   * @description Get col number
   */
  getColDelay() {
    if (this.config.via !== """") {
      return 5;
    }
    return 4;
  },

  /**
   * @param {Object} train
   */
  getViaFromRoute(train) {
    const viaConfigList = this.config.via.split("","");
    const route = train.via;
    for (let i = 0; i < route.length; i += 1) {
      const city = route[i];
      for (let j = 0; j < viaConfigList.length; j += 1) {
        if (city.includes(viaConfigList[j])) {
          return viaConfigList[j];
        }
      }
    }
    return false;
  },

  /**
   * @description Check if destination is in list config.withoutDestination
   * @param {Object} train
   */
  checkDestination(train, destinationConfig) {
    const destinations = destinationConfig.split("","");
    for (let index = 0; index < destinations.length; index += 1) {
      if (train.destination === destinations[index]) {
        return true;
      }
    }
    return false;
  },

  /**
   * @description Check if train is in list config.train
   * @param {Object} train
   */
  checkTrain(train) {
    const trains = this.config.train.split("","");
    const trainName = train.train.split("" "")[0] + train.train.split("" "")[1];
    for (let i = 0; i < trains.length; i += 1) {
      if (trainName.includes(trains[i])) {
        return true;
      }
    }
    return false;
  },

  /**
   * @description Checks time and return day/hour/mins
   * @param {int} time - Remaining time
   */
  convertTime(scheduledTime) {
    const time = this.calculateTime(scheduledTime);
    if (time >= 3600) {
      const strTime = Math.floor(time / 3600).toString();
      return `+${strTime} ${this.translate(""HOUR"")}`;
    }
    if (time >= 60) {
      const strTime = Math.floor(time / 60).toString();
      return `${strTime} ${this.translate(""MINUTE"")}`;
    }
    return this.translate(""NOW"");
  },

  /**
   * @description Calculate remaining time
   * @param {int:int} scheduledTime
   */
  calculateTime(scheduledTime) {
    const d = new Date();
    const time = scheduledTime.split("":"");
    const dateTrain = new Date(
      d.getFullYear(),
      d.getMonth(),
      d.getDate(),
      time[0],
      time[1],
    );
    const newStamp = new Date().getTime();
    return Math.round((dateTrain.getTime() - newStamp) / 1000);
  },

  /**
   * @description Check msg exists
   * @param {Object[]} departures
   */
  checkMsgExist(departures) {
    for (let index = 0; index < this.getSize(departures); index += 1) {
      if (
        departures[index] !== undefined
        && departures[index].messages.delay.length > 0
      ) {
        return true;
      }
    }
    return false;
  },

  /**
   * @description Creates the header for the Table
   */
  createTableHeader(departures) {
    const tableHead = document.createElement(""tr"");
    tableHead.className = ""border-bottom"";

    const tableHeadValues = [
      this.translate(""TRAIN""),
      this.translate(""TRACK""),
      this.translate(""DESTINATION""),
    ];

    if (this.config.via !== """") {
      tableHeadValues.push(this.translate(""VIA""));
    }
    if (!this.config.onlyArrivalTime) {
      tableHeadValues.push(this.translate(""DEPARTURE""));
    }
    else {
      tableHeadValues.push(this.translate(""ARRIVAL""));
    }

    if (
      this.checkDelayExist(departures)
      || this.checkCancelledExist(departures)
    ) {
      const delayClockIcon = ""<i class=\""fa fa-clock-o\""></i>"";
      tableHeadValues.push(delayClockIcon);
    }

    if (this.config.showDelayMsg && this.checkMsgExist(departures)) {
      tableHeadValues.push(this.translate(""DELAYMSG""));
    }

    for (
      let thCounter = 0;
      thCounter < tableHeadValues.length;
      thCounter += 1
    ) {
      const tableHeadSetup = document.createElement(""th"");
      if (thCounter === 5) {
        tableHeadSetup.style.textAlign = ""Left"";
      }
      tableHeadSetup.innerHTML = tableHeadValues[thCounter];
      tableHead.appendChild(tableHeadSetup);
    }
    return tableHead;
  },

  /**
   * @param usableResults
   * @param tableWrapper
   * @returns {HTMLTableRowElement}
   */
  createTableContent(departures, tableWrapper) {
    // Show the generation of the content has started
    this.sendNotification(""GENERATING_TABLE_CONTENT"", { message: '[MMM-DBF] Table content is being generated.'});
    let size = this.getSize(departures);
    let departureCount = 0;
    for (let index = 0; index < size; index += 1) {
      const obj = departures[index];
      const trWrapper = document.createElement(""tr"");
      trWrapper.className = obj.isCancelled ? ""tr cancelled"" : ""tr"";
      this.checkMsgExist(obj);

      // Check train
      if (this.config.train !== """" && !this.checkTrain(obj)) {
        if (size + 1 <= departures.length) {
          size += 1;
        }
      }
      else if (
        this.config.withoutDestination !== """"
        && this.checkDestination(obj, this.config.withoutDestination)
      ) {
        if (size + 1 <= departures.length) {
          size += 1;
        }
      }
      else if (
        this.config.onlyDestination !== """"
        && !this.checkDestination(obj, this.config.onlyDestination)
      ) {
        if (size + 1 <= departures.length) {
          size += 1;
        }
      }
      else {
        const tdValues = [obj.train, obj.platform, obj.destination];
        if (this.config.via !== """") {
          const via = this.getViaFromRoute(obj);
          if (via === false) {
            tdValues.push("""");
          }
          else {
            tdValues.push(this.getViaFromRoute(obj));
          }
        }

        let time;
        if (this.config.onlyArrivalTime) {
          time = obj.scheduledArrival;
        }
        else {
          time = obj.scheduledDeparture;
        }

        const remainingTime = this.convertTime(time);
        switch (this.config.timeOption) {
          case ""time+countdown"":
            tdValues.push(`${time} (${remainingTime})`);
            break;
          case ""countdown"":
            tdValues.push(remainingTime);
            break;
          default:
            tdValues.push(time);
            break;
        }

        if (
          this.checkDelayExist(departures)
          || this.checkCancelledExist(departures)
        ) {
          if (obj.delayDeparture > 0 && !this.config.hideLowDelay) {
            let delay = "" +"" + obj.delayDeparture;
            tdValues.push(delay);
          }
          else if (obj.delayDeparture >= 5) {
            let delay = "" +"" + obj.delayDeparture;
            tdValues.push(delay);
          }
          else if (obj.isCancelled > 0) {
            tdValues.push(this.translate(""CANCELMSG""));
          }
        }

        if (
          this.config.showDelayMsg
          && this.checkMsgExist(departures)
          && obj.delayDeparture > 0
        ) {
          if (obj.messages.delay.length > 0) {
            tdValues.push(obj.messages.delay[0].text);
          }
        }

        departureCount += 1;
        for (let c = 0; c < tdValues.length; c += 1) {
          const tdWrapper = document.createElement(""td"");
          tdWrapper.innerHTML = tdValues[c];

          if (c === this.getColDelay()) {
            tdWrapper.className = ""delay"";
          }
          if (c === this.getColDelay() + 1) {
            tdWrapper.className = ""delay"";
            tdWrapper.style.width = ""200px"";
            tdWrapper.style.textAlign = ""Left"";
            // tdWrapper.innerHTML = '<marquee scrollamount=""3"" >' + tdValues[c] + '<marquee>';
          }
          trWrapper.appendChild(tdWrapper);
        }
        tableWrapper.appendChild(trWrapper);
      }
    }

    if (departureCount === 0) {
      const trWrapper = document.createElement(""tr"");
      trWrapper.className = ""tr"";
      const tdWrapper = document.createElement(""td"");

      if (this.config.onlyDestination !== """" && this.config.train !== """") {
        tdWrapper.innerHTML = ""Destination or train not found"";
        Log.error(""Destination or train not found"");
      }
      else if (this.config.onlyDestination !== """") {
        tdWrapper.innerHTML = ""Destination not found"";
        Log.error(""Destination not found"");
      }
      else if (this.config.train !== """") {
        tdWrapper.innerHTML = ""Train not found"";
        Log.error(""Train not found"");
      }

      trWrapper.appendChild(tdWrapper);
      tableWrapper.appendChild(trWrapper);
    }
  },

  /**
   * @description Define required styles.
   * @returns {[string,string]}
   */
  getStyles() {
    return [""MMM-DBF.css"", ""font-awesome.css""];
  },

  /**
   * @description Load translations files
   * @returns {{en: string, de: string}}
   */
  getTranslations() {
    return {
      en: ""translations/en.json"",
      de: ""translations/de.json"",
    };
  },
  /**
   * @description Update data and send notification to node_helper
   * @param {*} data
   */
  processData(data) {
    // Show that data are being processed
    this.sendNotification(""PROCESSING_DATA"", { message: '[MMM-DBF] Data are being processed.'});
    this.dataRequest = data;

    if (this.loaded === false) {
      this.sendNotification(""UPDATE_CONFIG_ANIMATION_SPEED"", { message: '[MMM-DBF] Config animation speed is being updated.'});
      this.updateDom(this.config.animationSpeed);
    }
    this.loaded = true;
  },
});
"
DEsh0D2J,Test Mon,MagmaLP,Lua,Sunday 18th of May 2025 04:22:30 PM CDT,"-- === MONITOR Setup ===
local mon = peripheral.wrap(""left"")
mon.clear()
mon.setTextScale(1)
local width, height = mon.getSize()

local x, y = 1, 1
local cursorVisible = true
local timerID = os.startTimer(0.5)
local textColor = colors.white
local bgColor = colors.black

-- === TASTATURMAPPING ===
local keyMap = {
  [16] = ""q"", [17] = ""w"", [18] = ""e"", [19] = ""r"", [20] = ""t"",
  [21] = ""y"", [22] = ""u"", [23] = ""i"", [24] = ""o"", [25] = ""p"",
  [30] = ""a"", [31] = ""s"", [32] = ""d"", [33] = ""f"", [34] = ""g"",
  [35] = ""h"", [36] = ""j"", [37] = ""k"", [38] = ""l"",
  [44] = ""z"", [45] = ""x"", [46] = ""c"", [47] = ""v"", [48] = ""b"",
  [49] = ""n"", [50] = ""m"",
  [57] = "" ""
}

-- === HILFSFUNKTIONEN ===
local function clamp(val, min, max)
  return math.max(min, math.min(max, val))
end

-- === CURSOR ZEICHNEN ===
local function drawCursor()
  mon.setCursorPos(x, y)
  if cursorVisible then
    mon.setTextColor(textColor)
    mon.setBackgroundColor(bgColor)
    mon.write(""_"")
  else
    mon.setTextColor(textColor)
    mon.setBackgroundColor(colors.black)
    mon.write("" "")
  end
  mon.setCursorPos(x, y)
end

-- === TERMINAL-FARBAUSWAHL ZEICHNEN ===
local colorList = {
  [0]=colors.black, [1]=colors.red, [2]=colors.green, [3]=colors.brown,
  [4]=colors.blue, [5]=colors.purple, [6]=colors.cyan, [7]=colors.lightGray,
  [8]=colors.gray, [9]=colors.pink, [10]=colors.lime, [11]=colors.yellow,
  [12]=colors.lightBlue, [13]=colors.magenta, [14]=colors.orange, [15]=colors.white
}

local function drawColorBars()
  term.clear()
  term.setCursorPos(1,1)
  print(""Textfarbe wählen (oben) | Hintergrund (unten)"")
  for i = 0, 15 do
    term.setCursorPos(i+1, 2)
    term.setBackgroundColor(colorList[i])
    term.write("" "")
  end
  for i = 0, 15 do
    term.setCursorPos(i+1, 3)
    term.setBackgroundColor(colorList[i])
    term.write("" "")
  end
  term.setBackgroundColor(colors.black)
  term.setTextColor(colors.white)
  term.setCursorPos(1, 5)
  print(""Klicke unten zum Starten des Schreibmodus"")
end

drawColorBars()

-- === TERMINAL-FARBWAHL-LOGIK ===
while true do
  local event, button, cx, cy = os.pullEvent(""mouse_click"")
  if cy == 2 and cx >= 1 and cx <= 16 then
    textColor = colorList[cx - 1]
    term.setCursorPos(1, 4)
    term.setTextColor(textColor)
    print(""Textfarbe gesetzt."")
  elseif cy == 3 and cx >= 1 and cx <= 16 then
    bgColor = colorList[cx - 1]
    term.setCursorPos(1, 4)
    term.setBackgroundColor(bgColor)
    term.setTextColor(textColor)
    print(""Hintergrundfarbe gesetzt."")
  elseif cy >= 5 then
    break
  end
end

term.setTextColor(colors.white)
term.setBackgroundColor(colors.black)
term.clear()
term.setCursorPos(1,1)
print(""Schreibmodus auf Monitor gestartet. ENTER beendet."")

-- === MONITOR-SCHREIBMODUS ===
mon.clear()
drawCursor()

while true do
  local event, param = os.pullEvent()

  if event == ""key"" then
    local key = param
    if key == keys.enter then
      break
    end

    cursorVisible = false
    drawCursor()

    if key == keys.left then
      x = clamp(x - 1, 1, width)
    elseif key == keys.right then
      x = clamp(x + 1, 1, width)
    elseif key == keys.up then
      y = clamp(y - 1, 1, height)
    elseif key == keys.down then
      y = clamp(y + 1, 1, height)
    else
      local char = keyMap[key]
      if char then
        mon.setCursorPos(x, y)
        mon.setTextColor(textColor)
        mon.setBackgroundColor(bgColor)
        mon.write(char)
        -- Hintergrund wieder zurücksetzen auf Schwarz
        mon.setBackgroundColor(colors.black)
        x = clamp(x + 1, 1, width)
      end
    end

    cursorVisible = true
    drawCursor()

  elseif event == ""timer"" and param == timerID then
    cursorVisible = not cursorVisible
    drawCursor()
    timerID = os.startTimer(0.5)
  end
end

-- ENDE
cursorVisible = false
drawCursor()
mon.setCursorPos(1, height)
mon.setTextColor(colors.white)
mon.setBackgroundColor(colors.black)
mon.write("" Programm beendet "")
"
YdRwf3Am,tracker.lua,Maro919,Lua,Sunday 18th of May 2025 03:53:55 PM CDT,"CHANNEL_TRACKER = 65531

local modem = peripheral.find(""modem"")

modem.open(CHANNEL_TRACKER)

while true do
    local event, side, channel, replyChannel, message, distance = os.pullEvent(""modem_message"")
    if type(message) == ""table"" and message.dimmension and message.position then
        print(textutils.serialise(message))
    end
end
"
Ujj4cFEt,snap.lua,Maro919,Lua,Sunday 18th of May 2025 03:53:06 PM CDT,"if not arg[1] then
    error(""File not found."",2)
end
local file = io.open(arg[1], ""r"")
local map = textutils.unserialise(file:read(""*a""))
file:close()

rednet.open(""back"")

print(""Welcome to snap."")
print(""To add new intersection stand in the middle and type name or leave blank and press enter."")
print(""After adding new intersection you can add connections by typing index numbers of intersections to connect to. To leave connection mode type -1."")
print(""To save and quit type \"":q\""."")
print(""If you wish to abort saving just terminate the program."")

while true do
    local name
    local conn
    local x, z
    
    write(""Name: "")
    name = read()
    x, _, z = gps.locate(2)
    if name == "":q"" or x == nil then
        break
    elseif name == """" then
        name = nil
    end
    
    map.intersections[#map.intersections+1] = {x = x, y = z, name = name}
    print(""Index: ""..#map.intersections)
    while true do
        write(""Connection: "")
        conn = tonumber(read())
        if conn == -1 then
            break
        end
        map.connections[#map.connections+1] = {#map.intersections, conn}
    end
end
file = io.open(arg[1],""w"")
file:write(textutils.serialise(map))
file:close()
"
WcbH2k1a,Iran deal simulation v0.1,ehsankhoddam,Python,Sunday 18th of May 2025 03:42:56 PM CDT,"import pyro
import pyro.distributions as dist
import torch

# =========================
# --- CONFIGURATION ------
# =========================

AGENT_NAMES = [
    'Trump', 'Khamenei', 'IRGC', 'Israel', 'MAGA', 'Neocons',
    'China', 'Russia', 'EU'
]

AGENT_INIT = {
    'intent':    {'mean': 0.5, 'std': 0.15},
    'capability':{'mean': 0.7, 'std': 0.1},
    'risk_tolerance':{'mean': 0.5, 'std': 0.13},
    'ideology':  {'mean': 0.6, 'std': 0.15}
}

INFLUENCE_NETWORK = {
    'Trump': [('Trump', 'w_trump_self'), ('MAGA', 'w_trump_maga'), ('Neocons', 'w_trump_neocons')],
    'Khamenei': [('Khamenei', 'w_khamenei_self'), ('IRGC', 'w_khamenei_irgc')],
    'Israel': [('Israel', 'w_israel_self')],
    'IRGC': [('IRGC', 'w_irgc_self')],
    'MAGA': [('MAGA', 'w_maga_self')],
    'Neocons': [('Neocons', 'w_neocons_self')],
    'China': [('China', 'w_china_self')],
    'Russia': [('Russia', 'w_russia_self')],
    'EU': [('EU', 'w_eu_self')]
}

INFLUENCE_WEIGHTS = {
    'w_trump_self': 0.6, 'w_trump_maga': 0.25, 'w_trump_neocons': 0.15,
    'w_khamenei_self': 0.7, 'w_khamenei_irgc': 0.3,
    'w_israel_self': 1.0,
    'w_irgc_self': 1.0,
    'w_maga_self': 1.0,
    'w_neocons_self': 1.0,
    'w_china_self': 1.0,
    'w_russia_self': 1.0,
    'w_eu_self': 1.0
}

WORLD_INIT = {
    'oil_price': {'mean': 85, 'std': 5},
    'geopolitical_tension': {'a': 2, 'b': 5},
    'global_sentiment': {'mean': 0, 'std': 1},
    'regional_conflict': [0.6, 0.3, 0.1],
    'supply_chain_disruption': 0.2,
    'inflation': {'mean': 5, 'std': 1},
    'gdp_iran': {'mean': 400, 'std': 80},
    'defence_budget_iran': {'mean': 20, 'std': 4},
    'currency_iran': {'mean': 500000, 'std': 50000}
}

EVENT_PARAMS = {
    'us_bombed_nuclear_sites':    {'weights': [2.2, 1.5, 1.0, 1.0, 1.4]},
    'israel_bombed_nuclear_sites':{'weights': [2.3, 1.2, 1.3]},
    'khamenei_assassinated':      {'weights': [1.5, 1.3, 1.2]},
    'nuclear_deal_signed':        {'weights': [1.0, 1.0, 1.0, 1.0]},
    'snapback_activated':         {'weights': [1.3, 0.9, 0.9, 0.6, 0.6]},
    'iran_covert_disrupt_region': {'weights': [1.8, 1.2, 1.1]},
    'iran_covert_terrorist_attack_on_west': {'weights': [1.6, 1.1, 1.1]},
    'sanctions_imposed':          {'weights': [1.2, 1.2, 1.0, 0.6]},
    'oil_supply_disrupted':       {'weights': [1.3, 0.9, 1.1, 0.8]},
    'major_protest':              {'weights': [1.0, 1.0, 0.7, 0.7]},
}

def sigmoid_weighted_sum(weights, variables):
    z = sum(w * v for w, v in zip(weights, variables))
    return torch.sigmoid(torch.tensor(z))

def agent_weighted_intent(agent, agent_vars, t, weights):
    total = 0.0
    infl_list = INFLUENCE_NETWORK[agent]
    for infl, weight_name in infl_list:
        w = weights[weight_name]
        total += w * agent_vars[infl][f""intent_{infl}_{t}""]
    return total

def model(T=8):
    oil_price = pyro.sample(""oil_price_0"", dist.Normal(WORLD_INIT['oil_price']['mean'], WORLD_INIT['oil_price']['std']))
    tension = pyro.sample(""geopolitical_tension_0"", dist.Beta(WORLD_INIT['geopolitical_tension']['a'], WORLD_INIT['geopolitical_tension']['b']))
    global_sentiment = pyro.sample(""global_sentiment_0"", dist.Normal(WORLD_INIT['global_sentiment']['mean'], WORLD_INIT['global_sentiment']['std']))
    regional_conflict = pyro.sample(""regional_conflict_0"", dist.Categorical(torch.tensor(WORLD_INIT['regional_conflict'])))
    supply_chain = pyro.sample(""supply_chain_disruption_0"", dist.Bernoulli(WORLD_INIT['supply_chain_disruption']))
    inflation = pyro.sample(""inflation_0"", dist.Normal(WORLD_INIT['inflation']['mean'], WORLD_INIT['inflation']['std']))
    gdp_iran = pyro.sample(""gdp_iran_0"", dist.Normal(WORLD_INIT['gdp_iran']['mean'], WORLD_INIT['gdp_iran']['std']))
    defence_budget_iran = pyro.sample(""defence_budget_iran_0"", dist.Normal(WORLD_INIT['defence_budget_iran']['mean'], WORLD_INIT['defence_budget_iran']['std']))
    currency_iran = pyro.sample(""currency_iran_0"", dist.Normal(WORLD_INIT['currency_iran']['mean'], WORLD_INIT['currency_iran']['std']))

    agent_vars = {}
    for agent in AGENT_NAMES:
        agent_vars[agent] = {}
        for var in AGENT_INIT:
            agent_vars[agent][f""{var}_{agent}_0""] = pyro.sample(f""{var}_{agent}_0"", dist.Normal(AGENT_INIT[var]['mean'], AGENT_INIT[var]['std']).to_event(0))

    for t in range(1, T+1):
        for agent in AGENT_NAMES:
            for var in AGENT_INIT:
                prev_val = agent_vars[agent][f""{var}_{agent}_{t-1}""]
                agent_vars[agent][f""{var}_{agent}_{t}""] = pyro.sample(
                    f""{var}_{agent}_{t}"",
                    dist.Normal(0.85*prev_val + 0.15*torch.rand(1), AGENT_INIT[var]['std']).to_event(0)
                )
        weighted_intents = {}
        for agent in AGENT_NAMES:
            weighted_intents[agent] = agent_weighted_intent(agent, agent_vars, t, INFLUENCE_WEIGHTS)

        oil_price = pyro.sample(f""oil_price_{t}"", dist.Normal(oil_price + 2*torch.rand(1) - 1, WORLD_INIT['oil_price']['std']).to_event(0))
        tension = pyro.sample(f""geopolitical_tension_{t}"", dist.Normal(0.85*tension + 0.15*torch.rand(1), 0.06).to_event(0))
        global_sentiment = pyro.sample(f""global_sentiment_{t}"", dist.Normal(0.8*global_sentiment + 0.2*torch.randn(1), 0.1).to_event(0))
        inflation = pyro.sample(f""inflation_{t}"", dist.Normal(0.9*inflation + 0.1*torch.rand(1), WORLD_INIT['inflation']['std']).to_event(0))

        prob_us_bomb = sigmoid_weighted_sum(
            EVENT_PARAMS['us_bombed_nuclear_sites']['weights'],
            [
                weighted_intents['Trump'],
                agent_vars['Trump'][f""capability_Trump_{t}""],
                agent_vars['Trump'][f""risk_tolerance_Trump_{t}""],
                tension,
                agent_vars['Trump'][f""ideology_Trump_{t}""]
            ]
        )
        pyro.sample(f""us_bombed_nuclear_sites_{t}"", dist.Bernoulli(prob_us_bomb))

        prob_israel_bomb = sigmoid_weighted_sum(
            EVENT_PARAMS['israel_bombed_nuclear_sites']['weights'],
            [
                weighted_intents['Israel'],
                agent_vars['Israel'][f""capability_Israel_{t}""],
                tension
            ]
        )
        pyro.sample(f""israel_bombed_nuclear_sites_{t}"", dist.Bernoulli(prob_israel_bomb))

        direct_conflict = 1.0 if regional_conflict==2 else 0.0
        prob_khamenei_assass = sigmoid_weighted_sum(
            EVENT_PARAMS['khamenei_assassinated']['weights'],
            [
                weighted_intents['Israel'],
                tension,
                torch.tensor(direct_conflict)
            ]
        )
        pyro.sample(f""khamenei_assassinated_{t}"", dist.Bernoulli(prob_khamenei_assass))

        enrichment_ended = 0
        prob_nuclear_deal = sigmoid_weighted_sum(
            EVENT_PARAMS['nuclear_deal_signed']['weights'],
            [
                weighted_intents['Khamenei'],
                weighted_intents['Trump'],
                global_sentiment,
                torch.tensor(enrichment_ended)
            ]
        )
        pyro.sample(f""nuclear_deal_signed_{t}"", dist.Bernoulli(prob_nuclear_deal))

        enrichment_ongoing = 0
        prob_snapback = sigmoid_weighted_sum(
            EVENT_PARAMS['snapback_activated']['weights'],
            [
                weighted_intents['Trump'],
                weighted_intents['Neocons'],
                tension,
                torch.tensor(enrichment_ongoing),
                weighted_intents['EU']
            ]
        )
        pyro.sample(f""snapback_activated_{t}"", dist.Bernoulli(prob_snapback))

        prob_disrupt = sigmoid_weighted_sum(
            EVENT_PARAMS['iran_covert_disrupt_region']['weights'],
            [
                weighted_intents['IRGC'],
                tension,
                torch.tensor(direct_conflict)
            ]
        )
        pyro.sample(f""iran_covert_disrupt_region_{t}"", dist.Bernoulli(prob_disrupt))

        prob_attack_west = sigmoid_weighted_sum(
            EVENT_PARAMS['iran_covert_terrorist_attack_on_west']['weights'],
            [
                weighted_intents['IRGC'],
                tension,
                weighted_intents['Trump']
            ]
        )
        pyro.sample(f""iran_covert_terrorist_attack_on_west_{t}"", dist.Bernoulli(prob_attack_west))

        prob_sanctions = sigmoid_weighted_sum(
            EVENT_PARAMS['sanctions_imposed']['weights'],
            [
                weighted_intents['Trump'],
                weighted_intents['Neocons'],
                tension,
                weighted_intents['EU']
            ]
        )
        pyro.sample(f""sanctions_imposed_{t}"", dist.Bernoulli(prob_sanctions))

        prob_oil_disrupt = sigmoid_weighted_sum(
            EVENT_PARAMS['oil_supply_disrupted']['weights'],
            [
                weighted_intents['IRGC'],
                weighted_intents['Trump'],
                torch.tensor(direct_conflict),
                weighted_intents['Russia']
            ]
        )
        pyro.sample(f""oil_supply_disrupted_{t}"", dist.Bernoulli(prob_oil_disrupt))

        prob_protest = sigmoid_weighted_sum(
            EVENT_PARAMS['major_protest']['weights'],
            [
                weighted_intents['Khamenei'],
                weighted_intents['IRGC'],
                inflation / 10,
                prob_sanctions
            ]
        )
        pyro.sample(f""major_protest_{t}"", dist.Bernoulli(prob_protest))

        logits_regional = torch.stack([
            1.0 - tension,
            weighted_intents['IRGC'] + weighted_intents['Israel'] + tension,
            1.1 * tension + 0.7 * prob_protest
        ])
        regional_conflict = pyro.sample(f""regional_conflict_{t}"", dist.Categorical(torch.softmax(logits_regional, 0)))"
bNwZGQiP,x22,KutermaScripts,HTML,Sunday 18th of May 2025 03:30:53 PM CDT,"<align=""center""><size=350%><color=#D70040><b> Ewalfor</color> <color=#4E453B>P</color><color=#443D32>r</color><color=#3F382E>o</color><color=#3D352C>j</color><color=#302A22>e</color><color=#28231D>c</color><color=#241F19>t</color></b></size>


<align=""center""><size=350%><b><color=#70AAD3>E</color><color=#1C76AB>w</color><color=#7084C0>a</color><color=#1170A7>l</color><color=#C91618>f</color><color=#6379B9>o</color><color=#243575>r</color> | <color=#454B45> NoRules </color></b></color>






<align=center><size=15><color=#000000>────────────────────────────</size></align></color>
<align=center><size=140%><link=""https://discord.gg/ChrJxADEga""><mark=#4477B9>[🌍]</mark><mark=#3A3A3A>   Discord <space=0.05em>‎  </mark></link> <align=center><size=140%><link=""https://click-storm.ru/i/ava/thumbs/13/134126.jpg""><mark=#4477B9>[💸]</mark><mark=#3A3A3A>   Donation <space=0.05em></mark></link>"
YZEYgPpA,Untitled,15kilovolt,JSON,Sunday 18th of May 2025 03:29:42 PM CDT,"/* global Log Module */

/* MagicMirror²
 * Module: MMM-DBF
 *
 * By Marc Helpenstein <helpi9007@gmail.com>
 * MIT Licensed.
 */

Module.register(""MMM-DBF"", {
  defaults: {
    updateInterval: 60000, // 1 minute
    retryDelay: 30000, // 30 seconds
    station: ""Düsseldorf Hbf"",
    platform: """",
    via: """",
    showApp: false,
    showArrivalTime: false,
    showRealTime: false,
    onlyArrivalTime: false,
    numberOfResults: 10,
    hideLowDelay: false,
    withoutDestination: """",
    onlyDestination: """",
    train: """",
    height: ""600px"",
    width: ""400px"",
    setTableWidth: """",
    timeOption: ""time"", // time+countdown or countdown
    showDelayMsg: false,
  },

  requiresVersion: ""2.1.0"",

  /**
   * @description Helper function to generate API url
   *
   * @returns {String} url
   */
  generateUrl() {
    this.sendNotification(""MMM_DBF_GENERATING_URL"", { message: '[MMM-DBF] Generating URL from dbf.finalrewind.org ...'});
    let baseUrl = ""https://dbf.finalrewind.org/"";
    baseUrl += `${this.config.station}?platforms=${this.config.platform}&via=${this.config.via}&hide_opts=1`;
    if (this.config.showArrivalTime) {
      baseUrl += ""&detailed=1"";
    }
    if (this.config.showRealTime) {
      baseUrl += ""&show_realtime=1"";
    }
    if (this.config.onlyArrivalTime) {
      baseUrl += ""&admode=dep"";
    }
    else {
      baseUrl += ""&admode=dep"";
    }
    if (this.config.hideLowDelay) {
      baseUrl += ""&hidelowdelay=1"";
    }
    return baseUrl;
  },

  /**
   * @description Calls updateIterval
   */
  start() {
    // Flag for check if module is loaded
    this.loaded = false;
    // Schedule update timer.
    this.getData();
    // Show that the module is running by issuing a notification
    this.sendNotification(""MMM_DBF_LOADED"", { message: '[MMM-DBF] Module loaded.'});
  },

  /**
   * @description Gets data from dbf.finalrewind.org
   */
  async getData() {
    const self = this;
    const urlApi = `${this.generateUrl()}&mode=json&version=3`;
    const dataRequest = await fetch(urlApi);

    if (!dataRequest.ok) {
      // Show that the data request is being processed
      this.sendNotification(""MMM_DBF_ERROR_PROCESSING_DATA"", { message: '[MMM-DBF] Data processing returned an error. See log.'});
      let message = `An error has occurred: ${dataRequest.status}`;
      if (dataRequest.status === 300) {
        message += "" - Ambiguous station name."";
      }
      throw new Error(message);
    }
    else {
      const data = await dataRequest.json();
      // Show that the data request is being processed
      this.sendNotification(""MMM_DBF_START_PROCESSING_DATA"", { message: '[MMM-DBF] Data processing started.'});
      self.processData(data);
    }
    self.scheduleUpdate(self.config.retryDelay);
  },

  /**
   * @description Schedule next update.
   * @param {int} delay - Milliseconds before next update.
   */
  scheduleUpdate(delay) {
    const self = this;
    let nextLoad = this.config.updateInterval;
    if (typeof delay !== ""undefined"" && delay >= 0) {
      nextLoad = delay;
    }
    setTimeout(() => {
      self.getData();
    }, nextLoad);

    if (!this.config.showApp) {
      // Show that the module is updating its content
      this.sendNotification(""MMM_DBF_UPDATING_DOM"", { message: '[MMM-DBF] DOM is being updated.'});
      this.updateDom();
    }
  },

  /**
   * @description Create App Frame or HTML table
   *
   * @returns {HTMLIframeElement}
   */
  getDom() {
    if (this.config.showApp) {
      const iframe = document.createElement(""IFRAME"");
      iframe.style = ""border:0"";
      iframe.width = this.config.width;
      iframe.height = this.config.height;
      iframe.src = this.generateUrl();
      // Show that the module has set up the iFrame
      this.sendNotification(""MMM_DBF_IFRAME_URL_GENERATED"", { message: '[MMM-DBF] URL for iFrame successfully generated.'});
      return iframe;
    }
    const tableWrapper = document.createElement(""table"");
    tableWrapper.className = ""small mmm-dbf-table"";
    if (this.dataRequest) {
      if (!this.dataRequest.error) {
        if (this.config.setTableWidth) {
          tableWrapper.style.width = this.config.setTableWidth;
        }
        const { departures } = this.dataRequest;
        const tableHead = this.createTableHeader(departures);
        tableWrapper.appendChild(tableHead);
        this.createTableContent(departures, tableWrapper);
        // Table content successfully generated
        this.sendNotification(""MMM_DBF_TABLE_CONTENT_GENERATED"", { message: '[MMM-DBF] Table content successfully generated.'});
      }
      else {
        // An error occurred which is being logged
        this.sendNotification(""MMM_DBF_DATA_REQUEST_ERROR"", { message: '[MMM-DBF] Error while performing data request. See log.'});
        Log.error(this.dataRequest.error);
      }
    }
    return tableWrapper;
  },

  /**
   * @description Get the size for showing entrys
   * @param {Object[]} departures
   */
  getSize(departures) {
    if (departures.length < this.config.numberOfResults) {
      return departures.length;
    }
    return this.config.numberOfResults;
  },

  /**
   * @description Check delay exist
   * @param {Object[]} departures
   */
  checkDelayExist: function (departures) {
    for (let index = 0; index < this.getSize(departures); index++) {
      if (departures[index].delayDeparture) {
        if (this.config.hideLowDelay && departures[index].delayDeparture >= 5) {
          return true;
        }
        if (!this.config.hideLowDelay) {
          return true;
        }
      }
    }
    return false;
  },

  /**
   * @description Get col number
   */
  getColDelay() {
    if (this.config.via !== """") {
      return 5;
    }
    return 4;
  },

  /**
   * @param {Object} train
   */
  getViaFromRoute(train) {
    const viaConfigList = this.config.via.split("","");
    const route = train.via;
    for (let i = 0; i < route.length; i += 1) {
      const city = route[i];
      for (let j = 0; j < viaConfigList.length; j += 1) {
        if (city.includes(viaConfigList[j])) {
          return viaConfigList[j];
        }
      }
    }
    return false;
  },

  /**
   * @description Check if destination is in list config.withoutDestination
   * @param {Object} train
   */
  checkDestination(train, destinationConfig) {
    const destinations = destinationConfig.split("","");
    for (let index = 0; index < destinations.length; index += 1) {
      if (train.destination === destinations[index]) {
        return true;
      }
    }
    return false;
  },

  /**
   * @description Check if train is in list config.train
   * @param {Object} train
   */
  checkTrain(train) {
    const trains = this.config.train.split("","");
    const trainName = train.train.split("" "")[0] + train.train.split("" "")[1];
    for (let i = 0; i < trains.length; i += 1) {
      if (trainName.includes(trains[i])) {
        return true;
      }
    }
    return false;
  },

  /**
   * @description Checks time and return day/hour/mins
   * @param {int} time - Remaining time
   */
  convertTime(scheduledTime) {
    const time = this.calculateTime(scheduledTime);
    if (time >= 3600) {
      const strTime = Math.floor(time / 3600).toString();
      return `+${strTime} ${this.translate(""HOUR"")}`;
    }
    if (time >= 60) {
      const strTime = Math.floor(time / 60).toString();
      return `${strTime} ${this.translate(""MINUTE"")}`;
    }
    return this.translate(""NOW"");
  },

  /**
   * @description Calculate remaining time
   * @param {int:int} scheduledTime
   */
  calculateTime(scheduledTime) {
    const d = new Date();
    const time = scheduledTime.split("":"");
    const dateTrain = new Date(
      d.getFullYear(),
      d.getMonth(),
      d.getDate(),
      time[0],
      time[1],
    );
    const newStamp = new Date().getTime();
    return Math.round((dateTrain.getTime() - newStamp) / 1000);
  },

  /**
   * @description Check msg exists
   * @param {Object[]} departures
   */
  checkMsgExist(departures) {
    for (let index = 0; index < this.getSize(departures); index += 1) {
      if (
        departures[index] !== undefined
        && departures[index].messages.delay.length > 0
      ) {
        return true;
      }
    }
    return false;
  },

  /**
   * @description Creates the header for the Table
   */
  createTableHeader(departures) {
    const tableHead = document.createElement(""tr"");
    tableHead.className = ""border-bottom"";

    const tableHeadValues = [
      this.translate(""TRAIN""),
      this.translate(""TRACK""),
      this.translate(""DESTINATION""),
    ];

    if (this.config.via !== """") {
      tableHeadValues.push(this.translate(""VIA""));
    }
    if (!this.config.onlyArrivalTime) {
      tableHeadValues.push(this.translate(""DEPARTURE""));
    }
    else {
      tableHeadValues.push(this.translate(""ARRIVAL""));
    }

    if (
      this.checkDelayExist(departures)
      || this.checkCancelledExist(departures)
    ) {
      const delayClockIcon = ""<i class=\""fa fa-clock-o\""></i>"";
      tableHeadValues.push(delayClockIcon);
    }

    if (this.config.showDelayMsg && this.checkMsgExist(departures)) {
      tableHeadValues.push(this.translate(""DELAYMSG""));
    }

    for (
      let thCounter = 0;
      thCounter < tableHeadValues.length;
      thCounter += 1
    ) {
      const tableHeadSetup = document.createElement(""th"");
      if (thCounter === 5) {
        tableHeadSetup.style.textAlign = ""Left"";
      }
      tableHeadSetup.innerHTML = tableHeadValues[thCounter];
      tableHead.appendChild(tableHeadSetup);
    }
    return tableHead;
  },

  /**
   * @param usableResults
   * @param tableWrapper
   * @returns {HTMLTableRowElement}
   */
  createTableContent(departures, tableWrapper) {
    // Show the generation of the content has started
    this.sendNotification(""MMM_DBF_GENERATING_TABLE_CONTENT"", { message: '[MMM-DBF] Table content is being generated.'});
    let size = this.getSize(departures);
    let departureCount = 0;
    for (let index = 0; index < size; index += 1) {
      const obj = departures[index];
      const trWrapper = document.createElement(""tr"");
      trWrapper.className = obj.isCancelled ? ""tr cancelled"" : ""tr"";
      this.checkMsgExist(obj);

      // Check train
      if (this.config.train !== """" && !this.checkTrain(obj)) {
        if (size + 1 <= departures.length) {
          size += 1;
        }
      }
      else if (
        this.config.withoutDestination !== """"
        && this.checkDestination(obj, this.config.withoutDestination)
      ) {
        if (size + 1 <= departures.length) {
          size += 1;
        }
      }
      else if (
        this.config.onlyDestination !== """"
        && !this.checkDestination(obj, this.config.onlyDestination)
      ) {
        if (size + 1 <= departures.length) {
          size += 1;
        }
      }
      else {
        const tdValues = [obj.train, obj.platform, obj.destination];
        if (this.config.via !== """") {
          const via = this.getViaFromRoute(obj);
          if (via === false) {
            tdValues.push("""");
          }
          else {
            tdValues.push(this.getViaFromRoute(obj));
          }
        }

        let time;
        if (this.config.onlyArrivalTime) {
          time = obj.scheduledArrival;
        }
        else {
          time = obj.scheduledDeparture;
        }

        const remainingTime = this.convertTime(time);
        switch (this.config.timeOption) {
          case ""time+countdown"":
            tdValues.push(`${time} (${remainingTime})`);
            break;
          case ""countdown"":
            tdValues.push(remainingTime);
            break;
          default:
            tdValues.push(time);
            break;
        }

        if (
          this.checkDelayExist(departures)
          || this.checkCancelledExist(departures)
        ) {
          if (obj.delayDeparture > 0 && !this.config.hideLowDelay) {
            let delay = "" +"" + obj.delayDeparture;
            tdValues.push(delay);
          }
          else if (obj.delayDeparture >= 5) {
            let delay = "" +"" + obj.delayDeparture;
            tdValues.push(delay);
          }
          else if (obj.isCancelled > 0) {
            tdValues.push(this.translate(""CANCELMSG""));
          }
        }

        if (
          this.config.showDelayMsg
          && this.checkMsgExist(departures)
          && obj.delayDeparture > 0
        ) {
          if (obj.messages.delay.length > 0) {
            tdValues.push(obj.messages.delay[0].text);
          }
        }

        departureCount += 1;
        for (let c = 0; c < tdValues.length; c += 1) {
          const tdWrapper = document.createElement(""td"");
          tdWrapper.innerHTML = tdValues[c];

          if (c === this.getColDelay()) {
            tdWrapper.className = ""delay"";
          }
          if (c === this.getColDelay() + 1) {
            tdWrapper.className = ""delay"";
            tdWrapper.style.width = ""200px"";
            tdWrapper.style.textAlign = ""Left"";
            // tdWrapper.innerHTML = '<marquee scrollamount=""3"" >' + tdValues[c] + '<marquee>';
          }
          trWrapper.appendChild(tdWrapper);
        }
        tableWrapper.appendChild(trWrapper);
      }
    }

    if (departureCount === 0) {
      const trWrapper = document.createElement(""tr"");
      trWrapper.className = ""tr"";
      const tdWrapper = document.createElement(""td"");

      if (this.config.onlyDestination !== """" && this.config.train !== """") {
        tdWrapper.innerHTML = ""Destination or train not found"";
        Log.error(""Destination or train not found"");
      }
      else if (this.config.onlyDestination !== """") {
        tdWrapper.innerHTML = ""Destination not found"";
        Log.error(""Destination not found"");
      }
      else if (this.config.train !== """") {
        tdWrapper.innerHTML = ""Train not found"";
        Log.error(""Train not found"");
      }

      trWrapper.appendChild(tdWrapper);
      tableWrapper.appendChild(trWrapper);
    }
  },

  /**
   * @description Define required styles.
   * @returns {[string,string]}
   */
  getStyles() {
    return [""MMM-DBF.css"", ""font-awesome.css""];
  },

  /**
   * @description Load translations files
   * @returns {{en: string, de: string}}
   */
  getTranslations() {
    return {
      en: ""translations/en.json"",
      de: ""translations/de.json"",
    };
  },
  /**
   * @description Update data and send notification to node_helper
   * @param {*} data
   */
  processData(data) {
    // Show that data are being processed
    this.sendNotification(""MMM_DBF_PROCESSING_DATA"", { message: '[MMM-DBF] Data are being processed.'});
    this.dataRequest = data;

    if (this.loaded === false) {
      this.updateDom(this.config.animationSpeed);
    }
    this.loaded = true;
  },
});
"
nbMiJsdz,Untitled,Nefrace,OpenGL Shading,Sunday 18th of May 2025 03:28:30 PM CDT,"#version 330

// Input vertex attributes (from vertex shader)
in vec3 fragPosition;
in vec2 fragTexCoord;
in vec4 fragColor;
in vec3 fragNormal;

// Input uniform values
uniform sampler2D texture0; // Screen texture
uniform sampler2D texture1; // Palette
uniform vec4 colDiffuse;

out vec4 finalColor;

const int bayer16[16] = int[16](0,  8,  2,  10, 
                                12, 4,  14, 6, 
                                3,  11, 1,  9, 
                                15, 7,  13, 5);


void main() {
    vec4 texelColor = texture(texture0, fragTexCoord);
    float grey = 0.21 * texelColor.r + 0.71 * texelColor.g + 0.07 * texelColor.b; 
    int col = int(mod(gl_FragCoord.x, 4));
    int row = int(mod(gl_FragCoord.y, 4));
    float threshold = float(bayer16[col + 4 * row]) / 16.0 - 0.5;
    grey = clamp(grey + threshold * 0.1 , 0.01, 0.99); // Apply bayer pattern to the color

    vec2 paluv = vec2(grey, 0.5);
    vec4 paletteValue = texture(texture1, paluv);
    finalColor.a = 1.0;
    finalColor.rgb = paletteValue.rgb;
}

"
h1erSXHx,Untitled,dllbridge,C,Sunday 18th of May 2025 02:05:19 PM CDT,"


#include  <iostream>
#include <algorithm>
#include    <vector>
using namespace std;


void monitor_vector(vector<int> &rb);
void monitorVector (vector<int> &rb);

///////////////////////////////////////////////////
int main() 
{

    setlocale(LC_ALL, ""rus""); 	
    
    
    int nArr[9] = {21, 222, 32, 7857, 14, 54};
    
    
    cout << ""sizeof(nArr) = "" << sizeof(nArr) << endl;
    
    vector<int> v(nArr, &nArr[6]);
    

    
    monitor_vector(v);

    sort(v.begin(), v.end()); 
    monitorVector (v);  
}


////////////////////////////////////////////////////
void monitor_vector(vector<int> &rb)
{
     
     vector<int>::iterator it = rb.begin();
     
    while(it != rb.end())
    {
            
       cout << *it++ << "", "";  
       
     //  it++;      
            
    }  cout << endl;
         
}






////////////////////////////////////////////////////
void monitorVector(vector<int> &rb)
{
     
    for(int i = 0; i < rb.size(); i++)
    {
            
       cout << rb[i] << "", "";        
            
    }  cout << endl;
         
}

"
2GQqBJBt,Northwood Official Server Rules,TheMasterK,HTML,Sunday 18th of May 2025 01:41:14 PM CDT,"<size=24pt><align=""center""><color=#ef0707>Northwood Official SCP: Secret Laboratory Server</color></align></size>
 
<align=""center""><size=18><color=#ff9100>Feel free to join our Discord and connect with other players in our heartwarming and friendly community!</color></size></align>
 
<align=""center""><size=18><color=#FFD700><link=""https://discord.gg/nwofficials"">Click here for Discord invite or go to https://discord.gg/nwofficials</link></color></size></align>
 
<align=""center"">This Official Server is hosted by <b>Northwood Studio</b>. We currently have Five Official Servers,three in Canada and two in Europe.</align>

<align=""center""><size=18><color=#FFD700><link=""https://www.patreon.com/nwservers"">Interested in our patreon? Click here, or go to https://www.patreon.com/nwservers</link></color></size></align>
 
<size=18pt><b><color=#ff2424>Official Server Rules</color></b></size>
<color=#ff2424>1.</color> Cheating and exploiting<color=#ff2424>[1]</color> are strictly prohibited.
<color=#ff2424>2.</color> Phishing, scamming, and other illegal activities are strictly prohibited.
<color=#ff2424>3.</color> Racism[2], discrimination, and other offensive content is strictly prohibited.
<color=#ff2424>4.</color> Harassment, toxicity, and baseless, out-of-game accusations against other players are strictly prohibited.
<color=#ff2424>5.</color> Staff or player impersonation is strictly prohibited.
<color=#ff2424>6.</color> Mic spamming is prohibited. Music is allowed, but must be stopped upon request.
<color=#ff2424>7.</color> Advertisements, including server advertisements and streaming channel advertisements, must be kept to a minimum.
<color=#ff2424>8.</color> Teaming and camping[3] are tolerated if they do not lead to round delays.
<color=#ff2424>9.</color> False reporting and abuse of the in-game reporting function is prohibited.
<color=#ff2424>10.</color> Announcing moderators who have hidden tags is prohibited. Interfering with a moderator’s job is also prohibited.
<color=#ff2424>11.</color> Encouraging others to violate server rules is prohibited.
<color=#ff2424>12.</color> Team sabotage[4] is not allowed.
<color=#ff2424>13.</color> Leaving/suiciding to avoid an SCP, or spawning as a role you do not want to be is prohibited.
<color=#ff2424>14.</color> Explicit Sexual Content, including extended discussion of it and/or roleplay, is prohibited.

<color=#ff2424>[1]</color>  <align=""center"">Using in-game exploit spots, which are normally unreachable, is prohibited. Spots that can be reached by jumping on intentional props/railings are allowed.</align>

<color=#ff2424>[2]</color> <align=""center"">Racism includes use of a cut-off/implied slur, a slur in a song, a racist/offensive steam username, or just general use of slurs.</align>

<color=#ff2424>[3]</color> <align=""center"">Teaming that directly, or intentionally, leads to the death of teammates is prohibited. Staying in a room prolongedly is considered camping. Walking around in the same zone and staying in a corridor/tunnel are not considered camping. Sitting on surface and chatting/doing nothing will be considered camping/round delay.</align>

<color=#ff2424>[4]</color> <align=""left"">For Human Classes - Examples of Teaming/Team sabotage include:</align>
<color=#186bf0>[1]</color><indent=15%>Turning Off Generators.</indent>
<color=#186bf0>[2]</color><indent=15%>Killing obedient, cuffed Class-D/Scientists, unless you cuffed them.</indent>
<color=#186bf0>[3]</color><indent=15%>Uncuffing and Recuffing Class-D/Scientists just to kill them.</indent>
<color=#186bf0>[4]</color><indent=15%>Uncuffing Class-D/Scientists right before their escape.</indent>

<align=""left"">SCPs - Examples of Teaming/Team sabotage include:</align>
<color=#186bf0>[1]</color><indent=15%>Closing/locking doors on teammates.</indent>
<color=#186bf0>[2]</color><indent=15%>Intentionally letting the Nuke go off when it would cause SCPs to lose the round.</indent>

<align=""left"">Scientists/Class-D - Examples of Teaming/Team sabotage include:</align>
<color=#186bf0>[1]</color><indent=15%>- Cuff Trading (the act of uncuffing someone you have previously cuffed, and providing them with a weapon so that they may cuff you — enabling you to play on the opposite team), is permitted. </indent>
<color=#186bf0>[2]</color><indent=15%>- Players should note that Cuff Trading will put them at risk of breaking our rules regarding Teaming[2]. When, and if, this is the case, this will be left entirely up to the Moderator's discretion. </indent>
<indent=20%>- MTF/Chaos are free to kill people who are caught attempting to carry out these 'deals'.</indent>



<size=18pt><b><color=#ff2424>Contact</color></b></size>
Please join our Official Discord <color=#FFD700><link=""https://discord.gg/nwofficials"">(https://discord.gg/nwofficials)</link></color> to contact our staff directly for reporting Northwood Official Servers related incidents. For Ban appeals, also join the server, and read <color=#FFD700><link=""https://discord.com/channels/761966386800623626/852948807011926036"">here</link></color> for our ban appeal channel for who to contact and what to send.
 
<size=12pt><align=""center""><b>Last updated: 18th May 2025</b></align></size>
"
jSWWYDPA,Random String Generator (MINIFIED),outFillippov22,JavaScript,Sunday 18th of May 2025 01:39:47 PM CDT,"// This is a snippet that returns a randomized string you can use.

for(s="""",i=16;i--;)s+=String.fromCharCode(Math.random()*256|0)

// This snippet weighs ≈0.06055 KB or 62 B. It is also a one-liner.
// Use it as-is."
ruVJemNS,VIPTools,Sungmingamerpro13,CSS,Sunday 18th of May 2025 01:04:58 PM CDT,"--------------------
--| WaitForChild |--
--------------------

-- Waits for parent.child to exist, then returns it
local function WaitForChild(parent, childName)
	assert(parent, ""ERROR: WaitForChild: parent is nil"")
	while not parent:FindFirstChild(childName) do parent.ChildAdded:wait() end
	return parent[childName]
end

-----------------
--| Variables |--
-----------------

local GamePassService = game:GetService('GamePassService')
local PlayersService = game:GetService('Players')
local LightingService = game:GetService('Lighting') --TODO: Use new data store service once that exists

local GamePassIdObject = WaitForChild(script, 'GamePassId')
local AdminTools = WaitForChild(LightingService, 'VIPTools')

-----------------
--| Functions |--
-----------------

-- Makes copies of all the admin tools and puts them in target
local function CloneAdminTools(target)
	for _, tool in pairs(AdminTools:GetChildren()) do
		local toolClone = tool:Clone()
		toolClone.Parent = target
	end
end

-- When a player with the game pass joins, give them the admin tools
local function OnPlayerAdded(player)
	if GamePassService:PlayerHasPass(player, GamePassIdObject.Value) then
		local starterGear = WaitForChild(player, 'StarterGear')
		CloneAdminTools(starterGear)
		if player.Character then -- They've already loaded and won't get their StarterGear until next spawn
			local backpack = WaitForChild(player, 'Backpack')
			CloneAdminTools(backpack)
		end
	end
end

--------------------
--| Script Logic |--
--------------------

PlayersService.PlayerAdded:connect(OnPlayerAdded)
"
Z2aQDTyF,2025-05-18T20:02:08.753011,powerampache,PHP,Sunday 18th of May 2025 01:02:10 PM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:984)
	at android.os.Handler.dispatchMessage(Handler.java:104)
	at android.os.Looper.loopOnce(Looper.java:238)
	at android.os.Looper.loop(Looper.java:357)
	at android.app.ActivityThread.main(ActivityThread.java:8088)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:548)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:957)

getPlaylists() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
BV3h78Ar,GPS Installer,ElliNet13,Lua,Sunday 18th of May 2025 12:15:31 PM CDT,"-- GPS Tower installer by ElliNet13
-- Check if advanced
local isAdvanced = term.isColor()
-- Check for any wireless modem
local hasWirelessModem = false
for _, name in ipairs(peripheral.getNames()) do
    if peripheral.getType(name) == ""modem"" then
        local modem = peripheral.wrap(name)
        if modem.isWireless and modem.isWireless() then
            hasWirelessModem = true
            break
        end
    end
end
-- Try GPS
local x, y, z = gps.locate(2)
local gpsWorking = x ~= nil
-- Final check
local ok = isAdvanced and hasWirelessModem
-- Output
print(""Advanced computer:"", isAdvanced)
print(""Wireless modem:"", hasWirelessModem)
print(""GPS working:"", gpsWorking)
if gpsWorking then
    print(""GPS location: x=""..x.."" y=""..y.."" z=""..z)
end
print(""Computer ready (advanced + modem):"", ok)
-- If not ok, reject
if not ok then
    print(""Sorry, you can not be a GPS tower."")
    return
end
-- Ask for 3 numbers
print(""Enter 3 numbers (X Y Z):"")
local input = read()
local userX, userY, userZ = input:match(""^(%-?%d+)%s+(%-?%d+)%s+(%-?%d+)$"")
userX, userY, userZ = tonumber(userX), tonumber(userY), tonumber(userZ)
if not (userX and userY and userZ) then
    print(""Invalid input. Please enter 3 numbers separated by spaces."")
    return
end
-- Show user input
print(""You entered: x=""..userX.."" y=""..userY.."" z=""..userZ)
-- Full command wrapped in shell.run()
local shellCommand = string.format('shell.run(""bg gps host %d %d %d"")', userX, userY, userZ)
-- Paths to check
local startupPaths = {""startup"", ""startup.lua""}
local startupFound = false
-- Append to existing startup or startup.lua
for _, path in ipairs(startupPaths) do
    if fs.exists(path) then
        local file = fs.open(path, ""a"")
        file.writeLine(shellCommand)
        file.close()
        startupFound = true
    end
end
-- If neither existed, create startup
if not startupFound then
    local file = fs.open(""startup"", ""w"")
    file.writeLine(shellCommand)
    file.close()
end
-- Run it now
shell.run(""bg"", ""gps"", ""host"", tostring(userX), tostring(userY), tostring(userZ))
print(""You have now been added as a GPS tower, thanks!"")"
MWq8svyQ,Global Leaderboard,BlonixOne,Lua,Sunday 18th of May 2025 12:12:19 PM CDT,"--[[
this script is for a l´global leaderboard (for the game 'Rainbow Ladder')
]]

-- get the DataStoreService and create an ordered datastore named ""WinsLeaderboard""
local DataStoreService = game:GetService(""DataStoreService"")
local WinsLeaderboard = DataStoreService:GetOrderedDataStore(""WinsLeaderboard"")

-- updates the in-game leaderboard gui with top players from the datastore
local function updateLeaderboard()
	local success, err = pcall(function()
		-- fetch the top 10 players (sorted in descending order by value)
		local ordered = WinsLeaderboard:GetSortedAsync(false, 11, 1)
		local page = ordered:GetCurrentPage()

		-- get GUI elements
		local FrameGui = workspace.Leaderboard.SurfaceGui.Frame
		local Podiums = FrameGui.Parent.Parent.Podiums

		-- clear previous leaderboard entries (except the ""Info"" frame)
		for _, v in FrameGui:GetChildren() do
			if v.ClassName == ""Frame"" and v.Name ~= ""Info"" then
				v:Destroy()
			end
		end

		-- loop through ranked data from the datastore
		for rank, data in page do
			local player = game.Players:GetPlayerByUserId(tonumber(data.key))
			local wins = data.value
			local isOnLeaderboard = false

			-- check if player is already on the leaderboard to avoid duplicates
			for _, v in FrameGui:GetChildren() do
				if v.ClassName == ""Frame"" and v.Name ~= ""Info"" then
					if v.Username.Text == player.Name then
						isOnLeaderboard = true
						break
					end
				end
			end

			-- if player has a valid score and is not yet shown on leaderboard
			if wins and not isOnLeaderboard then
				local podium

				-- choose podium style based on rank
				if rank == 1 then
					podium = Podiums.First:Clone()
				elseif rank == 2 then
					podium = Podiums.Second:Clone()
				elseif rank == 3 then
					podium = Podiums.Third:Clone()
				else
					podium = Podiums.Normal:Clone()
				end

				-- fill in leaderboard entry details
				podium.Rank.Text = tostring(rank)
				podium.Username.Text = player.Name
				podium.Wins.Text = tostring(wins)
				podium.LayoutOrder = rank
				podium.Parent = FrameGui
			end
		end
	end)

	-- warn if the leaderboard failed to update
	if err then
		warn(""Failed to update leaderboard due to the following error: "" .. err)
	end
end

-- saves a player’s win count to the ordered datastore
local function saveWinsData(player: Player)
	pcall(function()
		WinsLeaderboard:SetAsync(player.UserId, player.leaderstats.Wins.Value)
	end)
end

-- background task: auto-save players' wins every 1 second
task.spawn(function()
	while task.wait(1) do
		for _, player in game.Players:GetPlayers() do
			saveWinsData(player)
		end
	end
end)

-- background task: update the leaderboard display every 20 seconds
task.spawn(function()
	while task.wait(20) do
		updateLeaderboard()
	end
end)
"
AGL4YNH8,Coltivare v.2,Vorakh,Lua,Sunday 18th of May 2025 12:06:36 PM CDT,"
local function farm_avanti()
    --print('Avanti')
    for i = 0, 9 do
        turtle.forward()
        local successo, data = turtle.inspectDown()
        if successo then
            if  data.state.age == 7 then
                turtle.digDown()
                turtle.placeDown()
            end
        elseif turtle.placeDown() then

        end
    end
end

local function gira_sx()
    --print('Gira Sinistra')
    turtle.turnLeft()
    turtle.forward()
    turtle.turnLeft()
end

local function gira_dx()
    --print('Gira Destra')
    turtle.turnRight()
    turtle.forward()
    turtle.turnRight()
end

local function torna_base()
    --print('Torna alla base')
    for i = 1, 10 do
        turtle.forward()
    end
    turtle.turnLeft()
    for i = 1, 9 do
        turtle.forward()
    end
    turtle.turnLeft()
end

-- Funzione che controlla se l'inventario della turtle è pieno
function inventarioPieno()
    for slot = 1, 16 do
        if turtle.getItemCount(slot) == 0 then
            return false -- C'è almeno uno slot vuoto
        end
    end
    return true -- Tutti gli slot sono pieni
end


local function gestione_inventario()
    -- Svuota e ricarica le patate
    for slot = 1, 16 do
        turtle.select(slot)
        turtle.dropDown()
        
    end
    turtle.select(1)
    turtle.suckDown(64)
    
end

local function gestione_carburante()
    -- Da implementrare
end

---------------------------------------
-- Programma turtle coltivazione v.2 --
---------------------------------------
print(""Farm automatica Patate"")

while true do
    gestione_inventario()
    if inventarioPieno() then
        print('Sia la cassa che la Turtle sono piene, fare spazio per riprendere la raccolta')
        print('Turtle in attesa...')
    else
        for i = 1, 9 do
        --print('i:'..i)
        if (i%2) == 1 then
            farm_avanti()
            gira_sx()
        else
            farm_avanti()
            gira_dx()
        end
    end
    torna_base()

    print('Finito un ciclo di Raccolta, in attesa di ricrescita prima di iniziare il successivo')
    end
    sleep(60)
end
"
XLTv7YZN,Untitled,AdeonWriter,Linden Scripting,Sunday 18th of May 2025 11:48:39 AM CDT,"integer IsWholeNumber(float number){
    return TRUE;
    if(number == (float)((integer)number)){
        return TRUE;
    }
    else return FALSE;
}

integer GetNumberFromLetter(string single_letter){
    return SubStringIndex(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", single_letter)+1;
}

string GetLetterFromNumber(integer single_number){
    single_number--;
    return GetSubString(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", single_number, single_number);
}

integer Core4Alpha(string s){
    return Core4(
        (float)GetNumberFromLetter(GetSubString(s, 0, 0)),
        (float)GetNumberFromLetter(GetSubString(s, 1, 1)),
        (float)GetNumberFromLetter(GetSubString(s, 2, 2)),
        (float)GetNumberFromLetter(GetSubString(s, 3, 3)) );
}

integer Core4(float a, float b, float c, float d)
{
    integer winner = INT_MAX;
    list potential_cores = [];
    if(d!=0) {
        if(IsWholeNumber(((a-b)*c)/d))
        potential_cores += [ ((a-b)*c)/d ];
    }if(c!=0){
        if(IsWholeNumber(((a-b)/c)))
        potential_cores += [ ((a-b)/c)*d ];
    }if(d!=0) {
        if(IsWholeNumber(((a*b)-c)/d))
        potential_cores += [ ((a*b)-c)/d ];
    }if(c!=0){
        if(IsWholeNumber((a*b)/c))
        potential_cores += [ ((a*b)/c)-d ]; 
    }if(b!=0){
        if(IsWholeNumber(a/b))
        potential_cores += [ ((a/b)*c)-d ];
    }if(b!=0){
        if(IsWholeNumber(a/b))
        potential_cores += [ ((a/b)-c)*d ];
    }
    integer i;
    for(i=0; i<GetListLength(potential_cores); i++){
        if(List2Float(potential_cores, i) == (float)((integer)List2Float(potential_cores, i))){
            if(List2Float(potential_cores, i) < winner){
                if(List2Float(potential_cores, i) > 0){
                    winner = (integer)List2Float(potential_cores, i);
                }
            }
        }
    }
    return winner;
}

string TranslateMessage(list words){
    string output;
    integer length = GetListLength(words);
    integer i;
    for(i=0; i<length; i++){
        string word = List2String(words, i);
        output += GetLetterFromNumber(Core4Alpha(word));
    }
    return output;
}"
RvqcL65i,Mine2,Slinger0001,Lua,Sunday 18th of May 2025 11:23:42 AM CDT,"--[[
    Modular Mining Turtle Program
    Features:
    - Mines a rectangular area (WIDTH x DEPTH)
    - Clears blocks in front and above
    - Tracks position and returns to start
    - Handles fuel needs and movement safely
--]]

-- CONFIGURATION
local WIDTH = 50         -- Number of ""rows"" wide (X)
local DEPTH = 50        -- Number of blocks forward per row (Z)
local MIN_FUEL = 50     -- Minimum fuel buffer

-- STATE TRACKING
local currentRow = 0
local currentDepth = 0
local isFacingForward = true

-- SAFETY: Ensure enough fuel
local function ensureFuel()
    if turtle.getFuelLevel() < MIN_FUEL then
        for i = 1, 16 do
            turtle.select(i)
            if turtle.refuel(1) then
                print(""Refueled using slot "" .. i)
                break
            end
        end
    end
end

-- MOVEMENT WRAPPERS (safe movement)
local function tryForward()
    while not turtle.forward() do
        if turtle.detect() then
            turtle.dig()
        else
            sleep(0.5)
        end
    end
end

local function tryUp()
    while not turtle.up() do
        if turtle.detectUp() then
            turtle.digUp()
        else
            sleep(0.5)
        end
    end
end

local function tryDown()
    while not turtle.down() do
        if turtle.detectDown() then
            turtle.digDown()
        else
            sleep(0.5)
        end
    end
end

-- DIGGING HELPERS
local function clearFront()
    if turtle.detect() then turtle.dig() end
end

local function clearUp()
    if turtle.detectUp() then turtle.digUp() end
end

-- MOVE FORWARD 1 BLOCK SAFELY WITH CLEARING
local function moveAndClearForward()
    clearFront()
    clearUp()
    tryForward()
    currentDepth = currentDepth + (isFacingForward and 1 or -1)
end

-- SHIFT RIGHT TO NEXT ROW
local function shiftRowRight()
    turtle.turnRight()
    clearFront()
    tryForward()
    turtle.turnRight()
    isFacingForward = not isFacingForward
    currentRow = currentRow + 1
end

-- SHIFT LEFT TO NEXT ROW
local function shiftRowLeft()
    turtle.turnLeft()
    clearFront()
    tryForward()
    turtle.turnLeft()
    isFacingForward = not isFacingForward
    currentRow = currentRow + 1
end

-- MAIN DIG LOOP
local function mineArea(width, depth)
    for row = 1, width do
        for step = 1, depth - 1 do
            ensureFuel()
            moveAndClearForward()
        end

        if row < width then
            if isFacingForward then
                shiftRowRight()
            else
                shiftRowLeft()
            end
        end
    end
end

-- RETURN TO START POSITION
local function returnToOrigin()
    -- Face original direction (forward)
    if not isFacingForward then
        turtle.turnLeft()
        turtle.turnLeft()
    end

    -- Back out to 0 depth
    for i = 1, math.abs(currentDepth) do
        tryForward()
    end

    -- Face left to return across rows
    turtle.turnLeft()
    for i = 1, currentRow do
        tryForward()
    end

    -- Face forward again
    turtle.turnRight()
end

-- MAIN
print(""Starting mining operation..."")
ensureFuel()
mineArea(WIDTH, DEPTH)
print(""Mining complete. Returning to start..."")
returnToOrigin()
print(""All done."")
"
5EcARuTD,cf.rel (recursive),John4711,JavaScript,Sunday 18th of May 2025 11:08:48 AM CDT,"var ll=[],a=[],u=new Set(),i=0;
ll=[8412];
async function _1(){
    let x=ll.shift();if(!x) return false;i++;
    fetch(""https://radar.cloudflare.com/charts/BgpRoutesRelsTable/fetch?location=as""+x).then(r=>r.json()).then(d=>{
        i--;
        // console.log (x,d.rels.all.length); // ,d.rels.all.map(v=>v.asn));
        for (var v of d.rels.all) if(!u.has(v.asn)){u.add(v.asn);ll.push(v.asn); delete (v.rel); a.push(v); }
        for (var j=i;j<Math.min(ll.length,10);j++) _1();
        let _asn = a.find(item => item.asn === x); if(_asn) {
            _asn.u=d.rels.upstreams.map(v=>v.asn);
            _asn.p=d.rels.peers.map(v=>v.asn);
            _asn.d=d.rels.downstreams.map(v=>v.asn);
            console.log(_asn);
            }
        return d;
    })
    
};
_1();"
EVjSy2Li,"How to make ""Kenworth K-100"" work on the latest game version",Bartal_69,YAML,Sunday 18th of May 2025 10:40:50 AM CDT,"Go to this path in your Steam folder:
...\Steam\steamapps\workshop\content\227300\1814887717\
...\Steamlibrary\steamapps\workshop\content\227300\1814887717\

In this folder open ""versions.sii"" file via any text editor, e.x. in notepad:

============================================ You will see this ============================================
SiiNunit
{
package_version_info : .universal
{
    package_name: ""universal""
	informational: true
}
package_version_info : .c2c
{
    package_name: ""c2c""
	compatible_versions[]: ""1.36.*""
	compatible_versions[]: ""1.35.*""
}
package_version_info : .137
{
    package_name: ""actros_mp2""
	compatible_versions[]: ""1.37.*""
	compatible_versions[]: ""1.38.*""
}
package_version_info : .139
{
    package_name: ""actros_mp3""
	compatible_versions[]: ""1.39.*""
}
}
=========================================================================================================

==================================== And you need change it, to this ====================================
SiiNunit
{
package_version_info : .universal
{
    package_name: ""actros_mp3""
}
}
=========================================================================================================

After that, restart your game if it was launched before this editing.
And Voila!"
CBiSwnqS,forwarding,STANAANDREY,C++,Sunday 18th of May 2025 10:35:14 AM CDT,"#if defined(_MSC_VER)
#include <__msvc_all_public_headers.hpp>
#elif defined(__GNUC__)
#include <bits/stdc++.h>
#else
#error ""Unsupported compiler""
#endif
using namespace std;

class Integer {
public:
	Integer() {
		pval = new int(0);
		cout << ""Integer()"" << endl;
	}
	Integer(int value) {
		pval = new int(value);
		cout << ""Integer(int)"" << endl;
	}
	Integer(const Integer& other) {
		pval = new int(*other.pval);
		cout << ""Integer(const Integer&)"" << endl;
	}
	Integer(Integer&& other) noexcept {
		pval = other.pval;
		other.pval = nullptr;
		cout << ""Integer(Integer&&)"" << endl;
	}
	int get() const {
		return *pval;
	}
	~Integer() {
		delete pval;
		cout << ""~Integer()"" << endl;
	}
private:
	int* pval = nullptr;
};

class Entity {
public:
	template <typename T1, typename T2>
	Entity(T1&& id, T2&& name) : id(forward<T1>(id)), name(forward<T2>(name)) {
		cout << ""Entity(T1&&, T2&&)"" << endl;
	}

	template <typename T1, typename T2>
	static Entity* create(T1&& id, T2&& name) {
		return new Entity{ forward<T1>(Integer{ id }), name };
	}
private:
	Integer id;
	string name;
};

int main() {
	Entity e1{ Integer{1}, ""Alice"" };
	return 0;
}
"
EFUBcTrw,Monster Hutner: Wilds | Dual Blade build May-2025 | 437+48 effective damage,Nyanderful,JSON,Sunday 18th of May 2025 10:24:07 AM CDT,"{
  ""weapon"": {
    ""name"": ""Tiltkreise"",
    ""type"": ""Dual Blades""
  },
  ""artian"": {
    ""element"": ""Ice"",
    ""infusions"": [
      ""Attack"",
      ""Attack"",
      ""Attack""
    ],
    ""upgrades"": [
      ""Attack"",
      ""Attack"",
      ""Sharpness"",
      ""Sharpness"",
      ""Affinity""
    ]
  },
  ""helm"": ""Rey Sandhelm γ"",
  ""body"": ""Rey Sandmail γ"",
  ""arms"": ""Rey Sandbraces γ"",
  ""waist"": ""Gore Coil β"",
  ""legs"": ""Gore Greaves β"",
  ""charm"": ""Marathon Charm III"",
  ""weaponSlots"": [
    ""Frost/Focus Jewel [3]"",
    ""Rzr Sharp/Handicraft Jwl [3]"",
    ""Critical Jewel III [3]""
  ],
  ""helmSlots"": [
    ""Challenger Jewel [3]""
  ],
  ""bodySlots"": [
    ""Mirewalker Jewel [1]""
  ],
  ""armsSlots"": [
    ""Challenger Jewel [3]"",
    ""Chain Jewel [3]""
  ],
  ""waistSlots"": [
    ""Challenger Jewel [3]"",
    ""Earplugs Jewel [2]""
  ],
  ""legsSlots"": [
    ""Counterattack Jewel [3]"",
    ""Sane Jewel [1]"",
    ""Sane Jewel [1]""
  ],
  ""buffs"": {
    ""Frenzy"": 1
  },
  ""uptime"": {
    ""Latent Power"": 100,
    ""Maximum Might"": 100,
    ""Lord's Soul"": 100,
    ""Frenzy"": 100
  }
}"
ZAFag9ZN,Untitled,xConquerPS,JavaScript,Sunday 18th of May 2025 10:17:10 AM CDT,"const fs = require('node:fs');
const http = require('node:http');

const userDB = 'users.json';
function getAllUsers() {
  return new Promise((resolve, reject) => {
    const read = fs.createReadStream(userDB);
    let users = [];

    read.on('data', (chunk) => { users += chunk; });

    read.on('end', () => {
      try {
        return resolve(JSON.parse(users));
      } catch (err) {
        return reject(err);
      }
    });

    read.on('error', (err) => { return reject(err); });
  });
}
function updateUsers(users) {
  fs.createWriteStream(userDB).write(JSON.stringify(users));
}

function userMgr(request, response, status) {
  switch (status) {
    case 'fetch': {
      return getAllUsers().then((users) => { return response.end(JSON.stringify(users)); });
    }
    case 'create': {
      let userObj = null;
      request.on('data', (chunk) => { userObj = JSON.parse(chunk); });
      request.on('end', () => {
        getAllUsers().then((users) => {
          const userIndex = users.findIndex((user) => { return user.id == userObj.id; });

          if (userIndex == -1) {
            users.push(userObj);
            updateUsers(users);
            response.writeHead(201);
            return response.end(JSON.stringify({ message: 'User created successfully.' }));
          } else {
            response.writeHead(409);
            return response.end(JSON.stringify({ message: 'This user already exists.' }));
          }
        });
      });
      break;
    }
    case 'update': {
      let userObj = null;
      request.on('data', (chunk) => { userObj = JSON.parse(chunk); });

      request.on('end', () => {
        getAllUsers().then((users) => {
          const userIndex = users.findIndex((user) => { return user.id == userObj.id });

          if (userIndex == -1) {
            response.writeHead(409);
            return response.end(JSON.stringify({ message: 'This user is not exists.' }));
          } else {
            users[userIndex] = userObj;
            updateUsers(users);

            response.writeHead(201);
            return response.end(JSON.stringify({ message: 'User updated successfully.', }));
          }
        });
      });
      break;
    }
    case 'delete': {
      let userObj = null;
      request.on('data', (chunk) => { userObj = JSON.parse(chunk); });

      request.on('end', () => {
        getAllUsers().then((users) => {
          const userIndex = users.findIndex((user) => { return user.id == userObj.id });

          if (userIndex == -1) {
            response.writeHead(409);
            return response.end(JSON.stringify({ message: 'This user is not exists.' }));
          } else {
            users = users.filter(user => user.id != userObj.id);
            updateUsers(users);

            response.writeHead(201);
            return response.end(JSON.stringify({ message: 'User deleted successfully.', }));
          }
        });
      });
      break;
    }
  }
}

const server = http
  .createServer((request, response) => {
    //Request handler..
    console.log(request.method, request.url);

    switch (request.method) {
      case 'GET': {
        if (request.url == '/users') return userMgr(request, response, 'fetch');
        break;
      }
      case 'POST': {
        if (request.url == '/users') return userMgr(request, response, 'create');
        break;
      }
      case 'PATCH': {
        if (request.url == '/users') return userMgr(request, response, 'update');
        break;
      }
      case 'DELETE': {
        if (request.url == '/users') return userMgr(request, response, 'delete');
        break;
      }
      default: {
        response.writeHead(404);
        response.write('Invalid request.');
        break;
      }
    }
    response.end();
  })
  .listen(4006);"
GJdgL9d3,Untitled,PaffcioStudio,Lua,Sunday 18th of May 2025 10:15:00 AM CDT,"

// FOLDER: /
Ścieżka: /src/__init__.py
Rozmiar: 0,03 KB
Zawartość:
# Plik inicjalizujący moduł src

Ścieżka: app.py:
Zawartość:
# Główny plik aplikacji IDE
#/app.py

import sys
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QLocale
from src.ui import IDEWindow

if __name__ == '__main__':
    app = QApplication(sys.argv)
    QLocale.setDefault(QLocale(QLocale.Language.Polish, QLocale.Country.Poland))
    main_window = IDEWindow()
    main_window.show()
    sys.exit(app.exec())

Ścieżka: /src/config.py
Rozmiar: 7,52 KB
Zawartość:
# Konfiguracja i stałe aplikacji
#/src/config.py

import os
import re
from PyQt6.QtGui import QTextCharFormat, QColor, QFont

APP_DIR = os.path.dirname(os.path.abspath(os.path.dirname(__file__)))
DATA_DIR = os.path.join(APP_DIR, 'userdata')
PROJECTS_DIR = os.path.join(APP_DIR, 'projects')
SETTINGS_FILE = os.path.join(DATA_DIR, 'settings.json')
RECENTS_FILE = os.path.join(DATA_DIR, 'recents.json')
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(PROJECTS_DIR, exist_ok=True)

FORMAT_DEFAULT = QTextCharFormat()
FORMAT_KEYWORD = QTextCharFormat()
FORMAT_KEYWORD.setForeground(QColor(""#000080"")) # Navy
FORMAT_STRING = QTextCharFormat()
FORMAT_STRING.setForeground(QColor(""#008000"")) # Green
FORMAT_COMMENT = QTextCharFormat()
FORMAT_COMMENT.setForeground(QColor(""#808080"")) # Gray
FORMAT_COMMENT.setFontItalic(True)
FORMAT_FUNCTION = QTextCharFormat()
FORMAT_FUNCTION.setForeground(QColor(""#0000FF"")) # Blue
FORMAT_CLASS = QTextCharFormat()
FORMAT_CLASS.setForeground(QColor(""#A52A2A"")) # Brown
FORMAT_CLASS.setFontWeight(QFont.Weight.Bold)
FORMAT_NUMBERS = QTextCharFormat()
FORMAT_NUMBERS.setForeground(QColor(""#FF0000"")) # Red
FORMAT_OPERATOR = QTextCharFormat()
FORMAT_OPERATOR.setForeground(QColor(""#A62929"")) # Dark Red
FORMAT_BUILTIN = QTextCharFormat()
FORMAT_BUILTIN.setForeground(QColor(""#008080"")) # Teal
FORMAT_SECTION = QTextCharFormat() # Dla sekcji w INI
FORMAT_SECTION.setForeground(QColor(""#800080"")) # Purple
FORMAT_SECTION.setFontWeight(QFont.Weight.Bold)
FORMAT_PROPERTY = QTextCharFormat() # Dla kluczy/właściwości w INI/JSON
FORMAT_PROPERTY.setForeground(QColor(""#B8860B"")) # DarkGoldenrod

HIGHLIGHTING_RULES = {
    'python': {
        'keywords': ['and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else',
                     'except', 'False', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'None',
                     'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'True', 'try', 'while', 'with', 'yield'],
        'builtins': ['print', 'len', 'range', 'list', 'dict', 'tuple', 'set', 'str', 'int', 'float', 'bool', 'open', 'isinstance'],
        'patterns': [
            (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION),
            (r'\bclass\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS),
            (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS),
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR),
            (r'"".*?""', FORMAT_STRING),
            (r""'.*?'"", FORMAT_STRING),
            (r'#.*', FORMAT_COMMENT),
        ]
    },
    'javascript': {
        'keywords': ['abstract', 'arguments', 'await', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const', 'continue',
                     'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'final',
                     'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import', 'in', 'instanceof', 'int', 'interface',
                     'let', 'long', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'short', 'static',
                     'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void',
                     'volatile', 'while', 'with', 'yield'],
         'builtins': ['console', 'log', 'warn', 'error', 'info', 'Math', 'Date', 'Array', 'Object', 'String', 'Number', 'Boolean', 'RegExp', 'JSON', 'Promise', 'setTimeout', 'setInterval'],
        'patterns': [
            (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION),
             (r'\bclass\s+([A-Za-z_][A-ZaZ0-9_]*)\b', FORMAT_CLASS),
            (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS),
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR),
            (r'"".*?""', FORMAT_STRING),
            (r""'.*?'"", FORMAT_STRING),
            (r'//.*', FORMAT_COMMENT),
        ]
    },
     'html': {
        'keywords': [],
        'builtins': [],
        'patterns': [
            (r'<[^>]+>', FORMAT_KEYWORD),
            (r'[a-zA-Z0-9_-]+\s*=', FORMAT_OPERATOR),
            (r'"".*?""', FORMAT_STRING),
            (r""'.*?'"", FORMAT_STRING),
             (r'&[a-zA-Z0-9]+;', FORMAT_BUILTIN),
            (r'<!--.*?-->', FORMAT_COMMENT, re.DOTALL),
        ]
    },
    'css': {
        'keywords': [],
        'builtins': [],
        'patterns': [
            (r'\.[a-zA-Z0-9_-]+', FORMAT_CLASS),
            (r'#[a-zA-Z0-9_-]+', FORMAT_BUILTIN),
            (r'[a-zA-Z0-9_-]+\s*:', FORMAT_KEYWORD),
            (r';', FORMAT_OPERATOR),
            (r'\{|\}', FORMAT_OPERATOR),
             (r'\(|\)', FORMAT_OPERATOR),
            (r'\b\d+(\.\d*)?(px|em|%|vh|vw|rem|pt|cm|mm)?\b', FORMAT_NUMBERS),
             (r'#[0-9a-fA-F]{3,6}', FORMAT_NUMBERS),
            (r'"".*?""', FORMAT_STRING),
            (r""'.*?'"", FORMAT_STRING),
        ]
    },
    'c++': {
         'keywords': ['alignas', 'alignof', 'and', 'and_eq', 'asm', 'atomic_cancel', 'atomic_commit', 'atomic_noexcept', 'auto',
                     'bitand', 'bitor', 'bool', 'break', 'case', 'catch', 'char', 'char8_t', 'char16_t', 'char32_t', 'class',
                     'compl', 'concept', 'const', 'consteval', 'constexpr', 'constinit', 'const_cast', 'continue', 'co_await',
                     'co_return', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
                     'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto', 'if', 'inline', 'int', 'long',
                     'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 'private',
                     'protected', 'public', 'reflexpr', 'register', 'reinterpret_cast', 'requires', 'return', 'short', 'signed',
                     'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch', 'synchronized', 'template',
                     'this', 'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned',
                     'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq'],
         'builtins': ['cout', 'cin', 'endl', 'string', 'vector', 'map', 'set', 'array', 'queue', 'stack', 'pair', 'algorithm', 'iostream', 'fstream', 'sstream', 'cmath', 'cstdlib', 'cstdio', 'ctime'],
         'patterns': [
             (r'\b[A-Za-z_][A-ZaZ0-9_]*\s*\(', FORMAT_FUNCTION),
             (r'\bclass\s+([A-Za-z_][A-ZaZ0-9_]*)\b', FORMAT_CLASS),
             (r'\bstruct\s+([A-Za-z_][A-ZaZ0-9_]*)\b', FORMAT_CLASS),
             (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS),
             (r'[+\-*/=<>!&|%^~?:]', FORMAT_OPERATOR),
             (r'"".*?""', FORMAT_STRING),
             (r""'.*?'"", FORMAT_STRING),
             (r'//.*', FORMAT_COMMENT),
         ]
    },
    'ini': {
        'keywords': [],
        'builtins': [],
        'patterns': [
            (r'^\[.*?\]', FORMAT_SECTION),
            (r'^[a-zA-Z0-9_-]+\s*=', FORMAT_PROPERTY),
            (r';.*', FORMAT_COMMENT),
            (r'#.*', FORMAT_COMMENT),
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR),
             (r'=\s*"".*?""', FORMAT_STRING),
             (r""=\s*'.*?'"", FORMAT_STRING),
             (r'=\s*[^;#""\'].*', FORMAT_STRING),
        ]
    },
    'json': {
        'keywords': ['true', 'false', 'null'],
        'builtins': [],
        'patterns': [
            (r'""(?:[^""\\]|\\.)*""\s*:', FORMAT_PROPERTY),
            (r'"".*?""', FORMAT_STRING),
            (r'\b-?\d+(\.\d+)?([eE][+-]?\d+)?\b', FORMAT_NUMBERS),
            (r'\{|\}|\[|\]|:|,', FORMAT_OPERATOR),
        ]
    }
}


Ścieżka: /src/console.py
Rozmiar: 23,59 KB
Zawartość:
# Zarządzanie konsolą i chatem AI
# /src/console.py

import os
import sys
import shlex
import json
import requests
import platform
import markdown2
from PyQt6.QtCore import QProcess, QProcessEnvironment, pyqtSignal, QObject, QTimer, QThread, pyqtSlot
from PyQt6.QtGui import QTextCharFormat, QColor, QFont
from PyQt6.QtWidgets import QPlainTextEdit, QLineEdit, QVBoxLayout, QWidget, QPushButton, QComboBox, QHBoxLayout, QTabWidget, QApplication, QTextEdit

class ConsoleManager(QObject):
    output_received = pyqtSignal(str, bool)  # tekst, is_error
    status_updated = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.process = QProcess(self)
        self.process.readyReadStandardOutput.connect(self._handle_stdout)
        self.process.readyReadStandardError.connect(self._handle_stderr)
        self.process.finished.connect(self._handle_process_finished)
        
    def run_command(self, command_text, working_dir, python_path="""", node_path=""""):
        if self.process.state() != QProcess.ProcessState.NotRunning:
            self.output_received.emit(""Inny proces już działa. Zakończ go najpierw."", True)
            self.status_updated.emit(""Błąd: Inny proces aktywny."")
            return
        
        try:
            command = shlex.split(command_text)
        except ValueError as e:
            self.output_received.emit(f""Błąd parsowania komendy: {e}"", True)
            self.status_updated.emit(""Błąd parsowania komendy."")
            return
            
        if not command:
            self.output_received.emit(""Błąd: Pusta komenda."", True)
            self.status_updated.emit(""Błąd: Pusta komenda."")
            return
            
        command_str = shlex.join(command)
        self.output_received.emit(f""Uruchamianie: {command_str}\nw katalogu: {working_dir}\n---"", False)
        self.status_updated.emit(""Proces uruchomiony..."")
        
        try:
            self.process.setWorkingDirectory(working_dir)
            env = QProcessEnvironment.systemEnvironment()
            current_path = env.value(""PATH"", """")
            paths_to_prepend = []
            
            if python_path and os.path.exists(python_path):
                py_dir = os.path.dirname(python_path)
                current_path_dirs = [os.path.normcase(p) for p in current_path.split(os.pathsep) if p]
                if os.path.normcase(py_dir) not in current_path_dirs:
                    paths_to_prepend.append(py_dir)
            if node_path and os.path.exists(node_path):
                node_dir = os.path.dirname(node_path)
                if os.path.normcase(node_dir) not in current_path_dirs:
                    paths_to_prepend.append(node_dir)
                    
            if paths_to_prepend:
                new_path = os.pathsep.join(paths_to_prepend) + (os.pathsep + current_path if current_path else """")
                env.insert(""PATH"", new_path)
                
            self.process.setProcessEnvironment(env)
            
            # Poprawka dla Windows: odpal komendy przez cmd.exe
            if platform.system() == ""Windows"":
                self.process.start(""cmd.exe"", [""/c"", command_text])
            else:
                program = command[0]
                arguments = command[1:]
                self.process.start(program, arguments)
                
            if not self.process.waitForStarted(1000):
                error = self.process.errorString()
                self.output_received.emit(f""Nie udało się uruchomić '{command_text}': {error}"", True)
                self.status_updated.emit(f""Błąd uruchamiania: {command_text}"")
        except Exception as e:
            self.output_received.emit(f""Błąd podczas uruchamiania: {e}"", True)
            self.status_updated.emit(""Błąd uruchamiania."")
            
    def _handle_stdout(self):
        while self.process.bytesAvailable():
            data = self.process.readAllStandardOutput()
            try:
                text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                text = bytes(data).decode('utf-8', errors='replace')
            self.output_received.emit(text, False)
            
    def _handle_stderr(self):
        while self.process.bytesAvailable():
            data = self.process.readAllStandardError()
            try:
                text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                text = bytes(data).decode('utf-8', errors='replace')
            self.output_received.emit(text, True)
            
    def _handle_process_finished(self, exit_code, exit_status):
        self._handle_stdout()
        self._handle_stderr()
        self.output_received.emit(""\n--- Zakończono proces ---"", False)
        if exit_status == QProcess.ExitStatus.NormalExit and exit_code == 0:
            self.output_received.emit(f""Kod wyjścia: {exit_code}"", False)
            self.status_updated.emit(""Proces zakończony pomyślnie."")
        else:
            self.output_received.emit(f""Proces zakończony z błędem (kod: {exit_code})."", True)
            self.status_updated.emit(f""Błąd procesu. Kod wyjścia: {exit_code}"")

class AIWorker(QThread):
    result = pyqtSignal(str, bool)
    status = pyqtSignal(str)
    def __init__(self, ai_manager, message, file_content=None):
        super().__init__()
        self.ai_manager = ai_manager
        self.message = message
        self.file_content = file_content
    def run(self):
        try:
            # Dołącz plik do prompta jeśli jest
            if self.file_content:
                prompt = f""[Kontekst pliku poniżej]\n\n{self.file_content}\n\n[Twoja wiadomość]\n{self.message}""
            else:
                prompt = self.message
            response, is_error = self.ai_manager._send_message_internal(prompt)
            self.result.emit(response, is_error)
            self.status.emit(""Otrzymano odpowiedź od AI."")
        except Exception as e:
            self.result.emit(f""Błąd komunikacji z AI: {e}"", True)
            self.status.emit(""Błąd komunikacji z AI."")

class AIChatManager(QObject):
    output_received = pyqtSignal(str, bool)  # tekst, is_error
    status_updated = pyqtSignal(str)
    models_updated = pyqtSignal(list)  # lista modeli

    def __init__(self, settings, parent=None):
        super().__init__(parent)
        self.settings = settings
        self.api_key = settings.get(""api_key"", """")
        self.gemini_api_key = settings.get(""gemini_api_key"", """")
        self.mistral_api_key = settings.get(""mistral_api_key"", """")
        self.provider = settings.get(""ai_provider"", ""grok"")
        self.base_url = self._get_base_url(self.provider)
        self.current_model = settings.get(""ai_model"", ""grok-3"")
        self.conversation_history = []
        self.mistral_available = self._check_mistral_import()
        self._fetch_models()

    def _check_mistral_import(self):
        try:
            import mistralai
            # Sprawdź wersję
            from pkg_resources import get_distribution
            version = get_distribution(""mistralai"").version
            if version.startswith(""0.""):
                self.output_received.emit(""Zła wersja mistralai! Potrzebujesz 1.0.0+, masz "" + version, True)
                self.status_updated.emit(""Zła wersja biblioteki mistralai!"")
                return False
            return True
        except ImportError:
            self.output_received.emit(""Biblioteka mistralai nie jest zainstalowana! Zainstaluj: pip install mistralai"", True)
            return False

    def update_settings(self, settings):
        self.settings = settings
        self.api_key = settings.get(""api_key"", """")
        self.gemini_api_key = settings.get(""gemini_api_key"", """")
        self.mistral_api_key = settings.get(""mistral_api_key"", """")
        self.provider = settings.get(""ai_provider"", ""grok"")
        self.base_url = self._get_base_url(self.provider)
        self.current_model = settings.get(""ai_model"", ""grok-3"")
        self.mistral_available = self._check_mistral_import()
        self._fetch_models()

    def _get_base_url(self, provider):
        if provider == ""grok"":
            return ""https://api.x.ai/v1""
        elif provider == ""gemini"":
            return ""https://generativelanguage.googleapis.com/v1beta""
        elif provider == ""mistral"":
            return ""https://api.mistral.ai/v1""
        return """"

    def _fetch_models(self):
        self.models_updated.emit([])
        if self.provider == ""grok"":
            try:
                headers = {""Authorization"": f""Bearer {self.api_key}""}
                response = requests.get(f""{self.base_url}/models"", headers=headers)
                response.raise_for_status()
                models_data = response.json()
                models = [model[""id""] for model in models_data.get(""data"", []) if model.get(""id"")]
                if models:
                    self.models_updated.emit(models)
                    self.current_model = models[0] if models else ""grok-3""
                    self.status_updated.emit(""Pobrano listę modeli AI (Grok)."")
                else:
                    self.output_received.emit(""Brak dostępnych modeli w API Grok."", True)
                    self.status_updated.emit(""Błąd: Brak modeli AI Grok."")
            except Exception as e:
                self.output_received.emit(f""Błąd pobierania modeli Grok: {e}"", True)
                self.status_updated.emit(""Błąd pobierania modeli Grok."")
        elif self.provider == ""gemini"":
            try:
                models = [
                    ""gemini-1.5-flash-latest"",
                    ""gemini-1.5-pro-latest"",
                    ""gemini-2.0-flash-thinking-exp-1219"",
                    ""gemini-2.5-flash-preview-04-17""
                ]
                self.models_updated.emit(models)
                self.current_model = models[0]
                self.status_updated.emit(""Dostępne modele Gemini."")
            except Exception as e:
                self.output_received.emit(f""Błąd pobierania modeli Gemini: {e}"", True)
                self.status_updated.emit(""Błąd pobierania modeli Gemini."")
        elif self.provider == ""mistral"":
            if not self.mistral_available:
                self.models_updated.emit([])
                self.status_updated.emit(""Biblioteka mistralai nie jest zainstalowana!"")
                return
            try:
                from mistralai import Mistral
                client = Mistral(api_key=self.mistral_api_key)
                models_data = client.models.list()
                # Poprawka: models_data może być listą Model lub mieć atrybut .data
                if hasattr(models_data, 'data'):
                    models = [m.id for m in models_data.data]
                else:
                    models = [m.id for m in models_data]
                self.models_updated.emit(models)
                if models:
                    self.current_model = models[0]
                    self.status_updated.emit(f""Pobrano modele Mistral: {', '.join(models)}"")
                else:
                    self.output_received.emit(""Brak dostępnych modeli w API Mistral."", True)
                    self.status_updated.emit(""Brak modeli Mistral."")
            except Exception as e:
                self.output_received.emit(f""Błąd pobierania modeli Mistral: {e}"", True)
                self.status_updated.emit(""Błąd pobierania modeli Mistral."")

    def set_model(self, model):
        self.current_model = model
        self.status_updated.emit(f""Zmieniono model na: {model}"")

    def set_provider(self, provider):
        self.provider = provider
        self.base_url = self._get_base_url(self.provider)
        self.mistral_available = self._check_mistral_import()
        self._fetch_models()

    def send_message(self, message, file_content=None):
        if not message.strip():
            self.output_received.emit(""Wiadomość nie może być pusta."", True)
            return
        self.conversation_history.append({""role"": ""user"", ""content"": message})
        self.output_received.emit(f""Użytkownik: {message}"", False)
        # Uruchom AIWorker w tle
        self.worker = AIWorker(self, message, file_content)
        self.worker.result.connect(self._handle_ai_result)
        self.worker.status.connect(self.status_updated)
        self.worker.start()

    def _handle_ai_result(self, text, is_error):
        if not is_error:
            self.conversation_history.append({""role"": ""assistant"", ""content"": text})
        self.output_received.emit(f""AI: {text}"", is_error)

    def _send_message_internal(self, prompt):
        # To jest wywoływane w wątku!
        try:
            if self.provider == ""grok"":
                headers = {
                    ""Authorization"": f""Bearer {self.api_key}"",
                    ""Content-Type"": ""application/json""
                }
                payload = {
                    ""model"": self.current_model,
                    ""messages"": self.conversation_history[:-1] + [{""role"": ""user"", ""content"": prompt}],
                    ""max_tokens"": 2048,
                    ""stream"": False
                }
                response = requests.post(f""{self.base_url}/chat/completions"", headers=headers, json=payload)
                response.raise_for_status()
                response_data = response.json()
                assistant_message = response_data[""choices""][0][""message""][""content""]
                return assistant_message, False
            elif self.provider == ""gemini"":
                headers = {""Content-Type"": ""application/json""}
                params = {""key"": self.gemini_api_key}
                payload = {
                    ""contents"": [
                        {""role"": ""user"", ""parts"": [{""text"": prompt}]}
                    ]
                }
                url = f""{self.base_url}/models/{self.current_model}:generateContent""
                response = requests.post(url, headers=headers, params=params, json=payload)
                response.raise_for_status()
                response_data = response.json()
                try:
                    assistant_message = response_data[""candidates""][0][""content""][""parts""][0][""text""]
                except Exception:
                    assistant_message = str(response_data)
                return assistant_message, False
            elif self.provider == ""mistral"":
                if not self.mistral_available:
                    return (""Biblioteka mistralai nie jest zainstalowana! Zainstaluj: pip install mistralai"", True)
                from mistralai import Mistral, UserMessage, AssistantMessage
                client = Mistral(api_key=self.mistral_api_key)
                messages = [
                    UserMessage(content=msg[""content""]) if msg[""role""] == ""user""
                    else AssistantMessage(content=msg[""content""])
                    for msg in self.conversation_history[:-1]
                ]
                messages.append(UserMessage(content=prompt))
                response = client.chat.complete(
                    model=self.current_model,
                    messages=messages,
                    max_tokens=2048
                )
                assistant_message = response.choices[0].message.content
                return assistant_message, False
            else:
                return (""Nieobsługiwany provider AI."", True)
        except Exception as e:
            return (f""Błąd komunikacji z API: {e}"", True)

    def clear_conversation(self):
        self.conversation_history = []
        self.output_received.emit(""Historia rozmowy wyczyszczona."", False)
        self.status_updated.emit(""Wyczyszczono rozmowę."")

class ConsoleWidget(QWidget):
    def __init__(self, console_manager, ai_chat_manager, parent=None):
        super().__init__(parent)
        self.console_manager = console_manager
        self.ai_chat_manager = ai_chat_manager
        self.current_file_path = None  # Dodane: ścieżka do otwartego pliku
        self._setup_ui()
        self._setup_connections()

    def set_current_file(self, file_path):
        self.current_file_path = file_path

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)
        self.console_tab = QWidget()
        console_layout = QVBoxLayout(self.console_tab)
        console_layout.setContentsMargins(0, 0, 0, 0)
        self.console = QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setFont(QFont(""Courier New"", 10))
        console_layout.addWidget(self.console, 1)
        self.console_input = QLineEdit()
        self.console_input.setPlaceholderText(""Wpisz polecenie..."")
        console_layout.addWidget(self.console_input, 0)
        console_buttons_layout = QHBoxLayout()
        console_buttons_layout.addStretch(1)
        self.clear_console_button = QPushButton(""Wyczyść konsolę"")
        console_buttons_layout.addWidget(self.clear_console_button)
        self.copy_console_button = QPushButton(""Skopiuj"")
        console_buttons_layout.addWidget(self.copy_console_button)
        console_layout.addLayout(console_buttons_layout)
        self.tab_widget.addTab(self.console_tab, ""Konsola"")
        # Zakładka Chat AI
        self.ai_tab = QWidget()
        ai_layout = QVBoxLayout(self.ai_tab)
        ai_layout.setContentsMargins(0, 0, 0, 0)
        # ZAMIANA: QTextEdit zamiast QPlainTextEdit
        self.ai_chat = QTextEdit()
        self.ai_chat.setReadOnly(True)
        self.ai_chat.setFont(QFont(""Courier New"", 10))
        ai_layout.addWidget(self.ai_chat, 1)
        ai_input_layout = QHBoxLayout()
        # Dodaj wybór providera AI
        self.ai_provider_combo = QComboBox()
        self.ai_provider_combo.addItems([""grok"", ""gemini"", ""mistral""])
        self.ai_provider_combo.setCurrentText(self.ai_chat_manager.provider)
        # Blokada wyboru Mistral jeśli nie ma biblioteki
        try:
            import mistralai
            mistral_ok = True
        except ImportError:
            mistral_ok = False
        idx = self.ai_provider_combo.findText(""mistral"")
        if idx != -1:
            self.ai_provider_combo.model().item(idx).setEnabled(mistral_ok)
            if not mistral_ok and self.ai_provider_combo.currentText() == ""mistral"":
                self.ai_provider_combo.setCurrentText(""grok"")
        ai_input_layout.addWidget(self.ai_provider_combo)
        self.ai_model_combo = QComboBox()
        self.ai_model_combo.setPlaceholderText(""Wybierz model..."")
        ai_input_layout.addWidget(self.ai_model_combo)
        self.ai_input = QLineEdit()
        self.ai_input.setPlaceholderText(""Wpisz wiadomość do AI..."")
        ai_input_layout.addWidget(self.ai_input)
        self.ai_send_button = QPushButton(""Wyślij"")
        ai_input_layout.addWidget(self.ai_send_button)
        self.ai_clear_button = QPushButton(""Wyczyść"")
        ai_input_layout.addWidget(self.ai_clear_button)
        ai_layout.addLayout(ai_input_layout)
        self.tab_widget.addTab(self.ai_tab, ""Chat AI"")

    def _setup_connections(self):
        self.console_manager.output_received.connect(self._append_console_output)
        self.console_input.returnPressed.connect(self._run_console_command)
        self.clear_console_button.clicked.connect(self.console.clear)
        self.copy_console_button.clicked.connect(self._copy_console)
        self.ai_chat_manager.output_received.connect(self._append_ai_output)
        self.ai_chat_manager.models_updated.connect(self._update_model_combo)
        self.ai_input.returnPressed.connect(self._send_ai_message)
        self.ai_send_button.clicked.connect(self._send_ai_message)
        self.ai_clear_button.clicked.connect(self.ai_chat_manager.clear_conversation)
        self.ai_model_combo.currentTextChanged.connect(self.ai_chat_manager.set_model)
        # Nowe: zmiana providera AI z poziomu UI
        self.ai_provider_combo.currentTextChanged.connect(self._on_provider_changed)

    def _on_provider_changed(self, provider):
        self.ai_chat_manager.set_provider(provider)
        # Po zmianie providera, pobierz modele tylko dla niego
        # (AIChatManager sam wywołuje _fetch_models, a sygnał models_updated odświeża model_combo)

    def _append_console_output(self, text, is_error):
        cursor = self.console.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        fmt = QTextCharFormat()
        if is_error:
            fmt.setForeground(QColor(""#DC143C""))
        cursor.setCharFormat(fmt)
        text_to_insert = text + ('\n' if text and not text.endswith('\n') else '')
        cursor.insertText(text_to_insert)
        self.console.setTextCursor(cursor)
        self.console.ensureCursorVisible()

    def _append_ai_output(self, text, is_error):
        # Jeśli to błąd, wyświetl na czerwono bez HTML
        if is_error:
            cursor = self.ai_chat.textCursor()
            cursor.movePosition(cursor.MoveOperation.End)
            fmt = QTextCharFormat()
            fmt.setForeground(QColor(""#DC143C""))
            cursor.setCharFormat(fmt)
            text_to_insert = text + ('\n' if text and not text.endswith('\n') else '')
            cursor.insertText(text_to_insert)
            self.ai_chat.setTextCursor(cursor)
            self.ai_chat.ensureCursorVisible()
            return
        # Zamiana Markdown na HTML
        html = markdown2.markdown(text, extras=[""fenced-code-blocks"", ""tables"", ""strike"", ""cuddled-lists"", ""code-friendly""]) 
        # Dodanie stylu dla bloków kodu i przycisku kopiowania
        html = html.replace('<code>', '<code style=""background:#f6f8fa; border-radius:4px; padding:2px 4px;"">')
        html = html.replace('<pre><code', '<div style=""position:relative;""><button onclick=\'navigator.clipboard.writeText(this.nextElementSibling.innerText)\' style=\'position:absolute;top:4px;right:4px;z-index:2;font-size:10px;padding:2px 6px;\'>Kopiuj kod</button><pre style=""background:#f6f8fa;border-radius:6px;padding:8px 12px;overflow:auto;""><code')
        html = html.replace('</code></pre>', '</code></pre></div>')
        self.ai_chat.moveCursor(self.ai_chat.textCursor().End)
        self.ai_chat.insertHtml(html + ""<br>"")
        self.ai_chat.ensureCursorVisible()

    def _copy_console(self):
        console_text = self.console.toPlainText()
        if console_text:
            QApplication.clipboard().setText(console_text)

    def _run_console_command(self):
        command = self.console_input.text().strip()
        if command:
            self.console_input.clear()
            self.console_manager.run_command(command, os.getcwd())

    def _send_ai_message(self):
        message = self.ai_input.text().strip()
        if message:
            self.ai_input.clear()
            file_content = None
            if self.current_file_path:
                try:
                    with open(self.current_file_path, 'r', encoding='utf-8') as f:
                        file_content = f.read()
                except Exception:
                    file_content = None
            self.ai_chat_manager.send_message(message, file_content=file_content)

    def _update_model_combo(self, models):
        self.ai_model_combo.clear()
        if models:
            self.ai_model_combo.addItems(models)
            if self.ai_chat_manager.current_model in models:
                self.ai_model_combo.setCurrentText(self.ai_chat_manager.current_model)

Ścieżka: /src/dialogs.py
Rozmiar: 12,94 KB
Zawartość:
# Dialogi dla IDE – tworzenie projektów, plików, zmiana nazw, ustawienia
# /src/dialogs.py

import os
import re
import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from PyQt6.QtWidgets import (
    QDialog, QFormLayout, QLineEdit, QDialogButtonBox, QHBoxLayout,
    QPushButton, QComboBox, QFileDialog, QLabel, QSpinBox, QVBoxLayout,
    QTableWidget, QTableWidgetItem, QHeaderView, QMessageBox
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QFont

class NewProjectDialog(QDialog):
    def __init__(self, projects_dir, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Nowy projekt"")
        self.projects_dir = projects_dir
        self.setModal(True)
        layout = QFormLayout(self)
        self.name_edit = QLineEdit()
        layout.addRow(""Nazwa projektu:"", self.name_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(""Utwórz"")
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.name_edit.textChanged.connect(self._validate_name)
        self.name_edit.textChanged.emit(self.name_edit.text())

    def _validate_name(self, name):
        name = name.strip()
        is_empty = not name
        is_valid_chars = re.fullmatch(r'[a-zA-Z0-9_-]+', name) is not None or name == """"
        full_path = os.path.join(self.projects_dir, name)
        dir_exists = os.path.exists(full_path)
        enable_ok = not is_empty and is_valid_chars and not dir_exists
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_ok)
        if is_empty:
            self.name_edit.setToolTip(""Nazwa projektu nie może być pusta."")
        elif not is_valid_chars:
            self.name_edit.setToolTip(""Nazwa projektu może zawierać tylko litery, cyfry, podkreślenia i myślniki."")
        elif dir_exists:
            self.name_edit.setToolTip(f""Projekt o nazwie '{name}' już istnieje w:\n{self.projects_dir}"")
        else:
            self.name_edit.setToolTip(f""Katalog projektu zostanie utworzony w:\n{full_path}"")
        if not enable_ok and not is_empty:
            self.name_edit.setStyleSheet(""background-color: #ffe0e0;"")
        else:
            self.name_edit.setStyleSheet("""")

    def get_project_name(self):
        return self.name_edit.text().strip()

    def get_project_path(self):
        return os.path.join(self.projects_dir, self.get_project_name())

class NewItemDialog(QDialog):
    def __init__(self, parent_dir, is_folder=False, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Nowy folder"" if is_folder else ""Nowy plik"")
        self.parent_dir = parent_dir
        self.is_folder = is_folder
        self.setModal(True)
        layout = QFormLayout(self)
        self.item_type_label = ""Nazwa folderu:"" if is_folder else ""Nazwa pliku:""
        self.name_edit = QLineEdit()
        layout.addRow(self.item_type_label, self.name_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.name_edit.textChanged.connect(self._validate_name)
        self.name_edit.textChanged.emit(self.name_edit.text())

    def _validate_name(self, name):
        name = name.strip()
        is_empty = not name
        illegal_chars_pattern = r'[<>:""/\\|?*\x00-\x1F]'
        is_valid_chars = re.search(illegal_chars_pattern, name) is None
        full_path = os.path.join(self.parent_dir, name)
        item_exists = os.path.exists(full_path)
        enable_create = not is_empty and is_valid_chars and not item_exists
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_create)
        if is_empty:
            self.name_edit.setToolTip(f""{self.item_type_label} nie może być pusta."")
        elif not is_valid_chars:
            self.name_edit.setToolTip(""Nazwa zawiera niedozwolone znaki."")
        elif item_exists:
            self.name_edit.setToolTip(f""Element o nazwie '{name}' już istnieje w:\n{self.parent_dir}"")
        else:
            self.name_edit.setToolTip("""")
        if not enable_create and not is_empty:
            self.name_edit.setStyleSheet(""background-color: #ffe0e0;"")
        else:
            self.name_edit.setStyleSheet("""")

    def get_item_name(self):
        return self.name_edit.text().strip()

class RenameItemDialog(QDialog):
    def __init__(self, current_path, parent=None):
        super().__init__(parent)
        self.current_path = current_path
        self.is_folder = os.path.isdir(current_path)
        old_name = os.path.basename(current_path)
        self.setWindowTitle(""Zmień nazwę"")
        layout = QFormLayout(self)
        self.label = QLabel(f""Nowa nazwa dla '{old_name}':"")
        self.line_edit = QLineEdit(old_name)
        layout.addRow(self.label, self.line_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.line_edit.textChanged.connect(self._validate_name)
        self._validate_name(self.line_edit.text())

    def _validate_name(self, name):
        name = name.strip()
        is_empty = not name
        illegal_chars_pattern = r'[<>:""/\\|?*\x00-\x1F]'
        is_valid_chars = re.search(illegal_chars_pattern, name) is None
        old_name = os.path.basename(self.current_path)
        is_same_name = name == old_name
        parent_dir = os.path.dirname(self.current_path)
        new_full_path = os.path.join(parent_dir, name)
        item_exists_at_new_path = os.path.exists(new_full_path)
        enable_ok = not is_empty and is_valid_chars and (is_same_name or not item_exists_at_new_path)
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_ok)

    def get_new_name(self):
        return self.line_edit.text().strip()

class SettingsDialog(QDialog):
    def __init__(self, current_settings, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Ustawienia IDE"")
        self.current_settings = current_settings.copy()
        self.setMinimumWidth(400)
        self.setModal(True)
        self._setup_ui()

    def _setup_ui(self):
        layout = QFormLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        self.theme_combo = QComboBox()
        self.theme_combo.addItems([""light"", ""dark""])
        self.theme_combo.setCurrentText(self.current_settings.get(""theme"", ""light""))
        layout.addRow(""Motyw:"", self.theme_combo)

        self.python_path_input = QLineEdit()
        self.python_path_input.setText(self.current_settings.get(""python_path"", """"))
        self.python_browse_button = QPushButton(""Przeglądaj..."")
        self.python_browse_button.clicked.connect(self._browse_python_path)
        python_layout = QHBoxLayout()
        python_layout.addWidget(self.python_path_input)
        python_layout.addWidget(self.python_browse_button)
        layout.addRow(""Ścieżka Python:"", python_layout)

        self.node_path_input = QLineEdit()
        self.node_path_input.setText(self.current_settings.get(""node_path"", """"))
        self.node_browse_button = QPushButton(""Przeglądaj..."")
        self.node_browse_button.clicked.connect(self._browse_node_path)
        node_layout = QHBoxLayout()
        node_layout.addWidget(self.node_path_input)
        node_layout.addWidget(self.node_browse_button)
        layout.addRow(""Ścieżka Node.js:"", node_layout)

        # Nowy wybór dostawcy AI
        self.ai_provider_combo = QComboBox()
        self.ai_provider_combo.addItems([""grok"", ""gemini"", ""mistral""])
        self.ai_provider_combo.setCurrentText(self.current_settings.get(""ai_provider"", ""grok""))
        layout.addRow(""Dostawca AI:"", self.ai_provider_combo)

        # Klucz API xAI
        self.api_key_input = QLineEdit()
        self.api_key_input.setText(self.current_settings.get(""api_key"", """"))
        self.api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow(""Klucz API xAI:"", self.api_key_input)
        # Klucz API Gemini
        self.gemini_api_key_input = QLineEdit()
        self.gemini_api_key_input.setText(self.current_settings.get(""gemini_api_key"", """"))
        self.gemini_api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow(""Klucz API Gemini:"", self.gemini_api_key_input)
        # Klucz API Mistral
        self.mistral_api_key_input = QLineEdit()
        self.mistral_api_key_input.setText(self.current_settings.get(""mistral_api_key"", """"))
        self.mistral_api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addRow(""Klucz API Mistral:"", self.mistral_api_key_input)

        # Model AI – dynamicznie aktualizowany przez AIChatManager
        self.ai_model_combo = QComboBox()
        self.ai_model_combo.addItems([self.current_settings.get(""ai_model"", ""grok-3"")])
        self.ai_model_combo.setCurrentText(self.current_settings.get(""ai_model"", ""grok-3""))
        layout.addRow(""Model AI:"", self.ai_model_combo)

        self.font_size_combo = QComboBox()
        self.font_size_combo.addItems([str(i) for i in range(8, 21)])
        self.font_size_combo.setCurrentText(str(self.current_settings.get(""editor_font_size"", 10)))
        layout.addRow(""Rozmiar czcionki edytora:"", self.font_size_combo)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

        # Zmiana widoczności kluczy API w zależności od dostawcy
        self.ai_provider_combo.currentTextChanged.connect(self._update_api_key_visibility)
        self._update_api_key_visibility(self.ai_provider_combo.currentText())
        # Blokada wyboru Mistral jeśli nie ma biblioteki
        self._block_mistral_if_missing()

    def _block_mistral_if_missing(self):
        try:
            import mistralai
            mistral_ok = True
        except ImportError:
            mistral_ok = False
        idx = self.ai_provider_combo.findText(""mistral"")
        if idx != -1:
            self.ai_provider_combo.model().item(idx).setEnabled(mistral_ok)
            if not mistral_ok and self.ai_provider_combo.currentText() == ""mistral"":
                self.ai_provider_combo.setCurrentText(""grok"")

    def _update_api_key_visibility(self, provider):
        self.api_key_input.setEnabled(provider == ""grok"")
        self.gemini_api_key_input.setEnabled(provider == ""gemini"")
        self.mistral_api_key_input.setEnabled(provider == ""mistral"")

    def _browse_python_path(self):
        # Wybierz Pythona, jakbyś wybierał psa na spacer 🐶
        file_path, _ = QFileDialog.getOpenFileName(
            self, ""Wybierz plik wykonywalny Pythona"", """",
            ""Pliki wykonywalne (*.exe);;Wszystkie pliki (*)""
        )
        if file_path:
            self.python_path_input.setText(file_path)

    def _browse_node_path(self):
        # Node.js – dla fanów async chaosu 😜
        file_path, _ = QFileDialog.getOpenFileName(
            self, ""Wybierz plik wykonywalny Node.js"", """",
            ""Pliki wykonywalne (*.exe);;Wszystkie pliki (*)""
        )
        if file_path:
            self.node_path_input.setText(file_path)

    def get_settings(self):
        # Zwraca ustawienia jak pizzę – wszystko, czego chciałeś 🍕
        api_key = self.api_key_input.text()
        gemini_api_key = self.gemini_api_key_input.text()
        mistral_api_key = self.mistral_api_key_input.text()
        # Jeśli przez przypadek pole zostało nadpisane funkcją, wymuś string
        if not isinstance(api_key, str):
            api_key = str(api_key)
        if not isinstance(gemini_api_key, str):
            gemini_api_key = str(gemini_api_key)
        if not isinstance(mistral_api_key, str):
            mistral_api_key = str(mistral_api_key)
        return {
            ""theme"": self.theme_combo.currentText(),
            ""python_path"": self.python_path_input.text().strip(),
            ""node_path"": self.node_path_input.text().strip(),
            ""ai_provider"": self.ai_provider_combo.currentText(),
            ""api_key"": api_key.strip(),
            ""gemini_api_key"": gemini_api_key.strip(),
            ""mistral_api_key"": mistral_api_key.strip(),
            ""ai_model"": self.ai_model_combo.currentText(),
            ""editor_font_size"": int(self.font_size_combo.currentText())
        }

Ścieżka: /src/filesystem.py
Rozmiar: 2,23 KB
Zawartość:
# Model systemu plików
#/src/filesystem.py

import os
from PyQt6.QtGui import QFileSystemModel
from PyQt6.QtCore import Qt
try:
    import qtawesome as qta
except ImportError:
    qta = None

class CustomFileSystemModel(QFileSystemModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon_map = {
            '.py': 'fa5s.file-code',
            '.js': 'fa5s.file-code',
            '.json': 'fa5s.file-code',
            '.html': 'fa5s.file-code',
            '.css': 'fa5s.file-code',
            '.ini': 'fa5s.file-alt',
            '.txt': 'fa5s.file-alt',
            '.md': 'fa5s.file-alt',
            '.c': 'fa5s.file-code',
            '.cpp': 'fa5s.file-code',
            '.h': 'fa5s.file-code',
            '.hpp': 'fa5s.file-code',
        }
        self.folder_icon_name = 'fa5s.folder'
        self.default_file_icon_name = 'fa5s.file'
        self._has_qtawesome = qta is not None

    def rename(self, index, new_name):
        if not index.isValid():
            return False
        old_path = self.filePath(index)
        new_path = os.path.join(os.path.dirname(old_path), new_name)
        try:
            os.rename(old_path, new_path)
            self.refresh()
            return True
        except Exception as e:
            print(f""Błąd zmiany nazwy: {e}"")
            return False

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DecorationRole:
            file_info = self.fileInfo(index)
            if file_info.isDir():
                return qta.icon(self.folder_icon_name) if self._has_qtawesome else super().data(index, role)
            elif file_info.isFile():
                extension = file_info.suffix().lower()
                dotted_extension = '.' + extension
                if dotted_extension in self.icon_map and self._has_qtawesome:
                    return qta.icon(self.icon_map[dotted_extension])
                return qta.icon(self.default_file_icon_name) if self._has_qtawesome else super().data(index, role)
        return super().data(index, role)

    def refresh(self, *args):
        self.setRootPath(self.rootPath())

Ścieżka: /src/highlighter.py
Rozmiar: 3,31 KB
Zawartość:
# Kolorowanie składni dla edytora
#/src/highlighter.py

import re
from PyQt6.QtGui import QSyntaxHighlighter, QTextDocument
from src.config import FORMAT_DEFAULT, FORMAT_COMMENT, HIGHLIGHTING_RULES

class CodeSyntaxHighlighter(QSyntaxHighlighter):
    def __init__(self, parent: QTextDocument, language: str):
        super().__init__(parent)
        self._language = language.lower()
        self._rules = []
        lang_config = HIGHLIGHTING_RULES.get(self._language, {})
        keywords = lang_config.get('keywords', [])
        builtins = lang_config.get('builtins', [])
        patterns = lang_config.get('patterns', [])
        for keyword in keywords:
            pattern = r'\b' + re.escape(keyword) + r'\b'
            self._rules.append((re.compile(pattern), lang_config.get('keyword_format', FORMAT_DEFAULT)))
        for builtin in builtins:
            pattern = r'\b' + re.escape(builtin) + r'\b'
            self._rules.append((re.compile(pattern), lang_config.get('builtin_format', FORMAT_DEFAULT)))
        for pattern_str, format, *flags in patterns:
            try:
                pattern = re.compile(pattern_str, *flags)
                self._rules.append((pattern, format))
            except re.error as e:
                print(f""Błąd regex '{pattern_str}' dla {self._language}: {e}"")

    def highlightBlock(self, text: str):
        self.setFormat(0, len(text), FORMAT_DEFAULT)
        self.setCurrentBlockState(0)
        block_comment_delimiters = []
        if self._language in ['javascript', 'css', 'c++']:
            block_comment_delimiters.append((""/*"", ""*/"", FORMAT_COMMENT))
        comment_start_in_prev_block = (self.previousBlockState() == 1)
        if comment_start_in_prev_block:
            end_delimiter_index = text.find(""*/"")
            if end_delimiter_index >= 0:
                self.setFormat(0, end_delimiter_index + 2, FORMAT_COMMENT)
                self.setCurrentBlockState(0)
                start_pos = end_delimiter_index + 2
            else:
                self.setFormat(0, len(text), FORMAT_COMMENT)
                self.setCurrentBlockState(1)
                return
        else:
            start_pos = 0
        start_delimiter = ""/*""
        end_delimiter = ""*/""
        startIndex = text.find(start_delimiter, start_pos)
        while startIndex >= 0:
            endIndex = text.find(end_delimiter, startIndex)
            if endIndex >= 0:
                length = endIndex - startIndex + len(end_delimiter)
                self.setFormat(startIndex, startIndex + length, FORMAT_COMMENT)
                startIndex = text.find(start_delimiter, startIndex + length)
            else:
                self.setFormat(startIndex, len(text) - startIndex, FORMAT_COMMENT)
                self.setCurrentBlockState(1)
                break
        for pattern, format in self._rules:
            if format == FORMAT_COMMENT and (pattern.pattern.startswith(re.escape('/*')) or pattern.pattern.startswith(re.escape('<!--'))):
                continue
            if format == FORMAT_COMMENT and pattern.pattern.startswith('//') and self.currentBlockState() == 1:
                continue
            for match in pattern.finditer(text):
                start, end = match.span()
                self.setFormat(start, end, format)

                

Ścieżka: /src/models.py
Rozmiar: 1,48 KB
Zawartość:
# Modele danych aplikacji
#/src/models.py

import os
import json
from src.config import SETTINGS_FILE, RECENTS_FILE

class AppState:
    def __init__(self):
        self.settings = {
            ""theme"": ""light"",
            ""python_path"": """",
            ""node_path"": """",
            ""show_tree"": True,
            ""show_console"": True,
            ""editor_font_size"": 10
        }
        self.recents = {""last_project_dir"": None, ""open_files"": []}

    def load(self):
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    self.settings.update(json.load(f))
            if os.path.exists(RECENTS_FILE):
                with open(RECENTS_FILE, 'r', encoding='utf-8') as f:
                    self.recents.update(json.load(f))
        except Exception as e:
            print(f""Błąd wczytywania stanu: {e}"")

    def save(self, open_files, project_dir):
        try:
            self.recents[""open_files""] = list(open_files)
            if project_dir and os.path.isdir(project_dir):
                self.recents[""last_project_dir""] = os.path.normpath(project_dir)
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=4)
            with open(RECENTS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.recents, f, indent=4)
        except Exception as e:
            print(f""Błąd zapisu stanu: {e}"")

Ścieżka: /src/package_manager.py
Rozmiar: 41,10 KB
Zawartość:
import os
import re
import requests
import zipfile
import tarfile
import json
import shutil
import subprocess
import py7zr
from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QProgressBar, QTableWidget, QTableWidgetItem, QHeaderView, QPushButton, QApplication, QHBoxLayout, QWidget
from PyQt6.QtCore import QThread, pyqtSignal, Qt
from PyQt6.QtGui import QColor, QIcon
from src.theme import get_dark_package_manager_stylesheet, get_light_package_manager_stylesheet

# Ustaw katalog do przechowywania pakietów, tworząc go, jeśli nie istnieje
PACKAGES_DIR = os.path.abspath(""packages"")
os.makedirs(PACKAGES_DIR, exist_ok=True)

class DownloadWorker(QThread):
    """"""Klasa wątku do obsługi pobierania i instalacji pakietów w tle.""""""
    progress = pyqtSignal(int)  # Sygnał wysyłający postęp operacji (0-100)
    finished = pyqtSignal(str)  # Sygnał wysyłający komunikat o pomyślnym zakończeniu
    error = pyqtSignal(str)     # Sygnał wysyłający komunikat o błędzie

    def __init__(self, func, package_name):
        """"""
        Inicjalizuje wątek.
        :param func: Funkcja do wykonania w wątku (np. instalacja).
        :param package_name: Nazwa pakietu do wyświetlania w komunikatach.
        """"""
        super().__init__()
        self.func = func
        self.package_name = package_name

    def run(self):
        """"""Główna pętla wątku, wykonująca przekazaną funkcję.""""""
        try:
            self.func(progress_callback=self.progress.emit)
            self.finished.emit(f""Operacja dla {self.package_name} zakończona pomyślnie."")
        except Exception as e:
            self.error.emit(f""Błąd podczas operacji dla {self.package_name}: {str(e)}"")

class PackageManager:
    """"""Klasa zarządzająca pakietami (pobieranie, instalacja, odinstalowanie).""""""
    def __init__(self, parent=None):
        """"""
        Inicjalizuje menadżera pakietów.
        :param parent: Obiekt nadrzędny (opcjonalne, dla kontekstu ścieżki).
        """"""
        self.parent = parent
        base_dir = os.path.dirname(__file__) if '__file__' in locals() else os.getcwd()
        self.settings_path = os.path.abspath(os.path.join(base_dir, "".."", ""userdata"", ""settings.json""))
        os.makedirs(os.path.dirname(self.settings_path), exist_ok=True)

    def _download_file(self, url, dest_path, progress_callback=None):
        """"""
        Pobiera plik z podanego URL do wskazanej ścieżki.
        :param url: Adres URL pliku.
        :param dest_path: Ścieżka docelowa zapisu pliku.
        :param progress_callback: Funkcja callback do raportowania postępu.
        """"""
        try:
            response = requests.get(url, stream=True, timeout=15)
            response.raise_for_status()
            total = int(response.headers.get('content-length', 0))
            downloaded = 0
            with open(dest_path, ""wb"") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total > 0 and progress_callback:
                            percent = int(downloaded * 100 / total)
                            progress_callback(percent)
            if progress_callback:
                progress_callback(100)
        except requests.exceptions.Timeout:
            raise RuntimeError(f""Upłynął czas oczekiwania na odpowiedź serwera podczas pobierania z {url}"")
        except requests.RequestException as e:
            raise RuntimeError(f""Błąd podczas pobierania pliku z {url}: {str(e)}"")

    def _extract_archive(self, file_path, extract_to):
        """"""
        Rozpakowuje archiwum (ZIP, TAR.GZ lub 7Z) do wskazanego katalogu.
        :param file_path: Ścieżka do pliku archiwum.
        :param extract_to: Ścieżka do katalogu docelowego rozpakowania.
        """"""
        os.makedirs(extract_to, exist_ok=True)
        try:
            if file_path.lower().endswith("".zip""):
                with zipfile.ZipFile(file_path, 'r') as zip_ref:
                    for member in zip_ref.namelist():
                        fname = member.split('/', 1)[1] if '/' in member else member
                        if fname:
                            target_path = os.path.join(extract_to, fname)
                            if member.endswith('/'):
                                os.makedirs(target_path, exist_ok=True)
                            else:
                                os.makedirs(os.path.dirname(target_path), exist_ok=True)
                                with open(target_path, 'wb') as f:
                                    f.write(zip_ref.read(member))
            elif file_path.lower().endswith(("".tar.gz"", "".tgz"")):
                with tarfile.open(file_path, 'r:gz') as tar_ref:
                    tar_ref.extractall(extract_to)
            elif file_path.lower().endswith("".7z""):
                with py7zr.SevenZipFile(file_path, mode='r') as z:
                    z.extractall(extract_to)
            else:
                raise ValueError(f""Nieobsługiwany format archiwum: {file_path}"")
        except (zipfile.BadZipFile, tarfile.TarError, py7zr.Py7zrError) as e:
            raise RuntimeError(f""Błąd podczas rozpakowywania archiwum {os.path.basename(file_path)}: {str(e)}"")
        except Exception as e:
            raise RuntimeError(f""Nieoczekiwany błąd podczas rozpakowywania: {str(e)}"")

    def _get_local_version(self, package):
        """"""
        Pobiera lokalnie zainstalowaną wersję pakietu.
        :param package: Nazwa pakietu.
        :return: Wersja lub None.
        """"""
        exe_path = self._get_setting(f""{package.lower()}_path"")
        if not exe_path or not os.path.exists(exe_path):
            return None
        try:
            if package == ""Python"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[-1]
            elif package == ""Node.js"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().lstrip('v')
            elif package == ""Go"":
                result = subprocess.run([exe_path, ""version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[2].lstrip('go')
            elif package == ""Java"":
                result = subprocess.run([exe_path, ""-version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[2].strip('""')
            elif package == ""Ruby"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[1]
            elif package == ""Rust"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[1]
            elif package == ""Git"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[-1]
            elif package == ""Docker"":
                result = subprocess.run([exe_path, ""--version""], capture_output=True, text=True, check=True, encoding='utf-8')
                return result.stdout.strip().split()[2].rstrip(',')
        except (subprocess.CalledProcessError, FileNotFoundError, OSError):
            return None
        return None

    def _get_latest_version(self, package):
        """"""
        Pobiera najnowszą wersję pakietu ze źródeł zewnętrznych.
        :param package: Nazwa pakietu.
        :return: Wersja lub None.
        """"""
        try:
            if package == ""Python"":
                url = ""https://www.python.org/ftp/python/index-windows.json""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                data = response.json()
                versions = [v for v in data[""versions""] if v.get(""url"", """").endswith("".zip"") and ""64"" in v.get(""id"", """") and v.get(""sort-version"", """").replace(""."", """").isdigit()]
                if not versions:
                    return None
                return sorted(versions, key=lambda v: list(map(int, v[""sort-version""].split("".""))), reverse=True)[0][""sort-version""]
            elif package == ""Node.js"":
                shasums_url = ""https://nodejs.org/dist/latest/SHASUMS256.txt""
                response = requests.get(shasums_url, timeout=10)
                response.raise_for_status()
                pattern = r""^[a-f0-9]{64}\s+(node-v([\d.]+)-win-x64\.zip)$""
                for line in response.text.splitlines():
                    match = re.match(pattern, line, re.MULTILINE)
                    if match:
                        return match.group(2)
                return None
            elif package == ""Go"":
                url = ""https://go.dev/dl/""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""go(\d+\.\d+\.\d+)\.windows-amd64\.zip""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Java"":
                url = ""https://jdk.java.net/21/""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""openjdk-(\d+)_windows-x64_bin\.zip""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Ruby"":
                url = ""https://rubyinstaller.org/downloads/""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""rubyinstaller-(\d+\.\d+\.\d+-\d+)-x64\.7z""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Rust"":
                url = ""https://static.rust-lang.org/dist/channel-rust-stable.toml""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""version = \""(\d+\.\d+\.\d+)\""""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Git"":
                url = ""https://git-scm.com/download/win""
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                pattern = r""Git-(\d+\.\d+\.\d+)-64-bit\.exe""
                match = re.search(pattern, response.text)
                return match.group(1) if match else None
            elif package == ""Docker"":
                url = ""https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe""
                response = requests.head(url, timeout=10)
                response.raise_for_status()
                return ""latest""  # Docker Desktop nie publikuje wersji wprost
        except requests.RequestException:
            return None
        return None

    def _is_installed(self, package):
        """"""
        Sprawdza, czy pakiet jest zainstalowany.
        :param package: Nazwa pakietu.
        :return: True, jeśli zainstalowany, inaczej False.
        """"""
        if package == ""Python"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""python"", ""python.exe""))
        elif package == ""Node.js"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""node.js"", ""node.exe""))
        elif package == ""Go"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""go"", ""bin"", ""go.exe""))
        elif package == ""Java"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""java"", ""bin"", ""java.exe""))
        elif package == ""Ruby"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""ruby"", ""bin"", ""ruby.exe""))
        elif package == ""Rust"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""rust"", ""bin"", ""cargo.exe""))
        elif package == ""Git"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""git"", ""bin"", ""git.exe""))
        elif package == ""Docker"":
            return os.path.exists(os.path.join(PACKAGES_DIR, ""docker"", ""Docker"", ""Docker Desktop.exe""))
        return False

    def install_latest_python(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Pythona.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url_index = ""https://www.python.org/ftp/python/index-windows.json""
            response = requests.get(url_index, timeout=10)
            response.raise_for_status()
            data = response.json()
            versions = [v for v in data[""versions""] if v.get(""url"", """").endswith("".zip"") and ""64"" in v.get(""id"", """") and v.get(""sort-version"", """").replace(""."", """").isdigit()]
            if not versions:
                raise RuntimeError(""Nie znaleziono stabilnej wersji 64-bitowej Pythona z plikiem ZIP."")
            latest = sorted(versions, key=lambda v: list(map(int, v[""sort-version""].split("".""))), reverse=True)[0]
            download_url = latest[""url""]
            version = latest[""sort-version""]
            filename = f""python-{version}-amd64.zip""
            python_dir = os.path.join(PACKAGES_DIR, ""python"")
            zip_path = os.path.join(PACKAGES_DIR, filename)
            if os.path.exists(python_dir):
                shutil.rmtree(python_dir)
            os.makedirs(python_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, zip_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(zip_path, python_dir)
            if progress_callback: progress_callback(98)
            os.remove(zip_path)
            python_exe_path = os.path.join(python_dir, ""python.exe"")
            if not os.path.exists(python_exe_path):
                raise RuntimeError(""Nie znaleziono pliku python.exe po rozpakowaniu."")
            self._update_settings(""python_path"", python_exe_path)
            self._update_settings(""python_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Python nieudana: {str(e)}"")

    def install_latest_nodejs(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Node.js.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            shasums_url = ""https://nodejs.org/dist/latest/SHASUMS256.txt""
            response = requests.get(shasums_url, timeout=10)
            response.raise_for_status()
            pattern = r""^[a-f0-9]{64}\s+(node-v([\d.]+)-win-x64\.zip)$""
            filename = None
            version = None
            for line in response.text.splitlines():
                match = re.match(pattern, line, re.MULTILINE)
                if match:
                    filename = match.group(1)
                    version = match.group(2)
                    break
            if not filename or not version:
                raise RuntimeError(""Nie znaleziono archiwum Node.js dla Windows x64 w pliku SHASUMS256.txt."")
            base_url = ""https://nodejs.org/dist/latest/""
            download_url = f""{base_url}{filename}""
            zip_path = os.path.join(PACKAGES_DIR, filename)
            node_dir = os.path.join(PACKAGES_DIR, ""node.js"")
            if os.path.exists(node_dir):
                shutil.rmtree(node_dir)
            os.makedirs(node_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, zip_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(zip_path, node_dir)
            if progress_callback: progress_callback(98)
            os.remove(zip_path)
            node_exe_path = os.path.join(node_dir, ""node.exe"")
            if not os.path.exists(node_exe_path):
                raise RuntimeError(""Nie znaleziono pliku node.exe po rozpakowaniu."")
            self._update_settings(""node_path"", node_exe_path)
            self._update_settings(""node_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Node.js nieudana: {str(e)}"")

    def install_latest_go(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Go.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://go.dev/dl/""
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            pattern = r""go(\d+\.\d+\.\d+)\.windows-amd64\.zip""
            match = re.search(pattern, response.text)
            if not match:
                raise RuntimeError(""Nie znaleziono wersji Go dla Windows x64"")
            version = match.group(1)
            filename = f""go{version}.windows-amd64.zip""
            download_url = f""{url}{filename}""
            zip_path = os.path.join(PACKAGES_DIR, filename)
            go_dir = os.path.join(PACKAGES_DIR, ""go"")
            if os.path.exists(go_dir):
                shutil.rmtree(go_dir)
            os.makedirs(go_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, zip_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(zip_path, go_dir)
            if progress_callback: progress_callback(98)
            os.remove(zip_path)
            go_exe_path = os.path.join(go_dir, ""bin"", ""go.exe"")
            if not os.path.exists(go_exe_path):
                raise RuntimeError(""Nie znaleziono pliku go.exe po rozpakowaniu."")
            self._update_settings(""go_path"", go_exe_path)
            self._update_settings(""go_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Go nieudana: {str(e)}"")

    def install_latest_java(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję OpenJDK.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://jdk.java.net/21/""
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            pattern = r""openjdk-(\d+)_windows-x64_bin\.zip""
            match = re.search(pattern, response.text)
            if not match:
                raise RuntimeError(""Nie znaleziono OpenJDK dla Windows x64"")
            version = match.group(1)
            filename = f""openjdk-{version}_windows-x64_bin.zip""
            download_url = f""https://download.java.net/java/GA/jdk{version}/{filename}""
            zip_path = os.path.join(PACKAGES_DIR, filename)
            java_dir = os.path.join(PACKAGES_DIR, ""java"")
            if os.path.exists(java_dir):
                shutil.rmtree(java_dir)
            os.makedirs(java_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, zip_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(zip_path, java_dir)
            if progress_callback: progress_callback(98)
            os.remove(zip_path)
            java_exe_path = os.path.join(java_dir, ""bin"", ""java.exe"")
            if not os.path.exists(java_exe_path):
                raise RuntimeError(""Nie znaleziono pliku java.exe po rozpakowaniu."")
            self._update_settings(""java_path"", java_exe_path)
            self._update_settings(""java_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Java nieudana: {str(e)}"")

    def install_latest_ruby(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Ruby.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://rubyinstaller.org/downloads/""
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            pattern = r""rubyinstaller-(\d+\.\d+\.\d+-\d+)-x64\.7z""
            match = re.search(pattern, response.text)
            if not match:
                raise RuntimeError(""Nie znaleziono Ruby dla Windows x64"")
            version = match.group(1)
            filename = f""rubyinstaller-{version}-x64.7z""
            download_url = f""https://github.com/oneclick/rubyinstaller2/releases/download/RubyInstaller-{version}/{filename}""
            archive_path = os.path.join(PACKAGES_DIR, filename)
            ruby_dir = os.path.join(PACKAGES_DIR, ""ruby"")
            if os.path.exists(ruby_dir):
                shutil.rmtree(ruby_dir)
            os.makedirs(ruby_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, archive_path, progress_callback)
            if progress_callback: progress_callback(95)
            self._extract_archive(archive_path, ruby_dir)
            if progress_callback: progress_callback(98)
            os.remove(archive_path)
            ruby_exe_path = os.path.join(ruby_dir, ""bin"", ""ruby.exe"")
            if not os.path.exists(ruby_exe_path):
                raise RuntimeError(""Nie znaleziono pliku ruby.exe po rozpakowaniu."")
            self._update_settings(""ruby_path"", ruby_exe_path)
            self._update_settings(""ruby_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Ruby nieudana: {str(e)}"")

    def install_latest_rust(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Rust.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe""
            exe_path = os.path.join(PACKAGES_DIR, ""rustup-init.exe"")
            rust_dir = os.path.join(PACKAGES_DIR, ""rust"")
            os.makedirs(rust_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(url, exe_path, progress_callback)
            if progress_callback: progress_callback(95)
            subprocess.run([exe_path, ""--default-toolchain"", ""stable"", ""--profile"", ""minimal"", ""-y"", f""--target-dir={rust_dir}""], check=True)
            if progress_callback: progress_callback(98)
            os.remove(exe_path)
            cargo_exe_path = os.path.join(rust_dir, ""bin"", ""cargo.exe"")
            if not os.path.exists(cargo_exe_path):
                raise RuntimeError(""Nie znaleziono pliku cargo.exe po instalacji."")
            version = subprocess.run([cargo_exe_path, ""--version""], capture_output=True, text=True).stdout.strip().split()[1]
            self._update_settings(""rust_path"", cargo_exe_path)
            self._update_settings(""rust_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Rust nieudana: {str(e)}"")

    def install_latest_git(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Git.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://git-scm.com/download/win""
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            pattern = r""Git-(\d+\.\d+\.\d+)-64-bit\.exe""
            match = re.search(pattern, response.text)
            if not match:
                raise RuntimeError(""Nie znaleziono Git dla Windows x64"")
            version = match.group(1)
            filename = f""Git-{version}-64-bit.exe""
            download_url = f""https://github.com/git-for-windows/git/releases/download/v{version}.windows.1/{filename}""
            exe_path = os.path.join(PACKAGES_DIR, filename)
            git_dir = os.path.join(PACKAGES_DIR, ""git"")
            os.makedirs(git_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(download_url, exe_path, progress_callback)
            if progress_callback: progress_callback(95)
            subprocess.run([exe_path, ""/VERYSILENT"", f""/DIR={git_dir}""], check=True)
            if progress_callback: progress_callback(98)
            os.remove(exe_path)
            git_exe_path = os.path.join(git_dir, ""bin"", ""git.exe"")
            if not os.path.exists(git_exe_path):
                raise RuntimeError(""Nie znaleziono pliku git.exe po instalacji."")
            self._update_settings(""git_path"", git_exe_path)
            self._update_settings(""git_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Git nieudana: {str(e)}"")

    def install_latest_docker(self, progress_callback=None):
        """"""
        Instaluje najnowszą wersję Docker Desktop.
        :param progress_callback: Funkcja callback dla postępu.
        """"""
        try:
            url = ""https://desktop.docker.com/win/stable/amd64/Docker%20Desktop%20Installer.exe""
            exe_path = os.path.join(PACKAGES_DIR, ""DockerDesktopInstaller.exe"")
            docker_dir = os.path.join(PACKAGES_DIR, ""docker"")
            os.makedirs(docker_dir, exist_ok=True)
            if progress_callback: progress_callback(1)
            self._download_file(url, exe_path, progress_callback)
            if progress_callback: progress_callback(95)
            subprocess.run([exe_path, ""install"", ""--quiet"", f""--install-dir={docker_dir}""], check=True)
            if progress_callback: progress_callback(98)
            os.remove(exe_path)
            docker_exe_path = os.path.join(docker_dir, ""Docker"", ""Docker Desktop.exe"")
            if not os.path.exists(docker_exe_path):
                raise RuntimeError(""Nie znaleziono pliku Docker Desktop po instalacji."")
            version = subprocess.run([docker_exe_path, ""--version""], capture_output=True, text=True).stdout.strip().split()[2].rstrip(',')
            self._update_settings(""docker_path"", docker_exe_path)
            self._update_settings(""docker_version"", version)
            if progress_callback: progress_callback(100)
        except Exception as e:
            raise RuntimeError(f""Instalacja pakietu Docker nieudana: {str(e)}"")

    def uninstall_package(self, package):
        """"""
        Odinstalowuje pakiet, usuwając jego katalog i wpisy w ustawieniach.
        :param package: Nazwa pakietu.
        """"""
        try:
            folder = os.path.join(PACKAGES_DIR, package.lower())
            if os.path.exists(folder):
                shutil.rmtree(folder)
            self._remove_setting(f""{package.lower()}_path"")
            self._remove_setting(f""{package.lower()}_version"")
        except Exception as e:
            raise RuntimeError(f""Odinstalowanie pakietu {package} nieudane: {str(e)}"")

    def _update_settings(self, key, value):
        """"""
        Zapisuje ustawienie w pliku settings.json.
        :param key: Klucz ustawienia.
        :param value: Wartość ustawienia.
        """"""
        settings = {}
        try:
            if os.path.exists(self.settings_path):
                with open(self.settings_path, ""r"", encoding=""utf-8"") as f:
                    settings = json.load(f)
        except (json.JSONDecodeError, IOError):
            settings = {}
        settings[key] = value
        try:
            with open(self.settings_path, ""w"", encoding=""utf-8"") as f:
                json.dump(settings, f, indent=4)
        except IOError as e:
            raise RuntimeError(f""Błąd zapisu ustawień do pliku {os.path.basename(self.settings_path)}: {str(e)}"")

    def _remove_setting(self, key):
        """"""
        Usuwa ustawienie z pliku settings.json.
        :param key: Klucz ustawienia do usunięcia.
        """"""
        settings = {}
        try:
            if os.path.exists(self.settings_path):
                with open(self.settings_path, ""r"", encoding=""utf-8"") as f:
                    settings = json.load(f)
                if key in settings:
                    del settings[key]
                    with open(self.settings_path, ""w"", encoding=""utf-8"") as f:
                        json.dump(settings, f, indent=4)
        except (json.JSONDecodeError, IOError):
            pass
        except Exception as e:
            raise RuntimeError(f""Błąd usuwania ustawienia '{key}' z pliku {os.path.basename(self.settings_path)}: {str(e)}"")

    def _get_setting(self, key):
        """"""
        Pobiera wartość ustawienia z pliku settings.json.
        :param key: Klucz ustawienia.
        :return: Wartość ustawienia lub None.
        """"""
        try:
            if os.path.exists(self.settings_path):
                with open(self.settings_path, ""r"", encoding=""utf-8"") as f:
                    settings = json.load(f)
                return settings.get(key)
            return None
        except (json.JSONDecodeError, IOError):
            return None
        except Exception:
            return None

class PackageManagerDialog(QDialog):
    """"""Okno dialogowe menadżera pakietów.""""""
    def __init__(self, project_dir, settings, parent=None):
        """"""Inicjalizuje okno dialogowe.""""""
        super().__init__(parent)
        self.project_dir = project_dir
        self.settings = settings

        self.setWindowTitle(""Menadżer Pakietów"")
        self.setModal(True)
        self.resize(800, 500)

        self.pkg_manager = PackageManager(self)
        self.worker = None

        self.setup_ui()
        self.apply_styles()
        self.populate_table()

    def setup_ui(self):
        """"""Konfiguruje interfejs użytkownika.""""""
        layout = QVBoxLayout(self)
        self.status_label = QLabel(""Status: Gotowy"")
        layout.addWidget(self.status_label)
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)
        self.table = QTableWidget(0, 5)
        self.table.setHorizontalHeaderLabels([""Nazwa Pakietu"", ""Opis"", ""Wersja"", ""Status"", ""Akcje""])
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
        self.table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)
        layout.addWidget(self.table)

    def apply_styles(self):
        """"""Zastosuj style CSS zgodnie z motywem aplikacji.""""""
        # Pobierz motyw z ustawień lub domyślnie 'light'
        theme = 'light'
        if self.parent and hasattr(self.parent, 'settings'):
            theme = getattr(self.parent, 'settings', {}).get('theme', 'light')
        elif hasattr(self.parent, 'theme'):
            theme = getattr(self.parent, 'theme', 'light')
        if theme == 'dark':
            self.setStyleSheet(get_dark_package_manager_stylesheet())
        else:
            self.setStyleSheet(get_light_package_manager_stylesheet())

    def populate_table(self):
        """"""Wypełnia tabelę informacjami o dostępnych pakietach.""""""
        packages = [
            {
                ""name"": ""Python"",
                ""desc"": ""Język programowania Python (64-bit)"",
                ""size"": ""~30 MB"",
                ""install_func"": self.download_python,
                ""uninstall_func"": lambda: self.uninstall_package(""Python""),
            },
            {
                ""name"": ""Node.js"",
                ""desc"": ""Środowisko uruchomieniowe JavaScript (64-bit)"",
                ""size"": ""~25 MB"",
                ""install_func"": self.download_node,
                ""uninstall_func"": lambda: self.uninstall_package(""Node.js""),
            },
            {
                ""name"": ""Go"",
                ""desc"": ""Język programowania Go (64-bit)"",
                ""size"": ""~100 MB"",
                ""install_func"": self.download_go,
                ""uninstall_func"": lambda: self.uninstall_package(""Go""),
            },
            {
                ""name"": ""Java"",
                ""desc"": ""Java Development Kit (OpenJDK, 64-bit)"",
                ""size"": ""~200 MB"",
                ""install_func"": self.download_java,
                ""uninstall_func"": lambda: self.uninstall_package(""Java""),
            },
            {
                ""name"": ""Ruby"",
                ""desc"": ""Język programowania Ruby (64-bit)"",
                ""size"": ""~50 MB"",
                ""install_func"": self.download_ruby,
                ""uninstall_func"": lambda: self.uninstall_package(""Ruby""),
            },
            {
                ""name"": ""Rust"",
                ""desc"": ""Język programowania Rust (64-bit)"",
                ""size"": ""~150 MB"",
                ""install_func"": self.download_rust,
                ""uninstall_func"": lambda: self.uninstall_package(""Rust""),
            },
            {
                ""name"": ""Git"",
                ""desc"": ""System kontroli wersji Git (64-bit)"",
                ""size"": ""~50 MB"",
                ""install_func"": self.download_git,
                ""uninstall_func"": lambda: self.uninstall_package(""Git""),
            },
            {
                ""name"": ""Docker"",
                ""desc"": ""Platforma do konteneryzacji Docker Desktop (64-bit)"",
                ""size"": ""~500 MB"",
                ""install_func"": self.download_docker,
                ""uninstall_func"": lambda: self.uninstall_package(""Docker""),
            },
        ]
        self.table.setRowCount(len(packages))
        for row, pkginfo in enumerate(packages):
            name = pkginfo[""name""]
            local_version = self.pkg_manager._get_local_version(name) or ""Brak""
            latest_version = self.pkg_manager._get_latest_version(name) or ""Brak informacji""
            version_text = local_version
            is_installed = self.pkg_manager._is_installed(name)
            status = ""Niezainstalowany""
            status_color = QColor(""#ff4444"")
            if is_installed:
                status = ""Zainstalowano""
                status_color = QColor(""#44ff44"")
                update_available = False
                if latest_version != ""Brak informacji"" and local_version != ""Brak"":
                    try:
                        local_parts = list(map(int, local_version.split('.')))
                        latest_parts = list(map(int, latest_version.split('.')))
                        max_len = max(len(local_parts), len(latest_parts))
                        local_parts += [0] * (max_len - len(local_parts))
                        latest_parts += [0] * (max_len - len(latest_parts))
                        if latest_parts > local_parts:
                            update_available = True
                    except ValueError:
                        if latest_version > local_version:
                            update_available = True
                if update_available:
                    status = ""Dostępna aktualizacja""
                    status_color = QColor(""#ffff44"")
                    version_text = f""{local_version} (Najnowsza: {latest_version})""
            self.table.setItem(row, 0, QTableWidgetItem(name))
            self.table.setItem(row, 1, QTableWidgetItem(pkginfo[""desc""]))
            self.table.setItem(row, 2, QTableWidgetItem(version_text))
            status_item = QTableWidgetItem(status)
            status_item.setForeground(status_color)
            status_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, 3, status_item)
            action_layout = QHBoxLayout()
            action_layout.setContentsMargins(0, 0, 0, 0)
            action_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            if is_installed:
                uninstall_btn = QPushButton(""Odinstaluj"")
                uninstall_btn.clicked.connect(pkginfo[""uninstall_func""])
                action_layout.addWidget(uninstall_btn)
                if update_available:
                    update_btn = QPushButton(""Aktualizuj"")
                    update_btn.clicked.connect(pkginfo[""install_func""])
                    action_layout.addWidget(update_btn)
            else:
                install_btn = QPushButton(""Zainstaluj"")
                install_btn.clicked.connect(pkginfo[""install_func""])
                action_layout.addWidget(install_btn)
            action_widget = QWidget()
            action_widget.setLayout(action_layout)
            self.table.setCellWidget(row, 4, action_widget)

    def download_python(self):
        """"""Rozpoczyna instalację Pythona.""""""
        self.start_operation(self.pkg_manager.install_latest_python, ""Python"", ""instalacji"")

    def download_node(self):
        """"""Rozpoczyna instalację Node.js.""""""
        self.start_operation(self.pkg_manager.install_latest_nodejs, ""Node.js"", ""instalacji"")

    def download_go(self):
        """"""Rozpoczyna instalację Go.""""""
        self.start_operation(self.pkg_manager.install_latest_go, ""Go"", ""instalacji"")

    def download_java(self):
        """"""Rozpoczyna instalację Java.""""""
        self.start_operation(self.pkg_manager.install_latest_java, ""Java"", ""instalacji"")

    def download_ruby(self):
        """"""Rozpoczyna instalację Ruby.""""""
        self.start_operation(self.pkg_manager.install_latest_ruby, ""Ruby"", ""instalacji"")

    def download_rust(self):
        """"""Rozpoczyna instalację Rust.""""""
        self.start_operation(self.pkg_manager.install_latest_rust, ""Rust"", ""instalacji"")

    def download_git(self):
        """"""Rozpoczyna instalację Git.""""""
        self.start_operation(self.pkg_manager.install_latest_git, ""Git"", ""instalacji"")

    def download_docker(self):
        """"""Rozpoczyna instalację Docker.""""""
        self.start_operation(self.pkg_manager.install_latest_docker, ""Docker"", ""instalacji"")

    def uninstall_package(self, package_name):
        """"""Rozpoczyna odinstalowanie pakietu.""""""
        self.start_operation(lambda progress_callback=None: self.pkg_manager.uninstall_package(package_name), package_name, ""odinstalowania"")

    def start_operation(self, func, package_name, operation_type):
        """"""
        Rozpoczyna operację na pakiecie w osobnym wątku.
        :param func: Funkcja do wykonania.
        :param package_name: Nazwa pakietu.
        :param operation_type: Typ operacji.
        """"""
        self.set_actions_enabled(False)
        self.status_label.setText(f""Rozpoczęto operację {operation_type} pakietu {package_name}..."")
        self.progress_bar.setValue(0)
        self.progress_bar.setVisible(True)
        self.worker = DownloadWorker(func, package_name)
        self.worker.progress.connect(self.update_progress)
        self.worker.finished.connect(self.on_operation_finished)
        self.worker.error.connect(self.on_operation_error)
        self.worker.start()

    def update_progress(self, value):
        """"""Aktualizuje pasek postępu.""""""
        self.progress_bar.setValue(value)
        QApplication.processEvents()

    def on_operation_finished(self, message):
        """"""Obsługuje zakończenie operacji.""""""
        self.status_label.setText(message)
        self.progress_bar.setValue(100)
        self.progress_bar.setVisible(False)
        self.populate_table()
        self.set_actions_enabled(True)

    def on_operation_error(self, message):
        """"""Obsługuje błąd operacji.""""""
        self.status_label.setText(f""Błąd: {message}"")
        self.progress_bar.setVisible(False)
        self.populate_table()
        self.set_actions_enabled(True)

    def set_actions_enabled(self, enabled):
        """"""Włącza/wyłącza przyciski akcji.""""""
        for row in range(self.table.rowCount()):
            widget = self.table.cellWidget(row, 4)
            if widget:
                for btn in widget.findChildren(QPushButton):
                    btn.setEnabled(enabled)

if __name__ == '__main__':
    import sys
    userdata_dir_test = os.path.abspath(os.path.join(os.path.dirname(__file__), "".."", ""userdata""))
    os.makedirs(userdata_dir_test, exist_ok=True)
    settings_path_test = os.path.join(userdata_dir_test, ""settings.json"")
    if not os.path.exists(settings_path_test):
        with open(settings_path_test, ""w"") as f:
            json.dump({}, f)
    app = QApplication(sys.argv)
    dialog = PackageManagerDialog()
    dialog.exec()
    sys.exit(app.exec())

Ścieżka: /src/process.py
Rozmiar: 4,36 KB
Zawartość:
# Zarządzanie procesami zewnętrznymi
#/src/process.py

import os
import platform
import shlex
from PyQt6.QtCore import QProcess, QProcessEnvironment

class ProcessManager:
    def __init__(self, parent):
        self.process = QProcess(parent)
        self.process.readyReadStandardOutput.connect(self._handle_stdout)
        self.process.readyReadStandardError.connect(self._handle_stderr)
        self.process.finished.connect(self._handle_finished)
        self.console_output_callback = None
        self.status_bar_callback = None

    def set_callbacks(self, console_output, status_bar):
        self.console_output_callback = console_output
        self.status_bar_callback = status_bar

    def run_command(self, command, working_dir, python_path=None, node_path=None):
        if self.process.state() != QProcess.ProcessState.NotRunning:
            self._append_output(""Inny proces już działa. Zakończ go najpierw."", is_error=True)
            return
        command_str = shlex.join(command)
        self._append_output(f""Uruchamianie: {command_str}\nw katalogu: {working_dir}\n---"")
        self._update_status(""Proces uruchomiony..."")
        try:
            program = command[0]
            arguments = command[1:]
            self.process.setWorkingDirectory(working_dir)
            env = QProcessEnvironment.systemEnvironment()
            current_path = env.value(""PATH"", """")
            paths_to_prepend = []
            if python_path and os.path.exists(python_path):
                py_dir = os.path.dirname(python_path)
                if os.path.normcase(py_dir) not in [os.path.normcase(p) for p in current_path.split(os.pathsep)]:
                    paths_to_prepend.append(py_dir)
            if node_path and os.path.exists(node_path):
                node_dir = os.path.dirname(node_path)
                if os.path.normcase(node_dir) not in [os.path.normcase(p) for p in current_path.split(os.pathsep)]:
                    paths_to_prepend.append(node_dir)
            if paths_to_prepend:
                new_path = os.pathsep.join(paths_to_prepend) + (os.pathsep + current_path if current_path else """")
                env.insert(""PATH"", new_path)
                if platform.system() == ""Windows"":
                    env.insert(""Path"", new_path)
            self.process.setProcessEnvironment(env)
            self.process.start(program, arguments)
            if not self.process.waitForStarted(1000):
                error = self.process.errorString()
                self._append_output(f""Nie udało się uruchomić '{program}': {error}"", is_error=True)
                self._update_status(f""Błąd uruchamiania: {program}"")
        except Exception as e:
            self._append_output(f""Błąd podczas uruchamiania: {e}"", is_error=True)
            self._update_status(""Błąd uruchamiania."")

    def _append_output(self, text, is_error=False):
        if self.console_output_callback:
            self.console_output_callback(text, is_error)

    def _update_status(self, message):
        if self.status_bar_callback:
            self.status_bar_callback(message)

    def _handle_stdout(self):
        while self.process.bytesAvailable():
            data = self.process.readAllStandardOutput()
            try:
                text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                text = bytes(data).decode('utf-8', errors='replace')
            self._append_output(text)

    def _handle_stderr(self):
        while self.process.bytesAvailable():
            data = self.process.readAllStandardError()
            try:
                text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                text = bytes(data).decode('utf-8', errors='replace')
            self._append_output(text, is_error=True)

    def _handle_finished(self, exit_code, exit_status):
        self._handle_stdout()
        self._handle_stderr()
        self._append_output(""\n--- Zakończono proces ---"")
        if exit_status == QProcess.ExitStatus.NormalExit:
            self._append_output(f""Kod wyjścia: {exit_code}"")
            self._update_status(f""Zakończono. Kod wyjścia: {exit_code}"")
        else:
            self._append_output(f""Awaria procesu z kodem: {exit_code}"", is_error=True)
            self._update_status(f""Awaria procesu. Kod wyjścia: {exit_code}"")

Ścieżka: /src/theme.py
Rozmiar: 12,98 KB
Zawartość:
# Zarządzanie motywami aplikacji – zajebiście stylowe! 😎
# /src/theme.py

from PyQt6.QtWidgets import QMainWindow, QApplication
from PyQt6.QtGui import QPalette, QColor

def get_dark_theme_stylesheet():
    return """"""
        QMainWindow, QWidget { background-color: #2E2E2E; color: #D3D3D3; }
        QMenuBar { background-color: #3C3C3C; color: #D3D3D3; }
        QMenuBar::item:selected { background-color: #505050; }
        QMenu { background-color: #3C3C3C; color: #D3D3D3; border: 1px solid #505050; }
        QMenu::item:selected { background-color: #505050; }
        QToolBar { background-color: #3C3C3C; color: #D3D3D3; spacing: 5px; padding: 2px; }
        QToolButton { background-color: transparent; border: 1px solid transparent; padding: 3px; border-radius: 4px; }
        QToolButton:hover { border: 1px solid #505050; background-color: #454545; }
        QToolButton:pressed { background-color: #404040; }
        QPushButton { background-color: #505050; color: #D3D3D3; border: 1px solid #606060; padding: 4px 8px; border-radius: 4px; }
        QPushButton:hover { background-color: #606060; }
        QStatusBar { background-color: #3C3C3C; color: #D3D3D3; }
        QSplitter::handle { background-color: #505050; }
        QTreeView { background-color: #1E1E1E; color: #D3D3D3; border: 1px solid #3C3C3C; alternate-background-color: #252525; }
        QTreeView::item:selected { background-color: #007acc; color: white; }
        QTabWidget::pane { border: 1px solid #3C3C3C; background-color: #1E1E1E; }
        QTabBar::tab { 
            background: #3C3C3C; 
            color: #D3D3D3; 
            border: 1px solid #3C3C3C; 
            border-bottom-color: #1E1E1E; 
            border-top-left-radius: 4px; 
            border-top-right-radius: 4px; 
            padding: 6px 12px; 
            margin-right: 2px; 
        }
        QTabBar::tab:selected { 
            background: #1E1E1E; 
            border-bottom-color: #1E1E1E; 
            color: #FFFFFF; 
        }
        QTabBar::tab:hover { 
            background: #454545; 
        }
        QPlainTextEdit { 
            background-color: #1E1E1E; 
            color: #D3D3D3; 
            border: none; 
            selection-background-color: #007acc; 
            selection-color: white; 
        }
        QPlainTextEdit[readOnly=""true""] { 
            background-color: #1E1E1E; 
            color: #CCCCCC; 
        }
        QLineEdit { 
            background-color: #3C3C3C; 
            color: #D3D3D3; 
            border: 1px solid #505050; 
            padding: 4px; 
            selection-background-color: #007acc; 
            selection-color: white; 
            border-radius: 3px; 
        }
        QComboBox { 
            background-color: #3C3C3C; 
            color: #D3D3D3; 
            border: 1px solid #505050; 
            padding: 4px; 
            border-radius: 3px; 
        }
        QComboBox::drop-down { 
            border: none; 
        }
        QComboBox::down-arrow { 
            image: url(:/icons/down_arrow_dark.png); 
        }
        QDialog { 
            background-color: #2E2E2E; 
            color: #D3D3D3; 
        }
        QLabel { 
            color: #D3D3D3; 
        }
        QDialogButtonBox QPushButton { 
            background-color: #505050; 
            color: #D3D3D3; 
            border: 1px solid #606060; 
            padding: 5px 10px; 
            border-radius: 4px; 
        }
        QSpinBox { 
            background-color: #3C3C3C; 
            color: #D3D3D3; 
            border: 1px solid #505050; 
            padding: 4px; 
            selection-background-color: #007acc; 
            selection-color: white; 
            border-radius: 3px; 
        }
    """"""

def get_light_theme_stylesheet():
    return """"""
        QMainWindow, QWidget { background-color: #F5F5F5; color: #222222; }
        QMenuBar { background-color: #E0E0E0; color: #222222; }
        QMenuBar::item:selected { background-color: #B0B0B0; }
        QMenu { background-color: #FFFFFF; color: #222222; border: 1px solid #CCCCCC; }
        QMenu::item:selected { background-color: #B0B0B0; }
        QToolBar { background-color: #E0E0E0; color: #222222; spacing: 5px; padding: 2px; }
        QToolButton { background-color: transparent; border: 1px solid transparent; padding: 3px; border-radius: 4px; }
        QToolButton:hover { border: 1px solid #CCCCCC; background-color: #F0F0F0; }
        QToolButton:pressed { background-color: #DDDDDD; }
        QPushButton { background-color: #E0E0E0; color: #222222; border: 1px solid #CCCCCC; padding: 4px 8px; border-radius: 4px; }
        QPushButton:hover { background-color: #CCCCCC; }
        QStatusBar { background-color: #E0E0E0; color: #222222; }
        QSplitter::handle { background-color: #CCCCCC; }
        QTreeView { background-color: #FFFFFF; color: #222222; border: 1px solid #CCCCCC; alternate-background-color: #F0F0F0; }
        QTreeView::item:selected { background-color: #007acc; color: white; }
        QTabWidget::pane { border: 1px solid #CCCCCC; background-color: #FFFFFF; }
        QTabBar::tab { 
            background: #E0E0E0; 
            color: #222222; 
            border: 1px solid #CCCCCC; 
            border-bottom-color: #FFFFFF; 
            border-top-left-radius: 4px; 
            border-top-right-radius: 4px; 
            padding: 6px 12px; 
            margin-right: 2px; 
        }
        QTabBar::tab:selected { 
            background: #FFFFFF; 
            border-bottom-color: #FFFFFF; 
            color: #000000; 
        }
        QTabBar::tab:hover { 
            background: #F0F0F0; 
        }
        QPlainTextEdit { 
            background-color: #FFFFFF; 
            color: #222222; 
            border: none; 
            selection-background-color: #007acc; 
            selection-color: white; 
        }
        QPlainTextEdit[readOnly=""true""] { 
            background-color: #F5F5F5; 
            color: #444444; 
        }
        QLineEdit { 
            background-color: #FFFFFF; 
            color: #222222; 
            border: 1px solid #CCCCCC; 
            padding: 4px; 
            selection-background-color: #007acc; 
            selection-color: white; 
            border-radius: 3px; 
        }
        QComboBox { 
            background-color: #FFFFFF; 
            color: #222222; 
            border: 1px solid #CCCCCC; 
            padding: 4px; 
            border-radius: 3px; 
        }
        QComboBox::drop-down { 
            border: none; 
        }
        QComboBox::down-arrow { 
            image: url(:/icons/down_arrow_light.png); 
        }
        QDialog { 
            background-color: #f5f5f5; 
            color: #222222; 
        }
        QLabel { 
            color: #222222; 
        }
        QDialogButtonBox QPushButton { 
            background-color: #e0e0e0; 
            color: #222222; 
            border: 1px solid #cccccc; 
            padding: 5px 10px; 
            border-radius: 4px; 
        }
        QSpinBox { 
            background-color: #FFFFFF; 
            color: #222222; 
            border: 1px solid #CCCCCC; 
            padding: 4px; 
            selection-background-color: #007acc; 
            selection-color: white; 
            border-radius: 3px; 
        }
    """"""

def get_dark_package_manager_stylesheet():
    return """"""
        QDialog {
            background-color: #23272e;
            color: #e0e0e0;
            font-family: 'Segoe UI', sans-serif;
        }
        QTableWidget {
            background-color: #2c313a;
            color: #e0e0e0;
            gridline-color: #444a56;
            border: 1px solid #444a56;
            selection-background-color: #3a3f4b;
            selection-color: #e0e0e0;
        }
        QTableWidget::item {
            padding: 5px;
        }
        QHeaderView::section {
            background-color: #23272e;
            color: #e0e0e0;
            padding: 5px;
            border: none;
            font-weight: bold;
        }
        QPushButton {
            background-color: #3a3f4b;
            color: #e0e0e0;
            border: 1px solid #444a56;
            padding: 5px 10px;
            border-radius: 4px;
        }
        QPushButton:hover {
            background-color: #444a56;
            border-color: #5a6272;
        }
        QPushButton:pressed {
            background-color: #23272e;
        }
        QPushButton:disabled {
            background-color: #2c313a;
            color: #888888;
            border-color: #444a56;
        }
        QProgressBar {
            background-color: #23272e;
            border: 1px solid #444a56;
            border-radius: 4px;
            text-align: center;
            color: #e0e0e0;
        }
        QProgressBar::chunk {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #4CAF50, stop:1 #81C784);
            border-radius: 4px;
        }
        QLabel {
            color: #e0e0e0;
            font-size: 14px;
            margin-bottom: 5px;
        }
        QWidget#actionWidget {
            background-color: transparent;
        }
    """"""

def get_light_package_manager_stylesheet():
    return """"""
        QDialog {
            background-color: #f5f5f5;
            color: #222222;
            font-family: 'Segoe UI', sans-serif;
        }
        QTableWidget {
            background-color: #ffffff;
            color: #222222;
            gridline-color: #cccccc;
            border: 1px solid #cccccc;
            selection-background-color: #b0d6fb;
            selection-color: #222222;
        }
        QTableWidget::item {
            padding: 5px;
        }
        QHeaderView::section {
            background-color: #e0e0e0;
            color: #222222;
            padding: 5px;
            border: none;
            font-weight: bold;
        }
        QPushButton {
            background-color: #e0e0e0;
            color: #222222;
            border: 1px solid #cccccc;
            padding: 5px 10px;
            border-radius: 4px;
        }
        QPushButton:hover {
            background-color: #cccccc;
            border-color: #999999;
        }
        QPushButton:pressed {
            background-color: #bbbbbb;
        }
        QPushButton:disabled {
            background-color: #dddddd;
            color: #aaaaaa;
            border-color: #cccccc;
        }
        QProgressBar {
            background-color: #e0e0e0;
            border: 1px solid #cccccc;
            border-radius: 4px;
            text-align: center;
            color: #222222;
        }
        QProgressBar::chunk {
            background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #4CAF50, stop:1 #81C784);
            border-radius: 4px;
        }
        QLabel {
            color: #222222;
            font-size: 14px;
            margin-bottom: 5px;
        }
        QWidget#actionWidget {
            background-color: transparent;
        }
    """"""

def apply_theme(window: QMainWindow, theme_name: str):
    # Nakładamy motyw jak farbę na płótno, Paffcio! 🎨
    app = QApplication.instance()
    palette = QPalette()

    if theme_name == ""dark"":
        # Ciemny motyw – jak Twój humor po debugowaniu w nocy 😜
        palette.setColor(QPalette.ColorRole.Window, QColor(""#2E2E2E""))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(""#D3D3D3""))
        palette.setColor(QPalette.ColorRole.Base, QColor(""#1E1E1E""))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(""#252525""))
        palette.setColor(QPalette.ColorRole.Text, QColor(""#D3D3D3""))
        palette.setColor(QPalette.ColorRole.Button, QColor(""#505050""))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(""#D3D3D3""))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(""#007acc""))
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(""#FFFFFF""))
        stylesheet = get_dark_theme_stylesheet()
    else:
        # Jasny motyw – dla tych, co kodzą przy kawie w słońcu ☕
        palette.setColor(QPalette.ColorRole.Window, QColor(""#F5F5F5""))
        palette.setColor(QPalette.ColorRole.WindowText, QColor(""#222222""))
        palette.setColor(QPalette.ColorRole.Base, QColor(""#FFFFFF""))
        palette.setColor(QPalette.ColorRole.AlternateBase, QColor(""#F0F0F0""))
        palette.setColor(QPalette.ColorRole.Text, QColor(""#222222""))
        palette.setColor(QPalette.ColorRole.Button, QColor(""#E0E0E0""))
        palette.setColor(QPalette.ColorRole.ButtonText, QColor(""#222222""))
        palette.setColor(QPalette.ColorRole.Highlight, QColor(""#007acc""))
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(""#FFFFFF""))
        stylesheet = get_light_theme_stylesheet()

    app.setPalette(palette)
    app.setStyleSheet(stylesheet)
    window.statusBar().showMessage(f""Zmieniono motyw na: {theme_name.capitalize()}"")

Ścieżka: /src/ui.py
Rozmiar: 69,99 KB
Zawartość:
import sys
import os
import json
import subprocess
import re
import platform
import shutil
import shlex
from src.console import ConsoleWidget, ConsoleManager, AIChatManager
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QSplitter, QTreeView, QTabWidget, QPlainTextEdit,
    QPushButton, QLineEdit, QFileDialog, QMenuBar, QToolBar, QStatusBar,
    QMessageBox, QMenu, QStyleFactory, QDialog, QFormLayout,
    QLabel, QDialogButtonBox, QComboBox, QToolButton,
    QInputDialog, QSpinBox, QSizePolicy, QAbstractItemView,
    QFrame
)
from PyQt6.QtGui import (
    QIcon, QAction, QKeySequence, QTextCharFormat, QFont,
    QSyntaxHighlighter, QTextDocument, QColor, QFileSystemModel,
    QDesktopServices, QPalette
)
from PyQt6.QtCore import (
    QDir, Qt, QProcess, QSettings, QFileInfo, QThread, pyqtSignal, QTimer, QSize,
    QStandardPaths, QUrl, QLocale, QCoreApplication, QProcessEnvironment
)
try:
    import qtawesome as qta
except ImportError:
    qta = None
    print(""Zainstaluj qtawesome ('pip install qtawesome') dla lepszych ikon."", file=sys.stderr)

try:
    from src.dialogs import NewProjectDialog, NewItemDialog, RenameItemDialog, SettingsDialog
    from src.package_manager import PackageManagerDialog
except ImportError:
    import sys, os
    sys.path.insert(0, os.path.join(os.path.dirname(__file__)))
    from dialogs import NewProjectDialog, NewItemDialog, RenameItemDialog, SettingsDialog
    from package_manager import PackageManagerDialog
from src.utils import load_package_json, get_file_language
from src.config import HIGHLIGHTING_RULES
from src.theme import apply_theme

# USTAWIENIE ROOT_DIR
ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DATA_DIR = os.path.join(ROOT_DIR, 'userdata')
PROJECTS_DIR = os.path.join(ROOT_DIR, 'projects')
SETTINGS_FILE = os.path.join(DATA_DIR, 'settings.json')
RECENTS_FILE = os.path.join(DATA_DIR, 'recents.json')
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(PROJECTS_DIR, exist_ok=True)

# Formatowanie podświetlania składni
FORMAT_DEFAULT = QTextCharFormat()
FORMAT_KEYWORD = QTextCharFormat()
FORMAT_KEYWORD.setForeground(QColor(""#000080""))  # Navy
FORMAT_STRING = QTextCharFormat()
FORMAT_STRING.setForeground(QColor(""#008000""))  # Green
FORMAT_COMMENT = QTextCharFormat()
FORMAT_COMMENT.setForeground(QColor(""#808080""))  # Gray
FORMAT_COMMENT.setFontItalic(True)
FORMAT_FUNCTION = QTextCharFormat()
FORMAT_FUNCTION.setForeground(QColor(""#0000FF""))  # Blue
FORMAT_CLASS = QTextCharFormat()
FORMAT_CLASS.setForeground(QColor(""#A52A2A""))  # Brown
FORMAT_CLASS.setFontWeight(QFont.Weight.Bold)
FORMAT_NUMBERS = QTextCharFormat()
FORMAT_NUMBERS.setForeground(QColor(""#FF0000""))  # Red
FORMAT_OPERATOR = QTextCharFormat()
FORMAT_OPERATOR.setForeground(QColor(""#A62929""))  # Dark Red
FORMAT_BUILTIN = QTextCharFormat()
FORMAT_BUILTIN.setForeground(QColor(""#008080""))  # Teal
FORMAT_SECTION = QTextCharFormat()
FORMAT_SECTION.setForeground(QColor(""#800080""))  # Purple
FORMAT_SECTION.setFontWeight(QFont.Weight.Bold)
FORMAT_PROPERTY = QTextCharFormat()
FORMAT_PROPERTY.setForeground(QColor(""#B8860B""))  # DarkGoldenrod

class CodeSyntaxHighlighter(QSyntaxHighlighter):
    def __init__(self, parent: QTextDocument, language: str):
        super().__init__(parent)
        self._language = language.lower()
        self._rules = []
        lang_config = HIGHLIGHTING_RULES.get(self._language, {})
        keywords = lang_config.get('keywords', [])
        builtins = lang_config.get('builtins', [])
        patterns = lang_config.get('patterns', [])
        keyword_format = FORMAT_KEYWORD
        for keyword in keywords:
            pattern = r'\b' + re.escape(keyword) + r'\b'
            self._rules.append((re.compile(pattern), keyword_format))
        builtin_format = FORMAT_BUILTIN
        for builtin in builtins:
            pattern = r'\b' + re.escape(builtin) + r'\b'
            self._rules.append((re.compile(pattern), builtin_format))
        for pattern_str, format, *flags in patterns:
            try:
                pattern = re.compile(pattern_str, *flags)
                self._rules.append((pattern, format))
            except re.error as e:
                print(f""Błąd kompilacji regex '{pattern_str}' dla języka {self._language}: {e}"", file=sys.stderr)

    def highlightBlock(self, text: str):
        self.setFormat(0, len(text), FORMAT_DEFAULT)
        self.setCurrentBlockState(0)
        block_comment_delimiters = []
        if self._language in ['javascript', 'css', 'c++']:
            block_comment_delimiters.append((""/*"", ""*/"", FORMAT_COMMENT))
        if self._language == 'html':
            pass  # HTML comments handled by regex
        comment_start_in_prev_block = (self.previousBlockState() == 1)
        if comment_start_in_prev_block:
            end_delimiter_index = text.find(""*/"")
            if end_delimiter_index >= 0:
                self.setFormat(0, end_delimiter_index + 2, FORMAT_COMMENT)
                self.setCurrentBlockState(0)
                start_pos = end_delimiter_index + 2
            else:
                self.setFormat(0, len(text), FORMAT_COMMENT)
                self.setCurrentBlockState(1)
                return
        else:
            start_pos = 0
        start_delimiter = ""/*""
        end_delimiter = ""*/""
        startIndex = text.find(start_delimiter, start_pos)
        while startIndex >= 0:
            endIndex = text.find(end_delimiter, startIndex)
            if endIndex >= 0:
                length = endIndex - startIndex + len(end_delimiter)
                self.setFormat(startIndex, startIndex + length, FORMAT_COMMENT)
                startIndex = text.find(start_delimiter, startIndex + length)
            else:
                self.setFormat(startIndex, len(text) - startIndex, FORMAT_COMMENT)
                self.setCurrentBlockState(1)
                break
        for pattern, format in self._rules:
            if format == FORMAT_COMMENT and (pattern.pattern.startswith(re.escape('/*')) or pattern.pattern.startswith(re.escape('<!--'))):
                continue
            if format == FORMAT_COMMENT and pattern.pattern.startswith('//') and self.currentBlockState() == 1:
                continue
            for match in pattern.finditer(text):
                start, end = match.span()
                self.setFormat(start, end, format)

class CustomFileSystemModel(QFileSystemModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon_map = {
            '.py': 'fa5s.file-code',
            '.js': 'fa5s.file-code',
            '.json': 'fa5s.file-code',
            '.html': 'fa5s.file-code',
            '.css': 'fa5s.file-code',
            '.ini': 'fa5s.file-alt',
            '.txt': 'fa5s.file-alt',
            '.md': 'fa5s.file-alt',
            '.c': 'fa5s.file-code',
            '.cpp': 'fa5s.file-code',
            '.h': 'fa5s.file-code',
            '.hpp': 'fa5s.file-code',
        }
        self.folder_icon_name = 'fa5s.folder'
        self.default_file_icon_name = 'fa5s.file'
        self._has_qtawesome = qta is not None

    def rename(self, index, new_name):
        if not index.isValid():
            return False
        old_path = self.filePath(index)
        new_path = os.path.join(os.path.dirname(old_path), new_name)
        try:
            os.rename(old_path, new_path)
            self.refresh()
            return True
        except Exception as e:
            print(f""Błąd podczas zmiany nazwy: {e}"", file=sys.stderr)
            return False

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DecorationRole:
            file_info = self.fileInfo(index)
            if file_info.isDir():
                return qta.icon(self.folder_icon_name) if self._has_qtawesome else super().data(index, role)
            elif file_info.isFile():
                extension = file_info.suffix().lower()
                dotted_extension = '.' + extension
                if dotted_extension in self.icon_map and self._has_qtawesome:
                    return qta.icon(self.icon_map[dotted_extension])
                return qta.icon(self.default_file_icon_name) if self._has_qtawesome else super().data(index, role)
        return super().data(index, role)

    def refresh(self, *args):
        self.setRootPath(self.rootPath())

class IDEWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.settings = {
            ""theme"": ""light"",
            ""python_path"": """",
            ""node_path"": """",
            ""show_tree"": True,
            ""show_console"": True,
            ""editor_font_size"": 10,
            ""api_key"": os.getenv(""XAI_API_KEY"", """"),
            ""gemini_api_key"": """",
            ""mistral_api_key"": """",
            ""ai_model"": ""grok-3"",
            ""ai_provider"": ""grok""
        }
        self.recents = {""last_project_dir"": None, ""open_files"": []}
        self._load_app_state()
        self.setWindowTitle(""Proste IDE - Bez nazwy"")
        self.setGeometry(100, 100, 1200, 800)
        self.setWindowIcon(qta.icon('fa5s.code') if qta else QIcon.fromTheme(""applications-development""))
        self.current_project_dir = self.recents.get(""last_project_dir"")
        self.open_files = {}
        self.base_editor_font = QFont(""Courier New"", 10)
        self._setup_ui()
        self._setup_menu()
        self._setup_toolbar()
        self._setup_status_bar()
        self._setup_connections()
        self._apply_theme(self.settings.get(""theme"", ""light""))
        self._apply_editor_font_size()
        self.node_scripts = {}
        QTimer.singleShot(10, self._initial_setup)

    def _setup_ui(self):
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(self.main_splitter)
        self.project_model = CustomFileSystemModel()
        self.project_model.setFilter(QDir.Filter.AllDirs | QDir.Filter.Files | QDir.Filter.NoDotAndDotDot)
        self.project_tree = QTreeView()
        self.project_tree.setModel(self.project_model)
        self.project_tree.setHeaderHidden(True)
        self.project_tree.hideColumn(1)
        self.project_tree.hideColumn(2)
        self.project_tree.hideColumn(3)
        self.project_tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.main_splitter.addWidget(self.project_tree)
        self.right_splitter = QSplitter(Qt.Orientation.Vertical)
        self.main_splitter.addWidget(self.right_splitter)
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.setMovable(True)
        self.right_splitter.addWidget(self.tab_widget)
        self.console_manager = ConsoleManager(self)
        self.ai_chat_manager = AIChatManager(self.settings, self)
        self.console_widget = ConsoleWidget(self.console_manager, self.ai_chat_manager)
        self.right_splitter.addWidget(self.console_widget)
        self.main_splitter.setSizes([200, 800])
        self.right_splitter.setSizes([600, 200])
        self.setCentralWidget(central_widget)
        self.action_toggle_tree = QAction(""Pokaż/Ukryj drzewko"", self)
        self.action_toggle_tree.setCheckable(True)
        self.action_toggle_tree.setChecked(True)
        self.action_toggle_tree.triggered.connect(self._toggle_tree_panel)
        self.action_toggle_console = QAction(""Pokaż/Ukryj konsolę i chat ai"", self)
        self.action_toggle_console.setCheckable(True)
        self.action_toggle_console.setChecked(True)
        self.action_toggle_console.triggered.connect(self._toggle_console_panel)
        self._apply_view_settings()

    def _apply_view_settings(self):
        """"""Stosuje ustawienia widoczności paneli z ustawień.""""""
        show_tree = self.settings.get(""show_tree"", True)
        show_console = self.settings.get(""show_console"", True)
        self.main_splitter.widget(0).setVisible(show_tree)
        self.right_splitter.widget(1).setVisible(show_console)
        self.action_toggle_tree.setChecked(show_tree)
        self.action_toggle_console.setChecked(show_console)

    def _toggle_tree_panel(self, checked):
        self.main_splitter.widget(0).setVisible(checked)
        self.settings[""show_tree""] = checked
        self._save_app_state()

    def _toggle_console_panel(self, checked):
        self.right_splitter.widget(1).setVisible(checked)
        self.settings[""show_console""] = checked
        self._save_app_state()

    def _setup_menu(self):
        menu_bar = self.menuBar()
        file_menu = menu_bar.addMenu(""&Plik"")
        self.action_new_project = QAction(qta.icon('fa5s.folder-plus') if qta else QIcon(), ""&Nowy projekt..."", self)
        self.action_new_project.triggered.connect(self._new_project)
        file_menu.addAction(self.action_new_project)
        self.action_open_folder = QAction(qta.icon('fa5s.folder-open') if qta else QIcon(), ""Otwórz &folder projektu..."", self)
        self.action_open_folder.triggered.connect(lambda: self._open_project_folder())
        file_menu.addAction(self.action_open_folder)
        self.action_open_file = QAction(qta.icon('fa5s.file-code') if qta else QIcon(), ""Otwórz &plik..."", self)
        self.action_open_file.triggered.connect(self._open_file_dialog)
        file_menu.addAction(self.action_open_file)
        file_menu.addSeparator()
        self.recent_files_menu = QMenu(""Ostatnio otwierane"", self)
        file_menu.addMenu(self.recent_files_menu)
        file_menu.addSeparator()
        self.action_save = QAction(qta.icon('fa5s.save') if qta else QIcon(), ""&Zapisz"", self)
        self.action_save.setShortcut(QKeySequence.StandardKey.Save)
        self.action_save.triggered.connect(self._save_current_file)
        file_menu.addAction(self.action_save)
        self.action_save_as = QAction(qta.icon('fa5s.file-export') if qta else QIcon(), ""Zapisz &jako..."", self)
        self.action_save_as.setShortcut(QKeySequence.StandardKey.SaveAs)
        self.action_save_as.triggered.connect(self._save_current_file_as)
        file_menu.addAction(self.action_save_as)
        self.action_save_all = QAction(qta.icon('fa5s.save') if qta else QIcon(), ""Zapisz wszys&tko"", self)
        self.action_save_all.setShortcut(QKeySequence(""Ctrl+Shift+S""))
        self.action_save_all.triggered.connect(self._save_all_files)
        file_menu.addAction(self.action_save_all)
        file_menu.addSeparator()
        self.action_close_file = QAction(qta.icon('fa5s.window-close') if qta else QIcon(), ""Zamknij ak&tualny plik"", self)
        self.action_close_file.triggered.connect(self._close_current_tab)
        file_menu.addAction(self.action_close_file)
        file_menu.addSeparator()
        self.action_exit = QAction(qta.icon('fa5s.door-open') if qta else QIcon(), ""&Zakończ"", self)
        self.action_exit.setShortcut(QKeySequence.StandardKey.Quit)
        self.action_exit.triggered.connect(self.close)
        file_menu.addAction(self.action_exit)
        edit_menu = menu_bar.addMenu(""&Edycja"")
        view_menu = menu_bar.addMenu(""&Widok"")
        self.action_toggle_tree = QAction(qta.icon('fa5s.sitemap') if qta else QIcon(), ""Pokaż &drzewko plików"", self)
        self.action_toggle_tree.setCheckable(True)
        self.action_toggle_tree.setChecked(self.settings.get(""show_tree"", True))
        self.action_toggle_tree.triggered.connect(self._toggle_tree_panel)
        view_menu.addAction(self.action_toggle_tree)
        self.action_toggle_console = QAction(qta.icon('fa5s.terminal') if qta else QIcon(), ""Pokaż &konsolę i chat ai"", self)
        self.action_toggle_console.setCheckable(True)
        self.action_toggle_console.setChecked(self.settings.get(""show_console"", True))
        self.action_toggle_console.triggered.connect(self._toggle_console_panel)
        view_menu.addAction(self.action_toggle_console)
        search_menu = menu_bar.addMenu(""&Wyszukaj"")
        self.action_find = QAction(qta.icon('fa5s.search') if qta else QIcon(), ""&Znajdź..."", self)
        self.action_find.setShortcut(QKeySequence.StandardKey.Find)
        self.action_find.triggered.connect(self._show_find_bar)
        search_menu.addAction(self.action_find)
        run_menu = menu_bar.addMenu(""&Uruchom"")
        self.action_run_file = QAction(qta.icon('fa5s.play') if qta else QIcon(), ""&Uruchom aktualny plik"", self)
        self.action_run_file.setShortcut(QKeySequence(""F5""))
        self.action_run_file.triggered.connect(self._run_current_file)
        run_menu.addAction(self.action_run_file)
        tools_menu = menu_bar.addMenu(""&Narzędzia"")
        self.action_settings = QAction(qta.icon('fa5s.cog') if qta else QIcon(), ""&Ustawienia..."", self)
        self.action_settings.triggered.connect(self._show_settings_dialog)
        tools_menu.addAction(self.action_settings)
        self.action_package_manager = QAction(qta.icon('fa5s.box-open') if qta else QIcon(), ""Menadżer pakietów"", self)
        self.action_package_manager.triggered.connect(self._show_package_manager)
        tools_menu.addAction(self.action_package_manager)
        help_menu = menu_bar.addMenu(""&Pomoc"")
        self.action_about = QAction(qta.icon('fa5s.info-circle') if qta else QIcon(), ""&O programie..."", self)
        self.action_about.triggered.connect(self._show_about_dialog)
        help_menu.addAction(self.action_about)

    def _setup_toolbar(self):
        toolbar = self.addToolBar(""Główne narzędzia"")
        toolbar.setMovable(False)
        toolbar.setIconSize(QSize(16, 16))
        toolbar.addAction(self.action_new_project)
        toolbar.addAction(self.action_open_folder)
        toolbar.addAction(self.action_open_file)
        toolbar.addSeparator()
        toolbar.addAction(self.action_save)
        toolbar.addAction(self.action_save_all)
        toolbar.addSeparator()
        self.run_toolbutton = QToolButton(self)
        self.run_toolbutton.setDefaultAction(self.action_run_file)
        self.run_toolbutton.setPopupMode(QToolButton.ToolButtonPopupMode.MenuButtonPopup)
        toolbar.addWidget(self.run_toolbutton)
        toolbar.addSeparator()
        self.search_input = QLineEdit(self)
        self.search_input.setPlaceholderText(""Szukaj w pliku..."")
        self.search_input.setClearButtonEnabled(True)
        self.search_input.returnPressed.connect(lambda: self._find_text(self.search_input.text(), 'next'))
        self.find_next_button = QPushButton(""Znajdź dalej"")
        self.find_next_button.clicked.connect(lambda: self._find_text(self.search_input.text(), 'next'))
        self.find_prev_button = QPushButton(""Znajdź poprzedni"")
        self.find_prev_button.clicked.connect(lambda: self._find_text(self.search_input.text(), 'previous'))
        toolbar.addWidget(self.search_input)
        toolbar.addWidget(self.find_next_button)
        toolbar.addWidget(self.find_prev_button)
        self.search_input.setVisible(False)
        self.find_next_button.setVisible(False)
        self.find_prev_button.setVisible(False)

    def _setup_status_bar(self):
        self.statusBar().showMessage(""Gotowy."")

    def _setup_connections(self):
        self.project_tree.doubleClicked.connect(self._handle_tree_item_double_click)
        self.tab_widget.tabCloseRequested.connect(self._close_tab_by_index)
        self.tab_widget.currentChanged.connect(self._handle_tab_change)
        self.project_tree.customContextMenuRequested.connect(self._show_project_tree_context_menu)

    def _initial_setup(self):
        initial_dir = self.recents.get(""last_project_dir"")
        if not initial_dir or not os.path.isdir(initial_dir):
            initial_dir = PROJECTS_DIR
            os.makedirs(PROJECTS_DIR, exist_ok=True)
        if os.path.isdir(initial_dir):
            self._open_project_folder(initial_dir)
        else:
            self.statusBar().showMessage(""Brak domyślnego katalogu projektu. Otwórz folder ręcznie lub utwórz nowy."")
            self.project_model.setRootPath("""")
            self.current_project_dir = None
            self._update_run_button_menu()
        recent_files = self.recents.get(""open_files"", [])
        QTimer.singleShot(200, lambda: self._reopen_files(recent_files))
        self._update_recent_files_menu()

    def _load_app_state(self):
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                    self.settings.update({
                        ""theme"": loaded_settings.get(""theme"", ""light""),
                        ""python_path"": loaded_settings.get(""python_path"", """"),
                        ""node_path"": loaded_settings.get(""node_path"", """"),
                        ""show_tree"": loaded_settings.get(""show_tree"", True),
                        ""show_console"": loaded_settings.get(""show_console"", True),
                        ""editor_font_size"": loaded_settings.get(""editor_font_size"", 10),
                        ""api_key"": loaded_settings.get(""api_key"", os.getenv(""XAI_API_KEY"", """")),
                        ""gemini_api_key"": loaded_settings.get(""gemini_api_key"", """"),
                        ""mistral_api_key"": loaded_settings.get(""mistral_api_key"", """"),
                        ""ai_model"": loaded_settings.get(""ai_model"", ""grok-3""),
                        ""ai_provider"": loaded_settings.get(""ai_provider"", ""grok"")
                    })
            if os.path.exists(RECENTS_FILE):
                with open(RECENTS_FILE, 'r', encoding='utf-8') as f:
                    loaded_recents = json.load(f)
                    self.recents.update({
                        ""last_project_dir"": loaded_recents.get(""last_project_dir""),
                        ""open_files"": loaded_recents.get(""open_files"", [])
                    })
        except (json.JSONDecodeError, Exception) as e:
            print(f""Błąd podczas wczytywania stanu aplikacji: {e}"", file=sys.stderr)

    def _save_app_state(self):
        try:
            self.recents[""open_files""] = list(self.open_files.keys())
            if self.current_project_dir and os.path.isdir(self.current_project_dir):
                self.recents[""last_project_dir""] = os.path.normpath(self.current_project_dir)
            else:
                self.recents[""last_project_dir""] = None
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=4)
            with open(RECENTS_FILE, 'w', encoding='utf-8') as f:
                normalized_open_files = [os.path.normpath(p) for p in self.recents[""open_files""]]
                unique_open_files = []
                for p in normalized_open_files:
                    if p not in unique_open_files:
                        unique_open_files.append(p)
                self.recents[""open_files""] = unique_open_files[:20]
                json.dump(self.recents, f, indent=4)
        except Exception as e:
            print(f""Błąd podczas zapisu stanu aplikacji: {e}"", file=sys.stderr)

    def closeEvent(self, event):
        unsaved_files = [path for path, editor in self.open_files.items() if editor.document().isModified()]
        if unsaved_files:
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Warning)
            msg_box.setWindowTitle(""Niezapisane zmiany"")
            msg_box.setText(f""Masz niezapisane zmiany w {len(unsaved_files)} plikach.\nCzy chcesz zapisać przed zamknięciem?"")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Save)
            reply = msg_box.exec()
            if reply == QMessageBox.StandardButton.Save:
                if self._save_all_files():
                    self._save_app_state()
                    event.accept()
                else:
                    event.ignore()
            elif reply == QMessageBox.StandardButton.Discard:
                for i in range(self.tab_widget.count() - 1, -1, -1):
                    widget = self.tab_widget.widget(i)
                    if hasattr(widget, 'document'):
                        widget.document().setModified(False)
                    self._close_tab_by_index(i)
                self._save_app_state()
                event.accept()
            else:
                event.ignore()
        else:
            self._save_app_state()
            event.accept()

    def _new_project(self):
        dialog = NewProjectDialog(PROJECTS_DIR, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            project_name = dialog.get_project_name()
            project_path = dialog.get_project_path()
            try:
                if os.path.exists(project_path):
                    QMessageBox.warning(self, ""Projekt już istnieje"", f""Projekt o nazwie '{project_name}' już istnieje."")
                    return
                os.makedirs(project_path)
                self.statusBar().showMessage(f""Utworzono nowy projekt: {project_name}"")
                self._open_project_folder(project_path)
            except OSError as e:
                QMessageBox.critical(self, ""Błąd tworzenia projektu"", f""Nie można utworzyć katalogu projektu:\n{e}"")
                self.statusBar().showMessage(""Błąd tworzenia projektu."")

    def _open_project_folder(self, path=None):
        if path is None:
            start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
            dialog_path = QFileDialog.getExistingDirectory(self, ""Otwórz folder projektu"", start_path)
            if not dialog_path:
                return
            path = dialog_path
        path = os.path.normpath(path)
        if not os.path.isdir(path):
            QMessageBox.critical(self, ""Błąd"", f""Wybrana ścieżka nie jest katalogiem lub nie istnieje:\n{path}"")
            self.statusBar().showMessage(f""Błąd: Nie można otworzyć folderu: {path}"")
            return
        if self.current_project_dir and self.current_project_dir != path:
            unsaved_files_count = sum(1 for editor in self.open_files.values() if editor.document().isModified())
            if unsaved_files_count > 0:
                reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                            f""Obecny projekt ma {unsaved_files_count} niezapisanych plików.\n""
                                            ""Czy chcesz zapisać zmiany przed otwarciem nowego folderu?"",
                                            QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Cancel:
                    self.statusBar().showMessage(""Otwieranie folderu anulowane."")
                    return
                if reply == QMessageBox.StandardButton.Save:
                    if not self._save_all_files():
                        self.statusBar().showMessage(""Otwieranie folderu anulowane (błąd zapisu)."")
                        return
            self._close_all_files()
        self.current_project_dir = path
        self.project_model.setRootPath(path)
        root_index = self.project_model.index(path)
        if not root_index.isValid():
            QMessageBox.critical(self, ""Błąd"", f""Nie można ustawić katalogu głównego drzewka dla ścieżki:\n{path}"")
            self.statusBar().showMessage(f""Błąd ustawienia katalogu głównego: {path}"")
            self.project_tree.setRootIndex(self.project_model.index(""""))
            self.current_project_dir = None
            self.recents[""open_files""] = [p for p in self.recents[""open_files""] if not os.path.normpath(p).startswith(os.path.normpath(path) + os.sep)]
            self._update_recent_files_menu()
            self._save_app_state()
            self._update_run_button_menu()
            return
        self.project_tree.setRootIndex(root_index)
        self.setWindowTitle(f""Proste IDE - {os.path.basename(path)}"")
        self.statusBar().showMessage(f""Otwarto folder: {path}"")
        self._check_package_json(path)
        self.recents[""last_project_dir""] = path
        self._save_app_state()

    def _close_all_files(self):
        for file_path in list(self.open_files.keys()):
            editor_widget = self.open_files.get(file_path)
            if editor_widget:
                tab_index = self.tab_widget.indexOf(editor_widget)
                if tab_index != -1:
                    if hasattr(editor_widget, 'document'):
                        editor_widget.document().setModified(False)
                    self.tab_widget.removeTab(tab_index)
                    if file_path in self.open_files:
                        del self.open_files[file_path]
        self.recents[""open_files""] = []
        self._update_recent_files_menu()

    def _open_file_dialog(self):
        start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
        file_path, _ = QFileDialog.getOpenFileName(self, ""Otwórz plik"", start_path, ""Wszystkie pliki (*);;Pliki Pythona (*.py);;Pliki JavaScript (*.js);;Pliki HTML (*.html);;Pliki CSS (*.css);;Pliki C++ (*.c *.cpp *.h *.hpp);;Pliki INI (*.ini);;Pliki JSON (*.json)"")
        if file_path:
            self._open_file(file_path)

    def _open_file(self, file_path):
        file_path = os.path.normpath(file_path)
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            self.statusBar().showMessage(f""Błąd: Plik nie istnieje lub nie jest plikiem: {file_path}"")
            if file_path in self.recents[""open_files""]:
                self.recents[""open_files""].remove(file_path)
                self._update_recent_files_menu()
                self._save_app_state()
            return
        if file_path in self.open_files:
            index = -1
            for i in range(self.tab_widget.count()):
                widget = self.tab_widget.widget(i)
                if self.open_files.get(file_path) is widget:
                    index = i
                    break
            if index != -1:
                self.tab_widget.setCurrentIndex(index)
                self.statusBar().showMessage(f""Plik {os.path.basename(file_path)} jest już otwarty."")
                if file_path in self.recents[""open_files""]:
                    self.recents[""open_files""].remove(file_path)
                    self.recents[""open_files""].insert(0, file_path)
                    self._update_recent_files_menu()
                    self._save_app_state()
                return
        try:
            content = """"
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except UnicodeDecodeError:
                try:
                    with open(file_path, 'r', encoding='latin-1') as f:
                        content = f.read()
                except Exception:
                    with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                        content = f.read()
        except Exception as e:
            QMessageBox.critical(self, ""Błąd otwarcia pliku"", f""Nie można odczytać pliku {os.path.basename(file_path)}:\n{e}"")
            self.statusBar().showMessage(f""Błąd otwarcia pliku: {os.path.basename(file_path)}"")
            return
        editor = QPlainTextEdit()
        editor.setPlainText(content)
        editor.setFont(self.base_editor_font)
        editor.document().setModified(False)
        editor.document().modificationChanged.connect(self._handle_modification_changed)
        language = self._get_language_from_path(file_path)
        highlighter = CodeSyntaxHighlighter(editor.document(), language)
        setattr(editor.document(), '_syntax_highlighter', highlighter)
        tab_index = self.tab_widget.addTab(editor, os.path.basename(file_path))
        self.tab_widget.setCurrentIndex(tab_index)
        self.open_files[file_path] = editor
        self.statusBar().showMessage(f""Otwarto plik: {file_path}"")
        if file_path in self.recents[""open_files""]:
            self.recents[""open_files""].remove(file_path)
        self.recents[""open_files""].insert(0, file_path)
        self._update_recent_files_menu()
        self._save_app_state()

    def _reopen_files(self, file_list):
        files_to_reopen = list(file_list)
        valid_files = [f for f in files_to_reopen if os.path.exists(f) and os.path.isfile(f)]
        self.recents[""open_files""] = valid_files
        self._update_recent_files_menu()
        for file_path in valid_files:
            QTimer.singleShot(0, lambda path=file_path: self._open_file(path))
        invalid_files = [f for f in files_to_reopen if f not in valid_files]
        if invalid_files:
            msg = ""Nie można ponownie otworzyć następujących plików (nie znaleziono):\n"" + ""\n"".join(invalid_files)
            QMessageBox.warning(self, ""Błąd otwarcia plików"", msg)

    def _update_recent_files_menu(self):
        self.recent_files_menu.clear()
        recent_items_to_show = list(self.recents.get(""open_files"", []))[:15]
        if not recent_items_to_show:
            self.recent_files_menu.addAction(""Brak ostatnio otwieranych plików"").setEnabled(False)
            return
        actions_to_add = []
        cleaned_recent_files = []
        for file_path in recent_items_to_show:
            if os.path.exists(file_path) and os.path.isfile(file_path):
                cleaned_recent_files.append(file_path)
                menu_text = os.path.basename(file_path)
                action = QAction(menu_text, self)
                action.setData(file_path)
                action.triggered.connect(lambda checked, path=file_path: self._open_file(path))
                actions_to_add.append(action)
        all_existing_recent_files = [p for p in self.recents.get(""open_files"", []) if os.path.exists(p) and os.path.isfile(p)]
        unique_recent_files = []
        for p in all_existing_recent_files:
            if p not in unique_recent_files:
                unique_recent_files.append(p)
        self.recents[""open_files""] = unique_recent_files[:20]
        for action in actions_to_add:
            self.recent_files_menu.addAction(action)
        self._save_app_state()

    def _show_project_tree_context_menu(self, point):
        index = self.project_tree.indexAt(point)
        menu = QMenu(self)
        if index.isValid():
            file_path = self.project_model.filePath(index)
            file_info = self.project_model.fileInfo(index)
            if file_info.isFile():
                open_action = QAction(""Otwórz"", self)
                open_action.triggered.connect(lambda: self._open_file(file_path))
                menu.addAction(open_action)
            # Dodaj opcję ""Otwórz jako projekt"" dla folderów
            if file_info.isDir():
                open_as_project_action = QAction(""Otwórz jako projekt"", self)
                open_as_project_action.triggered.connect(lambda: self._open_project_folder(file_path))
                menu.addAction(open_as_project_action)
            new_file_action = QAction(""Nowy plik"", self)
            new_file_action.triggered.connect(lambda: self._create_new_item(index, is_folder=False))
            menu.addAction(new_file_action)
            new_folder_action =QAction(""Nowy folder"", self)
            new_folder_action.triggered.connect(lambda: self._create_new_item(index, is_folder=True))
            menu.addAction(new_folder_action)
            rename_action = QAction(""Zmień nazwę"", self)
            rename_action.triggered.connect(lambda: self._rename_item(index))
            menu.addAction(rename_action)
            delete_action = QAction(""Usuń"", self)
            delete_action.triggered.connect(lambda: self._delete_item(index))
            menu.addAction(delete_action)
            if file_info.isFile():
                duplicate_action = QAction(""Duplikuj"", self)
                duplicate_action.triggered.connect(lambda: self._duplicate_file(index))
                menu.addAction(duplicate_action)
        else:
            new_file_action = QAction(""Nowy plik"", self)
            new_file_action.triggered.connect(lambda: self._create_new_item(None, is_folder=False))
            menu.addAction(new_file_action)
            new_folder_action = QAction(""Nowy folder"", self)
            new_folder_action.triggered.connect(lambda: self._create_new_item(None, is_folder=True))
            menu.addAction(new_folder_action)
        menu.exec(self.project_tree.mapToGlobal(point))

    def _create_new_item(self, index, is_folder=False):
        parent_dir = self.current_project_dir
        if index and index.isValid():
            file_path = self.project_model.filePath(index)
            if self.project_model.fileInfo(index).isDir():
                parent_dir = file_path
            else:
                parent_dir = os.path.dirname(file_path)
        dialog = NewItemDialog(parent_dir, is_folder, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            item_name = dialog.get_item_name()
            full_path = os.path.join(parent_dir, item_name)
            try:
                if is_folder:
                    os.makedirs(full_path, exist_ok=True)
                else:
                    with open(full_path, 'w', encoding='utf-8') as f:
                        f.write('')
                self.statusBar().showMessage(f""Utworzono: {item_name}"")
                parent_index = self.project_model.index(parent_dir)
                if parent_index.isValid():
                    self.project_model.refresh(parent_index)
            except OSError as e:
                QMessageBox.critical(self, ""Błąd tworzenia"", f""Nie można utworzyć {item_name}:\n{e}"")
                self.statusBar().showMessage(""Błąd tworzenia."")

    def _rename_item(self, index):
        if not index.isValid():
            return
        current_path = self.project_model.filePath(index)
        dialog = RenameItemDialog(current_path, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_name = dialog.get_new_name()
            if self.project_model.rename(index, new_name):
                self.statusBar().showMessage(f""Zmieniono nazwę na: {new_name}"")
            else:
                QMessageBox.critical(self, ""Błąd zmiany nazwy"", f""Nie można zmienić nazwy na '{new_name}'."")
                self.statusBar().showMessage(""Błąd zmiany nazwy."")

    def _delete_item(self, index):
        if not index.isValid():
            return
        file_path = self.project_model.filePath(index)
        file_info = self.project_model.fileInfo(index)
        item_name = file_info.fileName()
        is_dir = file_info.isDir()
        open_files_to_close = []
        if is_dir:
            for open_file_path in self.open_files:
                if os.path.normpath(open_file_path).startswith(os.path.normpath(file_path) + os.sep):
                    open_files_to_close.append(open_file_path)
        else:
            if file_path in self.open_files:
                open_files_to_close.append(file_path)
        if open_files_to_close:
            reply_close = QMessageBox.question(self, ""Otwarte pliki"",
                                              f""Element '{item_name}' zawiera {len(open_files_to_close)} otwartych plików.\n""
                                              f""Czy chcesz zamknąć te pliki, aby kontynuować usuwanie '{item_name}'?"",
                                              QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if reply_close == QMessageBox.StandardButton.No:
                self.statusBar().showMessage(f""Usuwanie '{item_name}' anulowane."")
                return
            unsaved_open_files = [p for p in open_files_to_close if self.open_files.get(p) and self.open_files[p].document().isModified()]
            if unsaved_open_files:
                save_reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                                 f""Niektóre z plików ({len(unsaved_open_files)}) mają niezapisane zmiany. Czy chcesz je zapisać przed zamknięciem i usunięciem?"",
                                                 QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                if save_reply == QMessageBox.StandardButton.Cancel:
                    self.statusBar().showMessage(""Usuwanie anulowane (niezapisane zmiany)."")
                    return
                if save_reply == QMessageBox.StandardButton.Save:
                    save_success = True
                    for file_path_to_save in unsaved_open_files:
                        editor = self.open_files.get(file_path_to_save)
                        if editor and not self._save_file(editor, file_path_to_save):
                            save_success = False
                            break
                    if not save_success:
                        self.statusBar().showMessage(""Usuwanie anulowane (błąd zapisu otwartych plików)."")
                        return
            for file_path_to_close in reversed(open_files_to_close):
                editor_widget = self.open_files.get(file_path_to_close)
                if editor_widget:
                    tab_index = self.tab_widget.indexOf(editor_widget)
                    if tab_index != -1:
                        if hasattr(editor_widget, 'document'):
                            editor_widget.document().setModified(False)
                        self.tab_widget.removeTab(tab_index)
                        del self.open_files[file_path_to_close]
                        editor_widget.deleteLater()
            self.recents[""open_files""] = [p for p in self.recents[""open_files""] if p not in open_files_to_close]
            self._update_recent_files_menu()
            self._save_app_state()
        item_type = ""folder"" if is_dir else ""plik""
        reply = QMessageBox.question(self, f""Usuń {item_type}"",
                                    f""Czy na pewno chcesz usunąć {item_type} '{item_name}'?\n""
                                    ""Ta operacja jest nieodwracalna!"",
                                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            success = self.project_model.remove(index)
            if success:
                self.statusBar().showMessage(f""Usunięto {item_type}: {item_name}"")
            else:
                QMessageBox.critical(self, f""Błąd usuwania {item_type}"", f""Nie można usunąć {item_type} '{item_name}'."")
                self.statusBar().showMessage(f""Błąd usuwania {item_type}."")

    def _duplicate_file(self, index):
        if not index.isValid():
            return
        file_path = self.project_model.filePath(index)
        file_info = self.project_model.fileInfo(index)
        if not file_info.isFile():
            self.statusBar().showMessage(""Można duplikować tylko pliki."")
            return
        parent_dir = os.path.dirname(file_path)
        old_name = os.path.basename(file_path)
        name, ext = os.path.splitext(old_name)
        suggested_name = f""{name}_kopia{ext}""
        counter = 1
        while os.path.exists(os.path.join(parent_dir, suggested_name)):
            counter += 1
            suggested_name = f""{name}_kopia{counter}{ext}""
        new_name, ok = QInputDialog.getText(self, ""Duplikuj plik"", f""Podaj nazwę dla kopii '{old_name}':"",
                                           QLineEdit.EchoMode.Normal, suggested_name)
        if ok and new_name:
            new_name = new_name.strip()
            if not new_name or re.search(r'[<>:""/\\|?*\x00-\x1F]', new_name) is not None:
                QMessageBox.warning(self, ""Nieprawidłowa nazwa"", ""Podana nazwa jest pusta lub zawiera niedozwolone znaki."")
                self.statusBar().showMessage(""Duplikowanie anulowane (nieprawidłowa nazwa)."")
                return
            new_path = os.path.join(parent_dir, new_name)
            if os.path.exists(new_path):
                QMessageBox.warning(self, ""Element już istnieje"", f""Element o nazwie '{new_name}' już istnieje."")
                self.statusBar().showMessage(""Duplikowanie anulowane (element już istnieje)."")
                return
            try:
                os.makedirs(os.path.dirname(new_path), exist_ok=True)
                shutil.copy2(file_path, new_path)
                self.statusBar().showMessage(f""Utworzono kopię: {new_name}"")
                parent_index = self.project_model.index(parent_dir)
                if parent_index.isValid():
                    self.project_model.refresh(parent_index)
                else:
                    root_path = self.project_model.rootPath()
                    if root_path and os.path.isdir(root_path):
                        self.project_model.refresh(self.project_model.index(root_path))
            except OSError as e:
                QMessageBox.critical(self, ""Błąd duplikowania"", f""Nie można zduplikować pliku '{old_name}':\n{e}"")
                self.statusBar().showMessage(""Błąd duplikowania pliku."")

    def _close_tab_by_index(self, index):
        if index == -1:
            return
        widget = self.tab_widget.widget(index)
        if widget is None:
            return
        file_path_before_save = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is widget:
                file_path_before_save = path
                break
        if hasattr(widget, 'document') and widget.document().isModified():
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Warning)
            msg_box.setWindowTitle(""Niezapisane zmiany"")
            tab_text = self.tab_widget.tabText(index).rstrip('*')
            display_name = os.path.basename(file_path_before_save) if file_path_before_save else tab_text
            msg_box.setText(f""Plik '{display_name}' ma niezapisane zmiany.\nCzy chcesz zapisać przed zamknięciem?"")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Save)
            reply = msg_box.exec()
            if reply == QMessageBox.StandardButton.Save:
                needs_save_as = (file_path_before_save is None or
                                 not os.path.exists(file_path_before_save) or
                                 not QFileInfo(file_path_before_save).isFile())
                if needs_save_as:
                    original_index = self.tab_widget.currentIndex()
                    self.tab_widget.setCurrentIndex(index)
                    save_success = self._save_current_file_as()
                    if original_index != -1 and original_index < self.tab_widget.count():
                        self.tab_widget.setCurrentIndex(original_index)
                    if not save_success:
                        self.statusBar().showMessage(f""Zamknięcie anulowane (błąd zapisu '{display_name}')."")
                        return
                else:
                    if not self._save_file(widget, file_path_before_save):
                        self.statusBar().showMessage(f""Zamknięcie anulowane (błąd zapisu '{display_name}')."")
                        return
            elif reply == QMessageBox.StandardButton.Cancel:
                self.statusBar().showMessage(f""Zamknięcie '{tab_text}' anulowane."")
                return
        if file_path_before_save in self.open_files:
            del self.open_files[file_path_before_save]
            if file_path_before_save in self.recents[""open_files""]:
                self.recents[""open_files""].remove(file_path_before_save)
                self._update_recent_files_menu()
        self.tab_widget.removeTab(index)
        widget.deleteLater()
        if file_path_before_save:
            self.statusBar().showMessage(f""Zamknięto plik: {os.path.basename(file_path_before_save)}"")
        else:
            self.statusBar().showMessage(""Zamknięto plik."")
        self._save_app_state()

    def _close_current_tab(self):
        current_index = self.tab_widget.currentIndex()
        if current_index != -1:
            self._close_tab_by_index(current_index)

    def _save_current_file(self):
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego pliku do zapisu."")
            return False
        file_path = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is current_widget:
                file_path = path
                break
        is_existing_valid_file = file_path and os.path.exists(file_path) and QFileInfo(file_path).isFile()
        if is_existing_valid_file:
            return self._save_file(current_widget, file_path)
        else:
            return self._save_current_file_as()

    def _save_current_file_as(self):
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego pliku do zapisu."")
            return False
        old_file_path = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is current_widget:
                old_file_path = path
                break
        suggested_name = ""bez_nazwy.txt""
        current_tab_index = self.tab_widget.indexOf(current_widget)
        if current_tab_index != -1:
            original_tab_text = self.tab_widget.tabText(current_tab_index).rstrip('*')
            if original_tab_text and original_tab_text != ""Nowy plik"":
                suggested_name = original_tab_text
            elif current_widget.document().toPlainText().strip():
                first_line = current_widget.document().toPlainText().strip().split('\n')[0].strip()
                if first_line:
                    suggested_name = re.sub(r'[\\/:*?""<>|]', '_', first_line)
                    suggested_name = suggested_name[:50].strip()
                    if not suggested_name:
                        suggested_name = ""bez_nazwy""
                    if '.' not in os.path.basename(suggested_name):
                        suggested_name += "".txt""
                else:
                    suggested_name = ""bez_nazwy.txt""
        start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
        if old_file_path and os.path.dirname(old_file_path):
            start_path = os.path.dirname(old_file_path)
        elif os.path.isdir(start_path):
            pass
        else:
            start_path = os.path.expanduser(""~"")
        file_filters = ""Wszystkie pliki (*);;Pliki Pythona (*.py);;Pliki JavaScript (*.js);;Pliki HTML (*.html);;Pliki CSS (*.css);;Pliki C++ (*.c *.cpp *.h *.hpp);;Pliki INI (*.ini);;Pliki JSON (*.json)""
        new_file_path, _ = QFileDialog.getSaveFileName(self, ""Zapisz plik jako..."", os.path.join(start_path, suggested_name), file_filters)
        if not new_file_path:
            self.statusBar().showMessage(""Zapisywanie anulowane."")
            return False
        new_file_path = os.path.normpath(new_file_path)
        if old_file_path and old_file_path != new_file_path:
            if old_file_path in self.open_files:
                del self.open_files[old_file_path]
            if old_file_path in self.recents[""open_files""]:
                self.recents[""open_files""].remove(old_file_path)
                self._update_recent_files_menu()
        self.open_files[new_file_path] = current_widget
        current_tab_index = self.tab_widget.indexOf(current_widget)
        if current_tab_index != -1:
            self.tab_widget.setTabText(current_tab_index, os.path.basename(new_file_path))
        if new_file_path in self.recents[""open_files""]:
            self.recents[""open_files""].remove(new_file_path)
        self.recents[""open_files""].insert(0, new_file_path)
        self._update_recent_files_menu()
        language = self._get_language_from_path(new_file_path)
        old_highlighter = getattr(current_widget.document(), '_syntax_highlighter', None)
        if old_highlighter:
            old_highlighter.setDocument(None)
        new_highlighter = CodeSyntaxHighlighter(current_widget.document(), language)
        setattr(current_widget.document(), '_syntax_highlighter', new_highlighter)
        return self._save_file(current_widget, new_file_path)

    def _save_file(self, editor_widget, file_path):
        if not file_path:
            print(""Error: _save_file called with empty path."", file=sys.stderr)
            self.statusBar().showMessage(""Błąd wewnętrzny: próba zapisu bez ścieżki."")
            return False
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(editor_widget.toPlainText())
            editor_widget.document().setModified(False)
            self.statusBar().showMessage(f""Plik zapisano pomyślnie: {os.path.basename(file_path)}"")
            tab_index = self.tab_widget.indexOf(editor_widget)
            if tab_index != -1:
                current_tab_text = self.tab_widget.tabText(tab_index).rstrip('*')
                self.tab_widget.setTabText(tab_index, current_tab_text)
            file_info = QFileInfo(file_path)
            dir_path = file_info.dir().path()
            root_path = self.project_model.rootPath()
            if root_path and dir_path.startswith(root_path):
                dir_index = self.project_model.index(dir_path)
                if dir_index.isValid():
                    self.project_model.refresh(dir_index)
                file_index = self.project_model.index(file_path)
                if file_index.isValid():
                    self.project_model.dataChanged.emit(file_index, file_index, [Qt.ItemDataRole.DisplayRole, Qt.ItemDataRole.DecorationRole])
            if file_path in self.recents[""open_files""]:
                self.recents[""open_files""].remove(file_path)
            self.recents[""open_files""].insert(0, file_path)
            self._update_recent_files_menu()
            self._save_app_state()
            return True
        except Exception as e:
            QMessageBox.critical(self, ""Błąd zapisu pliku"", f""Nie można zapisać pliku {os.path.basename(file_path)}:\n{e}"")
            self.statusBar().showMessage(f""Błąd zapisu pliku: {os.path.basename(file_path)}"")
            return False

    def _save_all_files(self):
        unsaved_files = [path for path, editor in self.open_files.items() if editor.document().isModified()]
        if not unsaved_files:
            self.statusBar().showMessage(""Brak zmodyfikowanych plików do zapisu."")
            return True
        self.statusBar().showMessage(f""Zapisywanie wszystkich zmodyfikowanych plików ({len(unsaved_files)})..."")
        total_saved = 0
        total_failed = 0
        files_to_save = list(unsaved_files)
        for file_path in files_to_save:
            editor_widget = self.open_files.get(file_path)
            if editor_widget is None or self.tab_widget.indexOf(editor_widget) == -1:
                print(f""Warning: Skipping save for {file_path} - editor widget not found or invalid."", file=sys.stderr)
                continue
            if not editor_widget.document().isModified():
                continue
            needs_save_as = (file_path is None or
                             not os.path.exists(file_path) or
                             not QFileInfo(file_path).isFile())
            save_success = False
            if needs_save_as:
                tab_index = self.tab_widget.indexOf(editor_widget)
                if tab_index != -1:
                    original_index = self.tab_widget.currentIndex()
                    self.tab_widget.setCurrentIndex(tab_index)
                    save_success = self._save_current_file_as()
                    if original_index != -1 and original_index < self.tab_widget.count():
                        self.tab_widget.setCurrentIndex(original_index)
                else:
                    print(f""Error: Cannot save '{os.path.basename(file_path if file_path else 'Nowy plik')}' (Save As needed) - widget not found in tabs."", file=sys.stderr)
                    total_failed += 1
                    continue
            else:
                save_success = self._save_file(editor_widget, file_path)
            if save_success:
                total_saved += 1
            else:
                total_failed += 1
        if total_saved > 0 and total_failed == 0:
            self.statusBar().showMessage(f""Zapisano pomyślnie wszystkie {total_saved} pliki."")
            return True
        elif total_saved > 0 and total_failed > 0:
            self.statusBar().showMessage(f""Zapisano {total_saved} plików, {total_failed} plików nie udało się zapisać."")
            QMessageBox.warning(self, ""Błąd zapisu wszystkich plików"", f""Nie udało się zapisać {total_failed} plików."")
            return False
        elif total_saved == 0 and total_failed > 0:
            self.statusBar().showMessage(f""Nie udało się zapisać żadnego z {total_failed} plików."")
            QMessageBox.critical(self, ""Błąd zapisu wszystkich plików"", f""Nie udało się zapisać żadnego z plików."")
            return False
        else:
            self.statusBar().showMessage(""Brak zmodyfikowanych plików do zapisu."")
            return True

    def _handle_modification_changed(self, modified):
        editor_document = self.sender()
        if not isinstance(editor_document, QTextDocument):
            return
        editor = None
        for editor_widget in self.open_files.values():
            if editor_widget.document() is editor_document:
                editor = editor_widget
                break
        if editor is None:
            return
        index = self.tab_widget.indexOf(editor)
        if index != -1:
            tab_text = self.tab_widget.tabText(index)
            if modified and not tab_text.endswith('*'):
                self.tab_widget.setTabText(index, tab_text + '*')
            elif not modified and tab_text.endswith('*'):
                self.tab_widget.setTabText(index, tab_text.rstrip('*'))

    def _handle_tab_change(self, index):
        self._hide_find_bar()
        if index != -1:
            widget = self.tab_widget.widget(index)
            if isinstance(widget, QPlainTextEdit):
                file_path = next((path for path, ed in self.open_files.items() if ed is widget), None)
                if file_path:
                    self.statusBar().showMessage(f""Edytujesz: {os.path.basename(file_path)}"")
                else:
                    self.statusBar().showMessage(""Edytujesz: Nowy plik"")
        else:
            self.statusBar().showMessage(""Gotowy."")

    def _find_text(self, text, direction='next'):
        editor = self.tab_widget.currentWidget()
        if not isinstance(editor, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego edytora do wyszukiwania."")
            return
        if not text:
            self.statusBar().showMessage(""Wpisz tekst do wyszukiwania."")
            return
        flags = QTextDocument.FindFlag(0)
        if direction == 'previous':
            flags |= QTextDocument.FindFlag.FindBackward
        found = editor.find(text, flags)
        if found:
            self.statusBar().showMessage(f""Znaleziono '{text}'."")
        else:
            self.statusBar().showMessage(f""Nie znaleziono '{text}'. Zawijanie..."")
            cursor = editor.textCursor()
            original_position = cursor.position()
            cursor.clearSelection()
            cursor.movePosition(cursor.MoveOperation.Start if direction == 'next' else cursor.MoveOperation.End)
            editor.setTextCursor(cursor)
            found_wrapped = editor.find(text, flags)
            if found_wrapped:
                self.statusBar().showMessage(f""Znaleziono '{text}' po zawinięciu."")
            else:
                self.statusBar().showMessage(f""Nie znaleziono '{text}' w całym pliku."")
                cursor.clearSelection()
                cursor.setPosition(original_position)
                editor.setTextCursor(cursor)

    def _show_find_bar(self):
        if self.search_input.isVisible():
            self._hide_find_bar()
            return
        self.search_input.setVisible(True)
        self.find_next_button.setVisible(True)
        self.find_prev_button.setVisible(True)
        self.search_input.setFocus()

    def _hide_find_bar(self):
        if self.search_input.isVisible():
            self.search_input.setVisible(False)
            self.find_next_button.setVisible(False)
            self.find_prev_button.setVisible(False)
            self.search_input.clear()

    def _run_current_file(self):
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.console_widget.console.appendPlainText(""Brak aktywnego pliku do uruchomienia."")
            self.statusBar().showMessage(""Błąd: Żaden plik nie jest otwarty."")
            return
        file_path = next((path for path, editor_widget in self.open_files.items() if editor_widget is current_widget), None)
        if not file_path or not os.path.exists(file_path) or not os.path.isfile(file_path):
            self.console_widget.console.appendPlainText(""Ścieżka aktywnego pliku jest nieprawidłowa lub plik nie istnieje."")
            self.statusBar().showMessage(""Błąd: Plik nie istnieje."")
            return
        if current_widget.document().isModified():
            if not self._save_file(current_widget, file_path):
                self.console_widget.console.appendPlainText(""Nie udało się zapisać pliku przed uruchomieniem."")
                self.statusBar().showMessage(""Błąd: Nie zapisano pliku."")
                return
        language = self._get_language_from_path(file_path)
        working_dir = os.path.dirname(file_path) or self.current_project_dir or os.getcwd()
        command = None
        if language == ""python"":
            python_path = self.settings.get(""python_path"", ""python"")
            if not python_path:
                self.console_widget.console.appendPlainText(""Błąd uruchamiania! Zainstaluj dodatek Python poprzez Menadżer Pakietów"")
                self.statusBar().showMessage(""Błąd: Brak interpretera Python."")
                return
            command = f'""{python_path}"" ""{file_path}""'
        elif language == ""javascript"":
            node_path = self.settings.get(""node_path"", ""node"")
            command = f'""{node_path}"" ""{file_path}""'
        elif language in [""c"", ""cpp""]:
            output_exe = os.path.splitext(file_path)[0] + ("".exe"" if platform.system() == ""Windows"" else """")
            compile_command = f'g++ ""{file_path}"" -o ""{output_exe}""'
            self.console_widget.console.appendPlainText(f""Kompilowanie: {compile_command}"")
            self.console_manager.run_command(compile_command, working_dir)
            # Czekaj na zakończenie kompilacji (może wymagać osobnego procesu)
            # Zakładam, że proces jest synchroniczny dla uproszczenia
            # Jeśli kompilacja się udała, uruchom program
            self.console_manager.run_command(f'""{output_exe}""', working_dir)
            return
        else:
            self.console_widget.console.appendPlainText(f""Uruchamianie nieobsługiwane dla języka: {language}"")
            self.statusBar().showMessage(f""Błąd: Nie można uruchomić pliku {os.path.basename(file_path)}."")
            return
        if command:
            self.console_widget.console.appendPlainText(f""Uruchamianie: {command}"")
            self.console_manager.run_command(command, working_dir, self.settings.get(""python_path"", """"), self.settings.get(""node_path"", """"))
            self.statusBar().showMessage(f""Uruchamianie: {os.path.basename(file_path)}"")

    def _get_language_from_path(self, file_path):
        return get_file_language(file_path)

    def _apply_theme(self, theme_name):
        apply_theme(self, theme_name)
        self.settings[""theme""] = theme_name
        self._save_app_state()
        self.statusBar().showMessage(f""Zastosowano motyw: {theme_name}"")

    def _apply_editor_font_size(self):
        font_size = self.settings.get(""editor_font_size"", 10)
        self.base_editor_font.setPointSize(font_size)
        for editor in self.open_files.values():
            editor.setFont(self.base_editor_font)

    def _show_settings_dialog(self):
        dialog = SettingsDialog(self.settings, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_settings = dialog.get_settings()
            self.settings.update(new_settings)
            self._apply_theme(self.settings[""theme""])
            self._apply_editor_font_size()
            self.ai_chat_manager.update_settings(self.settings)
            self._save_app_state()
            self.statusBar().showMessage(""Zapisano ustawienia."")

    def _show_package_manager(self):
        if not self.current_project_dir:
            QMessageBox.warning(self, ""Brak projektu"", ""Otwórz lub utwórz projekt, aby zarządzać pakietami."")
            return
        dialog = PackageManagerDialog(self.current_project_dir, self)
        dialog.exec()
        # Po zamknięciu menadżera pakietów wczytaj ponownie ustawienia z pliku settings.json
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                    # Automatyczne wyszukiwanie python.exe jeśli nie ma ścieżki lub jest pusta
                    python_path = loaded_settings.get(""python_path"", """")
                    if not python_path:
                        import glob
                        python_candidates = glob.glob(os.path.join(ROOT_DIR, ""packages"", ""python"", ""**"", ""python.exe""), recursive=True)
                        if python_candidates:
                            python_path = python_candidates[0]
                            loaded_settings[""python_path""] = python_path
                            # Zapisz poprawioną ścieżkę do settings.json
                            with open(SETTINGS_FILE, 'w', encoding='utf-8') as fw:
                                json.dump(loaded_settings, fw, indent=4)
                    self.settings.update({
                        ""python_path"": python_path or self.settings.get(""python_path"", """"),
                        ""node_path"": loaded_settings.get(""node_path"", self.settings.get(""node_path"", """")),
                        ""theme"": loaded_settings.get(""theme"", self.settings.get(""theme"", ""light"")),
                        ""editor_font_size"": loaded_settings.get(""editor_font_size"", self.settings.get(""editor_font_size"", 10)),
                        ""show_tree"": loaded_settings.get(""show_tree"", self.settings.get(""show_tree"", True)),
                        ""show_console"": loaded_settings.get(""show_console"", self.settings.get(""show_console"", True)),
                        ""api_key"": loaded_settings.get(""api_key"", self.settings.get(""api_key"", """")),
                        ""gemini_api_key"": loaded_settings.get(""gemini_api_key"", self.settings.get(""gemini_api_key"", """")),
                        ""mistral_api_key"": loaded_settings.get(""mistral_api_key"", self.settings.get(""mistral_api_key"", """")),
                        ""ai_model"": loaded_settings.get(""ai_model"", self.settings.get(""ai_model"", ""grok-3"")),
                        ""ai_provider"": loaded_settings.get(""ai_provider"", self.settings.get(""ai_provider"", ""grok"")),
                    })
            self._apply_theme(self.settings.get(""theme"", ""light""))
            self._apply_editor_font_size()
        except Exception as e:
            print(f""Błąd podczas ponownego wczytywania ustawień po menadżerze pakietów: {e}"", file=sys.stderr)

    def _show_about_dialog(self):
        QMessageBox.about(
            self,
            ""O programie"",
            ""Proste IDE\nWersja 1.0\nStworzone dla zajebistych kodersów, którzy nie lubią komplikacji.\n© 2025 Paffcio & xAI""
        )

    def _check_package_json(self, project_dir):
        self.node_scripts.clear()
        package_json_path = os.path.join(project_dir, ""package.json"")
        if os.path.exists(package_json_path):
            package_data = load_package_json(package_json_path)
            scripts = package_data.get(""scripts"", {})
            self.node_scripts.update(scripts)
        self._update_run_button_menu()

    def _update_run_button_menu(self):
        menu = QMenu(self)
        menu.addAction(self.action_run_file)
        if self.node_scripts and self.current_project_dir:
            node_menu = menu.addMenu(""Uruchom skrypt Node.js"")
            node_path = self.settings.get(""node_path"", ""node"")
            for script_name in self.node_scripts:
                action = QAction(script_name, self)
                command = f'""{node_path}"" run {script_name}'
                action.triggered.connect(
                    lambda checked, cmd=command: self.process.start(cmd, working_dir=self.current_project_dir)
                )
                node_menu.addAction(action)
        self.run_toolbutton.setMenu(menu)

    def _handle_tree_item_double_click(self, index):
        if not index.isValid():
            return
        file_path = self.project_model.filePath(index)
        file_info = self.project_model.fileInfo(index)
        if file_info.isFile():
            self._open_file(file_path)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = IDEWindow()
    window.show()
    sys.exit(app.exec())

Ścieżka: /src/utils.py
Rozmiar: 1,71 KB
Zawartość:
import os
import json
import re
import sys


def load_package_json(folder_path):
    """"""Parsuje package.json i zwraca skrypty npm.""""""
    if not folder_path or not os.path.isdir(folder_path):
        return {}
    package_json_path = os.path.join(folder_path, 'package.json')
    scripts = {}
    if os.path.exists(package_json_path):
        try:
            with open(package_json_path, 'r', encoding='utf-8') as f:
                package_data = json.load(f)
            scripts = package_data.get('scripts', {})
            if not isinstance(scripts, dict):
                scripts = {}
        except (json.JSONDecodeError, Exception) as e:
            print(f""Błąd parsowania package.json: {e}"", file=sys.stderr)
            return {}
    return scripts


def get_file_language(file_path):
    """"""Określa język programowania na podstawie rozszerzenia pliku.""""""
    extension = os.path.splitext(file_path)[1].lower()
    language_map = {
        '.py': 'python',
        '.pyw': 'python',
        '.js': 'javascript',
        '.ts': 'javascript',
        '.html': 'html',
        '.htm': 'html',
        '.css': 'css',
        '.c': 'c',
        '.cpp': 'cpp',
        '.cc': 'cpp',
        '.h': 'cpp',
        '.hpp': 'cpp',
        '.json': 'json',
        '.ini': 'ini',
        '.bat': 'batch',
        '.sh': 'bash',
        '.ps1': 'powershell',
        '.rb': 'ruby',
        '.java': 'java',
        '.go': 'go',
        '.rs': 'rust',
        '.php': 'php',
        '.xml': 'xml',
        '.md': 'markdown',
        '.txt': 'text',
    }
    return language_map.get(extension, 'text')  # Domyślnie 'text' dla nieznanych

__all__ = ['load_package_json', 'get_file_language']


// SKRYPT ZAKOŃCZONY: 18-05-2025 17:13:29
// RAPORT: Przetworzono 12 plików tekstowych, 0 nietekstowych, pominięto 1.
"
Dd5Vjjxy,2025-05-18T09:35:45.284786,powerampache,PHP,Sunday 18th of May 2025 09:35:45 AM CDT,"1.01-80-play (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:959)
	at android.os.Handler.dispatchMessage(Handler.java:100)
	at android.os.Looper.loopOnce(Looper.java:257)
	at android.os.Looper.loop(Looper.java:342)
	at android.app.ActivityThread.main(ActivityThread.java:9579)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:619)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:929)

scrobble() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
pyZr5xaW,2025-05-18T16:05:53.963542,powerampache,PHP,Sunday 18th of May 2025 09:05:55 AM CDT,"1.01-80 (80) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /192.168.88.7 (port 80) from /10.21.14.164 (port 49382) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

authorize() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /192.168.88.7 (port 80) from /10.21.14.164 (port 49382) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /192.168.88.7 (port 80) from /10.21.14.164 (port 49382) after 15000ms\"" }"",""stackTrace"":[]}"
TPxTdcDT,Melody,Fraeric123,Lua,Sunday 18th of May 2025 08:35:00 AM CDT,"local computer = require(""computer"")

melody = {
  {660, 0.1}, {660, 0.1}, {0, 0.1}, {660, 0.1},
  {0, 0.1}, {510, 0.1}, {660, 0.1}, {0, 0.1},
  {770, 0.1}, {0, 0.3}, {380, 0.1}, {0, 0.3},

  {510, 0.1}, {0, 0.1}, {380, 0.1}, {0, 0.1},
  {320, 0.1}, {0, 0.2}, {440, 0.1}, {0, 0.1},
  {480, 0.1}, {0, 0.1}, {450, 0.1}, {0, 0.1},
  {430, 0.1}, {0, 0.1}, {380, 0.1}, {660, 0.1},
  {760, 0.1}, {860, 0.1}, {0, 0.1},

  {700, 0.1}, {800, 0.1}, {660, 0.1}, {0, 0.1},
  {520, 0.1}, {580, 0.1}, {480, 0.1}, {0, 0.2},

  {510, 0.1}, {0, 0.1}, {380, 0.1}, {0, 0.1},
  {320, 0.1}, {0, 0.2}, {440, 0.1}, {0, 0.1},
  {480, 0.1}, {0, 0.1}, {450, 0.1}, {0, 0.1},
  {430, 0.1}, {0, 0.1}, {380, 0.1}, {660, 0.1},
  {760, 0.1}, {860, 0.1}, {0, 0.1},

  {700, 0.1}, {800, 0.1}, {660, 0.1}, {0, 0.1},
  {520, 0.1}, {580, 0.1}, {480, 0.1}, {0, 0.2}
}


function music()
	for _, note in ipairs(melody) do
		print(note[1], note[2])
	    if note[1] == 0 then os.sleep(note[2]) else computer.beep(note[1], note[2]) end
	end
	music()
end

music()"
EzYx6RGL,Untitled,PaffcioStudio,Lua,Sunday 18th of May 2025 08:25:03 AM CDT,"import os
import sys
import threading
import traceback
import time
import re
import platform
import json
import subprocess
import tempfile
import shutil # Added for recursive directory deletion
from datetime import datetime

# Conditional imports for AI APIs
try:
    import google.generativeai as genai
    HAS_GEMINI = True
except ImportError:
    print(""Warning: google-generativeai not found. Gemini API support disabled."")
    HAS_GEMINI = False
    class MockGeminiModel: # Mock class to prevent errors if genai is missing
        def __init__(self, model_name): self.model_name = model_name
        def start_chat(self, history): return MockChatSession()
    class MockChatSession:
        def send_message(self, message, stream=True):
            class MockChunk: text = ""Mock Gemini Response (API not available)""
            return [MockChunk()]
    genai = type('genai', (object,), {'GenerativeModel': MockGeminiModel, 'configure': lambda *args, **kwargs: None})()

try:
    from mistralai.client import MistralClient
    from mistralai.models.chat_models import ChatMessage
    HAS_MISTRAL = True
except ImportError:
    print(""Warning: mistralai not found. Mistral API support disabled."")
    HAS_MISTRAL = False
    class MockMistralClient: # Mock class to prevent errors if mistralai is missing
        def __init__(self, api_key): pass
        def chat(self, model, messages, stream=True):
            class MockChunk:
                choices = [type('MockChoice', (object,), {'delta': type('MockDelta', (object,), {'content': ""Mock Mistral Response (API not available)""})()})()]
            return [MockChunk()]
    ChatMessage = lambda role, content: {'role': role, 'content': content} # Mock ChatMessage
    MistralClient = MockMistralClient

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QListWidget, QLineEdit, QLabel, QMessageBox,
    QTextEdit, QScrollArea, QSizePolicy,
    QDialog, QDialogButtonBox, QComboBox, QFileDialog,
    QTabWidget, QSplitter, QTreeView,
    QMenu, QStatusBar, QToolBar, QToolButton, QSystemTrayIcon,
    QSpinBox, QCheckBox, QInputDialog, QAbstractItemView
)

from PyQt6.QtGui import (
    QIcon, QFontMetrics, QFont, QTextOption, QColor,
    QGuiApplication, QClipboard, QPalette, QBrush,
    QTextCursor, QAction, QDesktopServices, QTextCharFormat,
    QSyntaxHighlighter, QTextDocument, QFileSystemModel, QPainter, QTextFormat
)

from PyQt6.QtCore import (
    Qt, QThread, pyqtSignal, QSize, QMutex, QTimer, QObject,
    QRect, QFileInfo, QDir, QStandardPaths, QUrl, QModelIndex
)

from PyQt6.QtPrintSupport import QPrintDialog, QPrinter
# Importy Pygments do kolorowania składni

from pygments import highlight
from pygments.lexers import get_lexer_by_name, guess_lexer, ClassNotFound
from pygments.formatters import HtmlFormatter
from pygments.util import ClassNotFound as PygmentsClassNotFound
# --- Constants ---

SETTINGS_FILE = ""./editor_settings.json""
# List of models the application should attempt to use.
# Structure: (API_TYPE, MODEL_IDENTIFIER, DISPLAY_NAME)
# API_TYPE can be ""gemini"" or ""mistral""
# MODEL_IDENTIFIER is the string used by the respective API library
# DISPLAY_NAME is what's shown to the user
AVAILABLE_MODELS_CONFIG = [
    (""gemini"", ""gemini-1.5-flash-latest"", ""Gemini 1.5 Flash (Latest)""),
    (""gemini"", ""gemini-1.5-pro-latest"", ""Gemini 1.5 Pro (Latest)""),
    (""gemini"", ""gemini-2.0-flash-thinking-exp-1219"", ""Gemini 2.0 Flash (Experimental)""),
    (""gemini"", ""gemini-2.5-flash-preview-04-17"", ""Gemini 2.5 Flash (Preview)""),
    (""mistral"", ""codestral-latest"", ""Codestral (Latest)""),  # Example Codestral model
    (""mistral"", ""mistral-large-latest"", ""Mistral Large (Latest)""),
    (""mistral"", ""mistral-medium"", ""Mistral Medium""),
    (""mistral"", ""mistral-small"", ""Mistral Small""),
    (""mistral"", ""mistral-tiny"", ""Mistral Tiny""),
]


# Determine which models are actually available based on installed libraries
ACTIVE_MODELS_CONFIG = []
for api_type, identifier, name in AVAILABLE_MODELS_CONFIG:
    if api_type == ""gemini"" and HAS_GEMINI:
        ACTIVE_MODELS_CONFIG.append((api_type, identifier, name))
    elif api_type == ""mistral"" and HAS_MISTRAL:
        ACTIVE_MODELS_CONFIG.append((api_type, identifier, name))

if not ACTIVE_MODELS_CONFIG:
    # QMessageBox.critical(None, ""Błąd API"", ""Brak dostępnych API. Proszę zainstalować google-generativeai lub mistralai."")
    print(""Warning: No AI APIs available. AI features will be disabled."")
    # Fallback to a dummy entry if no APIs are available, to prevent crashes
    ACTIVE_MODELS_CONFIG = [(""none"", ""none"", ""Brak dostępnych modeli"")]


DEFAULT_MODEL_CONFIG = ACTIVE_MODELS_CONFIG[0] if ACTIVE_MODELS_CONFIG else (""none"", ""none"", ""Brak"") # Use the first active model as default

RECENT_FILES_MAX = 10
DEFAULT_FONT_SIZE = 12
DEFAULT_THEME = ""dark""
GEMINI_API_KEY_FILE = ""./.api_key"" # Keep original Google key file

# --- Syntax Highlighter Classes ---
# (PythonHighlighter, CSSHighlighter, HTMLHighlighter, JSHighlighter, GMLHighlighter - copied from your code)
# ... (Paste your Syntax Highlighter classes here) ...
class PythonHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        keywords = [
            'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',
            'elif', 'else', 'except', 'False', 'finally', 'for', 'from', 'global',
            'if', 'import', 'in', 'is', 'lambda', 'None', 'nonlocal', 'not', 'or',
            'pass', 'raise', 'return', 'True', 'try', 'while', 'with', 'yield'
        ]
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(""#569CD6""))  # Blue
        keyword_format.setFontWeight(QFont.Weight.Bold)
        self.highlight_rules.extend([(r'\b%s\b' % kw, keyword_format) for kw in keywords])

        string_format = QTextCharFormat()
        string_format.setForeground(QColor(""#CE9178""))  # Orange
        self.highlight_rules.append((r'""[^""\\]*(\\.[^""\\]*)*""', string_format))
        self.highlight_rules.append((r""'[^'\\]*(\\.[^'\\]*)*'"", string_format))

        function_format = QTextCharFormat()
        function_format.setForeground(QColor(""#DCDCAA""))  # Light yellow
        self.highlight_rules.append((r'\b[A-Za-z_][A-Za-z0-9_]*\s*(?=\()', function_format))

        number_format = QTextCharFormat()
        number_format.setForeground(QColor(""#B5CEA8""))  # Green
        self.highlight_rules.append((r'\b[0-9]+\b', number_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'#[^\n]*', comment_format))

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            matches = expression.finditer(text)
            for match in matches:
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)

class CSSHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        keywords = ['color', 'font', 'margin', 'padding', 'display', 'position', 'transition']
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(""#ff6ac1""))  # Pinkish
        keyword_format.setFontWeight(QFont.Weight.Bold)
        self.highlight_rules.extend([(r'\b%s\b' % kw, keyword_format) for kw in keywords])

        value_format = QTextCharFormat()
        value_format.setForeground(QColor(""#ce9178""))  # Orange
        self.highlight_rules.append((r'#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})', value_format))
        self.highlight_rules.append((r'rgb[a]?\([^)]+\)', value_format))

        selector_format = QTextCharFormat()
        selector_format.setForeground(QColor(""#dcdcAA""))  # Light yellow
        self.highlight_rules.append((r'^\s*[^{]+(?={)', selector_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'/\*.*?\*/', comment_format), re.DOTALL)

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            for match in expression.finditer(text):
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)

class HTMLHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        tag_format = QTextCharFormat()
        tag_format.setForeground(QColor(""#569CD6""))  # Blue
        self.highlight_rules.append((r'</?[\w-]+>', tag_format))

        attr_format = QTextCharFormat()
        attr_format.setForeground(QColor(""#9cdcfe""))  # Light blue
        self.highlight_rules.append((r'[\w-]+(?=\s*=)', attr_format))

        value_format = QTextCharFormat()
        value_format.setForeground(QColor(""#ce9178""))  # Orange
        self.highlight_rules.append((r'=""[^""]*""', value_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'<!--[\s\S]*?-->', comment_format))

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            for match in expression.finditer(text):
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)

class JSHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        keywords = ['var', 'let', 'const', 'function', 'if', 'else', 'return', 'for', 'while']
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(""#c586c0""))  # Purple
        keyword_format.setFontWeight(QFont.Weight.Bold)
        self.highlight_rules.extend([(r'\b%s\b' % kw, keyword_format) for kw in keywords])

        string_format = QTextCharFormat()
        string_format.setForeground(QColor(""#ce9178""))  # Orange
        self.highlight_rules.append((r'""[^""\\]*(\\.[^""\\]*)*""', string_format))
        self.highlight_rules.append((r""'[^'\\]*(\\.[^'\\]*)*'"", string_format))

        function_format = QTextCharFormat()
        function_format.setForeground(QColor(""#dcdcaa""))  # Light yellow
        self.highlight_rules.append((r'\b[A-Za-z_][A-Za-z0-9_]*\s*(?=\()', function_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'//[^\n]*', comment_format))
        self.highlight_rules.append((r'/\*[\s\S]*?\*/', comment_format), re.DOTALL)

    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            for match in expression.finditer(text):
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)

class GMLHighlighter(QSyntaxHighlighter):
    def __init__(self, document):
        super().__init__(document)
        self.highlight_rules = []

        keywords = ['if', 'else', 'switch', 'case', 'break', 'return', 'var', 'with', 'while']
        keyword_format = QTextCharFormat()
        keyword_format.setForeground(QColor(""#c586c0""))  # Purple
        keyword_format.setFontWeight(QFont.Weight.Bold)
        self.highlight_rules.extend([(r'\b%s\b' % kw, keyword_format) for kw in keywords])

        var_format = QTextCharFormat()
        var_format.setForeground(QColor(""#4ec9b0""))  # Teal
        self.highlight_rules.append((r'_[a-zA-Z][a-zA-Z0-9]*', var_format))

        func_format = QTextCharFormat()
        func_format.setForeground(QColor(""#dcdcaa""))  # Light yellow
        gml_funcs = ['instance_create', 'ds_list_add', 'draw_text']
        self.highlight_rules.extend([(r'\b%s\b(?=\()', func_format) for func in gml_funcs])

        string_format = QTextCharFormat()
        string_format.setForeground(QColor(""#ce9178""))  # Orange
        self.highlight_rules.append((r'""[^""\\]*(\\.[^""\\]*)*""', string_format))

        comment_format = QTextCharFormat()
        comment_format.setForeground(QColor(""#6A9955""))  # Green
        comment_format.setFontItalic(True)
        self.highlight_rules.append((r'//[^\n]*', comment_format))
        self.highlight_rules.append((r'/\*[\s\S]*?\*/', comment_format), re.DOTALL)


    def highlightBlock(self, text):
        for pattern, format in self.highlight_rules:
            expression = re.compile(pattern)
            for match in expression.finditer(text):
                start = match.start()
                length = match.end() - start
                self.setFormat(start, length, format)
# --- End of Syntax Highlighter Classes ---

# --- API Key Loading ---

def load_gemini_api_key(filepath=GEMINI_API_KEY_FILE):
    """"""Reads Gemini API key from a file.""""""
    if not os.path.exists(filepath):
        # Don't show critical error if file is just missing, allow user to configure in settings
        print(f""Gemini API key file not found: {filepath}. Please add key in settings."")
        return None
    try:
        with open(filepath, ""r"") as f:
            key = f.read().strip()
            if not key:
                print(f""Gemini API key file is empty: {filepath}. Please add key in settings."")
                return None
            return key
    except Exception as e:
        print(f""Error reading Gemini API key file: {filepath}\nError: {e}"")
        # QMessageBox.warning(None, ""Błąd odczytu klucza API"", f""Nie można odczytać pliku klucza API Google Gemini: {filepath}\nBłąd: {e}"")
        return None

# Load Gemini key initially, but allow overriding/setting in settings
GEMINI_API_KEY_GLOBAL = load_gemini_api_key()

# --- Configure APIs (Initial) ---
# This configuration should happen *after* loading settings in the main window,
# where the Mistral key from settings is also available.
# The current global configuration is okay for checking HAS_GEMINI but actual
# worker instances need potentially updated keys from settings.

# --- Settings Persistence ---

def load_settings():
    """"""Loads settings from a JSON file.""""""
    # Determine default model based on active APIs
    default_model_config = ACTIVE_MODELS_CONFIG[0] if ACTIVE_MODELS_CONFIG else (""none"", ""none"", ""Brak"")
    default_api_type = default_model_config[0]
    default_model_identifier = default_model_config[1]

    default_settings = {
        ""api_type"": default_api_type, # New field to store active API type
        ""model_identifier"": default_model_identifier, # New field to store model identifier
        ""mistral_api_key"": None, # New field for Mistral key
        ""recent_files"": [],
        ""font_size"": DEFAULT_FONT_SIZE,
        ""theme"": DEFAULT_THEME,
        ""workspace"": """",
        ""show_sidebar"": True,
        ""show_statusbar"": True,
        ""show_toolbar"": True
    }

    try:
        if os.path.exists(SETTINGS_FILE):
            with open(SETTINGS_FILE, 'r') as f:
                settings = json.load(f)
                # Handle potential old format or missing new fields
                if ""api_type"" not in settings or ""model_identifier"" not in settings:
                    # Attempt to migrate from old ""model_name"" if it exists
                    old_model_name = settings.get(""model_name"", """")
                    found_match = False
                    for api_type, identifier, name in ACTIVE_MODELS_CONFIG:
                        if identifier == old_model_name or name == old_model_name: # Check both identifier and display name from old settings
                             settings[""api_type""] = api_type
                             settings[""model_identifier""] = identifier
                             found_match = True
                             break
                    if not found_match:
                        # Fallback to default if old name not found or no old name
                        settings[""api_type""] = default_api_type
                        settings[""model_identifier""] = default_model_identifier
                    if ""model_name"" in settings:
                         del settings[""model_name""] # Remove old field

                # Add defaults for any other missing keys (including new mistral_api_key)
                for key in default_settings:
                    if key not in settings:
                        settings[key] = default_settings[key]

                # Validate loaded model against active configurations
                is_active = any(s[0] == settings.get(""api_type"") and s[1] == settings.get(""model_identifier"") for s in ACTIVE_MODELS_CONFIG)
                if not is_active:
                     print(f""Warning: Loaded model config ({settings.get('api_type')}, {settings.get('model_identifier')}) is not active. Falling back to default."")
                     settings[""api_type""] = default_api_type
                     settings[""model_identifier""] = default_model_identifier


                return settings
        return default_settings
    except Exception as e:
        print(f""Błąd ładowania ustawień: {e}. Używam ustawień domyślnych."")
        return default_settings

def save_settings(settings: dict):
    """"""Saves settings to a JSON file.""""""
    try:
        with open(SETTINGS_FILE, 'w') as f:
            json.dump(settings, f, indent=4)
    except Exception as e:
        print(f""Błąd zapisywania ustawień: {e}"")

# --- API Formatting Helper ---
def format_chat_history(messages: list, api_type: str) -> list:
    """"""Formats chat history for different API types.""""""
    formatted_history = []
    for role, content, metadata in messages:
        # Skip assistant placeholder messages and internal error/empty messages
        if not (role == ""assistant"" and metadata is not None and metadata.get(""type"") in [""placeholder"", ""error"", ""empty_response""]):
            if api_type == ""gemini"":
                 # Gemini uses ""user"" and ""model"" roles
                 formatted_history.append({
                     ""role"": ""user"" if role == ""user"" else ""model"",
                     ""parts"": [content] # Gemini uses 'parts' with content
                 })
            elif api_type == ""mistral"":
                 # Mistral uses ""user"" and ""assistant"" roles
                 formatted_history.append(ChatMessage(role='user' if role == 'user' else 'assistant', content=content))
            # Add other API types here if needed
    return formatted_history

# --- API Worker Threads ---

class GeminiWorker(QThread):
    response_chunk = pyqtSignal(str)
    response_complete = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, api_key: str, user_message: str, chat_history: list, model_identifier: str, parent=None):
        super().__init__(parent)
        self.api_key = api_key
        self.user_message = user_message
        self.chat_history = chat_history # Raw history from main window
        self.model_identifier = model_identifier
        self._is_running = True
        self._mutex = QMutex()
        print(f""GeminiWorker created for model: {model_identifier}"")


    def stop(self):
        self._mutex.lock()
        try:
            self._is_running = False
        finally:
            self._mutex.unlock()

    def run(self):
        if not self.api_key:
            self.error.emit(""Klucz API Google Gemini nie został skonfigurowany."")
            return
        if not self.user_message.strip():
            self.error.emit(""Proszę podać niepustą wiadomość tekstową."")
            return

        try:
            # Format history for Gemini API
            api_history = format_chat_history(self.chat_history, ""gemini"")

            try:
                 # Attempt to get the model instance
                 genai.configure(api_key=self.api_key) # Ensure API key is used in this thread
                 model_instance = genai.GenerativeModel(self.model_identifier)

                 # Start chat with history
                 chat = model_instance.start_chat(history=api_history)

                 # Send message and get stream
                 response_stream = chat.send_message(self.user_message, stream=True)

            except Exception as api_err:
                error_str = str(api_err)
                if ""BlockedPromptException"" in error_str or (""FinishReason"" in error_str and ""SAFETY"" in error_str):
                     self.error.emit(f""Odpowiedź zablokowana przez filtry bezpieczeństwa."")
                elif ""Candidate.content is empty"" in error_str:
                     self.error.emit(f""Otrzymano pustą treść z API (możliwe, że zablokowana lub niepowodzenie)."")
                elif ""returned an invalid response"" in error_str or ""Could not find model"" in error_str or ""Invalid model name"" in error_str:
                     self.error.emit(f""API Gemini zwróciło nieprawidłową odpowiedź lub model '{self.model_identifier}' nie znaleziono. Proszę sprawdzić ustawienia modelu i klucz API.\nSzczegóły: {api_err}"")
                elif ""AUTHENTICATION_ERROR"" in error_str or ""Invalid API key"" in error_str:
                     self.error.emit(f""Błąd autoryzacji API Gemini. Proszę sprawdzić klucz API w ustawieniach."")
                else:
                    error_details = f""{type(api_err).__name__}: {api_err}""
                    if hasattr(api_err, 'status_code'):
                         error_details += f"" (Status: {api_err.status_code})""
                    self.error.emit(f""Wywołanie API Gemini nie powiodło się:\n{error_details}"")
                return

            try:
                full_response_text = """"
                # Process the response stream chunk by chunk
                for chunk in response_stream:
                    self._mutex.lock()
                    is_running = self._is_running
                    self._mutex.unlock()

                    if not is_running:
                        break

                    if not chunk.candidates:
                         continue

                    try:
                        # Concatenate text parts from the chunk
                        # Safely access candidates and content
                        text_parts = [part.text for candidate in chunk.candidates for part in candidate.content.parts if part.text]
                        current_chunk = """".join(text_parts)
                    except (AttributeError, IndexError) as e:
                         print(f""Warning: Could not access chunk text: {e}"")
                         current_chunk = """" # Handle cases where structure isn't as expected

                    if current_chunk:
                        full_response_text += current_chunk
                        self.response_chunk.emit(current_chunk)

                self._mutex.lock()
                stopped_manually = not self._is_running
                self._mutex.unlock()

                if not stopped_manually:
                    self.response_complete.emit()

            except Exception as stream_err:
                 self._mutex.lock()
                 was_stopped = not self._is_running
                 self._mutex.unlock()

                 if not was_stopped:
                     error_details = f""{type(stream_err).__name__}: {stream_err}""
                     self.error.emit(f""Błąd podczas strumieniowania odpowiedzi z API Gemini:\n{error_details}"")

        except Exception as e:
            error_details = f""{type(e).__name__}: {e}""
            self.error.emit(f""Wystąpił nieoczekiwany błąd w wątku roboczym Gemini:\n{error_details}\n{traceback.format_exc()}"")


class MistralWorker(QThread):
    response_chunk = pyqtSignal(str)
    response_complete = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, api_key: str, user_message: str, chat_history: list, model_identifier: str, parent=None):
        super().__init__(parent)
        self.api_key = api_key
        self.user_message = user_message
        self.chat_history = chat_history # Raw history from main window
        self.model_identifier = model_identifier
        self._is_running = True
        self._mutex = QMutex()
        print(f""MistralWorker created for model: {model_identifier}"")

    def stop(self):
        self._mutex.lock()
        try:
            self._is_running = False
        finally:
            self._mutex.unlock()

    def run(self):
        if not self.api_key:
            self.error.emit(""Klucz API Mistral nie został skonfigurowany w ustawieniach."")
            return
        if not self.user_message.strip():
            self.error.emit(""Proszę podać niepustą wiadomość tekstową."")
            return

        try:
            # Format history for Mistral API
            # Mistral API expects a list of ChatMessage objects or dicts {'role': '...', 'content': '...'}
            # The last message is the current user message, others are history
            api_messages = format_chat_history(self.chat_history, ""mistral"")
            api_messages.append(ChatMessage(role='user', content=self.user_message))


            try:
                 client = MistralClient(api_key=self.api_key)

                 response_stream = client.chat(
                     model=self.model_identifier,
                     messages=api_messages,
                     stream=True
                 )

            except Exception as api_err:
                error_str = str(api_err)
                # Add more specific error handling for Mistral API if needed
                if ""authentication_error"" in error_str.lower():
                     self.error.emit(f""Błąd autoryzacji API Mistral. Proszę sprawdzić klucz API w ustawieniach."")
                elif ""model_not_found"" in error_str.lower():
                     self.error.emit(f""Model Mistral '{self.model_identifier}' nie znaleziono lub jest niedostępny dla tego klucza API."")
                else:
                    error_details = f""{type(api_err).__name__}: {api_err}""
                    self.error.emit(f""Wywołanie API Mistral nie powiodło się:\n{error_details}"")
                return


            try:
                full_response_text = """"
                # Process the response stream chunk by chunk
                for chunk in response_stream:
                    self._mutex.lock()
                    is_running = self._is_running
                    self._mutex.unlock()

                    if not is_running:
                        break

                    # Mistral stream chunk structure: chunk.choices[0].delta.content
                    current_chunk = """"
                    if chunk.choices and chunk.choices[0].delta and chunk.choices[0].delta.content:
                        current_chunk = chunk.choices[0].delta.content

                    if current_chunk:
                        full_response_text += current_chunk
                        self.response_chunk.emit(current_chunk)

                self._mutex.lock()
                stopped_manually = not self._is_running
                self._mutex.unlock()

                if not stopped_manually:
                    self.response_complete.emit()

            except Exception as stream_err:
                 self._mutex.lock()
                 was_stopped = not self._is_running
                 self._mutex.unlock()

                 if not was_stopped:
                     error_details = f""{type(stream_err).__name__}: {stream_err}""
                     self.error.emit(f""Błąd podczas strumieniowania odpowiedzi z API Mistral:\n{error_details}"")

        except Exception as e:
            error_details = f""{type(e).__name__}: {e}""
            self.error.emit(f""Wystąpił nieoczekiwany błąd w wątku roboczym Mistral:\n{error_details}\n{traceback.format_exc()}"")


# --- Pygments Helper for Syntax Highlighting ---
# (highlight_code_html and related CSS - copied from your code)
# ... (Paste your Pygments helper functions and CSS here) ...
PYGMENTS_STYLE_NAME = 'dracula'
try:
    PYGMENTS_CSS = HtmlFormatter(style=PYGMENTS_STYLE_NAME, full=False, cssclass='highlight').get_style_defs('.highlight')
except ClassNotFound:
    print(f""Ostrzeżenie: Styl Pygments '{PYGMENTS_STYLE_NAME}' nie znaleziono. Używam 'default'."")
    PYGMENTS_STYLE_NAME = 'default'
    PYGMENTS_CSS = HtmlFormatter(style=PYGMENTS_STYLE_NAME, full=False, cssclass='highlight').get_style_defs('.highlight')

CUSTOM_CODE_CSS = f""""""
.highlight {{
    padding: 0 !important;
    margin: 0 !important;
}}
.highlight pre {{
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    white-space: pre-wrap;
    word-wrap: break-word;
}}
""""""
FINAL_CODE_CSS = PYGMENTS_CSS + CUSTOM_CODE_CSS

def highlight_code_html(code, language=''):
    try:
        if language:
            lexer = get_lexer_by_name(language, stripall=True)
        else:
            lexer = guess_lexer(code)
        if lexer.name == 'text':
            raise PygmentsClassNotFound # Don't use 'text' lexer
    except (PygmentsClassNotFound, ValueError):
        try:
            # Fallback to a generic lexer or plain text
            lexer = get_lexer_by_name('text', stripall=True)
        except PygmentsClassNotFound:
             # This fallback should theoretically always work, but as a safeguard:
             return f""<pre><code>{code}</code></pre>""


    formatter = HtmlFormatter(style=PYGMENTS_STYLE_NAME, full=False, cssclass='highlight')
    return highlight(code, lexer, formatter)

# --- Custom Widgets for Chat Messages ---
# (CodeDisplayTextEdit, MessageWidget - copied from your code)
# ... (Paste your CodeDisplayTextEdit and MessageWidget classes here) ...
class CodeDisplayTextEdit(QTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setReadOnly(True)
        self.setAcceptRichText(True)
        self.setWordWrapMode(QTextOption.WrapMode.NoWrap) # Code blocks shouldn't wrap standardly
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        self.setMinimumHeight(QFontMetrics(self.font()).lineSpacing() * 3 + 16)
        self.setFrameStyle(QTextEdit.Shape.Box | QTextEdit.Shadow.Plain)
        self.document().setDocumentMargin(0)
        self.setContentsMargins(0,0,0,0)

        self.setStyleSheet(f""""""
            QTextEdit {{
                background-color: #2d2d2d; /* Dark background for code */
                color: #ffffff; /* White text */
                border: 1px solid #4a4a4a;
                border-radius: 5px;
                padding: 8px;
                font-family: ""Consolas"", ""Courier New"", monospace;
                font-size: 9pt; /* Smaller font for code blocks */
            }}
            {FINAL_CODE_CSS} /* Pygments CSS for syntax highlighting */
        """""")

    def setHtml(self, html: str):
        super().setHtml(html)
        self.document().adjustSize()
        doc_height = self.document().size().height()
        buffer = 5
        self.setFixedHeight(int(doc_height) + buffer)

class MessageWidget(QWidget):
    def __init__(self, role: str, content: str, metadata: dict = None, parent=None):
        super().__init__(parent)
        self.role = role
        self.content = content
        self.metadata = metadata
        self.is_placeholder = (role == ""assistant"" and metadata is not None and metadata.get(""type"") == ""placeholder"")
        self.segments = []

        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 5, 0, 5)
        self.layout.setSpacing(3)

        bubble_widget = QWidget()
        self.content_layout = QVBoxLayout(bubble_widget)
        self.content_layout.setContentsMargins(12, 8, 12, 8)
        self.content_layout.setSpacing(6)

        user_color = ""#dcf8c6""
        assistant_color = ""#e0e0e0""

        bubble_style = f""""""
            QWidget {{
                background-color: {'{user_color}' if role == 'user' else '{assistant_color}'};
                border-radius: 15px;
                padding: 0px;
                border: 1px solid #e0e0e0;
            }}
        """"""
        if self.is_placeholder:
            bubble_style = """"""
                QWidget {
                    background-color: #f0f0f0;
                    border-radius: 15px;
                    padding: 0px;
                    border: 1px dashed #cccccc;
                }
            """"""
        bubble_widget.setStyleSheet(bubble_style)
        bubble_widget.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum)

        outer_layout = QHBoxLayout()
        outer_layout.setContentsMargins(0, 0, 0, 0)
        outer_layout.setSpacing(0)

        screen_geometry = QGuiApplication.primaryScreen().availableGeometry()
        max_bubble_width = int(screen_geometry.width() * 0.75)
        bubble_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)
        bubble_widget.setMinimumWidth(1)

        spacer_left = QWidget()
        spacer_right = QWidget()
        spacer_left.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        spacer_right.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)

        if role == 'user':
            outer_layout.addWidget(spacer_left)
            outer_layout.addWidget(bubble_widget, 1)
            outer_layout.addWidget(spacer_right, 0)
        else:
            outer_layout.addWidget(spacer_left, 0)
            outer_layout.addWidget(bubble_widget, 1)
            outer_layout.addWidget(spacer_right)

        self.layout.addLayout(outer_layout)

        if self.is_placeholder:
            placeholder_label = QLabel(content)
            placeholder_label.setStyleSheet(""QLabel { color: #505050; font-style: italic; padding: 10px; }"")
            placeholder_label.setWordWrap(True)
            placeholder_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.content_layout.addWidget(placeholder_label)
            self.placeholder_label = placeholder_label
            placeholder_label.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            placeholder_label.setMinimumWidth(1)
        else:
            self.display_content(content, self.content_layout)

        self.content_layout.addStretch(1)

    def display_content(self, content, layout):
        block_pattern = re.compile(r'(^|\n)(`{3,})(\w*)\n(.*?)\n\2(?:\n|$)', re.DOTALL)
        last_end = 0

        for match in block_pattern.finditer(content):
            text_before = content[last_end:match.start()].strip()
            if text_before:
                self.add_text_segment(text_before, layout)

            code = match.group(4)
            language = match.group(3).strip()

            code_area = CodeDisplayTextEdit()
            highlighted_html = highlight_code_html(code, language)
            code_area.setHtml(highlighted_html)
            layout.addWidget(code_area)
            self.segments.append(code_area)

            copy_button = QPushButton(""Kopiuj kod"")
            copy_button.setIcon(QIcon.fromTheme(""edit-copy"", QIcon("":/icons/copy.png"")))
            copy_button.setFixedSize(100, 25)
            copy_button.setStyleSheet(""""""
                QPushButton {
                    background-color: #3c3c3c;
                    color: #ffffff;
                    border: 1px solid #5a5a5a;
                    border-radius: 4px;
                    padding: 2px 8px;
                    font-size: 9pt;
                }
                QPushButton:hover {
                    background-color: #4a4a4a;
                    border-color: #6a6a6a;
                }
                QPushButton:pressed {
                    background-color: #2a2a2a;
                    border-color: #5a5a5a;
                }
            """""")

            clipboard = QApplication.clipboard()
            if clipboard:
                copy_button.clicked.connect(lambda checked=False, code_widget=code_area: self.copy_code_to_clipboard(code_widget))
            else:
                copy_button.setEnabled(False)

            btn_layout = QHBoxLayout()
            btn_layout.addStretch()
            btn_layout.addWidget(copy_button)
            btn_layout.setContentsMargins(0, 0, 0, 0)
            btn_layout.setSpacing(0)
            layout.addLayout(btn_layout)

            last_end = match.end()

        remaining_text = content[last_end:].strip()
        if remaining_text:
            self.add_text_segment(remaining_text, layout)

    def add_text_segment(self, text: str, layout: QVBoxLayout):
        if not text:
            return

        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setFrameStyle(QTextEdit.Shape.NoFrame)
        text_edit.setContentsMargins(0, 0, 0, 0)
        text_edit.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        text_edit.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        text_edit.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        text_edit.setWordWrapMode(QTextOption.WrapMode.WrapAtWordBoundaryOrAnywhere)
        text_edit.setAcceptRichText(True)

        text_edit.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        text_edit.customContextMenuRequested.connect(lambda pos, te=text_edit: self.show_context_menu(pos, te))

        text_edit.setStyleSheet(f""""""
            QTextEdit {{
                background-color: transparent;
                border: none;
                padding: 0;
                font-size: 10pt;
                color: {'#333333' if self.role == 'user' else '#ffffff'};
            }}
        """""")

        html_text = text.replace('&', '&').replace('<', '<').replace('>', '>')
        html_text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', html_text)
        inline_code_style = ""font-family: Consolas, 'Courier New', monospace; background-color: #f0f0f0; padding: 1px 3px; border-radius: 3px; font-size: 9pt;""
        html_text = re.sub(r'`([^`]+)`', rf'<span style=""{inline_code_style}"">\1</span>', html_text)
        html_text = html_text.replace('\n', '<br>')

        text_edit.setHtml(html_text)
        self.segments.append(text_edit)

        text_edit.document().adjustSize()
        doc_size = text_edit.document().size()
        buffer = 5
        text_edit.setFixedHeight(int(doc_size.height()) + buffer)

        layout.addWidget(text_edit)

    def show_context_menu(self, position, text_edit):
        menu = QMenu(text_edit)

        copy_action = menu.addAction(""Kopiuj"")
        copy_action.setIcon(QIcon.fromTheme(""edit-copy""))
        copy_action.triggered.connect(text_edit.copy)

        menu.addSeparator()

        select_all_action = menu.addAction(""Zaznacz wszystko"")
        select_all_action.setIcon(QIcon.fromTheme(""edit-select-all""))
        select_all_action.setShortcut(""Ctrl+A"")
        select_all_action.triggered.connect(text_edit.selectAll)

        menu.exec(text_edit.viewport().mapToGlobal(position))

    def copy_code_to_clipboard(self, code_widget: CodeDisplayTextEdit):
        clipboard = QApplication.clipboard()
        if clipboard:
            code_text = code_widget.toPlainText()
            clipboard.setText(code_text)

            sender_button = self.sender()
            if sender_button:
                original_text = sender_button.text()
                sender_button.setText(""Skopiowano!"")
                QTimer.singleShot(1500, lambda: sender_button.setText(original_text))

    def update_placeholder_text(self, text):
        if self.is_placeholder and hasattr(self, 'placeholder_label'):
            display_text = text.strip()
            if len(display_text) > 200:
                display_text = ""..."" + display_text[-200:]
            display_text = ""⚙️ Przetwarzam... "" + display_text
            self.placeholder_label.setText(display_text)

    def apply_theme_colors(self, background: QColor, foreground: QColor, bubble_user: QColor, bubble_assistant: QColor):
        bubble_widget = self.findChild(QWidget)
        if bubble_widget and not self.is_placeholder:
            bubble_style = f""""""
                QWidget {{
                    background-color: {'{bubble_user.name()}' if self.role == 'user' else '{bubble_assistant.name()}'};
                    border-radius: 15px;
                    padding: 0px;
                    border: 1px solid #e0e0e0;
                }}
            """"""
            bubble_widget.setStyleSheet(bubble_style)
            bubble_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)

        for segment in self.segments:
            if isinstance(segment, QTextEdit) and not isinstance(segment, CodeDisplayTextEdit):
                segment.setStyleSheet(f""""""
                    QTextEdit {{
                        background-color: transparent;
                        border: none;
                        padding: 0;
                        font-size: 10pt;
                        color: {'{foreground.name()}' if self.role == 'assistant' else '#333333'};
                    }}
                """""")
# --- End of Custom Widgets ---


# --- Code Editor Widget ---
# (CodeEditor - copied and slightly modified for theme colors and line numbers)
# ... (Paste your CodeEditor class here) ...
class CodeEditor(QTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFont(QFont(""Consolas"", DEFAULT_FONT_SIZE))
        self.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)
        self.highlighter = PythonHighlighter(self.document()) # Default highlighter

        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

        self.line_number_area = QWidget(self)
        self.line_number_area.setFixedWidth(40)
        self.line_number_area.setStyleSheet(""background-color: #252526; color: #858585;"")
        self.update_line_number_area_width()

        self.document().blockCountChanged.connect(self.update_line_number_area_width)
        self.verticalScrollBar().valueChanged.connect(lambda: self.line_number_area.update())
        self.textChanged.connect(lambda: self.line_number_area.update())
        self.cursorPositionChanged.connect(lambda: self.update_line_number_area(self.viewport().rect(), 0))
        self.cursorPositionChanged.connect(self.highlight_current_line)

        self.setTabStopDistance(QFontMetrics(self.font()).horizontalAdvance(' ') * 4)

        self.current_line_format = QTextCharFormat()
        self.current_line_format.setBackground(QColor(""#2d2d2d""))

    def delete(self):
        cursor = self.textCursor()
        if cursor.hasSelection():
            cursor.removeSelectedText()
        else:
            cursor.deleteChar()
        self.setTextCursor(cursor)

    def show_context_menu(self, position):
        # This context menu is now set up by the main window's setup_editor_context_menu
        # which provides more actions. This local one is potentially redundant or simplified.
        # For now, let's keep the main window's setup, and this method could be empty or removed.
        # Or, it could call the main window's method. Let's update the main window setup.
        pass # The main window will handle this connection instead


    def update_line_number_area_width(self):
        digits = len(str(max(1, self.document().blockCount())))
        space = 10 + self.fontMetrics().horizontalAdvance('9') * digits
        self.line_number_area.setFixedWidth(space)
        self.setViewportMargins(self.line_number_area.width(), 0, 0, 0)

    def update_line_number_area(self, rect, dy):
        if dy != 0:
            self.line_number_area.scroll(0, dy)
        else:
            self.line_number_area.update(0, rect.y(), self.line_number_area.width(), rect.height())

        if rect.contains(self.viewport().rect()):
            self.update_line_number_area_width()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        cr = self.contentsRect()
        self.line_number_area.setGeometry(QRect(cr.left(), cr.top(), self.line_number_area.width(), cr.height()))

    def line_number_area_paint_event(self, event):
        painter = QPainter(self.line_number_area)
        if not painter.isActive():
            painter.begin(self.line_number_area)

        bg_color = self.palette().color(QPalette.ColorRole.Base)
        painter.fillRect(event.rect(), bg_color)

        doc = self.document()
        block = doc.begin()
        block_number = 0
        scroll_offset = self.verticalScrollBar().value()

        top = block.layout().boundingRect().top() + scroll_offset
        bottom = top + block.layout().boundingRect().height()

        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(block_number + 1)
                # Use line number area's stylesheet color for text
                # Accessing stylesheet color directly is tricky, fallback to palette or fixed color
                # Let's use the foreground color set in set_theme_colors
                painter.setPen(self.line_number_area.palette().color(QPalette.ColorRole.WindowText))


                painter.drawText(0, int(top), self.line_number_area.width() - 5, self.fontMetrics().height(),
                                 Qt.AlignmentFlag.AlignRight, number)

            block = block.next()
            if block.isValid():
                top = bottom
                # Recalculate block height each time
                bottom = top + self.blockBoundingRect(block).height() # Use blockBoundingRect for accurate height
                block_number += 1
            else:
                break

    def highlight_current_line(self):
        extra_selections = []

        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()
            selection.format = self.current_line_format
            selection.format.setProperty(QTextFormat.Property.FullWidthSelection, True)
            selection.cursor = self.textCursor()
            selection.cursor.clearSelection()
            extra_selections.append(selection)

        self.setExtraSelections(extra_selections)

    def set_font_size(self, size: int):
        font = self.font()
        font.setPointSize(size)
        self.setFont(font)
        self.setTabStopDistance(QFontMetrics(self.font()).horizontalAdvance(' ') * 4)
        self.update_line_number_area_width()
        self.line_number_area.update()

    def set_theme_colors(self, background: QColor, foreground: QColor, line_number_bg: QColor, line_number_fg: QColor, current_line_bg: QColor):
        palette = self.palette()
        palette.setColor(QPalette.ColorRole.Base, background)
        palette.setColor(QPalette.ColorRole.Text, foreground)
        self.setPalette(palette)

        # Update line number area palette and stylesheet for immediate effect
        linenum_palette = self.line_number_area.palette()
        linenum_palette.setColor(QPalette.ColorRole.Window, line_number_bg) # Window role for background
        linenum_palette.setColor(QPalette.ColorRole.WindowText, line_number_fg) # WindowText for foreground
        self.line_number_area.setPalette(linenum_palette)
        self.line_number_area.setStyleSheet(f""QWidget {{ background-color: {line_number_bg.name()}; color: {line_number_fg.name()}; }}"")


        self.current_line_format.setBackground(current_line_bg)
        self.highlight_current_line()

    def paintEvent(self, event):
        # Custom paint event to draw the line number area *before* the main editor content
        # Note: QWidget's paintEvent is not automatically called by QTextEdit's paintEvent
        # We need to manually trigger the line number area repaint or rely on its own update signals.
        # The current setup relies on signals connected in __init__.
        # We can skip the manual paintEvent call here and let the signals handle it.
        super().paintEvent(event)
# --- End of Code Editor Widget ---


# --- Settings Dialog ---

class SettingsDialog(QDialog):
    def __init__(self, active_models_config: list, current_settings: dict, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Ustawienia"")
        self.setMinimumWidth(400)
        self.setModal(True)

        self.active_models_config = active_models_config
        self.current_settings = current_settings

        self.layout = QVBoxLayout(self)

        # Model selection
        model_label = QLabel(""Model AI:"")
        self.layout.addWidget(model_label)

        self.model_combo = QComboBox()
        # Populate with display names, but store API type and identifier as user data
        for api_type, identifier, display_name in self.active_models_config:
            self.model_combo.addItem(display_name, userData=(api_type, identifier))

        # Set the current model in the combobox
        try:
            current_api_type = self.current_settings.get(""api_type"")
            current_identifier = self.current_settings.get(""model_identifier"")
            # Find the index for the current model config
            for i in range(self.model_combo.count()):
                 api_type, identifier = self.model_combo.itemData(i)
                 if api_type == current_api_type and identifier == current_identifier:
                      self.model_combo.setCurrentIndex(i)
                      break
            else: # If current model not found, select the first available
                if self.model_combo.count() > 0:
                    self.model_combo.setCurrentIndex(0)
        except Exception as e:
            print(f""Error setting initial model in settings dialog: {e}"")
            if self.model_combo.count() > 0: self.model_combo.setCurrentIndex(0)


        self.layout.addWidget(self.model_combo)

        # API Key Inputs (conditional based on available APIs)
        if HAS_GEMINI:
            # Gemini key is usually from file, but could add an input here too if needed
            pass # Keep Gemini key from file for now

        if HAS_MISTRAL:
            mistral_key_label = QLabel(""Klucz API Mistral:"")
            self.layout.addWidget(mistral_key_label)
            self.mistral_key_input = QLineEdit()
            self.mistral_key_input.setPlaceholderText(""Wprowadź klucz API Mistral"")
            self.mistral_key_input.setText(self.current_settings.get(""mistral_api_key"", """"))
            self.layout.addWidget(self.mistral_key_input)


        # Theme selection
        theme_label = QLabel(""Motyw:"")
        self.layout.addWidget(theme_label)

        self.theme_combo = QComboBox()
        self.theme_combo.addItems([""ciemny"", ""jasny""])
        self.theme_combo.setCurrentText(""ciemny"" if self.current_settings.get(""theme"", DEFAULT_THEME) == ""dark"" else ""jasny"")
        self.layout.addWidget(self.theme_combo)

        # Font size
        font_label = QLabel(""Rozmiar czcionki:"")
        self.layout.addWidget(font_label)

        self.font_spin = QSpinBox()
        self.font_spin.setRange(8, 24)
        self.font_spin.setValue(self.current_settings.get(""font_size"", DEFAULT_FONT_SIZE))
        self.layout.addWidget(self.font_spin)

        # UI elements visibility
        self.sidebar_check = QCheckBox(""Pokaż pasek boczny"")
        self.sidebar_check.setChecked(self.current_settings.get(""show_sidebar"", True))
        self.layout.addWidget(self.sidebar_check)

        self.toolbar_check = QCheckBox(""Pokaż pasek narzędzi"")
        self.toolbar_check.setChecked(self.current_settings.get(""show_toolbar"", True))
        self.layout.addWidget(self.toolbar_check)

        self.statusbar_check = QCheckBox(""Pokaż pasek stanu"")
        self.statusbar_check.setChecked(self.current_settings.get(""show_statusbar"", True))
        self.layout.addWidget(self.statusbar_check)

        self.layout.addStretch(1)

        # Standard OK/Cancel buttons
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        if ok_button: ok_button.setText(""Zapisz"")
        cancel_button = self.button_box.button(QDialogButtonBox.StandardButton.Cancel)
        if cancel_button: cancel_button.setText(""Anuluj"")
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.layout.addWidget(self.button_box)

    def get_selected_model_config(self) -> tuple:
        """"""Returns (api_type, model_identifier) of the selected model.""""""
        return self.model_combo.currentData()

    def get_mistral_api_key(self) -> str:
        """"""Returns the Mistral API key from the input field, or None if Mistral is not supported.""""""
        if HAS_MISTRAL:
             return self.mistral_key_input.text().strip() or None
        return None


    def get_selected_theme(self) -> str:
        return ""dark"" if self.theme_combo.currentText() == ""ciemny"" else ""light""

    def get_font_size(self) -> int:
        return self.font_spin.value()

    def get_ui_visibility(self) -> dict:
        return {
            ""show_sidebar"": self.sidebar_check.isChecked(),
            ""show_toolbar"": self.toolbar_check.isChecked(),
            ""show_statusbar"": self.statusbar_check.isChecked()
        }

# --- File Explorer ---

class FileExplorer(QTreeView):
    # Signal emitted when one or more files are selected for opening (e.g., by double-click or context menu)
    # Emits a list of file paths (only files, not directories)
    openFilesRequested = pyqtSignal(list)
    # Signal emitted when one or more items are selected for deletion
    # Emits a list of file/directory paths
    deleteItemsRequested = pyqtSignal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.model = QFileSystemModel() # Store model as instance variable
        self.setModel(self.model)

        home_dir = QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]
        self.model.setRootPath(home_dir)
        self.setRootIndex(self.model.index(home_dir))

        self.setAnimated(False)
        self.setIndentation(15)
        self.setSortingEnabled(True)

        # Set default sorting: Folders first, then by name, case-insensitive is often preferred
        self.model.setFilter(QDir.Filter.AllEntries | QDir.Filter.NoDotAndDotDot | QDir.Filter.Hidden) # Hide . and .., also hidden files/folders
        # self.model.setSortingFlags(QDir.SortFlag.DirsFirst | QDir.SortFlag.Name | QDir.SortFlag.IgnoreCase | QDir.SortFlag.LocaleAware)
        # The above line caused the error. QFileSystemModel handles DirsFirst internally when sorting by name.
        # We can rely on the default sorting behavior combined with sortByColumn.
        self.sortByColumn(0, Qt.SortOrder.AscendingOrder) # Sort by Name column (0) ascending

        # Hide columns we don't need
        for i in range(1, self.model.columnCount()):
            self.hideColumn(i)

        # Selection mode: Allows multi-selection with Ctrl/Shift
        self.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        # Selection behavior: Select entire rows
        self.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)

        # Connect double-click
        # Disconnect the default activated behavior that changes root
        try:
             self.activated.disconnect(self.on_item_activated)
        except TypeError: # Handle case where it's not connected yet or connected elsewhere
             pass
        # Connect double-click to toggle expansion for directories and open for files
        self.doubleClicked.connect(self.on_item_double_clicked)


        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

        # Internal clipboard for copy/cut operations
        self._clipboard_paths = []
        self._is_cut_operation = False

    def on_item_activated(self, index: QModelIndex):
        """"""Handles item activation (e.g., single-click or Enter key).""""""
        # Keep single-click behavior minimal or just selection
        if not index.isValid():
             return
        # Default single-click is usually just selection, which is fine.
        # The original on_item_activated changed the root on double-click, which is now handled by on_item_double_clicked.
        # We can leave this method empty or connect it to something else if needed.
        pass

    def on_item_double_clicked(self, index: QModelIndex):
        """"""Handles item double-click.""""""
        if not index.isValid():
            return

        file_path = self.model.filePath(index)
        file_info = QFileInfo(file_path)

        if file_info.isDir():
            # Toggle directory expansion instead of changing root
            self.setExpanded(index, not self.isExpanded(index))
        else:
            # If it's a file, emit signal to main window to open it
            self.openFilesRequested.emit([file_path]) # Emit a list even for a single file


    def get_selected_paths(self) -> list:
        """"""Returns a list of unique file/directory paths for all selected items.""""""
        paths = set() # Use a set to ensure uniqueness
        # Iterate through selected indexes, but only take the first column's index for each row
        # to avoid duplicates if multiple columns were visible
        for index in self.selectedIndexes():
             if index.column() == 0: # Only process the name column index
                 paths.add(self.model.filePath(index))
        return list(paths)

    def show_context_menu(self, position):
        menu = QMenu()
        index = self.indexAt(position) # Get index at click position
        clipboard = QApplication.clipboard() # Get global clipboard

        # --- Actions based on the clicked item ---
        if index.isValid():
            file_path = self.model.filePath(index)
            file_info = QFileInfo(file_path)
            selected_paths = self.get_selected_paths() # Get all selected items

            # --- Actions for the item at the click position ---

            # New File/Folder actions (only if clicked item is a directory)
            if file_info.isDir():
                new_file_action = menu.addAction(QIcon.fromTheme(""document-new""), ""Nowy plik w tym folderze"")
                new_file_action.triggered.connect(lambda: self.create_new_file(file_path))

                new_folder_action = menu.addAction(QIcon.fromTheme(""folder-new""), ""Nowy folder w tym folderze"")
                new_folder_action.triggered.connect(lambda: self.create_new_folder(file_path))

                menu.addSeparator()

            # Open action (for both files and directories)
            open_action = menu.addAction(QIcon.fromTheme(""document-open""), ""Otwórz"")
            if file_info.isDir():
                 # For directories, this could either expand/collapse or change root.
                 # Let's make it change root via context menu for explicit navigation.
                 open_action.triggered.connect(lambda: self.setRootIndex(index))
                 # Alternative: open_action.triggered.connect(lambda: self.setExpanded(index, not self.isExpanded(index)))
            else:
                 # For files, emit the open signal to the main window
                 open_action.triggered.connect(lambda: self.openFilesRequested.emit([file_path]))

            # Copy/Cut actions for the clicked item
            copy_action = menu.addAction(QIcon.fromTheme(""edit-copy""), ""Kopiuj"")
            copy_action.triggered.connect(lambda: self.copy_items([file_path]))

            cut_action = menu.addAction(QIcon.fromTheme(""edit-cut""), ""Wytnij"")
            cut_action.triggered.connect(lambda: self.cut_items([file_path]))


            # Paste actions (conditional based on clipboard and clicked item type)
            if self._clipboard_paths: # Only show paste options if clipboard is not empty
                 if file_info.isDir():
                      # Paste into the clicked directory
                      paste_into_action = menu.addAction(QIcon.fromTheme(""edit-paste""), ""Wklej do folderu"")
                      paste_into_action.triggered.connect(lambda: self.paste_items(file_path)) # Paste into this folder
                      # Paste alongside the clicked directory (in its parent)
                      parent_dir = self.model.filePath(index.parent())
                      if parent_dir: # Cannot paste alongside the root of the model
                         paste_alongside_action = menu.addAction(QIcon.fromTheme(""edit-paste""), ""Wklej obok"")
                         paste_alongside_action.triggered.connect(lambda: self.paste_items(parent_dir)) # Paste into parent folder
                 else: # Clicked item is a file
                      # Paste alongside the clicked file (in its parent)
                      parent_dir = self.model.filePath(index.parent())
                      if parent_dir: # Cannot paste alongside the root of the model
                         paste_alongside_action = menu.addAction(QIcon.fromTheme(""edit-paste""), ""Wklej obok"")
                         paste_alongside_action.triggered.connect(lambda: self.paste_items(parent_dir)) # Paste into parent folder


            # Rename action for the clicked item
            rename_action = menu.addAction(QIcon.fromTheme(""edit-rename""), ""Zmień nazwę"")
            rename_action.triggered.connect(lambda: self.edit(index)) # QTreeView.edit starts renaming

            # Delete action for the clicked item
            delete_action = menu.addAction(QIcon.fromTheme(""edit-delete""), ""Usuń"")
            delete_action.triggered.connect(lambda: self.deleteItemsRequested.emit([file_path])) # Emit list for consistency

            menu.addSeparator()

            show_in_explorer_action = menu.addAction(QIcon.fromTheme(""system-file-manager""), ""Pokaż w menedżerze plików"")
            show_in_explorer_action.triggered.connect(lambda: self.show_in_explorer(file_path))

        else:
            # --- Actions for empty space ---
            root_path = self.model.filePath(self.rootIndex()) # Target actions to the current root directory

            new_file_action = menu.addAction(QIcon.fromTheme(""document-new""), ""Nowy plik"")
            new_file_action.triggered.connect(lambda: self.create_new_file(root_path))

            new_folder_action = menu.addAction(QIcon.fromTheme(""folder-new""), ""Nowy folder"")
            new_folder_action.triggered.connect(lambda: self.create_new_folder(root_path))

            menu.addSeparator()

            # Paste action for empty space (paste into the current root directory)
            if self._clipboard_paths:
                 paste_action = menu.addAction(QIcon.fromTheme(""edit-paste""), f""Wklej elementy ({len(self._clipboard_paths)})"")
                 paste_action.triggered.connect(lambda: self.paste_items(root_path))


            select_all_action = menu.addAction(QIcon.fromTheme(""edit-select-all""), ""Zaznacz wszystko"")
            select_all_action.triggered.connect(self.selectAll)


        # --- Actions for multiple selected items (if applicable, add them regardless of clicked item if multi-selected) ---
        # Check if *multiple* items are selected (excluding the single item already handled above)
        all_selected_paths = self.get_selected_paths()
        if len(all_selected_paths) > 1:
             # Avoid adding separator if one was just added
             if not menu.actions()[-1].isSeparator():
                  menu.addSeparator()

             # Filter out directories for ""Open Selected Files""
             selected_files = [p for p in all_selected_paths if QFileInfo(p).isFile()]
             if selected_files:
                  open_selected_action = menu.addAction(QIcon.fromTheme(""document-open-folder""), f""Otwórz zaznaczone pliki ({len(selected_files)})"")
                  open_selected_action.triggered.connect(lambda: self.openFilesRequested.emit(selected_files))

             # Copy/Cut for multiple selected items
             copy_selected_action = menu.addAction(QIcon.fromTheme(""edit-copy""), f""Kopiuj zaznaczone elementy ({len(all_selected_paths)})"")
             copy_selected_action.triggered.connect(lambda: self.copy_items(all_selected_paths))

             cut_selected_action = menu.addAction(QIcon.fromTheme(""edit-cut""), f""Wytnij zaznaczone elementy ({len(all_selected_paths)})"")
             cut_selected_action.triggered.connect(lambda: self.cut_items(all_selected_paths))

             # Delete action for all selected items (files and folders)
             delete_selected_action = menu.addAction(QIcon.fromTheme(""edit-delete""), f""Usuń zaznaczone elementy ({len(all_selected_paths)})"")
             delete_selected_action.triggered.connect(lambda: self.deleteItemsRequested.emit(all_selected_paths)) # Emit list for consistency


        menu.exec(self.viewport().mapToGlobal(position))

    def create_new_file(self, dir_path):
        name, ok = QInputDialog.getText(self, ""Nowy plik"", ""Nazwa pliku:"", QLineEdit.EchoMode.Normal, ""nowy_plik.txt"")
        if ok and name:
            file_path = os.path.join(dir_path, name)
            try:
                if os.path.exists(file_path):
                    QMessageBox.warning(self, ""Błąd"", f""Plik już istnieje: {file_path}"")
                    return
                # Create the file manually
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write('') # Create an empty file
                print(f""Utworzono plik: {file_path}"")
                # Refresh the model to show the new file
                self.model.refresh(self.model.index(dir_path))
                # Optional: Select and start renaming the new file
                new_index = self.model.index(file_path)
                if new_index.isValid():
                    self.setCurrentIndex(new_index)
                    self.edit(new_index)
                self.parent().update_status_bar_message(f""Utworzono nowy plik: {os.path.basename(file_path)}"")

            except Exception as e:
                QMessageBox.warning(self, ""Błąd"", f""Nie można utworzyć pliku '{name}':\n{e}"")
                self.parent().update_status_bar_message(f""Błąd tworzenia pliku: {e}"")


    def create_new_folder(self, dir_path):
        name, ok = QInputDialog.getText(self, ""Nowy folder"", ""Nazwa folderu:"", QLineEdit.EchoMode.Normal, ""Nowy folder"")
        if ok and name:
            folder_path = os.path.join(dir_path, name)
            try:
                if os.path.exists(folder_path):
                    QMessageBox.warning(self, ""Błąd"", f""Folder już istnieje: {folder_path}"")
                    return
                # Use the model's method which handles refreshing and selection/editing
                index = self.model.index(dir_path)
                if index.isValid():
                    new_index = self.model.mkdir(index, name)
                    if new_index.isValid():
                        # Optional: Expand parent and select/rename new folder
                        self.setExpanded(index, True)
                        self.setCurrentIndex(new_index)
                        self.edit(new_index)
                        if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                            self.parent().update_status_bar_message(f""Utworzono nowy folder: {os.path.basename(folder_path)}"")
                        else:
                            print(f""Folder {folder_path} utworzony, ale brak metody 'update_status_bar_message'!"")
                    else:
                        QMessageBox.warning(self, ""Błąd"", f""Nie można utworzyć folderu '{name}'. Sprawdź uprawnienia."")
                        if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                            self.parent().update_status_bar_message(f""Błąd tworzenia folderu: {name}"")
                else:
                    # Fallback if dir_path cannot be found in the model (less likely for valid paths)
                    os.mkdir(folder_path)
                    self.model.refresh(self.model.index(dir_path))  # Manual refresh
                    new_index = self.model.index(folder_path)
                    if new_index.isValid():
                        self.setExpanded(self.model.index(dir_path), True)
                        self.setCurrentIndex(new_index)
                        self.edit(new_index)
                        if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                            self.parent().update_status_bar_message(f""Utworzono nowy folder: {os.path.basename(folder_path)}"")
                    else:
                        QMessageBox.warning(self, ""Błąd"", f""Nie można utworzyć folderu '{name}'. Sprawdź uprawnienia."")
                        if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                            self.parent().update_status_bar_message(f""Błąd tworzenia folderu: {name}"")
            except Exception as e:
                QMessageBox.warning(self, ""Błąd"", f""Nie można utworzyć folderu '{name}':\n{e}"")
                if self.parent() and hasattr(self.parent(), 'update_status_bar_message'):
                    self.parent().update_status_bar_message(f""Błąd tworzenia folderu: {e}"")



    def delete_items(self, file_paths: list):
        """"""Initiates deletion of a list of files/directories.""""""
        if not file_paths:
            return

        # Get confirmation for multiple items
        if len(file_paths) > 1:
            items_list = ""\n"".join([os.path.basename(p) for p in file_paths])
            reply = QMessageBox.question(self, ""Usuń zaznaczone"",
                                         f""Czy na pewno chcesz usunąć następujące elementy?\n\n{items_list}\n\nTa operacja jest nieodwracalna."",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        else:
            # Confirmation for single item (reusing logic from show_context_menu)
            item_name = os.path.basename(file_paths[0])
            reply = QMessageBox.question(self, ""Usuń"", f""Czy na pewno chcesz usunąć '{item_name}'?"",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            deleted_count = 0
            error_messages = []
            parent_dirs_to_refresh = set()

            for file_path in file_paths:
                parent_dirs_to_refresh.add(os.path.dirname(file_path))
                try:
                    index = self.model.index(file_path)
                    if index.isValid():
                        # QFileSystemModel.remove handles both files and non-empty directories recursively
                        # on supported platforms (like Windows, macOS). On Linux, it might be just rmdir for empty dirs.
                        # Let's prioritize the model's method first as it might be more integrated.
                        # For robustness, we can keep the shutil fallback.
                        # NOTE: model.remove returns True on success, False on failure, doesn't raise exceptions.
                        if self.model.remove(index.row(), 1, index.parent()):
                             print(f""Usunięto element (model): {file_path}"")
                             deleted_count += 1
                        else:
                             # model.remove failed, try recursive deletion with shutil/os
                             print(f""Model nie usunął '{file_path}', próbuję shutil/os..."")
                             if os.path.isdir(file_path):
                                  shutil.rmtree(file_path)
                                  print(f""Usunięto katalog (shutil): {file_path}"")
                                  deleted_count += 1
                             elif os.path.exists(file_path):
                                  os.remove(file_path)
                                  print(f""Usunięto plik (os.remove): {file_path}"")
                                  deleted_count += 1
                             else:
                                  # Should not happen if index was valid initially
                                  error_messages.append(f""Nie znaleziono: {file_path}"")
                    else:
                        error_messages.append(f""Nieprawidłowa ścieżka lub element niedostępny: {file_path}"")
                except Exception as e:
                    error_messages.append(f""Nie można usunąć '{os.path.basename(file_path)}': {e}"")
                    print(f""Błąd usuwania '{file_path}': {traceback.format_exc()}"") # Log error

            # Refresh parent directories that were affected
            for parent_dir in parent_dirs_to_refresh:
                 if os.path.exists(parent_dir): # Ensure parent still exists
                     self.model.refresh(self.model.index(parent_dir))

            if error_messages:
                 QMessageBox.warning(self, ""Błąd usuwania"", ""Wystąpiły błędy podczas usuwania niektórych elementów:\n\n"" + ""\n"".join(error_messages))
                 self.parent().update_status_bar_message(f""Wystąpiły błędy podczas usuwania ({len(error_messages)} błędów)"")
            elif deleted_count > 0:
                 self.parent().update_status_bar_message(f""Pomyślnie usunięto {deleted_count} elementów."")


    def copy_items(self, paths_to_copy: list):
         """"""Stores paths for copy operation in the internal clipboard.""""""
         if not paths_to_copy:
              return
         self._clipboard_paths = paths_to_copy
         self._is_cut_operation = False
         self.parent().update_status_bar_message(f""Skopiowano {len(paths_to_copy)} elementów."")
         print(f""Skopiowano: {self._clipboard_paths}"") # Debug print


    def cut_items(self, paths_to_cut: list):
         """"""Stores paths for cut operation in the internal clipboard.""""""
         if not paths_to_cut:
              return
         self._clipboard_paths = paths_to_cut
         self._is_cut_operation = True
         self.parent().update_status_bar_message(f""Wycięto {len(paths_to_cut)} elementów."")
         print(f""Wycięto: {self._clipboard_paths}"") # Debug print


    def paste_items(self, destination_dir: str):
         """"""Pastes items from the internal clipboard into the destination directory.""""""
         if not self._clipboard_paths:
              self.parent().update_status_bar_message(""Schowek jest pusty."")
              return

         if not os.path.isdir(destination_dir):
              QMessageBox.warning(self, ""Błąd wklejania"", f""Docelowa ścieżka nie jest katalogiem: {destination_dir}"")
              self.parent().update_status_bar_message(f""Błąd wklejania: {destination_dir} nie jest katalogiem."")
              return

         if not os.access(destination_dir, os.W_OK):
              QMessageBox.warning(self, ""Błąd wklejania"", f""Brak uprawnień zapisu w katalogu docelowym: {destination_dir}"")
              self.parent().update_status_bar_message(f""Błąd wklejania: Brak uprawnień w {destination_dir}."")
              return

         operation = ""Przenoszenie"" if self._is_cut_operation else ""Kopiowanie""
         self.parent().update_status_bar_message(f""{operation} {len(self._clipboard_paths)} elementów do '{os.path.basename(destination_dir)}'..."")

         success_count = 0
         error_messages = []
         parent_dirs_to_refresh = {destination_dir} # Always refresh destination

         for src_path in self._clipboard_paths:
              if not os.path.exists(src_path):
                   error_messages.append(f""Źródło nie istnieje: {os.path.basename(src_path)}"")
                   continue

              item_name = os.path.basename(src_path)
              dest_path = os.path.join(destination_dir, item_name)

              # Prevent pasting an item into itself or its sub-directory during a move
              if self._is_cut_operation and src_path == dest_path:
                   error_messages.append(f""Nie można przenieść '{item_name}' w to samo miejsce."")
                   continue
              if self._is_cut_operation and os.path.commonpath([src_path, dest_path]) == src_path and os.path.isdir(src_path):
                  error_messages.append(f""Nie można przenieść '{item_name}' do jego podkatalogu."")
                  continue

              # Handle potential overwrite (simple overwrite for now)
              if os.path.exists(dest_path):
                   # Ask for confirmation? For simplicity, let's overwrite or skip for now.
                   # A more complex dialog could be added here.
                   # For this example, let's just overwrite.
                   if os.path.isdir(dest_path):
                       try: shutil.rmtree(dest_path)
                       except Exception as e: error_messages.append(f""Nie można nadpisać katalogu '{item_name}': {e}""); continue
                   else:
                        try: os.remove(dest_path)
                        except Exception as e: error_messages.append(f""Nie można nadpisać pliku '{item_name}': {e}""); continue


              try:
                   if self._is_cut_operation:
                        # Move the item
                        shutil.move(src_path, dest_path)
                        success_count += 1
                        parent_dirs_to_refresh.add(os.path.dirname(src_path)) # Also refresh source's parent on move
                   else:
                        # Copy the item (recursive for directories)
                        if os.path.isdir(src_path):
                             shutil.copytree(src_path, dest_path)
                        else:
                             shutil.copy2(src_path, dest_path) # copy2 preserves metadata
                        success_count += 1

              except Exception as e:
                   error_messages.append(f""Błąd {operation.lower()} '{item_name}': {e}"")
                   print(f""Błąd {operation.lower()} '{src_path}' do '{dest_path}': {traceback.format_exc()}"") # Log error


         # Refresh affected directories
         for refresh_dir in parent_dirs_to_refresh:
              if os.path.exists(refresh_dir):
                   self.model.refresh(self.model.index(refresh_dir))

         if self._is_cut_operation and success_count > 0:
              # Clear clipboard only if it was a cut operation and at least one item was successfully moved
              self._clipboard_paths = []
              self._is_cut_operation = False

         if error_messages:
              QMessageBox.warning(self, f""Błąd {operation.lower()}enia"", f""Wystąpiły błędy podczas {operation.lower()}enia:\n\n"" + ""\n"".join(error_messages))
              self.parent().update_status_bar_message(f""Wystąpiły błędy podczas {operation.lower()}enia ({len(error_messages)} błędów)"")
         elif success_count > 0:
              self.parent().update_status_bar_message(f""Pomyślnie {operation.lower()}ono {success_count} elementów."")
         else:
              # This case happens if clipboard was empty or all items failed
              if not self._clipboard_paths: # If clipboard was empty initially
                 pass # Message already handled at the start
              else: # All items failed
                 self.parent().update_status_bar_message(f""Nie udało się {operation.lower()}ić żadnych elementów."")

    def show_in_explorer(self, file_path):
        """"""Opens the file or folder in the native file explorer.""""""
        if sys.platform == ""win32"":
            try:
                 # Use explorer.exe /select, to select the file/folder
                 subprocess.Popen(['explorer.exe', '/select,', os.path.normpath(file_path)])
                 self.parent().update_status_bar_message(f""Otworzono w eksploratorze: {os.path.basename(file_path)}"")
            except FileNotFoundError:
                 QMessageBox.warning(self, ""Błąd"", ""Nie znaleziono 'explorer.exe'."")
                 self.parent().update_status_bar_message(""Błąd: Nie znaleziono explorer.exe."")
            except Exception as e:
                 QMessageBox.warning(self, ""Błąd"", f""Nie można otworzyć menedżera plików:\n{e}"")
                 self.parent().update_status_bar_message(f""Błąd otwarcia w menedżerze: {e}"")
        elif sys.platform == ""darwin"":  # macOS
            try:
                 # Use 'open -R' to reveal file in Finder, or 'open' for folder
                 subprocess.Popen(['open', '-R', file_path])
                 self.parent().update_status_bar_message(f""Otworzono w Finderze: {os.path.basename(file_path)}"")
            except FileNotFoundError:
                 QMessageBox.warning(self, ""Błąd"", ""Nie znaleziono 'open'."")
                 self.parent().update_status_bar_message(""Błąd: Nie znaleziono open."")
            except Exception as e:
                 QMessageBox.warning(self, ""Błąd"", f""Nie można otworzyć Findera:\n{e}"")
                 self.parent().update_status_bar_message(f""Błąd otwarcia w Finderze: {e}"")
        else:  # Linux
            try:
                # Use xdg-open which should open the containing folder
                # For a file, xdg-open opens the file. To open the folder containing the file:
                target_path = os.path.dirname(file_path) if os.path.isfile(file_path) else file_path
                subprocess.Popen(['xdg-open', target_path])
                self.parent().update_status_bar_message(f""Otworzono w menedżerze plików: {os.path.basename(target_path)}"")
            except FileNotFoundError:
                QMessageBox.warning(self, ""Błąd"", ""Nie znaleziono 'xdg-open'. Nie można otworzyć lokalizacji pliku."")
                self.parent().update_status_bar_message(""Błąd: Nie znaleziono xdg-open."")
            except Exception as e:
                 QMessageBox.warning(self, ""Błąd"", f""Nie można otworzyć lokalizacji pliku:\n{e}"")
                 self.parent().update_status_bar_message(f""Błąd otwarcia w menedżerze: {e}"")

    # Open file logic is now handled by the main window via signal
    # The file explorer's open_file method is effectively replaced by on_item_activated
    # which emits openFilesRequested.


# --- Main Application Window ---

class CodeEditorWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Edytor Kodu AI"")
        self.setGeometry(100, 100, 1200, 800)

        # Load settings
        self.settings = load_settings()
        self.current_api_type = self.settings.get(""api_type"", DEFAULT_MODEL_CONFIG[0])
        self.current_model_identifier = self.settings.get(""model_identifier"", DEFAULT_MODEL_CONFIG[1])
        self.mistral_api_key = self.settings.get(""mistral_api_key"") # Load Mistral key
        # Gemini key is loaded globally GEMINI_API_KEY_GLOBAL

        self.recent_files = self.settings[""recent_files""]
        self.font_size = self.settings[""font_size""]
        self.theme = self.settings[""theme""]
        self.workspace = self.settings[""workspace""]
        self.show_sidebar = self.settings[""show_sidebar""]
        self.show_toolbar = self.settings[""show_toolbar""]
        self.show_statusbar = self.settings[""show_statusbar""]

        # Initialize UI
        self.init_ui()

        # Store references to menu actions for toggling visibility checks (Fix AttributeError)
        self.action_toggle_sidebar = self.findChild(QAction, ""Przełącz Pasek Boczny"")
        self.action_toggle_toolbar = self.findChild(QAction, ""Przełącz Pasek Narzędzi"")
        self.action_toggle_statusbar = self.findChild(QAction, ""Przełącz Pasek Stanu"")


        # Chat History State
        # Stored as list of (role, content, metadata) tuples
        self.chat_history = []

        # Threading Setup for API calls
        self.worker = None
        self.worker_thread = None
        self._is_processing = False

        # State for streaming response
        self.current_placeholder_widget = None
        self.current_response_content = """"

        # Setup status bar message timer
        self._status_timer = QTimer(self)
        self._status_timer.setSingleShot(True)
        self._status_timer.timeout.connect(self.clear_status_bar_message)

        # Open workspace if set and exists
        if self.workspace and os.path.exists(self.workspace) and os.path.isdir(self.workspace):
            self.file_explorer.setRootIndex(self.file_explorer.model.index(self.workspace))
            self.update_status_bar_message(f""Obszar roboczy: {self.workspace}"")
        else:
            # If workspace is not set or invalid, set root to home directory
            home_dir = QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]
            self.file_explorer.model.setRootPath(home_dir)
            self.file_explorer.setRootIndex(self.file_explorer.model.index(home_dir))
            self.workspace = home_dir  # Update settings to reflect actual root
            self.settings[""workspace""] = self.workspace
            save_settings(self.settings)  # Save updated workspace
            self.update_status_bar_message(f""Ustawiono domyślny obszar roboczy: {self.workspace}"")


        # Add welcome message
        # Find the display name for the initial model
        initial_model_name = next((name for api_type, identifier, name in ACTIVE_MODELS_CONFIG if api_type == self.current_api_type and identifier == self.current_model_identifier), self.current_model_identifier)

        self.add_message(""assistant"", f""Witaj w edytorze kodu AI! Aktualnie działam na modelu '{initial_model_name}'. Jak mogę Ci dziś pomóc?"")

    def init_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)

        self.sidebar = QWidget()
        sidebar_layout = QVBoxLayout(self.sidebar)
        sidebar_layout.setContentsMargins(0, 0, 0, 0)
        sidebar_layout.setSpacing(0)

        # FileExplorer initialization (this is where the error occurred)
        # The fix is inside the FileExplorer class itself
        self.file_explorer = FileExplorer(self)
        sidebar_layout.addWidget(self.file_explorer)
        # Connect signals from FileExplorer
        self.file_explorer.openFilesRequested.connect(self.open_files)
        self.file_explorer.deleteItemsRequested.connect(self.file_explorer.delete_items) # Connect to file_explorer's delete method


        self.right_panel = QSplitter(Qt.Orientation.Vertical)

        self.tabs = QTabWidget()
        self.tabs.setTabsClosable(True)
        self.tabs.tabCloseRequested.connect(self.close_tab)
        self.tabs.currentChanged.connect(self.update_status_bar)

        self.chat_container = QWidget()
        chat_layout = QVBoxLayout(self.chat_container)
        chat_layout.setContentsMargins(0, 0, 0, 0)
        chat_layout.setSpacing(0)

        self.chat_scroll = QScrollArea()
        self.chat_scroll.setWidgetResizable(True)
        self.chat_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

        self.chat_widget = QWidget()
        self.chat_widget.setObjectName(""chat_widget"")
        self.chat_layout = QVBoxLayout(self.chat_widget)
        self.chat_layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignHCenter)
        self.chat_layout.setSpacing(10)
        self.chat_layout.addStretch(1)

        self.chat_scroll.setWidget(self.chat_widget)
        chat_layout.addWidget(self.chat_scroll)

        self.chat_input = QLineEdit()
        self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
        self.chat_input.returnPressed.connect(self.send_message)

        self.send_button = QPushButton(""Wyślij"")
        self.send_button.clicked.connect(self.send_message)

        input_layout = QHBoxLayout()
        input_layout.addWidget(self.chat_input, 1)
        input_layout.addWidget(self.send_button)
        chat_layout.addLayout(input_layout)

        self.main_splitter.addWidget(self.sidebar)
        self.right_panel.addWidget(self.tabs)
        self.right_panel.addWidget(self.chat_container)
        self.right_panel.setStretchFactor(0, 3)
        self.right_panel.setStretchFactor(1, 1)
        self.main_splitter.addWidget(self.right_panel)

        main_layout = QVBoxLayout(central_widget)
        main_layout.addWidget(self.main_splitter)

        self.create_menu_bar()
        self.create_tool_bar()
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.update_status_bar()

        self.apply_font_size(self.font_size)
        self.apply_theme(self.theme)

        self.sidebar.setVisible(self.show_sidebar)
        self.toolbar.setVisible(self.show_toolbar)
        self.status_bar.setVisible(self.show_statusbar)

        self.main_splitter.setSizes([200, 800])
        self.right_panel.setSizes([600, 200])

    def create_menu_bar(self):
        menubar = self.menuBar()

        # File menu
        file_menu = menubar.addMenu(""📄 Plik"")

        new_action = QAction(QIcon.fromTheme(""document-new""), ""Nowy"", self)
        new_action.setShortcut(""Ctrl+N"")
        new_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        new_action.triggered.connect(self.new_file)
        file_menu.addAction(new_action)

        open_action = QAction(QIcon.fromTheme(""document-open""), ""Otwórz..."", self)
        open_action.setShortcut(""Ctrl+O"")
        open_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        open_action.triggered.connect(self.open_file_dialog)
        file_menu.addAction(open_action)

        save_action = QAction(QIcon.fromTheme(""document-save""), ""Zapisz"", self)
        save_action.setObjectName(""action_save"") # Add object name for potential lookup
        save_action.setShortcut(""Ctrl+S"")
        save_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut) # Ensure Ctrl+S works even when editor has focus
        save_action.triggered.connect(self.save_file)
        file_menu.addAction(save_action)

        save_as_action = QAction(""Zapisz jako..."", self)
        save_as_action.setShortcut(""Ctrl+Shift+S"")
        save_as_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        save_as_action.triggered.connect(self.save_file_as)
        file_menu.addAction(save_as_action)

        file_menu.addSeparator()

        open_workspace_action = QAction(QIcon.fromTheme(""folder-open""), ""Otwórz Obszar Roboczy..."", self)
        open_workspace_action.triggered.connect(self.open_workspace)
        file_menu.addAction(open_workspace_action)

        self.recent_files_menu = file_menu.addMenu(""Ostatnie pliki"")
        self.update_recent_files_menu()

        file_menu.addSeparator()

        exit_action = QAction(""Wyjście"", self)
        exit_action.setShortcut(""Ctrl+Q"")
        exit_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Edit menu
        edit_menu = menubar.addMenu(""✏️ Edycja"")

        undo_action = QAction(QIcon.fromTheme(""edit-undo""), ""Cofnij"", self)
        undo_action.setShortcut(""Ctrl+Z"")
        undo_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        undo_action.triggered.connect(self.undo)
        edit_menu.addAction(undo_action)

        redo_action = QAction(QIcon.fromTheme(""edit-redo""), ""Ponów"", self)
        redo_action.setShortcut(""Ctrl+Y"")
        redo_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        redo_action.triggered.connect(self.redo)
        edit_menu.addAction(redo_action)

        edit_menu.addSeparator()

        cut_action = QAction(QIcon.fromTheme(""edit-cut""), ""Wytnij"", self)
        cut_action.setShortcut(""Ctrl+X"")
        cut_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        cut_action.triggered.connect(self.cut)
        edit_menu.addAction(cut_action)

        copy_action = QAction(QIcon.fromTheme(""edit-copy""), ""Kopiuj"", self)
        copy_action.setShortcut(""Ctrl+C"")
        copy_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        copy_action.triggered.connect(self.copy)
        edit_menu.addAction(copy_action)

        paste_action = QAction(QIcon.fromTheme(""edit-paste""), ""Wklej"", self)
        paste_action.setShortcut(""Ctrl+V"")
        paste_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut) # Standard editor shortcut
        paste_action.triggered.connect(self.paste)
        edit_menu.addAction(paste_action)

        edit_menu.addSeparator()

        find_action = QAction(QIcon.fromTheme(""edit-find""), ""Znajdź..."", self)
        find_action.setShortcut(""Ctrl+F"")
        find_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut) # Find can often be window-wide
        find_action.triggered.connect(self.find)
        edit_menu.addAction(find_action)

        replace_action = QAction(QIcon.fromTheme(""edit-find-replace""), ""Zamień..."", self)
        replace_action.setShortcut(""Ctrl+H"")
        replace_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        replace_action.triggered.connect(self.replace)
        edit_menu.addAction(replace_action)

        # View menu
        view_menu = menubar.addMenu(""🖼️ Widok"")

        # Store references to toggle actions (Fix AttributeError)
        self.action_toggle_sidebar = QAction(""Przełącz Pasek Boczny"", self)
        self.action_toggle_sidebar.setObjectName(""Przełącz Pasek Boczny"") # Set object name for findChild if needed elsewhere
        self.action_toggle_sidebar.setShortcut(""Ctrl+B"")
        self.action_toggle_sidebar.setCheckable(True)
        self.action_toggle_sidebar.setChecked(self.show_sidebar)
        self.action_toggle_sidebar.triggered.connect(self.toggle_sidebar)
        view_menu.addAction(self.action_toggle_sidebar)

        self.action_toggle_toolbar = QAction(""Przełącz Pasek Narzędzi"", self)
        self.action_toggle_toolbar.setObjectName(""Przełącz Pasek Narzędzi"")
        self.action_toggle_toolbar.setCheckable(True)
        self.action_toggle_toolbar.setChecked(self.show_toolbar)
        self.action_toggle_toolbar.triggered.connect(self.toggle_toolbar)
        view_menu.addAction(self.action_toggle_toolbar)

        self.action_toggle_statusbar = QAction(""Przełącz Pasek Stanu"", self)
        self.action_toggle_statusbar.setObjectName(""Przełącz Pasek Stanu"")
        self.action_toggle_statusbar.setCheckable(True)
        self.action_toggle_statusbar.setChecked(self.show_statusbar)
        self.action_toggle_statusbar.triggered.connect(self.toggle_statusbar)
        view_menu.addAction(self.action_toggle_statusbar)

        view_menu.addSeparator()

        dark_theme_action = QAction(""Ciemny Motyw"", self)
        dark_theme_action.triggered.connect(lambda: self.apply_theme(""dark""))
        view_menu.addAction(dark_theme_action)

        light_theme_action = QAction(""Jasny Motyw"", self)
        light_theme_action.triggered.connect(lambda: self.apply_theme(""light""))
        view_menu.addAction(light_theme_action)

        # Tools menu
        tools_menu = menubar.addMenu(""🛠️ Narzędzia"")

        run_code_action = QAction(QIcon.fromTheme(""system-run""), ""Uruchom kod"", self)
        run_code_action.setShortcut(""Ctrl+R"")
        run_code_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut) # Run code is window-wide
        run_code_action.triggered.connect(self.run_code)
        tools_menu.addAction(run_code_action)

        settings_action = QAction(QIcon.fromTheme(""preferences-system""), ""Ustawienia..."", self)
        settings_action.triggered.connect(self.show_settings_dialog)
        tools_menu.addAction(settings_action)

        # Help menu
        help_menu = menubar.addMenu(""❓ Pomoc"")

        about_action = QAction(""O programie"", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)


    def create_tool_bar(self):
        self.toolbar = QToolBar(""Główny Pasek Narzędzi"")
        self.addToolBar(Qt.ToolBarArea.TopToolBarArea, self.toolbar)
        self.toolbar.setObjectName(""main_toolbar"") # Add object name for styling

        # Add actions (use the same actions created in the menu bar if possible, or recreate)
        # Recreating ensures they have icons regardless of theme availability
        self.toolbar.addAction(QAction(QIcon.fromTheme(""document-new""), ""Nowy"", self, triggered=self.new_file))
        self.toolbar.addAction(QAction(QIcon.fromTheme(""document-open""), ""Otwórz"", self, triggered=self.open_file_dialog))
        # Connect the toolbar save action to the same slot and set shortcut context
        save_toolbar_action = QAction(QIcon.fromTheme(""document-save""), ""Zapisz"", self, triggered=self.save_file)
        save_toolbar_action.setShortcut(""Ctrl+S"") # Redundant but good practice
        save_toolbar_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        self.toolbar.addAction(save_toolbar_action)

        self.toolbar.addSeparator()

        undo_action = QAction(QIcon.fromTheme(""edit-undo""), ""Cofnij"", self, triggered=self.undo)
        undo_action.setShortcut(""Ctrl+Z"")
        undo_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(undo_action)

        redo_action = QAction(QIcon.fromTheme(""edit-redo""), ""Ponów"", self, triggered=self.redo)
        redo_action.setShortcut(""Ctrl+Y"")
        redo_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(redo_action)

        self.toolbar.addSeparator()

        cut_action = QAction(QIcon.fromTheme(""edit-cut""), ""Wytnij"", self, triggered=self.cut)
        cut_action.setShortcut(""Ctrl+X"")
        cut_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(cut_action)

        copy_action = QAction(QIcon.fromTheme(""edit-copy""), ""Kopiuj"", self, triggered=self.copy)
        copy_action.setShortcut(""Ctrl+C"")
        copy_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(copy_action)

        paste_action = QAction(QIcon.fromTheme(""edit-paste""), ""Wklej"", self, triggered=self.paste)
        paste_action.setShortcut(""Ctrl+V"")
        paste_action.setShortcutContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.toolbar.addAction(paste_action)

        self.toolbar.addSeparator()

        find_action = QAction(QIcon.fromTheme(""edit-find""), ""Znajdź"", self, triggered=self.find)
        find_action.setShortcut(""Ctrl+F"")
        find_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        self.toolbar.addAction(find_action)

        self.toolbar.addSeparator()

        run_code_action = QAction(QIcon.fromTheme(""system-run""), ""➡️ Uruchom kod"", self, triggered=self.run_code)
        run_code_action.setShortcut(""Ctrl+R"")
        run_code_action.setShortcutContext(Qt.ShortcutContext.WindowShortcut)
        self.toolbar.addAction(run_code_action)

    def apply_theme(self, theme_name):
        self.theme = theme_name
        self.settings[""theme""] = theme_name
        save_settings(self.settings)

        if theme_name == ""dark"":
            main_bg = QColor(""#252526"")
            main_fg = QColor(""#ffffff"")
            menu_bg = QColor(""#252526"")
            menu_fg = QColor(""#ffffff"")
            menu_selected_bg = QColor(""#2d2d30"")
            menu_border = QColor(""#454545"")
            tab_pane_border = QColor(""#454545"")
            tab_pane_bg = QColor(""#1e1e1e"")
            tab_bg = QColor(""#2d2d2d"")
            tab_fg = QColor(""#ffffff"")
            tab_selected_bg = QColor(""#1e1e1e"")
            statusbar_bg = QColor(""#252526"")
            statusbar_fg = QColor(""#ffffff"")
            toolbar_bg = QColor(""#252526"")
            toolbar_fg = QColor(""#ffffff"")
            splitter_handle_bg = QColor(""#252526"")
            lineedit_bg = QColor(""#333333"")
            lineedit_fg = QColor(""#ffffff"")
            lineedit_border = QColor(""#454545"")
            button_bg = QColor(""#3c3c3c"")
            button_fg = QColor(""#ffffff"")
            button_border = QColor(""#5a5a5a"")
            button_hover_bg = QColor(""#4a4a4a"")
            button_pressed_bg = QColor(""#2a2a2a"")
            editor_bg = QColor(""#1e1e1e"")
            editor_fg = QColor(""#d4d4d4"")
            linenum_area_bg = QColor(""#252526"")
            linenum_fg = QColor(""#858585"")
            current_line_bg = QColor(""#2d2d2d"")
            chat_bg = QColor(""#1e1e1e"")
            chat_input_bg = QColor(""#333333"")
            chat_input_fg = QColor(""#ffffff"")
            bubble_user = QColor(""#3a3a3a"")
            bubble_assistant = QColor(""#2d2d2d"")
            bubble_border = QColor(""#454545"")

        else: # light theme
            main_bg = QColor(""#f5f5f5"")
            main_fg = QColor(""#333333"")
            menu_bg = QColor(""#f5f5f5"")
            menu_fg = QColor(""#333333"")
            menu_selected_bg = QColor(""#e5e5e5"")
            menu_border = QColor(""#cccccc"")
            tab_pane_border = QColor(""#cccccc"")
            tab_pane_bg = QColor(""#ffffff"")
            tab_bg = QColor(""#e5e5e5"")
            tab_fg = QColor(""#333333"")
            tab_selected_bg = QColor(""#ffffff"")
            statusbar_bg = QColor(""#f5f5f5"")
            statusbar_fg = QColor(""#333333"")
            toolbar_bg = QColor(""#f5f5f5"")
            toolbar_fg = QColor(""#333333"")
            splitter_handle_bg = QColor(""#f5f5f5"")
            lineedit_bg = QColor(""#ffffff"")
            lineedit_fg = QColor(""#000000"")
            lineedit_border = QColor(""#cccccc"")
            button_bg = QColor(""#e1e1e1"")
            button_fg = QColor(""#000000"")
            button_border = QColor(""#cccccc"")
            button_hover_bg = QColor(""#d1d1d1"")
            button_pressed_bg = QColor(""#c1c1c1"")
            editor_bg = QColor(""#ffffff"")
            editor_fg = QColor(""#000000"")
            linenum_area_bg = QColor(""#eeeeee"")
            linenum_fg = QColor(""#666666"")
            current_line_bg = QColor(""#f0f0f0"")
            chat_bg = QColor(""#ffffff"")
            chat_input_bg = QColor(""#ffffff"")
            chat_input_fg = QColor(""#000000"")
            bubble_user = QColor(""#dcf8c6"")
            bubble_assistant = QColor(""#ffffff"")
            bubble_border = QColor(""#e0e0e0"")

        palette = QPalette()
        palette.setColor(QPalette.ColorRole.Window, main_bg)
        palette.setColor(QPalette.ColorRole.WindowText, main_fg)
        palette.setColor(QPalette.ColorRole.Base, editor_bg) # Used by QTextEdit background
        palette.setColor(QPalette.ColorRole.Text, editor_fg) # Used by QTextEdit text color
        palette.setColor(QPalette.ColorRole.Button, button_bg)
        palette.setColor(QPalette.ColorRole.ButtonText, button_fg)
        palette.setColor(QPalette.ColorRole.Highlight, QColor(""#0078d4""))
        palette.setColor(QPalette.ColorRole.HighlightedText, QColor(""#ffffff""))
        palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(""#ffffe1"")) # Tooltip background
        palette.setColor(QPalette.ColorRole.ToolTipText, QColor(""#000000"")) # Tooltip text


        # Set palette for the application
        QApplication.setPalette(palette)

        # Apply specific stylesheets
        self.setStyleSheet(f""""""
            QMainWindow {{
                background-color: {main_bg.name()};
                color: {main_fg.name()};
            }}
            QMenuBar {{
                background-color: {menu_bg.name()};
                color: {menu_fg.name()};
            }}
            QMenuBar::item {{
                background-color: transparent;
                padding: 5px 10px;
                color: {menu_fg.name()};
            }}
            QMenuBar::item:selected {{
                background-color: {menu_selected_bg.name()};
            }}
            QMenu {{
                background-color: {menu_bg.name()};
                border: 1px solid {menu_border.name()};
                color: {menu_fg.name()};
            }}
            QMenu::item:selected {{
                background-color: {menu_selected_bg.name()};
            }}
            QTabWidget::pane {{
                border: 1px solid {tab_pane_border.name()};
                background: {tab_pane_bg.name()};
            }}
            QTabBar::tab {{
                background: {tab_bg.name()};
                color: {tab_fg.name()};
                padding: 5px;
                border: 1px solid {tab_pane_border.name()};
                border-bottom: none;
                min-width: 80px;
            }}
             QTabBar::tab:top, QTabBar::tab:bottom {{
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
             }}
             QTabBar::tab:left, QTabBar::tab:right {{
                border-top-left-radius: 4px;
                border-bottom-left-radius: 4px;
             }}
            QTabBar::tab:hover {{
                background: {tab_selected_bg.name()};
            }}
            QTabBar::tab:selected {{
                background: {tab_selected_bg.name()};
                border-bottom: 1px solid {tab_selected_bg.name()};
            }}
            QStatusBar {{
                background: {statusbar_bg.name()};
                color: {statusbar_fg.name()};
                border-top: 1px solid {menu_border.name()};
            }}
            QToolBar {{
                background: {toolbar_bg.name()};
                border: none;
                padding: 2px;
                spacing: 5px;
            }}
             QToolButton {{
                padding: 4px;
                border: 1px solid transparent; /* subtle border for hover */
                border-radius: 3px;
             }}
             QToolButton:hover {{
                background-color: {button_hover_bg.name()};
                border-color: {button_border.name()};
             }}
             QToolButton:pressed {{
                background-color: {button_pressed_bg.name()};
                border-color: {button_border.darker(150).name()};
             }}
            QSplitter::handle {{
                background: {splitter_handle_bg.name()};
            }}
            QSplitter::handle:hover {{
                background: {button_hover_bg.name()};
            }}
            QLineEdit {{
                background-color: {lineedit_bg.name()};
                color: {lineedit_fg.name()};
                border: 1px solid {lineedit_border.name()};
                padding: 4px;
                border-radius: 4px;
            }}
            QPushButton {{
                background-color: {button_bg.name()};
                color: {button_fg.name()};
                border: 1px solid {button_border.name()};
                border-radius: 4px;
                padding: 5px 10px;
            }}
            QPushButton:hover {{
                background-color: {button_hover_bg.name()};
                border-color: {button_border.darker(120).name()};
            }}
            QPushButton:pressed {{
                background-color: {button_pressed_bg.name()};
                border-color: {button_border.darker(150).name()};
            }}
            QScrollArea {{
                border: none;
            }}
            #chat_widget {{
                background-color: {chat_bg.name()};
            }}
             QTreeView {{
                background-color: {main_bg.name()};
                color: {main_fg.name()};
                border: 1px solid {tab_pane_border.name()}; /* Add border for separation */
                selection-background-color: {palette.color(QPalette.ColorRole.Highlight).name()};
                selection-color: {palette.color(QPalette.ColorRole.HighlightedText).name()};
            }}
            QTreeView::item:hover {{
                background-color: {menu_selected_bg.name()}; /* Subtle hover effect */
            }}

        """""")

        # Apply theme colors to CodeEditor instances
        for i in range(self.tabs.count()):
            editor = self.tabs.widget(i)
            if isinstance(editor, CodeEditor):
                editor.set_theme_colors(editor_bg, editor_fg, linenum_area_bg, linenum_fg, current_line_bg)

        # Apply theme colors to MessageWidget instances
        for i in range(self.chat_layout.count()):
            item = self.chat_layout.itemAt(i)
            if item and item.widget() and isinstance(item.widget(), MessageWidget):
                message_widget = item.widget()
                message_widget.apply_theme_colors(chat_bg, main_fg, bubble_user, bubble_assistant)

        self.apply_font_size(self.font_size)

    def update_status_bar_message(self, message: str, timeout_ms: int = 3000):
        """"""Displays a temporary message in the status bar.""""""
        if self.statusBar() and self.show_statusbar:
            self.statusBar().showMessage(message, timeout_ms)
            # The timeout handling by showMessage is often sufficient, but a dedicated timer
            # can be used for more complex clearing logic if needed.
            # self._status_timer.stop()
            # self._status_timer.start(timeout_ms)

    def clear_status_bar_message(self):
         """"""Clears the temporary status bar message.""""""
         if self.statusBar() and self.show_statusbar:
              self.statusBar().clearMessage()
              self.update_status_bar() # Restore default status message (line/col)


    def apply_font_size(self, size: int):
        self.font_size = size
        self.settings[""font_size""] = size
        save_settings(self.settings)

        for i in range(self.tabs.count()):
            editor = self.tabs.widget(i)
            if isinstance(editor, CodeEditor):
                editor.set_font_size(size)

        font = self.chat_input.font()
        font.setPointSize(size)
        self.chat_input.setFont(font)
        # Note: MessageWidget text font size is largely controlled by internal stylesheets (10pt, 9pt).

    def update_status_bar(self):
        # Ensure status bar object exists before trying to use it
        if self.statusBar() and self.show_statusbar:
            # If there's a temporary message, don't overwrite it immediately
            if not self.statusBar().currentMessage():
                editor = self.get_current_editor()
                if editor:
                    cursor = editor.textCursor()
                    line = cursor.blockNumber() + 1
                    col = cursor.columnNumber() + 1
                    modified_status = ""*"" if editor.document().isModified() else """"
                    file_name = os.path.basename(getattr(editor, 'file_path', 'Bez tytułu'))
                    self.statusBar().showMessage(f""Plik: {file_name}{modified_status} | Linia: {line}, Kolumna: {col}"")
                else:
                    current_tab_index = self.tabs.currentIndex()
                    if current_tab_index != -1:
                        tab_title = self.tabs.tabText(current_tab_index)
                        self.statusBar().showMessage(f""Gotowy - {tab_title}"")
                    else:
                        self.statusBar().showMessage(""Gotowy"")
        elif self.statusBar(): # Status bar exists but is hidden
             self.statusBar().clearMessage() # Clear any lingering message


    def get_current_editor(self):
        current_widget = self.tabs.currentWidget()
        if current_widget and isinstance(current_widget, CodeEditor):
            return current_widget
        return None

    def setup_editor_context_menu(self, editor):
        """"""Sets up a custom context menu for the CodeEditor instance.""""""
        # Disconnect any default context menu connection first if it existed
        try:
             editor.customContextMenuRequested.disconnect()
        except:
             pass # Ignore if not connected

        editor.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        editor.customContextMenuRequested.connect(lambda pos: self.show_editor_context_menu(pos, editor)) # Pass editor explicitly


    def show_editor_context_menu(self, position, editor):
        """"""Shows a custom context menu for the CodeEditor.""""""
        menu = QMenu(editor)

        undo_action = menu.addAction(""Cofnij"")
        undo_action.setIcon(QIcon.fromTheme(""edit-undo""))
        undo_action.setShortcut(""Ctrl+Z"")
        undo_action.triggered.connect(editor.undo)
        undo_action.setEnabled(editor.document().isUndoAvailable())

        redo_action = menu.addAction(""Ponów"")
        redo_action.setIcon(QIcon.fromTheme(""edit-redo""))
        redo_action.setShortcut(""Ctrl+Y"")
        redo_action.triggered.connect(editor.redo)
        redo_action.setEnabled(editor.document().isRedoAvailable())

        menu.addSeparator()

        cut_action = menu.addAction(""Wytnij"")
        cut_action.setIcon(QIcon.fromTheme(""edit-cut""))
        cut_action.setShortcut(""Ctrl+X"")
        cut_action.triggered.connect(editor.cut)
        cut_action.setEnabled(editor.textCursor().hasSelection())

        copy_action = menu.addAction(""Kopiuj"")
        copy_action.setIcon(QIcon.fromTheme(""edit-copy""))
        copy_action.setShortcut(""Ctrl+C"")
        copy_action.triggered.connect(editor.copy)
        copy_action.setEnabled(editor.textCursor().hasSelection())

        paste_action = menu.addAction(""Wklej"")
        paste_action.setIcon(QIcon.fromTheme(""edit-paste""))
        paste_action.setShortcut(""Ctrl+V"")
        paste_action.triggered.connect(editor.paste)
        clipboard = QApplication.clipboard()
        paste_action.setEnabled(bool(clipboard.text()))

        delete_action = menu.addAction(""Usuń"")
        delete_action.setIcon(QIcon.fromTheme(""edit-delete""))
        delete_action.triggered.connect(lambda: editor.textCursor().removeSelectedText())
        delete_action.setEnabled(editor.textCursor().hasSelection())

        menu.addSeparator()

        select_all_action = menu.addAction(""Zaznacz wszystko"")
        select_all_action.setIcon(QIcon.fromTheme(""edit-select-all""))
        select_all_action.setShortcut(""Ctrl+A"")
        select_all_action.triggered.connect(editor.selectAll)

        menu.exec(editor.viewport().mapToGlobal(position))

    def new_file(self):
        editor = CodeEditor()
        editor.document().contentsChanged.connect(self.update_status_bar)
        editor.cursorPositionChanged.connect(self.update_status_bar)
        editor.document().setModified(False) # New file starts as unmodified

        self.setup_editor_context_menu(editor) # Setup the context menu

        tab_title = ""Bez tytułu""
        # Store file_path as None initially for unsaved files
        editor.file_path = None
        editor.setObjectName(""editor_tab"") # Add object name for styling

        self.tabs.addTab(editor, tab_title)
        self.tabs.setCurrentWidget(editor)

        self.apply_font_size(self.font_size)
        # Re-apply theme to ensure new editor gets correct colors
        self.apply_theme(self.theme)

        self.update_recent_files(None) # Add placeholder for untitled file (or just update menu)
        self.update_status_bar()
        self.update_status_bar_message(""Utworzono nowy plik 'Bez tytułu'."")


    def open_file_dialog(self):
        start_dir = self.workspace if self.workspace and os.path.exists(self.workspace) else QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]

        file_path, _ = QFileDialog.getOpenFileName(self, ""Otwórz plik"", start_dir,
            ""Wszystkie pliki (*);;""
            ""Pliki Pythona (*.py);;""
            ""Pliki tekstowe (*.txt);;""
            ""Pliki CSS (*.css);;""
            ""Pliki HTML (*.html *.htm);;""
            ""Pliki JavaScript (*.js);;""
            ""Pliki GML (*.gml);;""
            ""Pliki JSON (*.json);;""
            ""Pliki Markdown (*.md);;""
            ""Pliki konfiguracyjne (*.ini *.cfg)"")
        if file_path:
            self.open_file(file_path)

    def open_file(self, file_path):
        """"""Opens a single file in a new tab.""""""
        if not file_path or not os.path.exists(file_path):
             QMessageBox.warning(self, ""Błąd"", f""Plik nie znaleziono:\n{file_path}"")
             self.update_status_bar_message(f""Błąd: Plik nie znaleziono ({os.path.basename(file_path)})"")
             return False

        # Check if the file is already open in a tab
        for i in range(self.tabs.count()):
            editor = self.tabs.widget(i)
            if isinstance(editor, CodeEditor) and hasattr(editor, 'file_path') and editor.file_path == file_path:
                self.tabs.setCurrentIndex(i)
                self.update_status_bar_message(f""Przełączono na plik: {os.path.basename(file_path)}"")
                return True

        # If not already open, open the file
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            editor = CodeEditor()
            editor.setPlainText(content)

            editor.document().contentsChanged.connect(self.update_status_bar)
            editor.cursorPositionChanged.connect(self.update_status_bar)
            editor.document().setModified(False) # Newly opened file is not modified

            self.setup_editor_context_menu(editor)

            file_name = os.path.basename(file_path)
            tab_title = file_name

            # Set syntax highlighting based on file extension
            # Get the actual CodeEditor highlighter object
            highlighter = None
            file_extension = os.path.splitext(file_path)[1].lower()
            if file_extension == '.py':
                highlighter = PythonHighlighter(editor.document())
            elif file_extension == '.css':
                highlighter = CSSHighlighter(editor.document())
            elif file_extension in ['.html', '.htm']:
                highlighter = HTMLHighlighter(editor.document())
            elif file_extension == '.js':
                highlighter = JSHighlighter(editor.document())
            elif file_extension == '.gml':
                highlighter = GMLHighlighter(editor.document())
            # Add more extensions/highlighters as needed

            editor.highlighter = highlighter # Assign the created highlighter (can be None)
            if highlighter:
                highlighter.rehighlight()


            editor.file_path = file_path
            editor.setObjectName(""editor_tab"") # Add object name for styling

            self.tabs.addTab(editor, tab_title)
            self.tabs.setCurrentWidget(editor)

            self.update_recent_files(file_path) # Update recent files list

            self.apply_font_size(self.font_size)
            self.apply_theme(self.theme) # Re-apply theme to ensure new editor has correct colors

            self.update_status_bar()
            self.update_status_bar_message(f""Otworzono plik: {os.path.basename(file_path)}"")
            return True
        except Exception as e:
            QMessageBox.warning(self, ""Błąd"", f""Nie można otworzyć pliku '{file_path}':\n{e}"")
            self.update_status_bar_message(f""Błąd otwierania pliku: {e}"")
            return False

    def open_files(self, file_paths: list):
        """"""Opens a list of files.""""""
        if not file_paths:
             return

        for file_path in file_paths:
            # Call the single open_file method for each file in the list
            self.open_file(file_path)


    def save_file(self):
        editor = self.get_current_editor()
        if not editor:
            self.update_status_bar_message(""Brak aktywnego edytora do zapisania."")
            return False # No active editor

        # If editor has a file_path, save to it
        if hasattr(editor, 'file_path') and editor.file_path and os.path.exists(os.path.dirname(editor.file_path) if os.path.dirname(editor.file_path) else '.'):
             # Check if the directory exists, or if it's a new file in the current directory
             file_path = editor.file_path
        else:
            # If no file_path (new file) or path is invalid, use Save As
            return self.save_file_as()

        # Perform the save operation
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(editor.toPlainText())

            editor.document().setModified(False)
            self.update_status_bar()
            self.update_recent_files(file_path)
            self.update_status_bar_message(f""Zapisano plik: {os.path.basename(file_path)}"")
            return True
        except Exception as e:
            QMessageBox.warning(self, ""Błąd"", f""Nie można zapisać pliku '{file_path}':\n{e}"")
            self.update_status_bar_message(f""Błąd zapisywania pliku: {e}"")
            return False

    def save_file_as(self):
        editor = self.get_current_editor()
        if not editor:
            self.update_status_bar_message(""Brak aktywnego edytora do zapisania."")
            return False

        initial_dir = self.workspace if self.workspace and os.path.exists(self.workspace) else QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]
        if hasattr(editor, 'file_path') and editor.file_path and os.path.dirname(editor.file_path):
            initial_dir = os.path.dirname(editor.file_path)

        file_path, _ = QFileDialog.getSaveFileName(self, ""Zapisz plik jako"", initial_dir, ""All Files (*);;Python Files (*.py);;Text Files (*.txt)"")

        if not file_path:
            self.update_status_bar_message(""Zapisywanie anulowane."")
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(editor.toPlainText())

            file_name = os.path.basename(file_path)
            index = self.tabs.indexOf(editor)
            self.tabs.setTabText(index, file_name)

            editor.file_path = file_path
            editor.document().setModified(False)
            self.update_status_bar()
            self.update_recent_files(file_path)

            # Update syntax highlighting if extension changed
            highlighter = None
            file_extension = os.path.splitext(file_path)[1].lower()
            if file_extension == '.py':
                highlighter = PythonHighlighter(editor.document())
            elif file_extension == '.css':
                highlighter = CSSHighlighter(editor.document())
            elif file_extension in ['.html', '.htm']:
                highlighter = HTMLHighlighter(editor.document())
            elif file_extension == '.js':
                highlighter = JSHighlighter(editor.document())
            elif file_extension == '.gml':
                highlighter = GMLHighlighter(editor.document())
            # Add more extensions/highlighters as needed
            editor.highlighter = highlighter # Assign the new highlighter
            editor.document().clearFormats() # Clear old highlighting before applying new one
            if highlighter:
                 highlighter.rehighlight()


            self.update_status_bar_message(f""Zapisano plik jako: {os.path.basename(file_path)}"")
            return True
        except Exception as e:
            QMessageBox.warning(self, ""Błąd"", f""Nie można zapisać pliku '{file_path}':\n{e}"")
            self.update_status_bar_message(f""Błąd zapisywania pliku jako: {e}"")
            return False

    def close_tab(self, index):
        editor = self.tabs.widget(index)
        if editor:
            if isinstance(editor, CodeEditor) and editor.document().isModified():
                file_name = os.path.basename(getattr(editor, 'file_path', 'Bez tytułu'))
                reply = QMessageBox.question(self, ""Zapisz zmiany"", f""Czy chcesz zapisać zmiany w '{file_name}' przed zamknięciem?"",
                                             QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel)
                if reply == QMessageBox.StandardButton.Yes:
                    # Need to save the tab before closing. If save fails/cancelled, stop closing.
                    # Temporarily set this tab as current to make save_file work on it.
                    original_index = self.tabs.currentIndex()
                    self.tabs.setCurrentIndex(index)
                    save_success = self.save_file()
                    self.tabs.setCurrentIndex(original_index) # Restore original index
                    if not save_success:
                        return # Stop closing if save failed/cancelled
                elif reply == QMessageBox.StandardButton.Cancel:
                    return # User cancelled closing
                # If reply is No or Yes (and save succeeded), continue closing

            tab_name = self.tabs.tabText(index) # Get name *before* removing tab
            self.tabs.removeTab(index)
            editor.deleteLater()
            self.update_status_bar() # Update status bar as current tab might change
            self.update_status_bar_message(f""Zamknięto zakładkę: {tab_name}"")

    def update_recent_files(self, file_path):
        """"""Updates the list of recent files and the menu.""""""
        # Note: None is passed for untitled files, which shouldn't be added to recent.
        if file_path and isinstance(file_path, str) and os.path.exists(file_path):
            # Normalize path for consistency
            file_path = os.path.normpath(file_path)
            # Remove if already exists to move it to the top
            if file_path in self.recent_files:
                self.recent_files.remove(file_path)

            # Add to the beginning
            self.recent_files.insert(0, file_path)

            # Trim the list if it exceeds max size
            if len(self.recent_files) > RECENT_FILES_MAX:
                self.recent_files = self.recent_files[:RECENT_FILES_MAX]

            # Save the updated list
            self.settings[""recent_files""] = self.recent_files
            save_settings(self.settings)

        # Always update the menu after potentially changing the list
        self.update_recent_files_menu()


    def update_recent_files_menu(self, menu: QMenu = None):
        """"""Updates the 'Ostatnie pliki' menu.""""""
        # Find the menu if not passed
        if menu is None:
             # Iterate through the menu bar actions to find the ""Plik"" menu
             for file_action in self.menuBar().actions():
                 if file_action.text() == ""📄 Plik"" and file_action.menu():
                     # Iterate through the ""Plik"" menu actions to find the ""Ostatnie pliki"" submenu
                     for sub_action in file_action.menu().actions():
                         # Use object name or text for lookup
                         # Ensure the action has a menu before accessing it
                         if sub_action.text() == ""Ostatnie pliki"" and sub_action.menu():
                             menu = sub_action.menu()
                             break
                 if menu: break # Stop searching once found

        if not menu: # Menu not found, cannot update
            print(""Warning: Recent files menu not found."")
            return

        menu.clear()
        # Filter out non-existent files from the stored list before updating the menu
        valid_recent_files = [f for f in self.recent_files if os.path.exists(f)]

        if not valid_recent_files:
            menu.setEnabled(False)
            # Add a dummy action
            disabled_action = QAction(""Brak ostatnio otwieranych plików"", self)
            disabled_action.setEnabled(False)
            menu.addAction(disabled_action)
        else:
            menu.setEnabled(True)
            # Use the filtered list to populate the menu
            for file_path in valid_recent_files:
                 action = QAction(os.path.basename(file_path), self)
                 # Store the file path in the action's data
                 action.setData(file_path)
                 action.triggered.connect(self.open_recent_file)
                 menu.addAction(action)

            # Update settings with the cleaned list
            if valid_recent_files != self.recent_files:
                 self.recent_files = valid_recent_files
                 self.settings[""recent_files""] = self.recent_files
                 save_settings(self.settings)


    def open_recent_file(self):
        action = self.sender()
        if action:
            file_path = action.data()
            if file_path and isinstance(file_path, str) and os.path.exists(file_path):
                self.open_file(file_path)
            else:
                QMessageBox.warning(self, ""Błąd"", f""Ostatni plik nie znaleziono:\n{file_path}"")
                self.update_status_bar_message(f""Błąd: Ostatni plik nie znaleziono ({os.path.basename(file_path)})"")
                # Remove invalid file from recent list
                if file_path in self.recent_files:
                    self.recent_files.remove(file_path)
                    self.settings[""recent_files""] = self.recent_files
                    save_settings(self.settings)
                    self.update_recent_files_menu()


    def open_workspace(self):
        start_dir = self.workspace if self.workspace and os.path.exists(self.workspace) else QStandardPaths.standardLocations(QStandardPaths.StandardLocation.HomeLocation)[0]

        dir_path = QFileDialog.getExistingDirectory(self, ""Otwórz Obszar Roboczy"", start_dir)
        if dir_path:
            self.workspace = dir_path
            self.file_explorer.model.setRootPath(dir_path)
            self.file_explorer.setRootIndex(self.file_explorer.model.index(dir_path))
            self.settings[""workspace""] = dir_path
            save_settings(self.settings)
            self.update_status_bar_message(f""Zmieniono obszar roboczy na: {dir_path}"")

    # Standard editor actions (delegated to current editor)
    def undo(self):
        editor = self.get_current_editor()
        if editor:
             editor.undo()
             self.update_status_bar_message(""Cofnięto ostatnią operację."")


    def redo(self):
        editor = self.get_current_editor()
        if editor:
             editor.redo()
             self.update_status_bar_message(""Ponowiono ostatnią operację."")


    def cut(self):
        editor = self.get_current_editor()
        if editor:
             editor.cut()
             self.update_status_bar_message(""Wycięto zaznaczenie."")


    def copy(self):
        editor = self.get_current_editor()
        if editor:
             editor.copy()
             self.update_status_bar_message(""Skopiowano zaznaczenie."")


    def paste(self):
        editor = self.get_current_editor()
        if editor:
             editor.paste()
             self.update_status_bar_message(""Wklejono zawartość schowka."")


    # Basic find/replace (delegated)
    def find(self):
        editor = self.get_current_editor()
        if editor:
            text, ok = QInputDialog.getText(self, ""Znajdź"", ""Szukaj:"")
            if ok and text:
                cursor = editor.textCursor()
                # Find from current position first
                if not editor.find(text):
                     # If not found from current position, try from the beginning
                     cursor.movePosition(QTextCursor.MoveOperation.Start)
                     editor.setTextCursor(cursor)
                     if not editor.find(text):
                         QMessageBox.information(self, ""Znajdź"", f""'{text}' nie znaleziono."")
                         self.update_status_bar_message(f""Nie znaleziono '{text}'."")
                     else:
                         self.update_status_bar_message(f""Znaleziono pierwsze wystąpienie '{text}'."")
                else:
                     self.update_status_bar_message(f""Znaleziono następne wystąpienie '{text}'."")


    def replace(self):
        editor = self.get_current_editor()
        if editor:
            find_text, ok1 = QInputDialog.getText(self, ""Zamień"", ""Szukaj:"")
            if ok1 and find_text:
                replace_text, ok2 = QInputDialog.getText(self, ""Zamień"", ""Zamień na:"")
                if ok2:
                    # Simple text replacement (replaces all occurrences)
                    text = editor.toPlainText()
                    # Count occurrences before replacing
                    occurrences = text.count(find_text)
                    if occurrences > 0:
                        new_text = text.replace(find_text, replace_text)
                        editor.setPlainText(new_text)
                        editor.document().setModified(True)
                        self.update_status_bar()
                        self.update_status_bar_message(f""Zamieniono {occurrences} wystąpień '{find_text}'."")
                    else:
                         QMessageBox.information(self, ""Zamień"", f""'{find_text}' nie znaleziono."")
                         self.update_status_bar_message(f""Nie znaleziono '{find_text}' do zamiany."")


    # Code execution
    def run_code(self):
        editor = self.get_current_editor()
        if editor:
            code = editor.toPlainText()
            if not code.strip():
                self.add_message(""assistant"", ""Brak kodu do uruchomienia."")
                self.update_status_bar_message(""Brak kodu do uruchomienia."")
                return

            # Add user message to chat history
            self.add_message(""user"", f""Proszę uruchomić ten kod:\n```\n{code}\n```"")

            try:
                # Use a temporary file with a .py extension to allow python interpreter to identify it
                # Ensure the temp directory exists and has write permissions
                temp_dir = tempfile.gettempdir()
                if not os.access(temp_dir, os.W_OK):
                    QMessageBox.warning(self, ""Błąd"", f""Brak uprawnień zapisu w katalogu tymczasowym: {temp_dir}"")
                    self.add_message(""assistant"", f""Błąd: Brak uprawnień zapisu w katalogu tymczasowym."")
                    self.update_status_bar_message(""Błąd: Brak uprawnień zapisu w katalogu tymczasowym."")
                    return

                # Ensure the temp file has a .py extension for the interpreter
                temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False, encoding='utf-8', dir=temp_dir)
                temp_file_path = temp_file.name
                temp_file.write(code)
                temp_file.close()


                self.add_message(""assistant"", ""⚙️ Uruchamiam kod..."", {""type"": ""placeholder""})
                self.update_status_bar_message(f""Uruchamiam kod ({os.path.basename(getattr(editor, 'file_path', 'Bez tytułu'))})"")


                # Run the code in a separate process
                # Using sys.executable ensures we use the same Python interpreter running the app
                process = subprocess.Popen([sys.executable, temp_file_path],
                                          stdout=subprocess.PIPE,
                                          stderr=subprocess.PIPE,
                                          text=True, # Decode output as text
                                          encoding='utf-8',
                                          cwd=os.path.dirname(temp_file_path)) # Set working directory


                stdout = """"
                stderr = """"
                try:
                    # Use a slightly longer timeout, maybe 30 seconds?
                    # Or make it configurable. Let's stick to 10 for now.
                    timeout_seconds = 10
                    stdout, stderr = process.communicate(timeout=timeout_seconds)
                    process.wait() # Ensure process is truly finished
                except subprocess.TimeoutExpired:
                    process.kill() # Kill the process if it times out
                    process.wait() # Wait for it to be killed
                    stderr = f""Czas wykonania kodu minął po {timeout_seconds} sekundach. Proces został przerwany.\n{stderr}""
                    self.update_status_bar_message(f""Wykonanie kodu przekroczyło limit czasu ({timeout_seconds}s)."")

                except Exception as proc_err:
                     stderr = f""Błąd wewnętrzny podczas uruchamiania procesu: {proc_err}\n{stderr}""
                     self.update_status_bar_message(f""Błąd wewnętrzny uruchamiania kodu: {proc_err}"")


                # Clean up the temporary file
                try:
                    os.unlink(temp_file_path)
                except OSError as e:
                    print(f""Błąd usuwania pliku tymczasowego {temp_file_path}: {e}"")
                    # Decide if this should be a user-visible error, probably not critical

                # Remove the placeholder message
                self.remove_last_message_widget()

                # Display the output and errors in the chat
                output_message = """"
                if stdout:
                    output_message += f""Wyjście:\n```text\n{stdout.strip()}\n```\n"" # Use 'text' for plain output highlighting
                if stderr:
                    output_message += f""Błędy:\n```text\n{stderr.strip()}\n```\n""

                if output_message:
                    self.add_message(""assistant"", f""Wykonanie kodu zakończone:\n{output_message}"")
                    self.update_status_bar_message(""Wykonanie kodu zakończone."")
                else:
                    self.add_message(""assistant"", ""Kod wykonano bez wyjścia i błędów."")
                    self.update_status_bar_message(""Kod wykonano bez wyjścia/błędów."")

            except FileNotFoundError:
                self.remove_last_message_widget()
                self.add_message(""assistant"", f""Błąd: Interpreter Pythona '{sys.executable}' nie znaleziono."")
                self.update_status_bar_message(f""Błąd: Interpreter Pythona nie znaleziono."")
            except Exception as e:
                self.remove_last_message_widget()
                self.add_message(""assistant"", f""Błąd wykonania kodu: {str(e)}"")
                print(f""Błąd uruchamiania kodu: {traceback.format_exc()}"")
                self.update_status_bar_message(f""Błąd wykonania kodu: {e}"")

    # Visibility toggles (Fixed AttributeErrors by using stored action references)
    def toggle_sidebar(self):
        self.show_sidebar = not self.show_sidebar
        self.sidebar.setVisible(self.show_sidebar)
        self.settings[""show_sidebar""] = self.show_sidebar
        save_settings(self.settings)
        if self.action_toggle_sidebar: # Check if reference exists
            self.action_toggle_sidebar.setChecked(self.show_sidebar)
        self.update_status_bar_message(f""Pasek boczny: {'widoczny' if self.show_sidebar else 'ukryty'}"")

    def toggle_toolbar(self):
        self.show_toolbar = not self.show_toolbar
        self.toolbar.setVisible(self.show_toolbar)
        self.settings[""show_toolbar""] = self.show_toolbar
        save_settings(self.settings)
        if self.action_toggle_toolbar: # Check if reference exists
            self.action_toggle_toolbar.setChecked(self.show_toolbar)
        self.update_status_bar_message(f""Pasek narzędzi: {'widoczny' if self.show_toolbar else 'ukryty'}"")

    def toggle_statusbar(self):
        self.show_statusbar = not self.show_statusbar
        if self.statusBar():
            self.statusBar().setVisible(self.show_statusbar)
        self.settings[""show_statusbar""] = self.show_statusbar
        save_settings(self.settings)
        if self.action_toggle_statusbar: # Check if reference exists
            self.action_toggle_statusbar.setChecked(self.show_statusbar)
        # Status bar message won't appear if status bar is now hidden
        if self.show_statusbar:
            self.update_status_bar_message(f""Pasek stanu: {'widoczny' if self.show_statusbar else 'ukryty'}"")


    def show_settings_dialog(self):
        # Pass active model configurations and current settings
        dialog = SettingsDialog(ACTIVE_MODELS_CONFIG, self.settings, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Update model and API type
            selected_api_type, selected_identifier = dialog.get_selected_model_config()

            model_changed = (selected_api_type != self.current_api_type or selected_identifier != self.current_model_identifier)

            self.current_api_type = selected_api_type
            self.current_model_identifier = selected_identifier
            self.settings[""api_type""] = self.current_api_type
            self.settings[""model_identifier""] = self.current_model_identifier

            # Update Mistral key
            if HAS_MISTRAL:
                new_mistral_key = dialog.get_mistral_api_key()
                key_changed = (new_mistral_key != self.mistral_api_key)
                self.mistral_api_key = new_mistral_key
                self.settings[""mistral_api_key""] = self.mistral_api_key
            else:
                 key_changed = False # Key couldn't change if Mistral isn't supported

            save_settings(self.settings)

            # Inform user about settings changes
            status_messages = []
            if model_changed:
                display_name = next((name for api_type, identifier, name in ACTIVE_MODELS_CONFIG if api_type == self.current_api_type and identifier == self.current_model_identifier), self.current_model_identifier)
                status_messages.append(f""Model AI zmieniono na '{display_name}'."")
            if key_changed:
                 status_messages.append(f""Ustawienia klucza API Mistral zaktualizowane."")

            new_theme = dialog.get_selected_theme()
            if new_theme != self.theme:
                self.apply_theme(new_theme)
                status_messages.append(f""Motyw zmieniono na '{new_theme}'."")


            new_font_size = dialog.get_font_size()
            if new_font_size != self.font_size:
                self.apply_font_size(new_font_size)
                status_messages.append(f""Rozmiar czcionki zmieniono na {new_font_size}."")


            ui_visibility = dialog.get_ui_visibility()
            if ui_visibility[""show_sidebar""] != self.show_sidebar:
                self.toggle_sidebar() # This call updates settings and status bar message internally
            if ui_visibility[""show_toolbar""] != self.show_toolbar:
                self.toggle_toolbar() # This call updates settings and status bar message internally
            if ui_visibility[""show_statusbar""] != self.show_statusbar:
                self.toggle_statusbar() # This call updates settings and status bar message internally


            if status_messages:
                 self.update_status_bar_message(""Ustawienia zaktualizowane: "" + ""; "".join(status_messages), 5000)
            else:
                 self.update_status_bar_message(""Ustawienia zapisano."")


    def show_about(self):
        QMessageBox.about(self, ""Informacje o Edytorze Kodu AI"",
                          ""<h2>Edytor Kodu AI</h2>""
                          ""<p>Prosty edytor kodu z integracją czatu AI.</p>""
                          ""<p>Wykorzystuje API Google Gemini i Mistral do pomocy AI.</p>""
                          ""<p>Wersja 1.1</p>""
                          ""<p>Stworzony przy użyciu PyQt6, google-generativeai i mistralai</p>"")
        self.update_status_bar_message(""Wyświetlono informacje o programie."")


    # --- Chat Message Handling ---
    def add_message(self, role: str, content: str, metadata: dict = None):
        # Add message to internal history (excluding placeholders, errors, empty)
        if metadata is None or metadata.get(""type"") not in [""placeholder"", ""error"", ""empty_response""]:
            # Store clean history for API calls
            self.chat_history.append((role, content, metadata))
            # Limit history size
            HISTORY_LIMIT = 20 # Keep a reasonable history size
            if len(self.chat_history) > HISTORY_LIMIT:
                self.chat_history = self.chat_history[len(self.chat_history) - HISTORY_LIMIT:]

        message_widget = MessageWidget(role, content, metadata=metadata, parent=self.chat_widget)

        # Apply current theme colors
        if self.theme == ""dark"":
            bubble_user_color = QColor(""#3a3a3a"")
            bubble_assistant_color = QColor(""#2d2d2d"")
            main_fg_color = QColor(""#ffffff"")
        else: # light theme
            bubble_user_color = QColor(""#dcf8c6"")
            bubble_assistant_color = QColor(""#ffffff"")
            main_fg_color = QColor(""#333333"")

        message_widget.apply_theme_colors(self.chat_widget.palette().color(QPalette.ColorRole.Window), main_fg_color, bubble_user_color, bubble_assistant_color)

        # Add the widget to the chat layout, keeping the stretch item at the end
        # Find the stretch item
        stretch_item = None
        if self.chat_layout.count() > 0:
             last_item = self.chat_layout.itemAt(self.chat_layout.count() - 1)
             if last_item and last_item.spacerItem():
                  stretch_item = self.chat_layout.takeAt(self.chat_layout.count() - 1)

        self.chat_layout.addWidget(message_widget)

        # Re-add the stretch item if found
        if stretch_item:
             self.chat_layout.addItem(stretch_item)
        elif self.chat_layout.count() == 1: # If this is the very first message and no stretch was added yet
             self.chat_layout.addStretch(1)


        if message_widget.is_placeholder:
            self.current_placeholder_widget = message_widget

        QTimer.singleShot(50, self.scroll_chat_to_bottom)

    def remove_last_message_widget(self):
        if self.chat_layout.count() > 1: # Need at least 1 widget + 1 stretch
            widget_to_remove = None
            # Find the last widget item before the stretch
            for i in reversed(range(self.chat_layout.count())):
                item = self.chat_layout.itemAt(i)
                if item and item.widget():
                    widget_to_remove = item.widget()
                    break

            if widget_to_remove:
                self.chat_layout.removeWidget(widget_to_remove)
                widget_to_remove.deleteLater()

            self.current_placeholder_widget = None

    def scroll_chat_to_bottom(self):
        self.chat_scroll.verticalScrollBar().setValue(self.chat_scroll.verticalScrollBar().maximum())

    def send_message(self):
        if self._is_processing:
            return

        msg = self.chat_input.text().strip()
        if not msg:
            return

        self._is_processing = True
        self.add_message(""user"", msg, None)

        self.chat_input.clear()
        self.chat_input.setPlaceholderText(""Czekam na odpowiedź..."")
        self.send_button.setEnabled(False)
        self.chat_input.setEnabled(False)
        self.update_status_bar_message(""Wysyłam zapytanie do modelu AI..."")


        # Stop any running worker thread
        if self.worker_thread and self.worker_thread.isRunning():
            print(""Stopping existing worker thread..."")
            self.worker.stop()
            if not self.worker_thread.wait(1000): # Wait up to 1 second
                print(""Worker thread did not stop cleanly, terminating."")
                self.worker_thread.terminate()
                self.worker_thread.wait()
            print(""Worker thread stopped."")

        # Determine which worker to use based on selected API type
        api_type = self.current_api_type
        model_identifier = self.current_model_identifier
        worker = None

        if api_type == ""gemini"" and HAS_GEMINI:
            api_key = GEMINI_API_KEY_GLOBAL # Use the globally loaded Gemini key
            if not api_key:
                 self.handle_error(""Klucz API Google Gemini nie znaleziono. Ustaw go w pliku .api_key lub w ustawieniach."")
                 self._is_processing = False # Reset state
                 self.send_button.setEnabled(True)
                 self.chat_input.setEnabled(True)
                 self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
                 return
            worker = GeminiWorker(api_key, msg, list(self.chat_history), model_identifier)

        elif api_type == ""mistral"" and HAS_MISTRAL:
            api_key = self.mistral_api_key # Use the key from settings
            if not api_key:
                 self.handle_error(""Klucz API Mistral nie ustawiono w ustawieniach."")
                 self._is_processing = False # Reset state
                 self.send_button.setEnabled(True)
                 self.chat_input.setEnabled(True)
                 self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
                 return
            worker = MistralWorker(api_key, msg, list(self.chat_history), model_identifier)
        else:
            # Check if the selected model type is ""none"" (fallback when no APIs are installed)
            if api_type == ""none"":
                 self.handle_error(""Brak dostępnych modeli AI. Proszę zainstalować obsługiwane biblioteki API."")
            else:
                 self.handle_error(f""Wybrany model '{model_identifier}' (API '{api_type}') nie jest obsługiwany lub brakuje zainstalowanych bibliotek."")

            self._is_processing = False # Reset state
            self.send_button.setEnabled(True)
            self.chat_input.setEnabled(True)
            self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
            return


        self.worker = worker # Store the current worker
        self.worker_thread = QThread()
        self.worker.moveToThread(self.worker_thread)

        self.worker.response_chunk.connect(self.handle_response_chunk)
        self.worker.response_complete.connect(self.handle_response_complete)
        self.worker.error.connect(self.handle_error)

        self.worker_thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.worker_thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker_thread.finished.connect(self.worker_thread.deleteLater)

        self.current_response_content = """"
        display_name = next((name for t, i, name in ACTIVE_MODELS_CONFIG if t == api_type and i == model_identifier), model_identifier)
        self.add_message(""assistant"", f""⚙️ Przetwarzam z użyciem '{display_name}'..."", {""type"": ""placeholder""})

        self.worker_thread.start()

    def handle_response_chunk(self, chunk: str):
        self.current_response_content += chunk
        if self.current_placeholder_widget:
            self.current_placeholder_widget.update_placeholder_text(self.current_response_content)
        self.scroll_chat_to_bottom()

    def handle_response_complete(self):
        if self.current_placeholder_widget:
            self.remove_last_message_widget()

        final_content = self.current_response_content.strip()
        if final_content:
            self.add_message(""assistant"", self.current_response_content, None)
        else:
            self.add_message(""assistant"", ""Otrzymano pustą odpowiedź od modelu."", {""type"": ""empty_response""})

        self.current_response_content = """"
        self.send_button.setEnabled(True)
        self.chat_input.setEnabled(True)
        self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
        self.chat_input.setFocus()
        self._is_processing = False
        self.scroll_chat_to_bottom()
        self.update_status_bar_message(""Odpowiedź AI zakończona."")


    def handle_error(self, error_message: str):
        if self.current_placeholder_widget:
            self.remove_last_message_widget()

        error_styled_message = f""<span style='color: #cc0000; font-weight: bold;'>Błąd API:</span> {error_message}""
        self.add_message(""assistant"", error_styled_message, {""type"": ""error""})

        self.send_button.setEnabled(True)
        self.chat_input.setEnabled(True)
        self.chat_input.setPlaceholderText(""Wpisz wiadomość tutaj..."")
        self.chat_input.setFocus()
        self._is_processing = False
        self.current_response_content = """"
        self.scroll_chat_to_bottom()
        self.update_status_bar_message(f""Błąd API: {error_message[:50]}..."") # Truncate message for status bar

    def closeEvent(self, event):
        # Stop the worker thread
        if self.worker_thread and self.worker_thread.isRunning():
            self.worker.stop()
            if not self.worker_thread.wait(3000): # Wait up to 3 seconds
                print(""Worker thread did not finish after stop signal, terminating."")
                self.worker_thread.terminate()
                self.worker_thread.wait()

        # Check for unsaved files
        unsaved_tabs = []
        for i in range(self.tabs.count()):
            editor = self.tabs.widget(i)
            if isinstance(editor, CodeEditor) and editor.document().isModified():
                 unsaved_tabs.append(i)

        if unsaved_tabs:
            # Ask about saving all unsaved tabs
            reply = QMessageBox.question(self, ""Zapisz zmiany"", f""Masz niezapisane zmiany w {len(unsaved_tabs)} plikach.\nCzy chcesz zapisać zmiany przed wyjściem?"",
                                         QMessageBox.StandardButton.SaveAll | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)

            if reply == QMessageBox.StandardButton.Cancel:
                event.ignore() # Stop closing
                self.update_status_bar_message(""Zamykanie anulowane."")
                return
            elif reply == QMessageBox.StandardButton.SaveAll:
                save_success = True
                # Iterate over unsaved tabs and try to save each one
                for index in unsaved_tabs:
                     editor = self.tabs.widget(index) # Get the editor again, index might change if tabs are closed during save
                     if editor and isinstance(editor, CodeEditor) and editor.document().isModified():
                          # Temporarily switch to the tab to make save_file work correctly
                          original_index = self.tabs.currentIndex()
                          self.tabs.setCurrentIndex(index)
                          current_save_success = self.save_file() # This updates status bar
                          self.tabs.setCurrentIndex(original_index) # Restore original index

                          if not current_save_success:
                               save_success = False
                               # If any save fails/cancelled, stop the whole process
                               event.ignore()
                               self.update_status_bar_message(""Zamykanie przerwane z powodu błędu zapisu."")
                               return # Stop the loop and closing process

                if save_success:
                     event.accept() # Continue closing if all saves succeeded
                else:
                     # This path should ideally not be reached due to the 'return' above,
                     # but as a safeguard:
                     event.ignore()
                     self.update_status_bar_message(""Zamykanie przerwane z powodu błędu zapisu."") # Redundant but safe
                     return

            elif reply == QMessageBox.StandardButton.Discard:
                # Discard changes and close all tabs
                # We need to close tabs in reverse order to avoid index issues
                for i in reversed(unsaved_tabs):
                    self.tabs.removeTab(i) # Remove tab without saving check

                event.accept() # Continue closing
                self.update_status_bar_message(""Zamknięto pliki bez zapisywania zmian."")


        else:
             # No unsaved tabs, just accept the close event
             event.accept()


# --- Main Application Entry Point ---

if __name__ == ""__main__"":
    # Enable High DPI scaling
    QGuiApplication.setHighDpiScaleFactorRoundingPolicy(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)

    app = QApplication(sys.argv)
    app.setApplicationName(""Edytor Kodu AI"")
    app.setOrganizationName(""YourOrganization"")

    # Initialize icon theme if available
    # QIcon.setThemeName(""breeze-dark"") # Example theme, requires icon theme installed

    try:
        main_window = CodeEditorWindow()
        main_window.show()
        sys.exit(app.exec())
    except Exception as app_error:
        print(f""Wystąpił nieoczekiwany błąd podczas uruchamiania aplikacji:\n{app_error}"")
        traceback.print_exc()
        # Ensure message box is shown even if app failed to initialize fully
        try:
            QMessageBox.critical(None, ""Błąd uruchomienia aplikacji"", f""Wystąpił nieoczekiwany błąd podczas uruchomienia aplikacji:\n{app_error}\n\nSprawdź konsolę, aby uzyskać szczegóły."")
        except Exception as mb_error:
            print(f""Could not show error message box: {mb_error}"")
        sys.exit(1)"
8Cc1kZ6s,String Pureness,Andonoff,Python,Sunday 18th of May 2025 08:18:49 AM CDT,"number_of_strings = int(input())

for current_string in range(number_of_strings):
    current_string = input()

    if "","" in current_string \
        or ""."" in current_string \
        or ""_"" in current_string:

        print(f""{current_string} is not pure!"")
    else:
        print(f""{current_string} is pure."")"
JNPQVS4h,Download Test,Fraeric123,Lua,Sunday 18th of May 2025 07:55:15 AM CDT,"local args = {...}

-- Kontrola, jestli byl zadán alespoň 1 argument (např. URL)
if not args[1] then
  print(""Použití: download <url> [soubor]"")
  os.exit(1)
end

local url = args[1]
local outputFile = args[2] or ""downloaded.lua""  -- Volitelný název výstupního souboru

local component = require(""component"")
local internet = component.internet

print(""Stahuji z: "" .. url)

local response = internet.request(url)
local isGood, err = pcall(function()
  local file, err = io.open(outputFile, ""w"")
  if not file then error(err) end
  for chunk in response do
    file:write(chunk)
  end
  file:close()
end)

if isGood then
  print(""Uloženo jako: "" .. outputFile)
else
  io.stderr:write(""Chyba při stahování:\n"")
  io.stderr:write(err .. ""\n"")
  os.exit(1)
end
"
EmqTyqh0,geometric-acceptance,Aurox_,C,Sunday 18th of May 2025 07:49:39 AM CDT,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define ARG_NUM 4

double ran_cos(void);

int main(int argc, char *argv[ARG_NUM]) {
    double r, d, cos_theta, cos_theta_crit, ratio, expected_ratio;
    int n;
    unsigned int counts, i;
    srand(time(NULL));

    if (argc != ARG_NUM) {
        fprintf(stderr, ""Usage: %s <number of points> <radius> <distance>\n"", argv[0]);
        return 1;
    }

    n = atoi(argv[1]);
    r = atof(argv[2]);
    d = atof(argv[3]);

    if (n <= 0) {
        fprintf(stderr, ""Number of points must be a positive integer.\n"");
        return 1;
    }
    if (r <= 0 || d <= 0) {
        fprintf(stderr, ""Radius and distance must be positive numbers.\n"");
        return 1;
    }

    
    cos_theta_crit = d / sqrt(r * r + d * d);
    printf(""Critical cos(theta): %f\n"", cos_theta_crit);

    for (i = 0, counts = 0; i < n; i++) {
        cos_theta = ran_cos();
        if (cos_theta > cos_theta_crit) {
            counts++;
        }
    }
    ratio = ((float)counts) / n;
    expected_ratio = 0.5 * (1 - cos_theta_crit);

    printf(""Total points: %d\nTotal hits: %d\nRatio: %.6f\nExpected ratio: %.6f\n"", n, counts, ratio, expected_ratio);

    return 0;
}

double ran_cos(void) {
    return 1 - 2 * ((double)rand() / RAND_MAX);
}"
8nbWa7Zf,OnOffSwitch,Fraeric123,Lua,Sunday 18th of May 2025 07:02:35 AM CDT,"local component = require(""component"")
local sides = require(""sides"")
local term = require(""term"")

local outputSide = sides.top
local rsAddress = nil

for address, ctype in component.list(""redstone"") do
   	rsAddress = address
	break
end    

if rsAddress == nil then
    print(""No redstone IO"")
    exit()
end

local rs = component.proxy(rsAddress)

function zapnout()
    term.clear()
    rs.setOutput(outputSide, 15)
    print(""Redstone zapnut."")
    os.sleep(0.5)
    menu()
end

function vypnout()
    term.clear()
    rs.setOutput(outputSide, 0)
    print(""Redstone vypnut."")
    os.sleep(0.5)
    menu()
end

function menu()
    term.clear()
	print(""Redstone ovládání"")
	print(""1 - Zapnout"")
	print(""2 - Vypnout"")
    
    local input = io.read()
    if input == ""1"" then
        zapnout()
    elseif input == ""2"" then
        vypnout()
    else
        print(""Neplatná volba."")
    end
end

menu()
"
zdrYj8qh,Untitled,rubiin,JavaScript,Sunday 18th of May 2025 06:21:37 AM CDT,"15-6000, 1 week-4500"
anHBQg0A,dataNone,TestGuy1,JSON,Sunday 18th of May 2025 06:00:20 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '49259a9c69f046de10664ef08f6d0b0eff3052f5e84c0c30badcfa059768d0ddb10686c0dadc538f4c9256a7f381f3d5983bc27ebe40fff5b0ca2d1e936e816092108aabc2aca9c1396eb781c4c1fe7f03a2758734488daec3f1779be9924770c9c682dd90b9926c28c97bef31a291844a5c7289d5a1d82ad3d64407f02e61ec',
  otherdata: [
    '841c202f1ae3fbbb38440cba44c3f6ec',
    '0920f6ae77b7641af8e2745b0ce39704',
    '37d398cfce77d70f5a45b1289f4715e5',
    '3fccfa629fc1f0a66dd7ef74e50a4920',
    '765472ca44f1587a357a7b2494f50520',
    '0a91abdb9fc3f954e317a2d20662c924',
    '509d664e553b431f850d5295b781b2fa',
    '76562617e06b7202b4a45a771eedb901'
  ]
}"
4jjBfU6y,Untitled,rgruber,JavaScript,Sunday 18th of May 2025 05:38:10 AM CDT,"// https://rapiddns.io/subdomain/krone.at?full=1
[...document.getElementById(""table"").tBodies[0].childNodes].map(v=>v.innerText).filter(Boolean).map(v=>v.split(""\t"")).filter(v=>v[3]!='AAAA')"
7N49mCds,Untitled,PaffcioStudio,Lua,Sunday 18th of May 2025 05:10:00 AM CDT,"import sys
import os
import json
import subprocess
import re
import platform
import shutil # Do kopiowania plików
import shlex # Do bezpiecznego formatowania komend
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QSplitter, QTreeView, QTabWidget, QPlainTextEdit,
    QPushButton, QLineEdit, QFileDialog, QMenuBar, QToolBar, QStatusBar,
    QMessageBox, QMenu, QStyleFactory, QDialog, QFormLayout,
    QLabel, QDialogButtonBox, QComboBox, QToolButton,
    QInputDialog, QSpinBox, QSizePolicy, QAbstractItemView,
    QFrame # Dodano do okna ustawień
)
from PyQt6.QtGui import (
    QIcon, QAction, QKeySequence, QTextCharFormat, QFont,
    QSyntaxHighlighter, QTextDocument, QColor, QFileSystemModel,
    QDesktopServices, # Do otwierania plików w domyślnych aplikacjach
    QPalette # Do motywów
)
from PyQt6.QtCore import (
    QDir, Qt, QProcess, QSettings, QFileInfo, QThread, pyqtSignal, QTimer, QSize,
    QStandardPaths, QUrl, QLocale, QCoreApplication, QProcessEnvironment
)
try:
    import qtawesome as qta
except ImportError:
    qta = None
    print(""Zainstaluj qtawesome ('pip install qtawesome') dla lepszych ikon."", file=sys.stderr)
APP_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(APP_DIR, 'data')
PROJECTS_DIR = os.path.join(APP_DIR, 'projects')
SETTINGS_FILE = os.path.join(DATA_DIR, 'settings.json')
RECENTS_FILE = os.path.join(DATA_DIR, 'recents.json')
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(PROJECTS_DIR, exist_ok=True)
FORMAT_DEFAULT = QTextCharFormat()
FORMAT_KEYWORD = QTextCharFormat()
FORMAT_KEYWORD.setForeground(QColor(""#000080"")) # Navy
FORMAT_STRING = QTextCharFormat()
FORMAT_STRING.setForeground(QColor(""#008000"")) # Green
FORMAT_COMMENT = QTextCharFormat()
FORMAT_COMMENT.setForeground(QColor(""#808080"")) # Gray
FORMAT_COMMENT.setFontItalic(True)
FORMAT_FUNCTION = QTextCharFormat()
FORMAT_FUNCTION.setForeground(QColor(""#0000FF"")) # Blue
FORMAT_CLASS = QTextCharFormat()
FORMAT_CLASS.setForeground(QColor(""#A52A2A"")) # Brown
FORMAT_CLASS.setFontWeight(QFont.Weight.Bold)
FORMAT_NUMBERS = QTextCharFormat()
FORMAT_NUMBERS.setForeground(QColor(""#FF0000"")) # Red
FORMAT_OPERATOR = QTextCharFormat()
FORMAT_OPERATOR.setForeground(QColor(""#A62929"")) # Dark Red
FORMAT_BUILTIN = QTextCharFormat()
FORMAT_BUILTIN.setForeground(QColor(""#008080"")) # Teal
FORMAT_SECTION = QTextCharFormat() # Dla sekcji w INI
FORMAT_SECTION.setForeground(QColor(""#800080"")) # Purple
FORMAT_SECTION.setFontWeight(QFont.Weight.Bold)
FORMAT_PROPERTY = QTextCharFormat() # Dla kluczy/właściwości w INI/JSON
FORMAT_PROPERTY.setForeground(QColor(""#B8860B"")) # DarkGoldenrod
HIGHLIGHTING_RULES = {
    'python': {
        'keywords': ['and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else',
                     'except', 'False', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'None',
                     'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'True', 'try', 'while', 'with', 'yield'],
        'builtins': ['print', 'len', 'range', 'list', 'dict', 'tuple', 'set', 'str', 'int', 'float', 'bool', 'open', 'isinstance'],
        'patterns': [
            (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION), # Funkcje (proste wykrycie, litera/podkreślnik na początku)
            (r'\bclass\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS), # Klasy
            (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS), # Liczby
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR), # Operatory
            (r'"".*?""', FORMAT_STRING), # Stringi w cudzysłowach podwójnych
            (r""'.*?'"", FORMAT_STRING), # Stringi w cudzysłowach pojedynczych
            (r'#.*', FORMAT_COMMENT), # Komentarze liniowe
        ]
    },
    'javascript': {
        'keywords': ['abstract', 'arguments', 'await', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const', 'continue',
                     'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'final',
                     'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import', 'in', 'instanceof', 'int', 'interface',
                     'let', 'long', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'short', 'static',
                     'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void',
                     'volatile', 'while', 'with', 'yield'],
         'builtins': ['console', 'log', 'warn', 'error', 'info', 'Math', 'Date', 'Array', 'Object', 'String', 'Number', 'Boolean', 'RegExp', 'JSON', 'Promise', 'setTimeout', 'setInterval'], # Przykładowe
        'patterns': [
            (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION), # Funkcje (proste wykrycie)
             (r'\bclass\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS), # Klasy
            (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS), # Liczby
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR), # Operatory
            (r'"".*?""', FORMAT_STRING), # Stringi w cudzysłowach podwójnych
            (r""'.*?'"", FORMAT_STRING), # Stringi w cudzysłowach pojedynczych
            (r'//.*', FORMAT_COMMENT), # Komentarze liniowe
        ]
    },
     'html': {
        'keywords': [], # HTML nie ma tradycyjnych słów kluczowych w ten sposób
        'builtins': [], # Encje HTML można potraktować jako builtins
        'patterns': [
            (r'<[^>]+>', FORMAT_KEYWORD), # Tagi HTML (uproszczone, bez atrybutów)
            (r'[a-zA-Z0-9_-]+\s*=', FORMAT_OPERATOR), # Znaki '=' w atrybutach
            (r'"".*?""', FORMAT_STRING), # Wartości atrybutów
            (r""'.*?'"", FORMAT_STRING), # Wartości atrybutów
             (r'&[a-zA-Z0-9]+;', FORMAT_BUILTIN), # Encje HTML
            (r'<!--.*?-->', FORMAT_COMMENT, re.DOTALL), # Komentarze (z re.DOTALL, aby objęły wiele linii)
        ]
    },
    'css': {
        'keywords': [],
        'builtins': [], # Selektory ID
        'patterns': [
            (r'\.[a-zA-Z0-9_-]+', FORMAT_CLASS), # Selektory klas
            (r'#[a-zA-Z0-9_-]+', FORMAT_BUILTIN), # Selektory ID
            (r'[a-zA-Z0-9_-]+\s*:', FORMAT_KEYWORD), # Właściwości CSS
            (r';', FORMAT_OPERATOR), # Średniki
            (r'\{|\}', FORMAT_OPERATOR), # Nawiasy klamrowe
             (r'\(|\)', FORMAT_OPERATOR), # Nawiasy okrągłe (np. w rgb())
            (r'\b\d+(\.\d*)?(px|em|%|vh|vw|rem|pt|cm|mm)?\b', FORMAT_NUMBERS), # Liczby z jednostkami
             (r'#[0-9a-fA-F]{3,6}', FORMAT_NUMBERS), # Kolory HEX
            (r'"".*?""', FORMAT_STRING), # Wartości stringów
            (r""'.*?'"", FORMAT_STRING), # Wartości stringów
        ]
    },
    'c++': {
         'keywords': ['alignas', 'alignof', 'and', 'and_eq', 'asm', 'atomic_cancel', 'atomic_commit', 'atomic_noexcept', 'auto',
                     'bitand', 'bitor', 'bool', 'break', 'case', 'catch', 'char', 'char8_t', 'char16_t', 'char32_t', 'class',
                     'compl', 'concept', 'const', 'consteval', 'constexpr', 'constinit', 'const_cast', 'continue', 'co_await',
                     'co_return', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
                     'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto', 'if', 'inline', 'int', 'long',
                     'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 'private',
                     'protected', 'public', 'reflexpr', 'register', 'reinterpret_cast', 'requires', 'return', 'short', 'signed',
                     'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch', 'synchronized', 'template',
                     'this', 'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned',
                     'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq'],
         'builtins': ['cout', 'cin', 'endl', 'string', 'vector', 'map', 'set', 'array', 'queue', 'stack', 'pair', 'algorithm', 'iostream', 'fstream', 'sstream', 'cmath', 'cstdlib', 'cstdio', 'ctime'], # Przykładowe popularne
         'patterns': [
             (r'\b[A-Za-z_][A-Za-z0-9_]*\s*\(', FORMAT_FUNCTION), # Funkcje (proste wykrycie)
             (r'\bclass\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS), # Klasy
             (r'\bstruct\s+([A-Za-z_][A-Za-z0-9_]*)\b', FORMAT_CLASS), # Struktury
             (r'\b\d+(\.\d*)?\b', FORMAT_NUMBERS), # Liczby
             (r'[+\-*/=<>!&|%^~?:]', FORMAT_OPERATOR), # Operatory
             (r'"".*?""', FORMAT_STRING), # Stringi w cudzysłowach podwójnych
             (r""'.*?'"", FORMAT_STRING), # Stringi w cudzysłowach pojedynczych (pojedyncze znaki)
             (r'//.*', FORMAT_COMMENT), # Komentarze liniowe
         ]
    },
    'ini': { # Nowe reguły dla INI
        'keywords': [], # Brak tradycyjnych słów kluczowych
        'builtins': [], # Brak typowych builtins
        'patterns': [
            (r'^\[.*?\]', FORMAT_SECTION), # Sekcje [section]
            (r'^[a-zA-Z0-9_-]+\s*=', FORMAT_PROPERTY), # Klucze property=
            (r';.*', FORMAT_COMMENT), # Komentarze po średniku
            (r'#.*', FORMAT_COMMENT), # Komentarze po krzyżyku
            (r'[+\-*/=<>!&|]', FORMAT_OPERATOR), # Operatory (np. =)
             (r'=\s*"".*?""', FORMAT_STRING), # ""value""
             (r""=\s*'.*?'"", FORMAT_STRING), # 'value'
             (r'=\s*[^;#""\'].*', FORMAT_STRING), # value without quotes or comments/sections
        ]
    },
    'json': { # Nowe reguły dla JSON
        'keywords': ['true', 'false', 'null'], # Literały JSON
        'builtins': [], # Brak typowych builtins
        'patterns': [
            (r'""(?:[^""\\]|\\.)*""\s*:', FORMAT_PROPERTY), # Klucze w cudzysłowach z następującym ':'
            (r'"".*?""', FORMAT_STRING), # Wartości stringów (muszą być po kluczach, żeby nie nadpisać klucza)
            (r'\b-?\d+(\.\d+)?([eE][+-]?\d+)?\b', FORMAT_NUMBERS), # Liczby
            (r'\{|\}|\[|\]|:|,', FORMAT_OPERATOR), # Nawiasy, dwukropek, przecinek
        ]
    }
}
class CodeSyntaxHighlighter(QSyntaxHighlighter):
    def __init__(self, parent: QTextDocument, language: str):
        super().__init__(parent)
        self._language = language.lower()
        self._rules = []
        lang_config = HIGHLIGHTING_RULES.get(self._language, {})
        keywords = lang_config.get('keywords', [])
        builtins = lang_config.get('builtins', [])
        patterns = lang_config.get('patterns', [])
        keyword_format = FORMAT_KEYWORD
        for keyword in keywords:
            pattern = r'\b' + re.escape(keyword) + r'\b' # Użyj re.escape dla słów kluczowych
            self._rules.append((re.compile(pattern), keyword_format))
        builtin_format = FORMAT_BUILTIN
        for builtin in builtins:
            pattern = r'\b' + re.escape(builtin) + r'\b'
            self._rules.append((re.compile(pattern), builtin_format))
        for pattern_str, format, *flags in patterns: # Opcjonalne flagi regex np. re.DOTALL
             try:
                 pattern = re.compile(pattern_str, *flags)
                 self._rules.append((pattern, format))
             except re.error as e:
                 print(f""Błąd kompilacji regex '{pattern_str}' dla języka {self._language}: {e}"", file=sys.stderr)
    def highlightBlock(self, text: str):
        """"""Główna metoda kolorująca blok tekstu (linię).""""""
        self.setFormat(0, len(text), FORMAT_DEFAULT)
        self.setCurrentBlockState(0) # Domyślny stan dla tego bloku
        block_comment_delimiters = []
        if self._language in ['javascript', 'css', 'c++']:
             block_comment_delimiters.append((""/*"", ""*/"", FORMAT_COMMENT))
        if self._language == 'html':
             pass # Rely on regex pattern for HTML comments
        comment_start_in_prev_block = (self.previousBlockState() == 1) # State 1 means inside /* ... */
        if comment_start_in_prev_block:
             end_delimiter_index = text.find(""*/"")
             if end_delimiter_index >= 0:
                  self.setFormat(0, end_delimiter_index + 2, FORMAT_COMMENT)
                  self.setCurrentBlockState(0) # Reset state
                  start_pos = end_delimiter_index + 2
             else:
                  self.setFormat(0, len(text), FORMAT_COMMENT)
                  self.setCurrentBlockState(1) # Keep state as inside comment
                  return # Entire line is a comment, no need to parse further
        else:
             start_pos = 0
        start_delimiter = ""/*""
        end_delimiter = ""*/""
        startIndex = text.find(start_delimiter, start_pos)
        while startIndex >= 0:
            endIndex = text.find(end_delimiter, startIndex)
            if endIndex >= 0:
                length = endIndex - startIndex + len(end_delimiter)
                self.setFormat(startIndex, startIndex + length, FORMAT_COMMENT)
                startIndex = text.find(start_delimiter, startIndex + length)
            else:
                self.setFormat(startIndex, len(text) - startIndex, FORMAT_COMMENT)
                self.setCurrentBlockState(1) # Set state to inside block comment
                break # No more pairs starting in this line
        for pattern, format in self._rules:
             if format == FORMAT_COMMENT and (pattern.pattern.startswith(re.escape('/*')) or pattern.pattern.startswith(re.escape('<!--'))):
                  continue
             if format == FORMAT_COMMENT and pattern.pattern.startswith('//') and self.currentBlockState() == 1:
                  continue
             for match in pattern.finditer(text):
                start, end = match.span()
                self.setFormat(start, end, format)
class CustomFileSystemModel(QFileSystemModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon_map = {
            '.py': 'fa5s.file-code',
            '.js': 'fa5s.file-code',
            '.json': 'fa5s.file-code',  # JSON też jako plik kodu
            '.html': 'fa5s.file-code',
            '.css': 'fa5s.file-code',
            '.ini': 'fa5s.file-alt',  # Plik konfiguracji
            '.txt': 'fa5s.file-alt',
            '.md': 'fa5s.file-alt',
            '.c': 'fa5s.file-code',
            '.cpp': 'fa5s.file-code',
            '.h': 'fa5s.file-code',
            '.hpp': 'fa5s.file-code',
        }
        self.folder_icon_name = 'fa5s.folder'
        self.default_file_icon_name = 'fa5s.file'
        self._has_qtawesome = qta is not None
    def rename(self, index, new_name):
        """"""Zmienia nazwę pliku lub folderu reprezentowanego przez podany index.""""""
        if not index.isValid():
            return False
        old_path = self.filePath(index)
        new_path = os.path.join(os.path.dirname(old_path), new_name)
        try:
            os.rename(old_path, new_path)
            self.refresh()  # Możliwe, że trzeba wymusić odświeżenie modelu
            return True
        except Exception as e:
            print(f""Błąd podczas zmiany nazwy: {e}"")
            return False
    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None
        if role == Qt.ItemDataRole.DecorationRole:
            file_info = self.fileInfo(index)
            if file_info.isDir():
                if self._has_qtawesome:
                    return qta.icon(self.folder_icon_name)
                else:
                    return super().data(index, role)
            elif file_info.isFile():
                extension = file_info.suffix().lower()
                dotted_extension = '.' + extension
                if dotted_extension in self.icon_map and self._has_qtawesome:
                    return qta.icon(self.icon_map[dotted_extension])
                else:
                    if self._has_qtawesome:
                        return qta.icon(self.default_file_icon_name)
                    else:
                        return super().data(index, role)
        return super().data(index, role)
    def refresh(self, *args):
        self.setRootPath(self.rootPath())
class NewProjectDialog(QDialog):
    def __init__(self, projects_dir, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Nowy projekt"")
        self.projects_dir = projects_dir
        self.setModal(True)
        layout = QFormLayout(self)
        self.name_edit = QLineEdit()
        layout.addRow(""Nazwa projektu:"", self.name_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setText(""Utwórz"")  # Zmieniamy tekst przycisku
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.name_edit.textChanged.connect(self._validate_name)
        self.name_edit.textChanged.emit(self.name_edit.text())  # Wywołaj walidację od razu
    def _validate_name(self, name):
        """"""Sprawdza poprawność nazwy projektu.""""""
        name = name.strip()
        is_empty = not name
        is_valid_chars = re.fullmatch(r'[a-zA-Z0-9_-]+', name) is not None or name == """"
        full_path = os.path.join(self.projects_dir, name)
        dir_exists = os.path.exists(full_path)
        enable_ok = not is_empty and is_valid_chars and not dir_exists
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_ok)
        if is_empty:
            self.name_edit.setToolTip(""Nazwa projektu nie może być pusta."")
        elif not is_valid_chars:
            self.name_edit.setToolTip(""Nazwa projektu może zawierać tylko litery, cyfry, podkreślenia i myślniki."")
        elif dir_exists:
            self.name_edit.setToolTip(f""Projekt o nazwie '{name}' już istnieje w:\n{self.projects_dir}"")
        else:
            self.name_edit.setToolTip(f""Katalog projektu zostanie utworzony w:\n{full_path}"")
        if not enable_ok and not is_empty:
            self.name_edit.setStyleSheet(""background-color: #ffe0e0;"")  # Jasnoczerwony
        else:
            self.name_edit.setStyleSheet("""")
    def get_project_name(self):
        return self.name_edit.text().strip()
    def get_project_path(self):
        return os.path.join(self.projects_dir, self.get_project_name())
class NewItemDialog(QDialog):
    def __init__(self, parent_dir, is_folder=False, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Nowy folder"" if is_folder else ""Nowy plik"")
        self.parent_dir = parent_dir
        self.is_folder = is_folder
        self.setModal(True)
        layout = QFormLayout(self)
        self.item_type_label = ""Nazwa folderu:"" if is_folder else ""Nazwa pliku:""
        self.name_edit = QLineEdit()
        layout.addRow(self.item_type_label, self.name_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
        self.name_edit.textChanged.connect(self._validate_name)
        self.name_edit.textChanged.emit(self.name_edit.text()) # Initial validation
    def _validate_name(self, name):
        """"""Sprawdza poprawność nazwy pliku/folderu.""""""
        name = name.strip()
        is_empty = not name
        illegal_chars_pattern = r'[<>:""/\\|?*\x00-\x1F]'
        is_valid_chars = re.search(illegal_chars_pattern, name) is None
        full_path = os.path.join(self.parent_dir, name)
        item_exists = os.path.exists(full_path)
        enable_create = not is_empty and is_valid_chars and not item_exists
        self.button_box.button(QDialogButtonBox.StandardButton.Ok).setEnabled(enable_create)
        if is_empty:
             self.name_edit.setToolTip(f""{self.item_type_label} nie może być pusta."")
        elif not is_valid_chars:
             self.name_edit.setToolTip(""Nazwa zawiera niedozwolone znaki."")
        elif item_exists:
             self.name_edit.setToolTip(f""Element o nazwie '{name}' już istnieje w:\n{self.parent_dir}"")
        else:
             self.name_edit.setToolTip("""")
        if not enable_create and not is_empty:
             self.name_edit.setStyleSheet(""background-color: #ffe0e0;"")
        else:
             self.name_edit.setStyleSheet("""")
    def get_item_name(self):
        return self.name_edit.text().strip()
class RenameItemDialog(QDialog):
    def __init__(self, current_path, parent=None):
        super().__init__(parent)
        self.current_path = current_path
        self.is_folder = os.path.isdir(current_path)
        old_name = os.path.basename(current_path)
        self.setWindowTitle(""Zmień nazwę"")
        layout = QVBoxLayout(self)
        self.label = QLabel(f""Nowa nazwa dla '{old_name}':"", self)
        layout.addWidget(self.label)
        self.line_edit = QLineEdit(old_name, self)
        layout.addWidget(self.line_edit)
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, self)
        layout.addWidget(self.button_box)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.line_edit.textChanged.connect(self._validate_name)
        self._validate_name(self.line_edit.text())  # Od razu sprawdź
    def _validate_name(self, name):
        name = name.strip()
        is_empty = not name
        illegal_chars_pattern = r'[<>:""/\\|?*\x00-\x1F]'
        is_valid_chars = re.search(illegal_chars_pattern, name) is None
        old_name = os.path.basename(self.current_path)
        is_same_name = name == old_name
        parent_dir = os.path.dirname(self.current_path)
        new_full_path = os.path.join(parent_dir, name)
        item_exists_at_new_path = os.path.exists(new_full_path)
        enable_ok = not is_empty and is_valid_chars and (is_same_name or not item_exists_at_new_path)
        self.button_box.button(QDialogButtonBox.Ok).setEnabled(enable_ok)
    def get_new_name(self):
        return self.line_edit.text().strip()
class SettingsDialog(QDialog):
    def __init__(self, settings, parent=None):
        super().__init__(parent)
        self.setWindowTitle(""Ustawienia"")
        self._settings = settings # Pracujemy na kopii
        self.setModal(True)
        layout = QFormLayout(self)
        self.theme_combo = QComboBox()
        self.theme_combo.addItems([""light"", ""dark""])
        self.theme_combo.setCurrentText(self._settings.get(""theme"", ""light""))
        layout.addRow(""Motyw:"", self.theme_combo)
        self.python_path_edit = QLineEdit(self._settings.get(""python_path"", """"))
        self.python_path_button = QPushButton(""Przeglądaj..."")
        python_path_layout = QHBoxLayout()
        python_path_layout.addWidget(self.python_path_edit)
        python_path_layout.addWidget(self.python_path_button)
        layout.addRow(""Ścieżka Python:"", python_path_layout)
        self.python_path_button.clicked.connect(lambda: self._browse_file(self.python_path_edit))
        self.node_path_edit = QLineEdit(self._settings.get(""node_path"", """"))
        self.node_path_button = QPushButton(""Przeglądaj..."")
        node_path_layout = QHBoxLayout()
        node_path_layout.addWidget(self.node_path_edit)
        node_path_layout.addWidget(self.node_path_button)
        layout.addRow(""Ścieżka Node.js:"", node_path_layout)
        self.node_path_button.clicked.connect(lambda: self._browse_file(self.node_path_edit))
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)
    def _browse_file(self, line_edit):
        """"""Otwiera dialog wyboru pliku dla pola QLineEdit.""""""
        start_dir = os.path.dirname(line_edit.text()) if os.path.dirname(line_edit.text()) else os.path.expanduser(""~"")
        if platform.system() == ""Windows"":
             filter_str = ""Wykonywalne pliki (*.exe *.bat *.cmd);;Wszystkie pliki (*)""
        else:
             filter_str = ""Wszystkie pliki (*)"" # Na Linux/macOS pliki wykonywalne nie mają konkretnego rozszerzenia
        file_path, _ = QFileDialog.getOpenFileName(self, ""Wybierz plik"", start_dir, filter_str)
        if file_path:
            line_edit.setText(os.path.normpath(file_path)) # Znormalizuj ścieżkę przed ustawieniem
    def get_settings(self):
        self._settings[""theme""] = self.theme_combo.currentText()
        self._settings[""python_path""] = self.python_path_edit.text().strip()
        self._settings[""node_path""] = self.node_path_edit.text().strip()
        return self._settings
    def layout(self):
        return super().layout()
class IDEWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.settings = {} # Słownik na ustawienia aplikacji
        self.recents = {""last_project_dir"": None, ""open_files"": []} # Słownik na historię
        self._load_app_state() # Wczytaj stan aplikacji (ustawienia i historię)
        self.setWindowTitle(""Proste IDE - Bez nazwy"")
        self.setGeometry(100, 100, 1200, 800)
        if qta:
             self.setWindowIcon(qta.icon('fa5s.code'))
        else:
             self.setWindowIcon(QIcon.fromTheme(""applications-development"")) # Przykładowa ikona systemowa
        self.current_project_dir = self.recents.get(""last_project_dir"")
        self.open_files = {} # {ścieżka_pliku: edytor_widget}
        self.base_editor_font = QFont(""Courier New"", 10) # Ustaw domyślną czcionkę początkową
        self._setup_ui()
        self._setup_menu()
        self._setup_toolbar()
        self._setup_status_bar()
        self._setup_connections()
        self._apply_theme(self.settings.get(""theme"", ""light""))
        self._apply_editor_font_size() # Zastosuj rozmiar czcionki do wszystkich otwartych edytorów (choć na start puste)
        self.process = QProcess(self) # Proces do uruchamiania kodu
        self.process.readyReadStandardOutput.connect(self._handle_stdout)
        self.process.readyReadStandardError.connect(self._handle_stderr)
        self.process.finished.connect(self._handle_process_finished)
        self.node_scripts = {} # Słownik na skrypty z package.json
        QTimer.singleShot(10, self._initial_setup)
    def _setup_ui(self):
        """"""Konfiguracja głównych elementów interfejsu.""""""
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(self.main_splitter)
        self.project_model = CustomFileSystemModel()  # Użyj niestandardowego modelu z ikonami
        self.project_model.setFilter(QDir.Filter.AllDirs | QDir.Filter.Files | QDir.Filter.NoDotAndDotDot)
        self.project_tree = QTreeView()
        self.project_tree.setModel(self.project_model)
        self.project_tree.setHeaderHidden(True)
        self.project_tree.hideColumn(1)
        self.project_tree.hideColumn(2)
        self.project_tree.hideColumn(3)
        self.project_tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.main_splitter.addWidget(self.project_tree)
        self.right_splitter = QSplitter(Qt.Orientation.Vertical)
        self.main_splitter.addWidget(self.right_splitter)
        self.tab_widget = QTabWidget()
        self.tab_widget.setTabsClosable(True)
        self.tab_widget.setMovable(True)
        self.right_splitter.addWidget(self.tab_widget)
        self.console_widget = QWidget()
        self.console_layout = QVBoxLayout(self.console_widget)
        self.console_layout.setContentsMargins(0, 0, 0, 0)
        self.console = QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setFont(self.base_editor_font)
        self.console_layout.addWidget(self.console, 1) # Rozciągnij pole konsoli
        self.console_input = QLineEdit()
        self.console_input.setPlaceholderText(""Wpisz polecenie..."")
        self.console_layout.addWidget(self.console_input, 0) # Nie rozciągaj pola wprowadzania
        self.console_buttons_layout = QHBoxLayout()
        self.console_buttons_layout.setContentsMargins(0, 0, 0, 0)
        self.console_buttons_layout.addStretch(1)
        self.clear_console_button = QPushButton(""Wyczyść konsolę"")
        self.console_buttons_layout.addWidget(self.clear_console_button)
        self.copy_console_button = QPushButton(""Skopiuj"")
        self.console_buttons_layout.addWidget(self.copy_console_button)
        self.console_layout.addLayout(self.console_buttons_layout)
        self.right_splitter.addWidget(self.console_widget)
        self.main_splitter.setSizes([200, 800])
        self.right_splitter.setSizes([600, 200])
        self.setCentralWidget(central_widget)
        self.action_toggle_tree = QAction(""Pokaż/Ukryj drzewko"", self)
        self.action_toggle_tree.setCheckable(True)
        self.action_toggle_tree.setChecked(True)
        self.action_toggle_tree.triggered.connect(self._toggle_tree_panel)
        self.action_toggle_console = QAction(""Pokaż/Ukryj konsolę"", self)
        self.action_toggle_console.setCheckable(True)
        self.action_toggle_console.setChecked(True)
        self.action_toggle_console.triggered.connect(self._toggle_console_panel)
        self._apply_view_settings()
    def _toggle_tree_panel(self, checked):
        self.main_splitter.widget(0).setVisible(checked)
    def _toggle_console_panel(self, checked):
        self.right_splitter.widget(1).setVisible(checked)
    def _setup_menu(self):
        """"""Konfiguracja paska menu.""""""
        menu_bar = self.menuBar()
        file_menu = menu_bar.addMenu(""&Plik"") # & dodaje skrót klawiszowy Alt+P
        self.action_new_project = QAction(qta.icon('fa5s.folder-plus') if qta else QIcon(), ""&Nowy projekt..."", self)
        self.action_new_project.triggered.connect(self._new_project)
        file_menu.addAction(self.action_new_project)
        self.action_open_folder = QAction(qta.icon('fa5s.folder-open') if qta else QIcon(), ""Otwórz &folder projektu..."", self)
        self.action_open_folder.triggered.connect(self._open_project_folder) # Użyj bezpośredniego połączenia
        file_menu.addAction(self.action_open_folder)
        self.action_open_file = QAction(qta.icon('fa5s.file-code') if qta else QIcon(), ""Otwórz &plik..."", self)
        self.action_open_file.triggered.connect(self._open_file_dialog)
        file_menu.addAction(self.action_open_file)
        file_menu.addSeparator()
        self.recent_files_menu = QMenu(""Ostatnio otwierane"", self)
        file_menu.addMenu(self.recent_files_menu)
        file_menu.addSeparator()
        self.action_save = QAction(qta.icon('fa5s.save') if qta else QIcon(), ""&Zapisz"", self)
        self.action_save.setShortcut(QKeySequence.StandardKey.Save)
        self.action_save.triggered.connect(self._save_current_file)
        file_menu.addAction(self.action_save)
        self.action_save_as = QAction(qta.icon('fa5s.file-export') if qta else QIcon(), ""Zapisz &jako..."", self)
        self.action_save_as.setShortcut(QKeySequence.StandardKey.SaveAs)
        self.action_save_as.triggered.connect(self._save_current_file_as)
        file_menu.addAction(self.action_save_as)
        self.action_save_all = QAction(qta.icon('fa5s.save') if qta else QIcon(), ""Zapisz wszys&tko"", self)
        self.action_save_all.setShortcut(QKeySequence(""Ctrl+Shift+S"")) # Standardowy skrót
        self.action_save_all.triggered.connect(self._save_all_files)
        file_menu.addAction(self.action_save_all)
        file_menu.addSeparator()
        self.action_close_file = QAction(qta.icon('fa5s.window-close') if qta else QIcon(), ""Zamknij ak&tualny plik"", self)
        self.action_close_file.triggered.connect(self._close_current_tab)
        file_menu.addAction(self.action_close_file)
        file_menu.addSeparator()
        self.action_exit = QAction(qta.icon('fa5s.door-open') if qta else QIcon(), ""&Zakończ"", self)
        self.action_exit.setShortcut(QKeySequence.StandardKey.Quit)
        self.action_exit.triggered.connect(self.close)
        file_menu.addAction(self.action_exit)
        edit_menu = menu_bar.addMenu(""&Edycja"")
        view_menu = menu_bar.addMenu(""&Widok"")
        self.action_toggle_tree = QAction(qta.icon('fa5s.sitemap') if qta else QIcon(), ""Pokaż &drzewko plików"", self)
        self.action_toggle_tree.setCheckable(True)
        self.action_toggle_tree.setChecked(self.settings.get(""show_tree"", True)) # Ustaw stan z ustawień
        self.action_toggle_tree.triggered.connect(self._toggle_tree_view)
        view_menu.addAction(self.action_toggle_tree)
        self.action_toggle_console = QAction(qta.icon('fa5s.terminal') if qta else QIcon(), ""Pokaż &konsolę"", self)
        self.action_toggle_console.setCheckable(True)
        self.action_toggle_console.setChecked(self.settings.get(""show_console"", True)) # Ustaw stan z ustawień
        self.action_toggle_console.triggered.connect(self._toggle_console)
        view_menu.addAction(self.action_toggle_console)
        search_menu = menu_bar.addMenu(""&Wyszukaj"")
        self.action_find = QAction(qta.icon('fa5s.search') if qta else QIcon(), ""&Znajdź..."", self)
        self.action_find.setShortcut(QKeySequence.StandardKey.Find)
        self.action_find.triggered.connect(self._show_find_bar)
        search_menu.addAction(self.action_find)
        run_menu = menu_bar.addMenu(""&Uruchom"")
        self.action_run_file = QAction(qta.icon('fa5s.play') if qta else QIcon(), ""&Uruchom aktualny plik"", self)
        self.action_run_file.setShortcut(QKeySequence(""F5"")) # Przykładowy skrót
        self.action_run_file.triggered.connect(self._run_current_file)
        run_menu.addAction(self.action_run_file)
        tools_menu = menu_bar.addMenu(""&Narzędzia"")
        self.action_settings = QAction(qta.icon('fa5s.cog') if qta else QIcon(), ""&Ustawienia..."", self)
        self.action_settings.triggered.connect(self._show_settings_dialog)
        tools_menu.addAction(self.action_settings)
        help_menu = menu_bar.addMenu(""&Pomoc"")
        self.action_about = QAction(qta.icon('fa5s.info-circle') if qta else QIcon(), ""&O programie..."", self)
        self.action_about.triggered.connect(self._show_about_dialog)
        help_menu.addAction(self.action_about)
    def _setup_toolbar(self):
        """"""Konfiguracja paska narzędzi.""""""
        toolbar = self.addToolBar(""Główne narzędzia"")
        toolbar.setMovable(False) # Nie można go przesuwać
        toolbar.setIconSize(QSize(16, 16)) # Rozmiar ikon
        toolbar.addAction(self.action_new_project) # Nowy projekt
        toolbar.addAction(self.action_open_folder) # Otwórz folder
        toolbar.addAction(self.action_open_file) # Otwórz plik
        toolbar.addSeparator()
        toolbar.addAction(self.action_save) # Zapisz
        toolbar.addAction(self.action_save_all) # Zapisz wszystko
        toolbar.addSeparator()
        self.run_toolbutton = QToolButton(self)
        self.run_toolbutton.setDefaultAction(self.action_run_file)
        self.run_toolbutton.setPopupMode(QToolButton.ToolButtonPopupMode.MenuButtonPopup)
        toolbar.addWidget(self.run_toolbutton) # Dodaj QToolButton do toolbara
        toolbar.addSeparator()
        self.search_input = QLineEdit(self)
        self.search_input.setPlaceholderText(""Szukaj w pliku..."")
        self.search_input.setClearButtonEnabled(True) # Przycisk czyszczenia
        self.search_input.returnPressed.connect(lambda: self._find_text(self.search_input.text(), 'next')) # Szukaj po wciśnięciu Enter
        self.find_next_button = QPushButton(""Znajdź dalej"")
        self.find_next_button.clicked.connect(lambda: self._find_text(self.search_input.text(), 'next'))
        self.find_prev_button = QPushButton(""Znajdź poprzedni"")
        self.find_prev_button.clicked.connect(lambda: self._find_text(self.search_input.text(), 'previous'))
        toolbar.addWidget(self.search_input)
        toolbar.addWidget(self.find_next_button)
        toolbar.addWidget(self.find_prev_button)
        self.search_input.setVisible(False)
        self.find_next_button.setVisible(False)
        self.find_prev_button.setVisible(False)
    def _setup_status_bar(self):
        """"""Konfiguracja paska stanu.""""""
        self.statusBar().showMessage(""Gotowy."")
    def _setup_connections(self):
        """"""Połączenie sygnałów ze slotami.""""""
        self.project_tree.doubleClicked.connect(self._handle_tree_item_double_click)
        self.tab_widget.tabCloseRequested.connect(self._close_tab_by_index)
        self.tab_widget.currentChanged.connect(self._handle_tab_change)
        self.project_tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu) # Upewnij się, że policy jest ustawione
        self.project_tree.customContextMenuRequested.connect(self._show_project_tree_context_menu)
        self.clear_console_button.clicked.connect(self.console.clear)
        self.copy_console_button.clicked.connect(self._copy_console)
        self.console_input.returnPressed.connect(self._run_console_command)
    def _initial_setup(self):
        """"""Wstępna konfiguracja po uruchomieniu, w tym ładowanie ostatniego stanu.""""""
        initial_dir = self.recents.get(""last_project_dir"")
        if not initial_dir or not os.path.isdir(initial_dir):
             initial_dir = PROJECTS_DIR # Użyj domyślnego katalogu projects
             os.makedirs(PROJECTS_DIR, exist_ok=True)
        if os.path.isdir(initial_dir):
             self._open_project_folder(initial_dir)
        else:
             self.statusBar().showMessage(f""Brak domyślnego katalogu projektu. Otwórz folder ręcznie lub utwórz nowy."")
             self.project_model.setRootPath("""") # Brak roota w drzewku
             self.current_project_dir = None # Resetuj current_project_dir
             self._update_run_button_menu()
        recent_files = self.recents.get(""open_files"", [])
        QTimer.singleShot(200, lambda: self._reopen_files(recent_files)) # Krótsze opóźnienie
        self._update_recent_files_menu() # Uaktualnij menu ostatnio otwieranych
    def _load_app_state(self):
        """"""Wczytuje ustawienia i historię z plików JSON.""""""
        try:
            if os.path.exists(SETTINGS_FILE):
                with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                    loaded_settings = json.load(f)
                    self.settings = {
                        ""theme"": loaded_settings.get(""theme"", ""light""),
                        ""python_path"": loaded_settings.get(""python_path"", """"),
                        ""node_path"": loaded_settings.get(""node_path"", """"),
                        ""show_tree"": loaded_settings.get(""show_tree"", True),
                        ""show_console"": loaded_settings.get(""show_console"", True),
                        ""editor_font_size"": loaded_settings.get(""editor_font_size"", 10)
                    }
            else:
                self.settings = {
                    ""theme"": ""light"",
                    ""python_path"": """",
                    ""node_path"": """",
                    ""show_tree"": True,
                    ""show_console"": True,
                    ""editor_font_size"": 10
                }
            if os.path.exists(RECENTS_FILE):
                 with open(RECENTS_FILE, 'r', encoding='utf-8') as f:
                     loaded_recents = json.load(f)
                     self.recents = {
                         ""last_project_dir"": loaded_recents.get(""last_project_dir""),
                         ""open_files"": loaded_recents.get(""open_files"", [])
                     }
            else:
                 self.recents = {""last_project_dir"": None, ""open_files"": []}
        except (json.JSONDecodeError, Exception) as e:
            print(f""Błąd podczas wczytywania stanu aplikacji: {e}"", file=sys.stderr)
            self.settings = {
                ""theme"": ""light"",
                ""python_path"": """",
                ""node_path"": """",
                ""show_tree"": True,
                ""show_console"": True,
                ""editor_font_size"": 10
            }
            self.recents = {""last_project_dir"": None, ""open_files"": []}
    def _save_app_state(self):
        """"""Zapisuje ustawienia i historię do plików JSON.""""""
        try:
            self.recents[""open_files""] = list(self.open_files.keys())
            if self.current_project_dir and os.path.isdir(self.current_project_dir):
                 self.recents[""last_project_dir""] = os.path.normpath(self.current_project_dir) # Znormalizuj przed zapisem
            else:
                 self.recents[""last_project_dir""] = None # Nie zapisuj jeśli nie ma folderu
            with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.settings, f, indent=4)
            with open(RECENTS_FILE, 'w', encoding='utf-8') as f:
                 normalized_open_files = [os.path.normpath(p) for p in self.recents[""open_files""]]
                 unique_open_files = []
                 for p in normalized_open_files:
                     if p not in unique_open_files:
                         unique_open_files.append(p)
                 self.recents[""open_files""] = unique_open_files[:20] # Ostatnie 20 unikalnych
                 json.dump(self.recents, f, indent=4)
        except Exception as e:
            print(f""Błąd podczas zapisu stanu aplikacji: {e}"", file=sys.stderr)
    def closeEvent(self, event):
        """"""Obsługa zdarzenia zamykania okna.""""""
        unsaved_files = [path for path, editor in self.open_files.items() if editor.document().isModified()]
        if unsaved_files:
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Warning)
            msg_box.setWindowTitle(""Niezapisane zmiany"")
            msg_box.setText(f""Masz niezapisane zmiany w {len(unsaved_files)} plikach.\nCzy chcesz zapisać przed zamknięciem?"")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Save)
            reply = msg_box.exec()
            if reply == QMessageBox.StandardButton.Save:
                if self._save_all_files():
                     self._save_app_state() # Zapisz stan po pomyślnym zapisie plików
                     event.accept() # Akceptuj zamknięcie
                else:
                     event.ignore() # Nie zamykaj, jeśli zapis się nie udał
            elif reply == QMessageBox.StandardButton.Discard:
                for i in range(self.tab_widget.count() - 1, -1, -1):
                     widget = self.tab_widget.widget(i)
                     if hasattr(widget, 'document'):
                          widget.document().setModified(False)
                     self._close_tab_by_index(i) # Ta metoda usunie z open_files i recents
                self._save_app_state() # Zapisz stan (lista otwartych plików będzie aktualna)
                event.accept() # Akceptuj zamknięcie
            else:
                event.ignore() # Ignoruj zamknięcie
        else:
            self._save_app_state() # Zapisz stan, bo nie ma niezapisanych plików
            event.accept() # Akceptuj zamknięcie
    def _new_project(self):
        """"""Tworzy nowy katalog projektu.""""""
        dialog = NewProjectDialog(PROJECTS_DIR, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            project_name = dialog.get_project_name()
            project_path = dialog.get_project_path()
            try:
                if os.path.exists(project_path):
                    QMessageBox.warning(self, ""Projekt już istnieje"", f""Projekt o nazwie '{project_name}' już istnieje."")
                    return
                os.makedirs(project_path)
                self.statusBar().showMessage(f""Utworzono nowy projekt: {project_name}"")
                self._open_project_folder(project_path)
            except OSError as e:
                QMessageBox.critical(self, ""Błąd tworzenia projektu"", f""Nie można utworzyć katalogu projektu:\n{e}"")
                self.statusBar().showMessage(""Błąd tworzenia projektu."")
            except Exception as e:
                 QMessageBox.critical(self, ""Nieoczekiwany błąd"", f""Wystąpił nieoczekiwany błąd:\n{e}"")
                 self.statusBar().showMessage(""Nieoczekiwany błąd."")
    def _open_project_folder(self, path=None):
        """"""Otwiera okno dialogowe wyboru folderu projektu lub otwiera wskazany folder.""""""
        if path is None:
            start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
            dialog_path = QFileDialog.getExistingDirectory(self, ""Otwórz folder projektu"", start_path)
            if not dialog_path:
                return
            path = dialog_path
        path = os.path.normpath(path)
        if not os.path.isdir(path):
            QMessageBox.critical(self, ""Błąd"", f""Wybrana ścieżka nie jest katalogiem lub nie istnieje:\n{path}"")
            self.statusBar().showMessage(f""Błąd: Nie można otworzyć folderu: {path}"")
            return
        if self.current_project_dir and self.current_project_dir != path:
             unsaved_files_count = sum(1 for editor in self.open_files.values() if editor.document().isModified())
             if unsaved_files_count > 0:
                  reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                               f""Obecny projekt ma {unsaved_files_count} niezapisanych plików.\n""
                                               ""Czy chcesz zapisać zmiany przed otwarciem nowego folderu?"",
                                               QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                  if reply == QMessageBox.StandardButton.Cancel:
                       self.statusBar().showMessage(""Otwieranie folderu anulowane."")
                       return # Anuluj operację
                  if reply == QMessageBox.StandardButton.Save:
                       if not self._save_all_files(): # Ta metoda obsłuży Save As dla nowych plików
                            self.statusBar().showMessage(""Otwieranie folderu anulowane (błąd zapisu)."")
                            return # Anuluj operację
             self._close_all_files() # Ta metoda już nie pyta o zapis
        self.current_project_dir = path
        self.project_model.setRootPath(path)
        root_index = self.project_model.index(path)
        if not root_index.isValid():
             QMessageBox.critical(self, ""Błąd"", f""Nie można ustawić katalogu głównego drzewka dla ścieżki:\n{path}\n""
                                                 ""Sprawdź uprawnienia lub czy ścieżka jest dostępna dla systemu plików."")
             self.statusBar().showMessage(f""Błąd ustawienia katalogu głównego: {path}"")
             self.project_tree.setRootIndex(self.project_model.index("""")) # Wyczyść roota
             self.current_project_dir = None # Resetuj current_project_dir
             self.recents[""open_files""] = [p for p in self.recents[""open_files""] if not os.path.normpath(p).startswith(os.path.normpath(path) + os.sep)]
             self._update_recent_files_menu()
             self._save_app_state() # Zapisz zaktualizowany stan
             self._update_run_button_menu() # Uaktualnij menu uruchamiania (brak projektu)
             return
        self.project_tree.setRootIndex(root_index)
        self.setWindowTitle(f""Proste IDE - {os.path.basename(path)}"")
        self.statusBar().showMessage(f""Otwarto folder: {path}"")
        self._check_package_json(path)
        self.recents[""last_project_dir""] = path
        self._save_app_state() # Zapisz, żeby zapamiętać ostatni folder
    def _close_all_files(self):
         """"""Zamyka wszystkie otwarte zakładki edytora bez pytania o zapis.""""""
         for file_path in list(self.open_files.keys()):
              editor_widget = self.open_files.get(file_path)
              if editor_widget:
                   tab_index = self.tab_widget.indexOf(editor_widget)
                   if tab_index != -1:
                        if hasattr(editor_widget, 'document'):
                            editor_widget.document().setModified(False)
                        self.tab_widget.removeTab(tab_index)
                        if file_path in self.open_files:
                             del self.open_files[file_path]
         self.recents[""open_files""] = [] # Wyczyść listę otwartych plików
         self._update_recent_files_menu() # Uaktualnij menu
    def _open_file_dialog(self):
        """"""Otwiera okno dialogowe wyboru pliku i otwiera go w edytorze.""""""
        start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
        file_path, _ = QFileDialog.getOpenFileName(self, ""Otwórz plik"", start_path, ""Wszystkie pliki (*);;Pliki Pythona (*.py);;Pliki JavaScript (*.js);;Pliki HTML (*.html);;Pliki CSS (*.css);;Pliki C++ (*.c *.cpp *.h *.hpp);;Pliki INI (*.ini);;Pliki JSON (*.json)"")
        if file_path:
            self._open_file(file_path)
    def _open_file(self, file_path):
        """"""Otwiera wskazany plik w nowej zakładce edytora.""""""
        file_path = os.path.normpath(file_path)
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            self.statusBar().showMessage(f""Błąd: Plik nie istnieje lub nie jest plikiem: {file_path}"")
            if file_path in self.recents[""open_files""]:
                 self.recents[""open_files""].remove(file_path)
                 self._update_recent_files_menu() # Uaktualnij menu
                 self._save_app_state() # Zapisz stan
            return
        if file_path in self.open_files:
            index = -1
            for i in range(self.tab_widget.count()):
                 widget = self.tab_widget.widget(i)
                 if self.open_files.get(file_path) is widget:
                      index = i
                      break
            if index != -1:
                self.tab_widget.setCurrentIndex(index)
                self.statusBar().showMessage(f""Plik {os.path.basename(file_path)} jest już otwarty."")
                if file_path in self.recents[""open_files""]:
                     self.recents[""open_files""].remove(file_path)
                     self.recents[""open_files""].insert(0, file_path)
                     self._update_recent_files_menu()
                     self._save_app_state()
                return
            else:
                print(f""Warning: File {file_path} found in open_files but not in tab widget."", file=sys.stderr)
        try:
            content = """"
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except UnicodeDecodeError:
                 try:
                      with open(file_path, 'r', encoding='latin-1') as f:
                          content = f.read()
                 except Exception:
                      with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                          content = f.read()
        except Exception as e:
            QMessageBox.critical(self, ""Błąd otwarcia pliku"", f""Nie można odczytać pliku {os.path.basename(file_path)}:\n{e}"")
            self.statusBar().showMessage(f""Błąd otwarcia pliku: {os.path.basename(file_path)}"")
            return
        editor = QPlainTextEdit()
        editor.setPlainText(content)
        editor.setFont(self.base_editor_font)
        editor.document().setModified(False) # Nowo otwarty plik nie jest zmodyfikowany
        editor.document().modificationChanged.connect(self._handle_modification_changed)
        language = self._get_language_from_path(file_path)
        highlighter = CodeSyntaxHighlighter(editor.document(), language) # Przypisz highlighter do dokumentu edytora
        setattr(editor.document(), '_syntax_highlighter', highlighter)
        tab_index = self.tab_widget.addTab(editor, os.path.basename(file_path))
        self.tab_widget.setCurrentIndex(tab_index)
        self.open_files[file_path] = editor # Zapisz odwołanie do edytora
        self.statusBar().showMessage(f""Otwarto plik: {file_path}"")
        if file_path in self.recents[""open_files""]:
            self.recents[""open_files""].remove(file_path) # Usuń stary wpis, żeby był na górze
        self.recents[""open_files""].insert(0, file_path) # Dodaj na początek
        self._update_recent_files_menu() # Uaktualnij menu
        self._save_app_state() # Zapisz stan
    def _reopen_files(self, file_list):
        """"""Ponownie otwiera listę plików po uruchomieniu programu.""""""
        files_to_reopen = list(file_list) # Tworzymy kopię
        valid_files = [f for f in files_to_reopen if os.path.exists(f) and os.path.isfile(f)]
        self.recents[""open_files""] = valid_files
        self._update_recent_files_menu() # Uaktualnij menu
        for file_path in valid_files:
            QTimer.singleShot(0, lambda path=file_path: self._open_file(path))
        invalid_files = [f for f in files_to_reopen if f not in valid_files]
        if invalid_files:
            msg = ""Nie można ponownie otworzyć następujących plików (nie znaleziono):\n"" + ""\n"".join(invalid_files)
            QMessageBox.warning(self, ""Błąd otwarcia plików"", msg)
    def _update_recent_files_menu(self):
        """"""Uaktualnia listę plików w menu 'Ostatnio otwierane'.""""""
        self.recent_files_menu.clear()
        recent_items_to_show = list(self.recents.get(""open_files"", []))[:15] # Pokaż max 15 (praca na kopii)
        if not recent_items_to_show:
            self.recent_files_menu.addAction(""Brak ostatnio otwieranych plików"").setEnabled(False)
            return
        actions_to_add = []
        cleaned_recent_files = [] # Zbuduj nową listę poprawnych ścieżek
        for file_path in recent_items_to_show:
            if os.path.exists(file_path) and os.path.isfile(file_path):
                 cleaned_recent_files.append(file_path) # Dodaj do listy czystej
                 menu_text = os.path.basename(file_path) # Pokaż tylko nazwę pliku
                 action = QAction(menu_text, self)
                 action.setData(file_path) # Zapisz pełną ścieżkę w danych akcji
                 action.triggered.connect(lambda checked, path=file_path: self._open_file(path))
                 actions_to_add.append(action)
        all_existing_recent_files = [p for p in self.recents.get(""open_files"", []) if os.path.exists(p) and os.path.isfile(p)]
        unique_recent_files = []
        for p in all_existing_recent_files:
            if p not in unique_recent_files:
                unique_recent_files.append(p)
        self.recents[""open_files""] = unique_recent_files[:20]
        self.recent_files_menu.clear() # Wyczyść ponownie
        if not self.recents[""open_files""]:
             self.recent_files_menu.addAction(""Brak ostatnio otwieranych plików"").setEnabled(False)
        else:
             for file_path in self.recents[""open_files""]:
                  menu_text = os.path.basename(file_path)
                  action = QAction(menu_text, self)
                  action.setData(file_path)
                  action.triggered.connect(lambda checked, path=file_path: self._open_file(path))
                  self.recent_files_menu.addAction(action)
    def _get_language_from_path(self, file_path):
         """"""Zwraca nazwę języka na podstawie rozszerzenia pliku.""""""
         if not file_path:
              return 'plaintext'
         file_info = QFileInfo(file_path)
         extension = file_info.suffix().lower()
         if extension == 'py':
             return 'python'
         elif extension == 'js':
             return 'javascript'
         elif extension == 'html':
             return 'html'
         elif extension == 'css':
             return 'css'
         elif extension in ['c', 'cpp', 'h', 'hpp']:
             return 'c++'
         elif extension == 'ini':
             return 'ini'
         elif extension == 'json':
             return 'json'
         else:
             return 'plaintext' # Bez kolorowania
    def _handle_tree_item_double_click(self, index):
        """"""Obsługa podwójnego kliknięcia w drzewku projektu.""""""
        file_path = self.project_model.filePath(index)
        if os.path.isfile(file_path):
            self._open_file(file_path)
        elif os.path.isdir(file_path):
             if self.project_tree.isExpanded(index):
                 self.project_tree.collapse(index)
             else:
                 self.project_tree.expand(index)
    def _show_project_tree_context_menu(self, point):
        """"""Wyświetla menu kontekstowe dla drzewka projektu.""""""
        index = self.project_tree.indexAt(point)
        menu = QMenu(self)
        create_file_action = QAction(qta.icon('fa5s.file-medical') if qta else QIcon(), ""Nowy plik..."", self)
        create_folder_action = QAction(qta.icon('fa5s.folder-plus') if qta else QIcon(), ""Nowy folder..."", self)
        select_all_action = QAction(""Zaznacz wszystko"", self)
        select_all_action.triggered.connect(self.project_tree.selectAll)
        if index.isValid():
            file_path = self.project_model.filePath(index)
            file_info = self.project_model.fileInfo(index)
            is_root_model = self.project_model.rootPath() == file_path
            if not is_root_model: # Nie usuwaj/zmieniaj nazwy roota projektu
                 rename_action = QAction(qta.icon('fa5s.edit') if qta else QIcon(), ""Zmień nazwę..."", self)
                 delete_action = QAction(qta.icon('fa5s.trash') if qta else QIcon(), ""Usuń"", self)
                 rename_action.triggered.connect(lambda: self._rename_item(index))
                 delete_action.triggered.connect(lambda: self._delete_item(index))
                 if file_info.isDir():
                     menu.addAction(create_file_action) # Nowy plik w folderze
                     menu.addAction(create_folder_action) # Nowy folder w folderze
                     menu.addSeparator()
                     menu.addAction(rename_action)
                     menu.addAction(delete_action)
                     menu.addSeparator()
                     open_in_os_action = QAction(qta.icon('fa5s.external-link-alt') if qta else QIcon(), ""Otwórz w eksploratorze"", self) # Windows
                     if platform.system() == ""Darwin"": open_in_os_action.setText(""Otwórz w Finderze"") # macOS
                     elif platform.system() == ""Linux"": open_in_os_action.setText(""Otwórz w menedżerze plików"") # Linux
                     open_in_os_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl.fromLocalFile(file_path)))
                     menu.addAction(open_in_os_action)
                     create_file_action.triggered.connect(lambda: self._create_new_item(file_path, is_folder=False))
                     create_folder_action.triggered.connect(lambda: self._create_new_item(file_path, is_folder=True))
                 elif file_info.isFile():
                     open_action = QAction(qta.icon('fa5s.file') if qta else QIcon(), ""Otwórz"", self) # Mimo podwójnego kliknięcia
                     open_action.triggered.connect(lambda: self._open_file(file_path))
                     duplicate_action = QAction(qta.icon('fa5s.copy') if qta else QIcon(), ""Duplikuj"", self)
                     duplicate_action.triggered.connect(lambda: self._duplicate_file(index))
                     copy_path_action = QAction(qta.icon('fa5s.link') if qta else QIcon(), ""Kopiuj ścieżkę"", self)
                     copy_path_action.triggered.connect(lambda: QApplication.clipboard().setText(file_path))
                     menu.addAction(open_action)
                     menu.addSeparator()
                     menu.addAction(rename_action)
                     menu.addAction(delete_action)
                     menu.addAction(duplicate_action)
                     menu.addSeparator()
                     menu.addAction(copy_path_action)
                     menu.addSeparator()
                     open_containing_folder_action = QAction(qta.icon('fa5s.folder-open') if qta else QIcon(), ""Pokaż w eksploratorze"", self) # Windows
                     if platform.system() == ""Darwin"": open_containing_folder_action.setText(""Pokaż w Finderze"") # macOS
                     elif platform.system() == ""Linux"": open_containing_folder_action.setText(""Pokaż w menedżerze plików"") # Linux
                     open_containing_folder_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl.fromLocalFile(os.path.dirname(file_path))))
                     menu.addAction(open_containing_folder_action)
            else: # Kliknięto na root folderu projektu
                 menu.addAction(create_file_action) # Nowy plik w roocie
                 menu.addAction(create_folder_action) # Nowy folder w roocie
                 menu.addSeparator()
                 open_in_os_action = QAction(qta.icon('fa5s.external-link-alt') if qta else QIcon(), ""Otwórz w eksploratorze"", self) # Windows
                 if platform.system() == ""Darwin"": open_in_os_action.setText(""Otwórz w Finderze"") # macOS
                 elif platform.system() == ""Linux"": open_in_os_action.setText(""Otwórz w menedżerze plików"") # Linux
                 open_in_os_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl.fromLocalFile(file_path)))
                 menu.addAction(open_in_os_action)
                 create_file_action.triggered.connect(lambda: self._create_new_item(file_path, is_folder=False))
                 create_folder_action.triggered.connect(lambda: self._create_new_item(file_path, is_folder=True))
        else: # Kliknięto na puste miejsce w drzewku
            if self.current_project_dir and os.path.isdir(self.current_project_dir):
                menu.addAction(create_file_action) # Nowy plik w roocie projektu
                menu.addAction(create_folder_action) # Nowy folder w roocie projektu
                create_file_action.triggered.connect(lambda: self._create_new_item(self.current_project_dir, is_folder=False))
                create_folder_action.triggered.connect(lambda: self._create_new_item(self.current_project_dir, is_folder=True))
                menu.addSeparator()
            menu.addAction(select_all_action)
        if menu.actions(): # Pokaż menu tylko jeśli są jakieś akcje
            menu.exec(self.project_tree.mapToGlobal(point))
    def _create_new_item(self, parent_dir, is_folder):
         """"""Tworzy nowy plik lub folder w podanym katalogu nadrzędnym.""""""
         if not os.path.isdir(parent_dir):
              QMessageBox.warning(self, ""Błąd tworzenia"", f""Katalog nadrzędny nie istnieje lub nie jest katalogiem:\n{parent_dir}"")
              self.statusBar().showMessage(""Błąd tworzenia nowego elementu."")
              return
         dialog = NewItemDialog(parent_dir, is_folder, self)
         if dialog.exec() == QDialog.DialogCode.Accepted:
             item_name = dialog.get_item_name()
             if not item_name: return # Powinno być obsłużone w dialogu, ale zabezpieczenie
             full_path = os.path.join(parent_dir, item_name)
             parent_index = self.project_model.index(parent_dir)
             if not parent_index.isValid():
                  try:
                       if is_folder:
                           os.makedirs(full_path)
                           self.statusBar().showMessage(f""Utworzono folder: {item_name}"")
                       else:
                           with open(full_path, 'w') as f: pass # Utwórz pusty plik
                           self.statusBar().showMessage(f""Utworzono plik: {item_name}"")
                       root_path = self.project_model.rootPath()
                       if root_path and os.path.isdir(root_path):
                            self.project_model.refresh(self.project_model.index(root_path))
                  except OSError as e:
                       QMessageBox.critical(self, ""Błąd tworzenia"", f""Nie można utworzyć {'folderu' if is_folder else 'pliku'}:\n{e}"")
                       self.statusBar().showMessage(f""Błąd tworzenia {'folderu' if is_folder else 'pliku'}."")
                  except Exception as e:
                      QMessageBox.critical(self, ""Nieoczekiwany błąd"", f""Wystąpił nieoczekiwany błąd:\n{e}"")
                      self.statusBar().showMessage(""Nieoczekiwany błąd."")
                  return
             success = False
             if is_folder:
                 new_index = self.project_model.mkdir(parent_index, item_name)
                 if new_index.isValid():
                      self.statusBar().showMessage(f""Utworzono folder: {item_name}"")
                      success = True
                      self.project_tree.expand(new_index) # Rozwiń folder, żeby było widać nowy element
             else:
                  try:
                       with open(full_path, 'w') as f: pass # Utwórz pusty plik
                       self.statusBar().showMessage(f""Utworzono plik: {item_name}"")
                       self.project_model.refresh(parent_index)
                       success = True
                  except OSError as e:
                       QMessageBox.critical(self, ""Błąd tworzenia"", f""Nie można utworzyć pliku:\n{e}"")
                       self.statusBar().showMessage(""Błąd tworzenia pliku."")
                  except Exception as e:
                      QMessageBox.critical(self, ""Nieoczekiwany błąd"", f""Wystąpił nieoczekiwany błąd:\n{e}"")
                      self.statusBar().showMessage(""Nieoczekiwany błąd."")
    def _rename_item(self, index):
         """"""Zmienia nazwę pliku lub folderu.""""""
         if not index.isValid(): return
         old_path = self.project_model.filePath(index)
         old_name = os.path.basename(old_path)
         parent_dir = os.path.dirname(old_path)
         if old_path == self.project_model.rootPath() or old_path == self.project_model.filePath(self.project_model.index("""")):
              QMessageBox.warning(self, ""Błąd zmiany nazwy"", ""Nie można zmienić nazwy katalogu głównego."")
              self.statusBar().showMessage(""Nie można zmienić nazwy katalogu głównego."")
              return
         dialog = RenameItemDialog(old_path, self)
         if dialog.exec() == QDialog.DialogCode.Accepted:
             new_name = dialog.get_new_name()
             if not new_name or new_name == old_name:
                  self.statusBar().showMessage(""Zmiana nazwy anulowana lub nowa nazwa jest taka sama."")
                  return # Brak zmiany lub pusta nazwa (powinno być obsłużone w dialogu)
             new_path = os.path.join(parent_dir, new_name)
             open_files_to_close = []
             if os.path.isfile(old_path):
                  if old_path in self.open_files:
                       open_files_to_close.append(old_path)
             elif os.path.isdir(old_path):
                  normalized_folder_path = os.path.normpath(old_path) + os.sep
                  for open_file_path in self.open_files.keys():
                       if os.path.normpath(open_file_path).startswith(normalized_folder_path):
                            open_files_to_close.append(open_file_path)
             if open_files_to_close:
                  open_file_names = [os.path.basename(p) for p in open_files_to_close]
                  msg = f""{{'Plik' if os.path.isfile(old_path) else 'Folder'}} '{old_name}' zawiera otwarte pliki, które zostaną zamknięte i ponownie otwarte po zmianie nazwy:\\n"" + ""\\n"".join(open_file_names)
                  reply = QMessageBox.question(self, ""Zamknij pliki"", msg + ""\n\nCzy chcesz kontynuować?"",
                                               QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
                  if reply == QMessageBox.StandardButton.No:
                       self.statusBar().showMessage(""Zmiana nazwy anulowana."")
                       return # Anuluj operację
                  unsaved_open_files = [p for p in open_files_to_close if self.open_files.get(p) and self.open_files[p].document().isModified()]
                  if unsaved_open_files:
                       save_reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                                         f""Niektóre z plików ({len(unsaved_open_files)}) mają niezapisane zmiany. Czy chcesz je zapisać przed zamknięciem i zmianą nazwy?"",
                                                         QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                       if save_reply == QMessageBox.StandardButton.Cancel:
                            self.statusBar().showMessage(""Zmiana nazwy anulowana (niezapisane zmiany)."")
                            return # Anuluj operację
                       if save_reply == QMessageBox.StandardButton.Save:
                            save_success = True
                            for file_path_to_save in unsaved_open_files:
                                 editor = self.open_files.get(file_path_to_save)
                                 if editor and not self._save_file(editor, file_path_to_save): # _save_file handles Save As if needed
                                      save_success = False
                                      break
                            if not save_success:
                                 self.statusBar().showMessage(""Zmiana nazwy anulowana (błąd zapisu otwartych plików)."")
                                 return # Anuluj operację
                  for file_path_to_close in reversed(open_files_to_close):
                       editor_widget = self.open_files.get(file_path_to_close)
                       if editor_widget:
                            tab_index = self.tab_widget.indexOf(editor_widget)
                            if tab_index != -1:
                                 if hasattr(editor_widget, 'document'):
                                      editor_widget.document().setModified(False)
                                 self.tab_widget.removeTab(tab_index)
                                 del self.open_files[file_path_to_close]
                                 editor_widget.deleteLater()
                  self.recents[""open_files""] = [p for p in self.recents[""open_files""] if p not in open_files_to_close]
                  self._update_recent_files_menu()
                  self._save_app_state() # Zapisz stan po zamknięciu plików
             success = self.project_model.rename(index, new_name)
             if success:
                 self.statusBar().showMessage(f""Zmieniono nazwę na: {new_name}"")
                 if open_files_to_close:
                      parent_index_after_rename = self.project_model.index(parent_dir)
                      if parent_index_after_rename.isValid():
                           self.project_model.refresh(parent_index_after_rename)
                      for old_file_path in open_files_to_close:
                           relative_path = os.path.relpath(old_file_path, old_path)
                           new_file_path = os.path.join(new_path, relative_path)
                           if os.path.exists(new_file_path) and os.path.isfile(new_file_path):
                                self._open_file(new_file_path) # Otworzy plik pod nową ścieżką
             else:
                  QMessageBox.critical(self, ""Błąd zmiany nazwy"", f""Nie można zmienić nazwy '{old_name}' na '{new_name}'.\n""
                                                                   ""Sprawdź, czy element o tej nazwie już nie istnieje lub czy masz uprawnienia."")
                  self.statusBar().showMessage(""Błąd zmiany nazwy."")
    def _delete_item(self, index):
        """"""Usuwa plik lub folder.""""""
        if not index.isValid(): return
        file_path = self.project_model.filePath(index)
        item_name = os.path.basename(file_path)
        is_dir = self.project_model.fileInfo(index).isDir()
        if file_path == self.project_model.rootPath() or file_path == self.project_model.filePath(self.project_model.index("""")):
             QMessageBox.warning(self, ""Błąd usuwania"", ""Nie można usunąć katalogu głównego."")
             self.statusBar().showMessage(""Nie można usunąć katalogu głównego."")
             return
        open_files_to_close = []
        if is_dir:
             normalized_folder_path = os.path.normpath(file_path) + os.sep
             for open_file_path in self.open_files.keys():
                  if os.path.normpath(open_file_path).startswith(normalized_folder_path):
                       open_files_to_close.append(open_file_path)
        elif file_path in self.open_files:
             open_files_to_close.append(file_path)
        if open_files_to_close:
             open_file_names = [os.path.basename(p) for p in open_files_to_close]
             msg = f""Nie można usunąć {{'folderu' if is_dir else 'pliku'}} '{item_name}', ponieważ zawiera on otwarte pliki, które muszą zostać zamknięte:\\n"" + ""\\n"".join(open_file_names)
             QMessageBox.warning(self, ""Element jest używany"", msg)
             reply_close = QMessageBox.question(self, ""Zamknij pliki"",
                                                f""Czy chcesz zamknąć te pliki, aby kontynuować usuwanie '{item_name}'?"",
                                                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
             if reply_close == QMessageBox.StandardButton.No:
                  self.statusBar().showMessage(f""Usuwanie '{item_name}' anulowane."")
                  return # Anuluj operację
             unsaved_open_files = [p for p in open_files_to_close if self.open_files.get(p) and self.open_files[p].document().isModified()]
             if unsaved_open_files:
                  save_reply = QMessageBox.question(self, ""Niezapisane zmiany"",
                                                    f""Niektóre z plików ({len(unsaved_open_files)}) mają niezapisane zmiany. Czy chcesz je zapisać przed zamknięciem i usunięciem?"",
                                                    QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
                  if save_reply == QMessageBox.StandardButton.Cancel:
                       self.statusBar().showMessage(""Usuwanie anulowane (niezapisane zmiany)."")
                       return # Anuluj operację
                  if save_reply == QMessageBox.StandardButton.Save:
                       save_success = True
                       for file_path_to_save in unsaved_open_files:
                            editor = self.open_files.get(file_path_to_save)
                            if editor and not self._save_file(editor, file_path_to_save): # _save_file handles Save As if needed
                                 save_success = False
                                 break
                       if not save_success:
                            self.statusBar().showMessage(""Usuwanie anulowane (błąd zapisu otwartych plików)."")
                            return # Anuluj operację
             for file_path_to_close in reversed(open_files_to_close):
                  editor_widget = self.open_files.get(file_path_to_close)
                  if editor_widget:
                       tab_index = self.tab_widget.indexOf(editor_widget)
                       if tab_index != -1:
                            if hasattr(editor_widget, 'document'):
                                editor_widget.document().setModified(False)
                            self.tab_widget.removeTab(tab_index)
                            del self.open_files[file_path_to_close]
                            editor_widget.deleteLater()
             self.recents[""open_files""] = [p for p in self.recents[""open_files""] if p not in open_files_to_close]
             self._update_recent_files_menu()
             self._save_app_state() # Zapisz stan po zamknięciu plików
        item_type = ""folder"" if is_dir else ""plik""
        reply = QMessageBox.question(self, f""Usuń {item_type}"",
                                     f""Czy na pewno chcesz usunąć {item_type} '{item_name}'?\\n""
                                     ""Ta operacja jest nieodwracalna!"", # Dodaj ostrzeżenie
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            success = self.project_model.remove(index)
            if success:
                self.statusBar().showMessage(f""Usunięto {item_type}: {item_name}"")
            else:
                 QMessageBox.critical(self, f""Błąd usuwania {item_type}"", f""Nie można usunąć {item_type} '{item_name}'.\\n""
                                                                            ""Sprawdź, czy masz uprawnienia lub czy element nie jest używany przez inny program."")
                 self.statusBar().showMessage(f""Błąd usuwania {item_type}."")
    def _duplicate_file(self, index):
         """"""Duplikuje plik.""""""
         if not index.isValid(): return
         file_path = self.project_model.filePath(index)
         file_info = self.project_model.fileInfo(index)
         if not file_info.isFile():
              self.statusBar().showMessage(""Można duplikować tylko pliki."")
              return
         parent_dir = os.path.dirname(file_path)
         old_name = os.path.basename(file_path)
         name, ext = os.path.splitext(old_name)
         suggested_name = f""{name}_kopia{ext}""
         counter = 1
         while os.path.exists(os.path.join(parent_dir, suggested_name)):
              counter += 1
              suggested_name = f""{name}_kopia{counter}{ext}""
         new_name, ok = QInputDialog.getText(self, ""Duplikuj plik"", f""Podaj nazwę dla kopii '{old_name}':"",
                                            QLineEdit.EchoMode.Normal, suggested_name)
         if ok and new_name:
             new_name = new_name.strip()
             if not new_name or re.search(r'[<>:""/\\|?*\x00-\x1F]', new_name) is not None:
                 QMessageBox.warning(self, ""Nieprawidłowa nazwa"", ""Podana nazwa jest pusta lub zawiera niedozwolone znaki."")
                 self.statusBar().showMessage(""Duplikowanie anulowane (nieprawidłowa nazwa)."")
                 return
             new_path = os.path.join(parent_dir, new_name)
             if os.path.exists(new_path):
                  QMessageBox.warning(self, ""Element już istnieje"", f""Element o nazwie '{new_name}' już istnieje."")
                  self.statusBar().showMessage(""Duplikowanie anulowane (element już istnieje)."")
                  return
             try:
                 os.makedirs(os.path.dirname(new_path), exist_ok=True)
                 shutil.copy2(file_path, new_path) # copy2 zachowuje metadane
                 self.statusBar().showMessage(f""Utworzono kopię: {new_name}"")
                 parent_index = self.project_model.index(parent_dir)
                 if parent_index.isValid():
                      self.project_model.refresh(parent_index)
                 else:
                      root_path = self.project_model.rootPath()
                      if root_path and os.path.isdir(root_path):
                           self.project_model.refresh(self.project_model.index(root_path))
             except OSError as e:
                  QMessageBox.critical(self, ""Błąd duplikowania"", f""Nie można zduplikować pliku '{old_name}':\n{e}"")
                  self.statusBar().showMessage(""Błąd duplikowania pliku."")
             except Exception as e:
                 QMessageBox.critical(self, ""Nieoczekiwany błąd"", f""Wystąpił nieoczekiwany błąd:\n{e}"")
                 self.statusBar().showMessage(""Nieoczekiwany błąd."")
    def _close_tab_by_index(self, index):
        """"""Zamyka zakładkę o podanym indeksie, pytając o zapisanie zmian.""""""
        if index == -1: # Brak otwartych zakładek
            return
        widget = self.tab_widget.widget(index)
        if widget is None: # Zabezpieczenie
            return
        file_path_before_save = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is widget:
                file_path_before_save = path
                break
        if hasattr(widget, 'document') and widget.document().isModified():
            msg_box = QMessageBox(self)
            msg_box.setIcon(QMessageBox.Icon.Warning)
            msg_box.setWindowTitle(""Niezapisane zmiany"")
            tab_text = self.tab_widget.tabText(index).rstrip('*')
            display_name = os.path.basename(file_path_before_save) if file_path_before_save else tab_text
            msg_box.setText(f""Plik '{display_name}' ma niezapisane zmiany.\nCzy chcesz zapisać przed zamknięciem?"")
            msg_box.setStandardButtons(QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            msg_box.setDefaultButton(QMessageBox.StandardButton.Save)
            reply = msg_box.exec()
            if reply == QMessageBox.StandardButton.Save:
                needs_save_as = (file_path_before_save is None or
                                 not os.path.exists(file_path_before_save) or
                                 not QFileInfo(file_path_before_save).isFile())
                if needs_save_as:
                    original_index = self.tab_widget.currentIndex()
                    self.tab_widget.setCurrentIndex(index)
                    save_success = self._save_current_file_as() # This handles saving and updating open_files/recents for the NEW path
                    if original_index != -1 and original_index < self.tab_widget.count():
                         self.tab_widget.setCurrentIndex(original_index)
                    else: # If the original tab was closed during Save As (e.g. saving an existing file to itself)
                         pass # Keep the new tab active
                    if not save_success:
                         self.statusBar().showMessage(f""Zamknięcie anulowane (błąd zapisu '{display_name}')."")
                         return # Anulowano lub błąd zapisu ""jako"", nie zamykaj zakładki
                else: # It's an existing file with a valid path
                     if not self._save_file(widget, file_path_before_save): # Spróbuj zapisać, jeśli się nie uda, nie zamykaj
                         self.statusBar().showMessage(f""Zamknięcie anulowane (błąd zapisu '{display_name}')."")
                         return # Anulowano lub błąd zapisu
            elif reply == QMessageBox.StandardButton.Cancel:
                self.statusBar().showMessage(f""Zamknięcie '{tab_text}' anulowane."")
                return # Anuluj zamknięcie
        if file_path_before_save in self.open_files:
             del self.open_files[file_path_before_save]
             if file_path_before_save in self.recents[""open_files""]:
                 self.recents[""open_files""].remove(file_path_before_save)
                 self._update_recent_files_menu() # Uaktualnij menu
        self.tab_widget.removeTab(index)
        widget.deleteLater() # Usuń widget z pamięci
        if file_path_before_save:
            self.statusBar().showMessage(f""Zamknięto plik: {os.path.basename(file_path_before_save)}"")
        else:
             self.statusBar().showMessage(""Zamknięto plik."")
        self._save_app_state()
    def _close_current_tab(self):
        """"""Zamyka aktualnie aktywną zakładkę.""""""
        current_index = self.tab_widget.currentIndex()
        if current_index != -1:
            self._close_tab_by_index(current_index)
    def _save_current_file(self):
        """"""Zapisuje aktualnie aktywny plik. Jeśli nowy, wywołuje Save As.""""""
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego pliku do zapisu."")
            return False
        file_path = None
        for path, editor_widget in list(self.open_files.items()):
            if editor_widget is current_widget:
                file_path = path
                break
        is_existing_valid_file = file_path and os.path.exists(file_path) and QFileInfo(file_path).isFile()
        if is_existing_valid_file:
             return self._save_file(current_widget, file_path)
        else:
             return self._save_current_file_as()
    def _save_current_file_as(self):
        """"""Zapisuje zawartość aktywnego edytora z nową nazwą.""""""
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego pliku do zapisu."")
            return False
        old_file_path = None
        for path, editor_widget in list(self.open_files.items()): # Iterate over a copy
            if editor_widget is current_widget:
                old_file_path = path
                break
        suggested_name = ""bez_nazwy.txt""
        current_tab_index = self.tab_widget.indexOf(current_widget)
        if current_tab_index != -1:
             original_tab_text = self.tab_widget.tabText(current_tab_index).rstrip('*')
             if original_tab_text and original_tab_text != ""Nowy plik"":
                  suggested_name = original_tab_text
             elif current_widget.document().toPlainText().strip():
                  first_line = current_widget.document().toPlainText().strip().split('\n')[0].strip()
                  if first_line:
                       suggested_name = re.sub(r'[\\/:*?""<>|]', '_', first_line) # Remove illegal chars
                       suggested_name = suggested_name[:50].strip() # Limit length
                       if not suggested_name:
                           suggested_name = ""bez_nazwy""
                       if '.' not in os.path.basename(suggested_name):
                            suggested_name += "".txt""
                  else:
                       suggested_name = ""bez_nazwy.txt"" # Fallback if content is just whitespace
        start_path = self.current_project_dir if self.current_project_dir else PROJECTS_DIR
        if old_file_path and os.path.dirname(old_file_path):
             start_path = os.path.dirname(old_file_path) # Use directory of old file if available
        elif os.path.isdir(start_path):
             pass # Use project dir if available
        else:
             start_path = os.path.expanduser(""~"")
        file_filters = ""Wszystkie pliki (*);;Pliki Pythona (*.py);;Pliki JavaScript (*.js);;Pliki HTML (*.html);;Pliki CSS (*.css);;Pliki C++ (*.c *.cpp *.h *.hpp);;Pliki INI (*.ini);;Pliki JSON (*.json)""
        new_file_path, _ = QFileDialog.getSaveFileName(self, ""Zapisz plik jako..."", os.path.join(start_path, suggested_name), file_filters)
        if not new_file_path:
            self.statusBar().showMessage(""Zapisywanie anulowane."")
            return False # Cancelled
        new_file_path = os.path.normpath(new_file_path)
        if old_file_path and old_file_path != new_file_path:
             if old_file_path in self.open_files:
                  del self.open_files[old_file_path]
             if old_file_path in self.recents[""open_files""]:
                 self.recents[""open_files""].remove(old_file_path)
                 self._update_recent_files_menu()
        self.open_files[new_file_path] = current_widget
        current_tab_index = self.tab_widget.indexOf(current_widget)
        if current_tab_index != -1:
             self.tab_widget.setTabText(current_tab_index, os.path.basename(new_file_path))
        if new_file_path in self.recents[""open_files""]: # Remove if already exists to move to front
             self.recents[""open_files""].remove(new_file_path)
        self.recents[""open_files""].insert(0, new_file_path)
        self._update_recent_files_menu() # Update the menu
        language = self._get_language_from_path(new_file_path)
        old_highlighter = getattr(current_widget.document(), '_syntax_highlighter', None)
        if old_highlighter:
             old_highlighter.setDocument(None) # Detach
        new_highlighter = CodeSyntaxHighlighter(current_widget.document(), language)
        setattr(current_widget.document(), '_syntax_highlighter', new_highlighter)
        return self._save_file(current_widget, new_file_path)
    def _save_file(self, editor_widget, file_path):
        """"""Zapisuje zawartość wskazanego edytora do wskazanego pliku.""""""
        if not file_path:
             print(""Error: _save_file called with empty path."", file=sys.stderr)
             self.statusBar().showMessage(""Błąd wewnętrzny: próba zapisu bez ścieżki."")
             return False
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(editor_widget.toPlainText())
            editor_widget.document().setModified(False) # Mark document as unmodified
            self.statusBar().showMessage(f""Plik zapisano pomyślnie: {os.path.basename(file_path)}"")
            tab_index = self.tab_widget.indexOf(editor_widget)
            if tab_index != -1:
                 current_tab_text = self.tab_widget.tabText(tab_index).rstrip('*')
                 self.tab_widget.setTabText(tab_index, current_tab_text)
            file_info = QFileInfo(file_path)
            dir_path = file_info.dir().path()
            root_path = self.project_model.rootPath()
            if root_path and dir_path.startswith(root_path):
                 dir_index = self.project_model.index(dir_path)
                 if dir_index.isValid():
                      self.project_model.refresh(dir_index)
                 file_index = self.project_model.index(file_path)
                 if file_index.isValid():
                      self.project_model.dataChanged.emit(file_index, file_index, [Qt.ItemDataRole.DisplayRole, Qt.ItemDataRole.DecorationRole]) # Trigger a view update
            if file_path in self.recents[""open_files""]:
                 self.recents[""open_files""].remove(file_path)
            self.recents[""open_files""].insert(0, file_path)
            self._update_recent_files_menu()
            self._save_app_state() # Save state after successful save
            return True # Save succeeded
        except Exception as e:
            QMessageBox.critical(self, ""Błąd zapisu pliku"", f""Nie można zapisać pliku {os.path.basename(file_path)}:\n{e}"")
            self.statusBar().showMessage(f""Błąd zapisu pliku: {os.path.basename(file_path)}"")
            return False # Save failed
    def _save_all_files(self):
        """"""Zapisuje wszystkie otwarte i zmodyfikowane pliki.""""""
        unsaved_files = [path for path, editor in self.open_files.items() if editor.document().isModified()]
        if not unsaved_files:
             self.statusBar().showMessage(""Brak zmodyfikowanych plików do zapisu."")
             return True # Nothing to save, counts as success
        self.statusBar().showMessage(f""Zapisywanie wszystkich zmodyfikowanych plików ({len(unsaved_files)})..."")
        total_saved = 0
        total_failed = 0
        files_to_save = list(unsaved_files)
        for file_path in files_to_save:
             editor_widget = self.open_files.get(file_path)
             if editor_widget is None or self.tab_widget.indexOf(editor_widget) == -1:
                  print(f""Warning: Skipping save for {file_path} - editor widget not found or invalid."", file=sys.stderr)
                  continue # Go to the next file
             if not editor_widget.document().isModified():
                  continue # Already saved
             needs_save_as = (file_path is None or
                              not os.path.exists(file_path) or
                              not QFileInfo(file_path).isFile())
             save_success = False
             if needs_save_as:
                  tab_index = self.tab_widget.indexOf(editor_widget)
                  if tab_index != -1:
                       original_index = self.tab_widget.currentIndex()
                       self.tab_widget.setCurrentIndex(tab_index)
                       save_success = self._save_current_file_as()
                       if original_index != -1 and original_index < self.tab_widget.count():
                           self.tab_widget.setCurrentIndex(original_index)
                  else:
                       print(f""Error: Cannot save '{os.path.basename(file_path if file_path else 'Nowy plik')}' (Save As needed) - widget not found in tabs."", file=sys.stderr)
                       total_failed += 1
                       continue # Skip this file, couldn't save it via Save As mechanism
             else:
                  save_success = self._save_file(editor_widget, file_path) # This updates modified state and status bar
             if save_success:
                  total_saved += 1
             else:
                  total_failed += 1
        if total_saved > 0 and total_failed == 0:
             self.statusBar().showMessage(f""Zapisano pomyślnie wszystkie {total_saved} pliki."")
             return True
        elif total_saved > 0 and total_failed > 0:
             self.statusBar().showMessage(f""Zapisano {total_saved} plików, {total_failed} plików nie udało się zapisać."")
             QMessageBox.warning(self, ""Błąd zapisu wszystkich plików"", f""Nie udało się zapisać {total_failed} plików. Sprawdź konsolę lub logi błędów."")
             return False
        elif total_saved == 0 and total_failed > 0:
             self.statusBar().showMessage(f""Nie udało się zapisać żadnego z {total_failed} plików."")
             QMessageBox.critical(self, ""Błąd zapisu wszystkich plików"", f""Nie udało się zapisać żadnego z plików. Sprawdź konsolę lub logi błędów."")
             return False
        else: # total_saved == 0 and total_failed == 0 (already handled by initial check, but good fallback)
             self.statusBar().showMessage(""Brak zmodyfikowanych plików do zapisu."")
             return True
    def _handle_modification_changed(self, modified):
        """"""Obsługa zmiany stanu modyfikacji dokumentu w aktywnym edytorze.""""""
        editor_document = self.sender() # Dokument, który wywołał sygnał
        if not isinstance(editor_document, QTextDocument): return
        editor = None
        for editor_widget in self.open_files.values():
             if editor_widget.document() is editor_document:
                  editor = editor_widget
                  break
        if editor is None:
             return
        index = self.tab_widget.indexOf(editor)
        if index != -1:
            tab_text = self.tab_widget.tabText(index)
            if modified and not tab_text.endswith('*'):
                self.tab_widget.setTabText(index, tab_text + '*')
            elif not modified and tab_text.endswith('*'):
                self.tab_widget.setTabText(index, tab_text.rstrip('*'))
    def _handle_tab_change(self, index):
         """"""Obsługa zmiany aktywnej zakładki.""""""
         self._hide_find_bar()
         if index != -1:
             widget = self.tab_widget.widget(index)
             if isinstance(widget, QPlainTextEdit):
                  file_path = next((path for path, ed in self.open_files.items() if ed is widget), None)
                  if file_path:
                       self.statusBar().showMessage(f""Edytujesz: {os.path.basename(file_path)}"")
                  else:
                       self.statusBar().showMessage(""Edytujesz: Nowy plik"")
         else:
             self.statusBar().showMessage(""Gotowy."") # Reset status bar
    def _find_next(self):
         """"""Znajduje kolejne wystąpienie tekstu z pola wyszukiwania.""""""
         text_to_find = self.search_input.text()
         self._find_text(text_to_find, 'next')
    def _find_previous(self):
         """"""Znajduje poprzednie wystąpienie tekstu z pola wyszukiwania.""""""
         text_to_find = self.search_input.text()
         self._find_text(text_to_find, 'previous')
    def _find_text(self, text, direction='next'):
        """"""Szuka tekstu w aktualnym edytorze.""""""
        editor = self.tab_widget.currentWidget()
        if not isinstance(editor, QPlainTextEdit):
            self.statusBar().showMessage(""Brak aktywnego edytora do wyszukiwania."")
            return
        if not text:
             self.statusBar().showMessage(""Wpisz tekst do wyszukania."")
             return
        flags = QTextDocument.FindFlag(0) # Default: case-sensitive in Qt find
        if direction == 'previous':
             flags |= QTextDocument.FindFlag.FindBackward
        found = editor.find(text, flags)
        if found:
            self.statusBar().showMessage(f""Znaleziono '{text}'."")
        else:
            self.statusBar().showMessage(f""Nie znaleziono '{text}'. Zawijanie..."")
            cursor = editor.textCursor()
            original_position = cursor.position() # Remember position before wrapping search
            cursor.clearSelection() # Clear selection before moving cursor position programmatically
            cursor.movePosition(cursor.MoveOperation.Start if direction == 'next' else cursor.MoveOperation.End)
            editor.setTextCursor(cursor)
            found_wrapped = editor.find(text, flags)
            if found_wrapped:
                self.statusBar().showMessage(f""Znaleziono '{text}' po zawinięciu."")
            else:
                 self.statusBar().showMessage(f""Nie znaleziono '{text}' w całym pliku."")
                 cursor.clearSelection()
                 cursor.setPosition(original_position)
                 editor.setTextCursor(cursor)
    def _show_find_bar(self):
        """"""Pokazuje pasek wyszukiwania.""""""
        if self.search_input.isVisible():
             self._hide_find_bar()
             return
        self.search_input.setVisible(True)
        self.find_next_button.setVisible(True)
        self.find_prev_button.setVisible(True)
        self.search_input.setFocus() # Ustaw kursor w polu wyszukiwania
    def _hide_find_bar(self):
        """"""Ukrywa pasek wyszukiwania.""""""
        if self.search_input.isVisible(): # Check if visible before hiding
            self.search_input.setVisible(False)
            self.find_next_button.setVisible(False)
            self.find_prev_button.setVisible(False)
            self.search_input.clear() # Wyczyść pole wyszukiwania
    def _show_settings_dialog(self):
        """"""Wyświetla okno dialogowe ustawień.""""""
        temp_settings = self.settings.copy()
        dialog = SettingsDialog(temp_settings, self) # Pass the copy
        font_size_label = QLabel(""Rozmiar czcionki edytora:"")
        font_size_spinbox = QSpinBox()
        font_size_spinbox.setRange(6, 72) # Typical font sizes
        font_size_spinbox.setValue(temp_settings.get(""editor_font_size"", 10))
        dialog_layout = dialog.layout()
        button_box_row_index = dialog_layout.rowCount() - 1
        dialog_layout.insertRow(button_box_row_index, font_size_label, font_size_spinbox)
        setattr(dialog, 'editor_font_size_spinbox', font_size_spinbox)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            updated_settings = dialog.get_settings()
            updated_settings[""editor_font_size""] = font_size_spinbox.value()
            self.settings = updated_settings
            self._apply_theme(self.settings.get(""theme"", ""light"")) # Apply theme
            self._apply_editor_font_size() # Apply new font size
            self._apply_view_settings() # Apply view settings (tree/console visibility)
            self._save_app_state() # Save updated settings and state
            self.statusBar().showMessage(""Ustawienia zapisane."")
        else:
            self.statusBar().showMessage(""Zmiany w ustawieniach anulowane."")
    def _show_about_dialog(self):
        """"""Wyświetla okno informacyjne 'O programie'.""""""
        QMessageBox.about(self, ""O programie"",
                          ""<h2>Proste IDE</h2>""
                          ""<p>Prosty edytor kodu napisany w Pythonie z użyciem biblioteki PyQt6.</p>""
                          ""<p>Wersja: 1.0</p>""
                          ""<p>Autor: [Twoje imię lub nazwa]</p>""
                          ""<p>Dostępne funkcje:</p>""
                          ""<ul>""
                          ""<li>Przeglądanie plików i folderów</li>""
                          ""<li>Otwieranie i edycja plików tekstowych/kodów</li>""
                          ""<li>Kolorowanie składni (Python, JavaScript, HTML, CSS, C++, INI, JSON)</li>""
                          ""<li>Uruchamianie plików Python/JavaScript (z konfigurowalnymi ścieżkami)</li>""
                          ""<li>Uruchamianie skryptów npm (po otwarciu folderu z package.json)</li>""
                          ""<li>**Wprowadzanie poleceń w konsoli**</li>"" # Dodano
                          ""<li>Zapisywanie plików (Zapisz, Zapisz jako, Zapisz wszystko)</li>""
                          ""<li>Historia ostatnio otwieranych plików/folderów</li>""
                          ""<li>Proste wyszukiwanie tekstu</li>""
                          ""<li>Podstawowe motywy (Jasny/Ciemny)</li>""
                          ""<li>Ukrywanie/pokazywanie paneli (Drzewko, Konsola)</li>""
                          ""<li>Zmiana rozmiaru czcionki edytora</li>""
                          ""<li>Operacje na plikach/folderach (Nowy, Zmień nazwę, Usuń, Duplikuj)</li>""
                          ""</ul>""
                          ""<p>Użyte technologie: PyQt6, Python, opcjonalnie qtawesome.</p>"")
    def _update_run_button_menu(self):
        """"""Uaktualnia menu przypisane do QToolButton 'Uruchom'.""""""
        menu = QMenu(self)
        menu.addAction(self.action_run_file)
        if self.node_scripts:
             menu.addSeparator()
             menu.addSection(""Skrypty npm:"")
             sorted_scripts = sorted(self.node_scripts.keys())
             for script_name in sorted_scripts:
                action = QAction(script_name, self)
                action.triggered.connect(lambda checked, name=script_name: self._run_npm_script(name))
                menu.addAction(action)
        else:
             no_scripts_action = QAction(""Brak skryptów npm (package.json)"", self)
             no_scripts_action.setEnabled(False) # Wyłącz akcję
             menu.addAction(no_scripts_action)
        self.run_toolbutton.setMenu(menu)
    def _run_current_file(self):
        """"""Uruchamia aktualnie otwarty plik.""""""
        current_widget = self.tab_widget.currentWidget()
        if not isinstance(current_widget, QPlainTextEdit):
            self._append_console_output(""Brak aktywnego pliku do uruchomienia."", is_error=True)
            return
        file_path = next((path for path, editor_widget in self.open_files.items() if editor_widget is current_widget), None)
        if not file_path or not os.path.exists(file_path) or not os.path.isfile(file_path):
             self._append_console_output(""Ścieżka aktywnego pliku jest nieprawidłowa lub plik nie istnieje."", is_error=True)
             return
        if current_widget.document().isModified():
             self._append_console_output(""Zapisywanie pliku przed uruchomieniem..."")
             if not self._save_file(current_widget, file_path):
                 self._append_console_output(""Zapisywanie nie powiodło się. Anulowano uruchomienie."", is_error=True)
                 return
        language = self._get_language_from_path(file_path)
        command = []
        working_dir = os.path.dirname(file_path) # Directory of the file
        python_path = self.settings.get(""python_path"")
        node_path = self.settings.get(""node_path"")
        if language == 'python':
            interpreter = python_path if python_path and os.path.exists(python_path) else ""python""
            command = [interpreter, ""-u"", file_path]
        elif language == 'javascript':
            interpreter = node_path if node_path and os.path.exists(node_path) else ""node""
            command = [interpreter, file_path]
        elif language in ['html', 'css']:
             self._append_console_output(f""Otwieranie pliku {os.path.basename(file_path)} w domyślnej przeglądarce..."")
             try:
                  QDesktopServices.openUrl(QUrl.fromLocalFile(file_path))
                  self.statusBar().showMessage(f""Otwarto plik w przeglądarce: {os.path.basename(file_path)}"")
             except Exception as e:
                  self._append_console_output(f""Błąd podczas otwierania pliku w przeglądarce: {e}"", is_error=True)
                  self.statusBar().showMessage(""Błąd otwierania w przeglądarce."")
             return # Do not run as a process
        else:
            self._append_console_output(f""Nieznany typ pliku do uruchomienia: {language}"", is_error=True)
            return
        if command:
             self._run_command(command, working_dir)
    def _check_package_json(self, folder_path):
        """"""Checks if package.json exists in the folder and parses scripts.""""""
        if not folder_path or not os.path.isdir(folder_path):
             self.node_scripts = {} # Clear any previous scripts
             self._update_run_button_menu() # Update run menu button
             return
        package_json_path = os.path.join(folder_path, 'package.json')
        self.node_scripts = {} # Clear previous scripts
        if os.path.exists(package_json_path):
            try:
                with open(package_json_path, 'r', encoding='utf-8') as f:
                    package_data = json.load(f)
                scripts = package_data.get('scripts', {})
                if isinstance(scripts, dict) and scripts:
                    self.node_scripts = scripts
                    self._append_console_output(f""Znaleziono {len(scripts)} skryptów w package.json w {os.path.basename(folder_path)}."")
                else:
                     self._append_console_output(f""Znaleziono package.json w {os.path.basename(folder_path)}, ale brak skryptów w sekcji 'scripts'."")
            except (FileNotFoundError, json.JSONDecodeError, Exception) as e:
                self._append_console_output(f""Błąd podczas parsowania package.json w {os.path.basename(folder_path)}:\n{e}"", is_error=True)
                self.node_scripts = {} # Ensure scripts are empty on error
        else:
             pass # Silence is golden
        self._update_run_button_menu() # After checking package.json, update the run menu button
    def _run_npm_script(self, script_name):
        """"""Runs the specified npm script.""""""
        if not self.current_project_dir or not os.path.isdir(self.current_project_dir):
            self._append_console_output(""Brak otwartego folderu projektu do uruchomienia skryptu npm."", is_error=True)
            return
        if script_name not in self.node_scripts:
            self._append_console_output(f""Skrypt '{script_name}' nie znaleziono w package.json otwartego projektu."", is_error=True)
            return
        node_path = self.settings.get(""node_path"")
        npm_command = ""npm"" # Default command
        if node_path and os.path.exists(node_path):
             node_dir = os.path.dirname(node_path)
             npm_candidates = [os.path.join(node_dir, 'npm')]
             if platform.system() == ""Windows"":
                  npm_candidates.append(os.path.join(node_dir, 'npm.cmd'))
             found_npm = None
             for candidate in npm_candidates:
                  if os.path.isfile(candidate) and os.access(candidate, os.X_OK):
                       found_npm = candidate
                       break
             if found_npm:
                  npm_command = found_npm
             else:
                  self._append_console_output(f""Ostrzeżenie: Nie znaleziono 'npm' (lub nie jest wykonywalne) obok skonfigurowanej ścieżki node '{node_path}'. Polegam na systemowym PATH."", is_error=True)
        command = [npm_command, ""run"", script_name]
        working_dir = self.current_project_dir # Npm scripts are run in the project directory
        self._run_command(command, working_dir)
    def _run_console_command(self):
        """"""Uruchamia komendę wpisaną w polu tekstowym konsoli.""""""
        command_text = self.console_input.text().strip()
        if not command_text:
            return # Nic nie wpisano
        self.console_input.clear() # Wyczyść pole wprowadzania
        self._append_console_output(f""> {command_text}"") # Wyświetl wpisaną komendę w konsoli
        try:
            command = shlex.split(command_text)
        except ValueError as e:
             self._append_console_output(f""Błąd parsowania komendy: {e}"", is_error=True)
             self.statusBar().showMessage(""Błąd parsowania komendy."")
             return
        if not command:
             self._append_console_output(""Błąd: Pusta komenda po parsowaniu."", is_error=True)
             self.statusBar().showMessage(""Błąd: Pusta komenda."")
             return
        working_dir = self.current_project_dir if self.current_project_dir and os.path.isdir(self.current_project_dir) else os.getcwd()
        self._run_command(command, working_dir)
    def _run_command(self, command, working_dir):
        """"""Uruchamia podaną komendę w QProcess.""""""
        if self.process.state() != QProcess.ProcessState.NotRunning:
            self._append_console_output(""Inny proces jest już uruchomiony. Zakończ go, aby uruchomić nowy."", is_error=True)
            self._append_console_output(""Możesz zatrzymać proces używając przycisku stop lub wpisując polecenie 'stop' w konsoli (jeśli obsługiwane przez program)."")
            return
        command_str = shlex.join(command) # Better command formatting
        self._append_console_output(f""Uruchamianie: {command_str}\nw katalogu: {working_dir}\n---"")
        self.statusBar().showMessage(""Proces uruchomiony..."")
        try:
            if not command:
                 self._append_console_output(""Komenda do uruchomienia jest pusta."", is_error=True)
                 self.statusBar().showMessage(""Błąd: Pusta komenda."")
                 return
            program = command[0]
            arguments = command[1:]
            self.process.setWorkingDirectory(working_dir)
            process_environment = QProcessEnvironment.systemEnvironment()
            current_path = process_environment.value(""PATH"", """") # Get system PATH
            paths_to_prepend = []
            py_path = self.settings.get(""python_path"")
            if py_path and os.path.exists(py_path):
                 py_dir = os.path.dirname(py_path)
                 current_path_dirs = [os.path.normcase(p) for p in current_path.split(os.pathsep) if p]
                 if os.path.normcase(py_dir) not in current_path_dirs:
                      paths_to_prepend.append(py_dir)
            node_path = self.settings.get(""node_path"")
            if node_path and os.path.exists(node_path):
                 node_dir = os.path.dirname(node_path)
                 if os.path.normcase(node_dir) not in current_path_dirs:
                     paths_to_prepend.append(node_dir)
            if paths_to_prepend:
                 new_path = os.pathsep.join(paths_to_prepend) + (os.pathsep + current_path if current_path else """")
            else:
                 new_path = current_path # No new paths to add
            process_environment.insert(""PATH"", new_path) # Overwrite or add PATH
            if platform.system() == ""Windows"" and process_environment.value(""Path"") is not None:
                 if process_environment.value(""Path"") != current_path: # Avoid unnecessary update
                      process_environment.insert(""Path"", new_path)
            self.process.setProcessEnvironment(process_environment)
            self.process.start(program, arguments)
            if not self.process.waitForStarted(1000):
                 error_string = self.process.errorString()
                 self._append_console_output(f""Nie udało się uruchomić procesu '{program}': {error_string}"", is_error=True)
                 self.statusBar().showMessage(f""Błąd uruchamiania: {program}"")
                 return # Process didn't start, exit
        except Exception as e:
            self._append_console_output(f""Wystąpił nieoczekiwany błąd podczas próby uruchomienia:\n{e}"", is_error=True)
            self.statusBar().showMessage(""Błąd podczas uruchamiania."")
    def _append_console_output(self, text, is_error=False):
        """"""Adds text to the console, optionally formatting as an error.""""""
        cursor = self.console.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        original_fmt = cursor.charFormat()
        fmt = QTextCharFormat()
        if is_error:
            fmt.setForeground(QColor(""#DC143C"")) # Crimson
        cursor.setCharFormat(fmt)
        text_to_insert = text
        if text and not text.endswith('\n'):
             text_to_insert += '\n'
        cursor.insertText(text_to_insert)
        cursor.setCharFormat(original_fmt)
        self.console.ensureCursorVisible()
    def _handle_stdout(self):
        """"""Reads standard output of the process and displays it in the console.""""""
        while self.process.bytesAvailable(): # Correct usage
            data = self.process.readAllStandardOutput()
            try:
                 text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                 try:
                     text = bytes(data).decode('latin-1')
                 except Exception:
                     text = bytes(data).decode('utf-8', errors='replace') # Replace unknown characters
            self._append_console_output(text)
    def _handle_stderr(self):
        """"""Reads standard error of the process and displays it in the console (in red).""""""
        while self.process.bytesAvailable(): # Correct usage
            data = self.process.readAllStandardError()
            try:
                 text = bytes(data).decode('utf-8')
            except UnicodeDecodeError:
                 try:
                     text = bytes(data).decode('latin-1')
                 except Exception:
                     text = bytes(data).decode('utf-8', errors='replace') # Replace unknown characters
            self._append_console_output(text, is_error=True)
    def _handle_process_finished(self, exitCode, exitStatus):
        """"""Handles the process finishing.""""""
        self._handle_stdout()
        self._handle_stderr()
        self._append_console_output(""\n--- Zakończono proces ---"") # Add a clear separator
        if exitStatus == QProcess.ExitStatus.NormalExit:
            self._append_console_output(f""Proces zakończył się z kodem wyjścia: {exitCode}"")
            self.statusBar().showMessage(f""Proces zakończył się. Kod wyjścia: {exitCode}"")
        else:
            self._append_console_output(f""Proces zakończył się awaryjnie z kodem wyjścia: {exitCode}"", is_error=True)
            self.statusBar().showMessage(f""Proces zakończył się awaryjnie. Kod wyjścia: {exitCode}"")
        if self.settings.get(""show_console"", True):
             self._show_console_panel() # Ensure console is visible and correctly sized
    def _copy_console(self):
         """"""Copies the entire content of the console to the clipboard.""""""
         clipboard = QApplication.clipboard()
         clipboard.setText(self.console.toPlainText())
         self.statusBar().showMessage(""Zawartość konsoli skopiowana do schowka."")
    def _toggle_tree_view(self, checked):
         """"""Shows/hides the file tree panel.""""""
         self.main_splitter.widget(0).setVisible(checked)
         self.settings[""show_tree""] = checked # Save state
         self._save_app_state() # Save settings change
         self._apply_view_settings() # Re-apply sizes to ensure panels aren't too small/large
    def _toggle_console(self, checked):
         """"""Shows/hides the console panel.""""""
         self.right_splitter.widget(1).setVisible(checked)
         self.settings[""show_console""] = checked # Save state
         self._save_app_state() # Save settings change
         if checked:
              self._show_console_panel() # Use method that sets sizes
    def _show_console_panel(self):
        """"""Ensures the console panel is visible and has a reasonable size.""""""
        self.right_splitter.widget(1).setVisible(True)
        self.action_toggle_console.setChecked(True)
        sizes = self.right_splitter.sizes()
        if len(sizes) == 2:
            total_height = sum(sizes)
            min_console_height = 100
            min_editor_height = 100
            if sizes[1] < min_console_height or (sizes[1] < 10 and self.settings.get(""show_console"", True)):
                 if total_height > min_console_height + min_editor_height:
                      self.right_splitter.setSizes([total_height - min_console_height, min_console_height])
                 elif total_height > 200: # Ensure some minimal height if window is small
                      self.right_splitter.setSizes([total_height // 2, total_height // 2]) # Split equally
    def _apply_view_settings(self):
        """"""Apply panel visibility settings after loading.""""""
        show_tree = self.settings.get(""show_tree"", True)
        show_console = self.settings.get(""show_console"", True)
        self.main_splitter.widget(0).setVisible(show_tree)
        self.action_toggle_tree.setChecked(show_tree)
        self.right_splitter.widget(1).setVisible(show_console)
        self.action_toggle_console.setChecked(show_console)
        main_sizes = self.main_splitter.sizes()
        if len(main_sizes) == 2:
             total_width = sum(main_sizes)
             min_tree_width = 150 # Minimal reasonable width for the tree view
             min_right_panel_width = 200 # Minimal width for the editor/console side
             if main_sizes[0] < min_tree_width or (main_sizes[0] < 10 and show_tree):
                  if total_width > min_tree_width + min_right_panel_width:
                       self.main_splitter.setSizes([min_tree_width, total_width - min_tree_width])
                  elif total_width > 300: # Ensure some minimal width if window is small
                       self.main_splitter.setSizes([total_width // 3, 2 * total_width // 3]) # Split approx 1/3, 2/3
        right_sizes = self.right_splitter.sizes()
        if len(right_sizes) == 2:
             total_height = sum(right_sizes)
             min_console_height = 100
             min_editor_height = 100 # Minimal height for the editor area
             if right_sizes[1] < min_console_height or (right_sizes[1] < 10 and show_console):
                   if total_height > min_console_height + min_editor_height:
                       self.right_splitter.setSizes([total_height - min_console_height, min_console_height])
                   elif total_height > 200: # Ensure some minimal height if window is small
                       self.right_splitter.setSizes([total_height // 2, total_height // 2]) # Split equally
             elif right_sizes[0] < min_editor_height and show_console and total_height > min_console_height + min_editor_height:
                   self.right_splitter.setSizes([min_editor_height, total_height - min_editor_height])
    def _apply_editor_font_size(self):
        """"""Apply the editor font size to all open editors and the console.""""""
        font_size = self.settings.get(""editor_font_size"", 10)
        new_font = QFont(""Courier New"", font_size) # Use Courier New, change size
        self.base_editor_font = new_font # Update the base font
        self.console.setFont(new_font)
        self.console_input.setFont(new_font)
        for editor_widget in self.open_files.values():
            editor_widget.setFont(new_font)
            if hasattr(editor_widget.document(), '_syntax_highlighter'):
                 editor_widget.document().rehighlight()
    def _apply_theme(self, theme_name):
        """"""Applies the selected color theme.""""""
        if theme_name == ""dark"":
            self.setStyleSheet(""""""
                QMainWindow, QWidget {
                    background-color: #2E2E2E;
                    color: #D3D3D3;
                }
                QMenuBar {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                }
                QMenuBar::item:selected {
                    background-color: #505050;
                }
                QMenu {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #505050;
                }
                QMenu::item:selected {
                    background-color: #505050;
                }
                QToolBar {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    spacing: 5px;
                    padding: 2px;
                }
                QToolButton { /* Buttons on toolbar */
                    background-color: transparent;
                    border: 1px solid transparent;
                    padding: 3px;
                    border-radius: 4px; /* Slight rounding */
                }
                QToolButton:hover {
                    border: 1px solid #505050;
                    background-color: #454545;
                }
                 QToolButton:pressed {
                     background-color: #404040;
                 }
                QPushButton { /* Standard buttons (e.g., Run, Find) */
                    background-color: #505050;
                    color: #D3D3D3;
                    border: 1px solid #606060;
                    padding: 4px 8px;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #606060;
                }
                QPushButton:pressed {
                    background-color: #404040;
                }
                QStatusBar {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                }
                QSplitter::handle {
                    background-color: #505050;
                }
                QSplitter::handle:horizontal {
                    width: 5px;
                }
                QSplitter::handle:vertical {
                    height: 5px;
                }
                QTreeView {
                    background-color: #1E1E1E;
                    color: #D3D3D3;
                    border: 1px solid #3C3C3C;
                    alternate-background-color: #252525; /* Alternating row colors */
                }
                QTreeView::item:selected {
                    background-color: #007acc; /* Selection color (VS Code blue) */
                    color: white;
                }
                QTreeView::branch:selected {
                     background-color: #007acc; /* Selection color for branch indicator */
                }
                QTabWidget::pane { /* Frame around tab content area */
                    border: 1px solid #3C3C3C;
                    background-color: #1E1E1E;
                }
                QTabWidget::tab-bar:top {
                    left: 5px; /* Leave some space on the left */
                }
                QTabBar::tab {
                    background: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #3C3C3C;
                    border-bottom-color: #1E1E1E; /* Blend bottom border with pane background */
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    padding: 4px 8px;
                    margin-right: 1px;
                }
                QTabBar::tab:selected {
                    background: #1E1E1E; /* Match pane background for selected tab */
                    border-bottom-color: #1E1E1E;
                }
                QTabBar::tab:hover {
                    background: #454545; /* Hover effect */
                }
                /* Optional: Style for close button */
                /* QTabBar::close-button { image: url(:/path/to/close_icon_dark.png); } */
                QPlainTextEdit { /* Code Editor */
                    background-color: #1E1E1E;
                    color: #D3D3D3;
                    border: none; /* Border is on QTabWidget::pane */
                    selection-background-color: #007acc; /* Selection color */
                    selection-color: white;
                }
                 QPlainTextEdit[readOnly=""true""] { /* Console */
                     background-color: #1E1E1E; /* Same as editor background */
                     color: #CCCCCC; /* Console text color */
                      selection-background-color: #007acc;
                      selection-color: white;
                 }
                QLineEdit { /* Search bar, input fields in settings */
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #505050;
                    padding: 2px;
                     selection-background-color: #007acc;
                     selection-color: white;
                     border-radius: 3px; /* Slight rounding */
                }
                 QComboBox { /* ComboBox in settings */
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #505050;
                    padding: 2px;
                     border-radius: 3px;
                 }
                 QComboBox::drop-down {
                    border: 0px; /* Remove default arrow */
                 }
                  QComboBox QAbstractItemView { /* Dropdown list of ComboBox */
                     background-color: #3C3C3C;
                     color: #D3D3D3;
                     selection-background-color: #007acc;
                     border: 1px solid #505050;
                 }
                 QDialog { /* Settings dialog window */
                     background-color: #2E2E2E;
                     color: #D3D3D3;
                 }
                  QLabel { /* Labels in dialogs */
                      color: #D3D3D3;
                  }
                  QDialogButtonBox QPushButton { /* Buttons in dialogs */
                      background-color: #505050;
                      color: #D3D3D3;
                      border: 1px solid #606060;
                      padding: 5px 10px;
                      border-radius: 4px;
                  }
                   QDialogButtonBox QPushButton:hover {
                      background-color: #606060;
                   }
                    QDialogButtonBox QPushButton:pressed {
                       background-color: #404040;
                   }
                   QSpinBox { /* Spinbox in settings */
                       background-color: #3C3C3C;
                       color: #D3D3D3;
                       border: 1px solid #505050;
                       padding: 2px;
                        selection-background-color: #007acc;
                        selection-color: white;
                         border-radius: 3px;
                   }
                   QFrame { /* Frames like the one in SettingsDialog */
                       border: none;
                   }
                /* Style for the console input field */
                QLineEdit[placeholderText=""Wpisz polecenie...""] {
                    background-color: #3C3C3C;
                    color: #D3D3D3;
                    border: 1px solid #505050;
                    padding: 2px;
                    margin: 0px; /* Remove default margins */
                    border-radius: 0px; /* No rounding for console input */
                }
            """""")
        elif theme_name == ""light"":
             self.setStyleSheet("""")
        self.statusBar().showMessage(f""Zmieniono motyw na: {theme_name.capitalize()}"")
if __name__ == '__main__':
    app = QApplication(sys.argv)
    QLocale.setDefault(QLocale(QLocale.Language.Polish, QLocale.Country.Poland))
    main_window = IDEWindow()
    main_window.show()
    sys.exit(app.exec())"
7PQjX7Sp,VIP Chat Tag,Cakey3101,Lua,Sunday 18th of May 2025 04:59:11 AM CDT,"local TextChatService = game:GetService(""TextChatService"")
local MarketPlaceService = game:GetService(""MarketplaceService"")
local Players = game:GetService(""Players"")

TextChatService.OnIncomingMessage = function(Messsage: TextChatMessage)
	local Properties = Instance.new(""TextChatMessageProperties"")
	
	if Messsage.TextSource then
		local Player = Players:GetPlayerByUserId(Messsage.TextSource.UserId)
		
		if MarketPlaceService:UserOwnsGamePassAsync(Player.UserId, 1221054409) then
			Properties.PrefixText = ""<font color='#ffff00'>[👑 VIP]</font> ""..Messsage.PrefixText 
		end
	end
	
	return Properties
end"
XNCZuUTL,2025-05-18T11:50:43.669800,powerampache,PHP,Sunday 18th of May 2025 04:50:44 AM CDT,"1.00-70 (70) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.MusicException: {""errorAction"":""share_create"",""errorCode"":""4703"",""errorMessage"":""Enable: share"",""errorType"":""system""}
	at luci.sixsixsix.powerampache2.data.AlbumsRepositoryImpl$getAlbumShareLink$2.invokeSuspend(AlbumsRepositoryImpl.kt:440)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:991)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:232)
	at android.os.Looper.loop(Looper.java:317)
	at android.app.ActivityThread.main(ActivityThread.java:8934)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:591)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:911)

getPlaylistShareLink() - {""errorAction"":""share_create"",""errorCode"":""4703"",""errorMessage"":""Enable: share"",""errorType"":""system""}"
n1TMmCce,Player,GigaOrts,C#,Sunday 18th of May 2025 04:19:32 AM CDT,"using UnityEngine;

namespace Scripts28785
{
    public class Player : MonoBehaviour
    {
        private const string Horizontal = ""Horizontal"";
        private const string Vertical = ""Vertical"";
        private const string RunMultiplier = ""RunMultiplier"";
        private const string Run = ""Run"";
        private readonly float _defaultSpeed = 1f;

        private Rigidbody2D _body2D;
        private Animator _animator;
        public float _speed = 3f;
        private Camera _camera;
        private Vector3 _faceDirection;

        private void Awake()
        {
            _body2D = GetComponent<Rigidbody2D>();
            _animator = GetComponent<Animator>();
        }

        private void Start()
        {
            _camera = Camera.main;
        }
    
        private void Update()  
        {  
            RotateCharacter();  
        }  

        private void RotateCharacter()  
        {   
            Vector3 mousePosition = Input.mousePosition;  
 
            Vector3 worldMousePosition = _camera.ScreenToWorldPoint(mousePosition);  
         
            _faceDirection = worldMousePosition - transform.position;  

            if (_faceDirection.x < 0)  
            {  
                transform.rotation = Quaternion.Euler(0, 180,0); 
            }  
            else  
            {  
                transform.rotation = Quaternion.Euler(0, 0,0);
            }  
        }  
    
        private void FixedUpdate()
        {
            Vector2 velocity = new Vector2(
                Input.GetAxisRaw(Horizontal),
                Input.GetAxisRaw(Vertical));

            bool isRunning = velocity.magnitude > 0;
            _animator.SetBool(Run, isRunning);

            if ((_faceDirection.x < 0 && velocity.x > 0) ||
                (_faceDirection.x > 0 && velocity.x < 0) && isRunning)
            {
                _animator.SetFloat(RunMultiplier, -_defaultSpeed);
            }
            else
            {
                _animator.SetFloat(RunMultiplier, _defaultSpeed);
            }
        
            _body2D.velocity = velocity.normalized * _speed;
        }
    }
}
"
