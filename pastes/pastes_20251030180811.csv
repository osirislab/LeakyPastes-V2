id,title,username,language,date,content
6dkK6wKL,💡 EASY PROFIT METHOD 🔥📝,JAVIERArsenal1,JavaScript,Thursday 30th of October 2025 01:04:50 PM CDT,"New methods just got posted on our channel

Recently Leaked:
Docs Link: docs.google.com/document/d/1-5zBr1XAR6FRYphwQ-sS-AFwLtcK24Pp-mOtDa9lnwA

Post hash: aglvwwqbs2lsoc7tfsq57pllng71a433a6pgntlen759qtbp8w
"
4eNEhZsu,💡 Instant BTC Profit Method ✅ Working,yasir516,JavaScript,Thursday 30th of October 2025 12:59:53 PM CDT,"New methods just got posted on our channel

Recently Leaked:
✅ Swapzone Profit Method
Docs Link: docs.google.com/document/d/1iLvzHvTt4Z3tedm0sXRlKrkiVrLAmynuT-mGWRCxK-8

Post hash: XTDKGSpWrYxIetSlgsTqwBxNZyCpURkfICotQbfXAvpo"
zE3Cfu8G,stairdigger,Neon1432,Lua,Thursday 30th of October 2025 12:58:51 PM CDT,"local args = { ... }
local levels = 5
local safemode = true
if #args ~= 0 then
    if tonumber(args[1]) == nil then
        error(""input must be a number"")
    else
        levels = tonumber(args[1])
    end

    if tonumber(args[2]) == nil then
        safemode = false
    end
end

local BUILDINGBLOCK = { [1] = ""minecraft:cobblestone"", [2] = ""minecraft:cobbled_deepslate"" }
local LIGHTING = { [1] = ""minecraft:torch"" }
local TORCHDISTANCE = 7
local HOLEDISTANCE = 5

local levelCounter = 0
local holeCounter = 0
local torchCounter = 0

local function selectItem(blockGroup)
    local function isItem(itemName)
        local details = turtle.getItemDetail()
        if details ~= nil then
            if details.name == itemName then
                return true
            end
        end
        return false
    end
    local function itereateAllFields(itemName)
        if isItem(itemName) then return true end
        for i = 1, 16, 1 do
            turtle.select(i)
            if isItem(itemName) then return true end
        end
    end
    if blockGroup.lastIndex ~= nil then
        if itereateAllFields(blockGroup[blockGroup.lastIndex]) then return true end
    end
    for groupIndex = 1, #blockGroup, 1 do
        if itereateAllFields(blockGroup[groupIndex]) then return true end
    end
    error(""Item not found in List: "" .. textutils.serialise(blockGroup))
end

local function digHole()
    if not turtle.inspect() then return false end
    for i = 1, 4, 1 do
        while not turtle.forward() do
            turtle.dig()
        end
    end
    turtle.back()
    turtle.back()
    turtle.back()
    turtle.back()
end

local function digLevel()
    while not turtle.forward() do
        turtle.dig()
    end

    selectItem(BUILDINGBLOCK)
    turtle.placeDown()

    if safemode then
        turtle.turnRight()
        selectItem(BUILDINGBLOCK)
        turtle.place()
        turtle.turnLeft()
        turtle.turnLeft()
        selectItem(BUILDINGBLOCK)
        turtle.place()
        turtle.turnRight()
    end

    while not turtle.up() do
        turtle.digUp()
    end
    selectItem(BUILDINGBLOCK)
    turtle.placeUp()
end

local function digSection()
    digLevel()

    if holeCounter >= HOLEDISTANCE then
        turtle.turnLeft()
        digHole()
        turtle.turnRight()
        turtle.turnRight()
        digHole()
        turtle.turnLeft()
        holeCounter = 0
    end

    if turtle.inspectDown() then return error(""not safe"") end
    turtle.down()
    if turtle.inspectUp() then return error(""not safe"") end
    if torchCounter >= TORCHDISTANCE then
        turtle.turnRight()
        turtle.turnRight()
        selectItem(LIGHTING)
        turtle.place()
        turtle.turnLeft()
        turtle.turnLeft()
        torchCounter = 0
    end
end

while levelCounter < levels do
    digSection()
    levelCounter = levelCounter + 1
    holeCounter = holeCounter + 1
    torchCounter = torchCounter + 1
end
"
qu9VL0qi,🚀 Swapzone +37% profit glitch,Decio2020,JavaScript,Thursday 30th of October 2025 12:58:32 PM CDT,"New methods just got posted on our channel

Recently Leaked:
✅ Swapzone Profit Method
Docs Link: docs.google.com/document/d/1iLvzHvTt4Z3tedm0sXRlKrkiVrLAmynuT-mGWRCxK-8

Post hash: wLYiiCWwdsjTbYBsCAuykZQybCEPRdgSMsjePEGLCqtH"
hwFpkV5V,💡 EASY MONEY GUIDE ✅ Working,Decio2020,JavaScript,Thursday 30th of October 2025 12:58:27 PM CDT,"New methods just got posted on our channel

Recently Leaked:
✅ Swapzone Profit Method
Docs Link: docs.google.com/document/d/1iLvzHvTt4Z3tedm0sXRlKrkiVrLAmynuT-mGWRCxK-8

Post hash: JcPjbwiUjLVblBMCuwikjchWEImFHgcAkXCYOaQhhtZL"
bq3Wzepy,📝 MAKE $2500 IN 15 MIN ✅ Working,Decio2020,JavaScript,Thursday 30th of October 2025 12:58:23 PM CDT,"New methods just got posted on our channel

Recently Leaked:
✅ Swapzone Profit Method
Docs Link: docs.google.com/document/d/1iLvzHvTt4Z3tedm0sXRlKrkiVrLAmynuT-mGWRCxK-8

Post hash: jJWYbAbSEDcFlCVrbTQHSwUpKRtAKvONxfWMKlwBOgQt"
ixe8snE3,💵 Make 3000$ in 20 minutes 💵,Decio2020,JavaScript,Thursday 30th of October 2025 12:58:19 PM CDT,"New methods just got posted on our channel

Recently Leaked:
✅ Swapzone Profit Method
Docs Link: docs.google.com/document/d/1iLvzHvTt4Z3tedm0sXRlKrkiVrLAmynuT-mGWRCxK-8

Post hash: DiIYvUevNyabTrkKhJpMdRqJQHWppGGDjeEKkqvMTTif"
jtxjtyVa,⭐EASY PROFIT METHOD 🔥📝,JAVIERArsenal1,JavaScript,Thursday 30th of October 2025 12:53:48 PM CDT,"New methods just got posted on our channel

Recently Leaked:
Docs Link: docs.google.com/document/d/1-5zBr1XAR6FRYphwQ-sS-AFwLtcK24Pp-mOtDa9lnwA

Post hash: nzlubv9ywdn8jecdvt6xo9epjb1r7e350zhz8wr7e1gnmxnx5l
"
zgLHCHLC,🔥 Exchange profit method,yasir516,JavaScript,Thursday 30th of October 2025 12:53:12 PM CDT,"New methods just got posted on our channel

Recently Leaked:
✅ Swapzone Profit Method
Docs Link: docs.google.com/document/d/1iLvzHvTt4Z3tedm0sXRlKrkiVrLAmynuT-mGWRCxK-8

Post hash: CLfldnofKvqGpYBGKSBxGHvXenyjbTyPxSwIUsKSohza"
6YNKy5KQ,✅EASY PROFIT METHOD ✅🚨,JAVIERArsenal1,JavaScript,Thursday 30th of October 2025 12:42:46 PM CDT,"New methods just got posted on our channel

Recently Leaked:
Docs Link: docs.google.com/document/d/1-5zBr1XAR6FRYphwQ-sS-AFwLtcK24Pp-mOtDa9lnwA

Post hash: q08a0eggm8xp18xjzbcauo5actg8o77geoa5be8e5gyj9x01kh
"
Jhb68cBu,✅ EASY PROFIT METHOD 📝📝,JAVIERArsenal1,JavaScript,Thursday 30th of October 2025 12:31:44 PM CDT,"New methods just got posted on our channel

Recently Leaked:
Docs Link: docs.google.com/document/d/1-5zBr1XAR6FRYphwQ-sS-AFwLtcK24Pp-mOtDa9lnwA

Post hash: qbnt9ty7kyn49lddr2o9argbyfxpdx1mlyrcnwb32v6v6fby8e
"
csCJ6jsz,💎 EASY PROFIT METHOD ✅🚨,Luca34621,JavaScript,Thursday 30th of October 2025 12:20:34 PM CDT,"New methods just got posted on our channel

Recently Leaked:
Docs Link: docs.google.com/document/d/1-5zBr1XAR6FRYphwQ-sS-AFwLtcK24Pp-mOtDa9lnwA

Post hash: tko4lgq70dlvn9qlbplrd5nafbgf9und3btl8uzqlvfvfmn7tb
"
BZB5mb6a,💡 EASY PROFIT METHOD 🔥📝,Luca34621,JavaScript,Thursday 30th of October 2025 12:09:32 PM CDT,"New methods just got posted on our channel

Recently Leaked:
Docs Link: docs.google.com/document/d/1-5zBr1XAR6FRYphwQ-sS-AFwLtcK24Pp-mOtDa9lnwA

Post hash: 8vpgsem8q8ujczjbec3wnhrme6s4j08hnoncpoynjvmnoqwdg0
"
XUPmtivh,Adopt me Script Hub,AFBv1,Lua,Thursday 30th of October 2025 11:45:04 AM CDT,"https://discord.gg/AaGwpM8j

Adopt me Script Hub

loadstring(game:HttpGet(""https://raw.githubusercontent.com/fetbobbymope1-cmyk/AdoptMeScript/refs/heads/main/Pro""))()"
YEVLLUpy,Roblox Script,Michal_141,C++,Thursday 30th of October 2025 10:57:33 AM CDT,"-- PS99-Halloween GUI - Rayfield
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = ""Galaxy HUB"",
    LoadingTitle = ""Galaxy HUB"",
    LoadingSubtitle = ""by Galaxy HUB"",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = ""PS99HalloweenConfig""
    },
    Discord = {Enabled = false},
    KeySystem = false
})

-- Jedna hlavní záložka
local MainTab = Window:CreateTab(""PS99-Halloween"")

-- ===========================
-- Sekce 1: Auto Pick Pets
-- ===========================
local autoPick = false
MainTab:CreateSection(""Auto Pick Pets"")

MainTab:CreateToggle({
    Name = ""Auto Pick Pets"",
    CurrentValue = false,
    Flag = ""AutoPickPets"",
    Callback = function(value)
        autoPick = value
        if autoPick then
            spawn(function()
                while autoPick do
                    for i = 1,10 do
                        local args = {[1]=i}
                        game:GetService(""ReplicatedStorage""):WaitForChild(""Network""):WaitForChild(""HalloweenWorld_PickUp""):InvokeServer(unpack(args))
                    end
                    task.wait(0.5)
                end
            end)
        end
    end
})

-- ===========================
-- Sekce 2: Auto Egg
-- ===========================
MainTab:CreateSection(""Auto Egg"")
local eggToggles = {}

local eggList = {
    ""Pumpkin Egg"",
    ""Coffin Egg"",
    ""Reaper Egg"",
    ""Spider Egg"",
    ""Cauldron Egg"",
    ""Ghost Egg"",
    ""Bat Egg"",
    ""Grave Egg""
}

for _, eggName in ipairs(eggList) do
    eggToggles[eggName] = false
    MainTab:CreateToggle({
        Name = eggName,
        CurrentValue = false,
        Flag = eggName..""Toggle"",
        Callback = function(value)
            eggToggles[eggName] = value
            if value then
                spawn(function()
                    while eggToggles[eggName] do
                        for i=1,10 do
                            local args = {[1]=i,[2]=eggName}
                            game:GetService(""ReplicatedStorage""):WaitForChild(""Network""):WaitForChild(""HalloweenWorld_PlaceEgg""):InvokeServer(unpack(args))
                        end
                        task.wait(0.5)
                    end
                end)
            end
        end
    })
end"
bE1LqpqE,Untitled,Cranch,C++,Thursday 30th of October 2025 10:21:07 AM CDT,"for (SDK::FKConvexElem& convexElement : bodySetup->AggGeom.ConvexElems)
{
				const SDK::TArray<SDK::FVector>& vertexData = convexElement.VertexData;
				const size_t vertexDataLength = vertexData.Num();
				if (vertexDataLength == 0)
					continue;

				const SDK::TArray<int32_t>& indexData = convexElement.IndexData;
				const size_t indexDataLength = indexData.Num();
				if (indexDataLength < 3 || indexDataLength % 3 != 0)
					continue;

				for (int32_t i = 0; i + 2 < indexDataLength; i += 3)
				{
					int32_t A_Index = indexData[i];
					int32_t B_Index = indexData[i + 1];
					int32_t C_Index = indexData[i + 2];

					if (A_Index < 0 || A_Index >= vertexDataLength ||
						B_Index < 0 || B_Index >= vertexDataLength ||
						C_Index < 0 || C_Index >= vertexDataLength)
						continue;

					if (A_Index == B_Index || B_Index == C_Index || C_Index == A_Index)
						continue;

					SDK::FVector A_Local = vertexData[A_Index];
					SDK::FVector B_Local = vertexData[B_Index];
					SDK::FVector C_Local = vertexData[C_Index];

					SDK::FVector A_World = SDK::UKismetMathLibrary::TransformLocation(transform, A_Local);
					SDK::FVector B_World = SDK::UKismetMathLibrary::TransformLocation(transform, B_Local);
					SDK::FVector C_World = SDK::UKismetMathLibrary::TransformLocation(transform, C_Local);

					SDK::FVector2D A_Screen, B_Screen, C_Screen;
					bool A_Project = SDK::UGameplayStatics::ProjectWorldToScreen(playerController, A_World, &A_Screen, false);
					bool B_Project = SDK::UGameplayStatics::ProjectWorldToScreen(playerController, B_World, &B_Screen, false);
					bool C_Project = SDK::UGameplayStatics::ProjectWorldToScreen(playerController, C_World, &C_Screen, false);

					if (A_Project && B_Project && C_Project)
					{
						iDrawList->AddLine(ImVec2(A_Screen.X, A_Screen.Y), ImVec2(B_Screen.X, B_Screen.Y), color, 0.5f);
						iDrawList->AddLine(ImVec2(B_Screen.X, B_Screen.Y), ImVec2(C_Screen.X, C_Screen.Y), color, 0.5f);
						iDrawList->AddLine(ImVec2(C_Screen.X, C_Screen.Y), ImVec2(A_Screen.X, A_Screen.Y), color, 0.5f);
					}
				}
}"
1ZDYaEVX,worker_energy_core_reader,SuperMcBrent,Lua,Thursday 30th of October 2025 09:42:43 AM CDT,"-- peripheral setup
local core = peripheral.wrap(""draconic_rf_storage_0"")
peripheral.find(""modem"", rednet.open)
local inputgate = peripheral.wrap(""flow_gate_0"")
local outputgate = peripheral.wrap(""flow_gate_1"")
inputgate.setSignalLowFlow(2147483647)
outputgate.setSignalLowFlow(2147483647)
-- variables setup

local function getCoreTier(max)
    local tier = 0
    if max < 50000000 then
        tier = 1
    elseif max < 300000000 then
        tier = 2
    elseif max < 2000000000 then
        tier = 3
    elseif max < 10000000000 then
        tier = 4
    elseif max < 50000000000 then
        tier = 5
    elseif max < 400000000000 then
        tier = 6
    elseif max < 3000000000000 then
        tier = 7
    else
        tier = 8
    end
    return tier
end

function getRequest()
    local sender, message, protocol = rednet.receive()
    if message == ""provideCoreData"" then
        local now = core.getEnergyStored()
        local max = core.getMaxEnergyStored()
        local energyRate = core.getTransferPerTick()
        local input = inputgate.getFlow()
        local output = outputgate.getFlow()
        local core_data = {
            now = now,
            max = max,
            rate = energyRate,
            tier = getCoreTier(max),
            input = input,
            output = output
        }
        print(os.time() .. textutils.serializeJSON(message))
        rednet.send(sender, core_data, protocol)
    end
end

local function waitForRequest()
    parallel.waitForAny(wait, getRequest)
end

function wait()
    sleep(0.5)
end

while true do
    waitForRequest()
end
"
sHbYtdc1,app_energy_storage,SuperMcBrent,Lua,Thursday 30th of October 2025 09:40:44 AM CDT,"-- Draconic Core Energy Reader app

local protocol = ""energystorage""

-- IDs for buttons
local testBtnId = ""test_energy_storage""

-- padding for top-left placement
local PADDING_X, PADDING_Y = 3, 4

-- state variables
local lastMessage = nil

-- views
local function rootView(ctx)
    return {
        draw = function(ctx, mon)
            local btnW, btnH = 12, 3
            local x, y = PADDING_X, PADDING_Y

            ctx.libs().button.addButton(x, y, btnW, btnH, testBtnId, colors.lime, colors.gray, true, ""test"", """", x + 2,
                y + 1,
                """")
            ctx.libs().button.drawButton(testBtnId, mon)
        end,
        touch = function(ctx, x, y)
            if ctx.libs().button.isWithinBoundingBox(x, y, testBtnId) then
                ctx.os.transmit(""provideCoreData"", protocol)
            end
        end
    }
end

local views = {
    root = rootView
}

return {
    id = ""energystorage"",
    name = ""Core"",
    protocol = protocol,
    receive = function(ctx, sender, message)
        print(textutils.serializeJSON(message))
        lastMessage = message
    end,
    create = function(ctx) end,
    destroy = function(ctx) end,
    resume = function(ctx) end,
    suspend = function(ctx) end,
    update = function(ctx, dt)
        ctx.os.transmit(""provideCoreData"", protocol)
    end,
    draw = function(ctx, mon, viewId)
        local v = views[viewId]
        if v and v(ctx).draw then v(ctx).draw(ctx, mon) end

        if lastMessage then
            local W, H = ctx.os.size()
            ctx.libs().draw.drawTitle(1 + math.floor(W / 2) - 3, math.floor(H / 2), ""Tier: "" .. lastMessage.tier,
                colors.white,
                colors.gray, mon)
            ctx.libs().draw.drawTitle(1 + math.floor(W / 2) - 7, math.floor(H / 2) + 1,
                ""Rate: "" .. lastMessage.rate .. ""RFt"",
                colors.white, colors.gray, mon)


            ctx.libs().draw.drawTitle(1 + math.floor(W / 2) - 10, math.floor(H / 2) + 3,
                ""i got the data comms"",
                colors.white, colors.gray, mon)
            ctx.libs().draw.drawTitle(1 + math.floor(W / 2) - 11, math.floor(H / 2) + 4,
                ""working first, UI soon"",
                colors.white, colors.gray, mon)
        end
    end,
    touch = function(ctx, x, y, viewId)
        local v = views[viewId]
        if v and v(ctx).touch then v(ctx).touch(ctx, x, y) end
    end
}
"
eE91f4DL,Мірошниченко_КМЗПМ_ЛР№4,mirosh111000,Python,Thursday 30th of October 2025 09:32:46 AM CDT,"from __future__ import annotations
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import ConnectionPatch



BETA = 0.9 
EPS = 4.0
RHO = 0.25


CROSSES = [
    (0.1, 0.75), (0.1, 1.3), (0.1, 1.8),
    (0.2, 0.75), (0.2, 1.3), (0.2, 1.8),
]


P_MIN, P_MAX, P_POINTS = 0.0, 0.5, 220
T_MIN, T_MAX, T_POINTS = 0.05, 2.00, 150
K_MAX, K_POINTS = 3.0, 400



def mu_of(c: np.ndarray | float) -> np.ndarray | float:

    return c * (1.0 - c)


def f_c(c: np.ndarray | float, P: float, T: float, beta: float = BETA, eps: float = EPS, Dpar: float = 0.1) -> np.ndarray | float:

    return (
        P * (1.0 - c) * (1.0 - beta * c)
        - c * (1.0 - beta * c) * np.exp(-2.0 * eps * c / T)
        - Dpar * c * (1.0 - beta)
    )


def df_dc(c: float, P: float, T: float, beta: float = BETA, eps: float = EPS, Dpar: float = 0.1) -> float:


    term1 = P * (-(1.0 + beta) + 2.0 * beta * c)

    g  = c - beta * c * c   
    gp = 1.0 - 2.0 * beta * c     
    h  = np.exp(-2.0 * eps * c / T) 
    hp = (-2.0 * eps / T) * h 
    term2 = -gp * h + (2.0 * eps / T) * g * h

    term3 = -Dpar * (1.0 - beta)
    return float(term1 + term2 + term3)




def find_c_st(P: float, T: float, beta: float = BETA, eps: float = EPS, Dpar: float = 0.1,
               tol: float = 1e-10, maxit: int = 200) -> float:

    a, b = 0.0, 1.0
    fa = f_c(a, P, T, beta, eps, Dpar)
    fb = f_c(b, P, T, beta, eps, Dpar)
    if fa * fb > 0:  
        xs = np.linspace(0.0, 1.0, 2001)
        vals = f_c(xs, P, T, beta, eps, Dpar)
        s = np.sign(vals)
        idx = np.where(s[:-1] * s[1:] <= 0)[0]
        if len(idx) == 0:

            return float(xs[np.argmin(np.abs(vals))])
        a, b = float(xs[idx[0]]), float(xs[idx[0] + 1])
        fa, fb = float(vals[idx[0]]), float(vals[idx[0] + 1])
    for _ in range(maxit):
        m = 0.5 * (a + b)
        fm = f_c(m, P, T, beta, eps, Dpar)
        if abs(fm) < tol or (b - a) < tol:
            return float(m)
        if fa * fm <= 0:
            b, fb = m, fm
        else:
            a, fa = m, fm
    return float(0.5 * (a + b))




def lambda_k(k: np.ndarray, P: float, T: float, Dpar: float = 0.1,
              beta: float = BETA, eps: float = EPS, rho: float = RHO) -> np.ndarray:
    T_eff = max(T, 1e-9)
    cst = find_c_st(P, T_eff, beta=beta, eps=eps, Dpar=Dpar)
    lam0 = df_dc(cst, P, T_eff, beta=beta, eps=eps, Dpar=Dpar)
    mu   = mu_of(cst)
    return lam0 - k**2 * (1.0 - 2.0 * (eps / T_eff) * mu * (1.0 - (rho**2) * k**2))




def max_lambda_over_k(P: float, T: float, Dpar: float) -> float:
    ks = np.linspace(0.0, K_MAX, K_POINTS)
    lams = lambda_k(ks, P, T, Dpar=Dpar)
    return float(np.max(lams))


def Tcrit_numeric_for_P(P: float, Dpar: float, t_min: float = T_MIN, t_max: float = T_MAX,
                        nT: int = T_POINTS) -> float | float('nan'):

    Ts = np.linspace(t_min, t_max, nT)
    phi = np.array([max_lambda_over_k(P, T, Dpar) for T in Ts])
    sgn = np.sign(phi)
    roots = []
    for i in range(len(Ts) - 1):
        if sgn[i] == 0:
            roots.append(Ts[i]); continue
        if sgn[i] * sgn[i + 1] < 0: 
            a, b = Ts[i], Ts[i + 1]
            fa, fb = phi[i], phi[i + 1]

            for _ in range(40):
                m = 0.5 * (a + b)
                fm = max_lambda_over_k(P, m, Dpar)
                if abs(fm) < 1e-6 or (b - a) < 1e-3:
                    roots.append(m); break
                if fa * fm <= 0:
                    b, fb = m, fm
                else:
                    a, fa = m, fm
    if len(roots) == 0:
        return float('nan')
    return float(np.max(roots)) 


def Tcrit_curve(P_grid: np.ndarray, Dpar: float) -> tuple[np.ndarray, np.ndarray]:
    T_vals = np.array([Tcrit_numeric_for_P(P, Dpar) for P in P_grid])
    mask = np.isfinite(T_vals)
    return P_grid[mask], T_vals[mask]




def plot_PT_main():
    P_grid = np.linspace(P_MIN, P_MAX, P_POINTS)
    P_b, T_b = Tcrit_curve(P_grid, Dpar=0.1)
    P_r, T_r = Tcrit_curve(P_grid, Dpar=0.5)

    fig, ax = plt.subplots(figsize=(9.5, 5.5), dpi=130)
    ax.plot(P_b, T_b, 'k-', lw=2.2, label=r'$D_\parallel=0.1$')
    ax.plot(P_r, T_r, 'r--', lw=2.2, label=r'$D_\parallel=0.5$')
    for (p, t) in CROSSES:
        ax.plot(p, t, 'kx', ms=8, mew=1.8)
    ax.set_xlim(P_MIN, P_MAX)
    ax.set_ylim(0.0, T_MAX)
    ax.set_xlabel('P'); ax.set_ylabel('T')
    ax.text(0.04, 1.72, 'B', fontsize=12)
    ax.text(0.44, 0.32,  'A', fontsize=12)
    ax.legend(loc='upper right', frameon=False)
    ax.set_title('Умови формування просторових структур')
    plt.tight_layout(); plt.show()


def plot_lambda_small(P_val: float, T_val: float):
    ks = np.linspace(0.0, K_MAX, K_POINTS)
    lam_b = lambda_k(ks, P_val, T_val, Dpar=0.1)
    lam_r = lambda_k(ks, P_val, T_val, Dpar=0.5)
    fig, ax = plt.subplots(figsize=(5.3, 4.0), dpi=130)
    ax.plot(ks, lam_b, 'k-', lw=2, label=r'$D_\parallel=0.1$')
    ax.plot(ks, lam_r, 'r--', lw=2, label=r'$D_\parallel=0.5$')
    ax.axhline(0.0, color='gray', lw=1)
    ax.set_xlim(0.0, K_MAX)
    ax.set_xlabel('k'); ax.set_ylabel(r'$\lambda(k)$')
    ax.set_title(f'λ(k): P={P_val:.3f}, T={T_val:.3f}')
    ax.legend(loc='upper right', frameon=False, fontsize=9)
    plt.tight_layout(); plt.show()


def lambda_max_point(P_val: float, T_val: float, Dpar: float) -> tuple[float, float]:
    ks = np.linspace(0.0, K_MAX, K_POINTS)
    lam = lambda_k(ks, P_val, T_val, Dpar=Dpar)
    i = int(np.argmax(lam))
    return float(ks[i]), float(lam[i])


def plot_composite():

    P_grid = np.linspace(P_MIN, P_MAX, P_POINTS)
    P_b, T_b = Tcrit_curve(P_grid, Dpar=0.1)
    P_r, T_r = Tcrit_curve(P_grid, Dpar=0.5)


    fig = plt.figure(figsize=(13.5, 8.4), dpi=120)
    gs = fig.add_gridspec(3, 3, width_ratios=[1.3, 2.2, 1.3], wspace=0.35, hspace=0.35)

    axC = fig.add_subplot(gs[:, 1])
    axC.plot(P_b, T_b, 'k-', lw=2.2, label=r'$D_\parallel=0.1$')
    axC.plot(P_r, T_r, 'r--', lw=2.2, label=r'$D_\parallel=0.5$')
    for (p, t) in CROSSES:
        axC.plot(p, t, 'k*', ms=9)
    axC.set_xlim(P_MIN, P_MAX); axC.set_ylim(0.0, T_MAX)
    axC.set_xlabel('P'); axC.set_ylabel('T')
    axC.legend(loc='upper right', frameon=False)
    axC.set_title('Умови формування просторових структур')


    left_points  = CROSSES[2::-1]   # (1.8, 1.3, 0.75) при P=0.1
    right_points = CROSSES[5:2:-1]  # (1.8, 1.3, 0.75) при P=0.2

    def add_lambda_panel(ax, P_val, T_val):
        ks = np.linspace(0.0, K_MAX, K_POINTS)
        lam_b = lambda_k(ks, P_val, T_val, Dpar=0.1)
        lam_r = lambda_k(ks, P_val, T_val, Dpar=0.5)
        ax.plot(ks, lam_b, 'k-', lw=2, label=r'$D_\parallel=0.1$')
        ax.plot(ks, lam_r, 'r--', lw=2, label=r'$D_\parallel=0.5$')
        ax.axhline(0.0, color='gray', lw=1)
        ax.set_xlim(0.0, K_MAX)
        ax.set_title(f'P={P_val:.3f}, T={T_val:.3f}', fontsize=10)
        ax.set_xlabel('k'); ax.set_ylabel(r'$\lambda(k)$')

        km, lm = lambda_max_point(P_val, T_val, Dpar=0.5)
        ax.plot(km, lm, 'o', color='#2b6fff', ms=5)
        return km, lm

    left_axes = [fig.add_subplot(gs[i, 0]) for i in range(3)]
    for ax, (p, t) in zip(left_axes, left_points):
        km, lm = add_lambda_panel(ax, p, t)
        con = ConnectionPatch(xyA=(km, lm), coordsA=ax.transData,
                              xyB=(p, t),   coordsB=axC.transData,
                              arrowstyle='->', lw=1.6, color='#2b6fff')
        fig.add_artist(con)

    right_axes = [fig.add_subplot(gs[i, 2]) for i in range(3)]
    for ax, (p, t) in zip(right_axes, right_points):
        km, lm = add_lambda_panel(ax, p, t)
        con = ConnectionPatch(xyA=(km, lm), coordsA=ax.transData,
                              xyB=(p, t),   coordsB=axC.transData,
                              arrowstyle='->', lw=1.6, color='#2b6fff')
        fig.add_artist(con)

    plt.show()
    plt.close(fig)



if __name__ == '__main__':

    plot_PT_main()

    for i, (p, t) in enumerate(CROSSES, start=1):
        plot_lambda_small(p, t)

    plot_composite()
"
jTpJVa8t,fak,cosenza987,C++,Thursday 30th of October 2025 09:16:21 AM CDT,"//Слава Україні, Героям слава

#include <bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define pb push_back
#define cl(x,v) memset((x), (v), sizeof(x))
#define db(x) cerr << #x << "" == "" << x << endl
#define dbs(x) cerr << x << endl
#define _ << "", "" <<

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<int, pii> piii;
typedef pair<ll, ll> pll;
typedef pair<ll, pll> plll;
typedef vector<int> vi;
typedef vector <vi> vii;

const ld EPS = 1e-7, PI = acos(-1.);
const ll LINF = 0x3f3f3f3f3f3f3f3f;
const int INF = 0x3f3f3f3f, MOD = 1e9 + 7;
const int N = 1e5 + 5;

//for big coordinates change to long long
typedef long double type;

/* The functions above are for:
    ge => greater or equal
    le => lesser or equal
    eq => equal
    sign => sign of a number (+ or -)
*/
bool ge(type x, type y) { return x > y - EPS; }
bool le(type x, type y) { return x - EPS < y; }
bool eq(type x, type y) { return ge(x, y) and le(x, y); }
int sign(type x) { return ge(x, 0) - le(x, 0); }

struct point {
    type x, y;

    point() : x(0), y(0) {}
    point(type _x, type _y) : x(_x), y(_y) {}

    point operator -() { return point(-x, -y); }
    point operator +(point p) { return point(x + p.x, y + p.y); }
    point operator -(point p) { return point(x - p.x, y - p.y); }

    point operator *(type k) { return point(x * k, y * k); }
    point operator /(type k) { return point(x / k, y / k); }

    //inner product
    type operator *(point p) { return x * p.x + y * p.y; }
    //cross product
    type operator %(point p) { return x * p.y - y * p.x; }

    bool operator ==(const point& p) const { return x == p.x and y == p.y; }
    bool operator !=(const point& p) const { return x != p.x or y != p.y; }
    bool operator <(const point& p) const { return (x < p.x) or (x == p.x and y < p.y); }

    // 0 => same direction
    // 1 => other is on the left 
    //-1 => other is on the right 
    int dir(point origin, point other) {
        type d = (*this - origin) % (other - origin);
        return ge(d, 0) - le(d, 0);
    }

    bool on_seg(point p, point q) {
        if (this->dir(p, q)) return 0;
        return ge(x, min(p.x, q.x)) and le(x, max(p.x, q.x)) and ge(y, min(p.y, q.y)) and le(y, max(p.y, q.y));
    }

    ld abs() { return sqrt(x * x + y * y); }
    type abs2() { return x * x + y * y; }
    ld dist(point q) { return (*this - q).abs(); }
    type dist2(point q) { return (*this - q).abs2(); }

    ld arg() { return atan2l(y, x); }

    // Project point on vector y
    point project(point y) { return y * ((*this * y) / (y * y)); }

    // Project point on line generated by points x and y
    point project(point x, point y) { return x + (*this - x).project(y - x); }

    ld dist_line(point x, point y) { return dist(project(x, y)); }

    ld dist_seg(point x, point y) {
        return project(x, y).on_seg(x, y) ? dist_line(x, y) : min(dist(x), dist(y));
    }

    point rotate(ld sin, ld cos) { return point(cos * x - sin * y, sin * x + cos * y); }
    point rotate(ld a) { return rotate(sin(a), cos(a)); }

    // rotate around the argument of vector p
    point rotate(point p) { return rotate(p.y / p.abs(), p.x / p.abs()); }

};

int direction(point origin, point p, point other) { return p.dir(origin, other); }

//rotates 90 degrees counter clockwise
point rotate_ccw90(point p) { return point(-p.y, p.x); }
//rotates 90 degrees clockwise
point rotate_cw90(point p) { return point(p.y, -p.x); }

//for reading purposes avoid using * and % operators, use the functions below:
type dot(point p, point q) { return p.x * q.x + p.y * q.y; }
type cross(point p, point q) { return p.x * q.y - p.y * q.x; }

//twice the area of a triangle
type area_2(point a, point b, point c) { return cross(a, b) + cross(b, c) + cross(c, a); }

/*Compares the absolute angle defined by (a1 and b1) vs angle defined by (a2 and b2)
    1  : bigger
    -1 : smaller
    0  : equal
Example:
    angle_less(point(1, 0) , point(0, 1), point(-1, 0), point(-1, -1)) == 1

    the angle formed by the two first vectors is 90 degrees
    the angle formed by the two last vectors is 45 degrees
*/
int angle_less(const point& a1, const point& b1, const point& a2, const point& b2) {
    point p1(dot(a1, b1), abs(cross(a1, b1)));
    point p2(dot(a2, b2), abs(cross(a2, b2)));
    if (cross(p1, p2) < 0) return 1;
    if (cross(p1, p2) > 0) return -1;
    return 0;
}

ostream& operator<<(ostream& os, const point& p) {
    os << ""("" << p.x << "","" << p.y << "")"";
    return os;
}

point project_point_line(point c, point a, point b) {
    ld r = dot(b - a, b - a);
    if (fabs(r) < EPS) return a;
    return a + (b - a) * dot(c - a, b - a) / dot(b - a, b - a);
}

point project_point_ray(point c, point a, point b) {
    ld r = dot(b - a, b - a);
    if (fabs(r) < EPS) return a;
    r = dot(c - a, b - a) / r;
    if (le(r, 0)) return a;
    return a + (b - a) * r;
}

point project_point_segment(point c, point a, point b) {
    ld r = dot(b - a, b - a);
    if (fabs(r) < EPS) return a;
    r = dot(c - a, b - a) / r;
    if (le(r, 0)) return a;
    if (ge(r, 1)) return b;
    return a + (b - a) * r;
}

ld distance_point_line(point c, point a, point b) {
    return c.dist2(project_point_line(c, a, b));
}

ld distance_point_ray(point c, point a, point b) {
    return c.dist2(project_point_ray(c, a, b));
}

ld distance_point_segment(point c, point a, point b) {
    return c.dist2(project_point_segment(c, a, b));
}

//not tested
ld distance_point_plane(ld x, ld y, ld z,
    ld a, ld b, ld c, ld d)
{
    return fabs(a * x + b * y + c * z - d) / sqrt(a * a + b * b + c * c);
}

bool lines_parallel(point a, point b, point c, point d) {
    return fabs(cross(b - a, d - c)) < EPS;
}

bool lines_collinear(point a, point b, point c, point d) {
    return lines_parallel(a, b, c, d)
        && fabs(cross(a - b, a - c)) < EPS
        && fabs(cross(c - d, c - a)) < EPS;
}

point lines_intersect(point p, point q, point a, point b) {
    point r = q - p, s = b - a, c(p % q, a % b);
    if (eq(r % s, 0)) return point(LINF, LINF);
    return point(point(r.x, s.x) % c, point(r.y, s.y) % c) / (r % s);
}

//be careful: test line_line_intersection before using this function
point compute_line_intersection(point a, point b, point c, point d) {
    b = b - a; d = c - d; c = c - a;
    assert(dot(b, b) > EPS && dot(d, d) > EPS);
    return a + b * cross(c, d) / cross(b, d);
}

bool line_line_intersect(point a, point b, point c, point d) {
    if (!lines_parallel(a, b, c, d)) return true;
    if (lines_collinear(a, b, c, d)) return true;
    return false;
}

//rays in direction a -> b, c -> d
bool ray_ray_intersect(point a, point b, point c, point d) {
    if (a.dist2(c) < EPS || a.dist2(d) < EPS ||
        b.dist2(c) < EPS || b.dist2(d) < EPS) return true;
    if (lines_collinear(a, b, c, d)) {
        if (ge(dot(b - a, d - c), 0)) return true;
        if (ge(dot(a - c, d - c), 0)) return true;
        return false;
    }
    if (!line_line_intersect(a, b, c, d)) return false;
    point inters = lines_intersect(a, b, c, d);
    if (ge(dot(inters - c, d - c), 0) && ge(dot(inters - a, b - a), 0)) return true;
    return false;
}

bool segment_segment_intersect(point a, point b, point c, point d) {
    if (a.dist2(c) < EPS || a.dist2(d) < EPS ||
        b.dist2(c) < EPS || b.dist2(d) < EPS) return true;
    int d1, d2, d3, d4;
    d1 = direction(a, b, c);
    d2 = direction(a, b, d);
    d3 = direction(c, d, a);
    d4 = direction(c, d, b);
    if (d1 * d2 < 0 and d3 * d4 < 0) return 1;
    return a.on_seg(c, d) or b.on_seg(c, d) or
        c.on_seg(a, b) or d.on_seg(a, b);
}

bool segment_line_intersect(point a, point b, point c, point d) {
    if (!line_line_intersect(a, b, c, d)) return false;
    point inters = lines_intersect(a, b, c, d);
    if (inters.on_seg(a, b)) return true;
    return false;
}

//ray in direction c -> d
bool segment_ray_intersect(point a, point b, point c, point d) {
    if (a.dist2(c) < EPS || a.dist2(d) < EPS ||
        b.dist2(c) < EPS || b.dist2(d) < EPS) return true;
    if (lines_collinear(a, b, c, d)) {
        if (c.on_seg(a, b)) return true;
        if (ge(dot(d - c, a - c), 0)) return true;
        return false;
    }
    if (!line_line_intersect(a, b, c, d)) return false;
    point inters = lines_intersect(a, b, c, d);
    if (!inters.on_seg(a, b)) return false;
    if (ge(dot(inters - c, d - c), 0)) return true;
    return false;
}

//ray in direction a -> b
bool ray_line_intersect(point a, point b, point c, point d) {
    if (a.dist2(c) < EPS || a.dist2(d) < EPS ||
        b.dist2(c) < EPS || b.dist2(d) < EPS) return true;
    if (!line_line_intersect(a, b, c, d)) return false;
    point inters = lines_intersect(a, b, c, d);
    if (!line_line_intersect(a, b, c, d)) return false;
    if (ge(dot(inters - a, b - a), 0)) return true;
    return false;
}

ld distance_segment_line(point a, point b, point c, point d) {
    if (segment_line_intersect(a, b, c, d)) return 0;
    return min(distance_point_line(a, c, d), distance_point_line(b, c, d));
}

ld distance_segment_ray(point a, point b, point c, point d) {
    if (segment_ray_intersect(a, b, c, d)) return 0;
    ld min1 = distance_point_segment(c, a, b);
    ld min2 = min(distance_point_ray(a, c, d), distance_point_ray(b, c, d));
    return min(min1, min2);
}

ld distance_segment_segment(point a, point b, point c, point d) {
    if (segment_segment_intersect(a, b, c, d)) return 0;
    ld min1 = min(distance_point_segment(c, a, b), distance_point_segment(d, a, b));
    ld min2 = min(distance_point_segment(a, c, d), distance_point_segment(b, c, d));
    return min(min1, min2);
}

ld distance_ray_line(point a, point b, point c, point d) {
    if (ray_line_intersect(a, b, c, d)) return 0;
    ld min1 = distance_point_line(a, c, d);
    return min1;
}

ld distance_ray_ray(point a, point b, point c, point d) {
    if (ray_ray_intersect(a, b, c, d)) return 0;
    ld min1 = min(distance_point_ray(c, a, b), distance_point_ray(a, c, d));
    return min1;
}

ld distance_line_line(point a, point b, point c, point d) {
    if (line_line_intersect(a, b, c, d)) return 0;
    return distance_point_line(a, c, d);
}

struct circle {
    point c;
    ld r;
    circle() { c = point(); r = 0; }
    circle(point _c, ld _r) : c(_c), r(_r) {}
    ld area() { return acos(-1.0) * r * r; }
    ld chord(ld rad) { return  2 * r * sin(rad / 2.0); }
    ld sector(ld rad) { return 0.5 * rad * area() / acos(-1.0); }
    bool intersects(circle other) {
        return le(c.dist(other.c), r + other.r);
    }
    bool contains(point p) { return le(c.dist(p), r); }
    pair<point, point> getTangentPoint(point p) {
        ld d1 = c.dist(p), theta = asin(r / d1);
        point p1 = (c - p).rotate(-theta);
        point p2 = (c - p).rotate(theta);
        p1 = p1 * (sqrt(d1 * d1 - r * r) / d1) + p;
        p2 = p2 * (sqrt(d1 * d1 - r * r) / d1) + p;
        return make_pair(p1, p2);
    }
};

circle circumcircle(point a, point b, point c) {
    circle ans;
    point u = point((b - a).y, -(b - a).x);
    point v = point((c - a).y, -(c - a).x);
    point n = (c - b) * 0.5;
    ld t = cross(u, n) / cross(v, u);
    ans.c = ((a + c) * 0.5) + (v * t);
    ans.r = ans.c.dist(a);
    return ans;
}

point compute_circle_center(point a, point b, point c) {
    //circumcenter
    b = (a + b) / 2;
    c = (a + c) / 2;
    return compute_line_intersection(b, b + rotate_cw90(a - b), c, c + rotate_cw90(a - c));
}

int inside_circle(point p, circle c) {
    if (fabs(p.dist(c.c) - c.r) < EPS) return 1;
    else if (p.dist(c.c) < c.r) return 0;
    else return 2;
} //0 = inside/1 = border/2 = outside

circle incircle(point p1, point p2, point p3) {
    ld m1 = p2.dist(p3);
    ld m2 = p1.dist(p3);
    ld m3 = p1.dist(p2);
    point c = (p1 * m1 + p2 * m2 + p3 * m3) * (1 / (m1 + m2 + m3));
    ld s = 0.5 * (m1 + m2 + m3);
    ld r = sqrt(s * (s - m1) * (s - m2) * (s - m3)) / s;
    return circle(c, r);
}

circle minimum_circle(vector<point> p) {
    random_shuffle(p.begin(), p.end());
    circle C = circle(p[0], 0.0);
    for (int i = 0; i < (int)p.size(); i++) {
        if (C.contains(p[i])) continue;
        C = circle(p[i], 0.0);
        for (int j = 0; j < i; j++) {
            if (C.contains(p[j])) continue;
            C = circle((p[j] + p[i]) * 0.5, 0.5 * p[j].dist(p[i]));
            for (int k = 0; k < j; k++) {
                if (C.contains(p[k])) continue;
                C = circumcircle(p[j], p[i], p[k]);
            }
        }
    }
    return C;
}

// compute intersection of line through points a and b with
// circle centered at c with radius r > 0
vector<point> circle_line_intersection(point a, point b, point c, ld r) {
    vector<point> ret;
    b = b - a;
    a = a - c;
    ld A = dot(b, b);
    ld B = dot(a, b);
    ld C = dot(a, a) - r * r;
    ld D = B * B - A * C;
    if (D < -EPS) return ret;
    ret.push_back(c + a + b * (sqrt(D + EPS) - B) / A);
    if (D > EPS)
        ret.push_back(c + a + b * (-B - sqrt(D)) / A);
    return ret;
}

vector<point> circle_circle_intersection(point a, point b, ld r, ld R) {
    vector<point> ret;
    ld d = sqrt(a.dist2(b));
    if (d > r + R || d + min(r, R) < max(r, R)) return ret;
    ld x = (d * d - R * R + r * r) / (2 * d);
    ld y = sqrt(r * r - x * x);
    point v = (b - a) / d;
    ret.push_back(a + v * x + rotate_ccw90(v) * y);
    if (y > 0)
        ret.push_back(a + v * x - rotate_ccw90(v) * y);
    return ret;
}

//GREAT CIRCLE

double gcTheta(double pLat, double pLong, double qLat, double qLong) {
    pLat *= acos(-1.0) / 180.0; pLong *= acos(-1.0) / 180.0; // convert degree to radian
    qLat *= acos(-1.0) / 180.0; qLong *= acos(-1.0) / 180.0;
    return acos(cos(pLat) * cos(pLong) * cos(qLat) * cos(qLong) +
        cos(pLat) * sin(pLong) * cos(qLat) * sin(qLong) +
        sin(pLat) * sin(qLat));
}

double gcDistance(double pLat, double pLong, double qLat, double qLong, double radius) {
    return radius * gcTheta(pLat, pLong, qLat, qLong);
}

// getting the angle at point b
long double angle(point a, point b, point c) {
    long double ab = a.dist(b), ac = a.dist(c), bc = b.dist(c);
    long double tmp = ab * ab + bc * bc - ac * ac;
    tmp /= 2 * ab * bc;
    return fabs(acosl(tmp));
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setprecision(15) << fixed;
    int n;
    cin >> n;
    vector<point> v(n);
    for(int i = 0; i < n; i++) {
        cin >> v[i].x >> v[i].y;
    }
    long double ans = 0;
    for(int i = 0; i < n; i++) {
        // cout << i << ""\n"";
        point pr = v[(i - 1 + n) % n], prr = v[(i - 2 + n) % n], pl = v[(i + 1) % n], pll = v[(i + 2) % n];
        point mid = (pl + pr) / 2;
        long double base = pl.dist(v[i]) + pr.dist(v[i]);
        long double rad = pl.dist(pr) / 2;
        point p = mid + rotate_ccw90((pr - pl) / 2);
        if(direction(pll, pl, p) == -1 and direction(prr, pr, p) == 1 and ge(angle(pll, pl, p), PI / 2) and ge(angle(prr, pr, p), PI / 2)) {
            // cout << ""on circle\n"";
            // cout << rad * 2 * sqrtl(2) - base << ""\n"";
            ans = max(ans, rad * 2 * sqrtl(2) - base);
        }
        if(line_line_intersect(pll, pl, prr, pr)) {
            point inter = lines_intersect(pll, pl, prr, pr);
            if(direction(pl, pr, inter) == 1 and ge(angle(pl, inter, pr), PI / 2)) {
                // cout << ""line line intersect\n"";
                // cout << pl.dist(inter) + pr.dist(inter) - base << ""\n"";
                // cout << inter << ""\n"";
                // cout << direction(pl, pr, inter) << ""\n"";
                ans = max(ans, pl.dist(inter) + pr.dist(inter) - base);
            }
        }
        //maybe middle do not work so grab the arc
        //each point will have a left boundary and right boundary which by default is arc(pl, pr), but maybe the possible arc is smaller than the whole arc
        point pr_lb = pl, pr_rb = pr, pl_lb = pl, pl_rb = pr;
        auto inter = circle_line_intersection(pl, pll, mid, rad);
        for(auto a : inter) {
            if(direction(prr, pr, a) == 1 and direction(pl, pr, a) != -1) {
                // cout << ""circle line left\n"";
                // cout << pl.dist(a) + pr.dist(a) - base << ""\n"";
                // cout << a << ""\n"";
                ans = max(ans, pl.dist(a) + pr.dist(a) - base);
                pl_lb = a;
            }
        }
        inter = circle_line_intersection(pr, prr, mid, rad);
        for(auto a : inter) {
            if (direction(pll, pl, a) == -1 and direction(pl, pr, a) != -1) {
                // cout << ""circle line right\n"";
                // cout << pl.dist(a) + pr.dist(a) - base << ""\n"";
                // cout << a << ""\n"";
                ans = max(ans, pl.dist(a) + pr.dist(a) - base);
                pr_rb = a;
            }
        }
        inter = circle_line_intersection(pr, pr + rotate_ccw90(pr - prr), mid, rad);
        for(auto a : inter) {
            if(eq(a.dist(pr), 0)) continue;
            if(direction(pl, pr, a) != -1) pr_lb = a;
        }
        inter = circle_line_intersection(pl, pl + rotate_cw90(pl - pll), mid, rad);
        for(auto a : inter) {
            if(eq(a.dist(pl), 0)) continue;
            if(direction(pl, pr, a) != -1) pl_rb = a;
        }
        //use boundaries to update answer, it will either improve or stay the same, e.g. boundary is pl or pr.
        //for each boundary point it must be inside the boundary defined by the other point, e.g. pl_al must be inside the arc(pr_al, pr_ar).
        //pr_lb
        if (direction(mid, pl_lb, pr_lb) != 1 and direction(mid, pl_rb, pr_lb) != -1) ans = max(ans, pl.dist(pr_lb) + pr.dist(pr_lb) - base);
        //pr_rb
        if (direction(mid, pl_lb, pr_rb) != 1 and direction(mid, pl_rb, pr_rb) != -1) ans = max(ans, pl.dist(pr_rb) + pr.dist(pr_rb) - base);
        //pl_lb
        if (direction(mid, pr_lb, pl_lb) != 1 and direction(mid, pr_rb, pl_lb) != -1) ans = max(ans, pl.dist(pl_lb) + pr.dist(pl_lb) - base);
        //pl_rb
        if (direction(mid, pr_lb, pl_rb) != 1 and direction(mid, pr_rb, pl_rb) != -1) ans = max(ans, pl.dist(pl_rb) + pr.dist(pl_rb) - base);
    }
    cout << ans << ""\n"";
    return 0;
}
"
iJbKViRb,Untitled,xShub,JavaScript,Thursday 30th of October 2025 08:39:36 AM CDT,"
let soldiDisponibili = 50;
let listaSpesa = [];
let numeroProdotti = 0;

function aggiungiProdotto(nome, prezzo) {
    if (soldiDisponibili >= prezzo) {

        // Aggiunge il contenuto della variabile nome alla lista 'listaSpesa'
        listaSpesa.push(nome);

        // Sottrae dai soldi a mia disposizione (variabile 'soldiDisponibili')
        // il valore contenuto nella variabile 'prezzo'

        // soldiDisponibili -= prezzo;
        soldiDisponibili = soldiDisponibili - prezzo;

        // Aumenta di uno il valore nella variabile 'numeroProdotti'
        // numeroProdotti += 1;
        // numeroProdotti++;
        numeroProdotti = numeroProdotti + 1;

        // Stampa varie informazioni per l'utente
        console.log(""Complimenti! Hai aggiunto il prodotto "" +
            nome + "" al prezzo di "" + prezzo.toString() +
            "" milioni di euro."");

        console.log(""Ti rimangono "" + soldiDisponibili.toString() +
            "" milioni di euro."");

    } else {
        const soldiMancanti = prezzo - soldiDisponibili;
        console.log(""Spendi troppo, ti mancano "" + soldiMancanti.toString() + "" milioni di euro."");
    }
}

function mostraLista() {

    console.log(""LA TUA LISTA DELLA SPESA:"");

    // let lunghezzaLista = listaSpesa.length;
    // numeroProdotti == listaSpesa.length


    // [ ""Primo Elemento"", ""Secondo Elemento"", ""Terzo Elemento"" ]
    // [      0          ,         1         ,         2        ]
    //
    // Lunghezza lista: 3

    let miaLunghezzaLista = listaSpesa.length;

    //if (listaSpesa.length === 0 ) {
    if (miaLunghezzaLista === 0 ) {
        console.log(""Non ci sono prodotti nella lista!"");
    } else {
        for (let i = 0; i < miaLunghezzaLista; i++) {
            let numeroProgressivo = (i + 1).toString();
            let nomePosizioneElemento = numeroProgressivo + "". "" + listaSpesa[i];
            console.log(nomePosizioneElemento);
        }
    }
    console.log(""Ci rimangono ancora "" + soldiDisponibili.toString() + "" milioni di euro."");
}




// aggiungiProdotto(""Pollo"", 12);
// aggiungiProdotto(""Pompelmi"", 10);
// aggiungiProdotto(""Pomodori"", 10);
// aggiungiProdotto(""Ovini Kinder"", 40);
"
7W562iXb,Table N3 of 19 Account Xtream BiG DaTa for Free - IPTV 29/10/2025,iptvregion,JavaScript,Thursday 30th of October 2025 07:46:01 AM CDT,"Table N3 of 19 Account Xtream BiG DaTa for Free - IPTV 29/10/2025

▼▼▼▼
https://www.iptvregion.eu.org/2025/10/table-n3-of-19-account-xtream-big-data.html
▲▲▲▲


join to us : linktr.ee/iptvregion

TAG: iptv,best iptv,what is iptv,iptv service,best iptv service,iptv news,iptv services,is iptv illegal,top iptv service,iptv box,iptv 2025,free iptv,the best iptv service,que es iptv,iptv subscription,is iptv legal,iptv service reviews,iptv shut down,iptv shutdown,ventajas iptv,benefits of iptv,iptv smartphones pro,top iptv providers,iptv review,iptv player,listas iptv,top iptv 2025,usa iptv 2025,best iptv
	"
D3hrnJkW,Untitled,msamufidi,Python,Thursday 30th of October 2025 07:30:33 AM CDT,"#include <pthread.h>
#include <stdio.h>
#include <stdlib.h> // Untuk exit, dll.

// 1. Deklarasi Mutex Global
pthread_mutex_t lock; 

int counter = 0;

void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        // 2. Kunci (Lock) Mutex sebelum mengakses critical section
        pthread_mutex_lock(&lock); 
        
        // Critical Section (Operasi yang harus atomik)
        counter++; 
        
        // 3. Buka Kunci (Unlock) Mutex setelah selesai
        pthread_mutex_unlock(&lock); 
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    // 4. Inisialisasi Mutex
    if (pthread_mutex_init(&lock, NULL) != 0) {
        printf(""\nMutex init failed\n"");
        return 1;
    }

    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    // 5. Hancurkan Mutex setelah tidak digunakan lagi
    pthread_mutex_destroy(&lock);

    printf(""Final counter: %d\n"", counter); 
    // Output yang diharapkan dan seharusnya konsisten adalah: 200000
    
    return 0;
}"
sWWSyhLC,PrimeX Hub | Adopt Me Script [Keyless],AFBv1,Lua,Thursday 30th of October 2025 07:03:27 AM CDT,"-- 🌟 PrimeX Hub 🌟
-- A feature-packed script hub designed for Adopt Me–style Roblox experiences.
-- Includes smooth automation, customization, and pet system enhancements.
-- Optimized for performance and security — made for testing, development, and advanced gameplay systems.
 
-- ✨ Features:
-- Autofarm
-- Auto Hatch Eggs
-- Auto Feed Pets
-- Auto Collect Rewards
-- Auto Upgrade Items
-- Auto Trade Assistant
-- Auto Equip Best Pet
-- Teleport Tools
-- Smart Inventory Sorting
-- Dev Tools + Debug Menu
-- Dupe
-- Pet Spawner
-- Auto Trade
-- Trade Scam
 
-- 🧩 Script:
loadstring(game:HttpGet(""https://raw.githubusercontent.com/fetbobbymope1-cmyk/AdoptMeScript/refs/heads/main/Pro""))()

--https://discord.gg/AaGwpM8j"
puKq5Gqz,PrimeX Hub | Adopt Me Script,AFBv1,Lua,Thursday 30th of October 2025 06:50:42 AM CDT,"-- 🌟 PrimeX Hub 🌟
-- A feature-packed script hub designed for Adopt Me–style Roblox experiences.
-- Includes smooth automation, customization, and pet system enhancements.
-- Optimized for performance and security — made for testing, development, and advanced gameplay systems.

-- ✨ Features:
-- Autofarm
-- Auto Hatch Eggs
-- Auto Feed Pets
-- Auto Collect Rewards
-- Auto Upgrade Items
-- Auto Trade Assistant
-- Auto Equip Best Pet
-- Teleport Tools
-- Smart Inventory Sorting
-- Dev Tools + Debug Menu
-- Dupe
-- Pet Spawner
-- Auto Trade
-- Trade Scam

-- 🧩 Script:
loadstring(game:HttpGet(""https://raw.githubusercontent.com/fetbobbymope1-cmyk/AdoptMeScript/refs/heads/main/Pro""))()"
XfdVtXuS,物理-探究A (不確定度計算),Casperliao,C++,Thursday 30th of October 2025 06:25:59 AM CDT,"//物理-探究A
#include <iostream>
#include <cmath>
#include <iomanip>
#include <vector>

using namespace std;

int main() {
	
    double n = 0;
    double average = 0;
    double SD = 0;
    double u = 0;
    
    int Language = 0;
    
    double sum = 0;
    
    vector<double> database;
    
    cout<<""English type 1\n""<<""繁體中文選 2\n""<<""Language (type 1 or 2): ""; 
    cin>>Language;
    
    if (Language == 1){
    	cout<<""how much data: "";
	}else{
		cout<<""幾組數據: "";
	}
    
    
    cin>>n;
    
    for (int i = 1; i <= n; i += 1){
    	double n2 = 0;
    	
    	if (Language == 1){
    		cout<<""data ""<<i<<"": "";
		}else{
			cout<<""數據 ""<<i<<"": "";
		}
		
    	cin>>n2;
    	
    	database.push_back(n2);
    	average += n2;
	}
	
	average /= n;
	
	for (int i = 0; i < database.size(); i += 1){
		double n2 = database[i];
		sum += (n2 - average) * (n2 - average);
	}
	
	SD = sqrt(sum / (n - 1));
	
	u = round(SD / sqrt(n) * 10) / 10;
	cout<<""--------------------""<<""\n"";
	if (Language == 1){
		cout<<""Average: ""<<average<<""\n"";
		cout<<""σ: ""<<SD<<""\n"";
		cout<<""u: ""<<u<<""\n"";
		cout<<""Best estimate: ""<<round(average * 10) / 10<<""\n"";
		cout<<""Result: ""<<round(average * 10) / 10<<"" ± ""<<u<<""\n"";
	}else{
		cout<<""平均值: ""<<average<<""\n"";
		cout<<""標準差: ""<<SD<<""\n"";
		cout<<""不確定度: ""<<u<<""\n"";
		cout<<""最佳估計值: ""<<round(average * 10) / 10<<""\n"";
		cout<<""測量結果: ""<<round(average * 10) / 10<<"" ± ""<<u<<""\n"";
	}
	
	
    return 0;
}"
ZMQsBEy4,Sudoku,wingman007,C#,Thursday 30th of October 2025 05:27:07 AM CDT,"/*
Below is a complete Console program (single file) that:

builds a valid, fully-solved Sudoku by recursive backtracking,

removes numbers while keeping the puzzle uniquely solvable, and

prints both the puzzle and the solution in the console.

You can paste this into a new Console App (Program.cs) and run.
*/

using System;
using System.Collections.Generic;

class Program
{
    static readonly int Size = 9;
    static readonly int Box = 3;
    static readonly Random Rng = new Random();

    static void Main()
    {
        // 1) Create an empty grid
        int[,] solution = new int[Size, Size];

        // 2) Fill it with a complete valid Sudoku (backtracking)
        if (!FillGrid(solution))
        {
            Console.WriteLine(""Failed to generate a full Sudoku solution."");
            return;
        }

        // Make a copy to keep the solution
        int[,] puzzle = CopyGrid(solution);

        // 3) Ask for a difficulty (how many cells to remove)
        Console.Write(""Choose difficulty (E=Easy, M=Medium, H=Hard) [default M]: "");
        string diff = (Console.ReadLine() ?? """").Trim().ToUpperInvariant();
        int removeTarget = diff switch
        {
            ""E"" => 30, // ~30 blanks (51 clues)
            ""H"" => 50, // ~50 blanks (31 clues)
            _   => 40  // Medium ~40 blanks (41 clues)
        };

        // 4) Carve out cells while keeping uniqueness
        MakePuzzleWithUniqueSolution(puzzle, removeTarget);

        // 5) Print results
        Console.WriteLine();
        Console.WriteLine(""=== PUZZLE ==="");
        PrintGrid(puzzle);

        Console.WriteLine();
        Console.WriteLine(""=== SOLUTION ==="");
        PrintGrid(solution);

        Console.WriteLine();
        Console.WriteLine(""Press any key to exit..."");
        Console.ReadKey();
    }

    // -------------------- Sudoku generation --------------------

    // Fill the grid fully using backtracking (random order for variety)
    static bool FillGrid(int[,] grid)
    {
        int row, col;
        if (!FindEmpty(grid, out row, out col))
        {
            // No empty cell: solved
            return true;
        }

        // Try numbers 1..9 in random order
        foreach (int num in ShuffledNumbers())
        {
            if (IsSafe(grid, row, col, num))
            {
                grid[row, col] = num;
                if (FillGrid(grid)) return true;
                grid[row, col] = 0; // backtrack
            }
        }

        return false; // trigger backtracking
    }

    // Check if placing num at [row,col] obeys Sudoku rules
    static bool IsSafe(int[,] grid, int row, int col, int num)
    {
        // Row
        for (int c = 0; c < Size; c++)
            if (grid[row, c] == num) return false;

        // Column
        for (int r = 0; r < Size; r++)
            if (grid[r, col] == num) return false;

        // 3x3 box
        int r0 = (row / Box) * Box;
        int c0 = (col / Box) * Box;
        for (int r = 0; r < Box; r++)
            for (int c = 0; c < Box; c++)
                if (grid[r0 + r, c0 + c] == num) return false;

        return true;
    }

    // Find the next empty cell (0 = empty). Returns false if none.
    static bool FindEmpty(int[,] grid, out int row, out int col)
    {
        for (int r = 0; r < Size; r++)
            for (int c = 0; c < Size; c++)
                if (grid[r, c] == 0)
                {
                    row = r;
                    col = c;
                    return true;
                }

        row = -1;
        col = -1;
        return false;
    }

    // Return numbers 1..9 in random order
    static IEnumerable<int> ShuffledNumbers()
    {
        List<int> nums = new List<int>(9);
        for (int i = 1; i <= 9; i++) nums.Add(i);
        for (int i = nums.Count - 1; i > 0; i--)
        {
            int j = Rng.Next(i + 1);
            (nums[i], nums[j]) = (nums[j], nums[i]);
        }
        return nums;
    }

    // -------------------- Puzzle carving with uniqueness --------------------

    static void MakePuzzleWithUniqueSolution(int[,] puzzle, int removeTarget)
    {
        // Create a list of all positions [0..80] and shuffle
        List<int> positions = new List<int>(Size * Size);
        for (int i = 0; i < Size * Size; i++) positions.Add(i);

        // Fisher–Yates shuffle
        for (int i = positions.Count - 1; i > 0; i--)
        {
            int j = Rng.Next(i + 1);
            (positions[i], positions[j]) = (positions[j], positions[i]);
        }

        int removed = 0;

        foreach (int pos in positions)
        {
            if (removed >= removeTarget) break;

            int row = pos / Size;
            int col = pos % Size;

            if (puzzle[row, col] == 0) continue; // already empty

            int backup = puzzle[row, col];
            puzzle[row, col] = 0;

            // Check uniqueness: count solutions up to 2
            int solutions = CountSolutions(CopyGrid(puzzle), 2);
            if (solutions == 1)
            {
                removed++;
            }
            else
            {
                // not unique — revert
                puzzle[row, col] = backup;
            }
        }
    }

    // Backtracking solver that counts how many solutions exist (up to 'limit')
    static int CountSolutions(int[,] grid, int limit)
    {
        int count = 0;
        SolveAndCount(grid, ref count, limit);
        return count;
    }

    static void SolveAndCount(int[,] grid, ref int count, int limit)
    {
        if (count >= limit) return; // early stop if enough found

        int row, col;
        if (!FindEmpty(grid, out row, out col))
        {
            // Found one solution
            count++;
            return;
        }

        // Try 1..9 (ordered or random — ordered is slightly faster here)
        for (int num = 1; num <= 9; num++)
        {
            if (IsSafe(grid, row, col, num))
            {
                grid[row, col] = num;
                SolveAndCount(grid, ref count, limit);
                if (count >= limit) return; // early stop
                grid[row, col] = 0;
            }
        }
    }

    // -------------------- Utilities --------------------

    static int[,] CopyGrid(int[,] src)
    {
        int[,] dst = new int[Size, Size];
        for (int r = 0; r < Size; r++)
            for (int c = 0; c < Size; c++)
                dst[r, c] = src[r, c];
        return dst;
    }

    static void PrintGrid(int[,] grid)
    {
        for (int r = 0; r < Size; r++)
        {
            if (r % 3 == 0)
                Console.WriteLine(""+-------+-------+-------+"");

            for (int c = 0; c < Size; c++)
            {
                if (c % 3 == 0) Console.Write(""| "");

                int val = grid[r, c];
                Console.Write(val == 0 ? "". "" : (val.ToString() + "" ""));
            }
            Console.WriteLine(""|"");
        }
        Console.WriteLine(""+-------+-------+-------+"");
    }
}
/*
How the algorithm works (step-by-step, in plain words)

1. Board representation
We use a 9x9 int array. 0 means “empty”.

2. Rules as code
A helper IsSafe(row, col, num) checks whether num can be placed at [row,col] (no duplicates in row, column, or 3×3 box).

3. Build a full solution (recursion + backtracking)

Find the next empty cell (top-to-bottom, left-to-right).

Try candidates 1..9 in random order.

If a candidate fits (IsSafe), place it and recurse to the next cell.

If we get stuck, backtrack: remove the number and try the next one.
This eventually fills the board with a valid solution.

4. Make a puzzle by removing numbers

Randomize all 81 cell positions.

Try to remove one cell (set it to 0).

Check uniqueness: run a solution counter (a solver that stops after it finds 2 solutions).

If there’s still exactly 1 solution → keep it removed.

Otherwise restore the number.

Continue until we removed enough numbers for the chosen difficulty (e.g., 40 empties).

5. Print nicely
A helper prints the grid with lines every 3 rows/columns.
*/"
VN2seDFf,Untitled,xShub,JavaScript,Thursday 30th of October 2025 05:22:55 AM CDT,"// HTML

<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>Esercizio del 30 Ottobre</title>
    <script defer src=""./js/funzioni_esercizio.js""></script>
</head>
<body>
<h2>Non ci interessa</h2>
</body>
</html>

// Javascript

let soldiDisponibili = 50;
let listaSpesa = [];
let numeroProdotti = 0;

function aggiungiProdotti(nome, prezzo) {
    if (soldiDisponibili >= prezzo) {

        listaSpesa.push(nome);

        // soldiDisponibili -= prezzo;
        soldiDisponibili = soldiDisponibili - prezzo;

        // numeroProdotti += 1;
        // numeroProdotti++;
        numeroProdotti = numeroProdotti + 1;

        console.log(""Complimenti! Hai aggiunto il prodotto "" +
            nome + "" al prezzo di "" + prezzo.toString());
        console.log(""Ti rimangono  "" + soldiDisponibili.toString() +
            "" milioni di euro."");
    } else {
        const soldiMancanti = prezzo - soldiDisponibili;
        console.log(""Spendi troppo, ti mancano "" + soldiMancanti.toString() + "" milioni di euro."");
    }
}
"
a7Xbjhuv,h,threatww,JavaScript,Thursday 30th of October 2025 04:54:33 AM CDT,"// findChannels.js
// Parallelized server scanning to find chattable channels.
// Uses servers.json (auto-located).
// WARNING: Selfbots violate Discord TOS. Use at your own risk.
const { Client, Intents } = require('discord.js-selfbot-v13');
const fs = require('fs');
const path = require('path');
/////////// CONFIG ///////////
const TOKEN = ''; // <-- put your token here
// Concurrency settings (tune to be slower to avoid rate limits/bans).
const CONCURRENCY = 1; // Set to 1 to process servers one by one (safer)
const CHANNEL_TEST_DELAY_MS = 2000; // Delay between testing each channel (in ms, e.g., 2000 = 2 seconds)
const RETRY_ATTEMPTS = 3; // retry attempts on transient errors / 429
const RETRY_BASE_MS = 1000; // base backoff in ms
const TEST_SEND = true; // Enabled to actually test sending ""X"" and deleting it to verify chattable (RISKY: can trigger anti-spam, rate limits, or bans! Run on small server lists first.)
const LOG_CHANNELS = true; // Enabled to log each found/verified channel's name and ID to console
const INTENTS = [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MEMBERS];
/////////// HELPERS ///////////
function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
/**
 * Locate servers.json in several sensible places so doubled folder problems won't block you.
 */
function locateServersJson() {
  const candidates = [
    path.resolve(process.cwd(), 'servers.json'),
    path.join(__dirname, 'servers.json'),
  ];
  for (const p of candidates) if (fs.existsSync(p)) return p;
  return { notFound: true, attempted: candidates };
}
function loadServerIdsOrExit() {
  const located = locateServersJson();
  if (located && located.notFound) {
    console.error('[error] Required file not found. Attempted the following paths:');
    for (const p of located.attempted) console.error(' ' + p);
    console.error('\nCreate a servers.json in one of those locations using this format (array of guild ID strings):');
    console.error(`[\n ""349051257702580224"",\n ""587355301083349002"",\n ""1141515589924429869""\n]`);
    process.exit(1);
  }
  console.log(`[info] Using servers.json at: ${located}`);
  let parsed;
  try { parsed = JSON.parse(fs.readFileSync(located, 'utf8')); }
  catch (e) { console.error(`[error] Failed to parse ${located}: ${e.message}`); process.exit(1); }
  if (!Array.isArray(parsed)) { console.error(`[error] ${located} must contain a JSON array of guild ID strings.`); process.exit(1); }
  const ids = Array.from(new Set(parsed.map(String).map(s => s.trim()).filter(Boolean).filter(s => /^\d+$/.test(s))));
  if (!ids.length) { console.error(`[error] ${located} contains no valid numeric guild IDs.`); process.exit(1); }
  return ids;
}
/**
 * Generic limited-concurrency runner.
 * items: array
 * limit: number of parallel workers
 * worker: async function(item, index) -> result
 */
async function runLimited(items, limit, worker) {
  let i = 0;
  const results = new Array(items.length);
  const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
    while (true) {
      const idx = i++;
      if (idx >= items.length) break;
      try { results[idx] = await worker(items[idx], idx); }
      catch (err) { results[idx] = { __error: err }; }
    }
  });
  await Promise.all(workers);
  return results;
}
/**
 * Robust channel scan inside a guild.
 * Tries to fetch channels and check permissions with retries on errors.
 * If TEST_SEND is true, actually tries to send and delete a message to verify.
 * Skips threads as per user request.
 */
async function findChattableChannelsInGuildWithRetries(guild, client) {
  for (let attempt = 0; attempt < RETRY_ATTEMPTS; attempt++) {
    try {
      // Fetch self member
      const me = await guild.members.fetch(client.user.id);
      // Fetch all channels (cache should populate) - only gets channels visible to the user
      await guild.channels.fetch();
      const channels = guild.channels.cache;
      const chattable = [];
      for (const channel of channels.values()) {
        if (!channel.isText() || channel.isThread()) continue; // Skip non-text and threads
        // Check permission first
        if (!channel.permissionsFor(me).has('SEND_MESSAGES')) continue;
        if (TEST_SEND) {
          // Actually test send ""X"" and delete
          try {
            const msg = await channel.send('X');
            await msg.delete();
            chattable.push(channel.id);
            if (LOG_CHANNELS) console.log(`  - Verified by send: #${channel.name} (${channel.id})`);
          } catch (sendErr) {
            console.warn(`[warn] Cannot send in channel ${channel.id} (${channel.name}): ${sendErr.message || sendErr}`);
            continue;
          }
        } else {
          chattable.push(channel.id);
          if (LOG_CHANNELS) console.log(`  - Found (perm check): #${channel.name} (${channel.id})`);
        }
        // Delay between channel tests to avoid rate limits
        await sleep(CHANNEL_TEST_DELAY_MS);
      }
      return chattable;
    } catch (err) {
      // Detect 429-like behavior if possible
      const is429 = (err && (err.status === 429 || /429|Too Many Requests/i.test(err.message || '')));
      const waitMs = RETRY_BASE_MS * Math.pow(2, attempt);
      if (is429) {
        console.warn(`[warn] Rate limited in guild ${guild.id}. Backing off ${waitMs}ms (attempt ${attempt+1}/${RETRY_ATTEMPTS})`);
      } else {
        console.warn(`[warn] Error in guild ${guild.id}: ${err.message || err}. Retrying ${waitMs}ms (attempt ${attempt+1}/${RETRY_ATTEMPTS})`);
      }
      await sleep(waitMs);
    }
  }
  // All attempts failed -> treat as no channels for this guild
  return [];
}
/////////// MAIN ///////////
(async () => {
  if (!TOKEN || TOKEN === 'PASTE_YOUR_TOKEN_HERE') {
    console.error('No token provided. Paste your token into the TOKEN constant at top of the script.');
    process.exit(1);
  }
  const serverIds = loadServerIdsOrExit();
  console.log(`Loaded ${serverIds.length} server ID(s) from servers.json.`);
  console.log(`Using concurrency: CONCURRENCY=${CONCURRENCY} (lowered for safety)`);
  console.log(`TEST_SEND mode: ${TEST_SEND ? 'ENABLED (will try sending ""X"" in each channel - risky, but verifies truly chattable)' : 'DISABLED (permission check only)'}`);
  console.log(`CHANNEL_TEST_DELAY_MS: ${CHANNEL_TEST_DELAY_MS}ms between each channel test`);
  console.log(`LOG_CHANNELS: ${LOG_CHANNELS ? 'ENABLED' : 'DISABLED'}`);
  const client = new Client({ intents: INTENTS });
  client.once('ready', async () => {
    console.log(`\nLogged in as ${client.user.tag}`);
    const allChattableChannels = new Set(); // Use set to avoid duplicates
    // Process servers in parallel with CONCURRENCY
    await runLimited(serverIds, CONCURRENCY, async (sid, idx) => {
      console.log(`\n[${idx+1}/${serverIds.length}] Checking server ${sid} ...`);
      let guild;
      try {
        guild = await client.guilds.fetch(sid);
      } catch (err) {
        console.warn(`- Skipping guild ${sid}: cannot fetch (not in guild / invalid id).`);
        return;
      }
      try {
        const channels = await findChattableChannelsInGuildWithRetries(guild, client);
        if (channels.length) {
          console.log(`- Found ${channels.length} chattable channel(s) in ${guild.name} (${guild.id})`);
          channels.forEach(id => allChattableChannels.add(id));
        } else {
          console.log(`- No chattable channels found in ${guild.name} (${guild.id})`);
        }
      } catch (err) {
        console.warn(`- Error scanning guild ${sid}: ${err.message || err}`);
      }
    });
    // Write to channels.json
    const outputPath = path.resolve(process.cwd(), 'channels.json');
    const channelArray = Array.from(allChattableChannels).sort(); // Sort for consistency
    const jsonContent = '[\n' + channelArray.map(id => `  ""${id}""`).join(',\n') + '\n]';
    fs.writeFileSync(outputPath, jsonContent, 'utf8');
    console.log(`\n--- scan complete — summary ---`);
    console.log(`Found ${channelArray.length} chattable channel(s) across all servers.`);
    console.log(`Saved to: ${outputPath}`);
    client.destroy();
    process.exit(0);
  });
  client.on('error', (err) => {
    console.error('Client error:', err && err.message ? err.message : err);
  });
  try {
    await client.login(TOKEN);
  } catch (err) {
    console.error('Failed to login:', err && err.message ? err.message : err);
    process.exit(1);
  }
})();"
XkYAVent,snake,imrskull,Lua,Thursday 30th of October 2025 04:46:43 AM CDT,"-- snake.lua — Змейка для OpenComputers (стабильный старт)
-- Управление: ← ↑ → ↓   |   Пауза: P   |   Выход: Q
-- Старт только по стрелке; не меняет текущее разрешение; выводит причину смерти.

local comp      = require(""component"")
local event     = require(""event"")
local keyboard  = require(""keyboard"")
local term      = require(""term"")
local computer  = require(""computer"")

assert(comp.isAvailable(""gpu""), ""Нужна видеокарта (gpu)."")
local gpu = comp.gpu

-- Палитра
local COL_BG      = 0x202020
local COL_BORDER  = 0x404040
local COL_TEXT    = 0xFFFFFF
local COL_SNAKE   = 0x00FF66
local COL_FOOD    = 0x33CCFF
local COL_HELP    = 0xFFD166

-- Сохраняем текущие настройки
local oldFg, oldBg = gpu.getForeground(), gpu.getBackground()
local oldW,  oldH  = gpu.getResolution()

local deathReason = nil
local function cleanup(msg)
  gpu.setForeground(oldFg); gpu.setBackground(oldBg)
  gpu.setResolution(oldW, oldH)
  term.clear()
  if msg then print(msg) end
  if deathReason then print(""Причина:"", deathReason) end
end

-- Текущее разрешение
local W, H = gpu.getResolution()

-- Поле и отступы
local LEFT, TOP      = 2, 4
local RIGHT, BOTTOM  = W - 1, H - 1
local FIELD_W        = RIGHT - LEFT + 1
local FIELD_H        = BOTTOM - TOP + 1

if FIELD_W < 10 or FIELD_H < 8 then
  cleanup(""Слишком маленькое разрешение экрана для игры."")
  return
end

-- Рисовалки
local function cls()
  gpu.setBackground(COL_BG); gpu.setForeground(COL_TEXT)
  term.clear()
end

local function drawFrame()
  -- Строка 1 — заголовок и подсказка
  gpu.setBackground(COL_BG)
  gpu.fill(1, 1, W, 1, "" "")
  gpu.setForeground(COL_TEXT)
  gpu.set(2, 1, ""S N A K E"")

  local help = ""←↑→↓ движение   P пауза   Q выход""
  gpu.setForeground(COL_HELP)
  gpu.set(math.max(2, W - #help - 1), 1, help)

  -- Строка 2 — статус (перерисует status())
  gpu.fill(1, 2, W, 1, "" "")

  -- Рамка поля
  gpu.setForeground(COL_BORDER)
  for x = LEFT-1, RIGHT+1 do gpu.set(x, TOP-1, ""─""); gpu.set(x, BOTTOM+1, ""─"") end
  for y = TOP-1, BOTTOM+1 do gpu.set(LEFT-1, y, ""│""); gpu.set(RIGHT+1, y, ""│"") end
  gpu.set(LEFT-1, TOP-1,     ""┌""); gpu.set(RIGHT+1, TOP-1,    ""┐"")
  gpu.set(LEFT-1, BOTTOM+1,  ""└""); gpu.set(RIGHT+1, BOTTOM+1, ""┘"")
end

local function status(score, speed)
  gpu.setForeground(COL_TEXT)
  local line = string.format("" Score: %d   Speed: %.1f fps "", score, speed)
  gpu.fill(1, 2, W, 1, "" "")
  gpu.set(math.max(2, math.floor((W - #line)/2)), 2, line)
end

local function fillField()
  gpu.setBackground(COL_BG)
  gpu.fill(LEFT, TOP, FIELD_W, FIELD_H, "" "")
end

local function drawCell(x, y, color, ch)
  gpu.setBackground(COL_BG)
  gpu.setForeground(color)
  gpu.set(x, y, ch or ""█"")
end

local function rnd(a, b) return math.random(a, b) end

local function spawnFood(snake)
  for _=1,10000 do
    local fx = rnd(LEFT, RIGHT)
    local fy = rnd(TOP,  BOTTOM)
    local clash = false
    for i=1,#snake do if snake[i].x == fx and snake[i].y == fy then clash = true; break end end
    if not clash then return {x=fx, y=fy} end
  end
  return {x = LEFT, y = TOP}
end

-- Инициализация
math.randomseed(os.time())

local snake = {}
local startLen = 4
local sx = math.floor((LEFT + RIGHT) / 2)
local sy = math.floor((TOP + BOTTOM) / 2)
for i=0,startLen-1 do
  table.insert(snake, 1, {x = sx - i, y = sy}) -- голова справа
end
local dir         = {x = 1, y = 0}
local pendingDir  = {x = 1, y = 0}
local food        = spawnFood(snake)
local score       = 0
local paused      = false
local alive       = true
local fps         = 8
local function stepDelay() return 1.0 / fps end

local function setDirection(nx, ny)
  if (#snake >= 2) then
    local head, neck = snake[1], snake[2]
    if head.x + nx == neck.x and head.y + ny == neck.y then return end
  end
  pendingDir = {x = nx, y = ny}
end

local function tick()
  dir = pendingDir
  local head = snake[1]
  local nx, ny = head.x + dir.x, head.y + dir.y

  if nx < LEFT or nx > RIGHT or ny < TOP or ny > BOTTOM then
    deathReason = ""удар о стену""
    alive = false; return
  end
  for i=1,#snake do
    if snake[i].x == nx and snake[i].y == ny then
      deathReason = ""врезался в себя""
      alive = false; return
    end
  end

  table.insert(snake, 1, {x=nx, y=ny})
  drawCell(nx, ny, COL_SNAKE, ""█"")

  if nx == food.x and ny == food.y then
    score = score + 1
    fps = math.min(20, 8 + score * 0.3)
    food = spawnFood(snake)
    drawCell(food.x, food.y, COL_FOOD, ""o"")
  else
    local tail = table.remove(snake)
    gpu.setForeground(COL_BG)
    gpu.set(tail.x, tail.y, "" "")
  end
end

-- Рендер статики
cls()
drawFrame()
fillField()
for i=1,#snake do drawCell(snake[i].x, snake[i].y, COL_SNAKE, ""█"") end
drawCell(food.x, food.y, COL_FOOD, ""o"")
status(score, fps)

-- 🔒 Старт ИМЕННО по стрелке (другие клавиши игнорируем)
gpu.setForeground(COL_HELP)
gpu.set(math.floor(W/2)-12, 3, ""Старт: нажми стрелку..."")
while true do
  local _, _, _, code = event.pull(""key_down"")
  if     code == keyboard.keys.up    then setDirection(0,-1); break
  elseif code == keyboard.keys.down  then setDirection(0, 1); break
  elseif code == keyboard.keys.left  then setDirection(-1,0); break
  elseif code == keyboard.keys.right then setDirection(1, 0); break
  elseif code == keyboard.keys.q     then cleanup(""Выход.""); return
  end
end
gpu.set(math.floor(W/2)-12, 3, ""                      "")

-- Главный цикл
local lastTime = computer.uptime()

while alive do
  local ev = {event.pull(stepDelay(), ""key_down"")}
  if ev[1] ~= nil then
    local _, _, _, code = table.unpack(ev)
    if code == keyboard.keys.q then break end
    if code == keyboard.keys.p then paused = not paused end
    if code == keyboard.keys.up    then setDirection(0, -1) end
    if code == keyboard.keys.down  then setDirection(0,  1) end
    if code == keyboard.keys.left  then setDirection(-1, 0) end
    if code == keyboard.keys.right then setDirection(1,  0) end
  end

  if paused then
    gpu.setForeground(COL_TEXT)
    gpu.set(math.floor(W/2)-3, 2, ""[PAUSE]"")
  else
    local t = computer.uptime()
    if t - lastTime >= stepDelay() then
      tick()
      status(score, fps)
      lastTime = t
    end
  end
end

if alive then
  cleanup(""Вы вышли из игры. Счёт: ""..tostring(score))
else
  cleanup(""Игра окончена. Счёт: ""..tostring(score))
end
"
fyB772bd,AI bot ?,chenshaoju,Apache Log,Thursday 30th of October 2025 04:46:38 AM CDT,"52.4.238.8 - - [27/Oct/2025:19:16:13 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/erpimgs/images/home/images/home/demoimages/demoimages/newimgs/erpimgs/images/home/demoimages/index.php?q=node/56 HTTP/1.1"" 200 3503 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/erpimgs/images/home/images/home/demoimages/demoimages/newimgs/erpimgs/images/home/demoimages/index.php"" 2.314 2.313
52.4.238.8 - - [27/Oct/2025:19:20:10 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/images/newimgs/images/home/demoimages/images/home/erpimgs/zengimgs/09.jpg HTTP/1.1"" 200 3379 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/images/newimgs/images/home/demoimages/images/home/erpimgs/zengimgs/09.jpg"" 4.225 4.226
52.4.238.8 - - [27/Oct/2025:19:26:52 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/newimgs/images/home/erpimgs/images/home/images/home/newimgs/erpimgs/index.php?q=node/117 HTTP/1.1"" 200 3137 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/newimgs/images/home/erpimgs/images/home/images/home/newimgs/erpimgs/index.php"" 2.787 2.787
98.82.40.168 - - [27/Oct/2025:04:40:18 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/zengimgs/images/home/images/home/erpimgs/images/home/newimgs/erpimgs/index.php?q=node/18 HTTP/1.1"" 200 3155 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/zengimgs/images/home/images/home/erpimgs/images/home/newimgs/erpimgs/index.php"" 0.484 0.484
98.82.40.168 - - [27/Oct/2025:04:47:19 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/download/doc/erpimgs/images/home/images/home/demoimages/newimgs/images/radmin/index.php?q=node/81 HTTP/1.1"" 200 4683 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/download/doc/erpimgs/images/home/images/home/demoimages/newimgs/images/radmin/index.php"" 0.379 0.379
98.82.40.168 - - [27/Oct/2025:04:55:32 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/erpimgs/zengimgs/images/home/images/ts/index.php?q=node/82 HTTP/1.1"" 200 4859 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/erpimgs/zengimgs/images/home/images/ts/index.php"" 0.712 0.712
3.212.205.90 - - [27/Oct/2025:04:34:39 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/download/doc/erpimgs/images/home/images/home/download/doc/images/erpimgs/index.php?q=node/80 HTTP/1.1"" 200 4366 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/download/doc/erpimgs/images/home/images/home/download/doc/images/erpimgs/index.php"" 1.820 1.820
3.212.205.90 - - [27/Oct/2025:04:37:58 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/newimgs/images/home/images/home/download/doc/images/radmin/newimgs/index.php?q=node/113 HTTP/1.1"" 200 3129 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/newimgs/images/home/images/home/download/doc/images/radmin/newimgs/index.php"" 0.724 0.725
3.212.205.90 - - [27/Oct/2025:04:40:49 +0800] ""GET http://www.example.com/index.php/images/index.php/index.php/events/cal/index.php/newimgs/images/home/images/home/download/doc/erpimgs/erpimgs/images/home/index.php?q=node/101 HTTP/1.1"" 200 3103 ""-"" ""Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Amazonbot/0.1; +https://developer.amazon.com/support/amazonbot) Chrome/119.0.6045.214 Safari/537.36"" ""serverhost.example.com"" ""text/html; charset=utf-8"" ""/data/user/htdocs/index.php/images/index.php/index.php/events/cal/index.php/newimgs/images/home/images/home/download/doc/erpimgs/erpimgs/images/home/index.php"" 1.279 1.280"
eYScnav0,firewall.bat,14ag,Batch,Thursday 30th of October 2025 03:44:29 AM CDT,"::---------------------------------------------------------------------------------------------------
:: commandline usage:  fire_wall.bat ""path\to\program.exe"" ^[allow^|block^] ^[in^|out^|all^]
::
::---------------------------------------------------------------------------------------------------
@echo off

:: user variables
setlocal
set ""extensions=.exe""
:: callback script
set ""OTHER_SCRIPT=""



:: functional variables
set ""loop=0""
set ""currentDirectory=%~dp0""
set ""_path=%~1""
set ""allow_block=%~2""
set ""in_out_all=%~3""
set ""empty_var=""

:: validate callback script exists and is executable function goes here

:: Validate allow_block parameter
call :validate ""allow block"" %allow_block%
if ""%validate%""==""false"" set ""allow_block=""

:: Validate in_out_all parameter
call :validate ""in out all"" %in_out_all%
if ""%validate%""==""false"" set ""in_out_all=""

::check if theres need to  show usage in single instance mode
call :validate ""'%in_out_all%' '%allow_block%' '%_path%'"" '%empty_var%'
if ""%validate%""==""true"" call :usage

::file validation
if ""%_path%""=="""" (
	set ""loop=1"" 
	goto :getFile
) 

goto :file_or_folder0


:getVars
cls
:: sets loop to happen if drag and drop is not happening
set ""loop=1""
set ""allow_block=""
set ""in_out_all=""


:getFile
call :info enter the file or folder to be processed here or
call :info Press Enter to process all files with the extensions ""%extensions%"" in the current directory
set ""_path=""
set /p ""_path=::""
if not defined _path (
	set ""_path=%currentDirectory:""=%""
) else if defined _path (
		set ""_path=%_path:""=%""
	)


:file_or_folder0
set ""workingDirectory=""
set ""file=""
call :file_or_folder ""%_path%""
if ""%file_or_folder%""==""folder"" (
	set ""workingDirectory=""%_path%""""
	goto :directory_processing
) else if ""%file_or_folder%""==""file"" (
	set ""file=""%_path%""""
	goto :fileProcessing
) else if ""%file_or_folder%""=="""" (
	call :error ""...%_path:~-10%"" not found
	goto :getFile
) else goto :getfile


:directory_processing
cls
call :info ""%workingDirectory%"" in use
set ""workingDirectory=%workingDirectory:""=%""
if ""%workingDirectory:~-1%""==""\"" (
	set ""workingDirectory=%workingDirectory:~0,-1%""
)

:: check for compatible files
cd %workingDirectory%
set ""found_files=0""
for %%j in (%extensions%) do (
    dir /b *%%j 2>nul | find ""."" >nul && set /a ""found_files+=1""
)
if %found_files% equ 0 (
    call :error No compatible files found in ""...%workingDirectory:~-10%""
	pause
	cls
    goto :getFile
)

if not defined in_out_all call :in_out_all
if not defined allow_block call :allow_block
cls
call :info the following files will be %allow_block%ed:
for %%j in (%extensions%) do (
	dir /b *%%j
)

setlocal enabledelayedexpansion
:: confirm install all files in the current directory
echo.
call :reset_choice
CHOICE /C yn /N /M ""\\\\\\\\ continue? [Y]es, [N]o ///////////""
if %errorlevel% equ 2 (
	cls
	goto :getVars
) else if %errorlevel% equ 1 (
	cls
	set ""ok_count=0""
	set ""all_count=0""
	:: install each file in the current directory
	for %%j in (%extensions%) do (
		for /r ""%workingDirectory%"" %%i in (*%%j) do (
		    call :subRoutine ""%%~i""
			set /a ""all_count+=1""
			if errorlevel 0 set /a ""ok_count+=1""
		)   )
		
	:: show number of files installed successfully
	call :info done. !ok_count!/!all_count! files processed.
	endlocal
	goto :end
) else exit /b 1


:fileProcessing
if not defined in_out_all call :in_out_all
if not defined allow_block call :allow_block
call :check %file% ""%extensions%""
if ""%check%""==""fail"" goto :getFile
call :subRoutine %file%
if errorlevel 0 (
	call :info \\\\\\\ done ///////
	) else if not errorlevel 0 (
		call :error /////// failed \\\\\\\
		)
goto :end


::---------------------------------------------------------------------------------------------------
:subRoutine
::---------------------------------------------------------------------------------------------------
set ""x=%*""
if ""%in_out_all%"" neq ""all"" (
	call :main %x%
) else if ""%in_out_all%"" equ ""all"" (
		set ""in_out_all=in""
		call :main %x%
		set ""in_out_all=out""
		call :main %x%
		set ""in_out_all=all""
	)
exit /b %errorlevel%


:main
set ""program_full_path=%*""
for %%i in (""%program_full_path:""=%"") do set ""rule_name=%%~ni""
netsh advfirewall firewall add rule name=""%rule_name%"" dir=%in_out_all% program=""%program_full_path:""=%"" profile=any action=%allow_block% enable=yes
exit /b %errorlevel%
::---------------------------------------------------------------------------------------------------


:: Display usage information and instructions
:usage
call :info ""Usage: %~nx0 'path\to\program.exe' [allow|block] [in|out|all]""
pause
exit /b 0


:in_out_all
echo.
call :selector ""echo in & echo out & echo all""
set ""in_out_all=%selector%""
exit /b 0


:allow_block
echo.
call :selector ""echo allow & echo block""
set ""allow_block=%selector%""
exit /b 0













:::::::::::::::::::::::::::::::::::::::::::helper functions::::::::::::::::::::::::::::::::::::::::::::::

:: reset errorlevel for correct choice
:reset_choice
exit /b 0


:: error handling
:error
Echo 1n| CHOICE /N >nul 2>&1 & rem BEL
echo error: %*
pause
exit /b 1


:: info handling
:info
echo.
echo info: %*
exit /b 0


:: call :truncate_str file.name extension
:: returns extension of file.name in variable [truncate_str]
:: file.name is the name of the file with extension
:: extension is the extension to be truncated
:truncate_str
set ""truncate_str=""
setlocal enabledelayedexpansion
set ""control_extension=%1""
set ""filename=%2""
for /L %%a in (1,1,10) do (
    if ""!control_extension:~%%a!""=="""" (
        for /f ""tokens=1"" %%b in (""-%%a"") do (
            for /f ""tokens=1"" %%c in (""!filename:~%%b!"") do (
                endlocal & set ""truncate_str=%%c""
            )   )   )   ) >nul 2>&1
exit /b 0


::call :file_or_folder file_or_folder
:: returns ""file"" or ""folder"" in variable [file_or_folder]
:: file_or_folder is the path to the file or folder
:file_or_folder
set ""file_or_folder=""
setlocal enabledelayedexpansion
set ""b=%1""
set ""b=%b:""=%""
if exist ""%b%"" (
	for %%I in (""%b%"") do (
		set ""attrs=%%~aI""
		REM Check if the first attribute is 'd' (directory)
		if ""!attrs:~0,1!"" == ""d"" (
			endlocal & set ""file_or_folder=folder"" 
		) else (
			endlocal & set ""file_or_folder=file""
		)   )
)
exit /b 0


:: call :validate ""control"" %items_to_test%
:: returns true or false in variable [validate]
:: control is a string of items separated by spaces
:validate
set ""validate=""
set ""control=%1""
set ""items_to_test=%2""
set ""items=0""
set ""count=0""
for %%i in (%control:""=%) do (
	if not ""%items_to_test%""==""%%i"" set /a count+=1
	set /a items+=1
)
if ""%count%"" geq ""%items%"" (
	set ""validate=false""
) else (
	set ""validate=true""
)
exit /b 0


:: call :selector ""[command that outputs list eg echo a & echo b & echo c]""
:: & is just a command separator, while && is a conditional operator
:selector
echo.
set ""selector=""
setlocal enabledelayedexpansion
set command=%* >nul
set ""i=0""
set ""choicelist=""
:: Loop through a list, act on each line
for /f ""eol=L tokens=1"" %%a in ('!command!') do (
	if errorlevel 1 (
		echo Error: Failed to execute command: !command!
		endlocal & exit /b 1
	)
	set /a i+=1
	:: Create dynamic variable names (_1, _2, etc.)
	for %%b in (_!i!) do (
		set ""%%b=%%a""
		set ""choicelist=!choicelist!!i!""
		echo !i!. %%a
	)   )

call :reset_choice
choice /c %choicelist% /n /m ""pick option btn %choicelist:~0,1% and %choicelist:~-1,1% ::""
for /L %%c in (%choicelist:~-1%,-1,%choicelist:~0,1%) do (
    if errorlevel %%c (
    for %%d in (!_%%c!) do (
            endlocal & set ""selector=%%d""
            goto :break
    )   )   )
:break
exit /b 0


::tests to find out if filename [%1] has any of these extensions [%2]
:check
set ""check=""
set ""filename=%1""
set ""extensions=%2""
set ""filename=%filename:""=%""
set ""extensions=%extensions:""=%""
setlocal enabledelayedexpansion
:: verify file existence & validate its type
if exist ""%filename%"" (
	::this loops thru each extension
	for %%k in (""%filename%"") do (
		for %%j in (%extensions%) do (
			call :truncate_str %%j %%~nxk
			if /i not ""%%j""==""!truncate_str!"" (
				call :error not a supported file.
				endlocal & set ""check=fail"" 
				) else (
					endlocal & set ""check=pass""
				) 	)	)
) else if not exist ""%filename%"" (
	call :error ""%filename%"" not found
	endlocal & set ""check=fail""
)
exit /b 0


:: loops if drag and drop is not happening
:end
if ""%loop%""==""1"" (
    pause
    cls
    goto getVars
) else (
    endlocal & exit /b %errorlevel%
)
"
TYJDxCpb,Untitled,katyafervent,Java,Thursday 30th of October 2025 03:37:52 AM CDT,"package com.example.pb.controller;

import javax.ws.rs.core.MediaType;

import com.example.pb.dto.BankMapRequest;
import com.example.pb.domain.Person;
import com.example.pb.repository.PersonRepository;
import com.example.pb.service.CreditCardService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;package com.example.pb.controller;

import javax.ws.rs.core.MediaType;

import com.example.pb.dto.BankMapRequest;
import com.example.pb.domain.Person;
import com.example.pb.repository.PersonRepository;
import com.example.pb.service.CreditCardService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;

import java.util.*;
import java.util.stream.Collectors;

@Controller
@RequestMapping(value = ""/api/persons"")
public class InefficientBanksController {

  @Autowired
  private PersonRepository repository;

  @Autowired
  private CreditCardService creditCardService;

  private static final Map<String, String> CARD_BANK = new HashMap<>();
  static {
    CARD_BANK.put(""cc-visa-1"", ""Bank of Spring"");
    CARD_BANK.put(""cc-mc-1"", ""Reactive Credit Union"");
  }

  @PostMapping(path = ""/banks-inefficient"",
               consumes = MediaType.APPLICATION_JSON,
               produces = MediaType.APPLICATION_JSON)
  public Map<String, List<String>> mapPersonToBanksInefficient(@RequestBody BankMapRequest req) {

    List<Person> persons = repository.findAllById(req.getPersonIds())
        .publishOn(Schedulers.parallel())
        .collectList()
        .block();

    List<String> allCards = new ArrayList<>();
    for (Person p : persons) {
      if (p.getCreditCardIds() != null) {
        allCards.addAll(p.getCreditCardIds());
      }
    }

    List<String> filtered = allCards.stream()
        .filter(id -> req.getCreditCardIds() != null && req.getCreditCardIds().contains(id))
        .collect(Collectors.toList());

    Set<String> toLookup = new HashSet<>(filtered);

    Map<String, List<String>> result = new LinkedHashMap<>();

    for (Person p : persons) {
      Map<String, String> card2bank =
          creditCardService.getBankNamesForCardIds(toLookup).block();

      List<String> copy = p.getCreditCardIds() == null
          ? new ArrayList<>()
          : new ArrayList<>(p.getCreditCardIds());
      copy.removeIf(id -> req.getCreditCardIds() == null || !req.getCreditCardIds().contains(id));

      List<String> banks = copy.stream()
          .map(card2bank::get)
          .collect(Collectors.toList());

      banks.removeIf(Objects::isNull);
      banks = new ArrayList<>(new LinkedHashSet<>(banks));

      result.put(p.getName(), banks);
    }

    return result;
  }
}


import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;

import java.util.*;
import java.util.stream.Collectors;

@Controller
@RequestMapping(value = ""/api/persons"")
public class InefficientBanksController {

  @Autowired
  private PersonRepository repository;

  @Autowired
  private CreditCardService creditCardService;

  private static final Map<String, String> CARD_BANK = new HashMap<>();
  static {
    CARD_BANK.put(""cc-visa-1"", ""Bank of Spring"");
    CARD_BANK.put(""cc-mc-1"", ""Reactive Credit Union"");
  }

  @PostMapping(path = ""/banks-inefficient"",
               consumes = MediaType.APPLICATION_JSON,
               produces = MediaType.APPLICATION_JSON)
  public Map<String, List<String>> mapPersonToBanksInefficient(@RequestBody BankMapRequest req) {

    List<Person> persons = repository.findAllById(req.getPersonIds())
        .publishOn(Schedulers.parallel())
        .collectList()
        .block();

    List<String> allCards = new ArrayList<>();
    for (Person p : persons) {
      if (p.getCreditCardIds() != null) {
        allCards.addAll(p.getCreditCardIds());
      }
    }

    List<String> filtered = allCards.stream()
        .filter(id -> req.getCreditCardIds() != null && req.getCreditCardIds().contains(id))
        .collect(Collectors.toList());

    Set<String> toLookup = new HashSet<>(filtered);

    Map<String, List<String>> result = new LinkedHashMap<>();

    for (Person p : persons) {
      Map<String, String> card2bank =
          creditCardService.getBankNamesForCardIds(toLookup).block();

      List<String> copy = p.getCreditCardIds() == null
          ? new ArrayList<>()
          : new ArrayList<>(p.getCreditCardIds());
      copy.removeIf(id -> req.getCreditCardIds() == null || !req.getCreditCardIds().contains(id));

      List<String> banks = copy.stream()
          .map(card2bank::get)
          .collect(Collectors.toList());

      banks.removeIf(Objects::isNull);
      banks = new ArrayList<>(new LinkedHashSet<>(banks));

      result.put(p.getName(), banks);
    }

    return result;
  }
}
"
QSBpUux0,chained postfix,happy-barney,Perl,Thursday 30th of October 2025 03:19:56 AM CDT,"/perl -Ilib -E '$_ = 1; say $_ for 1 .. $_ for 1 .. 4'
1
1
2
1
2
3
1
2
3
4
"
n9c8vRqY,Untitled,Haider38884,Lua,Thursday 30th of October 2025 03:16:25 AM CDT,"loadstring(game:HttpGet(""https://raw.githubusercontent.com/R7KScript/Arabic-speed/refs/heads/main/fee.Lua""))()"
sg2FqG2S,ChatBox,imrskull,Lua,Thursday 30th of October 2025 12:24:55 AM CDT,"-- /home/ChatBox — с обратным отсчётом и корректным Ctrl+C
local component = require(""component"")
local event     = require(""event"")
local term      = require(""term"")

local chat = component.chat_box or component.chat
assert(chat, ""Chat Box не найден. Поставь рядом/через Adapter."")

-- настройки
local NAME     = ""botWarpS""
local DISTANCE = 0        -- сделай локальный радиус; ставь 32767 для «везде»
local PERIOD   = 3600       -- 1 час
local MESSAGE  = ""§2✌ ⫸Warp S⫷ ✌ §4➤ &3Магазин ⣿ §5Механизмы ⣿ §aОбмен §aруды ⣿ §eКачалка опыта ✔""

if chat.setName then pcall(chat.setName, NAME) end
if chat.setDistance then pcall(chat.setDistance, DISTANCE) end

local function say(msg)
  if chat.say then chat.say(msg) elseif chat.sendMessage then chat.sendMessage(msg) end
end

local function drawStatus(remain)
  local m = math.floor(remain / 60)
  local s = remain % 60
  term.clear()
  term.setCursor(1,1)
  io.write((""Сообщение: %s\n""):format(MESSAGE))
  io.write((""Отправитель: %s\n""):format(NAME))
  io.write((""Следующая отправка через: %02d:%02d\n""):format(m, s))
  io.write(""Нажми Ctrl+C для остановки.\n"")
end

-- первое сообщение сразу
pcall(say, MESSAGE)
drawStatus(PERIOD)

-- слушаем Ctrl+C и считаем секунды
local running = true
event.listen(""interrupted"", function() running = false end)

while running do
  for t = PERIOD, 1, -1 do
    drawStatus(t)
    -- ждём любое событие до 1 сек; если было Ctrl+C, running станет false
    local name = event.pull(1)
    if not running or name == ""interrupted"" then running = false; break end
  end
  if not running then break end
  pcall(say, MESSAGE)
  drawStatus(PERIOD)
end

event.ignore(""interrupted"", function() running=false end)
term.clear()
term.setCursor(1,1)
print(""Остановлено."")
"
2Wi4a9cz,get question from bank,342fdfdfg,PHP,Wednesday 29th of October 2025 11:13:53 PM CDT,"public function getQuestions(Request $request)
    {
        $messages = [
            '*.bank_id.required' => 'Please Select Question Bank.',
        ];        

        $data = $request->validate([
            '*.bank_id' => 'required',
            '*.format' => 'nullable',
            '*.topic' => 'nullable',
        ], $messages);

        $quizzes = collect();

        foreach ($data as $item) {            
            $bank = QuestionBank::with([
                'quizzes' => function ($q) use ($item) {
                    $q->select([
                        'quizzes.id','quizzes.title','quizzes.difficulty',
                        'quizzes.type','quizzes.question_type',
                        'quizzes.parent_id','quizables.quizable_id'
                    ])
                    ->with(['quizzes' => function ($subQ) {
                        $subQ->select([
                            'quizzes.id','quizzes.title','quizzes.difficulty',
                            'quizzes.type','quizzes.question_type','quizzes.parent_id'
                        ]);
                    }])
                    ->when($item['format'], fn($query) => $query->where('quizzes.type', $item['format']))
                    ->when($item['topic'], fn($query) => $query->where('quizzes.question_type', $item['topic']));
                }
            ])->find($item['bank_id']);
            

            if ($bank) {
                $quizzes = $quizzes->merge($bank->quizzes);
            }
            
        }

        return response()->json($quizzes);
    }"
FWf8YQ6x,choose from bank,342fdfdfg,JavaScript,Wednesday 29th of October 2025 11:07:21 PM CDT,"<template>
    <div>
        <div v-if=""!submitted"">
            <div class=""step-indicator"">
                <div class=""progress-bar"" :style=""{ width: progressWidth }""></div>
                <div v-for=""step in totalSteps"" :key=""step"" class=""step""
                    :class=""{ active: currentStep === step, completed: currentStep > step, }"">
                    <div class=""step-number"">{{ step }}</div>
                    <div class=""step-title"">{{ stepTitles[step - 1] }}</div>
                </div>
            </div>

            <form @submit.prevent=""handleSubmit"">
                <div class=""form-content"">
                    <!-- Step 1 -->
                    <div class=""container step-content"" :class=""{ active: currentStep === 1 }"">
                        <div class=""row border border-2 mb-2"" v-for=""(item, index) in formData"" :key=""index"">
                            <div class=""col-4 form-group p-2"">
                                <InputLabel label=""Question Bank"" required />
                                <v-select 
                                    v-model=""item.bank_id"" 
                                    :options=""questionBanks""
                                    :reduce=""(option) => option.id"" 
                                    class=""text-uppercase clickoutside"" 
                                    label=""name""
                                    placeholder='Select Bank' 
                                />
                                <input-errors
                                    :name=""`${index}.bank_id`""
                                    :errors=""errors""
                                />
                            </div>
                            <div class=""col-4 form-group p-2"">
                                <InputLabel label=""Question Format"" />
                                <v-select v-model=""item.format"" :options=""questionFormats""
                                    :get-option-label=""(option) => option.replace(/_/g, ' ')"" class=""text-uppercase""
                                    placeholder=""Select Format"" />
                            </div>

                            <div class=""col-3 form-group p-2"">
                                <InputLabel label=""Question Topic"" />
                                <v-select v-model=""item.topic"" :options=""questionTypeOptions""
                                    :reduce=""(option) => option.id"" class=""text-uppercase""
                                    placeholder=""Select a topic"" />
                            </div>

                            <!-- <div class=""col-3 form-group p-2"">
                                <InputLabel label=""Difficulty"" />
                                <v-select 
                                    v-model=""item.difficulties""
                                    :options=""getDifficultiesOptions""
                                    class=""text-uppercase""
                                    placeholder=""Select Difficulty label""
                                    multiple
                                />
                            </div> -->

                            <!-- <div class=""col-3 form-group p-2"">
                                <InputLabel label=""Total"" />
                                <InputText v-model=""item.total"" class=""input-lg"" />
                            </div> -->

                            <div @click=""removeForm(index)""
                                class=""col-1 d-flex align-items-center justify-content-end mt-2 text-danger"">
                                <i class=""mdi mdi-delete-empty-outline clickable"" style=""font-size: 36px""></i>
                            </div>

                        </div>
                        <div class=""d-flex justify-content-end"">
                            <button type=""button"" class=""btn btn-danger"" @click=""addForm(index)"">Add More</button>
                        </div>
                    </div>

                    <!-- Step 2 -->
                    <div class=""step-content"" :class=""{ active: currentStep === 2 }"">
                        <div class=""d-flex flex-column gap-3"">
                            <template v-for=""question in quizzes"" :key=""question.id"">
                                <!-- Regular Question -->
                                <div v-if=""!question.quizzes.length""
                                    :class=""['question-card', { selected: isSelected(question.id) }]""
                                    @click=""toggleQuestion(question)"">
                                    <div class=""d-flex gap-3 align-items-start"">
                                        <div class=""icon-box flex-shrink-0"">
                                            <input type=""checkbox"" :checked=""isSelected(question.id)""
                                                class=""form-check-input"" />
                                        </div>
                                        <div class=""flex-grow-1"">
                                            <p v-html=""question.title"" class=""mb-2 text-dark lh-base""></p>
                                            <div class=""d-flex gap-2 flex-wrap"">
                                                <span class=""badge bg-info"">
                                                    {{ formatType(question.type) }}
                                                </span>
                                                <span class=""badge bg-primary"">
                                                    {{ formatType(question.question_type) }}
                                                </span>
                                                <span class=""badge bg-dark"">
                                                    {{ capitalizeFirst(question.difficulty) }}
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Group Question with Sub-questions -->
                                <div v-else class=""border rounded p-3"" style=""background-color: #f8f9fa"">
                                    <div :class=""['question-card mb-3', { selected: isSelected(question.id) }]""
                                        @click=""toggleQuestion(question)"">
                                        <div class=""d-flex gap-3 align-items-start"">
                                            <div class=""icon-box flex-shrink-0"">
                                                <input type=""checkbox"" :checked=""isSelected(question.id)""
                                                    class=""form-check-input"" />
                                            </div>
                                            <div class=""flex-grow-1"">
                                                <h5 v-html=""question.title"" class=""mb-2 fw-semibold text-dark""></h5>                                            </div>
                                        </div>
                                    </div>
                                    <div class=""d-flex flex-column gap-2 ms-4"">
                                        <div v-for=""subQuestion in question.questions"" :key=""subQuestion.id""
                                            :class=""['question-card', { selected: isSelected(subQuestion.id) }]""
                                            @click=""toggleQuestion(subQuestion)"">
                                            <div class=""d-flex gap-3 align-items-start"">
                                                <div class=""icon-box flex-shrink-0"">
                                                    <input type=""checkbox"" :checked=""isSelected(subQuestion.id)""
                                                        class=""form-check-input"" />
                                                </div>
                                                <div class=""flex-grow-1"">
                                                    <p class=""mb-2 text-dark lh-base"">{{question.title}}</p>
                                                    <div class=""d-flex gap-2 flex-wrap"">
                                                        <span class=""badge bg-info"">
                                                            {{ formatType(subQuestion.type) }}
                                                        </span>
                                                        <span class=""badge bg-primary"">
                                                            {{ formatType(subQuestion.question_type) }}
                                                        </span>
                                                        <span class=""badge bg-dark"">
                                                            {{ capitalizeFirst(subQuestion.difficulty) }}
                                                        </span>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <div class=""d-flex justify-content-between gap-2 mt-4"">
                    <button type=""button"" class=""btn-prev"" @click=""prevStep"" :disabled=""currentStep === 1"">
                        Previous
                    </button>
                    <button v-if=""currentStep < totalSteps"" type=""button"" class=""btn-next"" @click=""nextStep"">
                        Next
                    </button>
                    <button v-else type=""submit"" class=""btn-submit"">
                        Submit
                    </button>
                </div>
            </form>
        </div>
    </div>
</template>

<script setup>
import { ref, computed, reactive } from ""vue"";
import InputLabel from ""@/components/partials/InputLabel.vue"";
import vSelect from ""vue-select"";
import axios from ""axios"";
import { notifyMe } from ""@/helpers"";


const props = defineProps({
    questionBanks: Array,
    questionFormats: Array,
    questionTypeOptions: Array,
    difficultyLabels: Array
})

const currentStep = ref(2);
const totalSteps = 2;
const submitted = ref(false);

const stepTitles = [""Qurstion Bank Info"", ""Select Questions""];

const newData = { bank_id: '', format: '', topic: '' };

const formData = ref([
    { ...newData }
])

const questions = ref([
    {
        id: 1,
        text: ""<p>q1</p>"",
        type: ""expression_of_ideas"",
        difficulty: 'easy'
    },
    {
        id: 2,
        text: ""Compare and contrast the perspectives of two characters in a text of your choice, focusing on their motivations and conflicts."",
        type: ""expression_of_ideas"",
        difficulty: 'hard'
    },
    {
        id: 3,
        text: ""Write a persuasive essay arguing for or against the implementation of school uniforms in public schools."",
        type: ""expression_of_ideas"",
        difficulty: 'medium'
    },
    {
        id: 4,
        text: ""Identify and explain three examples of figurative language in a poem we have studied this semester."",
        type: ""expression_of_ideas"",
        difficulty: 'easy'
    },
    {
        id: 5,
        text: ""Passage Text"",
        questions: [
            {
                id: 6,
                text: ""Analyze how the author develops the theme of identity in the novel To Kill a Mockingbird."",
                type: ""expression_of_ideas"",
                difficulty: 'easy'
            },
            {
                id: 7,
                text: ""Compare and contrast the perspectives of two characters in a text of your choice, focusing on their motivations and conflicts."",
                type: ""expression_of_ideas"",
                difficulty: 'easy'
            }
        ]
    }

]);

const quizzes = ref([]);
const errors = ref({});

const selectedQuestions = ref([]);

const progressWidth = computed(
    () => `${((currentStep.value - 1) / (totalSteps - 1)) * 100}%`
);

const isSelected = (questionId) => selectedQuestions.value.includes(questionId);

const toggleQuestion = (question) => {
    const ids = question.questions
        ? [question.id, ...question.questions.map((q) => q.id)]
        : [question.id];
    const allSelected = ids.every((id) => isSelected(id));

    if (allSelected) {
        selectedQuestions.value = selectedQuestions.value.filter(
            (id) => !ids.includes(id)
        );
    } else {
        selectedQuestions.value = [
            ...new Set([...selectedQuestions.value, ...ids]),
        ];
    }
};

const nextStep = async () => {
    try {
        quizzes.value = [];
        const { data } = await axios.post(route('adaptive.get-bank-questions'), formData.value);
        quizzes.value = data;
        currentStep.value++;
        formData.value = [{ ...newData }];
    } catch (error) {
        if (error.response && error.response.status === 422) {
            errors.value = error.response.data.errors;
            notifyMe(error.response.data.message, ""error"");
        } else {
            notifyMe(error.message, ""error"");
        }
    }
};

const prevStep = () => currentStep.value--;

const handleSubmit = () => {
    console.log(""Form Data:"", formData);
    submitted.value = true;
};

const addForm = () => {
    formData.value.push({ ...newData })
}

const removeForm = (index) => {
    formData.value.splice(index, 1)
}

const formatType = (type) => {
    return type?.split('_')?.length > 1
        ? type?.split('_').map(word => capitalizeFirst(word)).join(' ')
        : capitalizeFirst(type);
}

const capitalizeFirst = (str) => str?.charAt(0).toUpperCase() + str?.slice(1);

/* const withAllOptions = (selected, list) => {
    return selected.includes(""All"") ? [""All""] : [""All"", ...list];
};

const getQuestionFormatOptions = computed(() =>
    withAllOptions(form.formats, props.questionFormats)
);

const getTypesOptions = computed(() =>
    withAllOptions(form.types, props.questionTypeOptions)
);

const getDifficultiesOptions = computed(() =>
    withAllOptions(form.difficulties, props.difficultyLabels)
); */


const getQuestionFormatOptions = computed(() => {
    if (form.formats.includes(""All"")) {
        return (form.formats = [""All""]);
    }
    return [""All"", ...props.questionFormats];
});
const getTypesOptions = computed(() => {
    if (form.types.includes(""All"")) {
        return (form.types = [""All""]);
    }
    return [{ id: ""All"", label: ""All"" }, ...props.questionTypeOptions];
});
const getDifficultiesOptions = computed(() => {
    if (form.difficulties.includes(""All"")) {
        return (form.difficulties = [""All""]);
    }
    return [""All"", ...props.difficultyLabels];
});


</script>

<style scoped>
.step-indicator {
    display: flex;
    justify-content: space-between;
    margin-bottom: 40px;
    position: relative;
}

.step-indicator::before {
    content: """";
    position: absolute;
    top: 22px;
    left: 0;
    right: 0;
    height: 3px;
    background: #e0e0e0;
    z-index: 0;
}

.step-indicator .progress-bar {
    position: absolute;
    top: 22px;
    left: 0;
    height: 3px;
    background: #667eea;
    z-index: 1;
    transition: width 0.3s ease;
}

.step {
    flex: 1;
    text-align: center;
    position: relative;
    z-index: 2;
}

.step-number {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    background: #e0e0e0;
    color: #666;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    margin-bottom: 10px;
    transition: all 0.3s ease;
    font-size: 18px;
}

.step.active .step-number {
    background: #667eea;
    color: white;
    transform: scale(1.15);
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
}

.step.completed .step-number {
    background: #48bb78;
    color: white;
}

.step-title {
    font-size: 14px;
    color: #666;
    font-weight: 600;
}

.step.active .step-title {
    color: #667eea;
}

.step-content {
    display: none;
    animation: fadeIn 0.4s ease;
}

.step-content.active {
    display: block;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateX(20px);
    }

    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.step-content h3 {
    color: #333;
    margin-bottom: 25px;
    font-size: 22px;
}

button {
    padding: 12px 35px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.3s ease;
    font-family: inherit;
}

.btn-prev {
    background: #6c757d;
    color: white;
}

.btn-prev:hover:not(:disabled) {
    background: #5a6268;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
}

.btn-next,
.btn-submit {
    background: #667eea;
    color: white;
    flex: 1;
}

.btn-next:hover,
.btn-submit:hover {
    color: white;
    background: #764ba2;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
}

button:disabled {
    background: #ccc;
    cursor: not-allowed;
    opacity: 0.6;
}

button:disabled:hover {
    transform: none;
    box-shadow: none;
}

::v-deep(.vs__search) {
    height: calc(1.5em + 1rem + 2px);
}

::v-deep(.input-lg) {
    height: calc(1.5em + 1rem + 12px);
}

.single-quiz {
    background: #f6fefe;
    padding: 0.6rem;
    border-radius: 5px 5px 0 0;
}

.question-card {
    border: 2px solid #e5e7eb;
    border-radius: 0.5rem;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    background-color: white;
}

.question-card:hover {
    border-color: #a5b4fc;
    background-color: #f9fafb;
}

.question-card.selected {
    border-color: #6366f1;
    background-color: #eef2ff;
}

.icon-box {
    margin-top: 0.25rem;
    flex-shrink: 0;
}

.selected-info {
    background-color: #eef2ff;
    border: 1px solid #c7d2fe;
    border-radius: 0.5rem;
}
</style>
"
FaQuTPaG,EDA Lab #10-2,david_gimenez,C,Wednesday 29th of October 2025 10:52:24 PM CDT,"#include <stdio.h>
#include <stdlib.h>

int sumaDigitosPares(int numero) {
    int ultimoDigito;

    if (numero < 0) {
        numero = -numero;
    }

    if (numero == 0) {
        return 0;
    }

    ultimoDigito = numero % 10;

    if (ultimoDigito % 2 == 0) {
        return ultimoDigito + sumaDigitosPares(numero / 10);
    } else {
        return sumaDigitosPares(numero / 10);
    }
}


void recorrerVector(int *vector, int tam, int indice, int *numeroMayor, int *sumaMayor) {
    int sumaActual;

    if (indice >= tam) {
        return;
    }

    sumaActual = sumaDigitosPares(vector[indice]);
    
    printf(""Numero: %d -> Suma de digitos pares: %d\n"", vector[indice], sumaActual);

    if (sumaActual > *sumaMayor) {
        *sumaMayor = sumaActual;
        *numeroMayor = vector[indice];
    }

    recorrerVector(vector, tam, indice + 1, numeroMayor, sumaMayor);
}

int main() {
    int tam, i;
    int *vector;
    int numeroMayor = 0;
    int sumaMayor = -1;

    printf(""Ingrese la cantidad de numeros: "");
    scanf(""%d"", &tam);
    
    if (tam <= 0) {
        printf(""Error: La cantidad debe ser mayor a 0\n"");
        return 1;
    }

    vector = (int *)malloc(tam * sizeof(int));
    
    if (vector == NULL) {
        printf(""Error al asignar memoria\n"");
        return 1;
    }

    printf(""\nIngrese los %d numeros:\n"", tam);
    for (i = 0; i < tam; i++) {
        printf(""vec[%d]="", i);
        scanf(""%d"", &vector[i]);
    }
    
    recorrerVector(vector, tam, 0, &numeroMayor, &sumaMayor);
    
    printf(""\nNumero con mayor suma de digitos pares: %d\n"", numeroMayor);
    printf(""Suma de sus digitos pares: %d\n"", sumaMayor);
    
    free(vector);
    
    return 0;
}"
9TcbWzju,EDA Lab #10-1,david_gimenez,C,Wednesday 29th of October 2025 10:49:27 PM CDT,"#include <stdio.h>
#include <stdlib.h>

int pascal(int fila, int columna) {
    if (columna == 0 || columna == fila) {
        return 1;
    }
    return pascal(fila - 1, columna - 1) + pascal(fila - 1, columna);
}

void imprimirTrianguloPascal(int numFilas) {
    int i, j;
    
    for (i = 0; i < numFilas; i++) {
        for (j = 0; j < numFilas - i - 1; j++) {
            printf(""   "");
        }
        
        for (j = 0; j <= i; j++) {
            printf(""%4d  "", pascal(i, j));
        }
        printf(""\n"");
    }
}

int main() {
    int numFilas;

    printf(""Ingrese el numero de filas para el Triangulo de Pascal: "");
    scanf(""%d"", &numFilas);
    printf(""\n"");
    
    if (numFilas > 0 && numFilas <= 20) { // n=34 ya tiene overflow, 20 parece amigable
        imprimirTrianguloPascal(numFilas);
    } else {
        printf(""Por favor ingrese un numero entre 1 y 20"");
    }
    
    return 0;
}"
i9bgW0q3,EDA Lab #09,david_gimenez,C,Wednesday 29th of October 2025 10:37:12 PM CDT,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

struct NodoPila {
    char caracter;
    struct NodoPila* siguiente;
};

struct NodoCola {
    char caracter;
    struct NodoCola* siguiente;
};

void apilar(struct NodoPila** pila, char c) {
    struct NodoPila* nuevoNodo = (struct NodoPila*)malloc(sizeof(struct NodoPila));
    nuevoNodo->caracter = c;
    nuevoNodo->siguiente = *pila;
    *pila = nuevoNodo;
}

char desapilar(struct NodoPila** pila) {
    if (*pila == NULL) return '\0';
    struct NodoPila* temp = *pila;
    char c = temp->caracter;
    *pila = temp->siguiente;
    free(temp);
    return c;
}

void encolar(struct NodoCola** cola, char c) {
    struct NodoCola* nuevoNodo = (struct NodoCola*)malloc(sizeof(struct NodoCola));
    nuevoNodo->caracter = c;
    nuevoNodo->siguiente = NULL;

    if (*cola == NULL) {
        *cola = nuevoNodo;
    } else {
        struct NodoCola* temp = *cola;
        while (temp->siguiente != NULL) {
            temp = temp->siguiente;
        }
        temp->siguiente = nuevoNodo;
    }
}

char desencolar(struct NodoCola** cola) {
    if (*cola == NULL) return '\0';
    struct NodoCola* temp = *cola;
    char c = temp->caracter;
    *cola = temp->siguiente;
    free(temp);
    return c;
}

void eliminarSaltoDeLinea(char *cadena) {
    int i = 0;
    while (cadena[i] != '\0') {
        if (cadena[i] == '\n') {
            cadena[i] = '\0';
            break;
        }
        i++;
    }
}

int esPalindromo(char* frase) {
    struct NodoPila* pila = NULL;
    struct NodoCola* cola = NULL;

    int i = 0;
    while (frase[i] != '\0') {
        if (isalpha(frase[i])) {
            char c = tolower(frase[i]);
            apilar(&pila, c);
            encolar(&cola, c);
        }
        i++;
    }

    while (pila != NULL && cola != NULL) {
        char c1 = desapilar(&pila);
        char c2 = desencolar(&cola);
        if (c1 != c2) {
            while (pila != NULL) desapilar(&pila);
            while (cola != NULL) desencolar(&cola);
            return 0;
        }
    }

    return 1;
}

int main() {
    char frase[256];

    while (1) {
        printf(""Introduce una frase (o '#' para terminar): "");
        fgets(frase, sizeof(frase), stdin);
        eliminarSaltoDeLinea(frase);

        if (strcmp(frase, ""#"") == 0) {
            break;
        }

        if (esPalindromo(frase)) {
            printf(""La frase es un palindromo.\n"");
        } else {
            printf(""La frase NO es un palindromo.\n"");
        }
    }

    return 0;
}"
PNv7Gu7Y,Two Sum (Sorted Input) - LeetCode,titan2400,Java,Wednesday 29th of October 2025 10:29:02 PM CDT,"// Two Sum - Input Array is sorted - https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/

class Solution {
    // Two pointers
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    public int[] twoSum(int[] numbers, int target) {
        int i = 0, j = numbers.length - 1;

        while(i < j) {
            if(numbers[i] + numbers[j] == target) {
                return new int[]{i+1, j+1};
            }
            else if (numbers[i] + numbers[j] > target) {
                j--;
            } else {
                i++;
            }
        }

        return new int[]{};
        
    }
}"
HaUH5wjW,Valid Palindrome - LeetCode,titan2400,Java,Wednesday 29th of October 2025 10:27:42 PM CDT,"// Valid Palindrome - https://leetcode.com/problems/valid-palindrome/

class Solution {

    // Time Complexity: O(n)
    // Space Complexity: O(n)
    // public boolean isPalindrome(String s) {
    //     s = s.toLowerCase();
    //     StringBuilder sb = new StringBuilder();

    //     for(int i = 0; i < s.length(); i++) {
    //         Character c = s.charAt(i);

    //         if(Character.isLetterOrDigit(c)) {
    //             sb.append(c);
    //         }
    //     }

    //     String toCheck = sb.toString();
    //     int i = 0, j = toCheck.length() - 1;

    //     while(i < j) {
    //         if(toCheck.charAt(i) != toCheck.charAt(j)) {
    //             return false;
    //         }
    //         i++;
    //         j--;
    //     }

    //     return true;
    // }


    // Time Complexity: O(n)
    // Space Complexity: O(n)
    // Similar to above but compact code
    // public boolean isPalindrome(String s) {
    //     StringBuilder sb = new StringBuilder();
    //     for(int i = 0; i < s.length(); i++) {
    //         Character c = s.charAt(i);

    //         if(Character.isLetterOrDigit(c)) {
    //             sb.append(Character.toLowerCase(c));
    //         }
    //     }

    //     return sb.toString().equals(sb.reverse().toString());
    // }

    // Two pointers optimized
    // Time Complexity: O(n)
    // Space Complexity: O(1)
    public boolean isPalindrome(String s) {
        int l = 0, r = s.length() - 1;

        while (l < r) {
            while (l < r && !alphaNum(s.charAt(l))) {
                l++;
            }
            while (r > l && !alphaNum(s.charAt(r))) {
                r--;
            }
            if (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r))) {
                return false;
            }
            l++; r--;
        }
        return true;
    }

    public boolean alphaNum(char c) {
        return (c >= 'A' && c <= 'Z' ||
                c >= 'a' && c <= 'z' ||
                c >= '0' && c <= '9');
    }
}"
LCxxNQXT,Mods Command,JonesofJustice,JavaScript,Wednesday 29th of October 2025 09:41:02 PM CDT,"// index.tsx (Bun v1.3 runtime)
import { Hono } from ""hono@4"";
import { cors } from ""hono/cors"";

const app = new Hono();

const strings = [
  ""Plant the seeds of doubt"",
  ""Break his Razer Naga"",
  ""Ban his Runescape account"",
  ""Break the TOS"",
  ""Purge the chat"",
  ""Link the allegations"",
  ""Put him in a room"",
  ""Microwave him"",
  ""Give him the wrong drop"",
  ""Bring him the cope machine"",
  ""Shave his beard"",
  ""Dye his hair"",
  ""Get him a RAID sponsor"",
  ""Make him mod Geupard12"",
  ""Ban Ice cloud"",
  ""Put him on stilts"",
  ""Pay for his leg extensions"",
  ""Sever his ethernet cable"",
  ""I'm not in the mood to execute this command"",
  ""Reset their runelite plugins"",
  ""Reset his phone to factory"",
  ""Reset his browser"",
  ""Spawn a mirrorback"",
  ""Defenestrate him"",
  ""Stab him"",
  ""Ban him"",
  ""Kill him"",
  ""Just kill him"",
  ""Take him out back"",
  ""Upgrade him"",
  ""EXTERMINATE!"",
  ""Investigate him"",
  ""Ban Geupard12"",
  ""Send him to the bees dimension"",
  ""Ship him to the bees"",
  ""Teleport him to the woods"",
  ""Rustle his jimmies"",
  ""Grind his gears"",
  ""Organize his bank"",
  ""Steal pippin from him"",
  ""Put raccoons in his walls"",
  ""Eat his leftovers"",
  ""Break his windows"",
  ""Toilet paper his house"",
  ""Egg his house"",
  ""Throw eggs at him"",
  ""Throw rotten tomatoes at him"",
  ""Add him to the perpetual stew"",
  ""Tell his wife"",
  ""Call him short"",
  ""Wish him a good night"",
  ""Dent his hair"",
  ""/timeout Ice_Cloud 10"",
  ""Help, Mika has created sentient life for this command and I must scream"",
  ""AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"",
  ""Add one electron to every atom in his body"",
  ""Shoot this guy"",
  ""Export him to png"",
  ""Push back his hairline"",
  ""Revoke his citizenship"",
  ""Remove his depth perception"",
  ""Laugh at him"",
  ""Cut his pizza unevenly"",
  ""You know what to do"",
  ""Lay his soul to rest"",
  ""Spam the chat"",
  ""Type 1"",
  ""Ban the dissenters"",
  ""Tie him up and force him to watch tiktok brainrot"",
  ""Make him used Ranged"",
  ""Burn him with fire"",
  ""Send him to QBD"",
  ""Make him do QBD without antifires"",
  ""Make him do The World Wakes"",
  ""Make him outrun the balls"",
  ""Kill Guthix again"",
  ""Send balls his way"",
  ""Tell him to eat bees"",
  ""Eat bees"",
  ""Widen his favourite emote"",
  ""Do a Croesus hour"",
  ""Do your hourlies DinkDonk"",
  ""Do your reapers"",
  ""Force him to skill"",
  ""Kill him with the cores"",
  ""Make him run through Entrana church"",
  ""Say something sus"",
  ""Pet pippin"",
  ""Make a prediction"",
  ""Give him a random allergy"",
  ""End the stream"",
  ""Delay the next leagues"",
  ""Squish that cat petthewidepippin"",
  ""Make him base"",
  ""Get him a throat coat sponsor"",
  ""Desync his audio"",
  ""Send him to Quebec"",
  ""Ban the french"",
  ""DDOS the entire city of Ottawa"",
  ""Send a blizzard to his house"",
  ""Biden blast him"",
];

// Enable CORS for all routes
app.use(""/*"", cors());

// Root route: return random string
app.get(""/"", (c) => {
  const random = strings[Math.floor(Math.random() * strings.length)];
  return c.text(random);
});

Bun.serve({
  port: Number(process.env.PORT) || 3000,
  fetch: app.fetch,
});

console.log(
  `Server running on http://localhost:${process.env.PORT || 3000}`
);
"
VL2XSiza,CAMINO AL AJUSTE II bug encontrado,ceska12,Autohotkey,Wednesday 29th of October 2025 08:55:23 PM CDT,"#Requires AutoHotkey v2.0
#SingleInstance Force
#WinActivateForce

; ===== CONFIGURACIÓN ACELERADA =====
SendMode ""Input""
SetWorkingDir A_ScriptDir

; ===== DISTRIBUCIÓN POR PERFIL =====
global symbols := Map(""cherry"", 32, ""bell"", 26, ""lemon"", 17, ""star"", 13, ""diamond"", 7, ""seven"", 4, ""joker"", 1)
global symbolValues := Map(""cherry"", 2, ""bell"", 4, ""lemon"", 7, ""star"", 12, ""diamond"", 24, ""seven"", 48, ""joker"", 0, ""three_jokers"", 80)
global spinning := false
global imgPath := ""imgs\""
global soundPath := ""sounds\""
global spinDuration := 500
global spinInterval := 30
global img1, img2, img3
global lastWin := false
global statsFile := ""slot_stats.ini""
global detailedStatsFile := ""detailed_stats.ini""
global configFile := ""slot_config.ini""
global savedSettingsFile := ""AfinacionesGuardadas.ini"" ; <<< NUEVA VARIABLE PARA AFINACIONES
global autoSpin := false
global autoSpinCount := 0
global maxAutoSpins := 1000
global lastUpdateCount := 0
global jackpotValue := 100
global jackpotCounter := 0
global testingMode := true  ; ← ACTIVADO PARA PRUEBAS
global DetailedStatsGui := """"
global ReportEdit := """"
global symbolWin := """"
global rescueThreshold := 35


; ===== ESTADÍSTICAS DE SISTEMAS DE AYUDA (SIMPLIFICADAS) =====
global pityActivations := 0, pityWins := 0, pityPesos := 0
global multiplierActivationsCount := 0, multiplierWins := 0, multiplierPesosExtra := 0
global jokerActivations := 0, jokerWins := 0, jokerPesos := 0
global jackpotActivations := 0, jackpotWins := 0, jackpotPesos := 0

; ===== NUEVAS VARIABLES PARA ANÁLISIS AVANZADO =====
global symbolFrequency := Map()
global combinationStats := Map()
global volatilityStats := Map()
global rtpBreakdown := Map()

; ===== SISTEMA DE MULTIPLICADORES =====
global multiplierProbability := 25
global multiplierValue := 2.0
global multiplierActivations := 0
global totalMultiplierPesos := 0

; ===== SISTEMA DE PERFILES RTP =====
global RTPProfiles := Map(""RTP35"", 35.0, ""RTP40"", 40.0, ""RTP45"", 45.0, ""RTP50"", 50.0)
global enableJokerSounds := false
global currentProfile := ""RTP40""
global targetRTP := RTPProfiles[currentProfile]

; ===== SISTEMA PITY COUNTER =====
global pityCounter := 0
global pityThreshold := 25
global originalPityThreshold := 20

; ===== SISTEMA BONUS MEJORADO =====
global bonusLights := 0
global maxBonusGiros := 25
global bonusLetters := [""B"", ""O"", ""N"", ""U"", ""S""]
global letterOrder := []
global bonusThresholds := []

; ===== INICIALIZAR ESTADISTICAS =====
global totalSpins := 0
global totalWins := 0
global totalPesos := 0
global winStats := Map()
global pesosStats := Map()

; ===== ESTADISTICAS DETALLADAS =====
global detailedTotalSpins := 0
global detailedTotalWins := 0
global detailedTotalPesos := 0
global detailedJackpotsWon := 0
global detailedCompensations := 0
global detailedCompensationCount := 0
global detailedWinStats := Map()
global detailedPesosStats := Map()
global detailedJokerRespines := 0
global detailedJokerRespinWins := 0
global detailedJokerRespinPesos := 0

; ===== NUEVAS ESTADISTICAS AVANZADAS =====
global currentLosingStreak := 0
global longestLosingStreak := 0
global symbolWinCounts := Map()
global symbolRTPContributions := Map()
global jokerRTPContribution := 0

; ===== INICIALIZAR LISTA DE SÍMBOLOS =====
global symbolList := []

; ===== VARIABLES RTP MEJORADO =====
global safetyNetThreshold := 40
global safetyNetActive := false
global safetyNetBoost := false
global jokerEffectivenessRTP35 := 20
global jokerEffectivenessRTP40 := 30
global jokerEffectivenessRTP45 := 40
global jokerEffectivenessRTP50 := 80

; ===== SISTEMA DE RESCATE DE VOLATILIDAD MEJORADO =====
global rescueSpinsWithoutWin := 0
global lastRescueSpin := 0
global rescueMinSpinsBetween := 200
global rescueActivations := 0
global rescuePesos := 0
global rescueSymbols := [""lemon"", ""star"", ""bell""]  ; Símbolos naturales para rescates
global rescueActive := false  ; Nueva variable para controlar estado

; ===== INTERFAZ GRAFICA =====
MyGui := Gui(""+AlwaysOnTop +Resize +OwnDialogs -MaximizeBox"", ""Tragamonedas JACKPOT 5000 giros"")
MyGui.MarginX := 10
MyGui.MarginY := 10
MyGui.SetFont(""s12"", ""Arial"")
MyGui.Opt(""+OwnDialogs"")

; Slot machine frame
MyGui.Add(""GroupBox"", ""w340 h150 Center"", ""Tragamonedas"")
MyGui.Add(""Picture"", ""vSlot1 xp+10 yp+25 w100 h100 Border"", imgPath . ""question.png"")
MyGui.Add(""Picture"", ""vSlot2 x+10 w100 h100 Border"", imgPath . ""question.png"")
MyGui.Add(""Picture"", ""vSlot3 x+10 w100 h100 Border"", imgPath . ""question.png"")

; Mostrar jackpot actual en una línea
MyGui.Add(""Text"", ""xm y+10 w180 Center"", ""Contador Jackpot:"")
JackpotCounterText := MyGui.Add(""Text"", ""x+0 yp w160 Center"", ""0/5000"")

; Logo Joker Giro Gratis - CENTRADO
MyGui.Add(""Picture"", ""vJokerLogo xm+80 y+5 w180 h35"", imgPath . ""joker_giro_gratis_apagado.png"")

; Display de BONUS
MyGui.Add(""Picture"", ""vBonusSlot1 xm+125 y+10 w20 h30"", imgPath . ""bonus_empty.png"")
MyGui.Add(""Picture"", ""vBonusSlot2 x+2 w20 h30"", imgPath . ""bonus_empty.png"")
MyGui.Add(""Picture"", ""vBonusSlot3 x+2 w20 h30"", imgPath . ""bonus_empty.png"")
MyGui.Add(""Picture"", ""vBonusSlot4 x+2 w20 h30"", imgPath . ""bonus_empty.png"")
MyGui.Add(""Picture"", ""vBonusSlot5 x+2 w20 h30"", imgPath . ""bonus_empty.png"")

; Botones de giro en una línea
SpinBtn := MyGui.Add(""Button"", ""xm y+20 w100 h25"", ""1 Moneda"")
SpinBtn.OnEvent(""Click"", StartSpin)
SpinBtn.Opt(""+Default"")

Spin1000Btn := MyGui.Add(""Button"", ""x+10 w100 h25"", ""1000"")
Spin1000Btn.OnEvent(""Click"", Start1000Spins)

Spin10000Btn := MyGui.Add(""Button"", ""x+10 w100 h25"", ""10000"")
Spin10000Btn.OnEvent(""Click"", Start10000Spins)

; === NUEVO BOTÓN ULTRA-RÁPIDO ===
UltraTestBtn := MyGui.Add(""Button"", ""xm y+10 w340 h30 cFFFFFF Background009900"", ""🔥 PRUEBA ULTRA-RÁPIDA 50000"")
UltraTestBtn.OnEvent(""Click"", StartUltraTest)

; === NUEVO BOTÓN EXPORTAR DATOS ===
ExportBtn := MyGui.Add(""Button"", ""xm y+5 w165 h25 cFFFFFF Background3366FF"", ""📊 EXPORTAR CSV"")
ExportBtn.OnEvent(""Click"", ExportTestData)

; === NUEVO BOTÓN EXPORTAR TXT ===
ExportTxtBtn := MyGui.Add(""Button"", ""x+10 yp w165 h25 cFFFFFF BackgroundFF6600"", ""📝 EXPORTAR TXT"")
ExportTxtBtn.OnEvent(""Click"", ExportTestResults)

; Boton de seleccion de perfil
ProfileBtn := MyGui.Add(""Button"", ""xm y+10 w340 h30"", ""Seleccionar Perfil RTP"")
ProfileBtn.OnEvent(""Click"", ShowProfileMenu)

; Indicador de perfil actual
CurrentProfileText := MyGui.Add(""Text"", ""xm y+5 w340 Center cFF9900"", ""Perfil Actual: RTP 40%"")

; Estadisticas
MyGui.Add(""GroupBox"", ""xm y+10 w340 h190 Center"", ""Estadisticas"")  ; ← Reducir altura
MyGui.Add(""Text"", ""xp+10 yp+25 w120"", ""Monedas totales:"")
TotalSpinsText := MyGui.Add(""Text"", ""vTotalSpinsText x+5 w50"", ""0"")
MyGui.Add(""Text"", ""xp-125 y+5 w120"", ""Pesos ganados:"")
TotalPesosText := MyGui.Add(""Text"", ""vTotalPesosText x+5 w50"", ""0"")
MyGui.Add(""Text"", ""xp-125 y+5 w120"", ""Jugador gana:"")
PlayerWinPercent := MyGui.Add(""Text"", ""vPlayerWinPercent x+5 w70"", ""0%"")
MyGui.Add(""Text"", ""xp-125 y+5 w120"", ""Maquina gana:"")
MachineWinPercent := MyGui.Add(""Text"", ""vMachineWinPercent x+5 w70"", ""100%"")
MyGui.Add(""Text"", ""xp-125 y+5 w120"", ""Giros sin ganar:"")
PityCounterText := MyGui.Add(""Text"", ""vPityCounterText x+5 w70"", ""0/20"")

; === NUEVO INDICADOR DE RESCATE ===
MyGui.Add(""Text"", ""xp-125 y+5 w120"", ""Rescates:"")
RescueCounterText := MyGui.Add(""Text"", ""vRescueCounterText x+5 w70"", ""0"")

StatsBtn := MyGui.Add(""Button"", ""xm+20 y+15 w140 h35"", ""Ver Detalles"")
StatsBtn.OnEvent(""Click"", ShowStats)

ResetBtn := MyGui.Add(""Button"", ""x+20 w140 h35"", ""Resetear Stats"")
ResetBtn.OnEvent(""Click"", ResetStats)

; Atajo de teclado para abrir el menú de estadísticas detalladas
9::ShowDetailedStats

MyGui.OnEvent(""Close"", GuiClose)
MyGui.Show(""AutoSize Center"")

; Inicializar después de crear la GUI
UpdateSymbolList()
LoadStats()
LoadDetailedStats()
InitializeAdvancedStats()
RandomizeBonusOrder()
RandomizeBonusThresholds()
LoadConfig()
LoadAfinacionesGuardadas() ; <--- ¡NUEVA LLAMADA PARA CARGAR AFINACIONES!

; Inicializar RTP de sesión
UpdateJokerStatus()

;
; ===== FUNCIÓN PARA CARGAR AFINACIONES GUARDADAS (AfinacionesGuardadas.ini) =====
;
LoadAfinacionesGuardadas() {
    ; Declarar variables globales necesarias
    global savedSettingsFile, currentProfile, symbols, pityThreshold, jokerEffectivenessRTP35
    global jokerEffectivenessRTP40, jokerEffectivenessRTP45, jokerEffectivenessRTP50, multiplierProbability
    global multiplierValue, safetyNetThreshold, targetRTP, RTPProfiles, CurrentProfileText
    global PityCounterText, MyGui, testingMode, symbolList

    ; 1. Comprobar si el archivo de afinaciones existe
    if (!FileExist(savedSettingsFile)) {
        if (testingMode) {
            OutputDebug(""⚠️ Archivo de afinaciones '"" . savedSettingsFile . ""' no encontrado. Usando configuración por defecto/slot_config.ini.`n"")
        }
        return
    }

    ; 2. Leer el perfil actualmente activo del archivo de afinaciones.
    ;    Asumimos que el perfil activo está guardado en la sección ""Afinacion"" bajo la clave ""CurrentProfile"".
    savedProfile := IniRead(savedSettingsFile, ""Afinacion"", ""CurrentProfile"", currentProfile)

    ; 3. Cargar configuraciones guardadas si el perfil existe como sección en el INI.
    ;    Los valores se leerán bajo una sección que coincide con el nombre del perfil (e.g., [RTP40])
    sectionName := savedProfile

    ; Leer valores, usando """" como default para saber si fueron encontrados
    loadedPity := IniRead(savedSettingsFile, sectionName, ""PityThreshold"", """")
    loadedProb := IniRead(savedSettingsFile, sectionName, ""MultiplierProbability"", """")
    loadedValue := IniRead(savedSettingsFile, sectionName, ""MultiplierValue"", """")

    ; 4. Aplicar los nuevos valores SOLO si se encontraron
    if (loadedPity != """") {
        pityThreshold := Integer(loadedPity)
    }
    if (loadedProb != """") {
        multiplierProbability := Integer(loadedProb)
    }
    ; Asegurarse de que el valor del multiplicador se lea como Float
    if (loadedValue != """") {
        multiplierValue := Float(loadedValue)
    }

    ; 5. Si el perfil guardado es diferente al actual, sobrescribir y recargar la configuración base.
    ;    Esto asegura que los defaults de símbolos y otros parámetros se actualicen correctamente
    if (savedProfile != currentProfile) {
        currentProfile := savedProfile
        LoadConfig() ; Se re-ejecuta LoadConfig() para aplicar los defaults del nuevo perfil (símbolos, etc.).
    }

    ; 6. Mensaje de depuración y actualización de interfaz
    if (testingMode) {
        OutputDebug(""✅ Afinaciones Guardadas cargadas. Perfil: "" . currentProfile . "". Pity: "" . pityThreshold . "". Prob Multi: "" . multiplierProbability . "". Valor Multi: "" . multiplierValue . ""`n"")
    }

    ; Re-actualizar display después de posibles cambios en pityThreshold y targetRTP
    targetRTP := RTPProfiles.Has(currentProfile) ? RTPProfiles[currentProfile] : 0.0
    CurrentProfileText.Value := ""Perfil Actual: "" . currentProfile . "" ("" . targetRTP . ""%)""
    PityCounterText.Value := pityCounter . ""/"" . pityThreshold
    UpdateSymbolList() ; Asegurar que la lista de símbolos se actualice.
}

; ===== FUNCIÓN EXPORTAR RESULTADOS TXT CORREGIDA =====
ExportTestResults(*) {
    global currentProfile, targetRTP, totalSpins, totalPesos, detailedTotalSpins, detailedTotalPesos
    global multiplierProbability, multiplierValue, testingMode

    if (totalSpins = 0) {
        MsgBox(""No hay datos para exportar. Realiza algunos giros primero."", ""Sin Datos"", ""48"")
        return
    }

    ; ✅ CALCULAR RTP CON SEGURIDAD
    currentRTP := 0
    if (totalSpins > 0) {
        currentRTP := (totalPesos / totalSpins) * 100
    }

    deviation := currentRTP - targetRTP

    ; Crear nombre de archivo con timestamp
    timestamp := FormatTime(, ""yyyy-MM-dd_HH-mm-ss"")
    filename := ""Resultado_Precision_"" . currentProfile . ""_"" . timestamp . "".txt""

    content := ""=== RESULTADO PRECISIÓN "" . currentProfile . "" ===`n""
    content .= ""Timestamp: "" . timestamp . ""`n""
    content .= ""Perfil: "" . currentProfile . "" (Objetivo: "" . targetRTP . ""%)`n""
    content .= ""Giros totales: "" . totalSpins . ""`n""
    content .= ""RTP Final: "" . Round(currentRTP, 3) . ""%`n""
    content .= ""Desviación: "" . Round(deviation, 3) . ""%`n""
    content .= ""Multiplicador final: "" . multiplierProbability . ""% / "" . multiplierValue . ""x`n""
    content .= ""Precisión: "" . (Abs(deviation) <= 0.5 ? ""✅ EXCELENTE"" : (Abs(deviation) <= 1.0 ? ""⚠️ ACEPTABLE"" : ""❌ INACEPTABLE"")) . ""`n""
    content .= ""`n""
    content .= ""=== DETALLES ADICIONALES ===`n""
    content .= ""Giros detallados: "" . detailedTotalSpins . ""`n""
    content .= ""Pesos detallados: "" . detailedTotalPesos . ""`n""
    content .= ""Fecha de análisis: "" . FormatTime(, ""dd/MM/yyyy HH:mm:ss"") . ""`n""

    try {
        FileAppend(content, filename)
        if (testingMode) {
            OutputDebug(""📊 RESULTADO EXPORTADO: "" . filename . ""`n"")
        }
        MsgBox(""✅ Archivo TXT exportado correctamente:`n"" . filename, ""Exportación Exitosa"", ""4096"")
    } catch Error as e {
        OutputDebug(""❌ ERROR exportando: "" . e.Message . ""`n"")
        MsgBox(""❌ Error al exportar archivo TXT:`n"" . e.Message, ""Error de Exportación"", ""16"")
    }
}
CheckVolatilityRescue() {
    global currentProfile, rescueSpinsWithoutWin, rescueThreshold, rescueMinSpinsBetween, lastRescueSpin, totalSpins
    global rescueActive, symbolValues, img1, img2, img3, symbolWin
    global totalPesos, detailedTotalPesos, totalWins, detailedTotalWins
    global winStats, detailedWinStats, pesosStats, detailedPesosStats
    global pityCounter, currentLosingStreak, MyGui, imgPath, testingMode
    global rescueActivations, rescuePesos

    ; ✅ USA rescueThreshold EN LUGAR DE NÚMERO FIJO
    if (rescueSpinsWithoutWin >= rescueThreshold && (totalSpins - lastRescueSpin) >= rescueMinSpinsBetween) {
        rescueActive := true

        ; 🎯 MODIFICACIÓN CRÍTICA: SOLO RTP35 USA CHERRY EXCLUSIVO
        if (currentProfile = ""RTP35"") {
            lowValueRescueSymbols := [""cherry""]  ; ← SOLO CHERRY PARA RTP35
        } else {
            lowValueRescueSymbols := [""cherry"", ""bell""]  ; ← NORMAL PARA OTROS PERFILES
        }

        ; Seleccionar símbolo de rescate
        rescueSymbol := lowValueRescueSymbols[Random(1, lowValueRescueSymbols.Length)]
        rescuePrize := symbolValues[rescueSymbol]

        if (rescuePrize > 0) {
            ; Forzar combinación ganadora
            img1 := rescueSymbol
            img2 := rescueSymbol
            img3 := rescueSymbol
            symbolWin := rescueSymbol

            ; Actualizar display visual inmediatamente
            MyGui[""Slot1""].Value := imgPath . rescueSymbol . "".png""
            MyGui[""Slot2""].Value := imgPath . rescueSymbol . "".png""
            MyGui[""Slot3""].Value := imgPath . rescueSymbol . "".png""

            ; Procesar la victoria
            HandleRescueWin(rescueSymbol, rescuePrize)

            ; Actualizar contadores
            rescueActivations++
            rescuePesos += rescuePrize
            lastRescueSpin := totalSpins
            rescueSpinsWithoutWin := 0
            pityCounter := 0
            currentLosingStreak := 0

            ; Actualizar display de estadísticas
            UpdateStatsDisplay()

            ; Mostrar notificación en modo testing
            if (testingMode) {
                OutputDebug(""🎯 RESCATE ACTIVADO: "" . rescueSymbol . "" - "" . rescuePrize . "" pesos`n"")
            }

            rescueActive := false
            return true
        }
        rescueActive := false
    }
    return false
}

GetRescuePrize() {
    global rescueSymbols, symbolValues

    ; Seleccionar símbolo natural para el rescate
    rescueSymbol := rescueSymbols[Random(1, rescueSymbols.Length)]

    ; Pagar el valor EXACTO de la figura
    return symbolValues[rescueSymbol]
}

HandleRescueWin(symbol, prize) {
    global totalWins, detailedTotalWins, winStats, detailedWinStats
    global totalPesos, detailedTotalPesos, pesosStats, detailedPesosStats
    global lastWin, pityCounter, currentLosingStreak, rescueSpinsWithoutWin

    lastWin := true
    totalWins++
    detailedTotalWins++
    pityCounter := 0
    currentLosingStreak := 0
    rescueSpinsWithoutWin := 0

    ; Registrar estadísticas
    winStats[symbol] := winStats.Has(symbol) ? winStats[symbol] + 1 : 1
    detailedWinStats[symbol] := detailedWinStats.Has(symbol) ? detailedWinStats[symbol] + 1 : 1

    pesosStats[symbol] := pesosStats.Has(symbol) ? pesosStats[symbol] + prize : prize
    detailedPesosStats[symbol] := detailedPesosStats.Has(symbol) ? detailedPesosStats[symbol] + prize : prize

    totalPesos += prize
    detailedTotalPesos += prize

    ; Actualizar display
    UpdateStatsDisplay()
    UpdateJokerStatus()
}

; ===== NUEVA FUNCIÓN: INICIALIZAR ESTADÍSTICAS AVANZADAS =====
InitializeAdvancedStats() {
    global symbolFrequency, combinationStats, volatilityStats, rtpBreakdown, symbols
    global rescueSpinsWithoutWin, lastRescueSpin, rescueActivations, rescuePesos, rescueActive

    ; Inicializar frecuencia de símbolos
    symbolFrequency := Map()
    for symbol in symbols {
        symbolFrequency[symbol] := 0
    }

    ; Inicializar estadísticas de combinaciones
    combinationStats := Map()

    ; Inicializar métricas de volatilidad
    volatilityStats := Map()
    volatilityStats[""CurrentLosingStreak""] := 0
    volatilityStats[""LongestLosingStreak""] := 0
    volatilityStats[""CurrentWinningStreak""] := 0
    volatilityStats[""LongestWinningStreak""] := 0
    volatilityStats[""SpinsBetweenWins""] := []
    volatilityStats[""WinDistribution""] := Map()

    ; Inicializar desglose de RTP
    rtpBreakdown := Map()
    rtpBreakdown[""Base_Symbols""] := 0
    rtpBreakdown[""Pity_System""] := 0
    rtpBreakdown[""Joker_Respins""] := 0
    rtpBreakdown[""Multipliers""] := 0
    rtpBreakdown[""Jackpot""] := 0
    rtpBreakdown[""Rescue_System""] := 0
    rtpBreakdown[""Total""] := 0

    ; Inicializar sistema de rescate
    rescueSpinsWithoutWin := 0
    lastRescueSpin := 0
    rescueActivations := 0
    rescuePesos := 0
    rescueActive := false
}

UpdateSymbolList() {
    global symbols, symbolList
    symbolList := []
    for symbol, count in symbols {
        Loop count {
            symbolList.Push(symbol)
        }
    }
}

LoadStats() {
    global statsFile, totalSpins, totalWins, totalPesos, winStats, pesosStats, symbols, jackpotCounter, pityCounter
    global rescueSpinsWithoutWin, lastRescueSpin, rescueActivations, rescuePesos

    if FileExist(statsFile) {
        totalSpins := Integer(IniRead(statsFile, ""Stats"", ""TotalSpins"", ""0""))
        totalWins := Integer(IniRead(statsFile, ""Stats"", ""TotalWins"", ""0""))
        totalPesos := Integer(IniRead(statsFile, ""Stats"", ""TotalPesos"", ""0""))
        jackpotCounter := Integer(IniRead(statsFile, ""Stats"", ""JackpotCounter"", ""0""))
        pityCounter := Integer(IniRead(statsFile, ""Stats"", ""PityCounter"", ""0""))
        rescueSpinsWithoutWin := Integer(IniRead(statsFile, ""Rescue"", ""SpinsWithoutWin"", ""0""))
        lastRescueSpin := Integer(IniRead(statsFile, ""Rescue"", ""LastRescueSpin"", ""0""))
        rescueActivations := Integer(IniRead(statsFile, ""Rescue"", ""Activations"", ""0""))
        rescuePesos := Integer(IniRead(statsFile, ""Rescue"", ""TotalPesos"", ""0""))

        for symbol in symbols {
            winStats[symbol] := Integer(IniRead(statsFile, ""Symbols"", symbol, ""0""))
            pesosStats[symbol] := Integer(IniRead(statsFile, ""Pesos"", symbol, ""0""))
        }
        winStats[""three_jokers""] := Integer(IniRead(statsFile, ""Symbols"", ""three_jokers"", ""0""))
        pesosStats[""three_jokers""] := Integer(IniRead(statsFile, ""Pesos"", ""three_jokers"", ""0""))
    } else {
        ; Inicializar valores si no existen
        totalSpins := 0
        totalWins := 0
        totalPesos := 0
        jackpotCounter := 0
        pityCounter := 0
        rescueSpinsWithoutWin := 0
        lastRescueSpin := 0
        rescueActivations := 0
        rescuePesos := 0

        for symbol in symbols {
            winStats[symbol] := 0
            pesosStats[symbol] := 0
        }
        winStats[""three_jokers""] := 0
        pesosStats[""three_jokers""] := 0
    }

    ; Actualizar la interfaz
    UpdateStatsDisplay()
}

SaveStats() {
    global statsFile, totalSpins, totalWins, totalPesos, winStats, pesosStats, jackpotCounter, pityCounter
    global rescueSpinsWithoutWin, lastRescueSpin, rescueActivations, rescuePesos

    IniWrite(totalSpins, statsFile, ""Stats"", ""TotalSpins"")
    IniWrite(totalWins, statsFile, ""Stats"", ""TotalWins"")
    IniWrite(totalPesos, statsFile, ""Stats"", ""TotalPesos"")
    IniWrite(jackpotCounter, statsFile, ""Stats"", ""JackpotCounter"")
    IniWrite(pityCounter, statsFile, ""Stats"", ""PityCounter"")
    IniWrite(rescueSpinsWithoutWin, statsFile, ""Rescue"", ""SpinsWithoutWin"")
    IniWrite(lastRescueSpin, statsFile, ""Rescue"", ""LastRescueSpin"")
    IniWrite(rescueActivations, statsFile, ""Rescue"", ""Activations"")
    IniWrite(rescuePesos, statsFile, ""Rescue"", ""TotalPesos"")

    for symbol, count in winStats {
        IniWrite(count, statsFile, ""Symbols"", symbol)
        IniWrite(pesosStats[symbol], statsFile, ""Pesos"", symbol)
    }
}

LoadDetailedStats() {
    global detailedStatsFile, detailedTotalSpins, detailedTotalWins, detailedTotalPesos, detailedJackpotsWon, detailedWinStats, detailedPesosStats, symbols, detailedCompensations, detailedCompensationCount, multiplierActivations, totalMultiplierPesos, detailedJokerRespines, detailedJokerRespinWins, detailedJokerRespinPesos
    global currentLosingStreak, longestLosingStreak
    global rescueSpinsWithoutWin, lastRescueSpin, rescueActivations, rescuePesos

    if FileExist(detailedStatsFile) {
        detailedTotalSpins := Integer(IniRead(detailedStatsFile, ""Stats"", ""TotalSpins"", ""0""))
        detailedTotalWins := Integer(IniRead(detailedStatsFile, ""Stats"", ""TotalWins"", ""0""))
        detailedTotalPesos := Integer(IniRead(detailedStatsFile, ""Stats"", ""TotalPesos"", ""0""))
        detailedJackpotsWon := Integer(IniRead(detailedStatsFile, ""Stats"", ""JackpotsWon"", ""0""))
        detailedCompensations := Integer(IniRead(detailedStatsFile, ""Stats"", ""TotalCompensations"", ""0""))
        detailedCompensationCount := Integer(IniRead(detailedStatsFile, ""Stats"", ""CompensationCount"", ""0""))
        multiplierActivations := Integer(IniRead(detailedStatsFile, ""Multipliers"", ""ActivationCount"", ""0""))
        totalMultiplierPesos := Integer(IniRead(detailedStatsFile, ""Multipliers"", ""TotalPesos"", ""0""))
        detailedJokerRespines := Integer(IniRead(detailedStatsFile, ""Joker"", ""Respines"", ""0""))
        detailedJokerRespinWins := Integer(IniRead(detailedStatsFile, ""Joker"", ""RespinWins"", ""0""))
        detailedJokerRespinPesos := Integer(IniRead(detailedStatsFile, ""Joker"", ""RespinPesos"", ""0""))
        rescueSpinsWithoutWin := Integer(IniRead(detailedStatsFile, ""Rescue"", ""SpinsWithoutWin"", ""0""))
        lastRescueSpin := Integer(IniRead(detailedStatsFile, ""Rescue"", ""LastRescueSpin"", ""0""))
        rescueActivations := Integer(IniRead(detailedStatsFile, ""Rescue"", ""Activations"", ""0""))
        rescuePesos := Integer(IniRead(detailedStatsFile, ""Rescue"", ""TotalPesos"", ""0""))

        for symbol in symbols {
            detailedWinStats[symbol] := Integer(IniRead(detailedStatsFile, ""Symbols"", symbol, ""0""))
            detailedPesosStats[symbol] := Integer(IniRead(detailedStatsFile, ""Pesos"", symbol, ""0""))
        }
        detailedWinStats[""three_jokers""] := Integer(IniRead(detailedStatsFile, ""Symbols"", ""three_jokers"", ""0""))
        detailedPesosStats[""three_jokers""] := Integer(IniRead(detailedStatsFile, ""Pesos"", ""three_jokers"", ""0""))

        ; Cargar nuevas estadísticas avanzadas
        currentLosingStreak := Integer(IniRead(detailedStatsFile, ""AdvancedMetrics"", ""CurrentLosingStreak"", ""0""))
        longestLosingStreak := Integer(IniRead(detailedStatsFile, ""AdvancedMetrics"", ""LongestLosingStreak"", ""0""))

    } else {
        ; Inicializar valores si no existen
        detailedTotalSpins := 0
        detailedTotalWins := 0
        detailedTotalPesos := 0
        detailedJackpotsWon := 0
        detailedCompensations := 0
        detailedCompensationCount := 0
        multiplierActivations := 0
        totalMultiplierPesos := 0
        currentLosingStreak := 0
        longestLosingStreak := 0
        rescueSpinsWithoutWin := 0
        lastRescueSpin := 0
        rescueActivations := 0
        rescuePesos := 0

        for symbol in symbols {
            detailedWinStats[symbol] := 0
            detailedPesosStats[symbol] := 0
        }
        detailedWinStats[""three_jokers""] := 0
        detailedPesosStats[""three_jokers""] := 0
    }
}

SaveDetailedStats() {
    global detailedStatsFile, detailedTotalSpins, detailedTotalWins, detailedTotalPesos, detailedJackpotsWon, detailedWinStats, detailedPesosStats, detailedCompensations, detailedCompensationCount, multiplierActivations, totalMultiplierPesos, detailedJokerRespines, detailedJokerRespinWins, detailedJokerRespinPesos
    global longestLosingStreak, symbolRTPContributions, jokerRTPContribution, symbolValues
    global rescueSpinsWithoutWin, lastRescueSpin, rescueActivations, rescuePesos

    RTP := 0
    if (detailedTotalSpins > 0) {
        RTP := Round((detailedTotalPesos / detailedTotalSpins) * 100, 2)
    }

    ; Calcular RTP por símbolo
    symbolRTPContributions := Map()
    for symbol, pesos in detailedPesosStats {
        if (detailedTotalPesos > 0) {
            symbolRTPContributions[symbol] := Round((pesos / detailedTotalPesos) * RTP, 2)
        } else {
            symbolRTPContributions[symbol] := 0
        }
    }

    ; Calcular contribución del Joker
    jokerRTPContribution := 0
    if (detailedTotalPesos > 0) {
        jokerRTPContribution := Round((detailedJokerRespinPesos / detailedTotalPesos) * RTP, 2)
    }

    IniWrite(detailedTotalSpins, detailedStatsFile, ""Stats"", ""TotalSpins"")
    IniWrite(detailedTotalWins, detailedStatsFile, ""Stats"", ""TotalWins"")
    IniWrite(detailedTotalPesos, detailedStatsFile, ""Stats"", ""TotalPesos"")
    IniWrite(detailedJackpotsWon, detailedStatsFile, ""Stats"", ""JackpotsWon"")
    IniWrite(detailedCompensations, detailedStatsFile, ""Stats"", ""TotalCompensations"")
    IniWrite(detailedCompensationCount, detailedStatsFile, ""Stats"", ""CompensationCount"")
    IniWrite(RTP, detailedStatsFile, ""Stats"", ""RTP"")
    IniWrite(multiplierActivations, detailedStatsFile, ""Multipliers"", ""ActivationCount"")
    IniWrite(totalMultiplierPesos, detailedStatsFile, ""Multipliers"", ""TotalPesos"")
    IniWrite(detailedJokerRespines, detailedStatsFile, ""Joker"", ""Respines"")
    IniWrite(detailedJokerRespinWins, detailedStatsFile, ""Joker"", ""RespinWins"")
    IniWrite(detailedJokerRespinPesos, detailedStatsFile, ""Joker"", ""RespinPesos"")
    IniWrite(rescueSpinsWithoutWin, detailedStatsFile, ""Rescue"", ""SpinsWithoutWin"")
    IniWrite(lastRescueSpin, detailedStatsFile, ""Rescue"", ""LastRescueSpin"")
    IniWrite(rescueActivations, detailedStatsFile, ""Rescue"", ""Activations"")
    IniWrite(rescuePesos, detailedStatsFile, ""Rescue"", ""TotalPesos"")

    for symbol, count in detailedWinStats {
        IniWrite(count, detailedStatsFile, ""Symbols"", symbol)
        IniWrite(detailedPesosStats[symbol], detailedStatsFile, ""Pesos"", symbol)
    }

    ; Escribir nuevas métricas avanzadas
    IniWrite(longestLosingStreak, detailedStatsFile, ""AdvancedMetrics"", ""LongestLosingStreak"")
    IniWrite(currentLosingStreak, detailedStatsFile, ""AdvancedMetrics"", ""CurrentLosingStreak"")

    ; Escribir contribución RTP por símbolo
    for symbol, rtp in symbolRTPContributions {
        IniWrite(rtp, detailedStatsFile, ""RTPBySymbol"", symbol)
    }

    ; Escribir contribución RTP del Joker
    IniWrite(jokerRTPContribution, detailedStatsFile, ""RTPBySymbol"", ""joker_respin_rtp"")
}

LoadConfig() {
    ; DECLARAR EXPLÍCITAMENTE TODAS LAS VARIABLES GLOBALES
    global currentProfile, symbols, pityThreshold, jokerEffectivenessRTP35, jokerEffectivenessRTP40
    global jokerEffectivenessRTP45, jokerEffectivenessRTP50, multiplierProbability, multiplierValue
    global safetyNetThreshold, targetRTP, RTPProfiles, CurrentProfileText, MyGui, PityCounterText
    global rescueSpinsWithoutWin, rescueMinSpinsBetween

    currentProfile := IniRead(configFile, ""Config"", ""CurrentProfile"", ""RTP40"")

    ; CONFIGURACIÓN MEJORADA
    ;symbols := Map(""cherry"", 25, ""bell"", 26, ""lemon"", 17, ""star"", 12, ""diamond"", 7, ""seven"", 6, ""joker"", 1)
    if (currentProfile = ""RTP35"") {
    symbols := Map(""cherry"", 25, ""bell"", 26, ""lemon"", 17, ""star"", 12, ""diamond"", 7, ""seven"", 6, ""joker"", 1)
    pityThreshold := 35
    multiplierProbability := 10
    rescueSpinsWithoutWin := 70
    multiplierValue := 2.0
    jokerEffectivenessRTP35 := 20
    safetyNetThreshold := 45
    rescueMinSpinsBetween := 200
} else if (currentProfile = ""RTP40"") {
    symbols := Map(""cherry"", 30, ""bell"", 25, ""lemon"", 19, ""star"", 12, ""diamond"", 7, ""seven"", 5, ""joker"", 2)
    pityThreshold := 25
    jokerEffectivenessRTP40 := 30  ; ← DE 50 A 30
    multiplierProbability := 25
    multiplierValue := 2.2
    safetyNetThreshold := 30
    rescueThreshold := 35
    rescueMinSpinsBetween := 80
} else if (currentProfile = ""RTP45"") {
    symbols := Map(""cherry"", 27, ""bell"", 23, ""lemon"", 20, ""star"", 15, ""diamond"", 6, ""seven"", 5, ""joker"", 4)
    pityThreshold := 25
    jokerEffectivenessRTP45 := 40
    multiplierProbability := 20
    multiplierValue := 2.5
    safetyNetThreshold := 30
    rescueThreshold := 33
    rescueMinSpinsBetween := 160
} else if (currentProfile = ""RTP50"") {
    symbols := Map(""cherry"", 25, ""bell"", 21, ""lemon"", 21, ""star"", 14, ""diamond"", 9, ""seven"", 7, ""joker"", 3)
    pityThreshold := 25
    jokerEffectivenessRTP50 := 80
    multiplierProbability := 45
    multiplierValue := 3.5
    safetyNetThreshold := 30
    rescueThreshold := 33
    rescueMinSpinsBetween := 100
}

    ; Leer valores de configuración si existen
    pityThreshold := Integer(IniRead(configFile, ""Config"", ""PityThreshold"", pityThreshold))
    multiplierProbability := Integer(IniRead(configFile, ""Multipliers"", ""ActivationProbability"", multiplierProbability))
    multiplierValue := Float(IniRead(configFile, ""Multipliers"", ""MultiplierValue"", multiplierValue))

    targetRTP := RTPProfiles[currentProfile]
    CurrentProfileText.Value := ""Perfil Actual: "" . currentProfile . "" ("" . targetRTP . ""%)""

    if (currentProfile = ""RTP35"")
        CurrentProfileText.Opt(""c007ACC"")
    else if (currentProfile = ""RTP40"")
        CurrentProfileText.Opt(""cFF9900"")
    else if (currentProfile = ""RTP45"")
        CurrentProfileText.Opt(""cFF3366"")
    else if (currentProfile = ""RTP50"")
        CurrentProfileText.Opt(""c00FF00"")

    MyGui.Title := ""Tragamonedas AHK - JACKPOT a 5000 giros""
    PityCounterText.Value := pityCounter . ""/"" . pityThreshold

    UpdateSymbolList()  ; ← ACTUALIZAR LISTA DE SÍMBOLOS
}

SaveConfig() {
    global configFile, currentProfile, pityThreshold, multiplierProbability, multiplierValue

    IniWrite(currentProfile, configFile, ""Config"", ""CurrentProfile"")
    IniWrite(pityThreshold, configFile, ""Config"", ""PityThreshold"")
    IniWrite(multiplierProbability, configFile, ""Multipliers"", ""ActivationProbability"")
    IniWrite(multiplierValue, configFile, ""Multipliers"", ""MultiplierValue"")
}

RandomizeBonusOrder() {
    global bonusLetters, letterOrder
    letterOrder := [""B"", ""O"", ""N"", ""U"", ""S""]
}

RandomizeBonusThresholds() {
    global bonusThresholds, currentProfile

    if (currentProfile = ""RTP35"") {
        ; BONUS A 30 GIROS PARA RTP35
        bonusThresholds := []
        bonusThresholds.Push(Random(4, 6))      ; B → 4–6
        bonusThresholds.Push(Random(9, 11))     ; O → 9–11 (ligeramente más cerca de B, transición suave)
        bonusThresholds.Push(Random(15, 17))    ; N → 15–17 (aumenta gradualmente la espera)
        bonusThresholds.Push(Random(21, 24))    ; U → 21–24 (casi el último antes del pity)
        bonusThresholds.Push(30)                ; S → 30 (pity fijo)
       } else {
        ; BONUS NORMAL A 25 GIROS
        bonusThresholds := []
        bonusThresholds.Push(Random(3, 5))       ; B
        bonusThresholds.Push(Random(8, 10))      ; O
        bonusThresholds.Push(Random(13, 15))     ; N
        bonusThresholds.Push(Random(18, 21))     ; U
        bonusThresholds.Push(25)                 ; S
    }
}

UpdateBonusLights() {
    global pityCounter, bonusThresholds, letterOrder, imgPath, MyGui

    lettersToShow := 0
    Loop 5 {
        if (pityCounter >= bonusThresholds[A_Index]) {
            lettersToShow := A_Index
        }
    }

    ; Apagar todas las luces primero
    Loop 5 {
        MyGui[""BonusSlot"" . A_Index].Value := imgPath . ""bonus_empty.png""
    }

    ; Encender las luces en ORDEN CONSECUTIVO
    Loop lettersToShow {
        letter := letterOrder[A_Index]
        if (letter = ""B"")
            MyGui[""BonusSlot"" . A_Index].Value := imgPath . ""bonus_B_red.png""
        else if (letter = ""O"")
            MyGui[""BonusSlot"" . A_Index].Value := imgPath . ""bonus_O_blue.png""
        else if (letter = ""N"")
            MyGui[""BonusSlot"" . A_Index].Value := imgPath . ""bonus_N_green.png""
        else if (letter = ""U"")
            MyGui[""BonusSlot"" . A_Index].Value := imgPath . ""bonus_U_yellow.png""
        else if (letter = ""S"")
            MyGui[""BonusSlot"" . A_Index].Value := imgPath . ""bonus_S_purple.png""
    }
}

ShowProfileMenu(*) {
    try {
        ProfileMenu := Menu()
        ProfileMenu.Add(""RTP 35%"", SetRTPProfile.Bind(""RTP35""))
        ProfileMenu.Add(""RTP 40%"", SetRTPProfile.Bind(""RTP40""))
        ProfileMenu.Add(""RTP 45%"", SetRTPProfile.Bind(""RTP45""))
        ProfileMenu.Add(""RTP 50%"", SetRTPProfile.Bind(""RTP50""))
        ProfileMenu.Show()
    }
}

SetRTPProfile(profileName, *) {
    ; DECLARAR EXPLÍCITAMENTE TODAS LAS VARIABLES GLOBALES
    global currentProfile, targetRTP, RTPProfiles, symbols, MyGui
    global pityThreshold, jokerEffectivenessRTP35, jokerEffectivenessRTP40
    global jokerEffectivenessRTP45, jokerEffectivenessRTP50, multiplierProbability, multiplierValue
    global safetyNetThreshold
	global rescueSpinsWithoutWin, rescueMinSpinsBetween

    currentProfile := profileName
    targetRTP := RTPProfiles[profileName]

   ; === CONFIGURACIÓN OPTIMIZADA GAMIFICACIÓN ===
   ;symbols := Map(""cherry"", 25, ""bell"", 26, ""lemon"", 17, ""star"", 12, ""diamond"", 7, ""seven"", 6, ""joker"", 1)
   if (currentProfile = ""RTP35"") {
    symbols := Map(""cherry"", 25, ""bell"", 26, ""lemon"", 17, ""star"", 12, ""diamond"", 7, ""seven"", 6, ""joker"", 1)
    pityThreshold := 35
    multiplierProbability := 10
    rescueSpinsWithoutWin := 70
    multiplierValue := 2.0
    jokerEffectivenessRTP35 := 20
    safetyNetThreshold := 45
    rescueMinSpinsBetween := 200
} else if (currentProfile = ""RTP40"") {
    symbols := Map(""cherry"", 30, ""bell"", 25, ""lemon"", 19, ""star"", 12, ""diamond"", 7, ""seven"", 5, ""joker"", 2)
    pityThreshold := 25
    jokerEffectivenessRTP40 := 30  ; ← DE 50 A 30
    multiplierProbability := 25
    multiplierValue := 2.2
    safetyNetThreshold := 30
    rescueThreshold := 35
    rescueMinSpinsBetween := 80
} else if (currentProfile = ""RTP45"") {
    symbols := Map(""cherry"", 27, ""bell"", 23, ""lemon"", 20, ""star"", 15, ""diamond"", 6, ""seven"", 5, ""joker"", 4)
    pityThreshold := 25
    jokerEffectivenessRTP45 := 40
    multiplierProbability := 20
    multiplierValue := 2.5
    safetyNetThreshold := 30
    rescueThreshold := 33
    rescueMinSpinsBetween := 160
} else if (currentProfile = ""RTP50"") {
    symbols := Map(""cherry"", 25, ""bell"", 21, ""lemon"", 21, ""star"", 14, ""diamond"", 9, ""seven"", 7, ""joker"", 3)
    pityThreshold := 25
    jokerEffectivenessRTP50 := 80
    multiplierProbability := 45
    multiplierValue := 3.5
    safetyNetThreshold := 30
    rescueThreshold := 33
    rescueMinSpinsBetween := 100
}

    UpdateSymbolList()
    UpdateProfileDisplay()
    ResetStats(0)

    ; GUARDAR CONFIGURACIÓN
    SaveConfig()

    MyGui.Opt(""+OwnDialogs"")
    MsgBox(""RTP configurado al "" . targetRTP . ""%"", ""Perfil Cambiado"", ""64"")
    MyGui.Title := ""Tragamonedas AHK - JACKPOT a 5000 giros""
    UpdateJokerStatus()
}

ResetProfileSettings() {
    global currentProfile, pityThreshold

    if (currentProfile = ""RTP35"") {
        pityThreshold := 35
    } else if (currentProfile = ""RTP40"") {
        pityThreshold := 25
    } else if (currentProfile = ""RTP45"") {
        pityThreshold := 25
    } else if (currentProfile = ""RTP50"") {
        pityThreshold := 25
    }

    SaveConfig()
}

UpdateProfileDisplay() {
    global currentProfile, targetRTP, CurrentProfileText, MyGui

    CurrentProfileText.Value := ""Perfil Actual: "" . currentProfile . "" ("" . targetRTP . ""%)""
    if (currentProfile = ""RTP35"")
        CurrentProfileText.Opt(""c007ACC"")
    else if (currentProfile = ""RTP40"")
        CurrentProfileText.Opt(""cFF9900"")
    else if (currentProfile = ""RTP45"")
        CurrentProfileText.Opt(""cFF3366"")
    else if (currentProfile = ""RTP50"")
        CurrentProfileText.Opt(""c00FF00"")

    MyGui.Title := ""Tragamonedas AHK - JACKPOT a 5000 giros""
}

CalculatePlayerWinPercent() {
    global totalSpins, totalPesos
    if (totalSpins = 0)
        return ""0%""
    playerWinPercent := (totalPesos / totalSpins) * 100
    return Round(playerWinPercent, 1) . ""%""
}

CalculateMachineWinPercent() {
    global totalSpins, totalPesos
    if (totalSpins = 0)
        return ""100%""
    machineWinPercent := ((totalSpins - totalPesos) / totalSpins) * 100
    return Round(machineWinPercent, 1) . ""%""
}

UpdateWinPercentages() {
    PlayerWinPercent.Value := CalculatePlayerWinPercent()
    MachineWinPercent.Value := CalculateMachineWinPercent()
}

UpdateJokerStatus() {
    global currentRTP, totalSpins, totalPesos, MyGui, imgPath

    if (totalSpins > 0) {
        currentRTP := (totalPesos / totalSpins) * 100
    } else {
        currentRTP := 0
    }

    if (currentRTP < targetRTP) {
        MyGui[""JokerLogo""].Value := imgPath . ""joker_giro_gratis_prendido.png""
    } else {
        MyGui[""JokerLogo""].Value := imgPath . ""joker_giro_gratis_apagado.png""
    }
}

Start1000Spins(*) {
    global spinning, autoSpin, testingMode, autoSpinCount, maxAutoSpins
    if spinning
        return
    autoSpin := true
    testingMode := true
    autoSpinCount := 0
    maxAutoSpins := 1000
    SpinBtn.Enabled := false
    Spin1000Btn.Enabled := false
    Spin10000Btn.Enabled := false
    SetTimer(AutoSpinLoop, 80)
}

Start10000Spins(*) {
    global spinning, autoSpin, testingMode, autoSpinCount, maxAutoSpins
    if spinning
        return
    autoSpin := true
    testingMode := true
    autoSpinCount := 0
    maxAutoSpins := 10000
    SpinBtn.Enabled := false
    Spin1000Btn.Enabled := false
    Spin10000Btn.Enabled := false
    SetTimer(AutoSpinLoop, 80)
}

StartUltraTest(*) {
    global spinning, autoSpin, testingMode, autoSpinCount, maxAutoSpins
    global symbols, symbolList  ; ← Asegurar que estas globales estén declaradas
    if spinning
        return
     ; === AGREGAR ESTA LÍNEA CRÍTICA ===
    UpdateSymbolList()  ; ← ¡ACTUALIZAR LA LISTA DE SÍMBOLOS!

    MyGui.Opt(""+OwnDialogs"")
    MsgBox(""🚀 INICIANDO PRUEBA ULTRA-RÁPIDA`n`n• 50,000 giros en 5-9 minutos`n• RTP teórico puro (sin ajustes dinámicos)`n• Sin animaciones ni sonidos`n• Resultados válidos al 100%"", ""Modo Pruebas Rápido"", ""4096"")

    autoSpin := true
    testingMode := true
    autoSpinCount := 0
    maxAutoSpins := 50000
    SpinBtn.Enabled := false
    Spin1000Btn.Enabled := false
    Spin10000Btn.Enabled := false
    UltraTestBtn.Enabled := false
    UltraTestBtn.Text := ""🔥 PROCESANDO... "" . autoSpinCount . ""/50000""

    SetTimer(UltraSpinLoop, 1)
}

UltraSpinLoop() {
    ; DECLARAR TODAS LAS VARIABLES GLOBALES UNA POR UNA
    global autoSpin, autoSpinCount, maxAutoSpins, spinning, totalSpins, detailedTotalSpins
    global img1, img2, img3, symbolWin, symbolList, targetRTP, totalPesos
    global detailedJokerRespines, detailedJokerRespinWins, UltraTestBtn
    global symbolFrequency, combinationStats, jokerActivations
    global jackpotCounter, jackpotValue, detailedJackpotsWon, pityCounter
    global detailedTotalPesos, testingMode, UpdateBonusLights, symbolValues
    global detailedJokerRespinPesos, jokerWins, jokerPesos
    global jackpotActivations, jackpotWins, jackpotPesos
    global currentLosingStreak, longestLosingStreak
    global currentProfile, safetyNetActive, safetyNetThreshold
    global rescueSpinsWithoutWin, lastRescueSpin, rescueMinSpinsBetween, rescueActivations, rescuePesos

    if spinning || autoSpinCount >= maxAutoSpins {
        if (autoSpinCount >= maxAutoSpins) {
            SetTimer(UltraSpinLoop, 0)
            autoSpin := false
            testingMode := false
            lastUpdateCount := 0

            SaveStats()
            SaveDetailedStats()

            ; ✅ NUEVO: EXPORTAR RESULTADOS AUTOMÁTICAMENTE - AGREGADO
            if (testingMode) {
                ExportTestResults()
            }

            SpinBtn.Enabled := true
            Spin1000Btn.Enabled := true
            Spin10000Btn.Enabled := true
            UltraTestBtn.Enabled := true
            UltraTestBtn.Text := ""🔥 PRUEBA ULTRA-RÁPIDA 50000""

            currentRTP := (totalPesos / totalSpins) * 100
            MyGui.Opt(""+OwnDialogs"")
            MsgBox(""✅ PRUEBA COMPLETADA`n`nGiros: "" . maxAutoSpins . ""`nRTP Final: "" . Round(currentRTP, 2) . ""%`nDesviación: "" . Round(currentRTP - targetRTP, 2) . ""%`n`n📊 Datos guardados en archivos INI"", ""Resultados Ultra-Rápidos"", ""4096"")
        }
        return
    }

    Critical true

    totalSpins++
    detailedTotalSpins++
    autoSpinCount++

        ; ACTUALIZACIÓN GARANTIZADA CADA 100 GIROS
    if (Mod(autoSpinCount, 100) == 0) {
        UltraTestBtn.Text := ""🔥 PROCESANDO... "" . autoSpinCount . ""/50000""
        UpdateStatsDisplay()
    }

    randIndex := Random(1, symbolList.Length)
    img1 := symbolList[randIndex]
    randIndex := Random(1, symbolList.Length)
    img2 := symbolList[randIndex]
    randIndex := Random(1, symbolList.Length)
    img3 := symbolList[randIndex]

    symbolFrequency[img1] := symbolFrequency.Get(img1, 0) + 1
    symbolFrequency[img2] := symbolFrequency.Get(img2, 0) + 1
    symbolFrequency[img3] := symbolFrequency.Get(img3, 0) + 1

    symbolWin := CheckWinCombination(img1, img2, img3)

    ; ===== VERIFICAR RESCATE DE VOLATILIDAD MEJORADO =====
    if (!symbolWin || symbolWin = false) {
        rescueSpinsWithoutWin++
        if (CheckVolatilityRescue()) {
            ; El rescate ya manejó la victoria, continuar al siguiente giro
            Critical false
            return
        }
    } else {
        rescueSpinsWithoutWin := 0
    }

    if (symbolWin is String && symbolWin != """") {
        HandleTripleWinUltra()
    } else if (img1 = ""joker"" || img2 = ""joker"" || img3 = ""joker"") {
        currentRTP := 0
        if (totalSpins > 0) {
            currentRTP := (totalPesos / totalSpins) * 100
        }

        if (currentRTP < targetRTP) {
            jokerActivations += 1
            detailedJokerRespines++

            if (img1 != ""joker"") {
                randIndex := Random(1, symbolList.Length)
                img1 := symbolList[randIndex]
            }
            if (img2 != ""joker"") {
                randIndex := Random(1, symbolList.Length)
                img2 := symbolList[randIndex]
            }
            if (img3 != ""joker"") {
                randIndex := Random(1, symbolList.Length)
                img3 := symbolList[randIndex]
            }

            symbolWin := CheckWinCombination(img1, img2, img3)
            if (symbolWin is String && symbolWin != """") {
                ; ✅ BLOQUE CORREGIDO - CONTADORES DE JOKER FIJOS
                pesosGanados := symbolValues.Has(symbolWin) ? symbolValues[symbolWin] : 2
                HandleTripleWinUltra()
                detailedJokerRespinWins += 1  ; ← SOLO 1 VICTORIA POR RESPIN
                detailedJokerRespinPesos += pesosGanados
                jokerWins += 1
                jokerPesos += pesosGanados
            } else {
                HandleLossUltra()
            }
        } else {
            HandleLossUltra()
        }
    } else {
        HandleLossUltra()
    }

    ; VERIFICACIÓN JACKPOT
    if (jackpotCounter >= 5000) {
        totalPesos += jackpotValue
        detailedTotalPesos += jackpotValue
        detailedJackpotsWon++
        jackpotCounter := 0
        pityCounter := 0
        UpdateBonusLights()

        ; ✅ CONTADORES DE SISTEMAS DE AYUDA
        jackpotActivations += 1
        jackpotWins += 1
        jackpotPesos += jackpotValue
    }

    Critical false
}

HandleTripleWinUltra() {
    global lastWin, totalWins, detailedTotalWins, winStats, detailedWinStats, pityCounter
    global totalPesos, detailedTotalPesos, pesosStats, detailedPesosStats, symbolWin, symbolValues
    global totalMultiplierPesos, multiplierActivations, multiplierValue, multiplierProbability
    global detailedJokerRespinPesos, combinationStats, multiplierActivationsCount, multiplierWins, multiplierPesosExtra
    global jokerWins, jokerPesos
    global currentLosingStreak, safetyNetActive, safetyNetBoost
    global rescueSpinsWithoutWin

    lastWin := true
    currentLosingStreak := 0
    rescueSpinsWithoutWin := 0
    totalWins++
    detailedTotalWins++
    pityCounter := 0

    pesosGanados := symbolValues.Has(symbolWin) ? symbolValues[symbolWin] : 2

    combinationStats[symbolWin] := combinationStats.Get(symbolWin, 0) + 1

    if (symbolWin = ""three_jokers"") {
        winStats[""three_jokers""] := winStats.Has(""three_jokers"") ? winStats[""three_jokers""] + 1 : 1
        detailedWinStats[""three_jokers""] := detailedWinStats.Has(""three_jokers"") ? detailedWinStats[""three_jokers""] + 1 : 1
    } else {
        winStats[symbolWin] := winStats.Has(symbolWin) ? winStats[symbolWin] + 1 : 1
        detailedWinStats[symbolWin] := detailedWinStats.Has(symbolWin) ? detailedWinStats[symbolWin] + 1 : 1

        if (Random(1, 100) <= (100 / multiplierProbability)) {
            multiplierActivations++
            multiplierActivationsCount++
            baseValue := symbolValues.Has(symbolWin) ? symbolValues[symbolWin] : 0
            multipliedValue := Round(baseValue * multiplierValue)
            totalMultiplierPesos += (multipliedValue - baseValue)
            multiplierPesosExtra += (multipliedValue - baseValue)
            multiplierWins += 1
            pesosGanados := multipliedValue
        }
    }

    totalPesos += pesosGanados
    detailedTotalPesos += pesosGanados

    if (symbolWin = ""three_jokers"") {
        pesosStats[""three_jokers""] := pesosStats.Has(""three_jokers"") ? pesosStats[""three_jokers""] + pesosGanados : pesosGanados
        detailedPesosStats[""three_jokers""] := detailedPesosStats.Has(""three_jokers"") ? detailedPesosStats[""three_jokers""] + pesosGanados : pesosGanados
    } else {
        pesosStats[symbolWin] := pesosStats.Has(symbolWin) ? pesosStats[symbolWin] + pesosGanados : pesosGanados
        detailedPesosStats[symbolWin] := detailedPesosStats.Has(symbolWin) ? detailedPesosStats[symbolWin] + pesosGanados : pesosGanados
    }
}

HandleLossUltra() {
    global lastWin, pityCounter, jackpotCounter, totalPesos, detailedTotalPesos, detailedCompensations, detailedCompensationCount, testingMode, currentProfile, totalSpins, pityThreshold, pityActivations, pityWins, pityPesos
    global currentLosingStreak, longestLosingStreak
    global safetyNetActive, safetyNetThreshold
    global rescueSpinsWithoutWin

    lastWin := false
    currentLosingStreak++
    if (currentLosingStreak > longestLosingStreak) {
        longestLosingStreak := currentLosingStreak
    }
    pityCounter++
    jackpotCounter++
    rescueSpinsWithoutWin++

    ; ✅ PRIMERO Pity Counter (MOVIDO ARRIBA)
    if (pityCounter >= pityThreshold) {
        pityCounter := 0
        compensation := 4

        if (compensation > 0) {
            detailedCompensations += compensation
            detailedCompensationCount++
            totalPesos += compensation
            detailedTotalPesos += compensation

            pityActivations += 1
            pityWins += 1
            pityPesos += compensation
            currentLosingStreak := 0
        }
    }

    ; ✅ LUEGO Safety Net (MOVIDO ABAJO)
    if (currentProfile = ""RTP35"" && currentLosingStreak >= safetyNetThreshold && !safetyNetActive) {
        safetyNetActive := false
        symbolWin := ""bell""
        HandleTripleWinUltra()
        safetyNetActive := false
        return
    }
}

ExportTestData(*) {
    global currentProfile, targetRTP, detailedTotalSpins, detailedTotalWins, detailedTotalPesos
    global symbolFrequency, combinationStats, symbols, symbolValues
    global detailedCompensations, detailedJokerRespines, detailedJokerRespinWins, detailedJokerRespinPesos
    global multiplierActivations, totalMultiplierPesos, detailedJackpotsWon, jackpotValue
    global longestLosingStreak, currentLosingStreak
    global pityActivations, pityWins, pityPesos, multiplierActivationsCount, multiplierWins, multiplierPesosExtra
    global jokerActivations, jokerWins, jokerPesos, jackpotActivations, jackpotWins, jackpotPesos
    global detailedPesosStats, detailedWinStats
    global rescueSpinsWithoutWin, rescueActivations, rescuePesos

    try {
        timestamp := FormatTime(, ""yyyy-MM-dd_HH-mm-ss"")
        filename := ""RTP_Analysis_"" . currentProfile . ""_"" . timestamp . "".csv""

        ; ✅ CALCULAR RTP CON SEGURIDAD
        currentRTP := 0
        if (detailedTotalSpins > 0) {
            currentRTP := (detailedTotalPesos / detailedTotalSpins) * 100
        }

        csvContent := """"

        csvContent .= ""ANÁLISIS RTP - PERFIL "" . currentProfile . ""`n""
        csvContent .= ""Timestamp,RTP_Teórico,RTP_Calculado,Total_Giros,Total_Victorias,Total_Pesos`n""
        csvContent .= timestamp . "","" . targetRTP . "","" . Round(currentRTP, 2) . "","" . detailedTotalSpins . "","" . detailedTotalWins . "","" . detailedTotalPesos . ""`n`n""

        ; ✅ SECCIÓN FRECUENCIA CORREGIDA - EVITA DIVISIÓN POR CERO
        csvContent .= ""FRECUENCIA DE SÍMBOLOS`n""
        csvContent .= ""Símbolo,Veces_Salió,Probabilidad_Real,Probabilidad_Teórica`n""

        totalSymbolAppearances := 0
        for symbol, count in symbolFrequency {
            totalSymbolAppearances += count
        }

        if (totalSymbolAppearances = 0) {
            ; Si no hay datos, mostrar valores en cero
            for symbol, count in symbolFrequency {
                theoreticalProbability := symbols.Has(symbol) ? (symbols[symbol] / 100) * 100 : 0
                csvContent .= symbol . "","" . count . "",0%,"" . theoreticalProbability . ""%`n""
            }
        } else {
            ; Calcular probabilidades normalmente
            for symbol, count in symbolFrequency {
                realProbability := (count / totalSymbolAppearances) * 100
                theoreticalProbability := symbols.Has(symbol) ? (symbols[symbol] / 100) * 100 : 0
                csvContent .= symbol . "","" . count . "","" . Round(realProbability, 2) . ""%,"" . theoreticalProbability . ""%`n""
            }
        }
        csvContent .= ""`n""

        ; ✅ SECCIÓN COMBINACIONES GANADORAS CON SEGURIDAD
        csvContent .= ""COMBINACIONES GANADORAS`n""
        csvContent .= ""Combinación,Veces,Probabilidad,Pesos_Generados,Valor_Promedio`n""

        totalWins := detailedTotalWins
        if (totalWins = 0) {
            ; Si no hay victorias, mostrar combinaciones en cero
            for combination, count in combinationStats {
                pesosGenerados := detailedPesosStats.Has(combination) ? detailedPesosStats[combination] : 0
                csvContent .= combination . "","" . count . "",0%,"" . pesosGenerados . "",0`n""
            }
        } else {
            ; Calcular probabilidades normalmente
            for combination, count in combinationStats {
                probability := (count / totalWins) * 100
                pesosGenerados := detailedPesosStats.Has(combination) ? detailedPesosStats[combination] : 0
                valorPromedio := (count > 0) ? (pesosGenerados / count) : 0
                csvContent .= combination . "","" . count . "","" . Round(probability, 2) . ""%,"" . pesosGenerados . "","" . Round(valorPromedio, 2) . ""`n""
            }
        }
        csvContent .= ""`n""

        ; ✅ SISTEMAS DE AYUDA CON VERIFICACIONES
        csvContent .= ""SISTEMAS DE AYUDA`n""
        csvContent .= ""Sistema,Activaciones,Victorias,Tasa_Éxito,Pesos_Generados`n""

        ; Pity Counter
        pitySuccessRate := (pityActivations > 0) ? ((pityWins / pityActivations) * 100) : 0
        csvContent .= ""Pity_Counter,"" . pityActivations . "","" . pityWins . "","" . Round(pitySuccessRate, 1) . ""%,"" . pityPesos . ""`n""

        ; Multiplicador
        multiplierSuccessRate := (multiplierActivationsCount > 0) ? ((multiplierWins / multiplierActivationsCount) * 100) : 0
        csvContent .= ""Multiplicador,"" . multiplierActivationsCount . "","" . multiplierWins . "","" . Round(multiplierSuccessRate, 1) . ""%,"" . multiplierPesosExtra . ""`n""

        ; Joker Respin
        jokerSuccessRate := (jokerActivations > 0) ? ((jokerWins / jokerActivations) * 100) : 0
        csvContent .= ""Joker_Respin,"" . jokerActivations . "","" . jokerWins . "","" . Round(jokerSuccessRate, 1) . ""%,"" . jokerPesos . ""`n""

        ; Jackpot
        jackpotSuccessRate := (jackpotActivations > 0) ? ((jackpotWins / jackpotActivations) * 100) : 0
        csvContent .= ""Jackpot,"" . jackpotActivations . "","" . jackpotWins . "","" . Round(jokerSuccessRate, 1) . ""%,"" . jackpotPesos . ""`n""

        ; Sistema de Rescate
        rescueSuccessRate := (rescueActivations > 0) ? 100 : 0  ; Siempre tiene éxito cuando se activa
        csvContent .= ""Rescate_Volatilidad,"" . rescueActivations . "","" . rescueActivations . "","" . rescueSuccessRate . ""%,"" . rescuePesos . ""`n""

        csvContent .= ""`n""

        ; ✅ VOLATILIDAD
        csvContent .= ""VOLATILIDAD`n""
        csvContent .= ""Métrica,Valor`n""
        csvContent .= ""Racha_Pérdida_Más_Larga,"" . longestLosingStreak . ""`n""
        csvContent .= ""Racha_Pérdida_Actual,"" . currentLosingStreak . ""`n""
        csvContent .= ""Giros_Sin_Victoria_Actual,"" . rescueSpinsWithoutWin . ""`n""

        avgSpinsBetweenWins := (detailedTotalWins > 0) ? (detailedTotalSpins / detailedTotalWins) : 0
        csvContent .= ""Giros_Promedio_Entre_Victorias,"" . Round(avgSpinsBetweenWins, 1) . ""`n""

        winRate := (detailedTotalSpins > 0) ? ((detailedTotalWins / detailedTotalSpins) * 100) : 0
        csvContent .= ""Tasa_de_Victoria,"" . Round(winRate, 2) . ""%`n""
        csvContent .= ""`n""

        ; ✅ DESGLOSE RTP CON VERIFICACIONES
        csvContent .= ""DESGLOSE RTP`n""
        csvContent .= ""Componente,Contribución_RTP`n""

        ; Calcular con seguridad contra división por cero
        if (detailedTotalSpins > 0) {
            baseRTP := ((detailedTotalPesos - detailedCompensations - detailedJokerRespinPesos - totalMultiplierPesos - (detailedJackpotsWon * jackpotValue) - rescuePesos) / detailedTotalSpins) * 100
            pityRTP := (detailedCompensations / detailedTotalSpins) * 100
            jokerRTP := (detailedJokerRespinPesos / detailedTotalSpins) * 100
            multiplierRTP := (totalMultiplierPesos / detailedTotalSpins) * 100
            jackpotRTP := ((detailedJackpotsWon * jackpotValue) / detailedTotalSpins) * 100
            rescueRTP := (rescuePesos / detailedTotalSpins) * 100
        } else {
            baseRTP := 0
            pityRTP := 0
            jokerRTP := 0
            multiplierRTP := 0
            jackpotRTP := 0
            rescueRTP := 0
        }

        csvContent .= ""Símbolos_Base,"" . Round(baseRTP, 2) . ""%`n""
        csvContent .= ""Sistema_Pity,"" . Round(pityRTP, 2) . ""%`n""
        csvContent .= ""Joker_Respins,"" . Round(jokerRTP, 2) . ""%`n""
        csvContent .= ""Multiplicadores,"" . Round(multiplierRTP, 2) . ""%`n""
        csvContent .= ""Jackpot,"" . Round(jackpotRTP, 2) . ""%`n""
        csvContent .= ""Rescate_Volatilidad,"" . Round(rescueRTP, 2) . ""%`n""
        csvContent .= ""TOTAL,"" . Round(currentRTP, 2) . ""%`n""

        FileAppend(csvContent, filename)

        MyGui.Opt(""+OwnDialogs"")
        MsgBox(""📈 DATOS EXPORTADOS`n`nArchivo: "" . filename . ""`n`nContiene análisis completo para afinación RTP"", ""Exportación Completada"", ""4096"")

    } catch Error as e {
        MyGui.Opt(""+OwnDialogs"")
        MsgBox(""❌ ERROR al exportar datos:`n"" . e.Message . ""`nLínea: "" . e.Line, ""Error de Exportación"", ""16"")
    }
}

UpdateStatsDisplay() {
    global totalSpins, totalWins, totalPesos, jackpotCounter, pityCounter, pityThreshold, multiplierActivations, rescueActivations

    TotalSpinsText.Value := totalSpins
    TotalPesosText.Value := totalPesos
    JackpotCounterText.Value := jackpotCounter . ""/5000""
    PityCounterText.Value := pityCounter . ""/"" . pityThreshold
    RescueCounterText.Value := rescueActivations  ; ← NUEVO: Mostrar rescates
    UpdateWinPercentages()
}

StartSpin(*) {
    global spinning, totalSpins, detailedTotalSpins, SpinBtn, Spin1000Btn, Spin10000Btn, imgPath, spinInterval, spinDuration
    global currentProfile

    if spinning
        return

    spinning := true
    SpinBtn.Enabled := false
    SpinBtn.Text := ""Girando...""
    Spin1000Btn.Enabled := false
    Spin10000Btn.Enabled := false

    totalSpins++
    detailedTotalSpins++

    UpdateStatsDisplay()
    SaveStats()

    Loop 3
        MyGui[""Slot"" . A_Index].Value := imgPath . ""question.png""

    SetTimer(SpinSlots, spinInterval)
    SetTimer(StopSpin, -spinDuration)
}

SpinSlots() {
    global symbolList, imgPath, MyGui, img1, img2, img3

    randIndex := Random(1, symbolList.Length)
    img1 := symbolList[randIndex]

    randIndex := Random(1, symbolList.Length)
    img2 := symbolList[randIndex]

    randIndex := Random(1, symbolList.Length)
    img3 := symbolList[randIndex]

    Loop 3 {
        currentImg := (A_Index = 1) ? img1 : (A_Index = 2) ? img2 : img3
        imgFile := imgPath . currentImg . "".png""
        fallback := imgPath . ""question.png""

        if FileExist(imgFile)
            MyGui[""Slot"" . A_Index].Value := imgFile
        else
            MyGui[""Slot"" . A_Index].Value := fallback
    }
}

StopSpin() {
    global spinning, MyGui, imgPath, img1, img2, img3, symbolWin, jackpotCounter, pityCounter, pityThreshold
    global SpinBtn, Spin1000Btn, Spin10000Btn, lastWin
    global currentLosingStreak, longestLosingStreak
    global currentProfile, rescueSpinsWithoutWin

    SetTimer(SpinSlots, 0)
    Critical true

    try {
        MyGui[""Slot1""].Value := imgPath . img1 . "".png""
        MyGui[""Slot2""].Value := imgPath . img2 . "".png""
        MyGui[""Slot3""].Value := imgPath . img3 . "".png""
    }
    Sleep 30

    symbolWin := CheckWinCombination(img1, img2, img3)

    ; ===== PRIMERO: VICTORIAS NORMALES =====
    if (symbolWin is String && symbolWin != """") {
        HandleTripleWin()
    }

    ; ===== SEGUNDO: JACKPOT =====
    if (jackpotCounter >= 5000) {
        HandleJackpotWin()
    }

    ; ===== TERCERO: JOKER RESPIN O PITY =====
    if (!symbolWin || symbolWin = false) {
        if (img1 = ""joker"" || img2 = ""joker"" || img3 = ""joker"") {
            HandleJokerRespin()
        } else {
            HandleLoss()  ; ← Aquí se activa el PITY
        }
    }

    ; ===== CUARTO: FINALMENTE VERIFICAR RESCATE (después de pity) =====
    if (!symbolWin || symbolWin = false) {
        rescueSpinsWithoutWin++
        if (CheckVolatilityRescue()) {
            ; El rescate manejó la victoria completamente
            spinning := false
            SpinBtn.Enabled := true
            SpinBtn.Text := ""1 Moneda""
            SpinBtn.Opt(""+Default"")
            if (!autoSpin) {
                Spin1000Btn.Enabled := true
                Spin10000Btn.Enabled := true
            }
            SaveStats()
            SaveDetailedStats()
            Critical false
            return
        }
    }

    ; ===== ACTUALIZAR ESTADÍSTICAS Y CONTADORES =====
    if (!lastWin) {
        currentLosingStreak++
    } else {
        if (currentLosingStreak > longestLosingStreak) {
            longestLosingStreak := currentLosingStreak
        }
        currentLosingStreak := 0
    }

    PityCounterText.Value := pityCounter . ""/"" . pityThreshold
    JackpotCounterText.Value := jackpotCounter . ""/5000""
    UpdateBonusLights()
    UpdateWinPercentages()
    UpdateJokerStatus()

    spinning := false
    SpinBtn.Enabled := true
    SpinBtn.Text := ""1 Moneda""
    SpinBtn.Opt(""+Default"")
    if (!autoSpin) {
        Spin1000Btn.Enabled := true
        Spin10000Btn.Enabled := true
    }

    SaveStats()
    SaveDetailedStats()
    Critical false
}

ShowRescueMessage() {
    MyGui.Opt(""+OwnDialogs"")
    MsgBox(""¡Combinación ganadora!`n`nHas obtenido una victoria."", ""¡Ganaste!"", ""64"")
}

CheckWinCombination(reel1, reel2, reel3) {
    symbolsInReels := [reel1, reel2, reel3]
    symbolCounts := Map()
    jokerCount := 0

    for symbol in symbolsInReels {
        if (symbol = ""joker"") {
            jokerCount++
        } else {
            symbolCounts[symbol] := symbolCounts.Has(symbol) ? symbolCounts[symbol] + 1 : 1
        }
    }

    for symbol, count in symbolCounts {
        if (count = 3) {
            return symbol
        }
    }

    for symbol, count in symbolCounts {
        if (count = 2 && jokerCount >= 1) {
            return symbol
        }
    }

    for symbol, count in symbolCounts {
        if (count = 1 && jokerCount >= 2) {
            return symbol
        }
    }

    if (jokerCount = 3) {
        return ""three_jokers""
    }

    return false
}

; ===== NUEVAS FUNCIONES RTP35 MEJORADO =====

CheckSafetyNet() {
    global currentLosingStreak, safetyNetThreshold, safetyNetActive, safetyNetBoost
    global symbols, currentProfile, totalSpins

    ; Solo activar para RTP35/RTP40/RTP45/RTP50 y si no está ya activo
    if ((currentProfile != ""RTP35"" && currentProfile != ""RTP40"" && currentProfile != ""RTP45"" && currentProfile != ""RTP50"") || safetyNetActive || currentLosingStreak < safetyNetThreshold) {
        return
    }

    safetyNetActive := true
    safetyNetBoost := true

    ; ✅ DISTRIBUCIÓN DE EMERGENCIA TEMPORAL POR PERFIL
    if (currentProfile = ""RTP35"") {
        emergencySymbols := Map(
            ""cherry"", 25,    ; -3 temporalmente
            ""bell"", 22,      ; -2
            ""lemon"", 14,     ; -2
            ""star"", 18,      ; +3 (aumentar significativamente)
            ""diamond"", 12,   ; +3 (más oportunidades alto valor)
            ""seven"", 8,      ; +1 (más símbolos premium)
            ""joker"", 1       ; = (mantener)
        )
    } else if (currentProfile = ""RTP40"") {
        emergencySymbols := Map(
            ""cherry"", 28,    ; -3 temporalmente
            ""bell"", 23,      ; -3
            ""lemon"", 15,     ; -2
            ""star"", 15,      ; +3 (aumentar significativamente)
            ""diamond"", 10,   ; +2 (más oportunidades alto valor)
            ""seven"", 6,      ; +1 (más símbolos premium)
            ""joker"", 1       ; = (mantener)
        )
    } else if (currentProfile = ""RTP45"") {
        emergencySymbols := Map(
            ""cherry"", 38,    ; -2 temporalmente
            ""bell"", 23,      ; -2
            ""lemon"", 14,     ; -1
            ""star"", 10,      ; +2 (aumentar significativamente)
            ""diamond"", 6,    ; +1 (más oportunidades alto valor)
            ""seven"", 5,      ; +1 (más símbolos premium)
            ""joker"", 2       ; = (mantener)
        )
    } else if (currentProfile = ""RTP50"") {
        emergencySymbols := Map(
            ""cherry"", 45,    ; -3 temporalmente
            ""bell"", 26,      ; -2
            ""lemon"", 16,     ; -2
            ""star"", 12,      ; +2 (aumentar significativamente)
            ""diamond"", 7,    ; +1 (más oportunidades alto valor)
            ""seven"", 6,      ; +1 (más símbolos premium)
            ""joker"", 2       ; = (mantener)
        )
    }

    ; Aplicar distribución de emergencia
    ApplyEmergencyDistribution(emergencySymbols)

    ; Restaurar después de 10 giros o primera victoria
    SetTimer(RestoreOriginalDistribution, 10000)
}

ApplyEmergencyDistribution(emergencySymbols) {
    global symbols
    symbols := emergencySymbols.Clone()
    UpdateSymbolList()
}

RestoreOriginalDistribution() {
    global safetyNetActive, safetyNetBoost, currentProfile

    if (safetyNetActive && currentProfile = ""RTP35"") {
        LoadConfig()  ; Recargar configuración original
        safetyNetActive := false
        safetyNetBoost := false

        ; Notificar restauración silenciosa
        SetTimer(ClearRestoreMessage, 3000)
    }
}

ClearRestoreMessage() {
}

GetWeightedPremiumSymbol() {
    premiumSymbols := [""seven"", ""diamond"", ""star"", ""bell"", ""lemon""]
    weights := [15, 20, 25, 25, 15]  ; Probabilidades ponderadas

    totalWeight := 0
    for weight in weights {
        totalWeight += weight
    }

    randomValue := Random(1, totalWeight)
    cumulativeWeight := 0

    Loop premiumSymbols.Length {
        cumulativeWeight += weights[A_Index]
        if (randomValue <= cumulativeWeight) {
            return premiumSymbols[A_Index]
        }
    }

    return ""star""  ; Fallback
}

EnhancedJokerRespin(spin1, spin2, spin3) {
    global img1, img2, img3, symbolList, MyGui, imgPath, jokerEffectivenessRTP35, jokerEffectivenessRTP40, jokerEffectivenessRTP45, jokerEffectivenessRTP50, currentProfile

    ; ✅ OBTENER EFECTIVIDAD CORRECTA SEGÚN PERFIL
    jokerEffectiveness := 35  ; Default
    if (currentProfile = ""RTP35"") {
        jokerEffectiveness := jokerEffectivenessRTP35
    } else if (currentProfile = ""RTP40"") {
        jokerEffectiveness := jokerEffectivenessRTP40
    } else if (currentProfile = ""RTP45"") {
        jokerEffectiveness := jokerEffectivenessRTP45
    } else if (currentProfile = ""RTP50"") {
        jokerEffectiveness := jokerEffectivenessRTP50
    }

    ; ✅ ALGORITMO MEJORADO - MÁS PROBABILIDAD DE ÉXITO
    if (spin1 && Random(1, 100) <= jokerEffectiveness) {
        ; Forzar símbolo de mayor valor
        img1 := GetWeightedPremiumSymbol()
        MyGui[""Slot1""].Value := imgPath . img1 . "".png""
    } else if (spin1) {
        randIndex := Random(1, symbolList.Length)
        img1 := symbolList[randIndex]
        MyGui[""Slot1""].Value := imgPath . img1 . "".png""
    }
    Sleep 120

    if (spin2 && Random(1, 100) <= jokerEffectiveness) {
        img2 := GetWeightedPremiumSymbol()
        MyGui[""Slot2""].Value := imgPath . img2 . "".png""
    } else if (spin2) {
        randIndex := Random(1, symbolList.Length)
        img2 := symbolList[randIndex]
        MyGui[""Slot2""].Value := imgPath . img2 . "".png""
    }
    Sleep 120

    if (spin3 && Random(1, 100) <= jokerEffectiveness) {
        img3 := GetWeightedPremiumSymbol()
        MyGui[""Slot3""].Value := imgPath . img3 . "".png""
    } else if (spin3) {
        randIndex := Random(1, symbolList.Length)
        img3 := symbolList[randIndex]
        MyGui[""Slot3""].Value := imgPath . img3 . "".png""
    }
    Sleep 120
}

StandardJokerRespin(spin1, spin2, spin3) {
    global img1, img2, img3, symbolList, MyGui, imgPath

    if (spin1) {
        randIndex := Random(1, symbolList.Length)
        img1 := symbolList[randIndex]
        MyGui[""Slot1""].Value := imgPath . img1 . "".png""
    }
    Sleep 100

    if (spin2) {
        randIndex := Random(1, symbolList.Length)
        img2 := symbolList[randIndex]
        MyGui[""Slot2""].Value := imgPath . img2 . "".png""
    }
    Sleep 100

    if (spin3) {
        randIndex := Random(1, symbolList.Length)
        img3 := symbolList[randIndex]
        MyGui[""Slot3""].Value := imgPath . img3 . "".png""
    }
    Sleep 100
}

ShowEnhancedJokerWin(symbolWin) {
    global symbolValues
    pesosGanados := symbolValues.Has(symbolWin) ? symbolValues[symbolWin] : 0
    MyGui.Opt(""+OwnDialogs"")
    MsgBox(""¡JOKER MEJORADO!`n`nCombinación: "" . symbolWin . ""`nPremio: "" . pesosGanados . "" pesos`n`n¡El comodín te sonríe!"", ""Joker Potenciado"", ""4096"")
}

; ===== FUNCIONES EXISTENTES MODIFICADAS =====

HandleJokerRespin() {
    global img1, img2, img3, spinning, imgPath, symbolList, testingMode, totalSpins, totalPesos, targetRTP, symbolWin
    global detailedJokerRespines, detailedJokerRespinWins, detailedJokerRespinPesos
    global SpinBtn, Spin1000Btn, Spin10000Btn, MyGui, detailedTotalWins, detailedTotalPesos, detailedWinStats, detailedPesosStats
    global jokerActivations, jokerWins, jokerPesos, currentProfile

    currentRTP := 0
    if (totalSpins > 0) {
        currentRTP := (totalPesos / totalSpins) * 100
    }

    ; ✅ UMBRAL MÁS FLEXIBLE PARA PERFILES BAJOS
    activationThreshold := (currentProfile = ""RTP35"") ? targetRTP + 3 : targetRTP

    if (currentRTP < activationThreshold) {
        jokerActivations += 1
        detailedJokerRespines++

        spinning := true
        SpinBtn.Enabled := false
        SpinBtn.Text := ""Re-Girando...""
        Spin1000Btn.Enabled := false
        Spin10000Btn.Enabled := false

        spin1 := (img1 != ""joker"")
        spin2 := (img2 != ""joker"")
        spin3 := (img3 != ""joker"")

        ; ✅ ANIMACIÓN MEJORADA PARA TODOS LOS PERFILES
        Loop 8 {
            if (spin1) {
                randIndex := Random(1, symbolList.Length)
                MyGui[""Slot1""].Value := imgPath . symbolList[randIndex] . "".png""
            }
            if (spin2) {
                randIndex := Random(1, symbolList.Length)
                MyGui[""Slot2""].Value := imgPath . symbolList[randIndex] . "".png""
            }
            if (spin3) {
                randIndex := Random(1, symbolList.Length)
                MyGui[""Slot3""].Value := imgPath . symbolList[randIndex] . "".png""
            }
            Sleep 40
        }

        ; ✅ RESULTADOS MEJORADOS PARA TODOS LOS PERFILES
        EnhancedJokerRespin(spin1, spin2, spin3)

        symbolWin := CheckWinCombination(img1, img2, img3)

        if (symbolWin is String && symbolWin != """") {
            HandleTripleWin()

            if (!testingMode && (currentProfile = ""RTP35"" || currentProfile = ""RTP50"")) {
                ShowEnhancedJokerWin(symbolWin)
            }
            pesosGanados := symbolValues.Has(symbolWin) ? symbolValues[symbolWin] : 2
            detailedJokerRespinWins++
            detailedJokerRespinPesos += pesosGanados
            jokerWins += 1
            jokerPesos += pesosGanados
        } else {
            HandleJokerRespinLoss()
        }

        spinning := false
        SpinBtn.Enabled := true
        SpinBtn.Text := ""1 Moneda""
        SpinBtn.Opt(""+Default"")
        Spin1000Btn.Enabled := true
        Spin10000Btn.Enabled := true
    } else {
        HandleLoss()
    }
}

HandleJokerRespinLoss() {
    global lastWin, testingMode
    lastWin := false
}

HandleJackpotWin() {
    global lastWin, totalWins, detailedTotalWins, pityCounter, totalPesos, detailedTotalPesos, detailedJackpotsWon, jackpotValue, jackpotCounter, testingMode, imgPath, symbolList, MyGui
    global jackpotActivations, jackpotWins, jackpotPesos

    if (!testingMode) {
    }
    Loop 5 {
        randIndex := Random(1, symbolList.Length)
        MyGui[""Slot1""].Value := imgPath . symbolList[randIndex] . "".png""
        randIndex := Random(1, symbolList.Length)
        MyGui[""Slot2""].Value := imgPath . symbolList[randIndex] . "".png""
        randIndex := Random(1, symbolList.Length)
        MyGui[""Slot3""].Value := imgPath . symbolList[randIndex] . "".png""
        Sleep 30
    }
    Loop 3 {
        randIndex := Random(1, symbolList.Length)
        MyGui[""Slot1""].Value := imgPath . symbolList[randIndex] . "".png""
        randIndex := Random(1, symbolList.Length)
        MyGui[""Slot2""].Value := imgPath . symbolList[randIndex] . "".png""
        randIndex := Random(1, symbolList.Length)
        MyGui[""Slot3""].Value := imgPath . symbolList[randIndex] . "".png""
        Sleep 80
    }
    MyGui[""Slot1""].Value := imgPath . ""jackpot.png""
    if (!testingMode) {
    }
    Sleep 150
    MyGui[""Slot2""].Value := imgPath . ""jackpot.png""
    if (!testingMode) {
    }
    Sleep 150
    MyGui[""Slot3""].Value := imgPath . ""jackpot.png""
    if (!testingMode) {
    }
    Sleep 250
    Loop 2 {
        MyGui[""Slot1""].Value := imgPath . ""jackpot_glow.png""
        MyGui[""Slot2""].Value := imgPath . ""jackpot_glow.png""
        MyGui[""Slot3""].Value := imgPath . ""jackpot_glow.png""
        Sleep 100
        MyGui[""Slot1""].Value := imgPath . ""jackpot.png""
        MyGui[""Slot2""].Value := imgPath . ""jackpot.png""
        MyGui[""Slot3""].Value := imgPath . ""jackpot.png""
        Sleep 100
    }
    lastWin := true
    totalWins++
    detailedTotalWins++
    pityCounter := 0
    totalPesos += jackpotValue
    detailedTotalPesos += jackpotValue
    detailedJackpotsWon++
    jackpotActivations += 1
    jackpotWins += 1
    jackpotPesos += jackpotValue
    if (!testingMode) {
    }
    jackpotCounter := 0
    Loop 5 {
        MyGui[""BonusSlot"" . A_Index].Value := imgPath . ""bonus_empty.png""
    }
    RandomizeBonusOrder()
    RandomizeBonusThresholds()
    UpdateStatsDisplay()
    UpdateJokerStatus()
}

HandleTripleWin() {
    global lastWin, totalWins, detailedTotalWins, winStats, detailedWinStats, pityCounter, totalPesos, detailedTotalPesos, pesosStats, detailedPesosStats, totalMultiplierPesos, multiplierActivations, symbolWin, testingMode, multiplierValue, imgPath, symbolValues, MyGui
    global safetyNetActive, safetyNetBoost, currentProfile
    global rescueSpinsWithoutWin

    if (!symbolWin is String || symbolWin = """") {
        return
    }

    lastWin := true
    totalWins++
    detailedTotalWins++
    pityCounter := 0
    rescueSpinsWithoutWin := 0  ; ← RESETEAR CONTADOR DE RESCATE

    ; ✅ BONUS EXTRA POR VICTORIA DURANTE SAFETY NET
    ;bonusPesos := 0
    ;if (safetyNetBoost && currentProfile = ""RTP35"") {
      ;  bonusPesos := 10  ; Bonus adicional por romper racha mala
      ;  totalPesos += bonusPesos
      ;  detailedTotalPesos += bonusPesos
    ;}

    ; ✅ DESACTIVAR SAFETY NET SI ESTÁ ACTIVO
    if (safetyNetActive) {
        RestoreOriginalDistribution()

    }

    if (!symbolValues.Has(symbolWin)) {
        pesosGanados := 2
    } else {
        pesosGanados := symbolValues[symbolWin]
    }

    if (symbolWin = ""three_jokers"") {
        if (!testingMode) {
        }
        winStats[""three_jokers""] := winStats.Has(""three_jokers"") ? winStats[""three_jokers""] + 1 : 1
        detailedWinStats[""three_jokers""] := detailedWinStats.Has(""three_jokers"") ? detailedWinStats[""three_jokers""] + 1 : 1
    } else {
        if (winStats.Has(symbolWin)) {
            winStats[symbolWin]++
            detailedWinStats[symbolWin]++
        } else {
            winStats[symbolWin] := 1
            detailedWinStats[symbolWin] := 1
        }

        extraMultiplier := CheckMultiplierActivation()
        if (extraMultiplier > 0) {
            totalMultiplied := pesosGanados + extraMultiplier

            if (!testingMode) {
            }

            pesosGanados := totalMultiplied
            totalMultiplierPesos += extraMultiplier
        } else {
            if (!testingMode && symbolWin != ""three_jokers"") {
            }
        }
    }

    totalPesos += pesosGanados
    detailedTotalPesos += pesosGanados

    if (symbolWin = ""three_jokers"") {
        pesosStats[""three_jokers""] := pesosStats.Has(""three_jokers"") ? pesosStats[""three_jokers""] + pesosGanados : pesosGanados
        detailedPesosStats[""three_jokers""] := detailedPesosStats.Has(""three_jokers"") ? detailedPesosStats[""three_jokers""] + pesosGanados : pesosGanados
    } else if (pesosStats.Has(symbolWin)) {
        pesosStats[symbolWin] += pesosGanados
        detailedPesosStats[symbolWin] += pesosGanados
    } else {
        pesosStats[symbolWin] := pesosGanados
        detailedPesosStats[symbolWin] := pesosGanados
    }

    UpdateStatsDisplay()
    UpdateJokerStatus()
}

CheckMultiplierActivation() {
    global multiplierProbability, multiplierValue, testingMode, multiplierActivations, symbolWin, symbolValues

    if (symbolWin = ""three_jokers"") {
        return 0
    }

    if (Random(1, 100) <= (100 / multiplierProbability)) {
        multiplierActivations++

        baseValue := symbolValues.Has(symbolWin) ? symbolValues[symbolWin] : 0
        multipliedValue := Round(baseValue * multiplierValue)

        return multipliedValue - baseValue
    }
    return 0
}

HandleLoss() {
    global lastWin, pityCounter, jackpotCounter, totalPesos, detailedTotalPesos, detailedCompensations, detailedCompensationCount, testingMode, currentProfile, totalSpins, pityThreshold, MyGui, imgPath
    global currentLosingStreak, longestLosingStreak
    global safetyNetActive, safetyNetThreshold
    global rescueSpinsWithoutWin
    global pityActivations, pityWins, pityPesos

    lastWin := false
    pityCounter++
    jackpotCounter++
    rescueSpinsWithoutWin++

    UpdateBonusLights()

    if ((currentProfile = ""RTP35"" || currentProfile = ""RTP40"" || currentProfile = ""RTP45"" || currentProfile = ""RTP50"") && currentLosingStreak >= safetyNetThreshold && !safetyNetActive) {
        CheckSafetyNet()
    }

    if (pityCounter >= pityThreshold) {
        pityCounter := 0
        compensation := 4
        compensationMessage := ""¡Compensación!`n"" . pityThreshold . "" giros sin ganar""
        showCompensationMessage := true

        if (compensation > 0) {
            detailedCompensations += compensation
            detailedCompensationCount++
            totalPesos += compensation
            detailedTotalPesos += compensation

            pityActivations += 1
            pityWins += 1
            pityPesos += compensation

            if (!testingMode && showCompensationMessage) {
                ; Mensaje opcional de compensación
            }
        }
    }
}

AutoSpinLoop() {
    global autoSpin, autoSpinCount, maxAutoSpins, spinning, SpinBtn, Spin1000Btn, Spin10000Btn
    if spinning
        return
    if (autoSpinCount >= maxAutoSpins) {
        SetTimer(AutoSpinLoop, 0)
        autoSpin := false
        testingMode := false
        SpinBtn.Enabled := true
        Spin1000Btn.Enabled := true
        Spin10000Btn.Enabled := true
        return
    }
    StartSpin()
    autoSpinCount++
}

ResetStats(reason, *) {
    global totalSpins, totalWins, totalPesos, winStats, pesosStats, jackpotCounter, pityCounter
    global detailedTotalSpins, detailedTotalWins, detailedTotalPesos, detailedJackpotsWon, detailedCompensations, detailedCompensationCount, detailedWinStats, detailedPesosStats
    global detailedJokerRespines, detailedJokerRespinWins, detailedJokerRespinPesos
    global multiplierActivations, totalMultiplierPesos
    global currentLosingStreak, longestLosingStreak
    global symbolFrequency, combinationStats, volatilityStats, rtpBreakdown
    global pityActivations, pityWins, pityPesos, multiplierActivationsCount, multiplierWins, multiplierPesosExtra
    global jokerActivations, jokerWins, jokerPesos, jackpotActivations, jackpotWins, jackpotPesos
    global safetyNetActive, safetyNetBoost
    global rescueSpinsWithoutWin, lastRescueSpin, rescueActivations, rescuePesos, rescueActive

    totalSpins := 0
    totalWins := 0
    totalPesos := 0
    jackpotCounter := 0
    pityCounter := 0

    detailedTotalSpins := 0
    detailedTotalWins := 0
    detailedTotalPesos := 0
    detailedJackpotsWon := 0
    detailedCompensations := 0
    detailedCompensationCount := 0
    detailedJokerRespines := 0
    detailedJokerRespinWins := 0
    detailedJokerRespinPesos := 0
    multiplierActivations := 0
    totalMultiplierPesos := 0

    currentLosingStreak := 0
    longestLosingStreak := 0

    pityActivations := 0
    pityWins := 0
    pityPesos := 0
    multiplierActivationsCount := 0
    multiplierWins := 0
    multiplierPesosExtra := 0
    jokerActivations := 0
    jokerWins := 0
    jokerPesos := 0
    jackpotActivations := 0
    jackpotWins := 0
    jackpotPesos := 0

    safetyNetActive := false
    safetyNetBoost := false

    rescueSpinsWithoutWin := 0
    lastRescueSpin := 0
    rescueActivations := 0
    rescuePesos := 0
    rescueActive := false

    InitializeAdvancedStats()

    for symbol in symbols {
        winStats[symbol] := 0
        pesosStats[symbol] := 0
        detailedWinStats[symbol] := 0
        detailedPesosStats[symbol] := 0
    }
    winStats[""three_jokers""] := 0
    pesosStats[""three_jokers""] := 0
    detailedWinStats[""three_jokers""] := 0
    detailedPesosStats[""three_jokers""] := 0

    UpdateStatsDisplay()
    UpdateJokerStatus()
    SaveStats()
    SaveDetailedStats()
    if (!reason = 0) {
        MyGui.Opt(""+OwnDialogs"")
        MsgBox(""Estadísticas reseteadas"", ""Reset"", ""4096"")
    }
}

ShowStats(*) {
    MyGui.Opt(""+OwnDialogs"")
    MsgBox(""Estadísticas de la sesión actual:`nTotal giros: "" . totalSpins . ""`nVictorias: "" . totalWins . ""`nPesos ganados: "" . totalPesos, ""Estadísticas de sesión"", ""4096"")
}

ShowDetailedStats(*) {
    global DetailedStatsGui, ReportEdit, detailedTotalSpins, detailedTotalWins, detailedTotalPesos, detailedJackpotsWon, detailedCompensations, detailedCompensationCount, detailedJokerRespines, detailedJokerRespinWins, detailedJokerRespinPesos
    global longestLosingStreak, symbolRTPContributions, jokerRTPContribution
    global rescueSpinsWithoutWin, rescueActivations, rescuePesos

    LoadDetailedStats()

    if (IsObject(DetailedStatsGui)) {
        DetailedStatsGui.Destroy()
    }
    DetailedStatsGui := Gui(""+Resize"", ""Reporte Detallado"")
    DetailedStatsGui.SetFont(""s10"", ""Courier New"")
    ReportEdit := DetailedStatsGui.Add(""Edit"", ""w600 h500 ReadOnly vReportEdit"")
    ReportEdit.Value := GenerateDetailedReport()
    DetailedStatsGui.Show(""Center"")
}

GenerateDetailedReport() {
    global detailedTotalSpins, detailedTotalWins, detailedTotalPesos, detailedJackpotsWon, detailedCompensations, detailedCompensationCount, detailedWinStats, detailedPesosStats, symbols
    global detailedJokerRespines, detailedJokerRespinWins, detailedJokerRespinPesos
    global multiplierActivations, totalMultiplierPesos
    global longestLosingStreak, symbolRTPContributions, jokerRTPContribution
    global rescueSpinsWithoutWin, rescueActivations, rescuePesos

    report := """"
    report .= ""============== REPORTE DETALLADO DE SIMULACIÓN ==============`n`n""
    report .= ""--- GENERAL ---`n""
    report .= ""Giros Totales: "" . detailedTotalSpins . ""`n""
    report .= ""Victorias Totales: "" . detailedTotalWins . ""`n""
    report .= ""Pesos Ganados Totales: "" . detailedTotalPesos . ""`n""
    report .= ""Multiplicadores Activados: "" . multiplierActivations . ""`n""
    report .= ""Pesos por Multiplicadores: "" . totalMultiplierPesos . ""`n""
    report .= ""Rescates de Volatilidad: "" . rescueActivations . ""`n""
    report .= ""Pesos por Rescates: "" . rescuePesos . ""`n""
    if (detailedTotalSpins > 0) {
        report .= ""RTP Calculado: "" . Round((detailedTotalPesos / detailedTotalSpins) * 100, 2) . ""%`n""
    } else {
        report .= ""RTP Calculado: N/A`n""
    }
    report .= ""`n""
    report .= ""--- VOLATILIDAD ---`n""
    report .= ""Racha de giros perdidos más larga: "" . longestLosingStreak . ""`n""
    report .= ""Giros sin victoria actual: "" . rescueSpinsWithoutWin . ""`n""
    report .= ""Victorias por compensación: "" . detailedCompensationCount . "" ("" . detailedCompensations . "" pesos)`n""
    report .= ""`n""
    report .= ""--- JACKPOT ---`n""
    report .= ""Jackpots Ganados: "" . detailedJackpotsWon . ""`n""
    report .= ""`n""
    report .= ""--- JOKER ---`n""
    report .= ""Respines de Joker: "" . detailedJokerRespines . ""`n""
    report .= ""Victorias por Respin: "" . detailedJokerRespinWins . ""`n""
    report .= ""Pesos ganados por Respin: "" . detailedJokerRespinPesos . ""`n""
    report .= ""Contribución RTP del Joker: "" . jokerRTPContribution . ""%`n""
    report .= ""`n""
    report .= ""--- SIMBOLOS (VICTORIAS & RTP) ---`n""
    report .= ""`t"" . ""Simbolo"" . ""`t"" . ""Victorias"" . ""`t"" . ""Pesos"" . ""`t"" . ""RTP Cont.`n""
    report .= ""--------------------------------------------------`n""
    for symbol, count in detailedWinStats {
        pesos := detailedPesosStats[symbol]
        rtp := symbolRTPContributions.Get(symbol, 0.00)
        report .= ""`t"" . symbol . ""`t`t"" . count . ""`t"" . pesos . ""`t"" . rtp . ""%`n""
    }
    return report
}

GuiClose(*) {
    SaveStats()
    SaveDetailedStats()
    ExitApp
}

PlaySound(file) {
    global soundPath
    if FileExist(soundPath . file) {
        SoundPlay soundPath . file
    }
}"
TdjkcjFe,AutoIt Clippboard Logger,mdelatorre,AutoIt,Wednesday 29th of October 2025 08:49:28 PM CDT,"
; URL			: https://github.com/geekcomputers/AutoIt/blob/master/clipboard_logger.au3
; Script Name	: clipboard_logger.au3
; Author		: Craig Richards
; Created		: 25th January 2012
; Last Modified	:
; Version		: 1.0

; Modifications	:

; Description	: Will log all contents added to the clipboard, even if they use 1Passwd, Keypass, Lastpass etc

#Include <clipboard.au3>										; Include the Clipboard Header file
#Include <File.au3>												; Include the File Header file

$oldclip="""" 													; Set the variable $oldclip to be blank
While 1 														; While True, so continually run
   $clip=_Clipboard_GetData()									; Sets the variable clip, which gets the contents of the clipboard
   If $clip <> ""0"" Then 										; If clip isn't zero then,
	  If $clip <> $oldclip Then									; Don't log the same clipboard text over and over, if nothing has come in in 100 milliseconds
		 _FileWriteLog(@UserProfileDir & ""\clip.log"", $clip)	; Write out to the clip.log file, this entry in timestamped.
		 $oldclip = $clip 										; Make oldclip the same as clip for this instance
	  EndIf 													; End the First IF Statement
   EndIf 														; End of the Second IF Statement
   Sleep(100) 													; Sleep for 100 Milliseconds
WEnd 															; End of the while loop
"
QZ99VMJq,Simple State Machine And Transparency Example,Windspar,Python,Wednesday 29th of October 2025 08:37:40 PM CDT,"import pygame

# Simple Infinite State Machine
class State:
    def __init__(self, control):
        self.control = control

    def on_draw(self, surface): pass
    def on_event(self, event): pass
    def on_update(self, delta): pass

class StateHandler:
    def __init__(self):
        self.states = {}
        self.current = None
        self.next_ = None

    def add(self, name, state):
        self.states[name] = state

    def get(self, name):
        return self.states[name]

    def push(self, state):
        self.next_ = self.states[state]

    def update(self):
        if self.next_:
            self.current = self.next_
            self.next_ = None

class StateControl:
    def __init__(self, caption, size, flags=0, fps=60):
        pygame.display.set_caption(caption)
        self.display = pygame.display.set_mode(size, flags)
        self.rect = self.display.get_rect()
        self.clock = pygame.time.Clock()
        self.running = True
        self.delta = 0
        self.fps = fps

        self.state = StateHandler()

    def loop(self):
        while self.running:
            self.state.update()
            for event in pygame.event.get():
                if event.type != pygame.QUIT:
                    self.state.current.on_event(event)
                else:
                    self.running = False

            self.state.current.on_update(self.delta)
            self.state.current.on_draw(self.display)
            pygame.display.flip()
            self.delta = self.clock.tick(self.fps)

    def run(self, state=None):
        if state:
            self.state.current = state
        else:
            if self.state.current is None:
                self.state.current = State(self)
                print(""You forgot to set state"")

        self.loop()

# States
class Intro(State):
    def __init__(self, control):
        super().__init__(control)
        font = pygame.font.Font(None, 30)
        self.image = font.render(""Game Intro"", 1, ""dodgerblue"")
        self.rect = self.image.get_rect()
        self.rect.top = self.control.rect.top + 20
        self.rect.centerx = self.control.rect.centerx

    def on_draw(self, surface):
        surface.fill(""black"")
        surface.blit(self.image, self.rect)

    def on_event(self, event):
        if event.type == pygame.KEYDOWN:
            self.control.state.push(""Game"")

class Game(State):
    def __init__(self, control):
        super().__init__(control)
        self.images = self.create_images()
        self.positions = (40, 30), (500, 200), (150, 320)

    def create_images(self):
        box = pygame.Surface((100, 100))
        box.fill(""blue"")

        rect = pygame.Rect(0, 0, 50, 50)
        circle = pygame.Surface(rect.size, pygame.SRCALPHA)
        pygame.draw.circle(circle, ""lawngreen"", rect.center, rect.width / 2 - 1)

        rect = pygame.Rect(0, 0, 60, 60)
        triangle = pygame.Surface(rect.size, pygame.SRCALPHA)
        points = rect.midtop, rect.bottomright, rect.bottomleft
        pygame.draw.polygon(triangle, ""firebrick"", points)

        return box, circle, triangle

    def on_draw(self, surface):
        surface.fill(""black"")
        for (image, pos) in zip(self.images, self.positions):
            surface.blit(image, pos)

    def on_event(self, event):
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                self.control.state.push(""Pause"")

class Pause(State):
    def __init__(self, control):
        super().__init__(control)
        self.image = pygame.Surface(self.control.rect.size, pygame.SRCALPHA)
        self.fill_color = pygame.Color(250, 250, 0, 100)
        self.font = pygame.font.Font(None, 24)
        self.alpha_sprite = QuickSprite()
        self.update_alpha()

    def on_draw(self, surface):
        game = self.control.state.get(""Game"")
        game.on_draw(surface)
        surface.blit(self.image, (0, 0))
        self.alpha_sprite.draw(surface)

    def on_event(self, event):
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_UP:
                if self.fill_color.a < 250:
                    self.fill_color.a += 10
                    self.update_alpha()
            elif event.key == pygame.K_DOWN:
                if self.fill_color.a > 10:
                    self.fill_color.a -= 10
                    self.update_alpha()
            else:
                self.control.state.push(""Game"")

    def update_alpha(self):
        self.image.fill(self.fill_color)
        image = self.font.render(str(self.fill_color.a), 1, 'navy')
        self.alpha_sprite.set_image(image)
        self.alpha_sprite.rect.top = 20
        self.alpha_sprite.rect.right = self.control.rect.right - 20

# Other
class QuickSprite:
    def __init__(self, image=None):
        if image:
            self.set_image(image)

    def draw(self, surface):
        surface.blit(self.image, self.rect)

    def set_image(self, image):
        self.image = image
        self.rect = image.get_rect()

def main():
    control = StateControl(""Example"", (800, 600))
    control.state.add(""Game"", Game(control))
    control.state.add(""Pause"", Pause(control))
    control.run(Intro(control))

if __name__ == ""__main__"":
    pygame.init()
    main()
    pygame.quit()
"
H89wG2Rp,Create a bootable USB flash drive Windows Server 2022,mdelatorre,PowerShell,Wednesday 29th of October 2025 08:34:44 PM CDT,"# Create a bootable USB flash drive in Win Srv 2022
# https://t.ly/HzBuo
# Save as winsrv2022_bootable.ps1


# Select USB drive letter
$usbDriveLetter = Read-Host ""Enter USB drive letter (Ex: E)""

# Format USB drive
Format-Volume -DriveLetter $usbDriveLetter -FileSystem NTFS -NewFileSystemLabel ""WinServerUSB"" -Confirm:$false | Out-Null

# Select ISO file mount point
$isoMountPointDriveLetter = Read-Host ""Enter ISO mount point drive letter (Ex: F)""

# Copy ISO files to USB drive
$source = ""$($isoMountPointDriveLetter):\""
$destination = ""$($usbDriveLetter):\""
robocopy $source $destination /COPYALL /Z /E /SEC /R:3 /W:3

# Make USB drive bootable
$usbDriveNumber = (Get-WmiObject -Class Win32_DiskDrive | Where-Object {$_.InterfaceType -eq ""USB"" -and $_.DeviceID -like ""*$usbDriveLetter""}).Index
bootsect /nt60 $usbDriveLetter`:

# Task completion notification
Write-Host ""USB Creation Complete!""
Start-Sleep -Seconds 2

#------------------------------------------------------------------------------------------------
# Error with script policy not letting it run

The following will allow all local scripts to execute on the VM, irrespective of whether they're signed or not:
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine"
fg7fQ7sP,Lucide Icons Wrapper,darraghd493,Lua,Wednesday 29th of October 2025 07:31:39 PM CDT,"--[[
    Lucide Icons Wrapper by darraghd493
 
    A simple wrapper for accessing icons from Lucide Icons Picker v2.
]]

local ASSETS_URL = ""https://pastebin.com/raw/reKydqu6""

local success, icons = pcall(function()
    return loadstring(game:HttpGet(ASSETS_URL))()
end)
if success then
    if not icons[""assets""] then
        error(""Invalid library format from '"" .. ASSETS_URL .. ""'"")
        return nil
    end
    return function(name: string)
        return icons[""assets""][string.lower(name)] or icons[""assets""][""lucide-"" .. string.lower(name)] or icons[""assets""][""lucide-alert-triangle""]
    end
else
    error(""Failed to load library '"" .. ASSETS_URL .. ""': "" .. tostring(icons))
    return nil
end
"
nJbnqPx9,LM-trickortreat-monsters,parracodea,JSON,Wednesday 29th of October 2025 07:15:06 PM CDT,"[
    `kevinc70GhostLove 👻`,
    `Witch 🧙‍♀️`,
    `Vampire bbtheeVamPop`,
    `Zombie justinegZombie`,
    `Skeleton 💀`,
    `Monster 🧌`,
    `Werewolf 🐺`,
    `Spider 🕷️`,
    `Black Cat 🐈‍⬛`,
    `Bat 🦇`
]"
