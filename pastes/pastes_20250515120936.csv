id,title,username,language,date,content
1nhm9tPh,RBLX. TimerScript,Hasli4,Lua,Thursday 15th of May 2025 07:06:59 AM CDT,"function Round(n, decimals)
	decimals = decimals or 0
	return math.floor(n * 10^decimals) / 10^decimals
end
local last_time = 0

local debounce = true
local BeginRace = game.Workspace.Start.BeginRace
local EndRace = game.Workspace.Finish.EndRace
local TextLabel = script.Parent.TextLabel
while true do
if BeginRace.Disabled and debounce then
		debounce = false
		local timer_status = true
		local timeStart = tick()
		while timer_status do
			local raceTimeResult = tick() - timeStart
			raceTimeResult = Round(raceTimeResult, 2)
			last_time = raceTimeResult
			TextLabel.Text = ""Time:""..tostring(last_time)
			if EndRace.Disabled then
				timer_status = false
				wait(5)
				debounce = true
				break
			end
			wait()
		end
	end
	wait()
end




"
ERAzQPaC,❤️ Telegram Leaks ❤️,Duipo,JavaScript,Thursday 15th of May 2025 06:50:12 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

52090
"
Lw463MtD,❤️private mehtod MT,tyty77923,JavaScript,Thursday 15th of May 2025 06:48:01 AM CDT," 
check it out at >> https://t.me/LucasL3AK  

bIswogLa4I
"
Fh04VRxs,❤️ Private BTC Method ❤️,Duipo,JavaScript,Thursday 15th of May 2025 06:29:50 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

93110
"
yzaStKyN,❤️ Private BTC Method ❤️,Duipo,JavaScript,Thursday 15th of May 2025 06:28:45 AM CDT,"Check it out at >> https://t.me/leakzbyeminem

72836"
87PEiDUd,Untitled,Duipo,JavaScript,Thursday 15th of May 2025 06:19:32 AM CDT,"Check it out at >> https://t.me/leakzbyeminem

231034901"
QbUdvd4m,❤️private mehtod CD,ONEHO,JavaScript,Thursday 15th of May 2025 06:16:12 AM CDT," 
check it out at >> https://t.me/LucasL3AK  

fn1vogwhL3
"
mS2gYQfS,dataNone,TestGuy1,JSON,Thursday 15th of May 2025 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '7efb5593c4624f3c1a0c8d556c6b08d1364c78369684985bca3c5c07bab66827f9a8550227c46e66745d947b03758f616c69fc3e6a314e79ad8f149f6829612a65df60c7151ae0a34113c3beb5c5d4f38f5651b0f425be0dba59b570c70b174488b6d890ac7c50c20c6a79a4b4fb5959296420cc95ff6e220c6ed087bcbd28e2',
  otherdata: [
    'd6348e2006ddb626ddf978bd5b76265e',
    'ce5fa1658e9df9e93b4fa3d2850d19c9',
    'b3c2f9e4ac7c845c9ef6c4596ff5e4b8',
    'b837fd242dd782d1b3e5fb6b3f4b0eb3',
    'adbd3522bf9a8d13279e0f4d848d4100',
    'c9260fb475f17bfc063d31ae50c57281',
    'b6ce0f77f4f4bcc6690d85c2d9e94381',
    '460f1069ac50fb249f17f55bac270c14'
  ]
}"
59MYEZaq,Untitled,heartsker,C++,Thursday 15th of May 2025 05:12:34 AM CDT,"#include <strategy/strategies/features_perceptron/strategy.h>
#include <util/macros/macros.h>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <array>
#include <algorithm> // для std::max и std::min

namespace {
    // Функция активации – сигмоида с защитой от переполнения.
    double Sigmoid(double x) {
        // Ограничиваем аргумент, чтобы избежать переполнения exp(-x)
        if (x < -100) x = -100;
        if (x > 100)  x = 100;
        double res = 1.0 / (1.0 + exp(-x));
        // if (std::isnan(res) || std::isinf(res) || std::isnan(-res)) {
        //     // std::cerr << x << "" -> "" << res << std::endl;
        //     throw std::runtime_error(""Sigmoid overflow"");
        // }
        return res;
    }

    // Генерация случайного веса в диапазоне [-0.5, 0.5]
    double RandomWeight() {
        return ((double)rand() / RAND_MAX) - 0.5;
    }
    
    // Простейшая функция для определения максимального значения из вектора
    int Max(const std::vector<int>& v) {
        int maxVal = v[0];
        for (size_t i = 1; i < v.size(); ++i) {
            if (v[i] > maxVal)
                maxVal = v[i];
        }
        return maxVal;
    }
    
    // Функция ограничения (clamping) значения в диапазоне [minVal, maxVal]
    double Clamp(double value, double minVal, double maxVal) {
        if (value < minVal) return minVal;
        if (value > maxVal) return maxVal;
        return value;
    }
}

TFeaturesPerceptronStrategy::TFeaturesPerceptronStrategy(const TParams& params)
    : atr(TParams{{""period"", std::get<int>(params[""atr""])}})
    , ma(TParams{{""period"", std::get<int>(params[""ma""])}})
    , ma2(TParams{{""period"", std::get<int>(params[""ma2""])}})
    , ema(TParams{{""period"", std::get<int>(params[""ema""])}})
    , rsi(TParams{{""period"", std::get<int>(params[""rsi""])}})
    , vrsi(TParams{{""period"", std::get<int>(params[""vrsi""])}})
    , macd(TParams{
        {""fast"", std::get<int>(params[""macd_fast""])},
        {""slow"", std::get<int>(params[""macd_slow""])},
        {""smooth"", std::get<int>(params[""macd_smooth""])}
    })
    , max(TParams{{""period"", std::get<int>(params[""optimum""])}})
    , min(TParams{{""period"", std::get<int>(params[""optimum""])}})
    , history(Max({
        std::get<int>(params[""atr""]) + 1,
        std::get<int>(params[""ma""]),
        std::get<int>(params[""ma2""]),
        std::get<int>(params[""ema""]),
        std::get<int>(params[""rsi""]),
        std::get<int>(params[""vrsi""]),
        std::get<int>(params[""macd_fast""]) + std::get<int>(params[""macd_smooth""]),
        std::get<int>(params[""macd_slow""]) + std::get<int>(params[""macd_smooth""]),
        std::get<int>(params[""optimum""]),
        std::get<int>(params[""avg_delta_period""]) + std::get<int>(params[""avg_delta_delta_period""]),
        // 1000
    }))
    , forward(std::get<int>(params[""forward""]))
    , threshold(std::get<double>(params[""threshold""]))
    , fee(std::get<double>(params[""fee""]))
    , learningRate(std::get<double>(params[""learning_rate""]))
    , stopLoss(std::get<double>(params[""stop_loss""]))
    , avgDelta(TParams{
        {""period"", std::get<int>(params[""avg_delta_period""])},
        {""delta_period"", std::get<int>(params[""avg_delta_delta_period""])},
    })
{
    // Инициализируем веса и смещения скрытого слоя
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        hiddenBias[i] = 0.0;
        for (size_t j = 0; j < INPUT_SIZE; ++j) {
            hiddenWeights[i][j] = RandomWeight();
        }
    }
    // Инициализируем веса и смещение выходного слоя
    outputBias = 0.0;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        outputWeights[i] = RandomWeight();
    }
}

TStrategyOut TFeaturesPerceptronStrategy::Signal(const TMarketState& state) {
    // Если есть достаточно свечей, обучаем сеть по новым данным.
    // Здесь SubView(offset, count) используется: offset = (i - history), count = history.

    // Определяем индекс начала обучения (исходим из того, до какого момента уже проводилось обучение)
    int trainFrom = state.candles.Size() - 1;
    while (trainFrom > history && state.candles[trainFrom].time > lastTrain) {
        trainFrom--;
    }
    if (state.candles[trainFrom].time == lastTrain) {
        trainFrom++;
    }
    // Обучаем сеть на новых данных
    double X = 3.0;
    double Y = 5.0;
    for (size_t i = trainFrom; i + forward < state.candles.Size(); ++i) {
        // Создаем копию состояния для обучения и выбираем подмножество свечей длиной history
        TMarketState trainState = state;
        trainState.candles = state.candles.SubView(i - history, history);
        // Целевое значение: 1, если последняя свеча выше предпоследней, иначе 0
        double target = 0;
        double init = state.candles[i - 1].close;
        double comission = X * fee * init;
        double minimum = init;
        double maximum = init;
        for (size_t j = i; j <= i + forward; ++j) {
            double price = state.candles[j].close;
            minimum = std::min(minimum, price);
            maximum = std::max(maximum, price);
            if (price - init > comission * Y) {
                // target = (maximum - init < comission ? 1 : 0.5);
                target = (init - minimum < comission ? 1 : 0);
                break;
            }
            // if (init - price > comission * 2) {
            //     target = (init - minimum < comission ? 0: 0.5);
            //     break;
            // }
        }
        if (target != 0.5) {
            // target = (state.candles[i + forward].close - init > 0 ? 1 : 0);
        // }
            if (target == 0) {
                zeros += learningRate;
            } else {
                ones += learningRate;
            }
            Train(trainState, target, learningRate);
            while (target == 0.0 && ones > zeros) {
                Train(trainState, target, learningRate);
                zeros += learningRate;
            }
            while (target == 1.0 && ones < zeros) {
                Train(trainState, target, learningRate);
                ones += learningRate;
            }
        }
        lastTrain = state.candles[i].time;
    }
    
    // Прямой проход для формирования торгового сигнала.
    // std::array<double, INPUT_SIZE> input = GetInput(state);
    std::array<double, INPUT_SIZE> normalized = GetInput(state);
    
    std::array<double, HIDDEN_SIZE> hiddenLayer;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        double sum = hiddenBias[i];
        for (size_t j = 0; j < INPUT_SIZE; ++j) {
            sum += hiddenWeights[i][j] * normalized[j];
        }
        hiddenLayer[i] = ::Sigmoid(sum);
    }
    
    double outputSum = outputBias;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        outputSum += outputWeights[i] * hiddenLayer[i];
    }
    double output = ::Sigmoid(outputSum);
    
    TIndicators indicators = {
        {""predict"", 2, output},
        {""up"", 2, threshold},
        {""down"", 2, 1.0 - threshold},
    };
    if (state.lots) {
        indicators.emplace_back(""stop"", 0, fakeStop);
        indicators.emplace_back(""take"", 0, fakeTake);
    }

    // uint64_t t = state.candles.Back().time % (60 * 60 * 24);
    // if (state.lots < 0 && t > 60 * 60 * 20.8) {
    //     return {ESignal::CLOSE, {}};
    // }
    // if ((t < 60 * 60 * 4 || t > 60 * 60 * 20.8)) {
    //     return {ESignal::CLOSE, {}};
    // }
    double price = state.candles.Back().close;
    if (state.lots) {
        if (++inTrade >= forward) {
            inTrade = 0;
            return {ESignal::CLOSE, indicators};
        }
        if (
            (state.lots > 0 && (fakeStop >= price || fakeTake <= price)) ||
            (state.lots < 0 && (fakeStop <= price || fakeTake >= price))
        ) {
            return {ESignal::CLOSE, indicators};
        }

        return {ESignal::NONE, indicators};
    }

    // output = avgDelta(state.candles);

    if (output > 1.0 - threshold) {
    // if (output > price * fee) {
        fakeStop = price - (price * X * fee);
        fakeTake = price + (price * X * Y * fee);
        inTrade = 0;
        // fakeStop = price - stopLoss * atr(state.candles);
        indicators.emplace_back(""stop"", 0, fakeStop);
        indicators.emplace_back(""take"", 0,fakeTake);
        return {ESignal::OPEN_BUY, indicators};
    } else if (output < threshold) {
    // } else if (output < -price * fee) {
        // inTrade = 0;
        // fakeStop = price + (price * 3 * fee);
        // fakeTake = price - (price * 6 * fee);
        // fakeStop = price + stopLoss * atr(state.candles);
        // indicators.emplace_back(""stop"", fakeStop);
        // indicators.emplace_back(""take"", fakeTake);
        return {ESignal::CLOSE, indicators};
    }
    return {ESignal::NONE, indicators};

    // return {ESignal::NONE, indicators};
}

std::array<double, INPUT_SIZE> TFeaturesPerceptronStrategy::GetInput(const TMarketState& state) {
    UNUSED(state);
    double price = state.candles.Back().close;
    // uint64_t time = state.candles.Back().time;
    double atrValue = atr(state.candles);
    return {
        avgDelta(state.candles) / price,
        atrValue,
        (ma(state.candles) - price) / price,
        // (ma2(state.candles) - price) / price,
        // (ema(state.candles) - price) / price,
        (rsi(state.candles) - 50.0) / 10,
        (vrsi(state.candles) - 50.0) / 10,
        // macd(state.candles),
        // (max(state.candles) - price) / atrValue,
        // (min(state.candles) - price) / atrValue,
        // static_cast<double>(time % (60 * 60 * 24) - 12 * 60 * 60) / (60 * 60 * 3),
    };
}

std::array<double, INPUT_SIZE> TFeaturesPerceptronStrategy::Sigmoid(std::array<double, INPUT_SIZE> input) {
    for (size_t i = 0; i < INPUT_SIZE; ++i) {
        input[i] = ::Sigmoid(input[i]);
    }
    return input;
}

std::array<double, INPUT_SIZE> TFeaturesPerceptronStrategy::Normalize(const std::array<double, INPUT_SIZE>& input) {
    std::array<double, INPUT_SIZE> normalized;
    for (size_t i = 0; i < INPUT_SIZE; ++i) {
        if (std::isnan(input[i])) {
            // std::cerr << ""inp: "" << input[i] << std::endl;
            throw std::runtime_error(""Normalize overflow"");
        }
        normalized[i] = ::Sigmoid(input[i]);
        if (std::isnan(normalized[i])) {
            // std::cerr << ""normalized inp: "" << normalized[i] << std::endl;
            throw std::runtime_error(""Normalize overflow2"");
        }
    }
    return normalized;
}

std::array<double, HIDDEN_SIZE> TFeaturesPerceptronStrategy::Normalize(const std::array<double, HIDDEN_SIZE>& input) {
    std::array<double, HIDDEN_SIZE> normalized;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        normalized[i] = ::Sigmoid(input[i]);
        if (std::isnan(normalized[i])) {
            // std::cerr << ""normalized hid: "" << normalized[i] << std::endl;
            throw std::runtime_error(""Normalize overflow"");
        }
    }
    return normalized;
}

std::array<double, HIDDEN_SIZE> TFeaturesPerceptronStrategy::Sigmoid(std::array<double, HIDDEN_SIZE> input) {
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        input[i] = ::Sigmoid(input[i]);
    }
    return input;
}

void TFeaturesPerceptronStrategy::Train(const TMarketState& state, double target, double learningRate) {
    // 1. Прямой проход: получаем вход и вычисляем активации скрытого и выходного слоев.
    // std::array<double, INPUT_SIZE> input = GetInput(state);
    // for (size_t i = 0; i < INPUT_SIZE; ++i) {
    //     if (std::isnan(input[i])) {
    //         // std::cerr << ""input["" << i << ""]: "" << input[i] << std::endl;
    //         throw std::runtime_error(""Train overflow"");
    //     }
    // }
    std::array<double, INPUT_SIZE> normalized = GetInput(state);
    
    std::array<double, HIDDEN_SIZE> hiddenLayer;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        double sum = hiddenBias[i];
        for (size_t j = 0; j < INPUT_SIZE; ++j) {
            sum += hiddenWeights[i][j] * normalized[j];
            if (std::isnan(sum)) {
                // std::cerr << ""sum: "" << sum << std::endl;
                throw std::runtime_error(""not implemented"");
            }
        }
        hiddenLayer[i] = ::Sigmoid(sum);
    }
    
    double outputSum = outputBias;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        outputSum += outputWeights[i] * hiddenLayer[i];
        if (std::isnan(outputSum)) {
            // std::cerr << ""outputSum: "" << outputSum << std::endl;
            throw std::runtime_error(""not implemented"");
        }
    }
    double output = ::Sigmoid(outputSum);

    // std::cerr << ""output: "" << output << std::endl;
    if (std::isnan(output)) {
        throw std::runtime_error(""not implemented"");
    }
    
    // 2. Вычисляем ошибку и дельту для выходного слоя.
    double error = target - output;
    double deltaOutput = error * output * (1.0 - output);
    
    // Сохраняем копию выходных весов до обновления для расчёта дельт скрытого слоя.
    std::array<double, HIDDEN_SIZE> oldOutputWeights = outputWeights;
    
    // 3. Обновляем веса и смещение выходного слоя.
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        outputWeights[i] += learningRate * deltaOutput * hiddenLayer[i];
        outputWeights[i] = Clamp(outputWeights[i], -1000.0, 1000.0);
        if (std::isnan(outputWeights[i])) {
            // std::cerr << ""outputWeights: "" << outputWeights[i] << std::endl;
            throw std::runtime_error(""not implemented"");
        }
    }
    outputBias += learningRate * deltaOutput;
    outputBias = Clamp(outputBias, -1000.0, 1000.0);
    
    // 4. Обновляем веса скрытого слоя.
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        double deltaHidden = hiddenLayer[i] * (1 - hiddenLayer[i]) * (oldOutputWeights[i] * deltaOutput);

        if (std::isnan(deltaHidden)) {
            // std::cerr << ""deltaHidden: "" << deltaHidden << std::endl;
            throw std::runtime_error(""not implemented"");
        }
        for (size_t j = 0; j < INPUT_SIZE; ++j) {
            hiddenWeights[i][j] += learningRate * deltaHidden * normalized[j];
            hiddenWeights[i][j] = Clamp(hiddenWeights[i][j], -1000.0, 1000.0);
            if (std::isnan(hiddenWeights[i][j])) {
                // std::cerr << ""deltaHidden: "" << hiddenWeights[i][j] << std::endl;
                throw std::runtime_error(""not implemented"");
            }
        }
        hiddenBias[i] += learningRate * deltaHidden;
        hiddenBias[i] = Clamp(hiddenBias[i], -1000.0, 1000.0);
        if (std::isnan(hiddenBias[i])) {
            // std::cerr << ""hiddenBias: "" << hiddenBias[i] << std::endl;
            throw std::runtime_error(""not implemented"");
        }
    }
}

void TFeaturesPerceptronStrategy::PrintWeights() const {
    std::cerr << ""Hidden weights:"" << std::endl;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        for (size_t j = 0; j < INPUT_SIZE; ++j) {
            std::cerr << hiddenWeights[i][j] << "" "";
        }
        std::cerr << std::endl;
    }
    std::cerr << ""Hidden bias: "" << std::endl;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        std::cerr << hiddenBias[i] << "" "";
    }
    std::cerr << std::endl;
    std::cerr << ""Output weights: "" << std::endl;
    for (size_t i = 0; i < HIDDEN_SIZE; ++i) {
        std::cerr << outputWeights[i] << "" "";
    }
    std::cerr << std::endl;
    std::cerr << ""Output bias: "" << std::endl;
    std::cerr << outputBias << std::endl;
}"
quB8bE7s,Favourite Client,Cakey3101,Lua,Thursday 15th of May 2025 04:57:16 AM CDT,"local Players = game:GetService(""Players"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local AvatarEditorService = game:GetService(""AvatarEditorService"")

local Remotes = ReplicatedStorage.Remotes

local Player = Players.LocalPlayer
local PlayerGui = Player.PlayerGui

local Gui = PlayerGui:WaitForChild(""FavouriteUI"")
local Button = Gui.Button

local AlreadyRecieved = false

local GAME_ID = game.PlaceId
local AVATAR_ITEM_TYPE = Enum.AvatarItemType.Asset

local function HasInventoryAccess()
	local Success, Permission = pcall(function()
		return AvatarEditorService:PromptAllowInventoryReadAccess()
	end)
	
	return Success and Permission
end

local function CheckFavourite()
	if not HasInventoryAccess() then
		warn(""Cannot Read Player's Inventory Due To Privacy Reasons"")
		return false
	end
	
	local Success, Favourited = pcall(function()
		return AvatarEditorService:GetFavorite(GAME_ID, AVATAR_ITEM_TYPE)
	end)
	
	if not Success then
		warn(""Failed To Check If Favourited"")
	end
	
	return Favourited
end

local function PromptFavourite()
	pcall(function()
		AvatarEditorService:PromptSetFavorite(GAME_ID, AVATAR_ITEM_TYPE, true)
	end)
end

local function ButtonClicked()
	if CheckFavourite() or AlreadyRecieved then return end
	
	PromptFavourite()
end

local function PromptSetFavouriteCompleted(Result: Enum.AvatarPromptResult)
	if Result ~= Enum.AvatarPromptResult.PermissionDenied and not AlreadyRecieved then
		AlreadyRecieved = true
		Remotes.GameFavourited:FireServer()
	end
end

Button.MouseButton1Click:Connect(ButtonClicked)
AvatarEditorService.PromptSetFavoriteCompleted:Connect(PromptSetFavouriteCompleted)"
HHrC4uji,Favourite Server,Cakey3101,Lua,Thursday 15th of May 2025 04:57:04 AM CDT,"local Players = game:GetService(""Players"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local DataStoreService = game:GetService(""DataStoreService"")
local RunService = game:GetService(""RunService"")

local DataStore = DataStoreService:GetDataStore(""MyDataStore1-"")

local Remotes = ReplicatedStorage.Remotes

local PlayerData = {}

local function PlayerAdded(Player: Player)
	local Leaderstats = Instance.new(""Folder"", Player)
	Leaderstats.Name = ""leaderstats""
	
	local Gems = Instance.new(""NumberValue"", Leaderstats)
	Gems.Name = ""Gems""
	Gems.Value = 0
	
	local UserId = Player.UserId
	local Key = ""Player_""..UserId
	
	local Success, SavedData = pcall(function()
		return DataStore:GetAsync(Key)
	end)
	
	if Success then
		PlayerData[UserId] = {
			HasFavourited = SavedData == true
		}
	else
		warn(""Failed To Load Data For Player"")
		PlayerData[UserId] = {
			HasFavourited = false
		}
	end
end

local function PlayerRemoving(Player: Player)
	local UserId = Player.UserId
	local Key = ""Player_""..UserId
	local SavedData = PlayerData[UserId]
	
	if SavedData then
		pcall(function()
			DataStore:SetAsync(Key, SavedData.HasFavourited)
		end)
	end
	
	PlayerData[UserId] = nil
end

local function BindToClose()
	for _, Player in Players:GetPlayers() do
		PlayerRemoving(Player)
	end
end

local function OnRemote(Player: Player)
	local UserId = Player.UserId
	local SavedData = PlayerData[UserId]
	
	if not SavedData or SavedData.HasFavourited then
		print(""Already Claimed!"")
		return
	end
	
	local Gems = Player:FindFirstChild(""leaderstats"") and Player.leaderstats:FindFirstChild(""Gems"")
	if Gems then
		Gems.Value += 10_000
		SavedData.HasFavourited = true
		print(""Recieved Reward!"")
	end
end

Players.PlayerAdded:Connect(PlayerAdded)
Players.PlayerRemoving:Connect(PlayerRemoving)
game:BindToClose(BindToClose)
Remotes.GameFavourited.OnServerEvent:Connect(OnRemote)"
pCvpWYSb,Лабораторна робота №18 (Завдання 1),Lavig,C++,Thursday 15th of May 2025 04:42:03 AM CDT,"#include <iostream>
#include <windows.h>

using namespace std;

template<typename T, size_t N>
bool arraysEqual(const T(&a)[N], const T(&b)[N]) {
    for (size_t i = 0; i < N; i++) {
        if (a[i] != b[i]) {
            return false;
        }
    }
    return true;
}

int main() {
    SetConsoleOutputCP(1251);
    SetConsoleCP(1251);
    const int N = 5;
    int choice{};
    while (true) {
        cout << ""Оберіть тип масиву:"" << endl;
        cout << ""1 - Цілі числа"" << endl;
        cout << ""2 - Числа з плаваючою комою"" << endl;
        cout << ""Введіть 1 або 2: "";
        cin >> choice;
        if (cin.fail() || (choice != 1 && choice != 2)) {
            cin.clear();
            cin.ignore(32767, '\n');
            cout << ""Число було введено неправильно. Спробуйте ще раз!"" << endl;
        }
        else {
            break;
        }
    }
    if (choice == 1) {
        int arr1[N]{};
        int arr2[N]{};
        cout << ""Введіть 5 цілих чисел першого масиву: "" << endl;
        for (int i = 0; i < N; i++) {
            cin >> arr1[i];
        }
        cout << ""Введіть 5 цілих чисел другого масиву: "" << endl;
        for (int i = 0; i < N; i++) {
            cin >> arr2[i];
        }

        if (arraysEqual(arr1, arr2)) {
            cout << ""Масиви рівні"" << endl;
        }
        else {
            cout << ""Масиви не рівні"" << endl;
        }
    }
    else if (choice == 2) {
        double arr1[N]{};
        double arr2[N]{};
        cout << ""Введіть 5 чисел з плаваючою комою першого масиву:"" << endl;
        for (int i = 0; i < N; i++) {
            cin >> arr1[i];
        }
        cout << ""Введіть 5 чисел з плаваючою комою другого масиву:"" << endl;
        for (int i = 0; i < N; i++) {
            cin >> arr2[i];
        }
        if (arraysEqual(arr1, arr2)) {
            cout << ""Масиви рівні"" << endl;
        }
        else {
            cout << ""Масиви не рівні"" << endl;
        }
    }
}"
tBv7a2SN,HP Gauge besides Enemy,FlipelyFlip,Ruby,Thursday 15th of May 2025 03:32:58 AM CDT,"class Scene_Battle < Scene_Base
  #--------------------------------------------------------------------------
  # * Start processing
  #--------------------------------------------------------------------------
  alias enemy_hp_start start
  def start
    super
    enemy_hp_start
    create_enemy_hp_windows
  end
  
  def create_enemy_hp_windows
    @window_enemy_hp = []
    for i in 0...$game_troop.members.length
      en = $game_troop.members[i]
      @window_enemy_hp[i] = Window_Enemy_HP.new(en.screen_x-160, en.screen_y-60,160,80, en)
      @window_enemy_hp[i].visible = !en.hidden
    end
  end

  alias enemy_hp_update update_basic
  def update_basic(main = false)
    enemy_hp_update(main)
    for i in 0...$game_troop.members.length
      en = $game_troop.members[i]
      @window_enemy_hp[i].refresh
      @window_enemy_hp[i].visible = !en.hidden
      @window_enemy_hp[i].visible = false if en.hp == 0
    end
  end
  
end

class Window_Enemy_HP < Window_Base
  def initialize(x,y,width,height,enemy)
    super(x,y,width,height)
    self.opacity = 0
    @enemy = enemy
    refresh
  end
  
  def refresh
    self.contents.clear
    draw_actor_hp(@enemy,0,0)
  end
end"
EwbNtQLJ,2025-05-15T10:26:28.058722,powerampache,PHP,Thursday 15th of May 2025 03:26:28 AM CDT,"1.00-70 (70) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
U2g1pd5v,2025-05-15T10:09:27.477698,powerampache,PHP,Thursday 15th of May 2025 03:09:26 AM CDT,"1.01-78 (78) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
aC3EYs2P,BONZCH8: A Chip-8 Emulator For BonziWorld!,nonogamer9,JavaScript,Thursday 15th of May 2025 03:07:00 AM CDT,"const prefix = ""!chip8 "";
const botname = ""BONZCH8 (!chip8)"";
let romList = [];
const MEMORY_SIZE = 4096;
const DISPLAY_WIDTH = 64;
const DISPLAY_HEIGHT = 32;
const PROGRAM_START = 0x200;
const FONT_START = 0x50;
let memory = new Uint8Array(MEMORY_SIZE);
let V = new Uint8Array(16);
let I = 0;
let pc = PROGRAM_START;
let stack = [];
let delayTimer = 0;
let soundTimer = 0;
let display = new Uint8Array(DISPLAY_WIDTH * DISPLAY_HEIGHT);
let keys = new Array(16).fill(false);
let running = false;
let autoRunInterval = null;
let autoRunSpeed = 1000;
const fontSet = [
  0xF0,0x90,0x90,0x90,0xF0, 0x20,0x60,0x20,0x20,0x70, 0xF0,0x10,0xF0,0x80,0xF0, 0xF0,0x10,0xF0,0x10,0xF0,
  0x90,0x90,0xF0,0x10,0x10, 0xF0,0x80,0xF0,0x10,0xF0, 0xF0,0x80,0xF0,0x90,0xF0, 0xF0,0x10,0x20,0x40,0x40,
  0xF0,0x90,0xF0,0x90,0xF0, 0xF0,0x90,0xF0,0x10,0xF0, 0xF0,0x90,0xF0,0x90,0x90, 0xE0,0x90,0xE0,0x90,0xE0,
  0xF0,0x80,0x80,0x80,0xF0, 0xE0,0x90,0x90,0x90,0xE0, 0xF0,0x80,0xF0,0x80,0xF0, 0xF0,0x80,0xF0,0x80,0x80
];
for (let i = 0; i < fontSet.length; i++) memory[FONT_START + i] = fontSet[i];
const exampleROM = [0x00, 0xE0, 0x60, 0x00, 0x61, 0x00, 0xA2, 0x02, 0xD0, 0x11, 0x70, 0x08, 0x30, 0x40, 0x12, 0x06];

function sendMsg(msg) {
    setTimeout(() => {
        socket.emit(""talk"", { text: msg });
    }, 1100);
}

setTimeout(() => { socket.emit(""command"", { list: [""name"", botname] }) }, 1000);
setTimeout(() => { socket.emit(""command"", { list: [""name"", botname] }) }, 2100);
setTimeout(() => {
    sendMsg(""BONZCH8 is online. The Only Emulator For BonziWorld! Type !chip8 help for commands."");
    setInterval(() => { sendMsg(""BONZCH8 is online. The Only Emulator For BonziWorld! Type !chip8 help for commands.""); }, 60000);
}, 3200);

function loadROM(rom) {
    reset();
    for (let i = 0; i < rom.length; i++) memory[PROGRAM_START + i] = rom[i];
    running = true;
    sendMsg(""ROM loaded."");
}

function reset() {
    memory.fill(0);
    for (let i = 0; i < fontSet.length; i++) memory[FONT_START + i] = fontSet[i];
    V.fill(0);
    I = 0;
    pc = PROGRAM_START;
    stack = [];
    delayTimer = 0;
    soundTimer = 0;
    display.fill(0);
    keys.fill(false);
    running = false;
    stopAutoRun();
}

function stopAutoRun() {
    if (autoRunInterval !== null) {
        clearInterval(autoRunInterval);
        autoRunInterval = null;
    }
}

function startAutoRun(intervalMs = autoRunSpeed) {
    stopAutoRun();
    autoRunInterval = setInterval(() => {
        if (!running) {
            stopAutoRun();
            return;
        }
        for (let i = 0; i < 10; i++) cycle();
        sendMsg(renderChip8Braille14x6());
    }, intervalMs);
}

function renderChip8Braille14x6() {
    const BRAILLE_WIDTH = 14, BRAILLE_HEIGHT = 6;
    const PIXEL_W = 2, PIXEL_H = 4;
    const VIRTUAL_W = BRAILLE_WIDTH * PIXEL_W;
    const VIRTUAL_H = BRAILLE_HEIGHT * PIXEL_H;
    const scaleX = DISPLAY_WIDTH / VIRTUAL_W;
    const scaleY = DISPLAY_HEIGHT / VIRTUAL_H;
    let out = [];
    for (let by = 0; by < BRAILLE_HEIGHT; by++) {
        let line = """";
        for (let bx = 0; bx < BRAILLE_WIDTH; bx++) {
            let code = 0x2800;
            for (let dy = 0; dy < PIXEL_H; dy++) {
                for (let dx = 0; dx < PIXEL_W; dx++) {
                    let vx = bx * PIXEL_W + dx;
                    let vy = by * PIXEL_H + dy;
                    let chip8x = Math.floor(vx * scaleX);
                    let chip8y = Math.floor(vy * scaleY);
                    if (chip8x < DISPLAY_WIDTH && chip8y < DISPLAY_HEIGHT) {
                        let dot = display[chip8x + chip8y * DISPLAY_WIDTH] ? 1 : 0;
                        if (dot) {
                            const dotIndex = [
                                [0, 1, 2, 6],
                                [3, 4, 5, 7]
                            ][dx][dy];
                            code |= (1 << dotIndex);
                        }
                    }
                }
            }
            line += String.fromCharCode(code);
        }
        out.push(line);
    }
    return out.join(""\n"");
}

function cycle() {
    let opcode = (memory[pc] << 8) | memory[pc + 1];
    let x = (opcode & 0x0F00) >> 8;
    let y = (opcode & 0x00F0) >> 4;
    let n = opcode & 0x000F;
    let nn = opcode & 0x00FF;
    let nnn = opcode & 0x0FFF;
    pc += 2;
    switch(opcode & 0xF000) {
        case 0x0000:
            if (opcode === 0x00E0) { display.fill(0); }
            else if (opcode === 0x00EE) { pc = stack.pop(); }
            break;
        case 0x1000: pc = nnn; break;
        case 0x2000: stack.push(pc); pc = nnn; break;
        case 0x3000: if (V[x] === nn) pc += 2; break;
        case 0x4000: if (V[x] !== nn) pc += 2; break;
        case 0x5000: if (V[x] === V[y]) pc += 2; break;
        case 0x6000: V[x] = nn; break;
        case 0x7000: V[x] = (V[x] + nn) & 0xFF; break;
        case 0x8000:
            switch (n) {
                case 0x0: V[x] = V[y]; break;
                case 0x1: V[x] |= V[y]; break;
                case 0x2: V[x] &= V[y]; break;
                case 0x3: V[x] ^= V[y]; break;
                case 0x4: {
                    let sum = V[x] + V[y];
                    V[0xF] = sum > 0xFF ? 1 : 0;
                    V[x] = sum & 0xFF;
                } break;
                case 0x5: {
                    V[0xF] = V[x] > V[y] ? 1 : 0;
                    V[x] = (V[x] - V[y]) & 0xFF;
                } break;
                case 0x6: {
                    V[0xF] = V[x] & 0x1;
                    V[x] >>= 1;
                } break;
                case 0x7: {
                    V[0xF] = V[y] > V[x] ? 1 : 0;
                    V[x] = (V[y] - V[x]) & 0xFF;
                } break;
                case 0xE: {
                    V[0xF] = (V[x] & 0x80) >> 7;
                    V[x] = (V[x] << 1) & 0xFF;
                } break;
            } break;
        case 0x9000: if (V[x] !== V[y]) pc += 2; break;
        case 0xA000: I = nnn; break;
        case 0xB000: pc = nnn + V[0]; break;
        case 0xC000: V[x] = (Math.floor(Math.random() * 0xFF)) & nn; break;
        case 0xD000: {
            let vx = V[x] % DISPLAY_WIDTH;
            let vy = V[y] % DISPLAY_HEIGHT;
            V[0xF] = 0;
            for (let row = 0; row < n; row++) {
                let sprite = memory[I + row];
                for (let col = 0; col < 8; col++) {
                    if ((sprite & (0x80 >> col)) !== 0) {
                        let xi = vx + col;
                        let yi = vy + row;
                        if (xi >= DISPLAY_WIDTH || yi >= DISPLAY_HEIGHT) continue;
                        let idx = xi + yi * DISPLAY_WIDTH;
                        if (display[idx]) V[0xF] = 1;
                        display[idx] ^= 1;
                    }
                }
            }
        } break;
        case 0xE000:
            if (nn === 0x9E) { if (keys[V[x]]) pc += 2; }
            else if (nn === 0xA1) { if (!keys[V[x]]) pc += 2; }
            break;
        case 0xF000:
            switch (nn) {
                case 0x07: V[x] = delayTimer; break;
                case 0x0A: {
                    let key = keys.findIndex(k => k);
                    if (key === -1) { pc -= 2; } else { V[x] = key; }
                } break;
                case 0x15: delayTimer = V[x]; break;
                case 0x18: soundTimer = V[x]; break;
                case 0x1E: I = (I + V[x]) & 0xFFF; break;
                case 0x29: I = FONT_START + (V[x] * 5); break;
                case 0x33: {
                    memory[I] = Math.floor(V[x] / 100);
                    memory[I + 1] = Math.floor((V[x] % 100) / 10);
                    memory[I + 2] = V[x] % 10;
                } break;
                case 0x55: for (let i = 0; i <= x; i++) memory[I + i] = V[i]; break;
                case 0x65: for (let i = 0; i <= x; i++) V[i] = memory[I + i]; break;
            } break;
    }
}

const help = ""__BONZCH8 Commands__\n"" +
    ""!chip8 help - Show this help\n"" +
    ""!chip8 load [url|number] - Download a ROM from URL and add it to the list, or load a ROM from the list (e.g. 1)\n"" +
    ""!chip8 roms - List downloaded ROMs\n"" +
    ""!chip8 listroms - List downloaded ROMs\n"" +
    ""!chip8 reset - Reset emulator\n"" +
    ""!chip8 step - Step one instruction\n"" +
    ""!chip8 run - Run automatically, displaying every second\n"" +
    ""!chip8 stop - Stop automatic run, clear display, and halt ROM\n"" +
    ""!chip8 display - Show display buffer (14x6 braille)\n"" +
    ""!chip8 key [0-F] [down|up] - Press or release a CHIP-8 key\n"" +
    ""!chip8 speed <ms> - Set auto-run speed in milliseconds per frame (e.g. 500, 1500)"";

socket.on(""talk"", function (message) {
    if (!message.text.startsWith(prefix)) return;
    const args = message.text.substring(prefix.length).split("" "");
    const cmd = args[0];
    if (cmd === ""help"") {
        sendMsg(help);
    } else if (cmd === ""load"") {
        stopAutoRun();
        if (args[1]) {
            if (args[1].startsWith(""http"")) {
                fetch(args[1])
                    .then(response => response.arrayBuffer())
                    .then(buffer => {
                        const rom = new Uint8Array(buffer);
                        const name = args[1].split(""/"").pop() || `ROM${romList.length+1}`;
                        romList.push({ name, data: rom, url: args[1] });
                        sendMsg(`ROM downloaded and added as #${romList.length}: ${name}`);
                    })
                    .catch(() => sendMsg(""Failed to download ROM from URL.""));
            } else if (!isNaN(args[1])) {
                const idx = parseInt(args[1], 10) - 1;
                if (romList[idx]) {
                    loadROM(romList[idx].data);
                    sendMsg(`Loaded ROM #${idx+1}: ${romList[idx].name}`);
                } else {
                    sendMsg(""No ROM at that number. Use !chip8 roms to list available ROMs."");
                }
            } else {
                sendMsg(""Invalid argument. Use a URL or a ROM number."");
            }
        } else {
            loadROM(exampleROM);
            sendMsg(""Loaded default example ROM."");
        }
    } else if (cmd === ""roms"" || cmd === ""listroms"") {
        if (romList.length === 0) {
            sendMsg(""No ROMs downloaded yet."");
        } else {
            let msg = ""__ROM List__\n"";
            romList.forEach((rom, i) => {
                msg += `${i+1}. ${rom.name} (${rom.url})\n`;
            });
            sendMsg(msg.trim());
        }
    } else if (cmd === ""reset"") {
        reset();
        sendMsg(""Emulator reset."");
    } else if (cmd === ""step"") {
        stopAutoRun();
        if (!running) { sendMsg(""No ROM loaded.""); return; }
        cycle();
        sendMsg(""Stepped one instruction.\n"" + renderChip8Braille14x6());
    } else if (cmd === ""run"") {
        if (!running) { sendMsg(""No ROM loaded.""); return; }
        sendMsg(""Running automatically. Type !chip8 stop to halt."");
        startAutoRun(autoRunSpeed);
    } else if (cmd === ""stop"") {
        stopAutoRun();
        running = false;
        display.fill(0);
        sendMsg(""Stopped automatic run, cleared display, and halted ROM.\n"" + renderChip8Braille14x6());
    } else if (cmd === ""display"") {
        sendMsg(renderChip8Braille14x6());
    } else if (cmd === ""key"") {
        if (args.length < 3) {
            sendMsg(""Usage: !chip8 key [0-F] [down|up]"");
            return;
        }
        let keyStr = args[1].toUpperCase();
        let action = args[2].toLowerCase();
        let keyVal = parseInt(keyStr, 16);
        if (isNaN(keyVal) || keyVal < 0 || keyVal > 0xF) {
            sendMsg(""Invalid key. Use 0-9 or A-F."");
            return;
        }
        if (action === ""down"") {
            keys[keyVal] = true;
            sendMsg(""Key "" + keyStr + "" pressed."");
        } else if (action === ""up"") {
            keys[keyVal] = false;
            sendMsg(""Key "" + keyStr + "" released."");
        } else {
            sendMsg(""Invalid action. Use 'down' or 'up'."");
        }
    } else if (cmd === ""speed"") {
        if (args.length < 2 || isNaN(args[1]) || parseInt(args[1],10) < 100) {
            sendMsg(""Usage: !chip8 speed <milliseconds> (minimum 100)"");
            return;
        }
        autoRunSpeed = parseInt(args[1], 10);
        if (autoRunInterval !== null) {
            startAutoRun(autoRunSpeed);
            sendMsg(`Auto-run speed set to ${autoRunSpeed} ms per frame (applied immediately).`);
        } else {
            sendMsg(`Auto-run speed set to ${autoRunSpeed} ms per frame.`);
        }
    } else {
        sendMsg(""Unknown CHIP8 command. Type !chip8 help."");
    }
});
"
fSjjAB94,PROJECT SYNC,snatzki,JSON,Thursday 15th of May 2025 02:52:08 AM CDT,"Point (3141401.56869893567636609 13907481.9283484686166048)	1909|-95.2961473x29.9388185y	4475JT	2	Y		7231NR					7231NR	2025-04-25	Y							
Point (3141656.22983733471482992 13907412.78957785665988922)	1909|-95.2953506x29.9386063y	4475JT	2	Y		7231NR					7231NR	2025-04-25	Y							
Point (3141369.53440188197419047 13906973.87361578643321991)	1909|-95.2962992x29.9374249y	4475JT	2	N		7231NR					7231NR	2025-04-25	Y							
Point (3140871.73525351425632834 13906617.11755945347249508)	1909|-95.2979057x29.9364877y	4475JT	2	N		7231NR					7231NR	2025-04-25	Y							
Point (3140615.74895534105598927 13905798.5145154669880867)	1909|-95.2987953x29.93426y	4475JT	6	N		7231NR					7231NR	2025-04-25	Y							
Point (3141070.16352515434846282 13906681.24376918748021126)	1909|-95.2972731x29.9366466y	4475JT	6	N		7231NR					7231NR	2025-04-25	Y							
Point (3142909.83097977377474308 13912145.33842609077692032)	1909|-95.2909207x29.9515043y	4475JT	2	Y		7231NR					7231NR	2025-04-25	Y							
Point (3142662.64036394096910954 13907961.94107979722321033)	967_|-95.2921196x29.9400279y		2	Y							7231NR	2025-04-25	Y						AA	2
Point (3143087.90915868990123272 13907904.25999387539923191)	967_|-95.2907834x29.9398323y		2	Y							7231NR	2025-04-25	Y						AA	2
Point (3142725.69674818869680166 13907892.68242824263870716)	967_|-95.2919276x29.939832y		2	Y							7231NR	2025-04-25	Y						AA	2
Point (3142725.69674818823114038 13908020.86261916346848011)	967_|-95.2919147x29.9401843y		2	Y							7231NR	2025-04-25	Y						AA	2
Point (3143123.05534007353708148 13908009.69853802025318146)	967_|-95.2906619x29.940119y		2	Y							7231NR	2025-04-25	Y						AA	2
Point (3142278.51327563589438796 13908277.42974328249692917)	967_|-95.2933003x29.9409285y		2	N							7231NR	2025-04-25	Y						AA	2
Point (3140349.09128876123577356 13908006.49403324536979198)	967_|-95.2994162x29.9403518y		2	Y							7231NR	2025-04-25	Y						AA	2
Point (3140766.60724938102066517 13907561.06786976009607315)	967_|-95.2981432x29.9390912y		2	Y							7231NR	2025-04-25	Y						AD	2
Point (3140843.51536393957212567 13907471.75522059574723244)	967_|-95.2979094x29.9388391y		2	Y							7231NR	2025-04-25	Y						AD	2
Point (3141845.59501787833869457 13908195.14633039385080338)	967_|-95.2946747x29.9407401y		2	N							7231NR	2025-04-25	Y						AA	2
Point (3140806.92198685230687261 13907929.68928982131183147)	967_|-95.2979791x29.9401009y		2	N							7231NR	2025-04-25	Y						AA	2"
hPqXGdii,generic-template,AlexNovoross87,Go,Thursday 15th of May 2025 02:29:42 AM CDT,"Generics

impoгt ""golang.org/x/exp/constraints""
comparable - сравнимый
unsigned, signed без/знаковый
ordered - сортируемый
integer - все цедые числа
any - любой


| Позволяет одной функции обрабатывать несколько типов данных
| Сокращает дублирование кода
| Меньше кода = меньше вероятность ошибок
| Обобщения определяются с использованием интерфейсов (называемых ограничениями)
| Параметры функции и типы возвращаемых значений ограничены определенным набором интерфейсов

Синтаксис:
----------
1 Имя обобщенного типа
2 Ограничение / Интерфейс
3 ""Или""
           1    2                     3
           |    |                     |
           V    V                     V
func name [Т constraint U constraintA | constraintB](a T,b U ) T {
// .. }

func IsEqual[T comparable](a, b T) bool {
	return a == b
}

IsEqual(2, 2) 
IsEqual(""foo"", ""bar"") 
IsEqual( 'a', 'b') 
IsEqual[uint8](4, 4)


Создание ограничения
--------------------
Ограничение по своей сути это интерфейс!!!!!!

type Integers32 interface { 
    int32 | uint32
}

func SumNumbers[T Integers32](arr []T) T 
{ 
    var sum T 
    for i := 0; i < len(arr); i++ {
    sum += arr[i] } 
    return sum
}
nums := []int32{l, 2, 3} 
nums2 := []uint32{l, 2, 3} 
total := SumNumbers(nums) 
total2 := SumNumbers(nums2)


Ограничение должно иметь точное соответствие по типу!!!
type Mylnt int32
nums := []Mylnt {Mylnt(1), Mylnt(2), Mylnt(3)}

Хоть Mylnt это псевдоним для int32 функция func SumNumbers 
не сработает

-------------------------------------------------------

Приближение (Approximation) ~ означает что функция дожна
принять все что является int32 или uint32 в независимости
от имени 
type Integers32 interface { 
    ~int32 | ~uint32 
}

--------------------------------------------------------

Обобщенная структура

type MyArray[T constraints.Ordered] struct { 
    inner []T 
}

func (m *MyArray[T]) Max() T {
max := m.inner[O]
for i := 0; i < len(m.inner); i++ 
{ if m inner[i] > max {
max = m.inner[i]
}
return max
}
arr := MyArray[int]{inner: []fnt{6, 4, 8, 9, 4, 0}}
fmt.Printin(arr.Max())

}"
jCyY9e0f,Dijkstra rozwiązanie,Xinef,Python,Thursday 15th of May 2025 02:14:41 AM CDT,"import math
import time



def rysujGraf(x: int, y: int, graf):
  #top bar
  foo = '/'
  for i in range(0,x-1):
    foo = foo + '----'
  print(foo+'---\\')

  # rows
  for iy in range(0,y):
    foo = '|'
    for ix in range(0,x):
      value = graf[iy][ix]
      value3digit = ''
      if value < 10:
        value3digit = '  ' + str(value)
      elif value < 100:
        value3digit = ' ' + str(value)
      else:
        value3digit = '' + str(value)
      foo = foo + value3digit + '|'
    print(foo)
    if iy != y-1:
      foo = '|'
      for i in range(0, x - 1):
        foo = foo + '----'
      print(foo + '---|')

  #bottom bar
  foo = '\\'
  for i in range(0, x-1):
    foo = foo + '----'
  print(foo + '---/')


def czyIstniejąNieodwiedzone(x: int, y: int, odwiedzone):
  for iy in range(0, y):
    for ix in range(0, x):
      if odwiedzone[iy][ix] == False:
        return True
  return False


if __name__ == '__main__':
  # wczytaj wymiary grafu
  x = int(input())
  y = int(input())

  # utwórz graf o podanych wymiarach, inicjalizując odległości 999
  graf = [[999 for ix in range(x)] for iy in range(y)]
  # ustaw odległość w startowym narożniku na 0
  graf[0][0] = 0

  # rysuj graf
  rysujGraf(x,y,graf)

  # utwórz tablicę przejść między komórkami grafu
  tab = [[[0,0,0,0] for ix in range(x)] for iy in range(y)]

  # wczytaj wagi przejść (0 - brak przejścia)
  for iy in range(0,y):
    for ix in range(0,x):
      for id in range(4):
        tab[iy][ix][id] = int(input())

  print(tab)

  # Dijkstra

  # inicjalizacja
  odwiedzone = [[False for ix in range(x)] for iy in range(y)]

  aktualnyX = 0
  aktualnyY = 0

  # dopóki istnieją nieodwiedzone węzły powtarzamy:
  while czyIstniejąNieodwiedzone(x, y, odwiedzone):
    # ustaw nieodwiedzony węzeł z najniższą wartością jako aktualny
    najnizsza = math.inf
    for iy in range(0, y):
      for ix in range(0, x):
        if (odwiedzone[iy][ix] == False) and (graf[iy][ix] < najnizsza):
          aktualnyX = ix
          aktualnyY = iy
          najnizsza = graf[iy][ix]

    # aktualizacja sąsiadów
    for d in range(0,4):
      r = tab[aktualnyY][aktualnyX][d]
      if r > 0:
        dystansNowy = graf[aktualnyY][aktualnyX] + r
        if d == 0:
          # do góry
          dystansStary = graf[aktualnyY-1][aktualnyX]
          if dystansNowy < dystansStary:
            graf[aktualnyY-1][aktualnyX] = dystansNowy
        if d == 1:
          # w prawo
          dystansStary = graf[aktualnyY][aktualnyX+1]
          if dystansNowy < dystansStary:
            graf[aktualnyY][aktualnyX+1] = dystansNowy
        if d == 2:
          # w dół
          dystansStary = graf[aktualnyY+1][aktualnyX]
          if dystansNowy < dystansStary:
            graf[aktualnyY+1][aktualnyX] = dystansNowy
        if d == 3:
          # w lewo
          dystansStary = graf[aktualnyY][aktualnyX-1]
          if dystansNowy < dystansStary:
            graf[aktualnyY][aktualnyX-1] = dystansNowy

    # zaznaczenie aktualnego węzła jako odwiedzonego
    odwiedzone[aktualnyY][aktualnyX] = True

    rysujGraf(x, y, graf)
    time.sleep(1)
"
5trvLdQF,RBLX. TimerStop,Hasli4,Lua,Thursday 15th of May 2025 01:53:02 AM CDT,"local function Round(n, decimals)
	decimals = decimals or 0
	return math.floor(n * 10^decimals) / 10^decimals
end
local function check_finish( x_part )
    if x_part:IsA(""VehicleSeat"") == true then
workspace.Finish.Transparency = 1
	workspace.Finish.Transparency = 1
		workspace.Start.Transparency = 0
		local timer = game.ServerStorage:FindFirstChild(""RaseTimer"")
		print(""Гонка закончилась"", timer.Value)
		local raceTimeResult = tick() - timer.Value

        raceTimeResult = Round(raceTimeResult, 2)
		print(raceTimeResult, ""секунд прошло"")
		script.Disabled = true
		workspace.Finish:FindFirstChildOfClass(""Script"").Disabled = true
		wait(3)
		workspace.Start:FindFirstChildOfClass(""Script"").Disabled = false
	end
end
script.Parent.Touched:Connect(check_finish)
"
ThddmfF7,RBLX. TImerStart,Hasli4,Lua,Thursday 15th of May 2025 01:49:39 AM CDT,"local function check_start( x_part, x_parent )
    if x_part:IsA(""VehicleSeat"") == true then
		workspace.Finish.Transparency = 0
		workspace.Start.Transparency = 1
		local timer = Instance.new(""NumberValue"")
		timer.Name = ""RaseTimer""
		timer.Parent = game.ServerStorage
print(""Гонка началась"", x_part, x_parent)
		timer.Value = tick()
		script.Disabled = true
		workspace.Finish:FindFirstChildOfClass(""Script"").Disabled = false
	end
end
script.Parent.Touched:Connect(check_start)
"
Q8DGW0xB,RBLX. DeleteCar,Hasli4,Lua,Thursday 15th of May 2025 01:17:47 AM CDT,"local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local DeleteCarEvent = ReplicatedStorage:WaitForChild(""DeleteCar"")
local player = game.Players.LocalPlayer

game.Workspace.ChildAdded:Connect(function(Added)
	if Added.Name == player.Name .. 'sCar' then
		script.Parent.Visible = true
	end
end)
script.Parent.MouseButton1Down:Connect(function()
	local Car = game.Workspace:FindFirstChild(player.Name .. 'sCar')
	if Car then
		script.Parent.Visible = false
		if player.Character.Humanoid.SeatPart ~= nil and player.Character.Humanoid.SeatPart:IsA(""VehicleSeat"") then
			player.Character.Humanoid.Sit = false
		end
		wait()
		DeleteCarEvent:FireServer(Car)
	end
end)
"
t1mKE6nF,RBLX. SpawnCar,Hasli4,Lua,Thursday 15th of May 2025 01:16:07 AM CDT,"local ServerStorage = game:GetService(""ServerStorage"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local SpawnCarEvent = ReplicatedStorage:WaitForChild(""SpawnCar"")
local DeleteCarEvent = ReplicatedStorage:WaitForChild(""DeleteCar"")

SpawnCarEvent.OnServerEvent:Connect(function(player, carName)
	local Car = ServerStorage:FindFirstChild(""Cars""):FindFirstChild(carName)
	local CurCar = game.Workspace:FindFirstChild(player.Name .. 'sCar')
	if CurCar then
		CurCar:Remove()
	end
	if Car then
		local clonedCar = Car:Clone()
		clonedCar.Name = player.Name .. 'sCar'
		clonedCar.Parent = game.Workspace
		clonedCar:MoveTo(player.Character.HumanoidRootPart.Position + player.Character.HumanoidRootPart.CFrame.LookVector * 15)
	end
end)
DeleteCarEvent.OnServerEvent:Connect(function(player, Car)
	if Car then
		Car:Remove()
	end
end)
game.Players.PlayerRemoving:Connect(function(player)
	local Car = game.Workspace:FindFirstChild(player.Name .. 'sCar')
	if Car then
		Car:Remove()
	end
end)
game.Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		local Car = game.Workspace:FindFirstChild(player.Name .. 'sCar')
		if Car then
			Car:Remove()
		end
	end)
end)
"
V4KnfYB7,Roblox Remotevent Script,Steamhesaproblox,RBScript,Thursday 15th of May 2025 12:56:58 AM CDT,"local player = game.Players.LocalPlayer
local UserInputService = game:GetService(""UserInputService"")

local gui = Instance.new(""ScreenGui"")
gui.Name = ""RemoteEventTriggerGui""
gui.Parent = player:WaitForChild(""PlayerGui"")
gui.ResetOnSpawn = false

-- Ana frame
local frame = Instance.new(""Frame"")
frame.Size = UDim2.new(0, 300, 0, 400)
frame.Position = UDim2.new(0, 20, 0, 50)
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
frame.BorderSizePixel = 0
frame.Parent = gui

-- Başlık çubuğu (drag bölgesi)
local titleBar = Instance.new(""Frame"")
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
titleBar.Parent = frame

-- Başlık yazısı
local title = Instance.new(""TextLabel"")
title.Size = UDim2.new(1, -50, 1, 0)
title.BackgroundTransparency = 1
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.SourceSansBold
title.TextSize = 20
title.Text = ""ReplicatedStorage RemoteEvent'leri""
title.TextXAlignment = Enum.TextXAlignment.Left
title.Position = UDim2.new(0, 10, 0, 0)
title.Parent = titleBar

-- Kapat butonu
local closeButton = Instance.new(""TextButton"")
closeButton.Size = UDim2.new(0, 40, 1, 0)
closeButton.Position = UDim2.new(1, -40, 0, 0)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.Font = Enum.Font.SourceSansBold
closeButton.TextSize = 24
closeButton.Text = ""X""
closeButton.Parent = titleBar

-- Açma butonu (GUI kapandığında gösterilecek)
local openButton = Instance.new(""TextButton"")
openButton.Size = UDim2.new(0, 100, 0, 30)
openButton.Position = UDim2.new(0, 20, 0, 50)
openButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
openButton.TextColor3 = Color3.fromRGB(255, 255, 255)
openButton.Font = Enum.Font.SourceSansBold
openButton.TextSize = 18
openButton.Text = ""GUI Aç""
openButton.Visible = false
openButton.Parent = gui

-- ScrollFrame
local scrollingFrame = Instance.new(""ScrollingFrame"")
scrollingFrame.Size = UDim2.new(1, 0, 1, -30)
scrollingFrame.Position = UDim2.new(0, 0, 0, 30)
scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollingFrame.ScrollBarThickness = 8
scrollingFrame.BackgroundTransparency = 1
scrollingFrame.Parent = frame

local layout = Instance.new(""UIListLayout"")
layout.Parent = scrollingFrame
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, 5)

-- Butonları ekle
for _, remote in ipairs(game:GetService(""ReplicatedStorage""):GetDescendants()) do
    if remote:IsA(""RemoteEvent"") then
        local button = Instance.new(""TextButton"")
        button.Size = UDim2.new(1, -10, 0, 30)
        button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Font = Enum.Font.SourceSans
        button.TextSize = 18
        button.Text = remote.Name
        button.Parent = scrollingFrame

        button.MouseButton1Click:Connect(function()
            print(""🔥 FireServer tetiklendi: ""..remote:GetFullName())
            pcall(function()
                remote:FireServer()
            end)
        end)
    end
end

local function updateCanvasSize()
    scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 10)
end

layout:GetPropertyChangedSignal(""AbsoluteContentSize""):Connect(updateCanvasSize)
updateCanvasSize()

-- Drag işlemi
local dragging, dragInput, dragStart, startPos

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)

-- Kapat butonu
closeButton.MouseButton1Click:Connect(function()
    frame.Visible = false
    openButton.Visible = true
end)

-- Aç butonu
openButton.MouseButton1Click:Connect(function()
    frame.Visible = true
    openButton.Visible = false
end)
"
nXc0bJe0,RBLX. ChangeColor,Hasli4,Lua,Thursday 15th of May 2025 12:53:23 AM CDT,"script.Parent.MouseEnter:Connect(function()
	script.Parent.ImageTransparency = 0
	script.Parent.ImageColor3 = Color3.fromRGB(200,200,200)
end)
script.Parent.MouseLeave:Connect(function()
	script.Parent.ImageTransparency = 0.5
	script.Parent.ImageColor3 = Color3.fromRGB(255,255,255)
end)
"
wez3wEyB,**Relay Control** rev_01,pleasedontcode,Arduino,Thursday 15th of May 2025 12:52:08 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: **Relay Control**
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-05-15 05:50:58

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Control a relay module using digital output pin */
	/* D2, allowing for on/off switching based on sensor */
	/* data from the BMX280 environmental sensor. Ensure */
	/* proper initialization and data handling for */
	/* reliable operation. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <Relay.h>	//https://github.com/rafaelnsantos/Relay
#include <forcedBMX280.h>	//https://github.com/soylentOrange/Forced-BMX280

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);

/***** DEFINITION OF DIGITAL OUTPUT PINS *****/
const uint8_t My32relay_RelayModule_Signal_PIN_D2		= 2;

// USER CODE: Define relay pins for 32 relays
const int relayPins[32] = {
  // First relay module (Relays 1–16)
  22, 23, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37,
  // Second relay module (Relays 17–32)
  38, 39, 40, 41, 42, 43, 44, 45,
  46, 47, 48, 49, 50, 51, 52, 53
};

/***** DEFINITION OF OUTPUT RAW VARIABLES *****/
/***** used to store raw data *****/
bool	My32relay_RelayModule_Signal_PIN_D2_rawData		= 0;

/***** DEFINITION OF OUTPUT PHYSICAL VARIABLES *****/
/***** used to store data after characteristic curve transformation *****/
float	My32relay_RelayModule_Signal_PIN_D2_phyData		= 0.0;

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
// Instantiate the sensor object
ForcedBMX280 sensor; // Default I2C address is 0x76

void setup(void)
{
	// put your setup code here, to run once:
	pinMode(My32relay_RelayModule_Signal_PIN_D2, OUTPUT);

	// USER CODE: Initialize relay pins
	for (int i = 0; i < 32; i++) {
		pinMode(relayPins[i], OUTPUT);
		digitalWrite(relayPins[i], HIGH); // OFF (active LOW)
	}

	// Initialize the sensor
	if (sensor.begin() != ERROR_OK) {
		// Handle sensor initialization error
		while (1); // Stop execution if sensor fails to initialize
	}
}

void loop(void)
{
	// put your main code here, to run repeatedly:
	updateOutputs(); // Refresh output data

	// Read sensor data
	My32relay_RelayModule_Signal_PIN_D2_phyData = sensor.getTemperatureCelsius(); // Get temperature

	// Control relay based on temperature threshold
	if (My32relay_RelayModule_Signal_PIN_D2_phyData > 25.0) { // Example threshold
		My32relay_RelayModule_Signal_PIN_D2_rawData = true; // Turn ON relay
	} else {
		My32relay_RelayModule_Signal_PIN_D2_rawData = false; // Turn OFF relay
	}

	// Update relay state
	digitalWrite(My32relay_RelayModule_Signal_PIN_D2, My32relay_RelayModule_Signal_PIN_D2_rawData);

	// USER CODE: Control multiple relays
	int group1[] = {5, 13, 2, 10};
	int group2[] = {6, 14, 3, 11};
	int group3[] = {7, 15, 4, 12};
	int group4[] = {8, 16, 1, 9};

	// Extend groups by adding the same numbers +16
	int* allGroups[] = {
		group1, group2, group3, group4,
	};

	int groupSizes[] = {
		4, 4, 4, 4,
	};

	for (int i = 0; i < 4; i++) {
		int size = groupSizes[i];
		int fullGroup[32];
		for (int j = 0; j < size; j++) {
			fullGroup[j] = allGroups[i][j];
			fullGroup[j + size] = allGroups[i][j] + 16;
		}
		setRelays(fullGroup, size * 2, true, 4000);
	}

	while (false); // stop repeating
}

void updateOutputs()
{
	digitalWrite(My32relay_RelayModule_Signal_PIN_D2, My32relay_RelayModule_Signal_PIN_D2_rawData);
}

/* END CODE */"
bHuuNsnk,Dijkstra bazowy,Xinef,Python,Thursday 15th of May 2025 12:48:37 AM CDT,"import math
import time



def rysujGraf(x: int, y: int, graf):
  #top bar
  foo = '/'
  for i in range(0,x-1):
    foo = foo + '----'
  print(foo+'---\\')

  # rows
  for iy in range(0,y):
    foo = '|'
    for ix in range(0,x):
      value = graf[iy][ix]
      value3digit = ''
      if value < 10:
        value3digit = '  ' + str(value)
      elif value < 100:
        value3digit = ' ' + str(value)
      else:
        value3digit = '' + str(value)
      foo = foo + value3digit + '|'
    print(foo)
    if iy != y-1:
      foo = '|'
      for i in range(0, x - 1):
        foo = foo + '----'
      print(foo + '---|')

  #bottom bar
  foo = '\\'
  for i in range(0, x-1):
    foo = foo + '----'
  print(foo + '---/')


def czyIstniejąNieodwiedzone(x: int, y: int, odwiedzone):
  # sprawdzić w tablicy odwiedzone czy istnieje choć jeden nieodwiedzony
  # ...
  return False


if __name__ == '__main__':
  # wczytaj wymiary grafu
  x = int(input())
  y = int(input())

  # utwórz graf o podanych wymiarach, inicjalizując odległości 999
  graf = [[999 for ix in range(x)] for iy in range(y)]
  # ustaw odległość w startowym narożniku na 0
  graf[0][0] = 0

  # rysuj graf
  rysujGraf(x,y,graf)

  # utwórz tablicę przejść między komórkami grafu
  # przejścia kodowane są po kolei:
  # [G, P, D, L]
  # G - w górę
  # P - w prawo
  # D - w dół
  # L - w lewo
  # wartość 0 oznacza brak przejścia
  tab = [[[0,0,0,0] for ix in range(x)] for iy in range(y)]

  # wczytaj wagi przejść (0 - brak przejścia)
  for iy in range(0,y):
    for ix in range(0,x):
      for d in range(4):
        tab[iy][ix][d] = int(input())

  print(tab)

  # Dijkstra

  # inicjalizacja
  # oznaczyć wszystkie węzły jako nieodwiedzone
  odwiedzone = [[False for ix in range(x)] for iy in range(y)]

  # ustawić jeden z węzłów jako startowy (tutaj węzeł 0,0 - lewy górny narożnik)
  aktualnyX = 0
  aktualnyY = 0

  # dopóki istnieją nieodwiedzone węzły powtarzamy:
  while czyIstniejąNieodwiedzone(x, y, odwiedzone):
    # ustaw nieodwiedzony węzeł z najniższą wartością jako aktualny
    # ...

    # aktualizacja sąsiadów
    # dla aktualnego węzła sprawdzamy przejścia w każdym z 4 kierunków
    # jeśli wartość przejścia <= 0, ignorujemy
    # jeśli wartość przejścia > 0 obliczamy nowy dystans jako sumę wartości
    # aktualnego węzła i długości sprawdzanego połączenia
    # ustawiamy wartość węzła w danym kierunku na mniejszą z wartości
    # ...


    # zaznaczenie aktualnego węzła jako odwiedzonego
    # ...

    rysujGraf(x, y, graf)
    time.sleep(1)
"
QAFYha4A,Masha123,aphex0990,Lua,Thursday 15th of May 2025 12:28:40 AM CDT,"mon=peripheral.wrap(""right"")
oldterm = term.redirect(mon)
while true do
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint1"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint2"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint3"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint4"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint5"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint6"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint7"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint8"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint9"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint10"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint11"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint12"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint13"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint14"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint15"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint16"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint17"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint18"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint19"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint20"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint21"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint22"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint23"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint24"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint25"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint26"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint27"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint28"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint29"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint30"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint31"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint32"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint33"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint34"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
    
term.setBackgroundColor(colors.black)
term.clear()
img=paintutils.loadImage(""paint35"")
paintutils.drawImage(img,1,1)
os.sleep(0.5)
end



















"
6kWeVahv,Code Signed Data,mrafiulwap,PHP,Wednesday 14th of May 2025 11:32:35 PM CDT,"<?php

private function strToHex($string){
        $hex = '';
        for ($i=0; $i<strlen($string); $i++){
            $ord = ord($string[$i]);
            $hexCode = dechex($ord);
            $hex .= substr('0'.$hexCode, -2);
        }
        return strToUpper($hex);
    }

private function signedData($productDescription, $transactionAmount, $exchangeOrderNo, $merchantOrderNo, $transactionCurrency, $emailAddress, $merchantId) 
    {

        $transactionAmount = number_format($transactionAmount/100, 2);

        $raw_data = $productDescription.'|'
        .$transactionAmount.'|'
        .$exchangeOrderNo.'|'
        .$merchantOrderNo.'|'
        .$transactionCurrency.'|'
        .$emailAddress.'|'
        .$merchantId;

        $data = $raw_data;

        $file_name = storage_path('m1paykey/91198457.key');

        $signature = '';

        try {
                $myfile = fopen($file_name, ""r"") or die(""Unable to open file!"");
                $priv_key = fread($myfile,filesize($file_name));
                fclose($myfile);
                $pkeyid = openssl_get_privatekey($priv_key);
                openssl_sign($data, $signature, $pkeyid, ""sha1WithRSAEncryption"");
                $signature = $this->strToHex($signature);
            } catch (Exception $e) {
                echo 'Caught exception: ', $e->getMessage(), ""\n"";
        	}

            return $signature;
    }"
uCZjS5Cx,2025-05-15T08:53:07.360248,powerampache,PHP,Wednesday 14th of May 2025 10:53:08 PM CDT,"1.01-80 (80) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
r5Df9X9f,MainScript with 2 Votes (2 Endings),Sungmingamerpro13,CSS,Wednesday 14th of May 2025 10:48:11 PM CDT,"local VotingValues = game.ReplicatedStorage.VotingValues
local votes = {VotingValues.Good, VotingValues.Bad}

function VotingSystem(Time)
	VotingValues.VotingOn.Value = true
	for i = Time,0,-1 do
		VotingValues.VotingStatus.Value = i.."" Seconds Left To Choose!""
		wait(1)
	end
	VotingValues.VotingOn.Value = false
end

wait(5)

VotingSystem(15)

table.sort(votes, function(A, B)
	return A.Value > B.Value
end)
local chosen = votes[1].Name
if chosen == ""Good"" then
	print(""Good Ending!"")
elseif chosen == ""Bad"" then
	print(""Bad Ending!"")
end
"
KRRxVgqs,VoteServer (Script),Sungmingamerpro13,CSS,Wednesday 14th of May 2025 10:46:55 PM CDT,"local VotingValues = game.ReplicatedStorage.VotingValues

VotingValues.VoteEvent.OnServerEvent:Connect(function(player, previous, chosen)
	local votes = VotingValues[chosen]
	votes.Value = votes.Value + 1
	if previous ~= nil then
		local prev = VotingValues[previous]
		prev.Value = prev.Value - 1
	end
end)
"
1gXjrPjV,VotingSystem with 2 Votes (LocalScript),Sungmingamerpro13,CSS,Wednesday 14th of May 2025 10:45:13 PM CDT,"local VotingValues = game.ReplicatedStorage.VotingValues
local chosen

local VotingFrame = script.Parent

local function Vote(chosen, Ending)
	VotingValues.VoteEvent:FireServer(chosen, Ending)
end

VotingFrame.Good.MouseButton1Click:Connect(function()
	if chosen ~= ""Good"" then
		Vote(chosen, ""Good"")
		chosen = ""Good""
	end
end)

VotingFrame.Bad.MouseButton1Click:Connect(function()
	if chosen ~= ""Bad"" then
		Vote(chosen, ""Bad"")
		chosen = ""Bad""
	end
end)

while wait() do
	VotingFrame.Visible = VotingValues.VotingOn.Value
	VotingFrame.statusLabel.Text = VotingValues.VotingStatus.Value
	VotingFrame.Good.Votes.Text = VotingValues.Good.Value
	VotingFrame.Bad.Votes.Text = VotingValues.Bad.Value
end
"
wX0w3PnJ,trace file on error_log,arie_cristianD,PHP,Wednesday 14th of May 2025 10:38:43 PM CDT,"function jnews_trace_log() {
	$backtrance = debug_backtrace();

	$logs = array();
	if ( is_array( $backtrance ) ) {
		foreach ( $backtrance as $log ) {
			$logs[] = $log['file'] . ':' . $log['line'];
		}
	}
	error_log( print_r( $logs, true ) );
}"
965retSP,"[🔥NEW] Bubble Gum Simulator INFINITY Script - Nousigi Hub | Auto Rift, Minigames, Smart Auto Dice!",Luka_EW,Lua,Wednesday 14th of May 2025 10:05:05 PM CDT,"loadstring(game:HttpGet(""https://raw.githubusercontent.com/NLLWA9/bgsi-scripts/refs/heads/main/Protected_2056069085651618.lua""))()"
EC1ZKbQD,AllowedIds,KatzenWau,JSON,Wednesday 14th of May 2025 09:19:54 PM CDT,"[7520699448, 7615323177, 7427967078, 7437165919]"
CC18N18E,Division_without_remainder,zyulfi,Python,Wednesday 14th of May 2025 08:55:07 PM CDT,"# 7. Деление без остатък
# Въведете две цели числа.
# Ако първото се дели на второто без остатък, отпечатайте ""Дели се"". Иначе – ""Не се дели"".

num_one = int(input(""Моля, въведете цяло число: ""))
num_second = int(input(""Моля, въведете цяло число: ""))

if num_one % num_second == 0:
    print(""Първото число се дели на второто"")
else:
    print(""Първото число не се дели на второто"")"
ZBmUUqFC,A_number_in_an_interval,zyulfi,Python,Wednesday 14th of May 2025 08:46:25 PM CDT,"# 6. Число в интервал
# Въведете цяло число. Проверете дали то е в интервала [10, 50] включително.
# Отпечатайте:
    # ""В интервала""
    # ""Извън интервала""

num = int(input(""Моля, въведете цяло число: ""))

if 10 <= num <= 50:
    print(""Числото е в интервала [10, 50]"")
else:
    print(""Числото не е в интервала [10, 50]"")"
PM5LUqAX,Passw,zyulfi,Python,Wednesday 14th of May 2025 08:36:53 PM CDT,"# 5. Парола за достъп
# Програмата изисква от потребителя да въведе парола.
# Ако тя е ""python123"", отпечатайте ""Достъп разрешен"". В противен случай – ""Грешна парола"".

password = input(""Моля, въведете парола: "")

if password == ""python123"":
    print(""Достъп разрешен"")
else:
    print(""Грешна парола"")"
d2WLh8dt,Temperature_advisor,zyulfi,Python,Wednesday 14th of May 2025 08:29:36 PM CDT,"# 4.Температурен съветник
# Въведете температура (цяло число):
    # Под 0 → ""Много студено""
    # От 0 до 20 → ""Хладно""
    # Над 20 до 35 → ""Топло""
    # Над 35 → ""Горещо!""

temperature = int(input(""Моля, въведете цяло число за температура: ""))

if temperature < 0:
    print(""Много студено!"")
elif temperature <= 20:
    print(""Хладно!"")
elif temperature <= 35:
    print(""Топло!"")
else:
    print(""Горещо!"")"
CPP73Ai4,Start Stop DB System (startStopDbSystemArgs.py),dominusceo,Python,Wednesday 14th of May 2025 08:06:05 PM CDT,"#! /usr/bin/python
""""""
Autor: Ricardo Carrillo - ricardo.d.carrillo@oracle.com
Objetivo:   Iniciar o Parar (start/stop) un dbsystem basado en un 'instance principal' sin la necesidad de configurar OCI-Cli
Ejemplo de ejecucion: 
     ./startStopDbSystemArgs.py  --action start --compartment_id  ocid1.compartment.oc1..aaaaaaaa5nflauus2d7wcdir5bk4nh7d6ts4xcox3ndutsm6icccjaryq --delay 10
""""""
import oci
import argparse
import time
""""""
# Cambiar por instance principal
signer = oci.auth.signers.InstancePrincipalsSecurityTokenSigner()
database_client = oci.database.DatabaseClient(config={}, signer=signer)
Allow dynamic-group Default/dbsystem-admin-group to manage database-family in compartment compartment-name
Allow dynamic-group Default/dbsystem-admin-group to use virtual-network-family in compartment compartment-name
ALL { instance.compartment.id = 'ocid1.compartment.oc1...yourcompartmentocid' }
""""""

# Configurar los argumentos para el script
parser = argparse.ArgumentParser()
parser.add_argument('--action', choices=['start', 'stop'], required=True, help=""Acción a realizar: start o stop"")
parser.add_argument('--compartment_id', required=True, help=""OCID del compartimento"")
parser.add_argument('--delay', type=int, default=5, help=""Delay de default entre acciones sobre cada nodo de DB System (opcional)"")
args = parser.parse_args()
action = args.action.upper()
# Obtener los DB Systems del compartimento especificado
db_systems = database_client.list_db_systems(compartment_id=args.compartment_id).data
# Iterar sobre los DB Systems
for db_system in db_systems:
    if db_system.lifecycle_state != ""AVAILABLE"":
        print(f""Saltando DB System {db_system.display_name} (estado: {db_system.lifecycle_state})"")
        continue
    if db_system.lifecycle_state == ""AVAILABLE"":
        print(f""Procesando DB System: {db_system.display_name}"")
        db_nodes = database_client.list_db_nodes(compartment_id=args.compartment_id,db_system_id=db_system.id).data
        for db_node in db_nodes:
            if action == ""START"" and db_node.lifecycle_state == ""STOPPED"":
                print(f"" -- Encendiendo DB Node {args.action}: {db_node.hostname}"")
                try:
                    response = database_client.db_node_action(db_node_id=db_node.id,action=""START"")
                    print(f"" +DB Node {db_node.hostname} encendido correctamente."")
                    time.sleep(args.delay)
                except oci.exceptions.ServiceError as e:
                    print(f"" *Error al ejecutar acción en DB Node {db_node.id}: {e.message}"")

            elif action == ""STOP"" and db_node.lifecycle_state == ""RUNNING"":
                print(f"" -- Apagando DB Node {args.action}: {db_node.hostname}"")
                try:
                    response = database_client.db_node_action(db_node_id=db_node.id,action=""STOP"")
                    print(f"" +DB Node {db_node.hostname} apagado correctamente."")
                    time.sleep(args.delay)
                except oci.exceptions.ServiceError as e:
                    print(f"" *Error al apagar DB Node {db_node.hostname}: {e.message}"")
            elif action == ""START"" and db_node.lifecycle_state == ""RUNNING"":
                print(f""    -- DB System {db_system.display_name} encendido"")
            elif action == ""STOP"" and db_node.lifecycle_state == ""AVAILABLE"":
                try:
                    response = database_client.db_node_action(db_node_id=db_node.id,action=""STOP"")
                    print(f"" +DB Node {db_node.hostname} apagado correctamente."")
                    time.sleep(args.delay)
                except oci.exceptions.ServiceError as e:
                    print(f"" *Error al apagar DB Node {db_node.hostname}: {e.message}"")
            else:
                print(f""    Nada que hacer con {db_node.hostname} - {db_node.lifecycle_state}"")"
FcsqX7mL,Comparison,zyulfi,Python,Wednesday 14th of May 2025 07:58:36 PM CDT,"# 3.Сравнение на две числа
# Въведете две цели числа. Отпечатайте:
    # ""Първото е по-голямо""
    # ""Второто е по-голямо""
    # ""Равни са""

num_one = int(input(""Моля, въведете първото число: ""))
num_second = int(input(""Моля, въведете второто число: ""))

if num_one > num_second:
    print(""Първото число е по-голямо от второто."")
elif num_second > num_one:
    print(""Второто число е по-голямо от първото."")
else:
    print(""Числата са равни."")"
55TQKmd2,Adulthood,zyulfi,Python,Wednesday 14th of May 2025 07:42:04 PM CDT,"# 2. Пълнолетие
# Напишете програма, която приема възраст и отпечатва:
#   ""Пълнолетен"", ако е 18 или повече
#   ""Непълнолетен"", ако е под 18

age = int(input(""Моля, въведете възраст на лицето: ""))

if age <= 0:
    print(""Възрастта не може да е по-малка или равна на 0."")
elif age < 18:
    print(""Лицето е непълнолетно."")
else:
    print(""Лицето е пълнолетно."")
"
NR4qFZ2D,fdsgdfh,miglss,C++,Wednesday 14th of May 2025 06:02:48 PM CDT,"void FunctionName_1(char * &data);

void FunctionName_2()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    FunctionName_1(data);
    {
        HMODULE hModule;
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
"
AuXL6tTh,Complete JavaScript training from A to Z (through practice),f0f077,JavaScript,Wednesday 14th of May 2025 05:58:42 PM CDT,"Complete JavaScript training from A to Z (through practice)
Learn JavaScript from the basics and progress to popular frameworks Angular, Vue & React
What you will learn
Discover the basics of JavaScript
Master important JavaScript concepts (types, objects, functions, syntax, etc.)
Understanding and manipulating JavaScript in the browser
Mastering Ajax and RESTFul Services
Manipulating page content with JavaScript
Know how to animate the graphic aspect with JavaScript
for more:https://linkrex.net/T7XbJjYzyk"
fPcrZHZj,fdgdfgdf,miglss,C++,Wednesday 14th of May 2025 05:54:41 PM CDT,"#ifndef OMITBAD

/* bad function declaration */
void badSource(char * &data);

void bad()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    badSource(data);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}

#endif /* OMITBAD */
"
Y1vDAZU0,20 JavaScript Projects,f0f077,JavaScript,Wednesday 14th of May 2025 05:52:43 PM CDT,"20 JavaScript Projects
Improve your JavaScript skills.
What you will learn
The JavaScript language
Using APIs
Do really fun and educational projects
Use loops, conditions
for more:https://linkrex.net/UYlpaRl"
k7qj1rCb,Minas,ThegeekKnight16,C++,Wednesday 14th of May 2025 05:47:46 PM CDT,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""Ofast"")

void dfs(int v, vector<int> &marc, const vector<vector<pair<int, int>>> &grafo, int &qnt, int x)
{
    marc[v] = 1; --qnt;
    for (auto [viz, e] : grafo[v]) if (!marc[viz] && e != x) dfs(viz, marc, grafo, qnt, x);
}

void getMatters(int v, vector<int> &marc, const vector<vector<pair<int, int>>> &grafo, vector<int> &matters)
{
    marc[v] = 1;
    for (auto [viz, e] : grafo[v]) if (!marc[viz]) {matters[e] = 1; getMatters(viz, marc, grafo, matters);}
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    int N, M; cin >> N >> M;
    array<vector<vector<pair<int, int>>>, 2> grafo; grafo[0].resize(N+1); grafo[1].resize(N+1); 
    vector<pair<int, int>> edges(M);
    for (int i = 0; i < M; i++) {auto &[x, y] = edges[i]; cin >> x >> y; grafo[0][x].emplace_back(y, i); grafo[1][y].emplace_back(x, i);}
    vector<int> matters(M), marc(N+1);
    getMatters(1, marc, grafo[0], matters); 
    fill(marc.begin(), marc.end(), 0);
    getMatters(1, marc, grafo[1], matters);

    vector<pair<int, int>> resp; resp.reserve(M);
    for (int i = 0; i < M; i++)
    {
        if (!matters[i]) continue;
        auto [x, y] = edges[i];
        vector<int> marc0(N+1, 0), marc1(N+1, 0); int qnt0 = N, qnt1 = N;
        dfs(1, marc0, grafo[0], qnt0, i); dfs(1, marc1, grafo[1], qnt1, i);
        if (qnt0 || qnt1) resp.emplace_back(x, y);
    }

    cout << resp.size() << '\n';
    for (auto [x, y] : resp) cout << x << "" "" << y << '\n';
}"
qZF21Gi7,Untitled,m1st4k3nnn,Lua,Wednesday 14th of May 2025 04:43:04 PM CDT,"-- Load the KR4K UI Library
local Library = loadstring(game:HttpGet(""https://pastebin.com/raw/AWhnUtQd""))()
local Window = Library.Window('KR4K Example')

-- Tabs
local RemoteTab = Window.CreateTab('Remote')
local MasteryTab = Window.CreateTab('Mastery')
local PlaytimeTab = Window.CreateTab('Playtime')
local FlavorTab = Window.CreateTab('Flavors')
local StorageTab = Window.CreateTab('Storage')
local FarmTab = Window.CreateTab('Farm')
local EggTab = Window.CreateTab('Eggs')

-- Script version label
local SCRIPT_VERSION = ""Script Version: 1.0.0""
print(SCRIPT_VERSION)
-- Variables to keep track of toggles
local sellBubbleEnabled = false
local blowBubbleEnabled = false
local autoBuyFlavorsEnabled = false
local autoBuyStorageEnabled = false
local autoPlaytimeEnabled = false
local farmEnabled = false
local autoHatchEnabled = false

-- Remote references
local RemoteEvent = game:GetService(""ReplicatedStorage"").Shared.Framework.Network.Remote.RemoteEvent
local RemoteFunction = game:GetService(""ReplicatedStorage"").Shared.Framework.Network.Remote.RemoteFunction

-- Helper: Move character to a position at a constant speed
local speed = 5 -- studs per second

local function moveTo(position, speed)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local root = character:FindFirstChild(""HumanoidRootPart"")
    if not root then
        warn(""HumanoidRootPart not found!"")
        return
    end
    local distance = (root.Position - position).Magnitude
    local duration = distance / speed
    local startTime = tick()
    local startPos = root.Position
    while tick() - startTime < duration do
        local alpha = (tick() - startTime) / duration
        root.CFrame = CFrame.new(startPos:Lerp(position, alpha))
        task.wait()
    end
    root.CFrame = CFrame.new(position)
end

-- Fix: Add unlockIslands function
local function unlockIslands(worldName, islandNames)
    local worldsFolder = workspace:FindFirstChild(""Worlds"")
    if not worldsFolder then
        warn(""Worlds folder not found in workspace!"")
        return
    end
    local world = worldsFolder:FindFirstChild(worldName)
    if not world then
        warn(""World not found:"", worldName)
        return
    end
    local islandsFolder = world:FindFirstChild(""Islands"")
    if not islandsFolder then
        warn(""Islands folder not found in"", worldName)
        return
    end

    local islands = {}
    for _, islandName in ipairs(islandNames) do
        local island = islandsFolder:FindFirstChild(islandName)
        if island and island:FindFirstChild(""Island"") and island.Island:FindFirstChild(""UnlockHitbox"") then
            local hitbox = island.Island.UnlockHitbox
            table.insert(islands, {name = islandName, part = hitbox, y = hitbox.Position.Y})
        end
    end

    table.sort(islands, function(a, b)
        return a.y < b.y
    end)

    for _, data in ipairs(islands) do
        moveTo(data.part.Position + Vector3.new(0, 5, 0), speed)
        wait(0.5)
    end
end

-- Remote Tab
RemoteTab.CreateLabel(SCRIPT_VERSION)
RemoteTab.CreateDivider(""Unlock Worlds"")
RemoteTab.CreateButton(""Unlock The Overworld Islands"", function()
    unlockIslands(""The Overworld"", {
        ""Floating Island"", ""Outer Space"", ""The Void"", ""Twilight"", ""Zen""
    })
end)
RemoteTab.CreateButton(""Unlock Minigame Paradise Islands"", function()
    unlockIslands(""Minigame Paradise"", {
        ""Dice Island"", ""Minecart Forest"", ""Robot Factory""
    })
end)

RemoteTab.CreateDivider(""Bubble Automation"")
RemoteTab.CreateToggle(""Auto Sell Bubble (10s)"", function(state)
    sellBubbleEnabled = state
    if state then
        spawn(function()
            while sellBubbleEnabled do
                RemoteEvent:FireServer(""SellBubble"")
                wait(10)
            end
        end)
    end
end)
RemoteTab.CreateToggle(""Auto Blow Bubble (0.5s)"", function(state)
    blowBubbleEnabled = state
    if state then
        spawn(function()
            while blowBubbleEnabled do
                RemoteEvent:FireServer(""BlowBubble"")
                wait(0.5)
            end
        end)
    end
end)

RemoteTab.CreateDivider(""Wheel"")
RemoteTab.CreateButton(""Claim Free Wheel Spin"", function()
    RemoteEvent:FireServer(""ClaimFreeWheelSpin"")
end)
RemoteTab.CreateButton(""Spin The Wheel"", function()
    RemoteFunction:InvokeServer(""WheelSpin"")
end)

RemoteTab.CreateDivider(""Other"")
RemoteTab.CreateButton(""Delete GUI & Stop"", function()
    sellBubbleEnabled = false
    blowBubbleEnabled = false
    autoBuyFlavorsEnabled = false
    autoBuyStorageEnabled = false
    autoPlaytimeEnabled = false
    farmEnabled = false
    autoHatchEnabled = false
    Library:Destroy()
end)

-- Mastery Tab
MasteryTab.CreateDivider(""Mastery Upgrades"")
MasteryTab.CreateButton(""Upgrade Pets"", function()
    RemoteEvent:FireServer(""UpgradeMastery"", ""Pets"")
end)
MasteryTab.CreateButton(""Upgrade Buffs"", function()
    RemoteEvent:FireServer(""UpgradeMastery"", ""Buffs"")
end)
MasteryTab.CreateButton(""Upgrade Shops"", function()
    RemoteEvent:FireServer(""UpgradeMastery"", ""Shops"")
end)
MasteryTab.CreateButton(""Upgrade Minigames"", function()
    RemoteEvent:FireServer(""UpgradeMastery"", ""Minigames"")
end)

-- Playtime Tab
PlaytimeTab.CreateDivider(""Playtime Rewards"")
PlaytimeTab.CreateToggle(""Auto Claim Playtime (1-9)"", function(state)
    autoPlaytimeEnabled = state
    if state then
        spawn(function()
            while autoPlaytimeEnabled do
                for i = 1, 9 do
                    if not autoPlaytimeEnabled then break end
                    RemoteFunction:InvokeServer(""ClaimPlaytime"", i)
                    wait(0.5)
                end
                wait(10)
            end
        end)
    end
end)

-- Flavors Tab
local flavors = {
    ""Bubble Gum"", ""Blueberry"", ""Cherry"", ""Pizza"", ""Watermelon"", ""Chocolate"",
    ""Contrast"", ""Gold"", ""Lemon"", ""Donut"", ""Swirl"", ""Molten"", ""Abstract""
}
local selectedFlavor = flavors[1]

FlavorTab.CreateDivider(""Flavors"")
FlavorTab.CreateToggle(""Auto Buy Flavors (Every 3s)"", function(state)
    autoBuyFlavorsEnabled = state
    if state then
        spawn(function()
            while autoBuyFlavorsEnabled do
                for _, flavor in ipairs(flavors) do
                    if not autoBuyFlavorsEnabled then break end
                    RemoteEvent:FireServer(""GumShopPurchase"", flavor)
                    wait(0.5)
                end
                wait(3)
            end
        end)
    end
end)
FlavorTab.CreateDropdown(""Select Flavor"", flavors, function(selected)
    selectedFlavor = selected
end)
FlavorTab.CreateButton(""Buy Selected Flavor"", function()
    RemoteEvent:FireServer(""GumShopPurchase"", selectedFlavor)
end)

-- Storage Tab
local storageList = {
    ""Basic Gum"", ""Stretchy Gum"", ""Chewy Gum"", ""Epic Gum"", ""Ultra Gum"", ""Omega Gum"",
    ""XL Gum"", ""Mega Gum"", ""Cosmic Gum"", ""Quantum Gum"", ""Alien Gum"", ""Radioactive Gum"",
    ""Experiment #52"", ""Void Gum"", ""Robogum""
}

StorageTab.CreateDivider(""Storage Upgrades"")
StorageTab.CreateToggle(""Auto Buy Storage (Every 5s)"", function(state)
    autoBuyStorageEnabled = state
    if state then
        spawn(function()
            while autoBuyStorageEnabled do
                for _, storage in ipairs(storageList) do
                    if not autoBuyStorageEnabled then break end
                    RemoteEvent:FireServer(""GumShopPurchase"", storage)
                    wait(0.5)
                end
                wait(5)
            end
        end)
    end
end)
StorageTab.CreateButton(""Buy All Storage Upgrades"", function()
    for _, storage in ipairs(storageList) do
        RemoteEvent:FireServer(""GumShopPurchase"", storage)
        wait(0.2)
    end
end)

-- Farm Tab
FarmTab.CreateDivider(""Coin Farming"")
FarmTab.CreateToggle(""Auto Farm Closest Coin"", function(state)
    farmEnabled = state
    if state then
        spawn(function()
            while farmEnabled do
                local rendered = workspace:FindFirstChild(""Rendered"")
                if rendered then
                    local pickupsFolder = rendered:GetChildren()[13]
                    if pickupsFolder then
                        local coins = {}
                        for _, pickup in ipairs(pickupsFolder:GetChildren()) do
                            if pickup:IsA(""Model"") then
                                for _, part in ipairs(pickup:GetDescendants()) do
                                    if part:IsA(""BasePart"") then
                                        table.insert(coins, {model = pickup, part = part})
                                        break
                                    end
                                end
                            end
                        end
                        local player = game.Players.LocalPlayer
                        local character = player.Character or player.CharacterAdded:Wait()
                        local root = character:FindFirstChild(""HumanoidRootPart"")
                        while #coins > 0 and farmEnabled do
                            local closestIndex, closestDist = nil, math.huge
                            for i, coin in ipairs(coins) do
                                local dist = (root.Position - (coin.part.Position + Vector3.new(0, 5, 0))).Magnitude
                                if dist < closestDist then
                                    closestDist = dist
                                    closestIndex = i
                                end
                            end
                            if closestIndex then
                                local coin = coins[closestIndex]
                                local targetPos = coin.part.Position + Vector3.new(0, 5, 0)
                                moveTo(targetPos, speed)
                                table.remove(coins, closestIndex)
                                wait(0.2)
                            end
                        end
                    end
                end
                wait(2)
            end
        end)
    end
end)
FarmTab.CreateButton(""Farm All Coins Closest Order Once"", function()
    local rendered = workspace:FindFirstChild(""Rendered"")
    if rendered then
        local pickupsFolder = rendered:GetChildren()[13]
        if pickupsFolder then
            local coins = {}
            for _, pickup in ipairs(pickupsFolder:GetChildren()) do
                if pickup:IsA(""Model"") then
                    for _, part in ipairs(pickup:GetDescendants()) do
                        if part:IsA(""BasePart"") then
                            table.insert(coins, {model = pickup, part = part})
                            break
                        end
                    end
                end
            end
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local root = character:FindFirstChild(""HumanoidRootPart"")
            while #coins > 0 do
                local closestIndex, closestDist = nil, math.huge
                for i, coin in ipairs(coins) do
                    local dist = (root.Position - (coin.part.Position + Vector3.new(0, 5, 0))).Magnitude
                    if dist < closestDist then
                        closestDist = dist
                        closestIndex = i
                    end
                end
                if closestIndex then
                    local coin = coins[closestIndex]
                    local targetPos = coin.part.Position + Vector3.new(0, 5, 0)
                    moveTo(targetPos, speed)
                    table.remove(coins, closestIndex)
                    wait(0.2)
                end
            end
        end
    end
end)

-- Eggs Tab
local overworldEggs = {
    ""Common Egg"", ""Spotted Egg"", ""Iceshard Egg"", ""Spikey Egg"", ""Magma Egg"",
    ""Crystal Egg"", ""Lunar Egg"", ""Void Egg"", ""Hell Egg"", ""Nightmare Egg"", ""Rainbow Egg""
}
local minigameEggs = {
    ""Snowman Egg"", ""Mining Egg"", ""Cyber Egg"", ""Underworld Egg""
}
local selectedOverworldEgg = overworldEggs[1]
local selectedMinigameEgg = minigameEggs[1]
local selectedWorld = ""The Overworld""

EggTab.CreateDivider(""Auto Egg Hatching"")
EggTab.CreateDropdown(""Select World"", {""The Overworld"", ""Minigame Paradise""}, function(world)
    selectedWorld = world
end)
EggTab.CreateDropdown(""Overworld Egg"", overworldEggs, function(selected)
    selectedOverworldEgg = selected
end)
EggTab.CreateDropdown(""Minigame Paradise Egg"", minigameEggs, function(selected)
    selectedMinigameEgg = selected
end)
EggTab.CreateToggle(""Start Hatching"", function(state)
    autoHatchEnabled = state
    if state then
        spawn(function()
            while autoHatchEnabled do
                local eggName
                if selectedWorld == ""The Overworld"" then
                    eggName = selectedOverworldEgg
                else
                    eggName = selectedMinigameEgg
                end
                RemoteEvent:FireServer(""HatchEgg"", eggName, 1)
                wait(1)
            end
        end)
    end
end)
"
c2nxLVLr,Ideas Needed!,NewBestPastebins,JavaScript,Wednesday 14th of May 2025 04:40:44 PM CDT,"Please comment some ideas for a fun script I could make, that would be nice for you to have. It can be as troll and weird as you want."
