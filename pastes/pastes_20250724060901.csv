id,title,username,language,date,content
d6t2vxVu,Atl,bastyav,HTML,Thursday 24th of July 2025 12:05:09 AM CDT,"net use k: /delete
net use k: \\scrnatl01fil01.scrn.fadv.net\clientservices
net use f: /delete
net use f: \\SCRNATL01FIL01.SCRN.FADV.NET\Winesp_documents
net use l: /delete
net use l: \\NOAM.FADV.NET\DFSRoot\ESS\Screening\DeptData\Premier_Leadership
net use p: \\NOAM.FADV.NET\DFSRoot\ESS\Screening\DeptData\Premier_Support
net use s: \\scrnatl01fil01.scrn.fadv.net\Softwares
net use Z: /delete
net use Z: \\scrnatl01fil03.scrn.fadv.net\HomeFolders\ATL\%username%

c:\Windows\explorer.exe /n,/e,::{20D04FE0-3AEA-1069-A2D8-08002B30309D}"
4Uy5zAVv,Trainyard 1.7,Talonsfold,Lua,Wednesday 23rd of July 2025 10:53:43 PM CDT,"--*******************************************************************
--*Notes:
--*
--*
--*
--*
--*
--*
--*
--*

--****************
--*Initializing  *
--****************


--Variables Setup
cvar = 0 -- used for counting
numlanes = 7 -- used as a sanity check when rolling though the lanes
lanecolors = {} -- stores lane color info
lanestat = {} -- stores lane status 
lanedock = {} -- stores if the train in that lane is in the unload area or ready to release
lanelocked = {} -- stores if a lane is manually shutdown
lanescreen = {} -- stores the monitor list for the lane displays
yardscram = 0 -- stores state for emergency shutdown process
exitlane = 0 -- stores which lane is good to be released.
traincount = 0 -- train count since last computer reset
id=0 -- not implemented yet
countmessage=0 -- not implemented yet
tempmonitor=""""

--  values assigned to each color transferred to a linked variable for easy access
-- entrylanecolors = colors.black 
lanecolors[1] = colors.white
lanecolors[2] = colors.orange
lanecolors[3] = colors.magenta
lanecolors[4] = colors.lightBlue
lanecolors[5] = colors.yellow
lanecolors[6] = colors.lime
lanecolors[7] = colors.pink
exitlanecolor = colors.black
traincountercolor = colors.red
laneclearcolor = colors.green
laneunloadingcolor = colors.orange
lanewaitingcolor = colors.yellow
lanelockedcolor = colors.red
lockedlanesx1 = {2,24,44,64,84,104,124} --workaround for floating point glitch on locked lane monitors 
lockedlanesx2 = {22,42,62,82,102,122,142} --workaround for floating point glitch on locked lane monitors 


--Monitor setup
local original_terminal = term.current()

--main display
local monitor = peripheral.wrap(""monitor_11"")
term.redirect(monitor)
monitor.clear()
monitor.setTextScale(1)

--Locked lane display
local monitor2 = peripheral.wrap(""monitor_10"")
monitor2.clear()
monitor2.setTextScale(.5)

--lane displays
lanescreen[1] = peripheral.wrap(""monitor_3"")
lanescreen[2] = peripheral.wrap(""monitor_4"")
lanescreen[3] = peripheral.wrap(""monitor_5"")
lanescreen[4] = peripheral.wrap(""monitor_6"")
lanescreen[5] = peripheral.wrap(""monitor_7"")
lanescreen[6] = peripheral.wrap(""monitor_2"")
lanescreen[7] = peripheral.wrap(""monitor_8"")



m1x, m1y = monitor.getSize() --screen size grab for automated sizing
lsx, lsy = lanescreen[1].getSize() --screen size grab for automated sizing

--m2x, m2y = monitor2.getSize() --disabled/not used due to floating point bug




--******************************************************************************************
--*Functions - are defined in the beginning and can be called from within the main loop    *
--******************************************************************************************

function scanlanes() --process lanes and assign status to variables.
	for cvar = 1,numlanes,1 do -- uses a counter to roll through each lane and check for the status. The status is then assigned to a variable for storage
		if rs.testBundledInput(""left"", lanecolors[cvar]) == true then lanestat[cvar] = false else lanestat[cvar] = true end	 -- check for occupied lanes
		if rs.testBundledInput(""bottom"", lanecolors[cvar]) == true then lanedock[cvar] = false else lanedock[cvar] = true end -- see if occupied train is in unloading or exit sections
		if rs.testBundledInput(""back"", lanecolors[cvar]) == true then lanelocked[cvar] = true else lanelocked[cvar] = false end -- check to see if any lanes have been manually locked out
	end
end

function release(releaselane) --process the release on the current selected exit lane. (also updates status displays
	term.setTextColor(colors.white)
	monitordraw(monitor, 2,6+((releaselane-1)*3),70,6+((releaselane-1)*3)+1,colors.blue, 5, 7+((releaselane-1)*3), ""Lane: "" .. releaselane .. "" Released"")
	rs.setBundledOutput(""right"", lanecolors[releaselane]) --sets the output to release a lane
	sleep(3) --delay to allow time for train to move into exit lane
	rs.setBundledOutput(""right"", 0) -- reset release
end

function monitordraw (display, x1, y1, x2, y2, lanecolor, textx, texty, lanetext)
	term.redirect(display)
	paintutils.drawFilledBox(x1,y1,x2,y2,lanecolor)
	monitor.setTextColor(colors.black)
	monitor.setCursorPos(textx, texty)
	print(lanetext)				
	monitor.setBackgroundColor(colors.black)
	term.redirect(monitor)
end


function drawupdate()
	monitor.clear()
	paintutils.drawFilledBox(1,1,110,5,colors.blue)
	paintutils.drawFilledBox(3,3,27,4,colors.black)
	paintutils.drawFilledBox(33,3,55,4,colors.black)
	term.setCursorPos(3,3)
	monitor.setTextColor(colors.white)
	print(""Train Station Monitoring"")
	monitor.setTextColor(colors.white)
	monitor.setCursorPos(33,3)
	print(""Trains Since Reset: "" .. traincount)

	--Draw Main Monitor lanes
	for j=1,numlanes,1 do
		if lanelocked[j] == true then
			monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,lanelockedcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Locked down"")
		else
			if lanestat[j] == true then
				if lanedock[j] == true then
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,laneunloadingcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Unloading"")
				else
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,lanewaitingcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Waiting for Release"")				end
			else
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,laneclearcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Vacant"")				end
			end
		end	
	-- Draw Lane Lock displays
	term.redirect(monitor2)
	term.setBackgroundColor(colors.black)
	term.clear()
	for j = 1,numlanes,1 do
		if lanelocked[j] == true then
			--monitordraw(monitor2,lockedlanesx1[j],1,lockedlanesx2[j],10,colors.red, lockedlanesx1[j]+2,5, ""Lane: "".. j.. "" Locked"") 
			paintutils.drawFilledBox(lockedlanesx1[j],1,lockedlanesx2[j],10,colors.red) 
			monitor2.setTextColor(colors.white)
			monitor2.setCursorPos(lockedlanesx1[j]+2,5)
			print(""Lane"".. j.. "": Locked"")
		else
			--monitordraw(monitor2,lockedlanesx1[j],1,lockedlanesx2[j],9,colors.greeb, lockedlanesx1[j]+2,5, ""Lane: "".. j.. "" Open"")
			paintutils.drawFilledBox(lockedlanesx1[j],1,lockedlanesx2[j],10,colors.green) 
			monitor2.setTextColor(colors.white)
			monitor2.setCursorPos(lockedlanesx1[j]+2,5)
			print(""Lane"".. j.. "": Open"")
		end
	end


	-- draw lanesigns
	
	for j = 1, numlanes, 1 do
		term.redirect(lanescreen[j])

		if lanelocked[j] == true then
			term.setBackgroundColor(lanelockedcolor)
			term.clear()
			term.setCursorPos(2,5)
			print(""Lane "".. j)
		else
			if lanestat[j] == true then
				if lanedock[j] == true then
					term.setBackgroundColor(laneunloadingcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
				else
					term.setBackgroundColor(lanewaitingcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
				end
			else
					term.setBackgroundColor(laneclearcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
			end
			end
		end	

	
	term.redirect(monitor)
end

function counterincrement()
	traincount=traincount+1
	while (rs.testBundledInput(""bottom"",traincountercolor)) do
	sleep(.1)
	end
end

--****************
--*Main Loop     *
--****************

while(true) do
	scanlanes() -- check to see what lanes are full
	exitlane=exitlane+1
	if rs.testBundledInput(""bottom"",traincountercolor) == true then counterincrement() end
	if exitlane>numlanes then exitlane=1 end
		if rs.testBundledInput(""left"", exitlanecolor) == false then  -- make sure the exit lane is clear.
			if lanestat[exitlane] == true then -- check if there is a train in the current tested lane.
				if lanedock[exitlane] == false then --if there is a lane but it is in the unloading area then skip to the next one
					if lanelocked[exitlane] == false then
						release(exitlane) -- if it meets all conditions then release
					end
			end	
		end	
	end
	drawupdate() -- update display 
	sleep(.3)
end


"
g6fCd95B,trainyard v1.6,Talonsfold,Lua,Wednesday 23rd of July 2025 10:52:29 PM CDT,"--*******************************************************************
--*Notes:
--*
--*
--*
--*
--*
--*
--*
--*

--****************
--*Initializing  *
--****************


--Variables Setup
cvar = 0 -- used for counting
numlanes = 7 -- used as a sanity check when rolling though the lanes
lanecolors = {} -- stores lane color info
lanestat = {} -- stores lane status 
lanedock = {} -- stores if the train in that lane is in the unload area or ready to release
lanelocked = {} -- stores if a lane is manually shutdown
lanescreen = {} -- stores the monitor list for the lane displays
yardscram = 0 -- stores state for emergency shutdown process
exitlane = 0 -- stores which lane is good to be released.
traincount = 395 -- train count since last computer reset
id=0 -- not implemented yet
countmessage=0 -- not implemented yet
tempmonitor=""""

--  values assigned to each color transferred to a linked variable for easy access
-- entrylanecolors = colors.black 
lanecolors[1] = colors.white
lanecolors[2] = colors.orange
lanecolors[3] = colors.magenta
lanecolors[4] = colors.lightBlue
lanecolors[5] = colors.yellow
lanecolors[6] = colors.lime
lanecolors[7] = colors.pink
exitlanecolor = colors.black
traincountercolor = colors.red
laneclearcolor = colors.green
laneunloadingcolor = colors.orange
lanewaitingcolor = colors.yellow
lanelockedcolor = colors.red
lockedlanesx1 = {2,24,44,64,84,104,124} --workaround for floating point glitch on locked lane monitors 
lockedlanesx2 = {22,42,62,82,102,122,142} --workaround for floating point glitch on locked lane monitors 


--Monitor setup
local original_terminal = term.current()

--main display
local monitor = peripheral.wrap(""monitor_11"")
term.redirect(monitor)
monitor.clear()
monitor.setTextScale(1)

--Locked lane display
local monitor2 = peripheral.wrap(""monitor_10"")
monitor2.clear()
monitor2.setTextScale(.5)

--lane displays
lanescreen[1] = peripheral.wrap(""monitor_3"")
lanescreen[2] = peripheral.wrap(""monitor_4"")
lanescreen[3] = peripheral.wrap(""monitor_5"")
lanescreen[4] = peripheral.wrap(""monitor_6"")
lanescreen[5] = peripheral.wrap(""monitor_7"")
lanescreen[6] = peripheral.wrap(""monitor_2"")
lanescreen[7] = peripheral.wrap(""monitor_8"")



m1x, m1y = monitor.getSize() --screen size grab for automated sizing
lsx, lsy = lanescreen[1].getSize() --screen size grab for automated sizing

--m2x, m2y = monitor2.getSize() --disabled/not used due to floating point bug




--******************************************************************************************
--*Functions - are defined in the beginning and can be called from within the main loop    *
--******************************************************************************************

function scanlanes() --process lanes and assign status to variables.
	for cvar = 1,numlanes,1 do -- uses a counter to roll through each lane and check for the status. The status is then assigned to a variable for storage
		if rs.testBundledInput(""left"", lanecolors[cvar]) == true then lanestat[cvar] = false else lanestat[cvar] = true end	 -- check for occupied lanes
		if rs.testBundledInput(""bottom"", lanecolors[cvar]) == true then lanedock[cvar] = false else lanedock[cvar] = true end -- see if occupied train is in unloading or exit sections
		if rs.testBundledInput(""back"", lanecolors[cvar]) == true then lanelocked[cvar] = true else lanelocked[cvar] = false end -- check to see if any lanes have been manually locked out
	end
end

function release(releaselane) --process the release on the current selected exit lane. (also updates status displays
	term.setTextColor(colors.white)
	monitordraw(monitor, 2,6+((releaselane-1)*3),70,6+((releaselane-1)*3)+1,colors.blue, 5, 7+((releaselane-1)*3), ""Lane: "" .. releaselane .. "" Released"")
	rs.setBundledOutput(""right"", lanecolors[releaselane]) --sets the output to release a lane
	sleep(3) --delay to allow time for train to move into exit lane
	rs.setBundledOutput(""right"", 0) -- reset release
end

function monitordraw (display, x1, y1, x2, y2, lanecolor, textx, texty, lanetext)
	term.redirect(display)
	paintutils.drawFilledBox(x1,y1,x2,y2,lanecolor)
	monitor.setTextColor(colors.black)
	monitor.setCursorPos(textx, texty)
	print(lanetext)				
	monitor.setBackgroundColor(colors.black)
	term.redirect(monitor)
end


function drawupdate()
	monitor.clear()
	paintutils.drawFilledBox(1,1,110,5,colors.blue)
	paintutils.drawFilledBox(3,3,27,4,colors.black)
	paintutils.drawFilledBox(33,3,55,4,colors.black)
	term.setCursorPos(3,3)
	monitor.setTextColor(colors.white)
	print(""Train Station Monitoring"")
	monitor.setTextColor(colors.white)
	monitor.setCursorPos(33,3)
	print(""Trains Since Reset: "" .. traincount)

	--Draw Main Monitor lanes
	for j=1,numlanes,1 do
		if lanelocked[j] == true then
			monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,lanelockedcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Locked down"")
		else
			if lanestat[j] == true then
				if lanedock[j] == true then
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,laneunloadingcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Unloading"")
				else
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,lanewaitingcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Waiting for Release"")				end
			else
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,laneclearcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Vacant"")				end
			end
		end	
	-- Draw Lane Lock displays
	term.redirect(monitor2)
	term.setBackgroundColor(colors.black)
	term.clear()
	for j = 1,numlanes,1 do
		if lanelocked[j] == true then
			--monitordraw(monitor2,lockedlanesx1[j],1,lockedlanesx2[j],10,colors.red, lockedlanesx1[j]+2,5, ""Lane: "".. j.. "" Locked"") 
			paintutils.drawFilledBox(lockedlanesx1[j],1,lockedlanesx2[j],10,colors.red) 
			monitor2.setTextColor(colors.white)
			monitor2.setCursorPos(lockedlanesx1[j]+2,5)
			print(""Lane"".. j.. "": Locked"")
		else
			--monitordraw(monitor2,lockedlanesx1[j],1,lockedlanesx2[j],9,colors.greeb, lockedlanesx1[j]+2,5, ""Lane: "".. j.. "" Open"")
			paintutils.drawFilledBox(lockedlanesx1[j],1,lockedlanesx2[j],10,colors.green) 
			monitor2.setTextColor(colors.white)
			monitor2.setCursorPos(lockedlanesx1[j]+2,5)
			print(""Lane"".. j.. "": Open"")
		end
	end


	-- draw lanesigns
	
	for j = 1, numlanes, 1 do
		term.redirect(lanescreen[j])

		if lanelocked[j] == true then
			term.setBackgroundColor(lanelockedcolor)
			term.clear()
			term.setCursorPos(2,5)
			print(""Lane "".. j)
		else
			if lanestat[j] == true then
				if lanedock[j] == true then
					term.setBackgroundColor(laneunloadingcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
				else
					term.setBackgroundColor(lanewaitingcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
				end
			else
					term.setBackgroundColor(laneclearcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
			end
			end
		end	

	
	term.redirect(monitor)
end

function counterincrement()
	traincount=traincount+1
	while (rs.testBundledInput(""bottom"",traincountercolor)) do
	sleep(.1)
	end
end

--****************
--*Main Loop     *
--****************

while(true) do
	scanlanes() -- check to see what lanes are full
	exitlane=exitlane+1
	if rs.testBundledInput(""bottom"",traincountercolor) == true then counterincrement() end
	if exitlane>numlanes then exitlane=1 end
		if rs.testBundledInput(""left"", exitlanecolor) == false then  -- make sure the exit lane is clear.
			if lanestat[exitlane] == true then -- check if there is a train in the current tested lane.
				if lanedock[exitlane] == false then --if there is a lane but it is in the unloading area then skip to the next one
					if lanelocked[exitlane] == false then
						release(exitlane) -- if it meets all conditions then release
					end
			end	
		end	
	end
	drawupdate() -- update display 
	sleep(.3)
end


"
5Y93JVDm,Untitled,Azzz_4565,Java,Wednesday 23rd of July 2025 09:52:31 PM CDT,"local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService(""RunService"")
local UserInputService = game:GetService(""UserInputService"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local Workspace = game:GetService(""Workspace"")
local stepped = RunService.Stepped

-- Constants for instant infinite damage
local INSTANT_INFINITY_POWER = 2 ^ (190 * 20 * 999999999999999)
local INSTANT_DEATH_DAMAGE = math.huge * 1e60 * INSTANT_INFINITY_POWER * 999000000000000000

-- Ultra fast wait function
local function ultraFastWait()
    -- Using stepped event for minimal yielding
    local event = Instance.new(""BindableEvent"")
    RunService.Stepped:Wait()
    event:Destroy()
    return
end

-- Hook wait/delay functions to remove yield/delay for max speed
for _, f in ipairs({wait, task.wait, delay, spawn, task.delay}) do
    for i = 1, 2000 do
        pcall(function()
            hookfunction(f, function()
                return stepped:Wait()
            end)
        end)
    end
end

-- Ultra instant kill function
local function trueInstantKill(humanoid)
    if humanoid and humanoid.Health > 0 then
        humanoid.Health = 0
        humanoid.MaxHealth = 0
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
        humanoid:ChangeState(Enum.HumanoidStateType.Dead)
    end
end

-- Claw damage / vaporize configuration
local clawDamage = 1e24 -- Supermassive damage for claws

local function clawVaporize(target)
    if target and target:FindFirstChild(""HumanoidRootPart"") then
        local humanoid = target:FindFirstChildOfClass(""Humanoid"")
        if humanoid and humanoid.Health > 0 then
            trueInstantKill(humanoid) -- instantly kill humanoid

            -- Apply explosive force to humanoid root part
            local force = Instance.new(""BodyVelocity"")
            force.MaxForce = Vector3.new(1e15, 1e15, 1e15)
            force.Velocity = Vector3.new(
                math.random(-1e6, 1e6), 
                math.random(1e6, 2e6), 
                math.random(-1e6, 1e6)
            )
            force.Parent = target.HumanoidRootPart

            -- Create a massive explosion at target's position
            local explosion = Instance.new(""Explosion"")
            explosion.Position = target.HumanoidRootPart.Position
            explosion.BlastRadius = 1000
            explosion.BlastPressure = 1e15
            explosion.Parent = Workspace

            -- Destroy all parts and accessories violently
            for _, part in ipairs(target:GetDescendants()) do
                if part:IsA(""BasePart"") then
                    part.Anchored = false
                    part.Velocity = Vector3.new(
                        math.random(-1e10, 1e10), 
                        1e10, 
                        math.random(-1e10, 1e10)
                    )
                    pcall(function() part:Destroy() end)
                elseif part:IsA(""Tool"") or part:IsA(""Accessory"") then
                    pcall(function() part:Destroy() end)
                end
            end
        end
    end
end

-- Vaporize nearby players in a large radius continuously
local function vaporizeNearbyPlayers()
    while true do
        ultraFastWait()
        local character = LocalPlayer.Character
        if character and character:FindFirstChild(""HumanoidRootPart"") then
            for _, targetPlayer in pairs(Players:GetPlayers()) do
                if targetPlayer ~= LocalPlayer then
                    local targetChar = targetPlayer.Character
                    if targetChar and targetChar:FindFirstChild(""HumanoidRootPart"") then
                        local humanoid = targetChar:FindFirstChildOfClass(""Humanoid"")
                        if humanoid and humanoid.Health > 0 then
                            local distance = (character.HumanoidRootPart.Position - targetChar.HumanoidRootPart.Position).Magnitude
                            if distance < 2000 then
                                clawVaporize(targetChar)
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Infinite power scaling damage applied to players in large radius
local function infinitePowerScaling()
    local powerLevel = 0
    local maxPower = 1e30
    local powerIncrement = 1e12

    while true do
        ultraFastWait()
        powerLevel = math.min(powerLevel + powerIncrement, maxPower)

        local character = LocalPlayer.Character
        if character and character:FindFirstChild(""HumanoidRootPart"") then
            for _, targetPlayer in pairs(Players:GetPlayers()) do
                if targetPlayer ~= LocalPlayer then
                    local targetChar = targetPlayer.Character
                    if targetChar and targetChar:FindFirstChild(""HumanoidRootPart"") then
                        local humanoid = targetChar:FindFirstChildOfClass(""Humanoid"")
                        if humanoid and humanoid.Health > 0 then
                            local distance = (character.HumanoidRootPart.Position - targetChar.HumanoidRootPart.Position).Magnitude
                            if distance < 1000 then
                                humanoid:TakeDamage(powerLevel)
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Function to handle massive nearby attacks including chain reactions
local function detectAndAttackMassiveTargets()
    while true do
        RunService.Heartbeat:Wait()

        local attackTargets = {}
        local character = LocalPlayer.Character
        if not (character and character:FindFirstChild(""HumanoidRootPart"")) then
            continue
        end
        local myPosition = character.HumanoidRootPart.Position

        -- Gather close targets
        for _, targetPlayer in pairs(Players:GetPlayers()) do
            if targetPlayer ~= LocalPlayer then
                local targetChar = targetPlayer.Character
                if targetChar and targetChar:FindFirstChild(""HumanoidRootPart"") then
                    local humanoid = targetChar:FindFirstChildOfClass(""Humanoid"")
                    if humanoid and humanoid.Health > 0 then
                        local distance = (myPosition - targetChar.HumanoidRootPart.Position).Magnitude
                        if distance < 15 then
                            table.insert(attackTargets, targetChar)
                        end
                    end
                end
            end
        end

        -- Attack up to 1000 targets with chain reactions
        if #attackTargets >= 1000 then
            for _, target in ipairs(attackTargets) do
                clawVaporize(target)

                local chainReactionTargets = 0
                for _, potentialTarget in ipairs(Players:GetPlayers()) do
                    if chainReactionTargets >= 7 then break end
                    local pChar = potentialTarget.Character
                    if pChar and pChar:FindFirstChild(""HumanoidRootPart"") then
                        local dist = (target.HumanoidRootPart.Position - pChar.HumanoidRootPart.Position).Magnitude
                        if dist < 15 then
                            clawVaporize(pChar)
                            chainReactionTargets = chainReactionTargets + 1
                        end
                    end
                end
            end
        end
    end
end

-- Ultra instant kill spawn hooking
local function attachSpawnDeath(player)
    player.CharacterAdded:Connect(function(character)
        for _, h in pairs(character:GetChildren()) do
            if h:IsA(""Humanoid"") then
                trueInstantKill(h)
            end
        end
        local hum = character:FindFirstChildWhichIsA(""Humanoid"")
        if hum then trueInstantKill(hum) end

        character.ChildAdded:Connect(function(child)
            if child:IsA(""Humanoid"") then
                trueInstantKill(child)
            end
        end)

        local killConn
        killConn = RunService.Heartbeat:Connect(function()
            for _, h in pairs(character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
            local hum = character:FindFirstChildWhichIsA(""Humanoid"")
            if not hum or hum.Health <= 0 then
                if killConn then killConn:Disconnect() end
            end
        end)
    end)
end

-- Setup instant kill for all players except LocalPlayer
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        attachSpawnDeath(player)
        if player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") then
                    trueInstantKill(h)
                end
            end
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        attachSpawnDeath(player)
    end
end)

-- Heartbeat kill aura - instant kill ongoing
RunService.Heartbeat:Connect(function()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
        end
    end
end)

-- Tool activation kills all others instantly
local tool = script.Parent
if tool and tool:IsA(""Tool"") then
    tool.Activated:Connect(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                for _, h in pairs(player.Character:GetChildren()) do
                    if h:IsA(""Humanoid"") and h.Health > 0 then
                        trueInstantKill(h)
                    end
                end
            end
        end
    end)
end

-- Input handling: X/Z triggers kill on others, F kills self, Touch triggers kill others
local function triggerNoCounter()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.X or input.KeyCode == Enum.KeyCode.Z then
        triggerNoCounter()
    elseif input.KeyCode == Enum.KeyCode.F then
        if LocalPlayer.Character then
            for _, h in pairs(LocalPlayer.Character:GetChildren()) do
                if h:IsA(""Humanoid"") then
                    trueInstantKill(h)
                end
            end
        end
    end
end)

UserInputService.TouchInputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        triggerNoCounter()
    end
end)

-- Optional: You may want to run these in separate threads if you want simultaneous behaviour
-- You can spawn coroutines or tasks for parallel loops like:

task.spawn(vaporizeNearbyPlayers)
task.spawn(infinitePowerScaling)
task.spawn(detectAndAttackMassiveTargets)

print(""🔥 ULTRA INSTANT INFINITY NOCOOLDOWN with MEGA CLAWS and MASSIVE ANTI-EXPLOIT activated. 🔥"")
"
xcsXQHjD,disable jnews ads on post page with spesific categories,arie_cristianD,PHP,Wednesday 23rd of July 2025 08:48:47 PM CDT,"add_filter( 'jnews_ads_global_enable', 'disable_ads_on_spesific_cat', 99, 3 );


function disable_ads_on_spesific_cat( $flag, $post_id, $location ) {
	if ( has_category( array( 'your-category-slug-1', 'your-category-slug-1' ), $post_id ) ) {
		return false;
	}
	return $flag;
}
"
bjsXjVuD,Mouse transducer,imk0tter,mIRC,Wednesday 23rd of July 2025 08:30:39 PM CDT,"alias -l ABSN return $CALC(($1 * $1) ^ (2  ^ -1))
alias -l ATANN return $CALC($1 / $ABSN($1))

alias CLAMP return $CALC(($INT($CALC($1 / $2)) % 2) * -1 * $2 + ($1 % $2))

alias TRANSDUCE return $CALC($ATANN($1) * 2 * $ASIN($CALC($ABS($CLAMP($CALC($1 * $IIF($2,$v1,1)),2)) / 2)))
alias TRANSDUCE1 return $CALC($ATANN($1) * $ACOS($CALC((2 - ($CLAMP($CALC($1 * $IIF($2,$v1,1)),2) ^ 2)) / 2)))
alias TRANSDUCE2 var %a $calc($2 * $2 * 2), %b $CLAMP($1, $CALC(2 * $2)) | return $CALC($ATANN($1) * $ACOS($CALC((%a - (%b * %b)) / %a)))

alias RESOLUTION_AND_FOV_TO_RADIUS return $CALC($1 / $SIN($CALC($PI / (360 / $2))) / 2)
"
WsFMnQ2C,Disable PeepSo page title override,ghenzdeveloper,PHP,Wednesday 23rd of July 2025 08:22:02 PM CDT,"add_filter('peepso_page_title_check', function($check){
    return false;
});"
r7xD1qey,Untitled,inhahe,Python,Wednesday 23rd of July 2025 08:06:36 PM CDT,"#todo: 
#`--x_paths .` doesn't seem to work.
#do absolute and relative path specifications in grep.py's parameters mingle correctly?
#do i need to remove trailing ""\"" from excludes passed to walk?

import os, re, argparse, fnmatch
from pathlib import Path

parser = argparse.ArgumentParser()
parser.add_argument(""-r"", action=""store_true"", help=""search directories recursively"")
parser.add_argument(""-i"", action=""store_true"", help=""make search case-insensitive"")
parser.add_argument(""--dotall"", action=""store_true"", help=""make '.' match newlines"")
parser.add_argument(""-f"", nargs=""*"", help=""search files matching these filespecs"")
parser.add_argument(""-p"", nargs=""*"", help=""search these paths"")
parser.add_argument(""--x_filespecs"", nargs=""*"", help=""exclude filespecs from search"")
parser.add_argument(""--x_paths"", nargs=""*"", help=""exclude paths from search"")
args = parser.parse_args()
paths = args.p or ["".""] 
x_paths = args.x_paths or []

def is_subpath(path, directory):
    try:
        Path(path).resolve().relative_to(Path(directory).resolve())
        return True
    except ValueError:
        return False

def walk(directory, exclude=[]):
  directory = directory.rstrip(""\\"")
  for e in [os.path.join(directory, x) for x in os.listdir(directory)]:
    if os.path.isfile(e):
      print(e)
    elif os.path.isdir(e):
      if not any(is_subpath(e, x) for x in x_paths):
        walk(e)

if args.r:
  for path in paths:
    walk(path)
    
    
"
fM4v9dAk,2025-07-23_stats.json,rdp_snitch,JSON,Wednesday 23rd of July 2025 07:18:06 PM CDT,"{
  ""ip"": {
    ""45.156.128.51"": 18,
    ""194.187.179.33"": 3,
    ""80.94.95.198"": 39,
    ""205.210.31.215"": 9,
    ""2.57.121.247"": 3,
    ""159.223.111.195"": 30,
    ""164.92.192.11"": 216,
    ""194.180.49.127"": 3,
    ""203.55.131.4"": 30,
    ""147.45.112.157"": 6,
    ""198.235.24.178"": 9,
    ""45.227.254.156"": 6,
    ""45.227.254.152"": 6,
    ""5.178.1.30"": 3,
    ""111.170.152.113"": 9,
    ""80.94.95.75"": 9,
    ""205.210.31.150"": 9,
    ""165.154.150.65"": 3,
    ""134.122.122.113"": 12,
    ""137.184.214.16"": 3,
    ""198.235.24.179"": 9
  },
  ""asn"": {
    ""AS211680"": 18,
    ""AS42969"": 3,
    ""AS204428"": 48,
    ""AS396982"": 36,
    ""AS47890"": 3,
    ""AS14061"": 261,
    ""AS201814"": 3,
    ""AS50219"": 30,
    ""AS209132"": 6,
    ""AS267784"": 12,
    ""AS211059"": 3,
    ""AS151185"": 9,
    ""AS135377"": 3
  },
  ""isp"": {
    ""NSEC - Sistemas Informaticos, S.A."": 18,
    ""Alpha Strike Labs GmbH"": 3,
    ""SS-Net"": 48,
    ""Google LLC"": 36,
    ""Unmanaged LTD"": 3,
    ""DigitalOcean, LLC"": 261,
    ""MEVSPACE sp. z o.o."": 3,
    ""LNK SYSTEMS MUNTENIA SRL"": 30,
    ""Alviva Holding Limited"": 6,
    ""Flyservers S.A."": 12,
    ""Tribeka Web Advisors S.A."": 3,
    ""China Telecom"": 9,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3
  },
  ""org"": {
    ""Inap AMS"": 18,
    ""Alpha Strike Labs GmbH"": 3,
    ""Unmanaged LTD"": 51,
    ""Palo Alto Networks, Inc"": 36,
    ""DigitalOcean, LLC"": 261,
    ""HostSlick"": 3,
    ""Valence Technology Co"": 30,
    ""Alviva Holding Limited"": 6,
    ""Xwin Universal LTD"": 12,
    ""Tribeka Web Advisors S.A"": 3,
    ""Chinanet HB"": 9,
    ""Ucloud Information Technology (hk) Limited"": 3
  },
  ""regionName"": {
    ""North Holland"": 48,
    ""Oregon"": 3,
    ""Sofia-Capital"": 48,
    ""California"": 36,
    ""England"": 3,
    ""New Jersey"": 45,
    ""Hesse"": 216,
    ""Bavaria"": 3,
    ""Shefa Province"": 6,
    ""Vilnius"": 12,
    ""Mariehamns stad"": 3,
    ""Hubei"": 9,
    ""Jakarta"": 3
  },
  ""country"": {
    ""The Netherlands"": 48,
    ""United States"": 84,
    ""Bulgaria"": 48,
    ""United Kingdom"": 3,
    ""Germany"": 219,
    ""Vanuatu"": 6,
    ""Lithuania"": 12,
    ""Aland Islands"": 3,
    ""China"": 9,
    ""Indonesia"": 3
  },
  ""account"": {
    ""root"": 18,
    ""user"": 3,
    ""142.93.8.59"": 39,
    ""JUtzbIZqf"": 3,
    ""WbGlff"": 3,
    ""JzBPum"": 3,
    ""Administr"": 21,
    ""hello"": 258,
    ""eltons"": 15,
    ""administr"": 15,
    ""TjHeNTbjC"": 3,
    ""LiCwAI"": 3,
    ""ssKIiJ"": 3,
    ""Test"": 12,
    ""xjEyVLTil"": 3,
    ""eSMQIr"": 3,
    ""FWdBhY"": 3,
    ""Administrator"": 3,
    ""wjdsa1aw"": 12,
    ""beio"": 3,
    ""PZLdJVqWu"": 3,
    ""xPAssk"": 3,
    ""sCDKAQ"": 3
  },
  ""keyboard"": {
    ""Unknown"": 435
  },
  ""client_build"": {
    ""Unknown"": 435
  },
  ""client_name"": {
    ""Unknown"": 435
  },
  ""ip_type"": {
    ""Unknown"": 135,
    ""hosting"": 297,
    ""hosting & proxy"": 3
  }
}"
QWh691rz,2025-07-23_stats.json,rdp_snitch,JSON,Wednesday 23rd of July 2025 07:16:16 PM CDT,"{
  ""ip"": {
    ""45.156.128.51"": 12,
    ""194.187.179.33"": 2,
    ""80.94.95.198"": 26,
    ""205.210.31.215"": 6,
    ""2.57.121.247"": 2,
    ""159.223.111.195"": 20,
    ""164.92.192.11"": 144,
    ""194.180.49.127"": 2,
    ""203.55.131.4"": 20,
    ""147.45.112.157"": 4,
    ""198.235.24.178"": 6,
    ""45.227.254.156"": 4,
    ""45.227.254.152"": 4,
    ""5.178.1.30"": 2,
    ""111.170.152.113"": 6,
    ""80.94.95.75"": 6,
    ""205.210.31.150"": 6,
    ""165.154.150.65"": 2,
    ""134.122.122.113"": 8,
    ""137.184.214.16"": 2,
    ""198.235.24.179"": 6
  },
  ""asn"": {
    ""AS211680"": 12,
    ""AS42969"": 2,
    ""AS204428"": 32,
    ""AS396982"": 24,
    ""AS47890"": 2,
    ""AS14061"": 174,
    ""AS201814"": 2,
    ""AS50219"": 20,
    ""AS209132"": 4,
    ""AS267784"": 8,
    ""AS211059"": 2,
    ""AS151185"": 6,
    ""AS135377"": 2
  },
  ""isp"": {
    ""NSEC - Sistemas Informaticos, S.A."": 12,
    ""Alpha Strike Labs GmbH"": 2,
    ""SS-Net"": 32,
    ""Google LLC"": 24,
    ""Unmanaged LTD"": 2,
    ""DigitalOcean, LLC"": 174,
    ""MEVSPACE sp. z o.o."": 2,
    ""LNK SYSTEMS MUNTENIA SRL"": 20,
    ""Alviva Holding Limited"": 4,
    ""Flyservers S.A."": 8,
    ""Tribeka Web Advisors S.A."": 2,
    ""China Telecom"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2
  },
  ""org"": {
    ""Inap AMS"": 12,
    ""Alpha Strike Labs GmbH"": 2,
    ""Unmanaged LTD"": 34,
    ""Palo Alto Networks, Inc"": 24,
    ""DigitalOcean, LLC"": 174,
    ""HostSlick"": 2,
    ""Valence Technology Co"": 20,
    ""Alviva Holding Limited"": 4,
    ""Xwin Universal LTD"": 8,
    ""Tribeka Web Advisors S.A"": 2,
    ""Chinanet HB"": 6,
    ""Ucloud Information Technology (hk) Limited"": 2
  },
  ""regionName"": {
    ""North Holland"": 32,
    ""Oregon"": 2,
    ""Sofia-Capital"": 32,
    ""California"": 24,
    ""England"": 2,
    ""New Jersey"": 30,
    ""Hesse"": 144,
    ""Bavaria"": 2,
    ""Shefa Province"": 4,
    ""Vilnius"": 8,
    ""Mariehamns stad"": 2,
    ""Hubei"": 6,
    ""Jakarta"": 2
  },
  ""country"": {
    ""The Netherlands"": 32,
    ""United States"": 56,
    ""Bulgaria"": 32,
    ""United Kingdom"": 2,
    ""Germany"": 146,
    ""Vanuatu"": 4,
    ""Lithuania"": 8,
    ""Aland Islands"": 2,
    ""China"": 6,
    ""Indonesia"": 2
  },
  ""account"": {
    ""root"": 12,
    ""user"": 2,
    ""142.93.8.59"": 26,
    ""JUtzbIZqf"": 2,
    ""WbGlff"": 2,
    ""JzBPum"": 2,
    ""Administr"": 14,
    ""hello"": 172,
    ""eltons"": 10,
    ""administr"": 10,
    ""TjHeNTbjC"": 2,
    ""LiCwAI"": 2,
    ""ssKIiJ"": 2,
    ""Test"": 8,
    ""xjEyVLTil"": 2,
    ""eSMQIr"": 2,
    ""FWdBhY"": 2,
    ""Administrator"": 2,
    ""wjdsa1aw"": 8,
    ""beio"": 2,
    ""PZLdJVqWu"": 2,
    ""xPAssk"": 2,
    ""sCDKAQ"": 2
  },
  ""keyboard"": {
    ""Unknown"": 290
  },
  ""client_build"": {
    ""Unknown"": 290
  },
  ""client_name"": {
    ""Unknown"": 290
  },
  ""ip_type"": {
    ""Unknown"": 90,
    ""hosting"": 198,
    ""hosting & proxy"": 2
  }
}"
PBnDgeVZ,2025-07-23_stats.json,rdp_snitch,JSON,Wednesday 23rd of July 2025 07:15:09 PM CDT,"{
  ""ip"": {
    ""45.156.128.51"": 6,
    ""194.187.179.33"": 1,
    ""80.94.95.198"": 13,
    ""205.210.31.215"": 3,
    ""2.57.121.247"": 1,
    ""159.223.111.195"": 10,
    ""164.92.192.11"": 72,
    ""194.180.49.127"": 1,
    ""203.55.131.4"": 10,
    ""147.45.112.157"": 2,
    ""198.235.24.178"": 3,
    ""45.227.254.156"": 2,
    ""45.227.254.152"": 2,
    ""5.178.1.30"": 1,
    ""111.170.152.113"": 3,
    ""80.94.95.75"": 3,
    ""205.210.31.150"": 3,
    ""165.154.150.65"": 1,
    ""134.122.122.113"": 4,
    ""137.184.214.16"": 1,
    ""198.235.24.179"": 3
  },
  ""asn"": {
    ""AS211680"": 6,
    ""AS42969"": 1,
    ""AS204428"": 16,
    ""AS396982"": 12,
    ""AS47890"": 1,
    ""AS14061"": 87,
    ""AS201814"": 1,
    ""AS50219"": 10,
    ""AS209132"": 2,
    ""AS267784"": 4,
    ""AS211059"": 1,
    ""AS151185"": 3,
    ""AS135377"": 1
  },
  ""isp"": {
    ""NSEC - Sistemas Informaticos, S.A."": 6,
    ""Alpha Strike Labs GmbH"": 1,
    ""SS-Net"": 16,
    ""Google LLC"": 12,
    ""Unmanaged LTD"": 1,
    ""DigitalOcean, LLC"": 87,
    ""MEVSPACE sp. z o.o."": 1,
    ""LNK SYSTEMS MUNTENIA SRL"": 10,
    ""Alviva Holding Limited"": 2,
    ""Flyservers S.A."": 4,
    ""Tribeka Web Advisors S.A."": 1,
    ""China Telecom"": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1
  },
  ""org"": {
    ""Inap AMS"": 6,
    ""Alpha Strike Labs GmbH"": 1,
    ""Unmanaged LTD"": 17,
    ""Palo Alto Networks, Inc"": 12,
    ""DigitalOcean, LLC"": 87,
    ""HostSlick"": 1,
    ""Valence Technology Co"": 10,
    ""Alviva Holding Limited"": 2,
    ""Xwin Universal LTD"": 4,
    ""Tribeka Web Advisors S.A"": 1,
    ""Chinanet HB"": 3,
    ""Ucloud Information Technology (hk) Limited"": 1
  },
  ""regionName"": {
    ""North Holland"": 16,
    ""Oregon"": 1,
    ""Sofia-Capital"": 16,
    ""California"": 12,
    ""England"": 1,
    ""New Jersey"": 15,
    ""Hesse"": 72,
    ""Bavaria"": 1,
    ""Shefa Province"": 2,
    ""Vilnius"": 4,
    ""Mariehamns stad"": 1,
    ""Hubei"": 3,
    ""Jakarta"": 1
  },
  ""country"": {
    ""The Netherlands"": 16,
    ""United States"": 28,
    ""Bulgaria"": 16,
    ""United Kingdom"": 1,
    ""Germany"": 73,
    ""Vanuatu"": 2,
    ""Lithuania"": 4,
    ""Aland Islands"": 1,
    ""China"": 3,
    ""Indonesia"": 1
  },
  ""account"": {
    ""root"": 6,
    ""user"": 1,
    ""142.93.8.59"": 13,
    ""JUtzbIZqf"": 1,
    ""WbGlff"": 1,
    ""JzBPum"": 1,
    ""Administr"": 7,
    ""hello"": 86,
    ""eltons"": 5,
    ""administr"": 5,
    ""TjHeNTbjC"": 1,
    ""LiCwAI"": 1,
    ""ssKIiJ"": 1,
    ""Test"": 4,
    ""xjEyVLTil"": 1,
    ""eSMQIr"": 1,
    ""FWdBhY"": 1,
    ""Administrator"": 1,
    ""wjdsa1aw"": 4,
    ""beio"": 1,
    ""PZLdJVqWu"": 1,
    ""xPAssk"": 1,
    ""sCDKAQ"": 1
  },
  ""keyboard"": {
    ""Unknown"": 145
  },
  ""client_build"": {
    ""Unknown"": 145
  },
  ""client_name"": {
    ""Unknown"": 145
  },
  ""ip_type"": {
    ""Unknown"": 45,
    ""hosting"": 99,
    ""hosting & proxy"": 1
  }
}"
Y8u7vjjQ,Untitled,Azzz_4565,Java,Wednesday 23rd of July 2025 05:12:25 PM CDT,"--🔥 ULTRA INSTANT INFINITY NOCOOLDOWN — 999 TRILLION TIMES FASTER, ABSOLUTE MAX DAMAGE, IMMEDIATE KILL 🔥
-- When you use your tool, every player (except you) dies instantly, just like Humanoid.Health = 0.
-- They never get full health, always die instantly every kill, every respawn.
-- For educational/testing use only. Server-side Script in your own Roblox game.

local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService(""RunService"")
local UserInputService = game:GetService(""UserInputService"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local stepped = RunService.Stepped

local INSTANT_INFINITY_POWER = 2 ^ (190 * 20 * 999999999999999)
local INSTANT_DEATH_DAMAGE = math.huge * 1e60 * INSTANT_INFINITY_POWER * 999000000000000000

-- REMOVE YIELD/DELAY
for _, f in ipairs({wait, task.wait, delay, spawn, task.delay}) do
    for i = 1, 2000 do
        pcall(function()
            hookfunction(f, function()
                return stepped:Wait()
            end)
        end)
    end
end

-- ULTRA INSTANT KILL FUNCTION (Just like setting Humanoid.Health = 0)
local function trueInstantKill(humanoid)
    if humanoid then
        humanoid.Health = 0
        humanoid.MaxHealth = 0
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
        humanoid:ChangeState(Enum.HumanoidStateType.Dead)
    end
end

-- Character spawn hook: Make instant death happen every spawn
local function attachSpawnDeath(player)
    player.CharacterAdded:Connect(function(character)
        local hum = character:FindFirstChildWhichIsA(""Humanoid"")
        if hum then trueInstantKill(hum) end
        character.ChildAdded:Connect(function(child)
            if child:IsA(""Humanoid"") then trueInstantKill(child) end
        end)
        -- Heartbeat kill loop until they're truly dead
        local killConn
        killConn = RunService.Heartbeat:Connect(function()
            for _, h in pairs(character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then trueInstantKill(h) end
            end
            local hum = character:FindFirstChildWhichIsA(""Humanoid"")
            if not hum or hum.Health <= 0 then
                if killConn then killConn:Disconnect() end
            end
        end)
    end)
end

-- Setup for all players except yourself
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        attachSpawnDeath(player)
        if player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") then trueInstantKill(h) end
            end
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        attachSpawnDeath(player)
    end
end)

-- Heartbeat kill aura: Every tick, every player dies instantly
RunService.Heartbeat:Connect(function()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
        end
    end
end)

-- Tool activation: Kill instantly on tool use
local tool = script.Parent
if tool:IsA(""Tool"") then
    tool.Activated:Connect(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                for _, h in pairs(player.Character:GetChildren()) do
                    if h:IsA(""Humanoid"") and h.Health > 0 then
                        trueInstantKill(h)
                    end
                end
            end
        end
    end)
end

-- Keybinds / Touch input: X/Z for kill aura, F for self kill
local function triggerNoCounter()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.X or input.KeyCode == Enum.KeyCode.Z then
        triggerNoCounter()
    elseif input.KeyCode == Enum.KeyCode.F then
        if LocalPlayer.Character then
            for _, h in pairs(LocalPlayer.Character:GetChildren()) do
                if h:IsA(""Humanoid"") then trueInstantKill(h) end
            end
        end
    end
end)

UserInputService.TouchInputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        triggerNoCounter()
    end
end)

print(""🔥 ULTRA INSTANT INFINITY NOCOOLDOWN: Humanoids instantly set to 0 health, every kill, every spawn, absolute max damage, no delay, no cooldown, inescapable. 🔥"")"
e3hT3E2N,RequestException: error with request,basedcount_bot,Python,Wednesday 23rd of July 2025 03:34:15 PM CDT,"Traceback (most recent call last):
  File ""/home/gmktec-server/Bots/basedcount_bot/basedcount_bot.py"", line 46, in wrapper
    await func(reddit_instance, mongo_client)
  File ""/home/gmktec-server/Bots/basedcount_bot/basedcount_bot.py"", line 263, in read_comments
    async for comment in pcm_subreddit.stream.comments(skip_existing=True):  # Comment
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/util.py"", line 172, in stream_generator
    [result async for result in function(limit=limit, **function_kwargs)]
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/util.py"", line 172, in <listcomp>
    [result async for result in function(limit=limit, **function_kwargs)]
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 37, in __anext__
    await self._next_batch()
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 90, in _next_batch
    self._listing = await self._reddit.get(self.url, params=self.params)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 813, in get
    return await self._objectify_request(method=""GET"", params=params, path=path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 570, in _objectify_request
    await self.request(
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 1061, in request
    return await self._core.request(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 383, in request
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 286, in _request_with_retries
    response, saved_exception = await self._make_request(
                                ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 192, in _make_request
    response = await self._rate_limiter.call(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/rate_limit.py"", line 51, in call
    response = await request_function(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/requestor.py"", line 80, in request
    raise RequestException(exc, args, kwargs) from None
asyncprawcore.exceptions.RequestException: error with request 
"
Dpxf1r5i,Testeonewlissta,Manuuuuuerty,JSON,Wednesday 23rd of July 2025 03:15:47 PM CDT,"  {
  ""name"": ""Plooplayerxxx"",
  ""author"": ""Plooplayerxxx"",
  ""telegram"": ""t.me/futbolgratisonlineenhd"",
  ""info"": ""Listasplooplayer"",
  ""pl"": ""oWZaQlfHYZNcJykYcqP1FYIvd4JjUmapKcNJN+RvwYk="",
  ""stations"": [
   
{
      ""name"": ""PrVega"",
      ""p"": """",
      ""image"": ""https://miro.medium.com/v2/resize:fit:640/format:webp/1*79lBAVR-jnIitFyMEqXmVg.png"",
      ""ploorl"": ""aDsBbewuGSBIC2W5v2ViGiJ4KbMAOsAr5PkMz1wEP4wVOjv0CCsofAiG68a/UnYD7W/y+i9tDpZzUH3ys798CXAegxLtoGXb"",
      ""embed"": ""true""
    },

{
      ""name"": ""PrVega 2"",
      ""image"": ""https://miro.medium.com/v2/resize:fit:640/format:webp/1*79lBAVR-jnIitFyMEqXmVg.png"",
      ""ploorl"": ""6leJ7ujeY/M1aARbjCV8MsSerDVABCutlChr46Q4Lys6eX7RhDfhlz7/2ObaHetBUX/mr2Ac/0i6sApT79fhfamU5QOQjWZvLerMcM14zw6gb50Rr3mT7JmFKx8WtjB/ueGIgBl2GVawUD0QyNi5QIJiP+JEXZ6s4No+J+cRQGisnqtnlL6ue8wWdobVsxZt3mARTcwCLDHWkq9Yha+EQw=="",
      ""embed"": ""true""
    },


{
      ""name"": ""PrVega 2"",
      ""image"": ""https://miro.medium.com/v2/resize:fit:640/format:webp/1*79lBAVR-jnIitFyMEqXmVg.png"",
      ""ploorl"": ""6leJ7ujeY/M1aARbjCV8MsSerDVABCutlChr46Q4Lys6eX7RhDfhlz7/2ObaHetBUX/mr2Ac/0i6sApT79fhfamU5QOQjWZvLerMcM14zw6gb50Rr3mT7JmFKx8WtjB/ueGIgBl2GVawUD0QyNi5QIJiP+JEXZ6s4No+J+cRQGisnqtnlL6ue8wWdobVsxZt3mARTcwCLDHWkq9Yha+EQw=="",
      ""isHost"":""true""
    },


{
      ""name"": ""ISOLATOR TEST (using parent)"",
      ""url"": ""https://www.sportsbay.dk/futbol/zira-vs-hajduk-split.html"",
      ""embed"": ""true"",
      ""plooIsoElement"": ""iframe"",
      ""plooIsoAttributes"": {
        ""width"": ""100%"",
        ""height"": ""100%""
      },
      ""plooIsoParentElement"": ""div"",
      ""plooIsoParentAttributes"": {
        ""id"": ""video_box""
      }
    },
  
  
  
  
  
  {
      ""name"": ""ISOLATOR TEST (using parent)"",
      ""url"": ""https://miztv.top/stream/stream-84.php"",
      ""embed"": ""true"",
      ""plooIsoElement"": ""iframe"",
      ""plooIsoAttributes"": {
        ""width"": ""100%"",
        ""height"": ""500""
      },
      ""plooIsoParentElement"": ""article"",
      ""plooIsoParentAttributes"": {
        ""class"": ""col-xs-12""
      }
    },
  
  
  
  
    {
      ""name"": ""ISOLATOR TEST CON DIV"",
      ""url"": ""https://miztv.top/stream/stream-84.php"",
      ""embed"": ""true"",
      ""plooIsoElement"": ""article"",
      ""plooIsoAttributes"": {
        ""class"": ""col-xs-12""
      },
      ""plooIsoParentElement"": ""div"",
      ""plooIsoParentAttributes"": {
        ""class"": ""row""
      }
    },
  
  
  
  
  
    {
      ""name"": ""ISOLATOR TEST (using parent)"",
      ""url"": ""https://miztv.top/stream/stream-84.php"",
      ""embed"": ""true"",
      ""plooIsoElement"": ""iframe"",
      ""plooIsoAttributes"": {
        ""width"": ""100%"",
        ""height"": ""500""
      }
     }
  
  
  
  
  
  
  


  ]
}"
39zTuu6v,smartQuary computercraft,daoek,Lua,Wednesday 23rd of July 2025 02:51:21 PM CDT,"local function TurtleState()
    local x, y, z = 0, 0, 0
    local dir = ""n""
    local path = ""/data/turtleState.json""

    local function load()
        if not fs.exists(""/data"") then
            fs.makeDir(""/data"")
        end

        if fs.exists(path) then
            local file = fs.open(path, ""r"")
            local data = textutils.unserializeJSON(file.readAll())
            file.close()
            x = data.x or 0
            y = data.y or 0
            z = data.z or 0
            dir = data.dir or ""n""
        end
    end

    local function save(newX, newY, newZ, newDir)
        x = newX or x
        y = newY or y
        z = newZ or z
        dir = newDir or dir

        local file = fs.open(path, ""w"")
        file.write(textutils.serializeJSON({
            x = x,
            y = y,
            z = z,
            dir = dir
        }))
        file.close()
    end

    local function get()
        return x, y, z, dir
    end

    load()

    return {
        load = load,
        save = save,
        get = get
    }
end

dirIndex = { n = 0, e = 1, s = 2, w = 3 }
dirNames = { ""n"", ""e"", ""s"", ""w"" }

turtleState = TurtleState()
x, y, z, dir = turtleState.get()

local function refuelAll(limit)
    if turtle.getFuelLevel() < limit then
        for i = 1, 16, 1 do
            turtle.select(i)
            turtle.refuel()
        end
    end
end

local function resetState()
    x, y, z, dir = 0, 0, 0, ""n""
    turtleState.save(x, y, z, dir)
    print(""Turtle state reset to 0, 0, 0, facing north."")
end

local function isOre(dir)
    local inspectFn

    if dir == """" or dir == ""forward"" then
        inspectFn = turtle.inspect
    elseif dir == ""up"" then
        inspectFn = turtle.inspectUp
    elseif dir == ""down"" then
        inspectFn = turtle.inspectDown
    else
        error(""Invalid direction: expected '', 'forward', 'up', or 'down'"", 2)
    end

    local success, data = inspectFn()
    if not success or not data.name then
        return false
    end

    local name = data.name

    local blacklist = {
        ""grass"", ""stone"", ""dirt"", ""gravel"",
        ""obsidian"", ""water"", ""lava"", ""bedrock"", ""turtle"", ""chest"", ""sand"", ""cactus""
    }

    for _, bad in ipairs(blacklist) do
        if name:find(bad) then
            return false
        end
    end

    return true
end

local function isInventoryFull()
    for i = 1, 16 do
        if turtle.getItemCount(i) == 0 then
            return false
        end
    end
    return true
end

local function dumpInventory(dir)
    local dropFn

    if dir == """" or dir == ""forward"" then
        dropFn = turtle.drop
    elseif dir == ""up"" then
        dropFn = turtle.dropUp
    elseif dir == ""down"" then
        dropFn = turtle.dropDown
    else
        error(""Invalid direction: must be '', 'up', or 'down'"", 2)
    end

    for i = 1, 16 do
        turtle.select(i)
        dropFn()
    end

    turtle.select(1) -- Restore selection
end

local function SmartDig(dir)

    local digFunction, inspectFunction, attempts

    if dir == """" or dir == ""forward"" then
        digFunction = turtle.dig
        inspectFunction = turtle.inspect
    elseif dir == ""up"" then
        digFunction = turtle.digUp
        inspectFunction = turtle.inspectUp
    elseif dir == ""down"" then
        digFunction = turtle.digDown
        inspectFunction = turtle.inspectDown
    else
        error(""Invalid direction: expected '', 'forward', 'up', or 'down'"", 2)
    end

    attempts = 2

    local function DigFallingEntity()
        while digFunction() do
            os.sleep(0.5)
        end
    end

    local function DigNormal()
        digFunction()
    end

    while attempts > 0 do
        local success, data = inspectFunction()
        if not success then
            return
        end

        local name = data.name or """"
        if name:find(""gravel"") or name:find(""sand"") then
            DigFallingEntity()
        elseif name:find(""turtle"") or name:find(""lava"") or name:find(""water"") or name:find(""bedrock"") then
            return
        else   
            DigNormal()
        end

        -- Check again in case something fell
        local again, newData = inspectFunction()

        if again then
            attempts = attempts - 1
        else
            return
        end
    end
end

local function forward()
    SmartDig(""forward"")

    if turtle.forward() then
        if dir == ""n"" then
            z = z - 1
        elseif dir == ""s"" then
            z = z + 1
        elseif dir == ""e"" then
            x = x + 1
        elseif dir == ""w"" then
            x = x - 1
        end

        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function back()
    if turtle.back() then
        if dir == ""n"" then
            z = z + 1
        elseif dir == ""s"" then
            z = z - 1
        elseif dir == ""e"" then
            x = x - 1
        elseif dir == ""w"" then
            x = x + 1
        end

        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function up()
    SmartDig(""up"")
    if turtle.up() then
        y = y + 1
        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function down()

    SmartDig(""down"")

    if turtle.down() then
        y = y - 1
        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function turnLeft()
    turtle.turnLeft()
    local idx = (dirIndex[dir] - 1) % 4
    dir = dirNames[idx + 1]
    turtleState.save(x, y, z, dir)
end

local function turnRight()
    turtle.turnRight()
    local idx = (dirIndex[dir] + 1) % 4
    dir = dirNames[idx + 1]
    turtleState.save(x, y, z, dir)
end

local function turnToDirection(desiredDir)
    if dir == desiredDir then return end

    local current = dirIndex[dir]
    local target = dirIndex[desiredDir]
    local diff = (target - current) % 4

    if diff == 1 then
        turnRight()
    elseif diff == 2 then
        turnRight()
        turnRight()
    elseif diff == 3 then
        turnLeft()
    end
end

local function moveToLocation(desiredX, desiredY, desiredZ)
    -- Move vertically first (Y axis)
    while y < desiredY do
        if not up() then return false end
    end
    while y > desiredY do
        if not down() then return false end
    end

    -- Move along X axis
    if desiredX > x then
        turnToDirection(""e"")
        while x < desiredX do
            if not forward() then return false end
        end
    elseif desiredX < x then
        turnToDirection(""w"")
        while x > desiredX do
            if not forward() then return false end
        end
    end

    -- Move along Z axis
    if desiredZ > z then
        turnToDirection(""s"")
        while z < desiredZ do
            if not forward() then return false end
        end
    elseif desiredZ < z then
        turnToDirection(""n"")
        while z > desiredZ do
            if not forward() then return false end
        end
    end

    return true
end

local function removeDataFromArray(array, data)
    local foundIndex = -1
    
    for i, v in ipairs(array) do
        if data == v then
            foundIndex = i
        end
    end

    if foundIndex ~= -1 then
        table.remove(array, foundIndex)
    end

end

local function doesArrayContain(array, data)
    for i, v in ipairs(array) do
        if data == v then
            return true
        end
    end

    return false
end

local function createPositionKey(x, y, z)
    return string.format(""%d,%d,%d"", x, y, z)
end

local function getPositionKeyWithDirection(relativeDir)
    local dx, dy, dz = 0, 0, 0

    if relativeDir == ""up"" then
        dy = 1
    elseif relativeDir == ""down"" then
        dy = -1
    elseif relativeDir == ""forward"" then
        if dir == ""n"" then dz = -1
        elseif dir == ""s"" then dz = 1
        elseif dir == ""e"" then dx = 1
        elseif dir == ""w"" then dx = -1 end
    elseif relativeDir == ""back"" then
        if dir == ""n"" then dz = 1
        elseif dir == ""s"" then dz = -1
        elseif dir == ""e"" then dx = -1
        elseif dir == ""w"" then dx = 1 end
    elseif relativeDir == ""left"" then
        if dir == ""n"" then dx = -1
        elseif dir == ""s"" then dx = 1
        elseif dir == ""e"" then dz = -1
        elseif dir == ""w"" then dz = 1 end
    elseif relativeDir == ""right"" then
        if dir == ""n"" then dx = 1
        elseif dir == ""s"" then dx = -1
        elseif dir == ""e"" then dz = 1
        elseif dir == ""w"" then dz = -1 end
    else
        error(""Invalid direction for getPositionKeyWithDirection: "" .. tostring(relativeDir))
    end

    return createPositionKey(x + dx, y + dy, z + dz)
end

local function smartMineOreVeinWorker(noOreDetected, oreDetected, backTrackLog)

    local targetPos = getPositionKeyWithDirection(""forward"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""down"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""down"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""up"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""up"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""right"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
    turnRight()

        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end

    turnLeft()
    end

    targetPos = getPositionKeyWithDirection(""left"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        turnLeft()
        
        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end

        turnRight()
    end




    -- Mine down if there is ore
    targetPos = getPositionKeyWithDirection(""down"")
    if doesArrayContain(oreDetected, targetPos) then

        if down() then
            table.insert(backTrackLog, ""up"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine left if there is ore
    targetPos = getPositionKeyWithDirection(""left"")
    if doesArrayContain(oreDetected, targetPos) then
        turnLeft()
        table.insert(backTrackLog, ""turnright"")

        if forward() then
            table.insert(backTrackLog, ""back"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine forward if there is ore
    targetPos = getPositionKeyWithDirection(""forward"")
    if doesArrayContain(oreDetected, targetPos) then
        if forward() then
            table.insert(backTrackLog, ""back"")
            
            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine right if there is ore
    targetPos = getPositionKeyWithDirection(""right"")
    if doesArrayContain(oreDetected, targetPos) then
        turnRight()
        table.insert(backTrackLog, ""turnleft"")

        if forward() then
            table.insert(backTrackLog, ""back"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)
        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine up if there is ore
    targetPos = getPositionKeyWithDirection(""up"")
    if doesArrayContain(oreDetected, targetPos) then

        if up() then
            table.insert(backTrackLog, ""down"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    --no ores next to turtle need to backtrack if there are any ores left
    if #oreDetected > 0 and #backTrackLog > 0 then
        local action = table.remove(backTrackLog)

        --back tracked
        if action == ""turnright"" then
            turnRight()
        elseif action == ""turnleft"" then
            turnLeft()
        elseif action == ""back"" then
            back()
        elseif action == ""down"" then
            down()
        elseif action == ""up"" then
            up()
        end

            --check backtracked location
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog) 
        

        

    else
        return true
    end

end

local function smartMineOreVein()

    local noOreDetected = {}
    local oreDetected = {}
    local backTrackLog = {}

    local startXPos, startYPos, startZPos, startDir = x, y, z, dir
    smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog, true)

    moveToLocation(startXPos,startYPos,startZPos)
    turnToDirection(startDir)
end

local function mineWellAndCollectOres()
    local startXPos, startYPos, startZPos = x, y, z

    while down() do
        for i = 1, 4, 1 do
            turnLeft()
            if isOre(""forward"") then
                smartMineOreVein()
            end
        end
    end

    moveToLocation(startXPos,startYPos,startZPos)
end

local function mineWellInGrid(width, depth)
    local wellLocations = {}
    local startXPos, startYPos, startZPos, startDir = x, y, z, dir

    -- Generate initial well positions
    for z = 0, -(depth - 1), -1 do
        for x = 0, (width - 1), 1 do
            if z % 4 == 0 and x % 4 == 0 then
                table.insert(wellLocations, {x, y, z}) -- assumes y is global
            end
        end
    end

    -- Duplicate with (2, 0, -2) offset
    local originalCount = #wellLocations
    for index = 1, originalCount do
        local loc = wellLocations[index]
        table.insert(wellLocations, {loc[1] + 2, loc[2], loc[3] - 2})
    end

    -- Remove locations out of bounds
    local i = 1
    while i <= #wellLocations do
        local x, _, z = table.unpack(wellLocations[i])
        if x < 0 or x >= width or math.abs(z) > depth then
            table.remove(wellLocations, i)
        else
            i = i + 1
        end
    end

    for i = 1, #wellLocations, 1 do
        
        moveToLocation(wellLocations[i][1], wellLocations[i][2], wellLocations[i][3])
        mineWellAndCollectOres()
        
        moveToLocation(startXPos,startYPos,startZPos)
        turnToDirection(startDir)

        turnLeft()
        turnLeft()

        refuelAll(2000)
        
        dumpInventory(""forward"")
    end
end

--go to starting location when loaded again
moveToLocation(0,0,0)
turnToDirection(""n"")

local args = { ... }

if not args[1] then
    print(""Usage:"")
    print(""mine reset (Reset turtle origin point)"")
    print(""mine smartQuary <width> <depth> (Mine a grid of ore wells)"")
    return

elseif args[1] == ""reset"" then
    resetState()
    return

elseif args[1] == ""smartQuary"" then
    local width = tonumber(args[2])
    local depth = tonumber(args[3])

    if width and depth then
        mineWellInGrid(width, depth)
    else
        print(""Usage: mine smartQuary <width> <depth>"")
        print(""Example: mine smartQuary 16 20"")
    end
    return

else
    print(""Unknown subcommand: "" .. tostring(args[1]))
    print(""Use one of the following:"")
    print(""reset"")
    print(""smartQuary <width> <depth>"")
    return
end










"
PAR1dc10,PersonalAccessToken.php,wzee1,PHP,Wednesday 23rd of July 2025 02:44:34 PM CDT,"<?php

namespace App\Models;

use Laravel\Sanctum\PersonalAccessToken as SanctumPersonalAccessToken;
use MongoDB\Laravel\Eloquent\DocumentModel;
use MongoDB\BSON\ObjectID;

class PersonalAccessToken extends SanctumPersonalAccessToken
{
    use DocumentModel;

    protected $connection = 'mongodb';
    protected $collection = 'personal_access_tokens';


    protected $primaryKey = '_id';
    protected $keyType = 'string';
    public $incrementing = false;



    protected $fillable = [
        'name',
        'token',
        'abilities',
        'last_used_at',
        'expires_at',
        'session_id'
    ];

    /**
     * Set the tokenable_id attribute, ensuring it's a MongoDB ObjectID.
     * This handles cases where a string ID might be passed.
     *
     * @param  mixed  $value
     * @return void
     */
    public function setTokenableIdAttribute($value)
    {
        // If the value is already an ObjectID, use it directly.
        // Otherwise, attempt to create an ObjectID from the string.
        $this->attributes['tokenable_id'] = (string) $value;
    }

    /**
     * Cast the tokenable_id attribute to ObjectID when retrieving.
     * While not strictly necessary for saving, it ensures consistency.
     *
     * @var array
     */
    protected $casts = [
        'abilities' => 'array',
        'expires_at' => 'datetime',
        'last_used_at' => 'datetime',
    ];
}
"
TLtfufRX,Homework45,JohnJuly,C#,Wednesday 23rd of July 2025 02:42:24 PM CDT,"using System;
using System.Collections.Generic;

namespace Colosseum
{
    class Program
    {
        static void Main(string[] args)
        {
            Arena arena = new Arena();
            arena.Run();
        }
    }

    abstract class Fighter
    {
        public Fighter(string type, string name, int damage, int defense, int health, string uniqueAbilityDescription)
        {
            Type = type;
            Name = name;
            Damage = damage;
            Defense = defense;
            Health = health;
            UniqueAbilityDescription = uniqueAbilityDescription;
        }

        public string Type { get; protected set; }
        public string Name { get; protected set; }
        public int Damage { get; protected set; }
        public int Defense { get; protected set; }
        public int Health { get; protected set; }
        public string UniqueAbilityDescription { get; protected set; }

        public virtual void Attack(Fighter opponent)
        {
            int inflictedDamage = Math.Max(0, Damage - opponent.Defense);

            Console.WriteLine($""{Name} атакует {opponent.Name} и наносит {inflictedDamage} урона."");
            opponent.TakeDamage(inflictedDamage);
        }

        public virtual void TakeDamage(int damage)
        {
            Health = Math.Max(0, Health - damage);
            Console.WriteLine($""{Name} получает {damage} урона. Осталось здоровья: {Health}"");
        }

        public virtual bool IsAlive() => Health > 0;

        public virtual string GetShortStats() =>
            $""( Имя: {Name} | Здоровье: {Health} | Урон: {Damage} | Защита: {Defense} | Способность: {UniqueAbilityDescription})"";

        public virtual void DisplayStats()
        {
            Console.WriteLine($""  Имя: {Name}"");
            Console.WriteLine($""  Тип: {Type}"");
            Console.WriteLine($""  Урон: {Damage}"");
            Console.WriteLine($""  Защита: {Defense}"");
            Console.WriteLine($""  Здоровье: {Health}"");
            Console.WriteLine($""  Особая способность: {UniqueAbilityDescription}"");
        }
    }

    class BasicFighter : Fighter
    {
        public BasicFighter(string name, int damage, int defense, int health)
            : base(""Воин"", name, damage, defense, health, ""Нет особых способностей"") { }
    }

    class DoubleDamageFighter : Fighter
    {
        private int _doubleDamageChance = 30;
        private int _damageMultiplier = 2;
        private int _randomNumberMin = 1;
        private int _randomNumberMax = 100;

        public DoubleDamageFighter(string name, int damage, int defense, int health)
            : base(""Двойной Урон"", name, damage, defense, health, ""Имеет шанс нанести удвоенный урон"") { }

        public override void Attack(Fighter opponent)
        {
            if (UserUtils.GenerateRandomNumber(_randomNumberMin, _randomNumberMax) <= _doubleDamageChance)
            {
                int doubledDamage = Math.Max(0, Damage * _damageMultiplier - opponent.Defense);
                Console.WriteLine($""{Name} использует двойной урон и наносит {doubledDamage} урона!"");
                opponent.TakeDamage(doubledDamage);
            }
            else
            {
                base.Attack(opponent);
            }
        }
    }

    class TripleAttackFighter : Fighter
    {
        private int _attackInterval = 3;
        private int _damageMultiplier = 2;
        private int _attackCounter = 0;

        public TripleAttackFighter(string name, int damage, int defense, int health)
            : base(""Тройная Атака"", name, damage, defense, health, ""Каждую третью атаку наносит двойной урон"") { }

        public override void Attack(Fighter opponent)
        {
            _attackCounter++;
            if (_attackCounter % _attackInterval == 0)
            {
                int doubleDamage = Math.Max(0, Damage * _damageMultiplier - opponent.Defense);
                Console.WriteLine($""{Name} использует ДВОЙНОЙ УРОН (каждые три атаки) и наносит {doubleDamage} урона!"");
                opponent.TakeDamage(doubleDamage);
            }
            else
            {
                base.Attack(opponent);
            }
        }
    }

    class RageFighter : Fighter
    {
        private int _rage = 0;
        private int _maxRage = 100;
        private int _healingAmount = 30;
        private int _maxHealthValue = 100;

        public RageFighter(string name, int damage, int defense, int health)
            : base(""Ярость"", name, damage, defense, health, ""Получая урон накапливает ярость и лечится"") { }

        public override void TakeDamage(int damage)
        {
            base.TakeDamage(damage);
            _rage = Math.Min(_rage + damage, _maxRage);

            if (_rage == _maxRage && Health > 0)
            {
                int healedAmount = Math.Min(_healingAmount, _maxHealthValue - Health);
                Health += healedAmount;
                Console.WriteLine($""{Name} накапливает ярость и использует лечение! Восстановлено {healedAmount} здоровья. Текущее здоровье: {Health}"");
                _rage = 0;
            }
        }
    }

    class MageFighter : Fighter
    {
        private int _mana = 100;
        private int _maxMana = 100;
        private int _fireBallCost = 30;
        private int _fireBallDamageMultiplier = 2;
        private int _manaRegenerationAmount = 10;

        public MageFighter(string name, int damage, int defense, int health)
            : base(""Маг"", name, damage, defense, health, ""Использует заклинание огненный шар"") { }

        public override void Attack(Fighter opponent)
        {
            if (_mana >= _fireBallCost)
            {
                _mana -= _fireBallCost;
                int fireBallDamage = Math.Max(0, Damage * _fireBallDamageMultiplier - opponent.Defense);
                Console.WriteLine($""{Name} использует ОГНЕННЫЙ ШАР и наносит {fireBallDamage} урона! Осталось маны: {_mana}"");
                opponent.TakeDamage(fireBallDamage);
            }
            else
            {
                base.Attack(opponent);
                _mana = Math.Min(_maxMana, _mana + _manaRegenerationAmount);
                Console.WriteLine($""{Name} использует обычную атаку. Осталось маны: {_mana}"");
            }
        }
    }

    class DodgeFighter : Fighter
    {
        private const int DodgeChance = 30;
        private int _randomNumberMin = 1;
        private int _randomNumberMax = 100;

        public DodgeFighter(string name, int damage, int defense, int health)
            : base(""Уклонение"", name, damage, defense, health, ""Имеет шанс уклониться от атаки"") { }

        public override void TakeDamage(int damage)
        {
            if (UserUtils.GenerateRandomNumber(_randomNumberMin, _randomNumberMax) > DodgeChance)
            {
                base.TakeDamage(damage);
            }
            else
            {
                Console.WriteLine($""{Name} УКЛОНЯЕТСЯ от атаки!"");
            }
        }
    }

    class Arena
    {
        private List<Fighter> availableFighters = new List<Fighter>();

        public Arena()
        {
            availableFighters.AddRange(new Fighter[]
            {
                new DoubleDamageFighter(""TempleKnight"", 15, 5, 100),
                new TripleAttackFighter(""Knight"", 12, 7, 110),
                new RageFighter(""Rager"", 10, 8, 120),
                new MageFighter(""Sorcerer"", 18, 3, 90),
                new DodgeFighter(""Dodger"", 11, 6, 105),
                new BasicFighter(""Warrior"", 13, 6, 115)
            });
        }

        public void Run()
        {
            const string CommandFight = ""go"";
            const string CommandExitMenu = ""exit"";

            bool isProgramUp = true;

            while (isProgramUp)
            {
                Console.WriteLine(""Добро пожаловать на арену Колизея!"");
                Console.WriteLine($""\nВыберите действие: \n1) Введите '{CommandFight}' чтобы посмотреть бой "" +
                                  $""\n2) Введите '{CommandExitMenu}' чтобы выйти"");

                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandFight:
                        ConductFight();
                        break;

                    case CommandExitMenu:
                        isProgramUp = false;
                        break;

                    default:
                        Console.WriteLine(""Неверная команда!!!"");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }

        private void ConductFight()
        {
            Console.WriteLine(""\nСписок доступных бойцов:"");
            for (int i = 0; i < availableFighters.Count; i++)
            {
                Console.WriteLine($""{i + 1}. {availableFighters[i].Name} ({availableFighters[i].Type}) {availableFighters[i].GetShortStats()}"");
            }

            Fighter fighter1 = ChooseFighter(""первого"");
            if (fighter1 == null) return;

            Fighter fighter2 = ChooseFighter(""второго"");
            if (fighter2 == null) return;

            StartFight(fighter1, fighter2);
        }

        private Fighter ChooseFighter(string ordinalNumber)
        {
            while (true)
            {
                Console.Write($""Выберите порядковый номер {ordinalNumber} бойца: "");
                if (int.TryParse(Console.ReadLine(), out int fighterNumber))
                {
                    if (fighterNumber >= 1 && fighterNumber <= availableFighters.Count)
                    {
                        return CreateFighterCopy(availableFighters[fighterNumber - 1]);
                    }
                    else
                    {
                        Console.WriteLine(""Неверный номер бойца. Пожалуйста, выберите номер из списка."");
                    }
                }
                else
                {
                    Console.WriteLine(""Неверный ввод. Пожалуйста, введите число."");
                }
            }
        }

        private Fighter CreateFighterCopy(Fighter fighter)
        {
            if (fighter is DoubleDamageFighter)
                return new DoubleDamageFighter(fighter.Name, fighter.Damage, fighter.Defense, fighter.Health);
            if (fighter is TripleAttackFighter)
                return new TripleAttackFighter(fighter.Name, fighter.Damage, fighter.Defense, fighter.Health);
            if (fighter is RageFighter)
                return new RageFighter(fighter.Name, fighter.Damage, fighter.Defense, fighter.Health);
            if (fighter is MageFighter)
                return new MageFighter(fighter.Name, fighter.Damage, fighter.Defense, fighter.Health);
            if (fighter is DodgeFighter)
                return new DodgeFighter(fighter.Name, fighter.Damage, fighter.Defense, fighter.Health);
            if (fighter is BasicFighter)
                return new BasicFighter(fighter.Name, fighter.Damage, fighter.Defense, fighter.Health);

            return null;
        }

        private void StartFight(Fighter fighter1, Fighter fighter2)
        {
            Console.WriteLine(""\n=== Начинается бой! ==="");
            Console.WriteLine($""Боец 1: {fighter1.Name} ({fighter1.Type})"");
            Console.WriteLine($""Боец 2: {fighter2.Name} ({fighter2.Type})"");

            int round = 1;

            while (fighter1.IsAlive() && fighter2.IsAlive())
            {
                Console.WriteLine($""\n--- Раунд {round} ---"");

                fighter1.Attack(fighter2);
                if (!fighter2.IsAlive())
                {
                    Console.WriteLine($""{fighter2.Name} повержен!"");
                    break;
                }

                fighter2.Attack(fighter1);
                if (!fighter1.IsAlive())
                {
                    Console.WriteLine($""{fighter1.Name} повержен!"");
                    break;
                }

                Console.WriteLine($""\nСтатистика после раунда {round}:"");
                Console.WriteLine($""  {fighter1.Name}: Здоровье = {fighter1.Health}"");
                Console.WriteLine($""  {fighter2.Name}: Здоровье = {fighter2.Health}"");

                Console.WriteLine(""\nНажмите любую клавишу для продолжения..."");
                Console.ReadKey();
                Console.Clear();
                round++;
            }

            Console.WriteLine(""\n=== Бой окончен! ==="");
            if (fighter1.IsAlive())
            {
                Console.WriteLine($""Победил {fighter1.Name}!"");
            }
            else if (fighter2.IsAlive())
            {
                Console.WriteLine($""Победил {fighter2.Name}!"");
            }
            else
            {
                Console.WriteLine(""Ничья!"");
            }

            Console.ReadKey();
        }
    }

    public static class UserUtils
    {
        private static Random s_random = new Random();

        public static int GenerateRandomNumber(int min, int max)
        {
            return s_random.Next(min, max + 1);
        }
    }
}"
VKWV04bF,AmmoLimiter.reds,SoulfateOriginal,Lua,Wednesday 23rd of July 2025 02:12:29 PM CDT,"import Codeware.Localization.*

// ### SYSTÈME DE CACHE ###
public abstract class ALDataCache{
	public static func GetCachedALData(ammoType:String,config:ref<AmmoLimiterConfig>) -> ref<ALData>{
		let cache=ALDataCache.EnsureCache();
		let configHash=ALDataCache.GetConfigHash(config);
		let key:Uint64=TDBID.ToNumber(TDBID.Create(ammoType+""_""+configHash));
		if cache.KeyExist(key){return cache.Get(key) as ALData;}
		let data=ALUtils.GetALData(ammoType,config);
		cache.Insert(key,data);
		return data;
	}

	private static func GetConfigHash(config:ref<AmmoLimiterConfig>) -> String{
		let hash:String="""";
		hash+=ToString(config.handModeSelected);
		hash+=""_""+IntToString(config.ammoLimitHandgun);
		hash+=""_""+IntToString(config.ammoLimitRifle);
		hash+=""_""+IntToString(config.ammoLimitShotgun);
		hash+=""_""+IntToString(config.ammoLimitSniper);
		hash+=""_""+IntToString(config.ammoBoxHandgun);
		hash+=""_""+IntToString(config.ammoBoxRifle);
		hash+=""_""+IntToString(config.ammoBoxShotgun);
		hash+=""_""+IntToString(config.ammoBoxSniper);
		hash+=""_""+FloatToString(config.ammoWeightHandgun);
		hash+=""_""+FloatToString(config.ammoWeightRifle);
		hash+=""_""+FloatToString(config.ammoWeightShotgun);
		hash+=""_""+FloatToString(config.ammoWeightSniper);
		hash+=""_""+FloatToString(config.ammoPriceHandgun);
		hash+=""_""+FloatToString(config.ammoPriceRifle);
		hash+=""_""+FloatToString(config.ammoPriceShotgun);
		hash+=""_""+FloatToString(config.ammoPriceSniper);
		return hash;
	}

	private static func EnsureCache() -> ref<inkHashMap>{
		let gameInstance=GetGameInstance();
		let system=gameInstance.GetScriptableSystemsContainer().Get(n""ALSystem"") as ALSystem;
		return system.GetCache();
	}
}


// ### UTILITAIRES ###
public class ALData extends IScriptable{
	public let ammoTDBID:TweakDBID;
	public let limit:Int32;
	public let ammoBox:Int32;
	public let handLimit:Int32;
	public let handMin:Int32;
	public let handMax:Int32;
	public let ammoWeight:Float;
	public let priceMult:Float;
	public let ammoConv:Float;
	public let ammoCraft:Int32;
}

public class ALUtils{
	public static func GetAmmoTypeNames() -> array<String>{return [""Handgun"",""Rifle"",""Shotgun"",""SniperRifle""];}

	public static func GetAmmoTDBID(ammoType:String) -> TweakDBID{return TDBID.Create(""Ammo.""+ammoType+""Ammo"");}

	public static func GetAmmoTypeFromID(ammoType:ItemID) -> String{
		let fullName=TDBID.ToStringDEBUG(ItemID.GetTDBID(ammoType));
		return !StrBeginsWith(fullName,""Ammo."")?"""":StrEndsWith(fullName,""Ammo"") && StrLen(fullName)>9?StrMid(fullName,5,StrLen(fullName)-9):StrMid(fullName,5);
	}

	public static func GetAmmoTypeFromWeaponType(weaponType:gamedataItemType) -> String{
		switch weaponType{
			case gamedataItemType.Wea_Handgun:
			case gamedataItemType.Wea_Revolver:
			case gamedataItemType.Wea_SubmachineGun:
				return ""Handgun"";
			case gamedataItemType.Wea_AssaultRifle:
			case gamedataItemType.Wea_Rifle:
			case gamedataItemType.Wea_LightMachineGun:
			case gamedataItemType.Wea_HeavyMachineGun:
				return ""Rifle"";
			case gamedataItemType.Wea_Shotgun:
			case gamedataItemType.Wea_ShotgunDual:
				return ""Shotgun"";
			case gamedataItemType.Wea_SniperRifle:
			case gamedataItemType.Wea_PrecisionRifle:
				return ""SniperRifle"";
			default:
				return """";
		}
	}

	public static func GetActiveWeaponAmmoType(player:ref<PlayerPuppet>) -> String{
		let weapon=GameInstance.GetTransactionSystem(player.GetGame()).GetItemInSlot(player,t""AttachmentSlots.WeaponRight"") as WeaponObject;
		return IsDefined(weapon)?ALUtils.GetAmmoTypeFromID(WeaponObject.GetAmmoType(weapon)):"""";
	}

	public static func GetALData(ammoType:String,config:ref<AmmoLimiterConfig>) -> ref<ALData>{
		let data=new ALData();
		data.ammoTDBID=ALUtils.GetAmmoTDBID(ammoType);
		switch ammoType{
			case ""Handgun"":
				data.limit=config.ammoLimitHandgun;
				data.ammoBox=config.ammoBoxHandgun;
				data.handLimit=config.handLimitHandgun;
				data.handMin=config.handMinHandgun;
				data.handMax=config.handMaxHandgun;
				data.ammoWeight=config.ammoWeightHandgun;
				data.priceMult=config.ammoPriceHandgun;
				data.ammoConv=Cast<Float>(config.craftingCompForAmmo)/Cast<Float>(config.ammoCraftHandgun)*Cast<Float>(config.ammoConversionRate);
				data.ammoCraft=config.ammoCraftHandgun;
				break;
			case ""Rifle"":
				data.limit=config.ammoLimitRifle;
				data.ammoBox=config.ammoBoxRifle;
				data.handLimit=config.handLimitRifle;
				data.handMin=config.handMinRifle;
				data.handMax=config.handMaxRifle;
				data.ammoWeight=config.ammoWeightRifle;
				data.priceMult=config.ammoPriceRifle;
				data.ammoConv=Cast<Float>(config.craftingCompForAmmo)/Cast<Float>(config.ammoCraftRifle)*Cast<Float>(config.ammoConversionRate);
				data.ammoCraft=config.ammoCraftRifle;
				break;
			case ""Shotgun"":
				data.limit=config.ammoLimitShotgun;
				data.ammoBox=config.ammoBoxShotgun;
				data.handLimit=config.handLimitShotgun;
				data.handMin=config.handMinShotgun;
				data.handMax=config.handMaxShotgun;
				data.ammoWeight=config.ammoWeightShotgun;
				data.priceMult=config.ammoPriceShotgun;
				data.ammoConv=Cast<Float>(config.craftingCompForAmmo)/Cast<Float>(config.ammoCraftShotgun)*Cast<Float>(config.ammoConversionRate);
				data.ammoCraft=config.ammoCraftShotgun;
				break;
			case ""SniperRifle"":
				data.limit=config.ammoLimitSniper;
				data.ammoBox=config.ammoBoxSniper;
				data.handLimit=config.handLimitSniper;
				data.handMin=config.handMinSniper;
				data.handMax=config.handMaxSniper;
				data.ammoWeight=config.ammoWeightSniper;
				data.priceMult=config.ammoPriceSniper;
				data.ammoConv=Cast<Float>(config.craftingCompForAmmo)/Cast<Float>(config.ammoCraftSniper)*Cast<Float>(config.ammoConversionRate);
				data.ammoCraft=config.ammoCraftSniper;
				break;
		}
		return data;
	}
}

// ### SYSTÈME DE MESSAGE ###
@addMethod(PlayerPuppet)
private func ALMessage(message:String) -> Void{
	let blackboard=GameInstance.GetBlackboardSystem(this.GetGame()).Get(GetAllBlackboardDefs().UI_Notifications);
	if IsDefined(blackboard){
		let msg:SimpleScreenMessage;
		msg.isShown=true;
		msg.message=message;
		blackboard.SetVariant(GetAllBlackboardDefs().UI_Notifications.OnscreenMessage,ToVariant(msg),true);
	}
}

// ### SYSTÈME D’INITIALISATION ###
public class ALDelayCallback extends DelayCallback{
	let m_system:wref<ALSystem>;

	public static func Create(system:ref<ALSystem>) -> ref<ALDelayCallback>{
		let callback=new ALDelayCallback();
		callback.m_system=system;
		return callback;
	}

	public func Call() -> Void{if IsDefined(this.m_system){this.m_system.ApplyAmmoConfig();}}
}

public class ALSystem extends ScriptableSystem{
	private let config:ref<AmmoLimiterConfig>;
	private let m_cache:ref<inkHashMap>;

	public static func GetConfig() -> ref<AmmoLimiterConfig>{
		let gameInstance=GetGameInstance();
		let alSystem=gameInstance.GetScriptableSystemsContainer().Get(n""ALSystem"") as ALSystem;
		if !IsDefined(alSystem.config){
			alSystem.config=new AmmoLimiterConfig();
		}
		return alSystem.config;
	}

	private func OnAttach(){
		this.m_cache=new inkHashMap();
		this.config=new AmmoLimiterConfig();
		this.ApplyAmmoConfig();
		GameInstance.GetCallbackSystem().RegisterCallback(n""Session/Start"",this,n""OnSessionStart"");
	}

	public func GetCache() -> ref<inkHashMap>{return this.m_cache;}

	public final func OnSessionStart(evt:ref<GameSessionEvent>) -> Void{GameInstance.GetDelaySystem(this.GetGameInstance()).DelayCallback(ALDelayCallback.Create(this),0.075);}

	public final func ApplyAmmoConfig() -> Void{
		this.config=ALSystem.GetConfig();
		let ammoTypes=ALUtils.GetAmmoTypeNames();
		this.CreateAndApplyAmmoMods(this.config,ammoTypes);
		this.ApplyHandSys(this.config,ammoTypes);
		this.ApplyAmmoBoxQties(this.config);
	}

	private final func CreateAndApplyAmmoMods(config:ref<AmmoLimiterConfig>,ammoTypes:array<String>) -> Void{
		for ammoType in ammoTypes{
			let ammoData=ALDataCache.GetCachedALData(ammoType,config);
			let basePath=""AmmoLimiter.""+ammoType;
			let buyModID=TDBID.Create(basePath+"".buyPrice"");
			let sellModID=TDBID.Create(basePath+"".sellPrice"");
			let weightModID=TDBID.Create(basePath+"".statModifiers"");
			let quantityModID=TDBID.Create(basePath+"".quantity"");
			TweakDBManager.CreateRecord(StringToName(basePath),n""gamedataItem_Record"");
			TweakDBManager.CreateRecord(StringToName(basePath+"".buyPrice""),n""gamedataConstantStatModifier_Record"");
			TweakDBManager.CreateRecord(StringToName(basePath+"".sellPrice""),n""gamedataConstantStatModifier_Record"");
			TweakDBManager.CreateRecord(StringToName(basePath+"".statModifiers""),n""gamedataConstantStatModifier_Record"");
			TweakDBManager.CreateRecord(StringToName(basePath+"".quantity""),n""gamedataConstantStatModifier_Record"");
			TweakDBManager.SetFlat(quantityModID+t"".modifierType"",n""Additive"");
			TweakDBManager.SetFlat(quantityModID+t"".statType"",t""BaseStats.Quantity"");
			TweakDBManager.SetFlat(quantityModID+t"".value"",9999.0);
			TweakDBManager.SetFlat(buyModID+t"".modifierType"",n""Multiplier"");
			TweakDBManager.SetFlat(buyModID+t"".statType"",t""BaseStats.Price"");
			TweakDBManager.SetFlat(buyModID+t"".value"",ammoData.priceMult);
			TweakDBManager.SetFlat(sellModID+t"".modifierType"",n""Multiplier"");
			TweakDBManager.SetFlat(sellModID+t"".statType"",t""BaseStats.Price"");
			TweakDBManager.SetFlat(sellModID+t"".value"",ammoData.priceMult/3.0);
			TweakDBManager.SetFlat(weightModID+t"".modifierType"",n""Additive"");
			TweakDBManager.SetFlat(weightModID+t"".statType"",t""BaseStats.Weight"");
			TweakDBManager.SetFlat(weightModID+t"".value"",ammoData.ammoWeight);
			TweakDBManager.SetFlat(ammoData.ammoTDBID+t"".buyPrice"",[t""Price.Ammo"",t""Price.BuyPrice_StreetCred_Discount"",buyModID]);
			TweakDBManager.SetFlat(ammoData.ammoTDBID+t"".sellPrice"",[t""Price.Ammo"",sellModID]);
			TweakDBManager.SetFlat(ammoData.ammoTDBID+t"".statModifiers"",[quantityModID,weightModID]);
			TweakDBManager.SetFlat(ammoData.ammoTDBID+t"".objectActions"",[t""ItemAction.Drop"",t""ItemAction.Disassemble""]);
			TweakDBManager.UpdateRecord(buyModID);
			TweakDBManager.UpdateRecord(sellModID);
			TweakDBManager.UpdateRecord(weightModID);
			TweakDBManager.UpdateRecord(quantityModID);
			TweakDBManager.UpdateRecord(ammoData.ammoTDBID);
		}
	}

	private final func ApplyHandSys(config:ref<AmmoLimiterConfig>,ammoTypes:array<String>) -> Void{
		for ammoType in ammoTypes{
			let ammoData=ALDataCache.GetCachedALData(ammoType,config);
			let recordID=TDBID.Create(""Ammo.Handicap""+ammoType+""AmmoPreset"");
			let limit=Equals(config.handModeSelected,handMode.Disabled)?99999:Equals(config.handModeSelected,handMode.Optimized)?ammoData.limit:ammoData.handLimit;
			let min=Equals(config.handModeSelected,handMode.Disabled)?0:Equals(config.handModeSelected,handMode.Optimized)?0:ammoData.handMin;
			let max=Equals(config.handModeSelected,handMode.Disabled)?0:Equals(config.handModeSelected,handMode.Optimized)?ammoData.limit/10:ammoData.handMax;
			TweakDBManager.SetFlat(recordID+t"".handicapLimit"",limit);
			TweakDBManager.SetFlat(recordID+t"".handicapMinQty"",min);
			TweakDBManager.SetFlat(recordID+t"".handicapMaxQty"",max);
			TweakDBManager.UpdateRecord(recordID);
		}
	}

	private final func ApplyAmmoBoxQties(config:ref<AmmoLimiterConfig>) -> Void{
		let mappings=[
			[""Handgun"",""AmmoLootTable_inline0""],
			[""Shotgun"",""AmmoLootTable_inline1""], 
			[""Rifle"",""AmmoLootTable_inline2""],
			[""SniperRifle"",""AmmoLootTable_inline3""]
		];
		let i:Int32=0;
		while i<ArraySize(mappings){
			let ammoType=mappings[i][0];
			let lootTableID=mappings[i][1];
			let ammoData=ALDataCache.GetCachedALData(ammoType,config);
			let recordID=TDBID.Create(""Ammo.""+lootTableID);
			TweakDBManager.SetFlat(recordID+t"".dropCountMin"",ammoData.ammoBox/2);
			TweakDBManager.SetFlat(recordID+t"".dropCountMax"",ammoData.ammoBox);
			TweakDBManager.UpdateRecord(recordID);
			i+=1;
		}
	}
}

// ### SYSTÈME DE RAMASSAGE ###
@wrapMethod(PlayerPuppet)
protected cb func OnItemChangedEvent(evt:ref<ItemChangedEvent>) -> Bool{
	let result=wrappedMethod(evt);
	if evt.difference==0{return result;}
	if !ItemID.IsValid(evt.itemID) || GameInstance.GetBlackboardSystem(this.GetGame()).Get(GetAllBlackboardDefs().UI_System).GetBool(GetAllBlackboardDefs().UI_System.IsInMenu){return result;}
	if !Equals(TweakDBInterface.GetItemRecord(ItemID.GetTDBID(evt.itemID)).ItemType().Type(),gamedataItemType.Con_Ammo){return result;}
	let ammoType=ALUtils.GetAmmoTypeFromID(evt.itemID);
	if Equals(ammoType,""""){return result;}
	let config=ALSystem.GetConfig();
	let ammoData=ALDataCache.GetCachedALData(ammoType,config);
	let transactionSystem=GameInstance.GetTransactionSystem(GetGameInstance());
	let curAmount=transactionSystem.GetItemQuantity(this,evt.itemID);
	let effectiveLimit:Int32;
	let isActiveAmmo=Equals(ammoType,ALUtils.GetActiveWeaponAmmoType(this));
	if config.sleepingAmmoControl && !isActiveAmmo{
		let addedAmount=evt.difference;
		let preAmount=curAmount-addedAmount;
		effectiveLimit=preAmount;
	}else if isActiveAmmo && config.activeWeaponBonus>100{effectiveLimit=(ammoData.limit*config.activeWeaponBonus)/100;}else{effectiveLimit=ammoData.limit;}
	if curAmount<=effectiveLimit{return result;}
	let excess=curAmount-effectiveLimit;
	if ammoData.ammoConv==0.0 && config.autoSell==0{
		GameInstance.GetLootManager(GetGameInstance()).SpawnItemDropOfManyItems(this,[DropInstruction.Create(evt.itemID,excess)],n""playerDropBag"",this.GetWorldPosition());
		if config.messageDisplay{this.ALMessage(ToString(excess)+"" ""+GetLocalizedTextByKey(TweakDBInterface.GetItemRecord(ItemID.GetTDBID(evt.itemID)).DisplayName())+"" ""+GetLocalizedTextByKey(n""AmmoLimiter-Message-Dropped"")+""."");}
	}else{
		let totalComp=ammoData.ammoConv>0.0?Cast<Int32>(Cast<Float>(excess)*ammoData.ammoConv*0.01):0;
		let totalEddies=config.autoSell>0?Cast<Int32>(Cast<Float>(excess*3*config.autoSell)*ammoData.priceMult*0.01):0;
		if totalComp==0 && totalEddies==0{return result;}
		let actualExcess=totalComp>0?Cast<Int32>(Cast<Float>(totalComp)/ammoData.ammoConv*100.0):excess;
		transactionSystem.RemoveItem(this,evt.itemID,actualExcess);
		let msg=config.messageDisplay?ToString(actualExcess)+"" ""+GetLocalizedTextByKey(TweakDBInterface.GetItemRecord(ItemID.GetTDBID(evt.itemID)).DisplayName())+"" ""+GetLocalizedTextByKey(n""AmmoLimiter-Message-Crafted"")+"" "":"""";
		if totalComp>0{
			transactionSystem.GiveItem(this,ItemID.FromTDBID(t""Items.CommonMaterial1""),totalComp,[n""AmmoLimiter""]);
			if config.messageDisplay{msg+=ToString(totalComp)+"" ""+GetLocalizedTextByKey(TweakDBInterface.GetItemRecord(t""Items.CommonMaterial1"").DisplayName());}
		}
		if totalEddies>0{
			transactionSystem.GiveItem(this,ItemID.FromTDBID(t""Items.money""),totalEddies,[n""AmmoLimiter""]);
			if config.messageDisplay{msg+=(totalComp>0?""\\n+ "":"""")+ToString(totalEddies)+"" €$"";}
		}
		if config.messageDisplay{this.ALMessage(msg+""."");}
	}
	return result;
}

// ### SYSTÈME DE DÉMONTAGE ###
@wrapMethod(RPGManager)
public final static func CanItemBeDisassembled(gameInstance:GameInstance,itemData:wref<gameItemData>) -> Bool{
	let config=ALSystem.GetConfig();
	return IsDefined(itemData) && config.ammoDisassDisabled && itemData.HasTag(n""Ammo"")?false:wrappedMethod(gameInstance,itemData);
}

@wrapMethod(DisassembleAction)
public func CompleteAction(gameInstance:GameInstance) -> Void{
	let itemData=this.GetItemData();
	let config=ALSystem.GetConfig();
	let executor=this.GetExecutor();
	wrappedMethod(gameInstance);
	if config.ammoDisass>0 && IsDefined(executor) && IsDefined(itemData){
		let player=executor as PlayerPuppet;
		if !IsDefined(player){return;}
		let record=TweakDBInterface.GetItemRecord(ItemID.GetTDBID(itemData.GetID())) as WeaponItem_Record;
		if !IsDefined(record){return;}
		let maxAmmo=Cast<Int32>(GameInstance.GetStatsSystem(gameInstance).GetStatValue(Cast<StatsObjectID>(itemData.GetID()),gamedataStatType.MagazineCapacityBase))*config.ammoDisass/100;
		if maxAmmo<=0{return;}
		let ammoData=ALDataCache.GetCachedALData(ALUtils.GetAmmoTypeFromWeaponType(record.ItemType().Type()),config);
		if Equals(ammoData.ammoTDBID,t""""){return;}
		let ammoAmount=RandRange(0,maxAmmo+1);
		if ammoAmount>0{
			GameInstance.GetTransactionSystem(gameInstance).GiveItem(player,ItemID.FromTDBID(ammoData.ammoTDBID),ammoAmount);
			if config.messageDisplay{player.ALMessage(GetLocalizedTextByKey(n""AmmoLimiter-Message-Recovered"")+"" ""+ToString(ammoAmount)+"" ""+GetLocalizedTextByKey(TweakDBInterface.GetItemRecord(ammoData.ammoTDBID).DisplayName())+""."");}
		}
	}
}

@wrapMethod(CraftingSystem)
private func OnDisassembleItemRequest(request:ref<DisassembleItemRequest>) -> Void{
	let config=ALSystem.GetConfig();
	let itemData=GameInstance.GetTransactionSystem(this.GetGameInstance()).GetItemData(request.target,request.itemID);
	if IsDefined(itemData) && itemData.HasTag(n""Ammo""){
		let originalAmount=request.amount;
		for ammoType in ALUtils.GetAmmoTypeNames(){
			if Equals(ItemID.GetTDBID(itemData.GetID()),ALUtils.GetAmmoTDBID(ammoType)){
				let ammoData=ALDataCache.GetCachedALData(ammoType,config);
				let ammoPerComp=Cast<Float>(ammoData.ammoCraft)/Cast<Float>(config.craftingCompForAmmo);
				let requestedComps=FloorF(Cast<Float>(originalAmount)/ammoPerComp);
				if requestedComps>=1{
					let exactFloat=Cast<Float>(requestedComps)*ammoPerComp;
					let exactInt=Cast<Int32>(exactFloat);
					if Cast<Float>(exactInt)==exactFloat{request.amount=exactInt;}else{request.amount=requestedComps*CeilF(ammoPerComp);}
				}else{request.amount=0;}
				if request.amount>0{
					let removedEvent=new ItemBeingRemovedEvent();
					removedEvent.itemID=request.itemID;
					removedEvent.itemData=itemData;
					removedEvent.difference=request.amount;
					removedEvent.currentQuantity=0;
					let player=GameInstance.GetPlayerSystem(this.GetGameInstance()).GetLocalPlayerMainGameObject() as PlayerPuppet;
					player.QueueEvent(removedEvent);
				}
				break;
			}
		}
	}
	wrappedMethod(request);
}

@wrapMethod(CraftingSystem)
private func DisassembleItem(target:wref<GameObject>,itemID:ItemID,quantity:Int32) -> Void{
	let itemData=GameInstance.GetTransactionSystem(this.GetGameInstance()).GetItemData(target,itemID);
	if IsDefined(itemData) && itemData.HasTag(n""Ammo""){
		let config=ALSystem.GetConfig();
		for ammoType in ALUtils.GetAmmoTypeNames(){
			if Equals(ItemID.GetTDBID(itemData.GetID()),ALUtils.GetAmmoTDBID(ammoType)){
				let restoredAttachments:array<ItemAttachments>;
				let vanillaResults=this.GetDisassemblyResultItems(target,itemID,1,restoredAttachments);
				if ArraySize(vanillaResults)>0{
					let ammoData=ALDataCache.GetCachedALData(ammoType,config);
					let correctComps=Cast<Int32>(Cast<Float>(quantity*config.craftingCompForAmmo)/Cast<Float>(ammoData.ammoCraft));
					GameInstance.GetTelemetrySystem(this.GetGameInstance()).LogItemDisassembled(target,itemID);
					let listOfIngredients:array<IngredientData>;
					if correctComps>0{
						GameInstance.GetTransactionSystem(this.GetGameInstance()).RemoveItem(target,itemID,quantity);
						GameInstance.GetTransactionSystem(this.GetGameInstance()).GiveItem(target,ItemID.FromTDBID(vanillaResults[0].id.GetID()),correctComps);
						let ingredient:IngredientData;
						ingredient.id=vanillaResults[0].id;
						ingredient.quantity=correctComps;
						ArrayPush(listOfIngredients,ingredient);
					}
					let Blackboard:ref<IBlackboard>=GameInstance.GetBlackboardSystem(this.GetGameInstance()).Get(GetAllBlackboardDefs().UI_Crafting);
					if IsDefined(Blackboard){
						Blackboard.SetVariant(GetAllBlackboardDefs().UI_Crafting.lastCommand,ToVariant(CraftingCommands.DisassemblingFinished),true);
						Blackboard.SetVariant(GetAllBlackboardDefs().UI_Crafting.lastItem,ToVariant(itemID),true);
						if ArraySize(listOfIngredients)>0{Blackboard.SetVariant(GetAllBlackboardDefs().UI_Crafting.lastIngredients,ToVariant(listOfIngredients),true);}
					}
					return;
				}
			}
		}
	}
	wrappedMethod(target,itemID,quantity);
}

// ### FILTRES D’INVENTAIRE ###
@wrapMethod(ItemCategoryFliter)
public final static func FilterItem(filter:ItemFilterCategory,wrappedData:ref<WrappedInventoryItemData>) -> Bool{
	if IsDefined(wrappedData.Item) && Equals(wrappedData.Item.GetItemType(),gamedataItemType.Con_Ammo){
		let ammoCat=ALSystem.GetConfig().ammoCategorySelected;
		return (Equals(ammoCat,ammoCategory.RangedWeapons) && (Equals(filter,ItemFilterCategory.RangedWeapons) || Equals(filter,ItemFilterCategory.AllItems))) || (Equals(ammoCat,ammoCategory.Attachments) && (Equals(filter,ItemFilterCategory.Attachments) || Equals(filter,ItemFilterCategory.AllItems))) || (Equals(ammoCat,ammoCategory.Consumables) && (Equals(filter,ItemFilterCategory.Consumables) || Equals(filter,ItemFilterCategory.Grenades) || Equals(filter,ItemFilterCategory.AllItems)));
	}
	return wrappedMethod(filter,wrappedData);
}

@wrapMethod(CraftingMainLogicController)
protected func SetupFilters() -> Void{
	let ammoCat=ALSystem.GetConfig().ammoCategorySelected;
	if Equals(ammoCat,ammoCategory.RangedWeapons){ArrayPush(this.m_filters,EnumInt(ItemFilterCategory.RangedWeapons));}else if Equals(ammoCat,ammoCategory.Attachments){ArrayPush(this.m_filters,EnumInt(ItemFilterCategory.Attachments));}else if Equals(ammoCat,ammoCategory.Consumables){ArrayPush(this.m_filters,EnumInt(ItemFilterCategory.Consumables));}
	wrappedMethod();
}

@wrapMethod(CraftingDataView)
public func FilterItem(data:ref<IScriptable>) -> Bool{
	let shouldShow=wrappedMethod(data);
	if shouldShow{return true;}
	let recipeData=data as RecipeData;
	if IsDefined(recipeData){
		let itemType=TweakDBInterface.GetItemRecord(recipeData.id.GetID()).ItemType().Type();
		if !Equals(itemType,gamedataItemType.Con_Ammo){return false;}
		let ammoCat=ALSystem.GetConfig().ammoCategorySelected;
		let currentFilter=this.GetFilterType();
		return (Equals(ammoCat,ammoCategory.RangedWeapons) && (Equals(currentFilter,ItemFilterCategory.RangedWeapons) || Equals(currentFilter,ItemFilterCategory.AllItems))) || (Equals(ammoCat,ammoCategory.Attachments) && (Equals(currentFilter,ItemFilterCategory.Attachments) || Equals(currentFilter,ItemFilterCategory.AllItems))) || (Equals(ammoCat,ammoCategory.Consumables) && (Equals(currentFilter,ItemFilterCategory.Consumables) || Equals(currentFilter,ItemFilterCategory.AllItems)));
	}
	return false;
}

// ### AFFICHAGE DES MUNITIONS DANS L’INVENTAIRE ###
@wrapMethod(UIInventoryItemsManager)
public final static func GetBlacklistedTags() -> array<CName>{
	let filteredTags=wrappedMethod();
	ArrayRemove(filteredTags,n""Ammo"");
	return filteredTags;
}

// ### SYSTÈME DE FABRICATION ###
@wrapMethod(CraftingSystem)
public final static func GetAmmoBulletAmount(ammoId:TweakDBID) -> Int32{
	let ammoType=ALUtils.GetAmmoTypeFromID(ItemID.FromTDBID(ammoId));
	return !Equals(ammoType,"""")?ALDataCache.GetCachedALData(ammoType,ALSystem.GetConfig()).ammoCraft:wrappedMethod(ammoId);
}

@wrapMethod(CraftingSystem)
public final const func GetMaxCraftingAmount(itemData:wref<gameItemData>) -> Int32{
	let itemRecord=TweakDBInterface.GetItemRecord(ItemID.GetTDBID(itemData.GetID()));
	if !itemRecord.TagsContains(n""Ammo""){return wrappedMethod(itemData);}
	let config=ALSystem.GetConfig();
	let ammoData=ALDataCache.GetCachedALData(ALUtils.GetAmmoTypeFromID(itemData.GetID()),config);
	let owner=this.m_playerCraftBook.GetOwner();
	let transactionSystem=GameInstance.GetTransactionSystem(this.GetGameInstance());
	let materialQuantity=transactionSystem.GetItemQuantity(owner,ItemID.FromTDBID(t""Items.CommonMaterial1""));
	let currentQuantity=transactionSystem.GetItemQuantity(owner,itemData.GetID());
	let materialLimit=materialQuantity>=config.craftingCompForAmmo?materialQuantity/config.craftingCompForAmmo:0;
	let ammoLimit:Int32;
	if currentQuantity+ammoData.ammoCraft<=ammoData.limit{ammoLimit=(ammoData.limit-currentQuantity)/ammoData.ammoCraft;}else{ammoLimit=9999;}
	return Max(Min(materialLimit,ammoLimit),0);
}

@wrapMethod(CraftingSystem)
public final const func CanItemBeCrafted(itemData:wref<gameItemData>) -> Bool{
	if !TweakDBInterface.GetItemRecord(ItemID.GetTDBID(itemData.GetID())).TagsContains(n""Ammo""){return wrappedMethod(itemData);}
	let config=ALSystem.GetConfig();
	let ammoData=ALDataCache.GetCachedALData(ALUtils.GetAmmoTypeFromID(itemData.GetID()),config);
	let transactionSystem=GameInstance.GetTransactionSystem(this.GetGameInstance());
	let owner=this.m_playerCraftBook.GetOwner();
	if !this.HasIngredients(this.GetItemCraftingCost(itemData)){return false;}
	if config.strictLimitation{
		let currentQuantity=transactionSystem.GetItemQuantity(owner,itemData.GetID());
		if currentQuantity+ammoData.ammoCraft>ammoData.limit{return false;}
	}
	return true;
}

@wrapMethod(CraftingSystem)
private final func CraftItem(target:wref<GameObject>,itemRecord:ref<Item_Record>,amount:Int32,opt ammoBulletAmount:Int32) -> wref<gameItemData>{
	let isAmmo=itemRecord.TagsContains(n""Ammo"");
	if isAmmo{
		let config=ALSystem.GetConfig();
		let ammoType=ALUtils.GetAmmoTypeFromID(ItemID.FromTDBID(itemRecord.GetID()));
		let ammoData=ALDataCache.GetCachedALData(ammoType,config);
		let transactionSystem=GameInstance.GetTransactionSystem(this.GetGameInstance());
		let craftedItemID=ItemID.FromTDBID(itemRecord.GetID());
		transactionSystem.RemoveItemByTDBID(target,t""Items.CommonMaterial1"",config.craftingCompForAmmo*amount,true);
		let finalAmmoAmount=amount*ammoData.ammoCraft;
		transactionSystem.GiveItem(target,craftedItemID,finalAmmoAmount);
		this.ProcessCraftSkill(Cast<Float>(TweakDBInterface.GetInt(t""Constants.CraftingSystem.commonIngredientXP"",10)*amount));
		let itemData=transactionSystem.GetItemData(target,craftedItemID);
		if IsDefined(itemData){
			this.SetItemLevel(itemData);
			this.MarkItemAsCrafted(itemData);
		}
		this.SendItemCraftedDataTrackingRequest(craftedItemID,finalAmmoAmount);
		return itemData;
	}
	return wrappedMethod(target,itemRecord,amount,ammoBulletAmount);
}

// ### SYSTÈME DE PICKER ###
@wrapMethod(ItemQuantityPickerController)
private func SetData() -> Void{
	wrappedMethod();
	if IsDefined(this.m_data){
		let itemID=InventoryItemData.GetID(this.m_data.gameItemData);
		if Equals(TweakDBInterface.GetItemRecord(ItemID.GetTDBID(itemID)).ItemType().Type(),gamedataItemType.Con_Ammo){
			let ammoType=ALUtils.GetAmmoTypeFromID(itemID);
			let ammoData=ALDataCache.GetCachedALData(ammoType,ALSystem.GetConfig());
			this.UpdateAmmoDisplay(this.m_data.maxValue,ammoType,ammoData);
		}
	}
}

@wrapMethod(ItemQuantityPickerController)
protected cb func OnSliderValueChanged(sliderController:wref<inkSliderController>,progress:Float,value:Float) -> Bool{
	let result=wrappedMethod(sliderController,progress,value);
	if IsDefined(this.m_data){
		let itemID=InventoryItemData.GetID(this.m_data.gameItemData);
		if Equals(TweakDBInterface.GetItemRecord(ItemID.GetTDBID(itemID)).ItemType().Type(),gamedataItemType.Con_Ammo){
			let ammoType=ALUtils.GetAmmoTypeFromID(itemID);
			this.UpdateAmmoDisplay(Cast<Int32>(value),ammoType,ALDataCache.GetCachedALData(ammoType,ALSystem.GetConfig()));
		}
	}
	return result;
}

@wrapMethod(ItemQuantityPickerController)
protected final func UpdateProgress() -> Void{
	wrappedMethod();
	if IsDefined(this.m_data){
		let itemID=InventoryItemData.GetID(this.m_data.gameItemData);
		if Equals(TweakDBInterface.GetItemRecord(ItemID.GetTDBID(itemID)).ItemType().Type(),gamedataItemType.Con_Ammo){
			let ammoType=ALUtils.GetAmmoTypeFromID(itemID);
			this.UpdateAmmoDisplay(this.m_choosenQuantity,ammoType,ALDataCache.GetCachedALData(ammoType,ALSystem.GetConfig()));
		}
	}
}

@addMethod(ItemQuantityPickerController)
private func UpdateAmmoDisplay(batchCount:Int32,ammoType:String,ammoData:ref<ALData>) -> Void{
	if Equals(ammoType,""""){return;}
	let originalName=inkTextRef.GetText(this.m_itemNameText);
	let parenPos=StrFindFirst(originalName,"" ("");
	let cleanName=parenPos>0?StrLeft(originalName,parenPos):originalName;
	inkTextRef.SetText(this.m_itemNameText,cleanName+"" (""+IntToString(batchCount*ammoData.ammoCraft)+"" ""+GetLocalizedTextByKey(n""AmmoLimiter-UI-Total"")+"")"");
	let totalWeight=Cast<Float>(batchCount)*ammoData.ammoWeight*Cast<Float>(ammoData.ammoCraft);
	inkTextRef.SetText(this.m_weightText,FloatToStringPrec(totalWeight,2)+"" (""+FloatToStringPrec(ammoData.ammoWeight,3)+"" ""+GetLocalizedTextByKey(n""AmmoLimiter-UI-Unit"")+"")"");
}

// ### SYSTÈME D'AVERTISSEMENT ###
public static func CheckAndNotifyLowAmmo(player:ref<PlayerPuppet>,weapon:ref<WeaponObject>) -> Void{
	let config=ALSystem.GetConfig();
	if config.ammoLowWarning==0{return;}
	let ammoID=WeaponObject.GetAmmoType(weapon);
	let ammoType=ALUtils.GetAmmoTypeFromID(ammoID);
	if Equals(ammoType,""""){return;}
	let ammoData=ALDataCache.GetCachedALData(ammoType,config);
	let warningThreshold=Cast<Int32>(Cast<Float>(ammoData.limit)*Cast<Float>(config.ammoLowWarning)/100.0);
	let transactionSystem=GameInstance.GetTransactionSystem(player.GetGame());
	let currentAmmo=transactionSystem.GetItemQuantity(player,ammoID);
	if currentAmmo<=warningThreshold && currentAmmo>0{
		let ammoName=GetLocalizedTextByKey(TweakDBInterface.GetItemRecord(ItemID.GetTDBID(ammoID)).DisplayName());
		let message=GetLocalizedTextByKey(n""AmmoLimiter-UI-LowAmmoWarning"");
		let finalMessage=StrReplace(message,""PROUTS"",ammoName);
		let simpleScreenMessage:SimpleScreenMessage;
		simpleScreenMessage.isShown=true;
		simpleScreenMessage.duration=1.2;
		simpleScreenMessage.message=finalMessage;
		simpleScreenMessage.isInstant=true;
		GameInstance.GetBlackboardSystem(player.GetGame()).Get(GetAllBlackboardDefs().UI_Notifications).SetVariant(GetAllBlackboardDefs().UI_Notifications.WarningMessage,ToVariant(simpleScreenMessage),true);
	}
}

@wrapMethod(WeaponObject)
public final static func SendAmmoUpdateEvent(weaponOwner:wref<GameObject>,weapon:wref<WeaponObject>) -> Void{
	wrappedMethod(weaponOwner,weapon);
	let player=weaponOwner as PlayerPuppet;
	if IsDefined(player) && IsDefined(weapon){CheckAndNotifyLowAmmo(player,weapon);}
}

@wrapMethod(PlayerPuppet)
protected cb func OnItemAddedToSlot(evt:ref<ItemAddedToSlot>) -> Bool{
	let result=wrappedMethod(evt);
	if evt.GetSlotID()==t""AttachmentSlots.WeaponRight""{
		let weapon=GameInstance.GetTransactionSystem(this.GetGame()).GetItemInSlot(this,evt.GetSlotID()) as WeaponObject;
		if IsDefined(weapon){CheckAndNotifyLowAmmo(this,weapon);}
	}
	return result;
}
"
b9tYut2m,Percent_Lifetime_Remain for /dev/sdl,briancmoses,Bash,Wednesday 23rd of July 2025 01:27:46 PM CDT,"root@truenas[/mnt/slow/homes/admin]# smartctl -a /dev/sdl
smartctl 7.4 2023-08-01 r5530 [x86_64-linux-6.6.44-production+truenas] (local build)
Copyright (C) 2002-23, Bruce Allen, Christian Franke, www.smartmontools.org

=== START OF INFORMATION SECTION ===
Model Family:     Crucial/Micron Client SSDs
Device Model:     CT1000MX500SSD1
Serial Number:    2114E594B2E2
LU WWN Device Id: 5 00a075 1e594b2e2
Firmware Version: M3CR033
User Capacity:    1,000,204,886,016 bytes [1.00 TB]
Sector Sizes:     512 bytes logical, 4096 bytes physical
Rotation Rate:    Solid State Device
Form Factor:      2.5 inches
TRIM Command:     Available
Device is:        In smartctl database 7.3/5528
ATA Version is:   ACS-3 T13/2161-D revision 5
SATA Version is:  SATA 3.3, 6.0 Gb/s (current: 6.0 Gb/s)
Local Time is:    Wed Jul 23 13:23:24 2025 CDT
SMART support is: Available - device has SMART capability.
SMART support is: Enabled

=== START OF READ SMART DATA SECTION ===
SMART overall-health self-assessment test result: PASSED
See vendor-specific Attribute list for marginal Attributes.

General SMART Values:
Offline data collection status:  (0x82) Offline data collection activity
                                        was completed without error.
                                        Auto Offline Data Collection: Enabled.
Self-test execution status:      (   0) The previous self-test routine completed
                                        without error or no self-test has ever
                                        been run.
Total time to complete Offline
data collection:                (    0) seconds.
Offline data collection
capabilities:                    (0x7b) SMART execute Offline immediate.
                                        Auto Offline data collection on/off support.
                                        Suspend Offline collection upon new
                                        command.
                                        Offline surface scan supported.
                                        Self-test supported.
                                        Conveyance Self-test supported.
                                        Selective Self-test supported.
SMART capabilities:            (0x0003) Saves SMART data before entering
                                        power-saving mode.
                                        Supports SMART auto save timer.
Error logging capability:        (0x01) Error logging supported.
                                        General Purpose Logging supported.
Short self-test routine
recommended polling time:        (   2) minutes.
Extended self-test routine
recommended polling time:        (  30) minutes.
Conveyance self-test routine
recommended polling time:        (   2) minutes.
SCT capabilities:              (0x0031) SCT Status supported.
                                        SCT Feature Control supported.
                                        SCT Data Table supported.

SMART Attributes Data Structure revision number: 16
Vendor Specific SMART Attributes with Thresholds:
ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE
  1 Raw_Read_Error_Rate     0x002f   100   100   000    Pre-fail  Always       -       0
  5 Reallocate_NAND_Blk_Cnt 0x0032   100   100   010    Old_age   Always       -       0
  9 Power_On_Hours          0x0032   100   100   000    Old_age   Always       -       3474
 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       86
171 Program_Fail_Count      0x0032   100   100   000    Old_age   Always       -       0
172 Erase_Fail_Count        0x0032   100   100   000    Old_age   Always       -       0
173 Ave_Block-Erase_Count   0x0032   001   001   000    Old_age   Always       -       1486
174 Unexpect_Power_Loss_Ct  0x0032   100   100   000    Old_age   Always       -       29
180 Unused_Reserve_NAND_Blk 0x0033   000   000   000    Pre-fail  Always       -       24
183 SATA_Interfac_Downshift 0x0032   100   100   000    Old_age   Always       -       0
184 Error_Correction_Count  0x0032   100   100   000    Old_age   Always       -       0
187 Reported_Uncorrect      0x0032   100   100   000    Old_age   Always       -       0
194 Temperature_Celsius     0x0022   064   025   000    Old_age   Always       -       36 (Min/Max 0/75)
196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0
197 Current_Pending_ECC_Cnt 0x0032   100   100   000    Old_age   Always       -       0
198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0
199 UDMA_CRC_Error_Count    0x0032   100   100   000    Old_age   Always       -       0
202 Percent_Lifetime_Remain 0x0030   001   001   001    Old_age   Offline  FAILING_NOW 99
206 Write_Error_Rate        0x000e   100   100   000    Old_age   Always       -       0
210 Success_RAIN_Recov_Cnt  0x0032   100   100   000    Old_age   Always       -       0
246 Total_LBAs_Written      0x0032   100   100   000    Old_age   Always       -       214486819463
247 Host_Program_Page_Count 0x0032   100   100   000    Old_age   Always       -       2462390276
248 FTL_Program_Page_Count  0x0032   100   100   000    Old_age   Always       -       24864455239

SMART Error Log Version: 1
Invalid Error Log index = 0x0e (valid range is from 1 to 5)
ATA Error Count: 0 (possibly also invalid)

SMART Self-test log structure revision number 1
Num  Test_Description    Status                  Remaining  LifeTime(hours)  LBA_of_first_error
# 1  Short offline       Completed without error       00%      3439         -
# 2  Short offline       Completed without error       00%      3428         -
# 3  Short offline       Completed without error       00%      3403         -
# 4  Extended offline    Completed without error       00%      3395         -
# 5  Short offline       Completed without error       00%      3392         -
# 6  Short offline       Completed without error       00%      3375         -
# 7  Short offline       Completed without error       00%      3352         -
# 8  Short offline       Completed without error       00%      3343         -
# 9  Extended offline    Completed without error       00%      3331         -
#10  Short offline       Completed without error       00%      3320         -
#11  Short offline       Completed without error       00%      3309         -
#12  Short offline       Completed without error       00%      3299         -
#13  Short offline       Completed without error       00%      3286         -
#14  Extended offline    Completed without error       00%      3281         -
#15  Short offline       Completed without error       00%      3274         -
#16  Short offline       Completed without error       00%      3263         -
#17  Short offline       Completed without error       00%      3252         -
#18  Short offline       Completed without error       00%      3242         -
#19  Extended offline    Completed without error       00%      3235         -
#20  Short offline       Completed without error       00%      3231         -
#21  Short offline       Completed without error       00%      3220         -

SMART Selective self-test log data structure revision number 1
 SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS
    1        0        0  Not_testing
    2        0        0  Not_testing
    3        0        0  Not_testing
    4        0        0  Not_testing
    5        0        0  Not_testing
Selective self-test flags (0x0):
  After scanning selected spans, do NOT read-scan remainder of disk.
If Selective self-test is pending on power-up, resume after 0 minute delay.

The above only provides legacy SMART information - try 'smartctl -x' for more

root@truenas[/mnt/slow/homes/admin]#"
LpNf9SuH,Halazia CSS,Hakrabis,CSS,Wednesday 23rd of July 2025 12:26:06 PM CDT,"@font-face{font-family:""Galvitra"";src:url(https://dl.dropbox.com/s/fhiet4342pwyo0xhe2vm1/Galvitra.ttf?rlkey=mtiow4d7prjtla2axf5urqks4&dl=0)}.BC-bg{width:650px;margin:auto;padding:20px 0;position:relative;display:flex;flex-direction:column;align-items:center;background:var(--BC-bg)}.BC-bg #BC-Cnt{width:540px;border:1.5px solid var(--BC-border);padding:10px}.BC-bg #BC-Cnt .BC-img{width:540px;height:240px}.BC-bg .BC-img span.BC-tit{width:auto;height:100px;padding:5px;position:relative;left:-130px;top:100px;z-index:1;display:grid;place-items:center;font:70px Galvitra;color:var(--BC-clr-title);text-shadow:2px 2px 4px #00000080}.BC-bg .BC-img span.BC-subtit{width:450px;padding:5px;position:relative;left:15px;top:60px;z-index:1;font:15px Oswald;text-transform:uppercase;letter-spacing:4px;color:var(--BC-clr-subtitle);text-shadow:2px 2px 4px #00000080}.BC-bsq1{width:450px;background:var(--BC-bg-bsq);margin:15px 0;padding:15px;position:relative;left:-55px;display:flex;justify-content:space-around}.BC-nmb{width:100px;color:var(--BC-clr-first-number);font:100px 'Bebas Neue';display:flex;justify-content:center;align-items:center}.BC-nmb span.BC-ok{color:var(--BC-clr-number-ok)}.BC-nmb span.BC-take{color:var(--BC-clr-number-take)}.BC-txt{width:300px;height:100px;color:var(--BC-clr-text);font:13px Nunito;text-align:justify;padding:10px;overflow:auto}.BC-bsq2{width:450px;background:var(--BC-bg-bsq);margin:15px 0;padding:20px;position:relative;right:-105px;display:flex;justify-content:space-around}.BC-lines{height:30px;display:flex;justify-content:center;align-items:center}.BC-line{width:100px;height:1px;background-color:var(--BC-border);margin:10px}.BC-icon{color:var(--BC-clr-icon);font-size:20px}.BC-fot{display:flex;justify-content:space-evenly;align-items:center}.BC-img2{width:125px;height:125px;border-radius:100%;border:1.7px solid var(--BC-border);padding:8px}.BC-img2 img{width:125px;height:125px;border-radius:100%}.BC-fot span.BC-quote{width:250px;color:var(--BC-clr-text);padding:10px;font:12px Nunito;text-align:justify}.BC-fot span.BC-quote span{color:var(--BC-clr-quote)}div::-webkit-scrollbar,span::-webkit-scrollbar{width:0}a.credi{color:#4d4d4d;font-family:Arial;text-decoration:none;font-size:9px;letter-spacing:2px;width:auto;position:relative;overflow:hidden;text-transform:uppercase;transition:color .3s cubic-bezier(0.11,0.7,0,1)}a.credi:hover{color:#ed6f88;transition:.2s}.citos:after{position:absolute;display:block;width:0;height:2px;background-color:#df1233;content:""""}"
1rW2bRxT,Holtop ERV esphome logger,blackscreener,YAML,Wednesday 23rd of July 2025 12:23:58 PM CDT,"esphome:
  name: $devicename
  #on_boot: 
  #  then:
    #  - pzemac.reset_energy: pzemac_1

esp32:
  board: nodemcu-32s
  #board_flash_mode: dout
  framework:
    type: esp-idf
    
    version: recommended
debug:
  update_interval: 60s


substitutions:
  devicename: reku-logger
  friendly_name: Rekuperator

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_pass

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: ""sweet-fallback-${devicename}""
    password: cvbcbcbcvbdfbgte4

captive_portal:

logger:
  baud_rate: 0
  level: DEBUG

# Enable Home Assistant API
api:
  #password: !secret api-password

ota:
  - platform: esphome

# Enable Web server
#web_server:
# port: 80
i2c:
  - id: bus_a
    sda: 21
    scl: 22
    scan: false
   # frequency: 50kHz
  - id: bus_b
    sda: 18
    scl: 19
    scan: false
  #  frequency: 50kHz


uart:
  - id: mod_bus #reku
    tx_pin: 16
    rx_pin: 17
    baud_rate: 9600
    stop_bits: 1

  - id: mod_bus2 #pzem
    tx_pin: 1
    rx_pin: 3
    baud_rate: 9600
    stop_bits: 2  #1 dla esp8266


time:
  - platform: sntp
    id: czas_systemowy

# Example configuration entry
button:
  - platform: restart
    name: ""ESP Reku Restart""

globals:
  - id: przewietrzanie_timer_koniec_timestamp # <--- DODAJ TĘ LINIĘ
    type: int
    restore_value: yes
    initial_value: '0'

  - id: okap_timer_koniec_timestamp
    type: int
    restore_value: yes # Zachowaj stan po restarcie
    initial_value: '0' # 0 oznacza, ze timer nie jest aktywny

  - id: impreza_timer_koniec_timestamp
    type: int
    restore_value: yes
    initial_value: '0' # 0 oznacza, ze timer nie jest aktywny


  - id: licznik_korekt
    type: int
    restore_value: no
    initial_value: '0'

  - id: ostatni_timestamp_korekty # Nowa zmienna globalna
    type: int
    restore_value: yes # Ważne: przywróć wartość po restarcie, aby opóźnienie działało poprawnie
    initial_value: '0' # Domyślnie 0, co oznacza, że pierwsza korekta może nastąpić od razu po uruchomieniu

  - id: limit_korekt_na_godzine
    type: int
    restore_value: no
    initial_value: '10'

  - id: stary_nawiew
    type: int
    restore_value: no
    initial_value: '0'
  - id: stary_wywiew
    type: int
    restore_value: no
    initial_value: '0'

  # Aktualny tryb z podtypem dla trybu auto
  - id: tryb_auto_status
    type: std::string
    initial_value: '""normal""'

  # Aktualny aktywny tryb
  - id: aktywny_tryb
    type: std::string
    initial_value: '""auto""'

  - id: ostatnie_obroty
    type: int
    restore_value: no
    initial_value: '0'

  - id: czy_przewietrzanie
    type: bool
    restore_value: no
    initial_value: 'false'

modbus:
  - id: mod_bus_reventon
    uart_id: mod_bus
    send_wait_time: 200ms
 #   flow_control_pin: GPIO4
  - id: mod_bus_pzem
 #   send_wait_time: 200ms
    uart_id: mod_bus2

modbus_controller:
  - id: reventon_reku
    address: 0x01
    modbus_id: mod_bus_reventon
    update_interval: 15s

  - id: pzem1
    modbus_id: mod_bus_pzem
    address: 0x1
    #command_throttle: 0ms
    setup_priority: -10
    update_interval: 5s

text_sensor:
  - platform: debug
    device:
      name: ""Device Info""
    reset_reason:
      name: ""Reset Reason""


  - platform: template
    name: ""Aktywny tryb rekuperatora""
    lambda: |-
      std::string tryb = id(aktywny_tryb);
      if (tryb == ""auto"") {
        std::string status = id(tryb_auto_status);
        //return std::string(""Tryb auto - "") + status;
        return std::string(status);
      }
      return tryb;
    update_interval: 30s


  - platform: template
    name: ""Ostatni reset korekt""
    id: ostatni_reset_korekt
    lambda: |-
      char str[20];
      time_t curr_time = id(czas_systemowy).now().timestamp;
      strftime(str, sizeof(str), ""%H:%M"", localtime(&curr_time));
      return std::string(str);
    update_interval: 1h

  - platform: template
    name: $friendly_name Uptime
    id: uptime_human
    icon: mdi:clock-start



  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Status
    id: reku_status
    register_type: holding
    address: 0x0012 #18
    response_size: 2
    raw_encode: HEXBYTES
    #bitmask: 0
    lambda: |-
       std::string z = """";
       int idx = item->offset+1;
       if ((data[idx] & 0x0001) != 0) z += ""Alarm pożarowy ON, "";
       if ((data[idx] & 0x0002) != 0) z += ""Bypass ON, "";
       if ((data[idx] & 0x0004) != 0) z += ""Bypass OFF, "";
       if ((data[idx] & 0x0008) != 0) z += ""Odladzanie, "";
       if(z.length() > 0){
         z.pop_back();
       }
       return {z};

  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Status2
    id: reku_status2
    register_type: holding
    address: 0x0012 #18
    response_size: 2
    raw_encode: HEXBYTES

  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Fault Message
    id: reku_fault_message
    register_type: holding
    address: 0x0014 #20
    response_size: 2
    raw_encode: HEXBYTES

  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Fault Message2
    id: reku_fault_message2
    register_type: holding
    address: 0x0014 #20
    response_size: 2
    #raw_encode: HEXBYTES
    lambda: |-
       std::string z = """";
       int idx = item->offset+1;
       if ((data[idx] & 0x0001) != 0) z += ""Błąd czujnika temperatury powietrza zewnętrznego (OA), "";
       if ((data[idx] & 0x0002) != 0) z += ""Błąd pamięci EEPROM, "";
       if ((data[idx] & 0x0004) != 0) z += ""Błąd czujnika temperatury powietrza wywiewanego (RA) lub SW4-3 jest w pozycji ON, ale bez podłączenia do czujnika wilgotności, "";
       if ((data[idx] & 0x0008) != 0) z += ""Błąd czujnika temperatury powietrza usuwanego (EA), "";
       if ((data[idx] & 0x0010) != 0) z += ""Błąd komunikacji, "";
       if ((data[idx] & 0x0020) != 0) z += ""Błąd czujnika temperatury powietrza nawiewanego (SA), "";
       if ((data[idx] & 0x0040) != 0) z += ""Błąd wentylatora wywiewnego, "";
       if ((data[idx] & 0x0080) != 0) z += ""Błąd wentylatora nawiewnego, "";
   
       if(z.length() > 0){
         z.pop_back();
       }
       return {z};

script:
  - id: sprawdz_ograniczenie_korekt
    mode: single
    parameters:
      korekta_id: int
    then:
      - if:
          condition:
            lambda: return id(licznik_korekt) < id(limit_korekt_na_godzine);
          then:
            - lambda: 'id(licznik_korekt) += 1;'
            - logger.log:
                format: ""Wykonano korektę. Licznik: %d / %d""
                args:
                  - id(licznik_korekt)
                  - id(limit_korekt_na_godzine)
            - if:
                condition:
                  lambda: return korekta_id == 1;
                then:
                  - script.execute: korekta_do_nadcisnienia
            - if:
                condition:
                  lambda: return korekta_id == 2;
                then:
                  - script.execute: korekta_do_podcisnienia
 
            # --- DODAJ AKTUALIZACJĘ TIMESTAMPU PO WYKONANIU KOREKTY ---
            - lambda: 'id(ostatni_timestamp_korekty) = id(czas_systemowy).now().timestamp;'
            - logger.log: ""Zaktualizowano timestamp ostatniej korekty.""
          
          else:
            - logger.log: ""Limit korekt na godzinę osiągnięty – korekta zablokowana.""

  - id: korekta_do_nadcisnienia # Zwiększa wywiew, aby zredukować nadciśnienie (nawiew > wywiew)
    mode: restart
    then:
      - lambda: |-
          const int max_fan_difference = 3; 
          int current_nawiew = id(wentylator_nawiewny).state; // Nawiew jest referencją (stała wartość)
          int current_wywiew = id(wentylator_wywiewny).state;
          int new_wywiew = current_wywiew + 1; // Próbujemy zwiększyć wywiew

          // Warunki:
          // 1. New_wywiew nie może przekroczyć 10.
          // 2. Różnica (nawiew - new_wywiew) musi być <= max_fan_difference.
          //    (Czyli wywiew może być max o 3 biegi mniejszy od nawiewu)
          if (new_wywiew <= 10 && (current_nawiew - new_wywiew) <= max_fan_difference) {
            id(wentylator_wywiewny).make_call().set_value(new_wywiew).perform();
            ESP_LOGI(""Korekta_Nadcisnienia"", ""Zwiekszono wywiew: wywiew = %d (nawiew = %d). Roznica: %d"",
                     new_wywiew, current_nawiew, current_nawiew - new_wywiew);
          } else {
            ESP_LOGI(""Korekta_Nadcisnienia"", ""Korekta nadcisnienia zablokowana: wywiew=%d, nawiew=%d. Roznica %d, limit %d. (Wywiew min/max lub poza roznica)"",
                     current_wywiew, current_nawiew, current_nawiew - current_wywiew, max_fan_difference);
          }


  - id: korekta_do_podcisnienia # Zmniejsza wywiew, aby zredukować podciśnienie (nawiew < wywiew)
    mode: restart
    then:
      - lambda: |-
          const int max_fan_difference = 3; 
          int current_nawiew = id(wentylator_nawiewny).state; // Nawiew jest referencją (stała wartość)
          int current_wywiew = id(wentylator_wywiewny).state;
          int new_wywiew = current_wywiew - 1; // Próbujemy zmniejszyć wywiew

          // Warunki:
          // 1. New_wywiew nie może schodzić poniżej 0.
          // 2. Różnica (new_wywiew - nawiew) musi być <= max_fan_difference.
          //    (Czyli wywiew może być max o 3 biegi większy od nawiewu)
          if (new_wywiew >= 0 && (new_wywiew - current_nawiew) <= max_fan_difference) {
            id(wentylator_wywiewny).make_call().set_value(new_wywiew).perform();
            ESP_LOGI(""Korekta_Podcisnienia"", ""Zmniejszono wywiew: wywiew = %d (nawiew = %d). Roznica: %d"",
                     new_wywiew, current_nawiew, new_wywiew - current_nawiew);
          } else {
            ESP_LOGI(""Korekta_Podcisnienia"", ""Korekta podcisnienia zablokowana: wywiew=%d, nawiew=%d. Roznica %d, limit %d. (Wywiew min/max lub poza roznica)"",
                     current_wywiew, current_nawiew, current_wywiew - current_nawiew, max_fan_difference);
          }

  - id: wlacz_przewietrzanie
    mode: single
    then:
      - logger.log: ""TRYB PRZEWIETRZANIA: aktywacja""
      - switch.turn_off: balans_przeplywu_switch
      - lambda: |-
          id(czy_przewietrzanie) = true;
          id(stary_nawiew) = (int)id(wentylator_nawiewny).state;
          id(stary_wywiew) = (int)id(wentylator_wywiewny).state;
          id(przewietrzanie_timer_koniec_timestamp) = id(czas_systemowy).now().timestamp + (int)id(czas_przewietrzania_minuty).state * 60;
      - number.set:
          id: wentylator_nawiewny
          value: 10
      - number.set:
          id: wentylator_wywiewny
          value: 10
      - lambda: |-
          int czas = (int)id(czas_przewietrzania_minuty).state;
          ESP_LOGI(""przewietrzanie"", ""Czas przewietrzania: %d min"", czas);
      - delay: !lambda 'return id(czas_przewietrzania_minuty).state * 60 * 1000;'
      - switch.turn_off: tryb_przewietrzania_switch

  - id: zakoncz_przewietrzanie
    mode: single
    then:
      - logger.log: ""TRYB PRZEWIETRZANIA: zakończenie – przywracanie poprzednich ustawień""
      - lambda: |-
          id(czy_przewietrzanie) = false;
          id(przewietrzanie_timer_koniec_timestamp) = 0; // Wyzeruj timer
      - number.set:
          id: wentylator_nawiewny
          value: !lambda 'return id(stary_nawiew);'
      - number.set:
          id: wentylator_wywiewny
          value: !lambda 'return id(stary_wywiew);'
      - switch.turn_on: balans_przeplywu_switch
      - homeassistant.event:
          event: esphome.przewietrzanie_zakonczone
          data:
            message: ""Tryb przewietrzania zakończony""
            nawiew: !lambda 'return id(wentylator_nawiewny).state;'
            wywiew: !lambda 'return id(wentylator_wywiewny).state;'

#   - id: set_mode
#     mode: single
#     parameters:
#       tryb: std::string
#     then:
#       - lambda: |-
#           id(aktywny_tryb) = tryb;
#           id(tryb_select_esp).publish_state(tryb);
#           ESP_LOGI(""tryb"", ""Ustawiono tryb: %s"", tryb.c_str());

#       - switch.turn_on: balans_przeplywu_switch

#       - if:
#           condition:
#             lambda: return tryb == ""nocny"";
#           then:
#             - switch.turn_off: balans_przeplywu_switch
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 2
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 2

#       - if:
#           condition:
#             lambda: return tryb == ""intensywny"";
#           then:
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 10
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 10
#             - delay: 2h
#             - script.execute:
#                 id: set_mode
#                 tryb: ""normalny""

#       - if:
#           condition:
#             lambda: return tryb == ""gosc"";
#           then:
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 10
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 10
#             - switch.turn_off: balans_przeplywu_switch
#             - delay: 4h
#             - homeassistant.event:
#                 event: esphome.tryb_goscia
#                 data:
#                   message: ""Tryb gość zakończony. Powrót do normalnego trybu.""
#             - script.execute:
#                 id: set_mode
#                 tryb: ""normalny""

#       - if:
#           condition:
#             lambda: return tryb == ""urlopowy"";
#           then:
#             - switch.turn_off: balans_przeplywu_switch
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 1
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 1

#       - if:
#           condition:
#             lambda: return tryb == ""serwisowy"";
#           then:
#             - switch.turn_off: balans_przeplywu_switch
#             - switch.turn_off: tryb_przewietrzania_switch

#       - if:
#           condition:
#             lambda: return tryb == ""auto"";
#           then:
#             - switch.turn_on: balans_przeplywu_switch

#       - if:
#           condition:
#             lambda: return tryb == ""normalny"";
#           then:
#             - switch.turn_on: balans_przeplywu_switch


#       - if:
#           condition:
#             lambda: return tryb == ""okno"";
#           then:
#             - switch.turn_off: balans_przeplywu_switch
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 1
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 3
#             - lambda: id(ostatnie_obroty) = 3;

  - id: set_mode
    mode: single
    parameters:
      mode: std::string 
      target_reku_speed: int
    then:
      - lambda: |-
          std::string new_mode = mode;
          int obroty_nawiew = 0;
          int obroty_wywiew = 0;

          if (new_mode == ""auto"") {
            obroty_nawiew = 3; 
            obroty_wywiew = 3;
            ESP_LOGI(""set_mode"", ""Tryb AUTO: Poczatkowe obroty: Nawiew=%d, Wywiew=%d. Dalsza regulacja w interval."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); // Upewnij sie, ze glowny przelacznik jest ON
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy
            // W trybie auto dalsze obroty sa dynamicznie ustalane przez interval: 1min
          
          } else if (new_mode == ""nocny"") {
            obroty_nawiew = 2; 
            obroty_wywiew = 2;
            ESP_LOGI(""set_mode"", ""Tryb NOCNY: Poczatkowe obroty: Nawiew=%d, Wywiew=%d. Dalsza regulacja w interval."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy           

          } else if (new_mode == ""okno"") {
            obroty_nawiew = 1; 
            obroty_wywiew = 4; 
            ESP_LOGI(""set_mode"", ""Tryb OKNO: Nawiew=%d, Wywiew=%d."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy


          } else if (new_mode == ""normalny"") {
            obroty_nawiew = 2; 
            obroty_wywiew = 2; 
            ESP_LOGI(""set_mode"", ""Tryb NORMALNY Nawiew=%d, Wywiew=%d."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy


          } else if (new_mode == ""serwisowy"") {
            id(reku_on_off_switch).make_call().set_value(false).perform(); 
            id(tryb_przewietrzania_switch).turn_off();
            id(balans_przeplywu_switch).turn_off();
            ESP_LOGI(""set_mode"", ""Tryb SERWISOWY: Wylaczam rekuperator. Wentylatory: Nawiew=%d, Wywiew=%d."", obroty_nawiew, obroty_wywiew);
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy

          } else if (new_mode == ""urlopowy"") {
            obroty_nawiew = 1;
            obroty_wywiew = 1;
            ESP_LOGI(""set_mode"", ""Tryb URLOPOWY: Wentylatory wylaczone (Nawiew=%d, Wywiew=%d)."", obroty_nawiew, obroty_wywiew);
            id(reku_on_off_switch).make_call().set_value(true).perform();         
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy

          } else if (new_mode == ""okap_auto"") {
            obroty_nawiew = target_reku_speed;
            obroty_wywiew = target_reku_speed;
            ESP_LOGI(""set_mode"", ""Tryb OKAP_AUTO: Nawiew=%d, Wywiew=%d (zalezne od predkosci okapu)."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy
          
          } else if (new_mode == ""wylaczony"") {
            ESP_LOGI(""set_mode"", ""Tryb WYLACZONY: Rekuperator wylaczony (Nawiew=%d, Wywiew=%d)."", obroty_nawiew, obroty_wywiew);
            id(reku_on_off_switch).make_call().set_value(false).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy
            id(tryb_przewietrzania_switch).turn_off();
            id(balans_przeplywu_switch).turn_off();

          } else if (new_mode == ""impreza"") { 
            obroty_nawiew = 7; 
            obroty_wywiew = 7;
            ESP_LOGI(""set_mode"", ""Tryb IMPREZA: Nawiew=%d, Wywiew=%d. Aktywny na %d godzin."", obroty_nawiew, obroty_wywiew, (int)id(impreza_czas_trwania_godz).state);
            id(reku_on_off_switch).make_call().set_value(true).perform();
            // Ustaw timer zakonczenia trybu Impreza (teraz + zdefiniowany czas w minutach)
            id(impreza_timer_koniec_timestamp) = id(czas_systemowy).now().timestamp + (int)id(impreza_czas_trwania_godz).state * 3600;

          }
          else {
            ESP_LOGW(""set_mode"", ""Nieznany tryb: %s"", new_mode.c_str());
            return;
          }

          // Wykonaj zmiany obrotow tylko jesli tryb sie zmienil LUB
          // jesli to tryb 'okap_auto' i jego obroty sie zmienily (bo sa dynamiczne)
          // UWAGA: Jesli reku_on_off_switch zostal wylaczony wczesniej, wentylatory i tak zostana ustawione na 0.
          if (id(aktywny_tryb) != new_mode ||
              (new_mode == ""okap_auto"" && (id(wentylator_nawiewny).state != obroty_nawiew || id(wentylator_wywiewny).state != obroty_wywiew))) {

            id(aktywny_tryb) = new_mode;
            id(ostatnie_obroty) = obroty_nawiew; // Aktualizuj dla spójności

            // Aktualizacja select.tryb_select_esp ---
            id(tryb_select_esp).publish_state(new_mode); 

            // Logika ustawiania obrotow wentylatorow (wykonuje sie nawet jesli sa na 0)
            ESP_LOGI(""set_mode"", ""Przelaczono na tryb: '%s'. Ustawiam obroty: Nawiew=%d, Wywiew=%d."", new_mode.c_str(), obroty_nawiew, obroty_wywiew);
            id(wentylator_nawiewny).make_call().set_value(obroty_nawiew).perform();
            id(wentylator_wywiewny).make_call().set_value(obroty_wywiew).perform();
          } else {
            ESP_LOGD(""set_mode"", ""Tryb '%s' juz jest aktywny z obrotami Nawiew=%d. Brak zmian."", new_mode.c_str(), obroty_nawiew);
          }

interval:
  - interval: 1h
    then:
      - lambda: 'id(licznik_korekt) = 0;'
      - component.update: licznik_korekt_sensor
      - component.update: licznik_korekt_pozostale
      - component.update: ostatni_reset_korekt

  - interval: 1min
    then:
      - lambda: |-
          // Sprawdz glowny przelacznik rekuperatora. Jesli jest wylaczony, przerwij logike sterowania.
          // Tryby ""serwisowy"", ""urlopowy"", ""wylaczony"" obsluguja to poprzez wylaczenie reku_on_off_switch.
          if (!id(reku_on_off_switch).state) {
            ESP_LOGD(""interval"", ""Rekuperator wylaczony glownym przelacznikiem. Pomijam logike sterowania."");
            id(tryb_auto_status) = ""reku wylaczony (switch OFF)""; // Uaktualnij status
            return; // Przerwij dalsze wykonywanie lambdy
          }

          // --- LOGIKA DLA TRYBU OKAPU (z wykorzystaniem sensora predkosci z Home Assistant) ---
          float hood_fan_speed_percent = 0.0;
          if (id(okap_predkosc_ha).has_state()) { // Sprawdz, czy sensor ma juz stan
              hood_fan_speed_percent = id(okap_predkosc_ha).state;
          } else {
              // W przypadku braku stanu sensora, traktujemy okap jako wylaczony
              ESP_LOGW(""okap_logic"", ""Sensor okap_predkosc_ha nie ma stanu! Traktuje okap jako wylaczony."");
          }

          bool okap_is_on = hood_fan_speed_percent > 0.0; // Okap jest wlaczony, jesli predkosc > 0

          int reku_speed_for_okap = 0;
          std::string okap_status_text = """";

          if (okap_is_on) {
            // Dostosuj progi i obroty rekuperatora do swoich biezacych potrzeb
            // Przyjmujemy 3 biegi okapu: niski, sredni, wysoki
            if (hood_fan_speed_percent > 66.0) { // Np. powyzej 66% to Bieg 3 okapu
              reku_speed_for_okap = 9; // Najwyzsze obroty rekuperatora
              okap_status_text = ""Okap: Bieg 3 (Wysoki)"";
            } else if (hood_fan_speed_percent > 33.0) { // Np. powyzej 33% to Bieg 2 okapu
              reku_speed_for_okap = 7; // Srednie obroty rekuperatora
              okap_status_text = ""Okap: Bieg 2 (Sredni)"";
            } else { // Pomiedzy 0% a 33% to Bieg 1 okapu
              reku_speed_for_okap = 5; // Nizsze obroty rekuperatora
              okap_status_text = ""Okap: Bieg 1 (Niski)"";
            }

            // Aktywuj tryb okap_auto i ustaw odpowiednie obroty
            if (id(aktywny_tryb) != ""okap_auto"" ||
                id(wentylator_nawiewny).state != reku_speed_for_okap) {
              ESP_LOGI(""tryb"", ""Wykryto aktywny Okap (%s) - przelaczam w tryb OKAP_AUTO. Obroty reku: %d."", okap_status_text.c_str(), reku_speed_for_okap);
              id(set_mode)->execute(""okap_auto"", reku_speed_for_okap);
            }
            id(tryb_auto_status) = okap_status_text;

            // Ustaw ""timer"" okapu: oblicz czas zakonczenia na teraz + czas trwania z number.okap_czas_trwania_min
            id(okap_timer_koniec_timestamp) = id(czas_systemowy).now().timestamp + (int)id(okap_czas_trwania_min).state * 60;
            ESP_LOGI(""tryb"", ""Timer OKAP_AUTO zresetowany na %d minut. Koniec o: %s"", (int)id(okap_czas_trwania_min).state, id(czas_systemowy).now().strftime(""%Y-%m-%d %H:%M:%S"").c_str());

            return; // Zakoncz, bo tryb okap ma priorytet
          } else { // Okap jest wylaczony (hood_fan_speed_percent jest 0)
            if (id(aktywny_tryb) == ""okap_auto"") {
                // Jesli bylismy w trybie okap_auto, ale okap sie wylaczyl, sprawdzamy ""timer""
                if (id(czas_systemowy).now().timestamp >= id(okap_timer_koniec_timestamp)) {
                    ESP_LOGI(""tryb"", ""Okap wylaczony, timer OKAP_AUTO minal - powracam do trybu AUTO."");
                    id(set_mode)->execute(""auto"", 0);
                    id(okap_timer_koniec_timestamp) = 0; // Wyzeruj timer po zakonczeniu
                } else {
                    int remaining_seconds = id(okap_timer_koniec_timestamp) - id(czas_systemowy).now().timestamp;
                    id(tryb_auto_status) = ""Okap wylaczony (timer aktywny)"";
                    ESP_LOGD(""tryb"", ""Okap wylaczony, timer OKAP_AUTO nadal aktywny. Pozostalo: %d s"", remaining_seconds);
                }
                return;
            }
          }
          // --- KONIEC LOGIKI TRYBU OKAPU ---


          // --- LOGIKA TRYBU IMPREZA (NAJWYŻSZY PRIORYTET PO OKAPIE) ---
          if (id(aktywny_tryb) == ""impreza"") {
            if (id(czas_systemowy).now().timestamp >= id(impreza_timer_koniec_timestamp)) {
                ESP_LOGI(""tryb"", ""Timer trybu IMPREZA minal - powracam do trybu AUTO."");
                id(set_mode)->execute(""auto"", 0);
                id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer po zakonczeniu
                return; // Zakoncz, bo tryb zmieniony
            } else {
                int remaining_minutes = (id(impreza_timer_koniec_timestamp) - id(czas_systemowy).now().timestamp) / 60;
                id(tryb_auto_status) = ""Impreza ("" + std::to_string(remaining_minutes) + "" min do konca)"";
                ESP_LOGD(""tryb"", ""Tryb IMPREZA nadal aktywny. Pozostalo: %d min"", remaining_minutes);
                return; // Zakoncz, bo tryb impreza ma priorytet nad auto/nocny
            }
          }
          // --- KONIEC LOGIKI TRYBU IMPREZA ---

          // Pobierz aktualny czas
          auto t = id(czas_systemowy).now();
          int hour = t.hour;

          // --- NOWA LOGIKA: Wyjście z trybu nocnego ---
          // Jeśli jesteśmy w trybie nocnym, a godzina nie jest już nocna (np. >= 6 rano i < 23)
          if (id(aktywny_tryb) == ""nocny"" && (hour >= 6 && hour < 23)) {
              ESP_LOGI(""tryb"", ""Koniec trybu nocnego - przechodzę w tryb AUTO."");
              id(set_mode)->execute(""auto"", 0);
              return; // Zakończ, by w tej minucie już być w trybie auto
          }
          // --- KONIEC NOWEJ LOGIKI ---


          // 1. Logika otwartego okna 
          if (id(czy_jakies_okno_otwarte).state) {
            // Jeśli okno jest otwarte i system jest włączony, ale nie jest w trybie ""okno""
            if (id(reku_on_off_switch).state && id(aktywny_tryb) != ""okno"") {
              ESP_LOGI(""tryb"", ""Okno otwarte — przełączam w tryb OKNO"");
              id(set_mode)->execute(""okno"", 0);
            }
            // Zawsze kończ działanie, jeśli jakiekolwiek okno jest otwarte
            return;
          }

          // Jeśli doszliśmy tutaj, to znaczy, że wszystkie okna są ZAMKNIĘTE.
          // Sprawdź, czy trzeba wyjść z trybu ""okno""
          if (id(aktywny_tryb) == ""okno"") {
            ESP_LOGI(""tryb"", ""Wszystkie okna zamknięte — przywracam tryb AUTO"");
            id(set_mode)->execute(""auto"", 0);
            return; // Zakończ, aby w następnej minucie już działać w trybie auto
          }



          // Sprawdź warunki do wejścia w tryb nocny
          if ((hour >= 23 || hour < 6) &&
              id(reku_on_off_switch).state == 1 &&
              !id(czy_przewietrzanie) &&
              id(aktywny_tryb) != ""serwisowy"" &&
              id(aktywny_tryb) != ""urlopowy"" &&
              id(aktywny_tryb) != ""nocny"" &&
              id(aktywny_tryb) != ""okno"" &&
              !id(dom_pusty).state) { // <--- TUTAJ USUNIĘTO DODATKOWY NAWIAS ZAMYKAJĄCY
            ESP_LOGI(""tryb"", ""Automatyczne przełączenie na tryb nocny"");
            id(set_mode)->execute(""nocny"", 0);
            return;  // pomiń dalej logikę w tej minucie
          }

          if (id(reku_on_off_switch).state != 1) {
            id(tryb_auto_status) = ""reku wyłączony"";
            return;
          }
          if (id(czy_przewietrzanie)) {
            id(tryb_auto_status) = ""przewietrzanie aktywne"";
            return;
          }

          std::string tryb = id(aktywny_tryb);

          // Deklaracje zmiennych na tym poziomie
          float hum = 0.0;
          int co2 = 0;
          bool pusty = id(dom_pusty).state; // Pobranie stanu 'dom_pusty' raz

          // Pobranie wartości z globalnych sensorów
          if (id(max_humidity_all_sensors).has_state()) {
              hum = id(max_humidity_all_sensors).state;
          } else {
              // Wartość domyślna, jeśli sensor max_humidity_all_sensors nie ma jeszcze stanu
              // To jest tylko na wypadek braku odczytu na samym starcie
              hum = 0.0;
              ESP_LOGW(""Wilgotnosc"", ""Maksymalna wilgotność nie jest dostępna!"");
          }

          if (id(co2_value).has_state()) {
              co2 = (int)id(co2_value).state;
          }

          if (tryb == ""nocny"") {
            // Logika CO2 i wilgotności dla trybu nocnego
            int obroty = id(ostatnie_obroty);
            std::string status;

            if (co2 > id(co2_nocny_high).state) {
              obroty = 5;
              status = ""nocny - wysoki CO2"";
            } else if (co2 < id(co2_nocny_low).state) {
              obroty = 2;
              status = ""nocny - niski CO2"";
            }

            // Dodatkowa logika wilgotności nocnej
            if (hum > id(wilgotnosc_nocna_high).state && obroty < 4) {
              obroty = 4;
              status = ""nocny - wysoka wilgotność"";
            } else if (hum < id(wilgotnosc_nocna_low).state && obroty > 2) {
              obroty = 2;
              status = ""nocny - niska wilgotność"";
            }

            // Wykonaj tylko jeśli się zmieniło
            if (obroty != id(ostatnie_obroty)) {
              id(wentylator_nawiewny).make_call().set_value(obroty).perform();
              id(wentylator_wywiewny).make_call().set_value(obroty).perform();
              id(ostatnie_obroty) = obroty;
            }

            // Zawsze ustaw status, nawet gdy obroty się nie zmieniają
            if (status.empty()) {
              status = ""nocny - bez zmian"";
            }
            id(tryb_auto_status) = status;
            return;
          }

          if (tryb == ""auto"") {
            // **NOWA LOGIKA: Sprawdź najpierw, czy dom jest pusty**
            if (pusty) { // Używamy zmiennej 'pusty' zdeklarowanej i ustawionej wcześniej
              // Jeśli dom jest pusty, wymuś obroty na 1 i zakończ logikę dla trybu auto
              int obroty = 1; // Minimalne obroty dla trybu ""dom pusty""
              if (obroty != id(ostatnie_obroty)) {
                id(wentylator_nawiewny).make_call().set_value(obroty).perform();
                id(wentylator_wywiewny).make_call().set_value(obroty).perform();
                id(ostatnie_obroty) = obroty;
              }
              id(tryb_auto_status) = ""dom pusty"";

            } else {
              // **ISTNIEJĄCA LOGIKA: Uruchamiana tylko, gdy dom NIE jest pusty**
              // Używamy już zdeklarowanych i ustawionych zmiennych hum i co2
              // Usuwamy podwójne deklaracje hum i co2 tutaj!

              // Obroty z logiki CO2
              int obroty_co2 = 3;
              std::string status_co2 = ""normalny"";
              if (co2 > id(co2_auto_high).state) {
                obroty_co2 = 9;
                status_co2 = ""wysoki CO2"";
              } else if (co2 > id(co2_auto_medium).state) {
                obroty_co2 = 6;
                status_co2 = ""średni CO2"";
              } else if (co2 > id(co2_auto_low).state) {
                obroty_co2 = 4;
                status_co2 = ""niski CO2"";
              }

              // Obroty z logiki wilgotności
              int obroty_hum = 3;
              std::string status_hum = """";
              if (hum > id(wilgotnosc_wysoka).state) {
                obroty_hum = 9;
                status_hum = ""wilgotność"";
              } else if (hum < id(wilgotnosc_niska).state) {
                obroty_hum = 3;
              }

              // Wybór wyższych obrotów
              int obroty = std::max(obroty_co2, obroty_hum);

              if (obroty != id(ostatnie_obroty)) {
                id(wentylator_nawiewny).make_call().set_value(obroty).perform();
                id(wentylator_wywiewny).make_call().set_value(obroty).perform();
                id(ostatnie_obroty) = obroty;
              }

              // Ustawienie statusu
              if (obroty == obroty_hum && status_hum != """") {
                id(tryb_auto_status) = ""Tryb auto - "" + status_hum;
              } else {
                id(tryb_auto_status) = ""Tryb auto - "" + status_co2;
              }
            }
          }

# Example configuration entry
psram:
  mode: quad
  speed: 40MHZ


sensor:

  - platform: template
    name: ""Okap - czas do końca""
    id: okap_czas_do_konca
    unit_of_measurement: ""min""
    icon: ""mdi:stove-fan""
    update_interval: 10s # Odświeżaj co 10 sekund dla płynniejszego liczenia
    lambda: |-
      int now_timestamp = id(czas_systemowy).now().timestamp;
      int end_timestamp = id(okap_timer_koniec_timestamp);

      if (end_timestamp > now_timestamp) {
        // Oblicz pozostały czas w sekundach, a następnie w minutach
        int remaining_seconds = end_timestamp - now_timestamp;
        return (float)std::ceil(remaining_seconds / 60.0); // Zaokrągl w górę do najbliższej minuty
      } else {
        return 0; // Jeśli tryb się zakończył lub nieaktywny
      }


  - platform: template
    name: ""Impreza - czas do końca""
    id: impreza_czas_do_konca
    unit_of_measurement: ""min""
    icon: ""mdi:party-popper""
    update_interval: 60s 
    lambda: |-
      int now_timestamp = id(czas_systemowy).now().timestamp;
      int end_timestamp = id(impreza_timer_koniec_timestamp);

      if (end_timestamp > now_timestamp) {
        // Oblicz pozostały czas w sekundach, a następnie w minutach
        int remaining_seconds = end_timestamp - now_timestamp;
        return (float)std::ceil(remaining_seconds / 60.0); // Zaokrągl w górę do najbliższej minuty
      } else {
        return 0; // Jeśli tryb się zakończył lub nieaktywny
      }

  - platform: template
    name: ""Przewietrzanie - czas do końca""
    id: przewietrzanie_czas_do_konca
    unit_of_measurement: ""min""
    icon: ""mdi:timer-sand""
    update_interval: 60s # Odświeżaj co 10 sekund dla płynniejszego liczenia
    lambda: |-
      int now_timestamp = id(czas_systemowy).now().timestamp;
      int end_timestamp = id(przewietrzanie_timer_koniec_timestamp);

      if (end_timestamp > now_timestamp) {
        // Oblicz pozostały czas w sekundach, a następnie w minutach
        int remaining_seconds = end_timestamp - now_timestamp;
        return (float)std::ceil(remaining_seconds / 60.0); // Zaokrągl w górę do najbliższej minuty
      } else {
        return 0; // Jeśli przewietrzanie się zakończyło lub nieaktywne
      }

  # Nowy sensor do odczytu predkosci okapu z Home Assistant
  - platform: homeassistant
    name: ""Predkosc Okapu z HA""
    id: okap_predkosc_ha
    entity_id: fan.fan_hood # <--- ZMIEŃ TO NA PRAWIDŁOWE entity_id TWOJEGO OKAPU W HA!
    attribute: percentage # Odczytujemy atrybut 'percentage' z encji typu fan w HA
    unit_of_measurement: ""%""
    accuracy_decimals: 0
    internal: true # Ten sensor jest uzywany tylko wewnetrznie przez ESPHome


  - platform: template
    name: ""Maksymalna Wilgotność w Domu""
    id: max_humidity_all_sensors # Nowy ID dla sensora maksymalnej wilgotności
    unit_of_measurement: ""%""
    accuracy_decimals: 1
    update_interval: 60s # Ustaw interwał aktualizacji np. na 10 sekund
    lambda: |-
      float max_h = 0.0;

      if (id(wilgotnosc_lazienka).has_state()) {
          max_h = std::max(max_h, id(wilgotnosc_lazienka).state);
      }
      if (id(wilgotnosc_kuchnia).has_state()) {
          max_h = std::max(max_h, id(wilgotnosc_kuchnia).state);
      }
      if (id(wilgotnosc_kotlownia).has_state()) {
          max_h = std::max(max_h, id(wilgotnosc_kotlownia).state);
      }

      //Jeśli masz więcej sensorów, dodaj kolejne bloki if i std::max()

      return max_h;


  - platform: debug
    free:
      name: ""Heap Free""
    block:
      name: ""Heap Max Block""
    loop_time:
      name: ""Loop Time""
    psram:
      name: ""Free PSRAM""
    cpu_frequency:
      name: ""CPU Frequency""
  
  
  - platform: internal_temperature
    name: ""Internal Temperature""

  - platform: uptime
    id: uptime_sensor
    internal: True
    update_interval: 60s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? to_string(days) + ""d "" : """") +
                (hours ? to_string(hours) + ""h "" : """") +
                (minutes ? to_string(minutes) + ""m "" : """") +
                (to_string(seconds) + ""s"")
              ).c_str();

  - platform: homeassistant
    id: co2_value
    entity_id: sensor.co2_salon
    internal: true

  - platform: homeassistant
    id: wilgotnosc_lazienka
    entity_id: sensor.atc_lazienka_parter_humidity
    internal: true

  - platform: homeassistant
    entity_id: sensor.ble_kuchnia_humidity
    id: wilgotnosc_kuchnia
    internal: true

  - platform: homeassistant
    entity_id: sensor.atc_04e8_humidity
    id: wilgotnosc_kotlownia
    internal: true


  - platform: template
    name: ""Wykonane korekty (w tej godzinie)""
    id: licznik_korekt_sensor
    unit_of_measurement: ""x""
    lambda: 'return id(licznik_korekt);'
    update_interval: 60s

  - platform: template
    name: ""Pozostale korekty""
    id: licznik_korekt_pozostale
    unit_of_measurement: ""x""
    lambda: 'return id(limit_korekt_na_godzine) - id(licznik_korekt);'
    update_interval: 60s
  
  
  
  #####################################################################
  #                  KANAL NAWIEWU (POWIETRZE WCHODZACE)             #
  #####################################################################

  # 1. Czujnik SDP810 dla nawiewu - surowe ciśnienie
  - platform: sdp3x
    name: ""Cisnienie Roznicowe Nawiew""
    id: nawiew_raw_pressure
    address: 0x25
    i2c_id: bus_a # Zmień na ID Twojej magistrali dla nawiewu
    update_interval: 5s
    filters:
      # Pierwszy filtr w liście
      - exponential_moving_average:
          alpha: 0.7 # Wcięcie 2 spacje pod 'exponential_moving_average'
      # Drugi filtr w liście. Wcięcie jak pierwszy filtr (myślnik w tej samej kolumnie).
    #  - lambda: 'return x > 0 ? x : 0;'
      
    # 2. Sensor szablonowy - oblicza przepływ dla nawiewu w m3/h
  - platform: template
    name: ""Przeplyw Nawiew m3/h""
    id: nawiew_airflow_m3_h
    update_interval: 5s
    icon: ""mdi:air-filter""
    unit_of_measurement: ""m³/h""
    lambda: |-
      // Stałe fizyczne
      const float p_atm = 101325.0;    // Ciśnienie atmosferyczne w Pa
      const float R = 287.05;          // Stała gazowa dla powietrza J/(kg·K)

      // Pobierz temperaturę (°C) i przelicz na Kelwiny
      float temp_c = id(nawiew_temp).state;
      float temp_k = temp_c + 273.15;

      // Oblicz gęstość powietrza (rho)
      float rho = p_atm / (R * temp_k);

      // Średnica i pole przekroju kanału (0.2 m)
      float duct_diameter = 0.2;
      float duct_radius = duct_diameter / 2.0;
      float duct_area = M_PI * pow(duct_radius, 2.0);

      // Odczytaj ciśnienie w hPa i przelicz na Pa
      float pressure_hpa = id(nawiew_raw_pressure).state;
      float pressure_pa = pressure_hpa * 100.0;

      // Sprawdź, czy ciśnienie dodatnie
      if (pressure_pa <= 0) {
        return 0;
      }

      // Oblicz prędkość i przepływ
      float velocity_mps = sqrt((2.0 * pressure_pa) / rho);
      float flow_m3_s = velocity_mps * duct_area;

      // Przelicz na m³/h
      return flow_m3_s * 3600.0;

  #####################################################################
  #                  KANAL WYWIEWU (POWIETRZE WYCHODZACE)             #
  #####################################################################

  # 3. Czujnik SDP810 dla wywiewu - surowe ciśnienie
  - platform: sdp3x
    name: ""Cisnienie Roznicowe Wywiew""
    id: wywiew_raw_pressure
    address: 0x25
    i2c_id: bus_b # Zmień na ID Twojej magistrali dla wywiewu
    update_interval: 5s
    filters:
      - exponential_moving_average:
          alpha: 0.7
      #- lambda: 'return x > 0 ? x : 0;'
      
  # 4. Sensor szablonowy - oblicza przepływ dla wywiewu w m3/h
  - platform: template
    name: ""Przeplyw Wywiew m3/h""
    id: wywiew_airflow_m3_h
    icon: ""mdi:air-filter""
    unit_of_measurement: ""m³/h""
    update_interval: 5s
    lambda: |-
      // Stałe fizyczne
      const float p_atm = 101325.0;    // Ciśnienie atmosferyczne w Pa
      const float R = 287.05;          // Stała gazowa dla powietrza J/(kg·K)

      // Pobierz temperaturę wywiewu i przelicz na Kelwiny
      float temp_c = id(wywiew_temp).state;
      float temp_k = temp_c + 273.15;

      // Oblicz gęstość powietrza (kg/m³) z równania gazu doskonałego
      float rho = p_atm / (R * temp_k);

      // Parametry kanału
      float duct_diameter = 0.2; // Średnica kanału (m)
      float duct_radius = duct_diameter / 2.0;
      float duct_area = M_PI * pow(duct_radius, 2.0);  // Pole przekroju (m²)

      // Ciśnienie dynamiczne w hPa → Pa
      float pressure_hpa = id(wywiew_raw_pressure).state;
      float pressure_pa = pressure_hpa * 100.0;

      // Jeśli ciśnienie ≤ 0, zwróć 0
      if (pressure_pa <= 0) {
        return 0.0;
      }

      // Oblicz prędkość przepływu (m/s)
      float velocity_mps = sqrt((2.0 * pressure_pa) / rho);

      // Oblicz przepływ objętościowy (m³/s) → przelicz na m³/h
      float flow_m3_s = velocity_mps * duct_area;

      return flow_m3_s * 3600.0;


# 5. Sensor szablonowy - oblicza różnicę przepływu (Nawiew - Wywiew)
  - platform: template
    name: ""Roznica Przeplywu""
    id: flow_difference_m3_h
    icon: ""mdi:compare-arrows""
    unit_of_measurement: ""m³/h""
    update_interval: 10s
    lambda: |-
      if (isnan(id(nawiew_airflow_m3_h).state) || isnan(id(wywiew_airflow_m3_h).state)) {
        return 0.0;
      }
      return id(nawiew_airflow_m3_h).state - id(wywiew_airflow_m3_h).state;
    on_value:
      - if:
          condition:
            # 1. Sprawdź, czy balans przepływu jest włączony
            - switch.is_on: balans_przeplywu_switch
            # 2. Sprawdź, czy minął wystarczający czas od ostatniej korekty
            - lambda: |-
                // Czas opóźnienia w minutach (np. 5 minut)
                const int delay_minutes = 5; // <--- TUTAJ ZMIENIASZ CZAS OPÓŹNIENIA W MINUTACH
                const int delay_seconds = delay_minutes * 60; // Przeliczenie na sekundy

                time_t current_time = id(czas_systemowy).now().timestamp;
                int last_correction_time = id(ostatni_timestamp_korekty);
                return (current_time - last_correction_time) >= delay_seconds;
          then:
            - logger.log:
                format: ""Różnica przepływu: %.1f m³/h""
                args: [""id(flow_difference_m3_h).state""]

            - if:
                condition:
                  lambda: return id(flow_difference_m3_h).state > 30; # Nadciśnienie - nawiew o 25 m³/h większy od wywiewu
                then:
                  - script.execute:
                      id: sprawdz_ograniczenie_korekt
                      korekta_id: 1 # Wywołuje korekta_do_nadcisnienia (zwiększa wywiew)

            - if:
                condition:
                  lambda: return id(flow_difference_m3_h).state < -30; # Podciśnienie - wywiew o 25 m³/h większy od nawiewu
                then:
                  - script.execute:
                      id: sprawdz_ograniczenie_korekt
                      korekta_id: 2 # Wywołuje korekta_do_podcisnienia (zmniejsza wywiew)



 ############   PZEM-004T V3 Reku
  - platform: pzemac
    modbus_id: mod_bus_pzem
    address: 1
    id: pzemac_1
    current:
      name: ""Rekuperator prąd""
      accuracy_decimals: 2 
      id: reku_prad
    voltage:
      name: ""Rekuperator napięcie""
      unit_of_measurement: V
      accuracy_decimals: 2
      id: reku_napiecie
    energy:
      name: ""Rekuperator zużycie energii""
      filters:
        # Wh to kWh is 0.001
        - multiply: 0.001
      unit_of_measurement: kWh
      accuracy_decimals: 3
      id: pg_energia
    power:
      name: ""Rekuperator moc""
      unit_of_measurement: W
      accuracy_decimals: 2
      id: reku_moc
    frequency:
      name: ""Rekuperator częstotliwość""
      unit_of_measurement: Hz
      accuracy_decimals: 2
    power_factor:
      name: ""Rekuperator współczynnik mocy""
      accuracy_decimals: 2
      id: reku_power_factor
    update_interval: 5s

  - platform: total_daily_energy
    name: ""Rekuperator dzienne zużycie energii""
    power_id: pg_energia
    unit_of_measurement: ""kWh""
    accuracy_decimals: 3
    id: pg_daily_kwh
    icon: mdi:counter
    device_class: energy
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  - platform: template
    name: ${friendly_name} sprawność
    unit_of_measurement: ""%""
    lambda: |-
      float dzielnik = id(wywiew_temp).state - id(czerpnia_temp).state;
      if (dzielnik != 0) {
        float dzielna = id(nawiew_temp).state - id(czerpnia_temp).state;
        return (dzielna / dzielnik) * 100.0;
      } else {
        // Zwróć 0 lub inną domyślną wartość, gdy nie można wykonać obliczeń
        return 0;
      }
    accuracy_decimals: 1
    update_interval: 15s

   # sprawność temperaturowa = (T2-T1)/(T3-T1)
   # T1 – temperatura powietrza zewnętrznego (nawiewanego przed wymiennikiem) [°C]
   # T2 – temperatura powietrza nawiewanego za wymiennikiem [°C]
   # T3– temperatura powietrza wywiewanego z pomieszczeń przed wymiennikiem [°C]

  - platform: wifi_signal
    name: ${friendly_name} RSSI
    update_interval: 60s
 
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Temperatura wywiew
    id: wywiew_temp
    register_type: holding
    address: 0x000c #12
    unit_of_measurement: ""°C""
    device_class: ""temperature""
    value_type: U_WORD
    filters:
      - lambda: return x - 40.0;
    #accuracy_decimals: 1
 
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Temperatura czerpnia
    id: czerpnia_temp
    register_type: holding
    address: 0x000d #13
    unit_of_measurement: ""°C""
    device_class: ""temperature""
    value_type: U_WORD
    filters:
      - lambda: return x - 40.0;
    #accuracy_decimals: 1 
    
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Temperatura wyrzutnia
    id: wyrzutnia_temp
    register_type: holding
    address: 0x000f #15
    unit_of_measurement: ""°C""
    device_class: ""temperature""
    value_type: U_WORD
    filters:
      - lambda: return x - 40.0;
    #accuracy_decimals: 1 
     
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Temperatura nawiew
    id: nawiew_temp
    register_type: holding
    address: 0x000e #14
    unit_of_measurement: ""°C""
    device_class: ""temperature""
    value_type: U_WORD
    filters:
      - lambda: return x - 40.0;
    #accuracy_decimals: 1 
   
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} CO2
    id: co2_reku
    register_type: holding
    address: 0x0300 #768
    unit_of_measurement: ""ppm""
    device_class: ""carbon_dioxide""
    value_type: U_WORD
    skip_updates: 100    
    #accuracy_decimals: 1 
     
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Fan running time
    id: fan_running_time
    register_type: holding
    address: 0x0301 #769
    unit_of_measurement: ""min""
    value_type: U_WORD
    filters:
      - lambda: return x * 6.0;
    skip_updates: 12   
    #accuracy_decimals: 1 
     
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Wilgotność
    id: wilgotnosc_reku
    register_type: holding
    address: 0x0302 #770
    unit_of_measurement: ""%""
    device_class: ""humidity""
    value_type: U_WORD
    skip_updates: 10      
    #accuracy_decimals: 1 
     
binary_sensor:
    - platform: homeassistant
      id: okno_salon
      entity_id: binary_sensor.shelly_blu_door_window_ce04_window

    - platform: homeassistant
      id: okno_salon2
      entity_id: binary_sensor.shelly_blu_door_window_24b7_window

    - platform: homeassistant
      id: okno_gabinet_l
      entity_id: binary_sensor.shelly_blu_door_window_cc52_window

    - platform: homeassistant
      id: okno_gabinet_p
      entity_id: binary_sensor.shelly_blu_door_window_882d_window

    - platform: homeassistant
      id: okno_lazienka
      entity_id: binary_sensor.shelly_blu_door_window_06b3_window

    - platform: homeassistant
      id: dom_pusty
      entity_id: input_boolean.dom_pusty
      internal: False
      name: Dom pusty

    - platform: template
      id: czy_jakies_okno_otwarte
      name: ""Czy jakiekolwiek okno otwarte""
      lambda: |-
        return id(okno_salon).state || id(okno_salon2).state || id(okno_gabinet_l).state 
        || id(okno_gabinet_p).state || id(okno_lazienka).state;
      #on_press:
       # then:
        #  - if:
         #     condition:
          #      lambda: return id(aktywny_tryb) != ""okno"";
           #   then:
            #    - logger.log: ""Wykryto otwarte okno — przełączam na tryb OKNO""
             #   - script.execute:
              #      id: set_mode
               #     tryb: ""okno""


      #on_release:
       # then:
        #  - if:
         #     condition:
          #      lambda: return id(aktywny_tryb) == ""okno"";
           #   then:
            #    - logger.log: ""Wszystkie okna zamknięte — przywracam tryb AUTO""
             #   - script.execute:
              #      id: set_mode
               #     tryb: ""auto""

    - platform: status
      name: ${friendly_name} Logger Status

    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} On/Off status 
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0009 #9
      #bitmask: 0x1
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Auto restart status 
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0000 #0
      #bitmask: 0x1
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Nagrzewnica status 
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0001 #1
      #bitmask: 0x1
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Zewnętrzny sygnał ON/OFF 
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0010 #16
      #bitmask: 0x1
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Sygnał ON/OFF czujnika CO2
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0011 #17
      #bitmask: 0x1
  
switch:
  - platform: template
    name: ""Tryb przewietrzania""
    id: tryb_przewietrzania_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - script.execute: wlacz_przewietrzanie
    on_turn_off:
      - script.execute: zakoncz_przewietrzanie

  - platform: template
    name: ""Automatyczny Balans Przeplywu""
    id: balans_przeplywu_switch
    icon: ""mdi:light-switch""
    # Ustawia przełącznik na wyłączony po restarcie ESP
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    name: ${friendly_name} switch
    id: reku_switch
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      if (id(reku_on_off_switch).state==1) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - number.set:
          id: reku_on_off_switch
          value: 1
    turn_off_action:
      - number.set:
          id: reku_on_off_switch
          value: 0 

number:
    - platform: template
      name: ""Czas trwania trybu Impreza""
      id: impreza_czas_trwania_godz
      min_value: 1
      max_value: 8
      step: 1
      unit_of_measurement: ""h""
      mode: BOX
      restore_value: yes
      initial_value: 5 # Domyslny czas trwania 5 godzin
      optimistic: true


    - platform: template
      name: ""Czas trwania trybu Okap""
      id: okap_czas_trwania_min
      min_value: 5
      max_value: 60
      step: 5
      unit_of_measurement: ""min""
      mode: BOX
      restore_value: yes
      initial_value: 15 # Domyslny czas trwania 15 minut
      optimistic: true

    - id: co2_auto_high
      name: ""CO2 Auto High""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 1200
      platform: template
      mode: box

    - id: co2_auto_medium
      name: ""CO2 Auto Medium""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 1000
      platform: template
      mode: box

    - id: co2_auto_low
      name: ""CO2 Auto Low""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 800
      platform: template
      mode: box

    - id: co2_nocny_high
      name: ""CO2 Nocny High""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 800
      platform: template
      mode: box

    - id: co2_nocny_low
      name: ""CO2 Nocny Low""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 700
      platform: template
      mode: box

    - id: wilgotnosc_wysoka
      name: ""Wilgotność Wysoka""
      min_value: 40
      max_value: 100
      step: 1
      unit_of_measurement: ""%""
      optimistic: true
      initial_value: 70
      platform: template
      mode: box

    - id: wilgotnosc_niska
      name: ""Wilgotność Niska""
      min_value: 30
      max_value: 100
      step: 1
      unit_of_measurement: ""%""
      optimistic: true
      initial_value: 55
      platform: template
      mode: box

    - id: wilgotnosc_nocna_high
      name: ""Wilgotność nocna wysoka""
      min_value: 60
      max_value: 100
      step: 1
      unit_of_measurement: ""%""
      optimistic: true
      initial_value: 80
      platform: template
      mode: box

    - id: wilgotnosc_nocna_low
      name: ""Wilgotność nocna niska""
      min_value: 30
      max_value: 100
      step: 1
      unit_of_measurement: ""%""
      optimistic: true
      initial_value: 65
      platform: template
      mode: box
 
    - platform: template
      name: ""Czas przewietrzania""
      id: czas_przewietrzania_minuty
      min_value: 1
      max_value: 30
      step: 1
      unit_of_measurement: ""min""
      optimistic: true
      restore_value: true
      initial_value: 10
      mode: box


    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      id: reku_on_off_switch
      address: 0x0009 #9
      value_type: U_WORD
      min_value: 0
      max_value: 1
      step: 1
      mode: box
      internal: true

    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Temperatura X otwarcia bypass’u
      address: 0x0002 #2
      unit_of_measurement: ""°C""
      id: temp_x_bypass
      value_type: U_WORD
      min_value: 5
      max_value: 30
      step: 1
      mode: box
      entity_category: config

      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Temperatura Y otwarcia bypass’u
      address: 0x0003 #3
      unit_of_measurement: ""°C""
      id: temp_y_bypass
      value_type: U_WORD
      min_value: 2
      max_value: 15
      step: 1
      mode: box
      entity_category: config      
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Interwał odszraniania
      address: 0x0004 #4
      unit_of_measurement: ""min""
      #device_class: ""temperature""
      id: defrosting_interval
      value_type: U_WORD
      min_value: 15
      max_value: 99
      step: 1
      mode: box
      entity_category: config      
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Temperatura odszraniania
      address: 0x0005 #5
      unit_of_measurement: ""°C""
      id: defrosting_enter_temperature
      value_type: U_WORD
      min_value: -9
      max_value: 5
      lambda: ""return x - 40.0;""
      write_lambda: ""return x + 40.0;""
      step: 1
      mode: box
      entity_category: config      
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Czas odszraniania
      address: 0x0006 #6
      unit_of_measurement: ""min""
      #device_class: ""temperature""
      id: defrost_duration_time
      value_type: U_WORD
      min_value: 2
      max_value: 20
      step: 1
      mode: box
      entity_category: config      
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Czujnik CO2
      address: 0x0007 #7
      unit_of_measurement: ""ppm""
      id: co2_set
      value_type: U_WORD
      min_value: 00
      max_value: 2500
      lambda: ""return x * 10.0;""
      write_lambda: ""return x / 10.0;""
      step: 1
      mode: box
      entity_category: config  
      skip_updates: 20       
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Wentylator nawiewny
      icon: ""mdi:fan-speed-1""
      address: 0x000a #10
      lambda: |-
         if (x == 2) {
         return 1;
         }
         if (x == 3) {
         return 2;
         }
         if (x == 5) {
         return 3;           
         }
         if (x == 8) {
         return 4;           
         }         
         if (x == 9) {
         return 5;           
         }           
         if (x == 10) {
         return 6;           
         }             
         if (x == 11) {
         return 7;           
         }            
         if (x == 12) {
         return 8;           
         }
         if (x == 13) {
         return 9;           
         }
         if (x == 14) {
         return 10;           
         } else {
          return NAN;
         }
      write_lambda: |-
         if (x == 1) {
         return 2;
         }
         if (x == 2) {
         return 3;
         }
         if (x == 3) {
         return 5;           
         }
         if (x == 4) {
         return 8;           
         }         
         if (x == 5) {
         return 9;           
         }           
         if (x == 6) {
         return 10;           
         }             
         if (x == 7) {
         return 11;           
         }            
         if (x == 8) {
         return 12;           
         }
         if (x == 9) {
         return 13;           
         }
         if (x == 10) {
         return 14;           
         } else {
          return NAN;
         }  
      #unit_of_measurement: ""%""
      id: wentylator_nawiewny
      value_type: U_WORD
      entity_category: """"
      min_value: 1
      max_value: 10
      step: 1
      mode: slider

    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Wentylator wywiewny
      icon: ""mdi:fan-speed-1""
      address: 0x000b #11
      lambda: |-
         if (x == 2) {
         return 1;
         }
         if (x == 3) {
         return 2;
         }
         if (x == 5) {
         return 3;           
         }
         if (x == 8) {
         return 4;           
         }         
         if (x == 9) {
         return 5;           
         }           
         if (x == 10) {
         return 6;           
         }             
         if (x == 11) {
         return 7;           
         }            
         if (x == 12) {
         return 8;           
         }
         if (x == 13) {
         return 9;           
         }
         if (x == 14) {
         return 10;           
         } else {
          return NAN;
         }
      write_lambda: |-
         if (x == 1) {
         return 2;
         }
         if (x == 2) {
         return 3;
         }
         if (x == 3) {
         return 5;           
         }
         if (x == 4) {
         return 8;           
         }         
         if (x == 5) {
         return 9;           
         }           
         if (x == 6) {
         return 10;           
         }             
         if (x == 7) {
         return 11;           
         }            
         if (x == 8) {
         return 12;           
         }
         if (x == 9) {
         return 13;           
         }
         if (x == 10) {
         return 14;           
         } else {
          return NAN;
         }  
      #unit_of_measurement: ""%""
      id: wentylator_wywiewny
      value_type: U_WORD
      entity_category: """"
      min_value: 1
      max_value: 10
      step: 1
      mode: slider    
      
select:
  - platform: template
    name: ""Tryb rekuperatora (ESP)""
    id: tryb_select_esp
    optimistic: true
    options:
      - auto
      - normalny
      - nocny
      - impreza
      - urlopowy
      - serwisowy
      - okno
      - okap_auto
    initial_option: auto
    restore_value: yes
    on_value:
      then:
        - script.execute:
            id: set_mode
            mode: !lambda 'return x;'
            target_reku_speed: 0

  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Ustawienia wielofunkcyjne
    icon: ""mdi:fan""
    id: multi_sel
    address:  0x0018 #24
    entity_category: config
    value_type: U_WORD
    optimistic: false
    optionsmap:
      ""Kasuj"": 0
      ""Usunięcie alarmu filtra"": 1
      ""Usunięcie harmonogramu tygodniowego"": 2
      
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Ustawienia alarmu filtra
    icon: ""mdi:fan""
    id: filter_sel
    address:  0x0019 #25
    entity_category: config
    value_type: U_WORD
    optimistic: false
    optionsmap:
      ""45 dni"": 0
      ""60 dni"": 1
      ""90 dni"": 2
      ""180 dni"": 3

"
cz04SFkg,WTF,Boss239,C++,Wednesday 23rd of July 2025 12:05:35 PM CDT,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve() {
    int n, m; cin >> n >> m;
    vector<int> ifless(n, 1), ifmore(n, 1);
	// ifless - если меньше остальных, ifmore - если больше остальных. Изначально все могут быть и теми, и теми.
    for (int j = 0; j < m; ++j) {
        int q; cin >> q;
        vector<int> cnt(n, 0);
		// считываем сколько раз он на левой чаше сравнения (отрицательное число значит, что он на противоположной), здесь также учитывается возможность того, что какой-то человек в сравнении участвует несколько раз
        for (int i = 0; i < q; ++i) {
            int a; cin >> a; a--;
            cnt[a]++;
        }
		// сначала добавляем тех, что слева
        for (int i = 0; i < q; ++i) {
            int a; cin >> a; a--;
            cnt[a]--;
        }
		// затем вычитаем тех что справа
        char res; cin >> res;
		// теперь считываем знак
        if (res == '=') {
            for (int i = 0; i < n; ++i) {
                if (cnt[i] != 0) {
                    ifless[i] = 0; ifmore[i] = 0;
                }
            }
        }
		// если равенство, то это значит, что все, у кого по итогу ненулевой вклад равны, а значит больше не могут быть особенными
        else if (res == '>') {
            for (int i = 0; i < n; ++i) {
                if (cnt[i] <= 0) { ifmore[i] = 0; }
                if (cnt[i] >= 0) { ifless[i] = 0; }
            }
        }
		// если больше, то если у кого-то вклад не больше нуля, то его не может быть слева, а значит он не может весить больше, так как слева уже есть человек, который весит больше. По аналогии с меньше и правой частью
        else {
            for (int i = 0; i < n; ++i) {
                if (cnt[i] >= 0) { ifmore[i] = 0; }
                if (cnt[i] <= 0) { ifless[i] = 0; }
            }
        }
		// точно также, но для случая с противоположным знаком просто меняются и знаки сравнения с нулем
    }
    int ans = 0;
	// ищем ответ. Если у нас есть несколько вариантов того, что кто-то может весить больше остальных (или меньше), то ответ сразу 0, так как мы по итогу не сможем отличить эти варианты. Если же какой-то человек одновременно может весить и больше, и меньше, то это ок, ведь его могли просто ни разу не брать, а все остальные были равны.
    for (int i = 0; i < n; ++i) {
        if (ifless[i]) {
            if (ans == 0) ans = i + 1;
            else {
                cout << ""0\n"";
                return;
            }
        }
        if (ifmore[i]) {
            if (ans == 0 || ans == i + 1) ans = i + 1;
            else {
                cout << ""0\n"";
                return;
            }
        }
    }
    cout << ans << endl;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  solve();
}
"
SVREc42D,Untitled,Josif_tepe,C++,Wednesday 23rd of July 2025 10:58:36 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
typedef long long ll;
const int maxn = 200001;
const ll MOD = 1e9 + 7;
int n;
string s;
ll dp[maxn][8];

ll rec(int at, int remainder) {
    if(at == n and remainder == 0) {
        return 1;
    }
    
    if(at == n) {
        return 0;
    }
    
    if(dp[at][remainder] != -1) {
        return dp[at][remainder];
    }
    ll res = 0;
    res += rec(at + 1, remainder);
    res %= MOD;
    
    int new_remainder = (remainder * 10 + (s[at] - '0')) % 8;
    res += rec(at + 1, new_remainder);
    res %= MOD;
    
    dp[at][remainder] = res;
    return res;
}
int main() {
    cin >> n;
    cin >> s;
    
    memset(dp, -1, sizeof dp);
    cout << rec(0, 0) - 1 << endl;
    return 0;
}
"
8kfzktyn,Untitled,Josif_tepe,C++,Wednesday 23rd of July 2025 09:50:03 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
int t,n,k,s;
const int maxs=1001;
int x[maxs];
int dp[maxs][maxs][11];
int rec(int at,int movesleft,int pos){
 if(at==s){
    return 0;
 }
 int res=0;
    if(at != -1 and dp[at][movesleft][pos] != -1) {
        return dp[at][movesleft][pos];
    }
 if(at != -1 and pos==x[at]){
    res=max(res,rec(at+1,movesleft,pos)+1);
    if(movesleft>0){
        if(pos>0){
           res=max(res,rec(at+1,movesleft-1,pos-1)+1);
        }
        if(pos<n){
           res=max(res,rec(at+1,movesleft-1,pos+1)+1);
        }
    }
 }
    
    if(movesleft>0){
        if(pos>0){
           res=max(res,rec(at+1,movesleft-1,pos-1));
        }
        if(pos<n){
           res=max(res,rec(at+1,movesleft-1,pos+1));
        }
    
 }
    res=max(res,rec(at+1,movesleft,pos));
    if(at != -1) {
        dp[at][movesleft][pos] = res;
    }
    return res;
}
 
int main()
{
    cin>>t;
    for(int i = 0;i<t;i++){
        memset(dp, -1, sizeof dp);
        cin>>n>>k>>s;
        for(int j = 0;j<s;j++){
          cin>>x[j];
            x[j]--;
        }
        int rez=rec(-1,k, 0);
        cout<<rez<<endl;
    }
 
    return 0;
}
"
SkBHWwau,Ball Battles script (inf spins),Nythic,Lua,Wednesday 23rd of July 2025 09:21:07 AM CDT,"-- DISCORD: https://discord.gg/u3V8d45P9Q
 



-- Pobranie lokalnego gracza (czyli Ciebie w grze)
local player = game.Players.LocalPlayer

-- Czekanie na załadowanie się folderu ""otherValues"" i wartości ""Spins""
-- Używamy WaitForChild, aby uniknąć błędów, jeśli skrypt uruchomi się zbyt wcześnie
local spinsValue = player:WaitForChild(""otherValues""):WaitForChild(""Spins"")

-- Sprawdzenie, czy na pewno znaleziono obiekt i jest to NumberValue
if spinsValue and spinsValue:IsA(""NumberValue"") then
    -- Ustawienie wartości na nieskończoność. W Lua jest to reprezentowane przez ""math.huge""
    spinsValue.Value = math.huge
    print(""Ustawiono spiny na nieskończoność!"")
else
    warn(""Nie znaleziono obiektu 'Spins' dla gracza: "" .. player.Name)
end"
YqXn4sQu,Untitled,skytless,C++,Wednesday 23rd of July 2025 08:56:28 AM CDT,"#include <iostream>
#include <vector>

using namespace std;

using ll = long long;

void print(vector<ll> &v) {
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << ' ';
    }
    cout << endl;
}

int main() {
    //ll a[] = {2, 7, 11, 12, 18};
    //ll a[3][10];
    
    vector<ll> a;
    vector<ll> b(10);
    vector<ll> c(5);
    for (int i = 0; i < c.size(); i++) {
        c[i] = i + 1;
    }
    
    //print(a);
    //print(b);
    //print(c);
    
    c.push_back(5);
    c.erase(c.begin() + 3);
    c.insert(c.begin() + 3, 10);
    c.pop_back();
    //print(c);
    
    for (auto &x: c) {
        x++;
        cout << x << ' ';
    }
    cout << endl;
    for (auto x: c) {
        cout << x << ' ';
    }
    
    
    //vector<vector<ll>> b(3, vector<ll>(10));
 
    /*
    double d = 3.17;
    cout << d;
    */
    
    
    /*
    char c;
	c = 'D';
	//'a' -> 97, 'b' -> 98
	//'0' -> 48
	//'1' -> 49
	cout << '8' - '0';
	string s = ""abcde0"";
	for (int i = 0; i < s.size(); i++) {
	    cout << s[i] << ' ';
	}
	
	char c = '3';
    cout << int(c);
    cout << char(120);
	*/
    
    
    /*
	ll a = 2e9, b = 2e9;
	ll c;
	c = (ll)a + b;
	cout << a << ' ' << b << endl;
	cout << c;
	*/
	
	
}
"
UnkkFB3z,TDS全部地圖,chen399d,Lua,Wednesday 23rd of July 2025 08:36:52 AM CDT,"TDSMaps = {
    Version = ""0.0"",Author = ""Tseting-nil"",
	Regular = {
		AbandonedCity = { name = ""Abandoned City"", Script = """" },
		AutumnFalling = { name = ""Autumn Falling"", Script = """" },
		Crossroads = { name = ""Crossroads"", Script = """" },
		ForestCamp = { name = ""Forest Camp"", Script = """" },
		FungiIsland = { name = ""Fungi Island"", Script = """" },
		GrassIsle = { name = ""Grass Isle"", Script = """" },
		Harbor = { name = ""Harbor"", Script = """" },
		Necropolis = { name = ""Necropolis"", Script = """" },
		Portland = { name = ""Portland"", Script = """" },
		RetroCrossroads = { name = ""Retro Crossroads"", Script = """" },
		RetroStainedTemple = { name = ""Retro Stained Temple"", Script = """" },
		RocketArena = { name = ""Rocket Arena"", Script = """" },
		SkyIslands = { name = ""Sky Islands"", Script = """" },
		TropicalIsles = { name = ""Tropical Isles"", Script = """" },
		Toyboard = { name = ""Toyboard"", Script = """" },
		UTurn = { name = ""U-Turn"", Script = """" },
		ChessBoard = { name = ""Chess Board"", Script = """" },
		CoralDeep = { name = ""Coral Deep"", Script = """" },
		CrystalCave = { name = ""Crystal Cave"", Script = """" },
		CyberCity = { name = ""Cyber City"", Script = """" },
		DesertedVillage = { name = ""Deserted Village"", Script = """" },
		FarmLands = { name = ""Farm Lands"", Script = """" },
		FourSeasons = { name = ""Four Seasons"", Script = """" },
		Lighthaos = { name = ""Lighthaos"", Script = """" },
		Marshlands = { name = ""Marshlands"", Script = """" },
		MedievalTimes = { name = ""Medieval Times"", Script = """" },
		Meltdown = { name = ""Meltdown"", Script = """" },
		MoonBase = { name = ""Moon Base"", Script = """" },
		Nether = { name = ""Nether"", Script = """" },
		NightStation = { name = ""Night Station"", Script = """" },
		RetroLighthouse = { name = ""Retro Lighthouse"", Script = """" },
		RubyEscort = { name = ""Ruby Escort"", Script = """" },
		Simplicity = { name = ""Simplicity"", Script = """" },
		SpringFever = { name = ""Spring Fever"", Script = """" },
		StainedTemple = { name = ""Stained Temple"", Script = """" },
		SugarRush = { name = ""Sugar Rush"", Script = """" },
		SummerCastle = { name = ""Summer Castle"", Script = """" },
		TropicalIndustries = { name = ""Tropical Industries"", Script = """" },
		WinterBridges = { name = ""Winter Bridges"", Script = """" },
		WreckedBattlefield = { name = ""Wrecked Battlefield"", Script = """" },
		WreckedBattlefieldII = { name = ""Wrecked Battlefield II"", Script = """" },
		AbyssalTrench = { name = ""Abyssal Trench"", Script = """" },
		CandyValley = { name = ""Candy Valley"", Script = """" },
		Cataclysm = { name = ""Cataclysm"", Script = """" },
		ConstructionCrazy = { name = ""Construction Crazy"", Script = """" },
		DustyBridges = { name = ""Dusty Bridges"", Script = """" },
		ForgettenDocks = { name = ""Forgetten Docks"", Script = """" },
		GildedPath = { name = ""Gilded Path"", Script = """" },
		RetroTheHeights = { name = ""Retro The Heights"", Script = """" },
		RetroZone = { name = ""Retro Zone"", Script = """" },
		SacredMountains = { name = ""Sacred Mountains"", Script = """" },
		TheHeights = { name = ""The Heights"", Script = """" },
		WinterAbyss = { name = ""Winter Abyss"", Script = """" },
		BlackSpotExchange = { name = ""Black Spot Exchange"", Script = """" },
		DeadAhead = { name = ""Dead Ahead"", Script = """" },
		HotSpot = { name = ""Hot Spot"", Script = """" },
		InfernalAbyss = { name = ""Infernal Abyss"", Script = """" },
		LayBy = { name = ""Lay By"", Script = """" },
		MasonArch = { name = ""Mason Arch"", Script = """" },
		SpaceCity = { name = ""Space City"", Script = """" },
		WinterStronghold = { name = ""Winter Stronghold"", Script = """" }
	},
	Special = {
		BadlandsII = { name = ""Badlands II"", Script = """" },
		PizzaParty = { name = ""Pizza Party"", Script = """" },
		PollutedWastelandII = { name = ""Polluted Wasteland II"", Script = """" }
	},
	Hardcore = {
		AutumnFalling = { name = ""Autumn Falling"", script = """" },
		Crossroads = { name = ""Crossroads"", script = """" },
		Harbor = { name = ""Harbor"", script = """" },
		CyberCity = { name = ""Cyber City"", script = """" },
		FourSeasons = { name = ""Four Seasons"", script = """" },
		Marshlands = { name = ""Marshlands"", script = """" },
		MedievalTimes = { name = ""Medieval Times"", script = """" },
		Nether = { name = ""Nether"", script = """" },
		NightStation = { name = ""Night Station"", script = """" },
		WreckedBattlefield = { name = ""Wrecked Battlefield"", script = """" },
		WreckedBattlefieldII = { name = ""Wrecked Battlefield II"", script = """" },
		BlackSpotExchange = { name = ""Black Spot Exchange"", script = """" },
		HotSpot = { name = ""Hot Spot"", script = """" },
		InfernalAbyss = { name = ""Infernal Abyss"", script = """" },
		LegacySpaceCity = { name = ""Legacy Space City"", script = """" },
		SpaceCity = { name = ""Space City"", script = """" },
		UnknownGarden = { name = ""Unknown Garden"", script = """" }
	}
}

return TDSMaps
"
smvuLfqd,Automod ana,genericPaster,Python,Wednesday 23rd of July 2025 08:28:49 AM CDT,"#!/usr/bin/env python3
""""""
    Moderation Log Analyzer
    
    Analyzes Reddit moderation logs to track automod effectiveness
    and identify when human moderators are undoing automod actions.
""""""

import json
import re
from datetime import datetime
from collections import defaultdict, Counter
from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional

@dataclass
class ModAction:
    """"""    Represents a single moderation action from the log.
    
    """"""
    time: str
    moderator: str
    action_type: str
    action: str
    content: str
    username: str
    parsed_time: datetime

class ModerationAnalyzer:
    """"""    Analyzes moderation logs to track automod effectiveness and
           human moderator interventions.
    
    """"""
    
    def __init__(self, json_file_path: str):
        """"""        Initialize analyzer with moderation log data.
        
        Args:
            json_file_path: Path to the JSON moderation log file
        """"""
        self.actions = []
        self.load_data(json_file_path)
    
    def load_data(self, json_file_path: str) -> None:
        """"""        Load and parse moderation log data from JSON file.
        
        """"""
        with open(json_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        for entry in data.get('JSONdata', []):
            action = self.parse_action(entry)
            if action:
                self.actions.append(action)
        
        # Sort by time for chronological analysis
        self.actions.sort(key=lambda x: x.parsed_time)
    
    def parse_action(self, entry: Dict) -> Optional[ModAction]:
        """"""        Parse a single log entry into a ModAction object.
        
        Extracts username from content using multiple patterns to handle
        various formats in the mod log.
        """"""
        try:
            content = entry.get('Content', '')
            
            # Extract username using multiple patterns
            username = self.extract_username(content)
            if username == 'unknown':
                return None
            
            # Parse time
            time_str = entry.get('Time', '')
            parsed_time = self.parse_time(time_str)
            
            return ModAction(
                time=time_str,
                moderator=entry.get('Moderator', ''),
                action_type=entry.get('Type', ''),
                action=entry.get('Action', ''),
                content=content,
                username=username,
                parsed_time=parsed_time
            )
        except Exception as e:
            print(f""Error parsing entry: {e}"")
            return None
    
    def extract_username(self, content: str) -> str:
        """"""        Extract username from content using various patterns.
        
        Handles different formats and edge cases like system actions
        and bot-generated content.
        """"""
        # Handle empty or very short content
        if not content or len(content.strip()) < 3:
            return 'system'
        
        # Try different username patterns
        patterns = [
            r'^u/(\S+)'  # Captures non-whitespace characters after u/
        ]
        for pattern in patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                username = match.group(1)
                username = username.rstrip('.,!?:;')
                if len(username) >= 2:
                    return username
        return 'unknown'
    
    def parse_time(self, time_str: str) -> datetime:
        """"""        Parse time string into datetime object.
        
        """"""
        try:
            return datetime.strptime(time_str, '%I:%M %p %b %d, %Y')
        except:
            try:
                return datetime.strptime(time_str, '%H:%M %p %b %d, %Y')
            except:
                return datetime.now()  # Fallback
    
    def identify_undos(self) -> List[Tuple[ModAction, ModAction]]:

        undos = []
        
        # Group all actions by username only
        user_actions = defaultdict(list)
        for action in self.actions:
            user_actions[action.username].append(action)
        
        # Look for AutoMod → Human undo patterns for each user
        for username, actions in user_actions.items():
            # Sort actions by time for this user
            actions.sort(key=lambda x: x.parsed_time)
            
            # Find all AutoMod → Human action pairs
            for i, automod_action in enumerate(actions):
                if 'AutoModerator' not in automod_action.moderator:
                    continue
                    
                # Look for subsequent human actions on same user
                for j in range(i + 1, len(actions)):
                    human_action = actions[j]
                    
                    # Skip if it's another AutoMod action
                    if 'AutoModerator' in human_action.moderator:
                        continue
                    
                    # Check if this human action undoes the AutoMod action
                    if self.is_undo_pair(automod_action, human_action):
                        undos.append((automod_action, human_action))
                        break  # Only match first undo for this AutoMod action
        
        return undos
    
    def is_undo_pair(self, action1: ModAction, action2: ModAction) -> bool:
        """"""        Determine if two actions constitute an undo pair.
        
        For username-based correlation, we look for:
        - AutoMod removes/spams → Human approves/unspams
        - Any opposing moderation actions on the same user
        """"""
        # Define opposing action patterns
        removal_actions = ['Remove', 'Spam']
        approval_actions = ['Approve', 'Unspam']
        
        action1_is_removal = any(word in action1.action for word in removal_actions)
        action1_is_approval = any(word in action1.action for word in approval_actions)
        
        action2_is_removal = any(word in action2.action for word in removal_actions)
        action2_is_approval = any(word in action2.action for word in approval_actions)
        
        # Check if action2 undoes action1
        if action1_is_removal and action2_is_approval:
            return True
        
        # Also check reverse case (though less common in AutoMod context)
        if action1_is_approval and action2_is_removal:
            return True
        
        return False
    
    def generate_summary_report(self) -> str:
        """"""        Generate comprehensive summary report of moderation activity.
        
        """"""
        report = []
        report.append(""="" * 60)
        report.append(""MODERATION LOG ANALYSIS SUMMARY"")
        report.append(""="" * 60)
        
        # Basic statistics
        total_actions = len(self.actions)
        automod_actions = len([a for a in self.actions if 'AutoModerator' in a.moderator])
        human_actions = total_actions - automod_actions
        
        report.append(f""\nBASIC STATISTICS:"")
        report.append(f""Total Actions: {total_actions}"")
        report.append(f""AutoModerator Actions: {automod_actions} ({automod_actions/total_actions*100:.1f}%)"")
        report.append(f""Human Moderator Actions: {human_actions} ({human_actions/total_actions*100:.1f}%)"")
        
        # Action type breakdown
        action_counts = Counter(action.action for action in self.actions)
        report.append(f""\nACTION BREAKDOWN:"")
        for action, count in action_counts.most_common():
            report.append(f""  {action}: {count}"")
        
        # Moderator activity
        mod_counts = Counter(action.moderator for action in self.actions)
        report.append(f""\nMODERATOR ACTIVITY:"")
        for mod, count in mod_counts.most_common():
            report.append(f""  {mod}: {count}"")
        
        # Undo analysis
        undos = self.identify_undos()
        report.append(f""\nUNDO ANALYSIS:"")
        report.append(f""Total Undo Actions Found: {len(undos)}"")
        
        if undos:
            # Categorize undos
            automod_undone = [u for u in undos if 'AutoModerator' in u[0].moderator]
            human_undone = [u for u in undos if 'AutoModerator' not in u[0].moderator]
            
            report.append(f""AutoModerator Actions Undone by Humans: {len(automod_undone)}"")
            report.append(f""Human Actions Undone: {len(human_undone)}"")
            
            if automod_actions > 0:
                undo_rate = len(automod_undone) / automod_actions * 100
                report.append(f""AutoMod Undo Rate: {undo_rate:.2f}%"")
        
        return ""\n"".join(report)

    def get_undoable_actions(self, actions: List[ModAction]) -> List[ModAction]:
        """"""        Filter actions to only those that could potentially be undone.
        
        Only removal/spam actions can be undone by approval/unspam actions.
        """"""
        removal_actions = ['Remove', 'Spam']
        return [action for action in actions 
                if any(word in action.action for word in removal_actions)]
    
    def generate_effectiveness_report(self) -> str:
        """"""        Generate report on automod effectiveness for the experiment.
        
        Separates analysis by content type (Comments vs Posts/Other).
        Only counts undoable actions in effectiveness calculations.
        """"""
        undos = self.identify_undos()
        all_automod_actions = [a for a in self.actions if 'AutoModerator' in a.moderator]
        
        # Only count actions that could potentially be undone
        automod_actions = self.get_undoable_actions(all_automod_actions)
        automod_undone = [u for u in undos if 'AutoModerator' in u[0].moderator]
        
        report = []
        report.append(""="" * 60)
        report.append(""AUTOMOD EFFECTIVENESS ANALYSIS"")
        report.append(""="" * 60)
        
        if not automod_actions:
            if all_automod_actions:
                report.append(""AutoModerator performed actions, but none were undoable removal/spam actions."")
                report.append(f""Total AutoMod actions: {len(all_automod_actions)} (sticky, distinguish, etc.)"")
            else:
                report.append(""No AutoModerator actions found in log."")
            return ""\n"".join(report)
        
        # Show both totals for transparency
        report.append(f""AutoMod total actions: {len(all_automod_actions)}"")
        report.append(f""AutoMod undoable actions (Remove/Spam): {len(automod_actions)}"")
        
        # Separate actions by content type
        comment_actions = [a for a in automod_actions if a.action_type == 'Comments']
        post_actions = [a for a in automod_actions if a.action_type != 'Comments']
        
        comment_undone = [u for u in automod_undone if u[0].action_type == 'Comments']
        post_undone = [u for u in automod_undone if u[0].action_type != 'Comments']
        
        # Overall effectiveness (only for undoable actions)
        total_automod = len(automod_actions)
        undone_count = len(automod_undone)
        effectiveness = ((total_automod - undone_count) / total_automod) * 100 if total_automod > 0 else 0
        
        report.append(f""\nOVERALL EFFECTIVENESS (Undoable Actions Only):"")
        report.append(f""Total AutoMod Undoable Actions: {total_automod}"")
        report.append(f""Actions Undone by Humans: {undone_count}"")
        report.append(f""Effectiveness Rate: {effectiveness:.1f}%"")
        report.append(f""Undo Rate: {(undone_count/total_automod)*100:.1f}%"")
        
        # Comments-specific analysis
        if comment_actions:
            comment_total = len(comment_actions)
            comment_undone_count = len(comment_undone)
            comment_effectiveness = ((comment_total - comment_undone_count) / comment_total) * 100
            
            report.append(f""\nCOMMENT MODERATION EFFECTIVENESS:"")
            report.append(f""Total AutoMod Comment Actions: {comment_total}"")
            report.append(f""Comment Actions Undone: {comment_undone_count}"")
            report.append(f""Comment Effectiveness Rate: {comment_effectiveness:.1f}%"")
            report.append(f""Comment Undo Rate: {(comment_undone_count/comment_total)*100:.1f}%"")
            
            # Break down comment actions by type
            comment_by_action = defaultdict(int)
            comment_undos_by_action = defaultdict(int)
            
            for action in comment_actions:
                comment_by_action[action.action] += 1
            
            for original, _ in comment_undone:
                comment_undos_by_action[original.action] += 1
            
            if comment_by_action:
                report.append(f""\n  Comment Actions Breakdown:"")
                for action_type in comment_by_action:
                    total = comment_by_action[action_type]
                    undone = comment_undos_by_action[action_type]
                    rate = ((total - undone) / total) * 100 if total > 0 else 0
                    
                    report.append(f""    {action_type}:"")
                    report.append(f""      Total: {total}, Undone: {undone}, Effectiveness: {rate:.1f}%"")
        
        # Posts-specific analysis  
        if post_actions:
            post_total = len(post_actions)
            post_undone_count = len(post_undone)
            post_effectiveness = ((post_total - post_undone_count) / post_total) * 100
            
            report.append(f""\nPOST MODERATION EFFECTIVENESS:"")
            report.append(f""Total AutoMod Post Actions: {post_total}"")
            report.append(f""Post Actions Undone: {post_undone_count}"")
            report.append(f""Post Effectiveness Rate: {post_effectiveness:.1f}%"")
            report.append(f""Post Undo Rate: {(post_undone_count/post_total)*100:.1f}%"")
            
            # Break down post actions by type
            post_by_action = defaultdict(int)
            post_undos_by_action = defaultdict(int)
            
            for action in post_actions:
                post_by_action[action.action] += 1
            
            for original, _ in post_undone:
                post_undos_by_action[original.action] += 1
            
            if post_by_action:
                report.append(f""\n  Post Actions Breakdown:"")
                for action_type in post_by_action:
                    total = post_by_action[action_type]
                    undone = post_undos_by_action[action_type]
                    rate = ((total - undone) / total) * 100 if total > 0 else 0
                    
                    report.append(f""    {action_type}:"")
                    report.append(f""      Total: {total}, Undone: {undone}, Effectiveness: {rate:.1f}%"")
               
        return ""\n"".join(report)

def main():
    """"""    Main function to run the analysis.
    
    """"""
    import sys
    
    if len(sys.argv) != 2:
        print(""Usage: python mod_analyzer.py <json_file>"")
        sys.exit(1)
    
    json_file = sys.argv[1]
    
    try:
        analyzer = ModerationAnalyzer(json_file)
        
        print(analyzer.generate_summary_report())
        print(""\n\n"")
        print(analyzer.generate_effectiveness_report())
        print(""\n\n"")
        
    except FileNotFoundError:
        print(f""Error: File '{json_file}' not found."")
    except json.JSONDecodeError:
        print(f""Error: Invalid JSON in file '{json_file}'."")
    except Exception as e:
        print(f""Error analyzing file: {e}"")

if __name__ == ""__main__"":
    main()"
Kdz2tctU,Software Development Company in India,prologictechnologies,CSS,Wednesday 23rd of July 2025 07:39:02 AM CDT,"Prologic Technologies is a trusted software development company in India, specializing in delivering innovative, scalable, and high-performance digital solutions tailored to your business needs. With expertise in AI-powered applications, web and mobile development, custom enterprise software, and digital transformation services, we empower startups, SMBs, and global enterprises to succeed in the modern tech landscape. Our team of experienced developers, UI/UX designers, and solution architects work collaboratively to ensure every project is delivered with precision, agility, and a client-first approach. Partner with Prologic Technologies to turn your ideas into powerful software solutions.

https://www.prologic-technologies.com/"
H4Akvfp9,Untitled,Kubig,JSON,Wednesday 23rd of July 2025 07:38:47 AM CDT,"[
    {
        ""id"": 1,
        ""username"": ""SHOOL"",
        ""password"": ""123456"",
        ""tasks"": [
            {
                ""id"": 1,
                ""title"": ""500 отжиманий"",
                ""description"": ""Сделать 500 отджиманий в день"",
                ""status"": ""Incompleted"",
                ""user"": {
                    ""id"": 1,
                    ""username"": ""SHOOL"",
                    ""password"": ""123456"",
                    ""tasks"": [
                        {
                            ""id"": 1,
                            ""title"": ""500 отжиманий"",
                            ""description"": ""Сделать 500 отджиманий в день"",
                            ""status"": ""Incompleted"",
                            ""user"": {
                                ""id"": 1,
                                ""username"": ""SHOOL"",
                                ""password"": ""123456"",
                                ""tasks"": [
                                    {"
kquH3NmW,巡路模組,chen399d,Lua,Wednesday 23rd of July 2025 07:37:58 AM CDT,"-- Module: TDS_PathfindingModule
local PathfindingService = game:GetService(""PathfindingService"")
local Players = game:GetService(""Players"")
local Workspace = game:GetService(""Workspace"")
local Debris = game:GetService(""Debris"")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild(""Humanoid"")
local rootPart = character:WaitForChild(""HumanoidRootPart"")

-- === 模組表 ===
local TDS = {}

-- === 參數設定 ===
local MAX_RETRIES = 3
local PATHFINDING_TIMEOUT = 5
local PATH_VISUALIZATION_DURATION = 30
local MAX_DEVIATION = 10 -- 偏離距離

-- === 路徑顏色策略 ===
local PATH_COLORS = {
    [1] = { point = BrickColor.new(""Bright red""), connection = BrickColor.new(""Really red"") },
    [2] = { point = BrickColor.new(""Bright green""), connection = BrickColor.new(""Earth green"") },
    [3] = { point = BrickColor.new(""Bright blue""), connection = BrickColor.new(""Really blue"") }
}

local isNavigating = false
local pathParts = {}
local attemptColor = 1

-- === 清除之前路徑顯示 ===
local function clearPathVisualization()
    for _, part in pairs(pathParts) do
        if part and part.Parent then part:Destroy() end
    end
    pathParts = {}
end

-- === 可視化路徑 ===
local function visualizePath(waypoints, colorSet)
    clearPathVisualization()
    for i, waypoint in ipairs(waypoints) do
        local pathPart = Instance.new(""Part"")
        pathPart.Name = ""PathPoint_"" .. i
        pathPart.Anchored = true
        pathPart.CanCollide = false
        pathPart.Material = Enum.Material.Neon
        pathPart.BrickColor = colorSet.point
        pathPart.Size = Vector3.new(1, 0.2, 1)
        pathPart.Position = waypoint.Position
        pathPart.Parent = Workspace

        local light = Instance.new(""PointLight"")
        light.Brightness = 2
        light.Range = 5
        light.Color = colorSet.point.Color
        light.Parent = pathPart

        if i > 1 then
            local prev = waypoints[i-1]
            local distance = (waypoint.Position - prev.Position).Magnitude
            local connection = Instance.new(""Part"")
            connection.Name = ""PathConnection_"" .. (i-1) .. ""_to_"" .. i
            connection.Anchored = true
            connection.CanCollide = false
            connection.Material = Enum.Material.ForceField
            connection.BrickColor = colorSet.connection
            connection.Size = Vector3.new(0.2, 0.2, distance)
            connection.CFrame = CFrame.lookAt((waypoint.Position + prev.Position) / 2, waypoint.Position)
            connection.Parent = Workspace
            table.insert(pathParts, connection)
        end
        table.insert(pathParts, pathPart)
    end
    for _, part in pairs(pathParts) do
        Debris:AddItem(part, PATH_VISUALIZATION_DURATION)
    end
end

-- === 將目標調整到地面 ===
local function snapToGround(position)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character}

    local result = Workspace:Raycast(position + Vector3.new(0, 50, 0), Vector3.new(0, -100, 0), params)
    if result then
        return result.Position + Vector3.new(0, humanoid.HipHeight + 0.5, 0)
    end
    return nil
end

-- === 偏移檢測 ===
local function monitorDeviation(expectedPos)
    local currentPos = rootPart.Position
    return (currentPos - expectedPos).Magnitude <= MAX_DEVIATION
end

-- === 三階段策略尋路 ===
local function tryPathfindingWithStrategies(target)
    for attempt = 1, 3 do
        attemptColor = attempt
        local path = PathfindingService:CreatePath({
            AgentHeight = 5,
            AgentRadius = 2,
            AgentCanJump = true,
            WaypointSpacing = (attempt == 1 and 4) or (attempt == 2 and 2) or 1
        })
        local success, err = pcall(function()
            path:ComputeAsync(rootPart.Position, target)
        end)
        if success and path.Status == Enum.PathStatus.Success then
            print(""✅ 成功找到路徑（策略："" .. attempt .. ""）"")
            return path
        else
            warn(""❌ 策略 "" .. attempt .. "" 失敗："" .. (err or path.Status.Name))
        end
    end
    return nil
end

-- === 移動到單一路徑點 ===
local function moveToWaypoint(waypoint, index, total)
    local start = tick()
    humanoid:MoveTo(waypoint.Position)
    local done = false
    local connection
    connection = humanoid.MoveToFinished:Connect(function()
        done = true
        connection:Disconnect()
    end)
    while not done and tick() - start < PATHFINDING_TIMEOUT do
        wait(0.1)
    end
    if connection then connection:Disconnect() end
    return done
end

-- === 核心導航函數 ===
local function navigateTo(targetPos)
    if isNavigating then return false end
    isNavigating = true
    local adjustedTarget = snapToGround(targetPos)
    if not adjustedTarget then
        warn(""❌ 無法找到地面"")
        isNavigating = false
        return false
    end

    local path = tryPathfindingWithStrategies(adjustedTarget)
    if not path then
        warn(""❌ 所有策略失敗"")
        isNavigating = false
        return false
    end

    local waypoints = path:GetWaypoints()
    if #waypoints == 0 then
        warn(""❌ 路徑點為空"")
        isNavigating = false
        return false
    end

    visualizePath(waypoints, PATH_COLORS[attemptColor])

    for i, wp in ipairs(waypoints) do
        if not isNavigating then return false end

        -- 偏移檢測
        if not monitorDeviation(wp.Position) then
            warn(""⚠️ 偵測到偏移，重新尋路..."")
            isNavigating = false
            return navigateTo(targetPos)
        end

        -- 移動
        if wp.Action == Enum.PathWaypointAction.Walk then
            if not moveToWaypoint(wp, i, #waypoints) then
                warn(""❌ 無法到達節點，重新尋路..."")
                isNavigating = false
                return navigateTo(targetPos)
            end
        elseif wp.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
            wait(0.5)
        end

        -- ✅ 走完該節點 → 刪除對應的方塊 & 連線
        local pointName = ""PathPoint_"" .. i
        local connectionName = ""PathConnection_"" .. (i-1) .. ""_to_"" .. i
        for index, part in ipairs(pathParts) do
            if part.Name == pointName or part.Name == connectionName then
                if part and part.Parent then
                    part:Destroy()
                end
                table.remove(pathParts, index)
            end
        end
    end


    print(""🎉 成功抵達目標！"")
    isNavigating = false
    return true
end

-- === 對外 API ===
function TDS:NavigateToPosition(x, y, z)
    spawn(function()
        navigateTo(Vector3.new(x, y, z))
    end)
end

function TDS:NavigateToPlayer(playerName)
    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild(""HumanoidRootPart"") then
        local pos = targetPlayer.Character.HumanoidRootPart.Position
        self:NavigateToPosition(pos.X, pos.Y, pos.Z)
    else
        warn(""❌ 找不到玩家："" .. playerName)
    end
end

function TDS:StopCurrentNavigation()
    if isNavigating then
        isNavigating = false
        humanoid:MoveTo(rootPart.Position)
        clearPathVisualization()
        print(""⏹️ 導航已停止"")
    else
        print(""ℹ️ 無進行中的導航"")
    end
end
--TDS:NavigateToPosition(7, 129, 151)
return TDS
"
MpHSe6G0,Untitled,wym36,C++,Wednesday 23rd of July 2025 07:28:05 AM CDT,"#include <iostream>
#include <vector>

using namespace std;

int main()
{
	int n, m, q, x, y;
	cin >> n >> m >> q >> x >> y;

	int a[105][105] = {};

	int dx[4] = {0, 1, 0, -1};
	int dy[4] = {1, 0, -1, 0};

	int z = 0;
	for(int i=1; i<=q; i++)
	{
		int t;
		cin >> t;
		if(t == 1)
		{
			x += dx[z];
			y += dy[z];

		}
		if(t == 2)
		{
			z += 1;
			if(z == 4)
			{
				z = 0;
			}
		}

		if(x < 0 || x >= n || y < 0 || y >= m)
		{
			x -= dx[z];
			y -= dy[z];
		}
		else
		{
			a[x][y] = i;
		}
	}

	for(int i=0; i<n; i++)
	{
		for(int j=0; j<m; j++)
			cout << a[i][j] << "" "";
		cout << ""\n"";
	}


    return 0;
}
"
3bZ4kJb3,веб камера,egor230,Python,Wednesday 23rd of July 2025 06:25:08 AM CDT,"import cv2, sys, os, time, warnings, subprocess
from pynput.keyboard import Key, Controller
warnings.filterwarnings('ignore')
# Путь к файлу Haar Cascade (ваш локальный файл)
cascade_path = ""/mnt/807EB5FA7EB5E954/софт/виртуальная машина/linux must have/python_linux/Project/haarcascade_frontalface_default.xml""


def enhance_brightness(frame):
 # Перевод в YUV, улучшение яркости канала Y
 yuv = cv2.cvtColor(frame, cv2.COLOR_BGR2YUV)
 yuv[:, :, 0] = cv2.equalizeHist(yuv[:, :, 0])
 return cv2.cvtColor(yuv, cv2.COLOR_YUV2BGR)


# Проверка существования файла Haar Cascade
if not os.path.exists(cascade_path):
    print(f""Ошибка: Файл каскада не найден по пути {cascade_path}"")
    sys.exit(1)

# Загрузка классификатора Haar Cascade
face_cascade = cv2.CascadeClassifier(cascade_path)
if face_cascade.empty():
    print(f""Ошибка: Не удалось загрузить файл каскада {cascade_path}"")
    sys.exit(1)

# Подключение к веб-камере с использованием V4L2
cap = cv2.VideoCapture('/dev/video0', cv2.CAP_V4L2)  # Попробуйте '/dev/video1', если не работает
if not cap.isOpened():
    print(""Ошибка: Не удалось открыть веб-камеру. Попробуйте '/dev/video1' или другой индекс."")
    # Попытка открыть альтернативное устройство
    cap = cv2.VideoCapture('/dev/video1', cv2.CAP_V4L2)
    if not cap.isOpened():
        print(""Ошибка: Не удалось открыть веб-камеру на '/dev/video1'. Проверьте устройство."")
        sys.exit(1)

# Установка разрешения камеры для ускорения обработки
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)

# Инициализация трекера KCF
tracker = cv2.TrackerKCF_create()
tracker_initialized = False
bbox = None  # Переменная для хранения координат лица
right = 50
left = 220
# Создаем объект для управления клавиатурой
keyboard = Controller()
# Основной цикл обработки кадров
while True: # Если трекер не инициализирован, ищем лицо с помощью Haar Cascade

 # Захват кадра с веб-камеры
 ret, frame = cap.read()

 frame = enhance_brightness(frame)
 if not tracker_initialized:
  # Преобразование кадра в серый цвет для ускорения обнаружения
  gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
  faces = face_cascade.detectMultiScale(gray, scaleFactor=1.3, minNeighbors=3, minSize=(20, 20))

  # Если лицо найдено, инициализируем трекер
  if len(faces) > 0:
   x, y, w, h = faces[0]  # Берем первое обнаруженное лицо
   bbox = (x, y, w, h)
   tracker.init(frame, bbox)
   tracker_initialized = True
 else:  # Обновление трекера для отслеживания лица
  success, bbox = tracker.update(frame)
  x, y, w, h = [int(v) for v in bbox]  # Преобразуем координаты в целые числа
  cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)  # Рисуем зеленый прямоугольник вокруг лица
  cv2.putText(frame, f'({x}, {y})', (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)  # Добавляем координаты над прямоугольником
  if not success: # Если трекер потерял лицо, сбрасываем инициализацию
   tracker_initialized = False
   tracker = cv2.TrackerKCF_create()  # Создаем новый трекер для повторной инициализации

 # Отрисовка прямоугольника и вывод координат

 if bbox is not None:
  if x < right:
    keyboard.press('d')  # Нажимаем и удерживаем кнопку ""d""
  if x > right:
    keyboard.release('d')  # Отпускаем кнопку ""d""
  if x > left:
    keyboard.press('a')  # Нажимаем и удерживаем кнопку ""d""
  if x < left:
   keyboard.release('a')  # Отпускаем кнопку ""d""
 else:
    keyboard.release('d')  # Отпускаем кнопку ""d""
    keyboard.release('a')  # Отпускаем кнопку ""d""
 cv2.imshow(""Head Tracking"", frame) # Отображение кадра с наложенным прямоугольником

 # Выход из цикла по нажатию клавиши 'q'
 if cv2.waitKey(1) & 0xFF == ord('q'):
  break

# Освобождение ресурсов
cap.release()
cv2.destroyAllWindows()

"
K4YSJzzn,Sort and Rename Comcast Bill PDFs by Billing Date,metalx1000,Bash,Wednesday 23rd of July 2025 06:10:33 AM CDT,"#!/bin/bash
######################################################################
#Copyright (C) 2025  Kris Occhipinti
#https://filmsbykris.com

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation version 3 of the License.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
######################################################################

# This will sort/rename Comcast Bill PDFs based on the ""Billing Date"" in the PDF

for pdf in *.pdf; do
  month=""$(pdfgrep -A 1 'Billing Date' ""$pdf"" | tail -n1 | awk '{print $5}')""
  month=""$(date -d ""$month 1 2022"" +%m)""
  year=""$(pdfgrep -A 1 'Billing Date' ""$pdf"" | tail -n1 | awk '{print $7}')""

  mv -v ""$pdf"" ""Comcast Statement ${year}-${month}.pdf""
done
"
8Vh03snA,Fix Links,KukuRuzo,Diff,Wednesday 23rd of July 2025 06:03:45 AM CDT,"diff --git a/README.html b/README.html
index 12028968..1b1f0279 100644
--- a/README.html
+++ b/README.html
@@ -52,7 +52,7 @@ pkgman install psi_plus
 
 <h2>Development</h2>
 
-<p>In 2009 a Psi fork named <a href=""https://psi-plus.com/"">Psi+</a> was started. Project purposes were: implementation of new features, writing of patches and plugins for transferring them to upstream. As of 2017 all active Psi+ developers have become official Psi developers and now Psi+ is just a development branch of Psi with rolling release development model.</p>
+<p>In 2009 a Psi fork named <a href=""https://sourceforge.net/projects/psiplus/"">Psi+</a> was started. Project purposes were: implementation of new features, writing of patches and plugins for transferring them to upstream. As of 2017 all active Psi+ developers have become official Psi developers and now Psi+ is just a development branch of Psi with rolling release development model.</p>
 
 <p>Users who wants to receive new features and bug fixes very quickly may use Psi+ on daily basis. Users who do not care about new trends and prefer constancy may choose Psi as it uses classical development model and its releases are quite rare.</p>
 
@@ -134,7 +134,6 @@ pkgman install psi_plus
 <li><a href=""https://github.com/psi-im/plugins"">Officially supported plugins</a> (sources)</li>
 <li><a href=""https://github.com/psi-im/psimedia"">Multimedia plugin for audio and video calls</a> (sources)</li>
 <li><a href=""https://github.com/psi-im/resources"">Extra resources</a> (iconsets, sounds, skins, themes, etc.)</li>
-<li><a href=""https://psi-plus.com/"">Psi+ project</a> (official website)</li>
 <li><a href=""https://github.com/psi-plus/psi-plus-snapshots"">Psi+ snapshots</a> (sources)</li>
 <li><a href=""https://github.com/psi-plus/psi-plus-l10n"">Psi+ translations</a> (sources)</li>
 </ul>
@@ -149,7 +148,7 @@ pkgman install psi_plus
 <li><a href=""https://sourceforge.net/projects/psiplus/files/macOS/tehnick/"">Psi+ builds for macOS</a></li>
 <li><a href=""https://depot.haiku-os.org/psi_plus"">Psi+ package in Haiku</a></li>
 <li><a href=""https://launchpad.net/~psi-plus/+archive/ubuntu/ppa"">Official PPA for Ubuntu and distros based on it</a> (daily builds)</li>
-<li><a href=""http://notesalexp.org/index-old.html"">Unofficial PPA for Debian and Ubuntu</a> (see <a href=""https://psi-plus.com/wiki/en:debian#nightly_builds"">notes</a> about using it)</li>
+<li><a href=""http://notesalexp.org/index-old.html"">Unofficial PPA for Debian and Ubuntu</a> (see <a href=""https://psi-im.org/wiki/doku.php?id=en:debian#nightly_builds"">notes</a> about using it)</li>
 <li><a href=""https://software.opensuse.org/package/psi-plus"">Unofficial PPA for openSUSE</a> (daily builds)</li>
 <li><a href=""https://copr.fedorainfracloud.org/coprs/valdikss/psi-plus-snapshots/"">Unofficial PPA for Fedora</a> (outdated)</li>
 <li><a href=""https://repology.org/metapackage/psi-plus/versions"">Packages for different Linux distros</a></li>
diff --git a/README.md b/README.md
index 6b37b27d..62f202df 100644
--- a/README.md
+++ b/README.md
@@ -50,7 +50,7 @@ MS Windows users may download official installers and portable builds from [Sour
 
 ## Development
 
-In 2009 a Psi fork named [Psi+](https://psi-plus.com/) was started. Project purposes were: implementation of new features, writing of patches and plugins for transferring them to upstream. As of 2017 all active Psi+ developers have become official Psi developers and now Psi+ is just a development branch of Psi with rolling release development model.
+In 2009 a Psi fork named [Psi+](https://sourceforge.net/projects/psiplus/) was started. Project purposes were: implementation of new features, writing of patches and plugins for transferring them to upstream. As of 2017 all active Psi+ developers have become official Psi developers and now Psi+ is just a development branch of Psi with rolling release development model.
 
 Users who wants to receive new features and bug fixes very quickly may use Psi+ on daily basis. Users who do not care about new trends and prefer constancy may choose Psi as it uses classical development model and its releases are quite rare.
 
@@ -125,7 +125,6 @@ If you want to donate some money for development of Psi and Psi+ project, it is
 * [Officially supported plugins](https://github.com/psi-im/plugins) (sources)
 * [Multimedia plugin for audio and video calls](https://github.com/psi-im/psimedia) (sources)
 * [Extra resources](https://github.com/psi-im/resources) (iconsets, sounds, skins, themes, etc.)
-* [Psi+ project](https://psi-plus.com/) (official website)
 * [Psi+ snapshots](https://github.com/psi-plus/psi-plus-snapshots) (sources)
 * [Psi+ translations](https://github.com/psi-plus/psi-plus-l10n) (sources)
 
@@ -138,7 +137,7 @@ If you want to donate some money for development of Psi and Psi+ project, it is
 * [Psi+ builds for macOS](https://sourceforge.net/projects/psiplus/files/macOS/tehnick/)
 * [Psi+ package in Haiku](https://depot.haiku-os.org/psi_plus)
 * [Official PPA for Ubuntu and distros based on it](https://launchpad.net/~psi-plus/+archive/ubuntu/ppa) (daily builds)
-* [Unofficial PPA for Debian and Ubuntu](http://notesalexp.org/index-old.html) (see [notes](https://psi-plus.com/wiki/en:debian#nightly_builds) about using it)
+* [Unofficial PPA for Debian and Ubuntu](http://notesalexp.org/index-old.html) (see [notes](https://psi-im.org/wiki/doku.php?id=en:debian#nightly_builds) about using it)
 * [Unofficial PPA for openSUSE](https://software.opensuse.org/package/psi-plus) (daily builds)
 * [Unofficial PPA for Fedora](https://copr.fedorainfracloud.org/coprs/valdikss/psi-plus-snapshots/) (outdated)
 * [Packages for different Linux distros](https://repology.org/metapackage/psi-plus/versions)
diff --git a/linux/psi-plus.appdata.xml b/linux/psi-plus.appdata.xml
index 36b0dca1..67b9889c 100644
--- a/linux/psi-plus.appdata.xml
+++ b/linux/psi-plus.appdata.xml
@@ -30,11 +30,11 @@
     <p>Psi+ is a development branch of Psi with rolling release development model. Users who wants to receive new features and bug fixes very quickly may use Psi+ on daily basis. Users who do not care about new trends and prefer constancy may choose Psi as it uses classical development model and its releases are quite rare.</p>
     <p xml:lang=""ru"">Psi+ — это ветка разработки клиента Psi, для которой используется модель разработки с плавающим релизом. Пользователи, которые хотят быстро получать новые функции и исправления ошибок, могут использовать Psi+ на ежедневной основе. Пользователи, которые не заботятся о новых тенденциях и предпочитают постоянство, могут выбрать Psi, поскольку он использует классическую модель разработки и его выпуски довольно редки.</p>
   </description>
-  <url type=""homepage"">https://psi-plus.com/</url>
+  <url type=""homepage"">https://psi-im.org/</url>
   <url type=""bugtracker"">https://github.com/psi-im/psi/issues</url>
   <screenshots>
     <screenshot type=""default"">
-      <image>https://psi-plus.com/wi/psiplus_screen_linux_big.png</image>
+      <image>https://psi-im.org/wiki/lib/exe/fetch.php?cache=&media=psiplus_screen_linux_big.png</image>
     </screenshot>
   </screenshots>
   <content_rating type=""oars-1.1"">
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 93ddc22e..a91f387e 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -188,16 +188,15 @@ elseif(IS_WEBENGINE)
     set(PSI_VER_SUFFIX "", webengine"")
 endif()
 
+set(CLIENT_CAPS_NODE ""https://psi-im.org"")
 if( NOT PSI_PLUS )
     set(CLIENT_NAME ""Psi"")
     set(CLIENT_SNAME ""psi"")
-    set(CLIENT_CAPS_NODE ""https://psi-im.org"")
     set(PSILOGO_PREFIX """")
     set(MAIN_ICON ""psimain.png"")
 else()
     set(CLIENT_NAME ""Psi+"")
     set(CLIENT_SNAME ""psi+"")
-    set(CLIENT_CAPS_NODE ""https://psi-plus.com"")
     set(PSILOGO_PREFIX ""psiplus/"")
     set(MAIN_ICON ""psiplus_icon.png"")
 endif()
diff --git a/src/aboutdlg.cpp b/src/aboutdlg.cpp
index 261f4ae5..acd30747 100644
--- a/src/aboutdlg.cpp
+++ b/src/aboutdlg.cpp
@@ -67,7 +67,7 @@ AboutDlg::AboutDlg(QWidget *parent) : QDialog(parent)
 
     // fill in About Psi+ tab...
     QString psiplus;
-    psiplus += details(QString::fromUtf8(""Psi+ Project""), """", ""psi-dev@conference.jabber.ru"", ""https://psi-plus.com/"",
+    psiplus += details(QString::fromUtf8(""Psi+ Project""), """", ""psi-dev@conference.jabber.ru"", ""https://psi-im.org/"",
                        tr(""Active project members are presents below:""));
     psiplus += details(QString::fromUtf8(""rion""), ""rion4ik@gmail.com"", """", """", tr(""Founder and Lead Patcher""));
     psiplus += details(QString::fromUtf8(""zet""), ""vladimir.shelukhin@gmail.com"", """", """",
diff --git a/src/mainwin.cpp b/src/mainwin.cpp
index 493d9096..6816f0d5 100644
--- a/src/mainwin.cpp
+++ b/src/mainwin.cpp
@@ -1001,7 +1001,7 @@ void MainWin::actOnlineWikiActivated()
 #ifndef PSI_PLUS
         ""https://github.com/psi-im/psi/wiki""
 #else
-        ""https://psi-plus.com/wiki/en:main""
+        ""https://psi-im.org/wiki/""
 #endif
     );
 }
@@ -1009,11 +1009,7 @@ void MainWin::actOnlineWikiActivated()
 void MainWin::actOnlineHomeActivated()
 {
     DesktopUtil::openUrl(
-#ifndef PSI_PLUS
         ""https://psi-im.org""
-#else
-        ""https://psi-plus.com""
-#endif
     );
 }
 
"
08Rm760L,dataNone,TestGuy1,JSON,Wednesday 23rd of July 2025 06:00:10 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '3b3b22af842c3f7187cdb3604fcdd03ffefbfcc68550ba236b33d619072a629f7b00d6a2d8c28f28a65a86468719db9ea9357880a70d8375980b0ca3bd230d015c368346360c456b3cfdcb9f81a6f837a40f9bf6b3099ca70fe9fbebdc32da460354fd6ecc58f3c8a35dddb5c04eb20e58216263e1ff5b0d6ab233ea9341b7da',
  otherdata: [
    '9faa205ac3cab0679766de069ef1ef31',
    '459a6dc8086a83195486447f9e7f7b88',
    'a1ad11d2b8c815e289c8325b716e7a97',
    'edb5055fe2ce8bf1357f9f0ab4705699',
    'a8e57eb45477ec8f00ec9d4e0af4abc2',
    '9703f6f6c3ddaedc943cdc6bfc9d1e22',
    '20336d0afc09dacc3e82ea6e7bb1ca80',
    '160868998c7c55d8876669056cd8a7cb'
  ]
}"
CxwCmZYe,Untitled,coentoro,HTML,Wednesday 23rd of July 2025 05:52:40 AM CDT,"<!-- Startof MGID in article -->
<style type=""text/css"">
   div#div-gpt-ad-mgid-inarticle-placeholder {
   min-height: 370px;
   }
</style>
<div id=""div-gpt-ad-mgid-inarticle-placeholder"" class=""advertisement-placeholder"">
   <div class=""advertisement-text"">
      <div>Advertisement</div>
   </div>
   <div id=""div-gpt-ad-kapanlagi-mgid-inarticle"" class=""advertisement-banner""></div>
</div>
<!-- Endof MGID in article -->"
wJ9AbDuS,Untitled,jdelano,SQL,Wednesday 23rd of July 2025 04:41:22 AM CDT,"tblSensors
ID	CableID	SensorName
1	1	Sensor1
2	1	Sensor2
3	1	Sensor3
4	2	Sensor1
5	2	Sensor2
6	2	Sensor3
7	2	Sensor4
8	3	Sensor 5

Count query results
Sensor1Count	OtherSenorsCount
3				5

Count query 
SELECT
    TOP 1 (
        SELECT
            count(cableid)
        FROM
            tblSensors
        WHERE
            CableID = 1
    ) AS Sensor1Count,
    (
        SELECT
            count(cableid)
        FROM
            tblSensors
        WHERE
            CableID = 2
            OR CableID = 3
    ) AS OtherSenorsCount
FROM
    tblSensors

or if looking for a regular dataset of records then you can use a union query, like:
SELECT
    id,
    SensorName,
    ""First Category"" AS CatName
FROM
    tblSensors
WHERE
    CableID = 1
UNION
SELECT
    id,
    SensorName,
    ""Second Category"" AS CatName
FROM
    tblSensors
WHERE
    CableID = 2
    OR CableID = 3

results:
id	SensorName	CatName
1	Sensor1		First Category
2	Sensor2		First Category
3	Sensor3		First Category
4	Sensor1		Second Category
5	Sensor2		Second Category
6	Sensor3		Second Category
7	Sensor4		Second Category
8	Sensor 5	Second Category"
K4KezT2S,Untitled,kirzecy670,MySQL,Wednesday 23rd of July 2025 04:13:31 AM CDT,"       WITH (
              extract(visitParamExtractString(sentPayload, 'message'), '""custom_type"":""([^""]+)""') AS m_type,
              extract(visitParamExtractString(sentPayload, 'message'), '""subType"":""([^""]+)""') AS m_sub_type,
              visitParamExtractString(sentPayload, 'custom_type') AS s_type,
              visitParamExtractString(sentPayload, 'subType') AS s_sub_type
            )
        SELECT dtSent                                                               AS dt,
               tsSent                                                               AS ts,
               status                                                               AS status,
               multiIf(userDeviceOs = 1 AND m_type != '', m_type,
                       userDeviceOs = 2 AND s_type != '', s_type, '')               AS type,
               multiIf(userDeviceOs = 1 AND sentDebug != 'huawei' AND m_sub_type != '', m_sub_type,
                       userDeviceOs = 1 AND sentDebug = 'huawei' AND s_sub_type != '', s_sub_type,
                       userDeviceOs = 2 AND s_sub_type != '', s_sub_type, pushType) AS sub_type,
               title                                                                AS title,
               text                                                                 AS text,
               toUInt64(userId)                                                     AS user_id,
               userUid                                                              AS user_uid,
               userType                                                             AS user_type,
               userDeviceOs                                                         AS user_device_os
        FROM logs.pushes_sent AS ps
            "
cw3szKme,Untitled,kirzecy670,PostgreSQL,Wednesday 23rd of July 2025 04:09:36 AM CDT,"SELECT 
    dtSent AS dt,
    tsSent AS ts,
    status AS status,
    
    -- Определение типа
    multiIf(
        userDeviceOs = 1 AND extract(visitParamExtractString(sentPayload, 'message'), '""custom_type"":""([^""]+)""') != '', 
            extract(visitParamExtractString(sentPayload, 'message'), '""custom_type"":""([^""]+)""'),
        userDeviceOs = 2 AND visitParamExtractString(sentPayload, 'custom_type') != '', 
            visitParamExtractString(sentPayload, 'custom_type'),
        ''
    ) AS type,

    -- Определение подтипа
    multiIf(
        userDeviceOs = 1 AND sentDebug != 'huawei' AND extract(visitParamExtractString(sentPayload, 'message'), '""subType"":""([^""]+)""') != '', 
            extract(visitParamExtractString(sentPayload, 'message'), '""subType"":""([^""]+)""'),
        userDeviceOs = 1 AND sentDebug = 'huawei' AND visitParamExtractString(sentPayload, 'subType') != '', 
            visitParamExtractString(sentPayload, 'subType'),
        userDeviceOs = 2 AND visitParamExtractString(sentPayload, 'subType') != '', 
            visitParamExtractString(sentPayload, 'subType'),
        pushType
    ) AS sub_type,

    title,
    text,
    toUInt64(userId) AS user_id,
    userUid AS user_uid,
    userType AS user_type,
    userDeviceOs AS user_device_os

FROM logs.pushes_sent AS ps
WHERE dtSent >= today()"
Gt0yMzdQ,Untitled,Goriec,HTML,Wednesday 23rd of July 2025 03:26:28 AM CDT,"                         <size=55><color=#ff0000>[</color><color=#ffffff>P</color><color=#ff0000>L</color><color=#ffffff>]</color> </size><b><size=55><color=#ffb300>P</color><color=#ffb300>o</color><color=#ff8c00>l</color><color=#ff8c00>i</color><color=#ff8c00>g</color><color=#ff4d00>o</color><color=#ff4d00>n</color>
_________________________
             <size=200%><color=blue>INFORMACJE</color>
     <size=150%>Discord <link=""https://discord.gg/xPnUYTaJ7c""><color=red><u>Poligon HardRP</u></color></link></size>
     <size=150%>Regulamin <link=""https://docs.google.com/document/d/1CELQM5qKivXPpjL58nZslN4hqXETngLtXr_vrdy1F-M/edit?tab=t.w6xeasfou8bs""><color=#00ff00><u>Google Docs</u></color></link></size>
     <size=150%>Kontakt:<color=yellow> t48970990@gmail.com</color>
 
======================================"
NzS7S0S7,Lab Solutions,arif334,C++,Wednesday 23rd of July 2025 02:16:29 AM CDT,"// LeetCode 20. Valid Parentheses [Hint: Use Stack]
bool isValid(string x) { // Complexity: O(n)
    stack<char> s;
    for(char c: x) {
        if(c == '(' or c == '{' or c == '[')
            s.push(c);
        else if(s.empty()) return false;
        else {
            char last = s.top();
            s.pop();
            if((last=='(' and c==')') 
               or (last=='{' and c=='}') 
               or (last=='[' and c==']'))
                ;
            else return false;
        }
    }
    return s.empty();
}


// Leetcode 1046. Last Stone Weight [Hint: Use Priority Queue]
int lastStoneWeight(vector<int>& stones) { // Complexity: O(n log n)
    priority_queue<int> pq(stones.begin(), stones.end());

    while(pq.size() > 1) {
        int y = pq.top(); pq.pop();
        int x = pq.top(); pq.pop();
        if(y > x) pq.push(y - x);
    }

    if(!pq.empty()) return pq.top();
    return 0;
}


// LeetCode 239. Sliding Window Maximum [Hint: Use Deque]
vector<int> maxSlidingWindow(vector<int>& nums, int k) { // Complexity: O(n)
    deque<int> dq;
    int n = nums.size();
    vector<int> ans;
    for(int i = 0; i < n; i++) {
        if(!dq.empty() and dq.front()<=(i-k))
            dq.pop_front();

        while(!dq.empty() and nums[dq.back()] < nums[i])
            dq.pop_back();

        dq.push_back(i);
        if(i >= k - 1) ans.push_back(nums[dq.front()]);
    }

    return ans;
}"
ZsLDa7eA,checkBuzzer,username32390394054,C,Wednesday 23rd of July 2025 02:06:27 AM CDT,"const int buzzerPin = 11;  // Pin connected to the speaker

void buzz(uint16_t repeat = 2) {
  const int melody[] = { 1000, 1200, 1000, 1200 };  // Frequencies in Hz
  const int duration = 150; // Duration of each tone in ms

  for (uint16_t r = 0; r < repeat; r++) {
    for (int i = 0; i < sizeof(melody) / sizeof(int); i++) {
      tone(buzzerPin, melody[i]);
      delay(duration);
      noTone(buzzerPin);
      delay(50); // Short pause between tones
    }
    delay(200); // Pause between repetitions
  }
}


void setup()  {
  pinMode(buzzerPin, OUTPUT);
  buzz(10);  // Play the melody 10 times on startup
}

void loop() {
  // Nothing here, we only test in setup()
}

"
bNjHM2ie,WormHandler Module for Be Mole,xyzster,Lua,Tuesday 22nd of July 2025 11:57:04 PM CDT,"local WormManager = {}

-- Get required services
local CollectionService = game:GetService(""CollectionService"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local DataStoreService = game:GetService(""DataStoreService"")
local Players = game:GetService(""Players"")
local DWPevent = ReplicatedStorage:WaitForChild(""Events""):WaitForChild(""DoubleWormPotionEvent"")
local MarketPlaceService = game:GetService(""MarketplaceService"")
local ServerStorage = game:GetService(""ServerStorage"")
local wormStore = DataStoreService:GetDataStore(""PlayerWorms"")


local teleportModule = require(script.Parent.TeleportHandler)

-- Golden Worm function
local FoundGoldenWorm = ReplicatedStorage.Functions.FoundGoldenWorm

-- events
local eventsFolder = ReplicatedStorage.Events
local uiEvent = eventsFolder.UIEvent
local pickUpEvent = ReplicatedStorage.Events.PickUpSound
local wormCountDown = ReplicatedStorage.Events.WormCountdown


-- positioning for worms 
local random = Random.new()

-- store of bools if number of worms has changed
local dataChanged = {}

local playerWorms = {}

-- for storing players with double worm potion or gamepass
local playersWithPotionActive = {}

local playersWithGamepass = {}

-- worm values 
local WORM_VALUE = 1

local GOLDEN_WORM_VALUE = 200


-- xyz coords for terrain to spawn worms
local areaForWorms = workspace[""Dig site mountain""].AreaForWorms  

local cf = areaForWorms.CFrame
local size = areaForWorms.Size

-- Calculate bounds
local WORM_GENERATION_BOUNDS = {
	minX = cf.X - size.X/2,
	maxX = cf.X + size.X/2,
	minZ = cf.Z - size.Z/2,
	maxZ = cf.Z + size.Z/2,
	minY = cf.Y - size.Y/2,
	maxY = cf.Y + size.Y/2
}

areaForWorms:Destroy()
-- when re adding worm >> collectedWorms[worm] = nil

-- how often worm count should be saved
local AUTOSAVE_INTERVAL = 120 

-- used to keep track of worms to stop multiple touched fires unintentionally giving more than one worm
local collectedWorms = {}


-- worm templates
local worm = workspace.Worms.Worm
local goldWorm = workspace.Worms.Golden_Worm

-- gamepass stuff
local purchasedGamePass = eventsFolder.PurchasedGamePass
local GAMEPASS_ID = 1261762621

-- for reseting the dig area
local wormResetFolder = ServerStorage.WormResetObjects
local Terrain = workspace.Terrain
local AreaForResetTp = workspace[""Dig site mountain""].AreaForResetTP

-- area for top worms on server leaderboard
local textOfLeaderBoard = workspace:WaitForChild(""LeaderBoards""):WaitForChild(""TWLeaderboard""):WaitForChild(""SurfaceGui""):WaitForChild(""TextLabel"")

-- cache for player names
local playerNameCache = {}


-- function to find spawn position of worm and spawn
local function findSpawnPosition(newWorm)
	local hitbox = newWorm:FindFirstChild(""Hitbox"")
	if hitbox and hitbox:IsA(""BasePart"") then
		newWorm.PrimaryPart = hitbox  

		newWorm.Parent = workspace.Worms.CopyOfWorms

		-- finding random position to spawn worm at
		local newPos = Vector3.new(
			random:NextInteger(WORM_GENERATION_BOUNDS.minX, WORM_GENERATION_BOUNDS.maxX),
			random:NextInteger(WORM_GENERATION_BOUNDS.minY, WORM_GENERATION_BOUNDS.maxY),
			random:NextInteger(WORM_GENERATION_BOUNDS.minZ, WORM_GENERATION_BOUNDS.maxZ)
		)

		-- Use SetPrimaryPartCFrame instead of MoveTo to set exact position
		newWorm:SetPrimaryPartCFrame(CFrame.new(newPos))
	end
end


-- spawining worms function
local function spawnWorms()
	for i = 1, 2000 do
		-- clones worms 
		local newWorm = worm:Clone()
		
		findSpawnPosition(newWorm)
		
		-- spawn golden worms for every three hundered worms
		if (i % 300) == 0 then
			local newWorm = goldWorm:Clone()

			findSpawnPosition(newWorm)
		end
	end
end


-- get players in dig area
local function getPlayersInsideDigArea(area)
	-- get dimensions of part parsed (part encompassing dig area)
	local regionMin = (area.CFrame * CFrame.new(-area.Size / 2)).Position
	local regionMax = (area.CFrame * CFrame.new(area.Size / 2)).Position

	-- loop through all players and storea and return ones who are in those dimensions
	local playersInside = {}
	for _, player in pairs(game.Players:GetPlayers()) do
		local character = player.Character
		if character and character:FindFirstChild(""HumanoidRootPart"") then
			local pos = character.HumanoidRootPart.Position

			if pos.X >= math.min(regionMin.X, regionMax.X) and pos.X <= math.max(regionMin.X, regionMax.X)
				and pos.Y >= math.min(regionMin.Y, regionMax.Y) and pos.Y <= math.max(regionMin.Y, regionMax.Y)
				and pos.Z >= math.min(regionMin.Z, regionMax.Z) and pos.Z <= math.max(regionMin.Z, regionMax.Z) then
				table.insert(playersInside, player)
			end
		end
	end
	return playersInside
end


-- worm spawner
local function wormSpawnAndReset()
	-- infinitely call
	while true do
		-- spawn worms
		spawnWorms()
		-- every 15 minutes fire countdown 
		task.wait(895)
		wormCountDown:FireAllClients()
		task.wait(5)
		
		-- destroy all current worm clones
		for _, worm in ipairs(workspace.Worms.CopyOfWorms:GetChildren()) do
			worm:Destroy()
		end
		
		-- clone grass and ground parts
		local grassClone = wormResetFolder.Grass
		local groundClone = wormResetFolder.Ground
		
		-- get players to tp and send them back to the lobby
		local playersToTP = getPlayersInsideDigArea(AreaForResetTp)
		
		for _, Aplayer in ipairs(playersToTP) do
			teleportModule.teleportPlayerToLobby(Aplayer)
		end
		
		grassClone.Parent = workspace
		groundClone.Parent = workspace
		-- get info from ground
		local groundCFrame = groundClone.CFrame
		local groundSize = groundClone.Size

		--get info from grass
		local grassCFrame = grassClone.CFrame
		local grassSize = grassClone.Size

		-- fill aresa with grass and ground (cframe, size, material)
		Terrain:FillBlock(groundCFrame, groundSize, Enum.Material.Ground)
		Terrain:FillBlock(grassCFrame, grassSize, Enum.Material.Grass)


		-- delete parts
		groundClone:Destroy()
		grassClone:Destroy()
	end
end


-- spawn worms on loop in anoter thread
task.spawn(wormSpawnAndReset)



-- function for updating ui
local function updateWormUI(player, wormAmount, doTween, showAlert)
	uiEvent:FireClient(player, {
		sentworm = wormAmount,
		doTween = doTween,
		showAlert = showAlert
	})
end


-- touching worms function
local function processWormCollect(worm, wormValue, player)
	-- removes the worm to simulate it being collected
	worm.Parent = nil
	

	-- add worm to players worm count
	local playerID = player.UserId 
	if playerWorms[playerID] then
		-- check if worm is golden by value and makes clean variables for logic
		local isGoldenWorm = wormValue == GOLDEN_WORM_VALUE
		local playerHasPotion = playersWithPotionActive[tostring(player.UserId)]
		local playerOwnsGamepass = playersWithGamepass[tostring(player.UserId)]
		
		-- create and change multiplier depending on what potion/gamepass
		local multiplier = 1
		
		if not isGoldenWorm then
			if playerHasPotion and playerOwnsGamepass then
				multiplier = 4
			elseif playerHasPotion or playerOwnsGamepass then
				multiplier = 2
			end
		end
		
		-- update worms
		playerWorms[playerID] += wormValue * multiplier
		
	end

	-- update ui to reflect new worm count 
	local uiValue = playerWorms[playerID] or 0
	updateWormUI(player, uiValue, true, false)
end


-- find worms and connect touch detection

local goldColour = ""#ffcc00""

for _, worm in pairs(CollectionService:GetTagged(""Worm"")) do
	-- get hitbox of worm
	local hitbox = worm:FindFirstChild(""Hitbox"") 

	if hitbox then
		hitbox.Touched:Connect(function(otherPart)
			-- find player for part that touched
			local partParent = otherPart.Parent
			local player = Players:GetPlayerFromCharacter(partParent)
			
			-- double check worm hasn't been touched before
			if player and not collectedWorms[worm] then
				collectedWorms[worm] = true
				
				-- send message to server if player found a golden worm
				if CollectionService:HasTag(worm, ""GoldenWorm"") then
					local message = ""["" .. player.Name .. "" has found a golden worm!]""
					ReplicatedStorage.Events.ChatEvent:FireAllClients(message, goldColour)
					FoundGoldenWorm:Invoke(player, 1)
					processWormCollect(worm, GOLDEN_WORM_VALUE, player)
				else
					-- plays sound on pickup
					pickUpEvent:FireClient(player)
					processWormCollect(worm, WORM_VALUE, player)
				end
			end
		end)
	end
end



-- saves a player's worm count 
local function saveData(dataStorekey, value)
	local success, err = pcall(function()
		wormStore:SetAsync(dataStorekey, value)
	end)
	if not success then
		warn(""Error saving worm count"")
	end
end



-- Auto saves player worm count when they leave the server
function WormManager.SavePlayer(player)
	local playerID = player.UserId
	if playerWorms[playerID] then
		saveData(playerID, playerWorms[playerID])
	end
end




-- sets worm count when a player joins

function WormManager.LoadPlayer(player)
	-- check at start if the player has the gamepass
	if MarketPlaceService:UserOwnsGamePassAsync(player.UserId, GAMEPASS_ID) then
		playersWithGamepass[tostring(player.UserId)] = true
	end 
	
	local playerID = player.UserId
	
	-- retrive previous worm count
	local success, storedWormCount = pcall(function()
		return wormStore:GetAsync(playerID)
	end)

	if success then
		local currentWorms = storedWormCount or 0
		playerWorms[playerID] = currentWorms

		-- Initial UI update
		updateWormUI(player, currentWorms, false, false)

		-- if the player somehow dies or resets 
		player.CharacterAdded:Connect(function()
			task.wait(1)
			local currentWorms = playerWorms[playerID] or 0
			--update ui
			updateWormUI(player, currentWorms, false, false)
		end)
	else
		uiEvent:FireClient(player, { showAlert = true })
	end

	-- auto-save every 60 seconds
	coroutine.wrap(function()
		while player and player.Parent do
			task.wait(AUTOSAVE_INTERVAL)
			if dataChanged[playerID] then
				saveData(playerID, playerWorms[playerID])
				dataChanged[playerID] = false
			end
		end
	end)()
end



-- Connect player join/leave events, potion and purchasing of gamepass
function WormManager.Init()
	-- double potion 
	DWPevent.OnServerEvent:Connect(function(player)
		-- give for 5 mins then remove potion effect of doubling worm 
		playersWithPotionActive[tostring(player.UserId)] = true
		task.wait(300) 
		playersWithPotionActive[tostring(player.UserId)] = nil
	end)
	
	-- game pass event firing 
	purchasedGamePass.OnServerEvent:Connect(function(player)
		-- double check they have the game pass
		if MarketPlaceService:UserOwnsGamePassAsync(player.UserId, GAMEPASS_ID) then
			playersWithGamepass[tostring(player.UserId)] = true
		end
	end)
	
	
	Players.PlayerAdded:Connect(WormManager.LoadPlayer)
	Players.PlayerRemoving:Connect(WormManager.SavePlayer)
end


-- adding worms ie when buying in shop 
function WormManager.AddWorms(player, amount)
	local playerID = player.UserId
	playerWorms[playerID] = (playerWorms[playerID] or 0) + amount
	dataChanged[playerID] = true

	-- update UI
	updateWormUI(player, playerWorms[playerID], true, false)
end

-- when trying to buy items in shop
function WormManager.DeductWorms(player, amount)
	local playerID = player.UserId
	if not playerWorms[playerID] then 
		return false 
	end
	
	-- check players worms against amount, if the player has enough deducts and returns true, else returns false
	if playerWorms[playerID] >= amount then
		playerWorms[playerID] -= amount
		dataChanged[playerID] = true

		-- update ui
		updateWormUI(player, playerWorms[playerID], true, false)
	
		return true
	else
		return false -- not enough worms
	end
end



-- get name of player from id
local function getPlayerName(userId)
	if playerNameCache[userId] then
		return playerNameCache[userId]
	end

	local success, name = pcall(function()
		return Players:GetNameFromUserIdAsync(userId)
	end)

	if success and name then
		playerNameCache[userId] = name
		return name
	else
		return ""Unknown""
	end
end

-- get top five players by worm count
local function getTop5Players(playerWorms)
	local topList = {}

	-- Convert dictionary to sortable array
	for userId, wormCount in pairs(playerWorms) do
		local playerName = getPlayerName(userId)

		table.insert(topList, {
			PlayerName = playerName,
			Worms = wormCount
		})
	end

	-- Sort descending by worm count
	table.sort(topList, function(a, b)
		return a.Worms > b.Worms
	end)

	-- Return only the top 5
	local top5 = {}
	for i = 1, math.min(5, #topList) do
		table.insert(top5, topList[i])
	end

	return top5
end

-- updates teh leaderboard every 30 seconds
local function updateLeaderBoard()
	while true do
		textOfLeaderBoard.Text = """"
		local topFive = getTop5Players(playerWorms)
		for rank, data in ipairs(topFive) do
			textOfLeaderBoard.Text = textOfLeaderBoard.Text .. string.format(""%d. %s - %d\n"", rank, data.PlayerName, data.Worms)
		end

		task.wait(30) 
	end
end

-- run leaderboard updater in parallel thread
task.spawn(updateLeaderBoard)



return WormManager"
ZFd712wt,gdg-stjohns-python,faiaz-halim,Python,Tuesday 22nd of July 2025 10:10:16 PM CDT,"import os

from flask import Flask, render_template, request
from google import genai
from google.genai import types

app = Flask(__name__)

PROJECT_ID = ""REPLACE_WITH_YOUR_PROJECT_ID""

client = genai.Client(
   vertexai=True,
   project=PROJECT_ID,
   location=""us-central1"",
)

# Define the home page route.
@app.route('/', methods=['GET'])
def index():
   '''
   Renders the home page.
   Returns:The rendered template.
   '''
   return render_template('index.html')


def generate(youtube_link, model, additional_prompt):

   # Prepare youtube video using the provided link
   youtube_video = types.Part.from_uri(
       file_uri=youtube_link,
       mime_type=""video/*"",
   )

   # If addtional prompt is not provided, just append a space
   if not additional_prompt:
       additional_prompt = "" ""

   # Prepare content to send to the model
   contents = [
       youtube_video,
       types.Part.from_text(text=""""""Provide a summary of the video.""""""),
       additional_prompt,
   ]

   # Define content configuration
   generate_content_config = types.GenerateContentConfig(
       temperature = 1,
       top_p = 0.95,
       max_output_tokens = 8192,
       response_modalities = [""TEXT""],
   )

   return client.models.generate_content(
       model = model,
       contents = contents,
       config = generate_content_config,
   ).text

@app.route('/summarize', methods=['GET', 'POST'])
def summarize():
   '''
   Summarize the user provided YouTube video.
   Returns: Summary.
   '''

   # If the request is a POST request, process the form data.
   if request.method == 'POST':
       youtube_link = request.form['youtube_link']
       model = request.form['model']
       additional_prompt = request.form['additional_prompt']
     
       # Generate the summary.
       try:
           summary = generate(youtube_link, model, additional_prompt)
           return summary

       except ValueError as e:
           raise e
 
   # If the request is a GET request, redirect to the home page.
   else:
       return redirect('/')


if __name__ == '__main__':
   server_port = os.environ.get('PORT', '8080')
   app.run(debug=False, port=server_port, host='0.0.0.0')"
Rp9hV7bq,gdg-stjohns-html,faiaz-halim,HTML,Tuesday 22nd of July 2025 10:08:21 PM CDT,"<!DOCTYPE html>
<html>
 <head>
   <title>YouTube Summarizer</title>
   <style>
     body {
       font-family: sans-serif;
       display: flex;
       justify-content: center;
       align-items: center;
       min-height: 100vh;
       background-color: #f4f4f4;
     }
     .container {
       background-color: white;
       padding: 30px;
       border-radius: 8px;
       box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
       text-align: center;
     }
     h2 {
       text-align: center;
       margin-bottom: 20px;
     }
     input[type=""text""], textarea, select {
       width: 100%;
       padding: 10px;
       margin-bottom: 15px;
       border: 1px solid #ccc;
       border-radius: 4px;
       box-sizing: border-box;
     }
     button {
       background-color: #4CAF50;
       color: white;
       padding: 12px 20px;
       border: none;
       border-radius: 4px;
       cursor: pointer;
     }
   </style>
 </head>
 <body>
   <div class=""container"">
     <h2>YouTube Summarizer</h2>
     <form action=""/summarize"" target=""_blank"" method=""post"">
       <input type=""text"" name=""youtube_link"" placeholder=""Enter YouTube Link"">
       <select name=""model"">
         <option value=""gemini-2.0-flash-001"">Gemini 2.0 Flash</option>
       </select>
       <textarea name=""additional_prompt"" placeholder=""Write your additional prompt here. For example: 'explain to me like I am five years old'""></textarea>
       <button type=""submit"">Summarize</button>
     </form>
   </div>
 </body>
</html>"
X7NfJJ7w,parrot code,NeedToSchool1,HTML 5,Tuesday 22nd of July 2025 07:45:12 PM CDT,"Check if the symlink you made exist:

ln -l /usr/lib/x86_64-linux-gnu/libjpeg.so.8

Remove symlink:

sudo rm -i /usr/lib/x86_64-linux-gnu/libjpeg.so.8

Download and install:

wget https://archive.debian.org/debian/pool/main/libj/libjpeg8/libjpeg8_8b-1_amd64.deb

sudo apt install ./libjpeg8_8b-1_amd64.deb"
abVtBQAs,menu-dialog.sh,vagnerfonseeca,Bash,Tuesday 22nd of July 2025 07:32:54 PM CDT,"#!/bin/bash
#
# Script menu.sh 
# Usado para exemplificar o uso de DIALOG nas aulas de Shell Script 
# 
# Criado por: Vagner Fonseca
# Versao: 0.1
#
#
#
# Testa se esta sendo executado no Modo Grafico ou Modo Texto
#
if [ -z $DISPLAY ]; then  
	export DIALOG=$(which dialog)
else
	export DIALOG=$(which Xdialog)
fi
#
# Cria o aquivo onde sera armazenada a resposta da pergunta dentro do dialog e
# se o script for cancelado ele apaga o arquivo
#
tempfile=`tempfile 2>/dev/null` || tempfile=/tmp/test$$
trap ""rm -f $tempfile"" 0 1 2 5 15
#
# Funcao que apresenta o menu para os usuarios escolherem as opcoes
#
function menu {
$DIALOG --backtitle ""Vagner Software LTDA"" --title ""MENU DE OPCOES"" \
        --menu ""Selecione abaixo o que deseja fazer:"" 18 50 10 \
        ""L""  ""Listar o /"" \
        ""D""  ""Exibir a data atual"" \
        ""U""  ""Ver o usuarios logados"" \
        ""K""  ""Ver a versao do Kernel"" \
        ""T""  ""Para ver o tempo de uso"" \
        ""S""  ""Para sair do Script"" 2> $tempfile
}
#
# Funcao que executa o que foi escolhido e apresenta o resultado do que foi feito
#
executa () {
RESP=$(cat $tempfile)
case $RESP in
	[L]) VAR=$(ls -l /); $DIALOG  --backtitle ""Vagner Software LTDA"" --title ""Lista do /"" --msgbox ""$VAR"" 30 80 ;;
	[D]) VAR=$(date); $DIALOG  --backtitle ""Vagner Software LTDA"" --title ""Data"" --msgbox ""$VAR"" 8 50 ;;
	[U]) VAR=$(w); $DIALOG  --backtitle ""Vagner Software LTDA"" --title ""Usuarios Logados"" --msgbox ""$VAR"" 20 80 ;;
	[K]) VAR=$(uname -r); $DIALOG  --backtitle ""Vagner Software LTDA"" --title ""Versao do Kernel"" --msgbox ""$VAR"" 8 40 ;;
	[T]) VAR=$(uptime); $DIALOG  --backtitle ""Vagner Software LTDA"" --title ""Tempo de Ligado"" --msgbox ""$VAR"" 8 70 ;;
	[S]) exit ;;
	*) $DIALOG  --backtitle ""Vagner Software LTDA"" --title ""Mensagem de erro"" --msgbox ""Para sair escolha a opcao S do menu"" 8 50;;
esac
}
#
# Evita que o script seja cancelado por algum sinal enviado por comando ou teclado
#
##trap 'echo ""Operacao Invalida""' 0 1 2 3 5 15 18 20 24
#
# Chama as funcoes dentro de um loop, portanto permanecera na tela ate que seja 
# escolhida a opcao sair
#
while true ; do
	clear
	menu
	executa
done
#
# Fim do script
"
K4eR0FRt,menu-de-texto.sh,vagnerfonseeca,Bash,Tuesday 22nd of July 2025 07:31:46 PM CDT,"#!/bin/bash
# menu-de-texto.sh
# Versao: 
# Script para:
# 2025-07-22 20:52-0300
# Codificacao utf-8
# Autor: Vagner Fonseca

# Cria um menu utilizavel em modo texto




while true ; do

echo -e ""\n""
echo ""Digite W para ver usuarios logados""
echo ""Digite K para ver versao kernel""
echo ""Digite I ver ip de internet""
echo ""Digite R repetir o menu""
echo ""Digite S para sair""
read RESP
echo -e ""\n""

case $RESP in 
	[wW]) w ;;
	[kK]) uname -r ;;
	[iI]) curl -4 https://icanhazip.com/ ;;
	[rR]) continue ;;
	[sS]) break ;;
	*) echo ""opcao nao reconhecida"" ;;
esac

done
echo ""FIM DE SCRIPT""
"
dKqnZD5h,bkp-rsync-var-inc.sh,vagnerfonseeca,Bash,Tuesday 22nd of July 2025 07:31:03 PM CDT,"#!/bin/bash

# A script to perform incremental backups using rsync

set -o errexit
set -o nounset
set -o pipefail

readonly SOURCE_DIR=""/var/log""
readonly BACKUP_DIR=""/mnt/data/backup""
readonly DATETIME=""$(date '+%Y-%m-%d_%H:%M:%S')""
readonly BACKUP_PATH=""${BACKUP_DIR}/${DATETIME}""
readonly LATEST_LINK=""${BACKUP_DIR}/latest""

if [ -d ""$BACKUP_DIR""  ] ; then
	echo ""Diretorio existe""
else
	mkdir -p ""${BACKUP_DIR}""
fi

rsync -av --delete \
  ""${SOURCE_DIR}/"" \
  --link-dest ""${LATEST_LINK}"" \
  --exclude="".cache"" \
  ""${BACKUP_PATH}""

rm -rf ""${LATEST_LINK}""
ln -s ""${BACKUP_PATH}"" ""${LATEST_LINK}""
"
