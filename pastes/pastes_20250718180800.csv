id,title,username,language,date,content
fkCSgfBZ,Prime-run for Nvida discrete graphics cards,srcid,Bash,Friday 18th of July 2025 12:33:50 PM CDT,"#/usr/bin/env bash

__NV_PRIME_RENDER_OFFLOAD=1
__VK_LAYER_NV_optimus=NVIDIA_only
__NV_PRIME_RENDER_OFFLOAD_PROVIDER=NVIDIA-G0
__GLX_VENDOR_LIBRARY_NAME=nvidia

exec ""$@""
"
j3YvkPvK,Bruteforce Example,somdcomputerguy,AutoIt,Friday 18th of July 2025 12:33:42 PM CDT,"#include <Array.au3>

Local $hTimer = TimerInit()
Local $charset = ""abcdefghijklmnopqrstuvwxyz""
;Local $charset = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789""
Local $password = ""pies""
Local $pwdlength = StringLen($password)
Local $startime = @MON &  ""/"" & @MDAY & "" "" & @HOUR & "":"" & @MIN

For $length = 1 To $pwdlength
 Local $combinations = GenerateCombinations($charset, $length)
 For $i = 0 To UBound($combinations) - 1
  Local $fDiff = Round((TimerDiff($hTimer) / 1000) / 60)
  Tooltip(""   Password: "" & $password & ""  "" & $fDiff & @CRLF & ""   "" & $i & "" of "" & UBound($combinations) - 1 & "" -> "" & $length & "" of "" & $pwdlength & "" -> "" & $combinations[$i])
  If CheckPassword($combinations[$i], $password) Then
   ToolTip("""")
   MsgBox(0, ""Password found! "" & $startime & "" -> "" & @MON & ""/"" & @MDAY & "" "" & @HOUR & "":"" & @MIN, $fDiff & "" -> "" & $i & "" -> "" & $combinations[$i])
   Exit
  EndIf
 Next
Next

Func GenerateCombinations($charset, $length)
    Local $result[1] = [""""]
    For $i = 1 To $length
        Local $temp[UBound($result) * StringLen($charset)]
        Local $index = 0
        For $j = 0 To UBound($result) - 1
            For $k = 1 To StringLen($charset)
                $temp[$index] = $result[$j] & StringMid($charset, $k, 1)
                $index += 1
            Next
        Next
        $result = $temp
    Next
    Return $result
EndFunc

Func CheckPassword($attempt, $actualPassword)
    Return $attempt == $actualPassword
EndFunc"
qtkqfFMx,2025-07-18T13:07:28.526570,powerampache,PHP,Friday 18th of July 2025 12:07:27 PM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 47694) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

scrobble() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 47694) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 47694) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
jitZWhbd,Refuelling Test,DomMOW,Lua,Friday 18th of July 2025 12:02:39 PM CDT,"fuelSaid = false
fuelYes = ""Cabbages""

function fuelCheck()
	fuelLevel = turtle.getFuelLevel()
    while not(fuelLevel > 0) do
        if fuelSaid == false then
            fuelSaidCheck()
            hasFuel = true
        end
		shell.run(""refuel all"")
		fuelLevel = turtle.getFuelLevel()
    end
    if hasFuel == true then
        shell.run(""clear"")
        print(""I'm Ready, Master. Type: 'Go' to Start"")
        fuelGoCheck = read()
        fuelGo()
    end
    shell.run(""clear"")
    hasFuel = false
    fuelSaid = false
end

function fuelGo()
    while not(fuelGoCheck == ""Go"") do
        print(""ERROR! Please try Again"")
        print(""Once I have Fuel Type: 'Go'"")
        fuelGoCheck = read()
        shell.run(""clear"")
    end
end

function fuelAdded()
    while not(fuelYes == ""Y"") do
        shell.run(""clear"")
        print(""ERROR! Please try Again"")
        print(""Once I have Fuel, Type: 'Y'"")
        fuelYes = read()
    end
end

function fuelSaidCheck()
    shell.run(""clear"")
    print(""I need Fuel, Master."")
	print(""Once I have Fuel Type: 'Y'"")
    fuelYes = read()
    fuelAdded()
end

while true do
  fuelCheck()
end
"
rte9mveP,raceAIInstaller,SolarFlare123,Lua,Friday 18th of July 2025 11:50:19 AM CDT,"print(""Choosing AI.."")
print(""Installing AI"")

print(""Done!"")"
Tpsx2mNm,Untitled,RTS_Dmitriy,Lua,Friday 18th of July 2025 11:35:21 AM CDT,"-- FUNCTIONS
function signal()
    rs.setOutput(""back"",true)
    sleep(1)
    rs.setOutput(""back"",false)
end

function checkWater()
  rednet.open('bottom')
  rednet.broadcast('check_water')
  id, result = rednet.receive()
  rednet.close()
  return result
end

function slitVodu()
   if checkWater() then
      signal()
      print('Voda slita')
   else
      print('Voda uzhe slita')
   end
end

function haletVodu()
   if checkWater() then    
      print('Bada yga haleta')
   else
      signal()
      print('haleBaey')
   end
end
  
-- PROGRAM
while true do
    print (""Dobro pozhalovat"")
    print (""1 - slit' vodu "")
    print (""2 - napolnit' vodoy "")

    text = read()
    if text == '1' then
        slitVodu()
    elseif text == '2' then
        haletVodu()
    else
        print('Nepravilnaya komanda')
    end
end


"
ueyFQbaA,Untitled,RTS_Dmitriy,Lua,Friday 18th of July 2025 11:15:50 AM CDT,"-- FUNCTIONS
function signal()
    rs.setOutput(""back"",true)
    sleep(1)
    rs.setOutput(""back"",false)
end

function checkWater()
  rednet.open('bottom')
  rednet.broadcast('check_water')
  id, result = rednet.receive()
  rednet.close()
  return result
end

function slitVodu()
   if checkWater()
      signal()
      print('Voda slita')
   else
      print('Voda uzhe slita')
   end
end

-- PROGRAM
print (""Dobro pozhalovat"")
print (""1 - slit' vodu "")
print (""2 - napolnit' vodoy "")

text = read()
if text == '1' then
    slitVodu()
elseif text == '2' then
    --
else
    print('Nepravilnaya komanda')
end


"
MK3PeEGu,Adding New StickPool Features (Fixing Pockets with Bezier Curves + CueStick etc.),alien_fx_fiend,C++,Friday 18th of July 2025 10:27:36 AM CDT,"==++ Here's the full source for (file 1/3 (No OOP-based)) ""Pool-Game-CloneV18.cpp""::: ++==
```Pool-Game-CloneV18.cpp
    #define WIN32_LEAN_AND_MEAN
    #define NOMINMAX
    #include <windows.h>
    #include <d2d1.h>
    #include <dwrite.h>
    #include <fstream> // For file I/O
    #include <iostream> // For some basic I/O, though not strictly necessary for just file ops
    #include <vector>
    #include <cmath>
    #include <string>
    #include <sstream> // Required for wostringstream
    #include <algorithm> // Required for std::max, std::min
    #include <ctime>    // Required for srand, time
    #include <cstdlib> // Required for srand, rand (often included by others, but good practice)
    #include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
    #include <mmsystem.h> // For PlaySound
    #include <tchar.h> //midi func
    #include <thread>
    #include <atomic>
    #include ""resource.h""

    #ifndef HAS_STD_CLAMP
    template <typename T>
    T clamp(const T& v, const T& lo, const T& hi)
    {
        return (v < lo) ? lo : (v > hi) ? hi : v;
    }
    namespace std { using ::clamp; }   // inject into std:: for seamless use
    #define HAS_STD_CLAMP
    #endif

    #pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
    #pragma comment(lib, ""d2d1.lib"")
    #pragma comment(lib, ""dwrite.lib"")
    #pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

    // --- Constants ---
    const float PI = 3.1415926535f;
    const float BALL_RADIUS = 10.0f;
    const float TABLE_LEFT = 100.0f;
    const float TABLE_TOP = 100.0f;
    const float TABLE_WIDTH = 700.0f;
    const float TABLE_HEIGHT = 350.0f;
    const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
    const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
    const float CUSHION_THICKNESS = 20.0f;
    const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
    const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
    const float MAX_SHOT_POWER = 15.0f;
    const float FRICTION = 0.985f; // Friction factor per frame
    const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
    const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
    const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
    const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
    const UINT ID_TIMER = 1;
    const int TARGET_FPS = 60; // Target frames per second for timer

    // --- Enums ---
    // --- MODIFIED/NEW Enums ---
    enum GameState {
        SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
        PRE_BREAK_PLACEMENT,// Player placing cue ball for break
        BREAKING,           // Player is aiming/shooting the break shot
        CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
        CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
        AIMING,             // Player is aiming
        AI_THINKING,        // NEW: AI is calculating its move
        SHOT_IN_PROGRESS,   // Balls are moving
        ASSIGNING_BALLS,    // Turn after break where ball types are assigned
        PLAYER1_TURN,
        PLAYER2_TURN,
        BALL_IN_HAND_P1,
        BALL_IN_HAND_P2,
        GAME_OVER
    };

    enum BallType {
        NONE,
        SOLID,  // Yellow (1-7)
        STRIPE, // Red (9-15)
        EIGHT_BALL, // Black (8)
        CUE_BALL // White (0)
    };

    // NEW Enums for Game Mode and AI Difficulty
    enum GameMode {
        HUMAN_VS_HUMAN,
        HUMAN_VS_AI
    };

    enum AIDifficulty {
        EASY,
        MEDIUM,
        HARD
    };

    enum OpeningBreakMode {
        CPU_BREAK,
        P1_BREAK,
        FLIP_COIN_BREAK
    };

    // --- Structs ---
    struct Ball {
        int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
        BallType type;
        float x, y;
        float vx, vy;
        D2D1_COLOR_F color;
        bool isPocketed;
    };

    struct PlayerInfo {
        BallType assignedType;
        int ballsPocketedCount;
        std::wstring name;
    };

    // --- Global Variables ---

    // Direct2D & DirectWrite
    ID2D1Factory* pFactory = nullptr;
    //ID2D1Factory* g_pD2DFactory = nullptr;
    ID2D1HwndRenderTarget* pRenderTarget = nullptr;
    IDWriteFactory* pDWriteFactory = nullptr;
    IDWriteTextFormat* pTextFormat = nullptr;
    IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""
    IDWriteTextFormat* pBallNumFormat = nullptr;

    // Game State
    HWND hwndMain = nullptr;
    GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
    std::vector<Ball> balls;
    int currentPlayer = 1; // 1 or 2
    PlayerInfo player1Info = { BallType::NONE, 0, L""Vince Woods""/*""Player 1""*/ };
    PlayerInfo player2Info = { BallType::NONE, 0, L""Virtus Pro""/*""CPU""*/ }; // Default P2 name
    bool foulCommitted = false;
    std::wstring gameOverMessage = L"""";
    bool firstBallPocketedAfterBreak = false;
    std::vector<int> pocketedThisTurn;
    // --- NEW: 8-Ball Pocket Call Globals ---
    int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
    int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
    int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
    std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""
         // --- NEW: Remember which pocket the 8?ball actually went into last shot
    int lastEightBallPocketIndex = -1;
    //int lastPocketedIndex = -1; // pocket index (0–5) of the last ball pocketed
    int called = -1;
    bool cueBallPocketed = false;

    // --- NEW: Foul Tracking Globals ---
    int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
    bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
    bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
    // --- End New Foul Tracking Globals ---

    // NEW Game Mode/AI Globals
    GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
    AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
    OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
    bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
    bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
    // bool aiIsThinking = false;       // Replaced by AI_THINKING game state
    // NEW: Flag to indicate if the current shot is the opening break of the game
    bool isOpeningBreakShot = false;

    // NEW: For AI shot planning and visualization
    struct AIPlannedShot {
        float angle;
        float power;
        float spinX;
        float spinY;
        bool isValid; // Is there a valid shot planned?
    };
    AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
    bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
    int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
    const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

    // Input & Aiming
    POINT ptMouse = { 0, 0 };
    bool isAiming = false;
    bool isDraggingCueBall = false;
    // --- ENSURE THIS LINE EXISTS HERE ---
    bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
    // --- End Ensure ---
    bool isSettingEnglish = false;
    D2D1_POINT_2F aimStartPoint = { 0, 0 };
    float cueAngle = 0.0f;
    float shotPower = 0.0f;
    float cueSpinX = 0.0f; // Range -1 to 1
    float cueSpinY = 0.0f; // Range -1 to 1
    float pocketFlashTimer = 0.0f;
    bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
    int draggingBallId = -1;
    bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
    MCIDEVICEID midiDeviceID = 0; //midi func
    std::atomic<bool> isMusicPlaying(false); //midi func
    std::thread musicThread; //midi func
    void StartMidi(HWND hwnd, const TCHAR* midiPath);
    void StopMidi();

    // UI Element Positions
    D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
    D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
    D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
    float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
    D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

    // Corrected Pocket Center Positions (aligned with table corners/edges)
    const D2D1_POINT_2F pocketPositions[6] = {
        {TABLE_LEFT, TABLE_TOP},                           // Top-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
        {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
        {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
        {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
    };

    // Colors
    const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.05f, 0.09f, 0.28f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    //const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    //const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
    const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Goldenrod); // Solids = Yellow Goldenrod
    const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::DarkOrchid);   // Stripes = Red DarkOrchid
    const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
    const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
    //const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
    const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

    // --------------------------------------------------------------------
//  Realistic colours for each id (0-15)
//  0 = cue-ball (white) | 1-7 solids | 8 = eight-ball | 9-15 stripes
// --------------------------------------------------------------------
    static const D2D1_COLOR_F BALL_COLORS[16] =
    {
        D2D1::ColorF(D2D1::ColorF::White),          // 0  cue
        D2D1::ColorF(1.00f, 0.85f, 0.00f),          // 1  yellow
        D2D1::ColorF(0.05f, 0.30f, 1.00f),          // 2  blue
        D2D1::ColorF(0.90f, 0.10f, 0.10f),          // 3  red
        D2D1::ColorF(0.55f, 0.25f, 0.85f),          // 4  purple
        D2D1::ColorF(1.00f, 0.55f, 0.00f),          // 5  orange
        D2D1::ColorF(0.00f, 0.60f, 0.30f),          // 6  green
        D2D1::ColorF(0.50f, 0.05f, 0.05f),          // 7  maroon / burgundy
        D2D1::ColorF(D2D1::ColorF::Black),          // 8  black
        D2D1::ColorF(1.00f, 0.85f, 0.00f),          // 9  (yellow stripe)
        D2D1::ColorF(0.05f, 0.30f, 1.00f),          // 10 blue stripe
        D2D1::ColorF(0.90f, 0.10f, 0.10f),          // 11 red stripe
        D2D1::ColorF(0.55f, 0.25f, 0.85f),          // 12 purple stripe
        D2D1::ColorF(1.00f, 0.55f, 0.00f),          // 13 orange stripe
        D2D1::ColorF(0.00f, 0.60f, 0.30f),          // 14 green stripe
        D2D1::ColorF(0.50f, 0.05f, 0.05f)           // 15 maroon stripe
    };

    // Quick helper
    inline D2D1_COLOR_F GetBallColor(int id)
    {
        return (id >= 0 && id < 16) ? BALL_COLORS[id]
            : D2D1::ColorF(D2D1::ColorF::White);
    }

    // --- Forward Declarations ---
    HRESULT CreateDeviceResources();
    void DiscardDeviceResources();
    void OnPaint();
    void OnResize(UINT width, UINT height);
    void InitGame();
    void GameUpdate();
    void UpdatePhysics();
    void CheckCollisions();
    bool CheckPockets(); // Returns true if any ball was pocketed
    void ProcessShotResults();
    void ApplyShot(float power, float angle, float spinX, float spinY);
    void RespawnCueBall(bool behindHeadstring);
    bool AreBallsMoving();
    void SwitchTurns();
    //bool AssignPlayerBallTypes(BallType firstPocketedType);
    bool AssignPlayerBallTypes(BallType firstPocketedType,
        bool creditShooter = true);
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
    Ball* GetBallById(int id);
    Ball* GetCueBall();
    //void PlayGameMusic(HWND hwnd); //midi func
    void AIBreakShot();

    // Drawing Functions
    void DrawScene(ID2D1RenderTarget* pRT);
    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
    void DrawBalls(ID2D1RenderTarget* pRT);
    void DrawCueStick(ID2D1RenderTarget* pRT);
    void DrawAimingAids(ID2D1RenderTarget* pRT);
    void DrawUI(ID2D1RenderTarget* pRT);
    void DrawPowerMeter(ID2D1RenderTarget* pRT);
    void DrawSpinIndicator(ID2D1RenderTarget* pRT);
    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
    // NEW
    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

    // Helper Functions
    float GetDistance(float x1, float y1, float x2, float y2);
    float GetDistanceSq(float x1, float y1, float x2, float y2);
    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
    template <typename T> void SafeRelease(T** ppT);
    // --- NEW HELPER FORWARD DECLARATIONS ---
    bool IsPlayerOnEightBall(int player);
    void CheckAndTransitionToPocketChoice(int playerID);
    // --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
    // --- End Forward Declaration ---
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

    // --- NEW Forward Declarations ---

    // AI Related
    struct AIShotInfo; // Define below
    void TriggerAIMove();
    void AIMakeDecision();
    void AIPlaceCueBall();
    AIShotInfo AIFindBestShot();
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
    bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
    Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
    bool IsValidAIAimAngle(float angle); // Basic check

    // Dialog Related
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void ShowNewGameDialog(HINSTANCE hInstance);
    void LoadSettings(); // For deserialization
    void SaveSettings(); // For serialization
    const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
    void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

    // --- Forward Declaration for Window Procedure --- <<< Add this line HERE
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // --- NEW Struct for AI Shot Evaluation ---
    struct AIShotInfo {
        bool possible = false;          // Is this shot considered viable?
        Ball* targetBall = nullptr;     // Which ball to hit
        int pocketIndex = -1;           // Which pocket to aim for (0-5)
        D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
        float angle = 0.0f;             // Calculated shot angle
        float power = 0.0f;             // Calculated shot power
        float score = -1.0f;            // Score for this shot (higher is better)
        bool involves8Ball = false;     // Is the target the 8-ball?
        float spinX = 0.0f;
        float spinY = 0.0f;
    };

    /*
    table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
    rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
    gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
    winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
    headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
    bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
    */

    // --- NEW Settings Serialization Functions ---
    void SaveSettings() {
        std::ofstream outFile(SETTINGS_FILE_NAME);
        if (outFile.is_open()) {
            outFile << static_cast<int>(gameMode) << std::endl;
            outFile << static_cast<int>(aiDifficulty) << std::endl;
            outFile << static_cast<int>(openingBreakMode) << std::endl;
            outFile.close();
        }
        // else: Handle error, e.g., log or silently fail
    }

    void LoadSettings() {
        std::ifstream inFile(SETTINGS_FILE_NAME);
        if (inFile.is_open()) {
            int gm, aid, obm;
            if (inFile >> gm) {
                gameMode = static_cast<GameMode>(gm);
            }
            if (inFile >> aid) {
                aiDifficulty = static_cast<AIDifficulty>(aid);
            }
            if (inFile >> obm) {
                openingBreakMode = static_cast<OpeningBreakMode>(obm);
            }
            inFile.close();

            // Validate loaded settings (optional, but good practice)
            if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
            if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
            if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
        }
        // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
    }
    // --- End Settings Serialization Functions ---

    // --- NEW Dialog Procedure ---
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
        switch (message) {
        case WM_INITDIALOG:
        {
            // --- ACTION 4: Center Dialog Box ---
    // Optional: Force centering if default isn't working
            RECT rcDlg, rcOwner, rcScreen;
            HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
            if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

            GetWindowRect(hwndOwner, &rcOwner);
            GetWindowRect(hDlg, &rcDlg);
            CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

            // Offset the owner rect relative to the screen if it's not the desktop
            if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
                OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
            }


            // Calculate centered position
            int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
            int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

            // Ensure it stays within screen bounds (optional safety)
            x = std::max(static_cast<int>(rcScreen.left), x);
            y = std::max(static_cast<int>(rcScreen.top), y);
            if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
                x = rcScreen.right - (rcDlg.right - rcDlg.left);
            if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
                y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


            // Set the dialog position
            SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

            // --- End Centering Code ---

            // Set initial state based on current global settings (or defaults)
            CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

            CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
                (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

            // Enable/Disable AI group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
            // Set initial state for Opening Break Mode
            CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
                (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
            // Enable/Disable Opening Break group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
        }
        return (INT_PTR)TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDC_RADIO_2P:
            case IDC_RADIO_CPU:
            {
                bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
                // Enable/Disable AI group controls based on selection
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
                // Also enable/disable Opening Break Mode group
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
            }
            return (INT_PTR)TRUE;

            case IDOK:
                // Retrieve selected options and store in global variables
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                    gameMode = HUMAN_VS_AI;
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
                }
                else {
                    gameMode = HUMAN_VS_HUMAN;
                    // openingBreakMode doesn't apply to HvsH, can leave as is or reset
                }
                SaveSettings(); // Save settings when OK is pressed
                EndDialog(hDlg, IDOK); // Close dialog, return IDOK
                return (INT_PTR)TRUE;

            case IDCANCEL: // Handle Cancel or closing the dialog
                // Optionally, could reload settings here if you want cancel to revert to previously saved state
                EndDialog(hDlg, IDCANCEL);
                return (INT_PTR)TRUE;
            }
            break; // End WM_COMMAND
        }
        return (INT_PTR)FALSE; // Default processing
    }

    // --- NEW Helper to Show Dialog ---
    void ShowNewGameDialog(HINSTANCE hInstance) {
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
            // User clicked Start, reset game with new settings
            isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
            if (isPlayer2AI) {
                switch (aiDifficulty) {
                case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
                case MEDIUM: player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
                case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
                }
            }
            else {
                player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
            }
            // Update window title
            std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
            if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
            else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
            SetWindowText(hwndMain, windowTitle.c_str());

            InitGame(); // Re-initialize game logic & board
            InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
        }
        else {
            // User cancelled dialog - maybe just resume game? Or exit?
            // For simplicity, we do nothing, game continues as it was.
            // To exit on cancel from F2, would need more complex state management.
        }
    }

    // --- NEW Reset Game Function ---
    void ResetGame(HINSTANCE hInstance) {
        // Call the helper function to show the dialog and re-init if OK clicked
        ShowNewGameDialog(hInstance);
    }

    // --- WinMain ---
    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
        if (FAILED(CoInitialize(NULL))) {
            MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
            return -1;
        }

        // --- NEW: Load settings at startup ---
        LoadSettings();

        // --- NEW: Show configuration dialog FIRST ---
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
            // User cancelled the dialog
            CoUninitialize();
            return 0; // Exit gracefully if dialog cancelled
        }
        // Global gameMode and aiDifficulty are now set by the DialogProc

        // Set AI flag based on game mode
        isPlayer2AI = (gameMode == HUMAN_VS_AI);
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
            case MEDIUM:player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
            case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
            }
        }
        else {
            player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
        }
        // --- End of Dialog Logic ---


        WNDCLASS wc = { };
        wc.lpfnWndProc = WndProc;
        wc.hInstance = hInstance;
        wc.lpszClassName = L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

        if (!RegisterClass(&wc)) {
            MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // --- ACTION 4: Calculate Centered Window Position ---
        const int WINDOW_WIDTH = 1000; // Define desired width
        const int WINDOW_HEIGHT = 700; // Define desired height
        int screenWidth = GetSystemMetrics(SM_CXSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYSCREEN);
        int windowX = (screenWidth - WINDOW_WIDTH) / 2;
        int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

        // --- Change Window Title based on mode ---
        std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

        DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

        hwndMain = CreateWindowEx(
            0, L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/, windowTitle.c_str(), dwStyle,
            windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
            NULL, NULL, hInstance, NULL
        );

        if (!hwndMain) {
            MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // Initialize Direct2D Resources AFTER window creation
        if (FAILED(CreateDeviceResources())) {
            MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        InitGame(); // Initialize game state AFTER resources are ready & mode is set
        Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
        StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
        //PlayGameMusic(hwndMain); //midi func

        ShowWindow(hwndMain, nCmdShow);
        UpdateWindow(hwndMain);

        if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
            MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        MSG msg = { };
        // --- Modified Main Loop ---
        // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
        // or gets reset to it via F2. The main loop runs normally once game starts.
        while (GetMessage(&msg, NULL, 0, 0)) {
            // We might need modeless dialog handling here if F2 shows dialog
            // while window is active, but DialogBoxParam is modal.
            // Let's assume F2 hides main window, shows dialog, then restarts game loop.
            // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }


        KillTimer(hwndMain, ID_TIMER);
        DiscardDeviceResources();
        SaveSettings(); // Save settings on exit
        CoUninitialize();

        return (int)msg.wParam;
    }

    // --- WndProc ---
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        // Declare cueBall pointer once at the top, used in multiple cases
        // For clarity, often better to declare within each case where needed.
        Ball* cueBall = nullptr; // Initialize to nullptr
        switch (msg) {
        case WM_CREATE:
            // Resources are now created in WinMain after CreateWindowEx
            return 0;

        case WM_PAINT:
            OnPaint();
            // Validate the entire window region after painting
            ValidateRect(hwnd, NULL);
            return 0;

        case WM_SIZE: {
            UINT width = LOWORD(lParam);
            UINT height = HIWORD(lParam);
            OnResize(width, height);
            return 0;
        }

        case WM_TIMER:
            if (wParam == ID_TIMER) {
                GameUpdate(); // Update game logic and physics
                InvalidateRect(hwnd, NULL, FALSE); // Request redraw
            }
            return 0;

            // --- NEW: Handle F2 Key for Reset ---
            // --- MODIFIED: Handle More Keys ---
        case WM_KEYDOWN:
        { // Add scope for variable declarations

            // --- FIX: Get Cue Ball pointer for this scope ---
            cueBall = GetCueBall();
            // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
            // --- End Fix ---

            // Check which player can interact via keyboard (Humans only)
            bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

            // --- F1 / F2 Keys (Always available) ---
            if (wParam == VK_F2) {
                HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
                ResetGame(hInstance); // Call reset function
                return 0; // Indicate key was processed
            }
            else if (wParam == VK_F1) {
                MessageBox(hwnd,
                    L""Direct2D-based StickPool game made in C++ from scratch (4827+ lines of code)\n"" // Update line count if needed {2764+ lines}
                    L""First succ    essful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                    L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                    L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions. Midnight Pool 4. 'BLISS' Game Engine.\n""
                    L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                    L""About This Game"", MB_OK | MB_ICONINFORMATION);
                return 0; // Indicate key was processed
            }

            // Check for 'M' key (uppercase or lowercase)
                // Toggle music with ""M""
            if (wParam == 'M' || wParam == 'm') {
                //static bool isMusicPlaying = false;
                if (isMusicPlaying) {
                    // Stop the music
                    StopMidi();
                    isMusicPlaying = false;
                }
                else {
                    // Build the MIDI file path
                    TCHAR midiPath[MAX_PATH];
                    GetModuleFileName(NULL, midiPath, MAX_PATH);
                    // Keep only the directory part
                    TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                    if (lastBackslash != NULL) {
                        *(lastBackslash + 1) = '\0';
                    }
                    // Append the MIDI filename
                    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                    // Start playing MIDI
                    StartMidi(hwndMain, midiPath);
                    isMusicPlaying = true;
                }
            }


            // --- Player Interaction Keys (Only if allowed) ---
            if (canPlayerControl) {
                // --- Get Shift Key State ---
                bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
                float powerStep = 0.2f; // Power step (Adjust as needed)

                switch (wParam) {
                case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle -= angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle < 0) cueAngle += 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_RIGHT: // Rotate Cue Stick Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle += angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_UP: // Decrease Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower -= powerStep;
                        if (shotPower < 0.0f) shotPower = 0.0f;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_DOWN: // Increase Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower += powerStep;
                        if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_SPACE: // Trigger Shot
                    if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                    {
                        if (shotPower > 0.15f) { // Use same threshold as mouse
                           // Reset foul flags BEFORE applying shot
                            firstHitBallIdThisShot = -1;
                            cueHitObjectBallThisShot = false;
                            railHitAfterContact = false;

                            // Play sound & Apply Shot
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                            // Update State
                            currentGameState = SHOT_IN_PROGRESS;
                            foulCommitted = false;
                            pocketedThisTurn.clear();
                            shotPower = 0; // Reset power after shooting
                            isAiming = false; isDraggingStick = false; // Reset aiming flags
                            keyboardAimingActive = false;
                        }
                    }
                    break;

                case VK_ESCAPE: // Cancel Aim/Shot Setup
                    if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                    {
                        shotPower = 0.0f;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = false;
                        // Revert to basic turn state if not breaking
                        if (currentGameState != BREAKING) {
                            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        }
                        //if (currentPlayer == 1) calledPocketP1 = -1;
                        //else                  calledPocketP2 = -1;
                    }
                    break;

                case 'G': // Toggle Cheat Mode
                    cheatModeEnabled = !cheatModeEnabled;
                    if (cheatModeEnabled)
                        MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                    else
                        MessageBeep(MB_OK); // Play a different beep when disabling
                    break;

                default:
                    // Allow default processing for other keys if needed
                    // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                    break;
                } // End switch(wParam) for player controls
                return 0; // Indicate player control key was processed
            } // End if(canPlayerControl)
        } // End scope for WM_KEYDOWN case
        // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
        // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
        return 0;

        case WM_MOUSEMOVE: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- NEW LOGIC: Handle Pocket Hover ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
                int oldHover = currentlyHoveredPocket;
                currentlyHoveredPocket = -1; // Reset
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        currentlyHoveredPocket = i;
                        break;
                    }
                }
                if (oldHover != currentlyHoveredPocket) {
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                // Do NOT return 0 here, allow normal mouse angle update to continue
            }
            // --- END NEW LOGIC ---


            cueBall = GetCueBall(); // Declare and get cueBall pointer

            if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
                Ball* ball = GetBallById(draggingBallId);
                if (ball) {
                    ball->x = (float)ptMouse.x;
                    ball->y = (float)ptMouse.y;
                    ball->vx = ball->vy = 0.0f;
                }
                return 0;
            }

            if (!cueBall) return 0;

            // Update Aiming Logic (Check player turn)
            if (isDraggingCueBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                    currentGameState == PRE_BREAK_PLACEMENT))
            {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                // Tentative position update
                cueBall->x = (float)ptMouse.x;
                cueBall->y = (float)ptMouse.y;
                cueBall->vx = cueBall->vy = 0;
            }
            else if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                //NEW2 MOUSEBOUND CODE = START
                    /*// Clamp mouse inside table bounds during aiming
                    if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
                if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
                if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
                if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
                //NEW2 MOUSEBOUND CODE = END
                // Aiming drag updates angle and power
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                    float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                    shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                }
            }
            else if (isSettingEnglish &&
                ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
            {
                // Setting English
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
            }
            else {
                //DISABLE PERM AIMING = START
                /*// Update visual angle even when not aiming/dragging (Check player turn)
                bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                    (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                    currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

                if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
                {
                    // NEW MOUSEBOUND CODE = START
                        // Only update cue angle if mouse is inside the playable table area
                    if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                        ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                    {
                        // NEW MOUSEBOUND CODE = END
                        Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                        if (cb) {
                            float dx = (float)ptMouse.x - cb->x;
                            float dy = (float)ptMouse.y - cb->y;
                            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                        }
                    } //NEW MOUSEBOUND CODE LINE = DISABLE
                }*/
                //DISABLE PERM AIMING = END
            }
            return 0;
        } // End WM_MOUSEMOVE

        case WM_LBUTTONDOWN: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- FOOLPROOF FIX: This block implements the two-stage pocket selection ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // STAGE 1, STEP 1: Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // STAGE 1, STEP 2: Player clicked on a pocket. Update the choice.
                    // We DO NOT change the game state here. This allows re-selection.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and stay in CHOOSING_POCKET state.
                }

                // STAGE 2, STEP 1: Check if the player is clicking the cue ball to confirm.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // STAGE 2, STEP 2: A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to a generic aiming state.
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message.
                    isAiming = true; // Prepare for aiming.
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable.
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }

            /*// --- FOOLPROOF FIX: This block handles re-selectable pocket choice ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) { // Player clicked on a pocket
                    // FIX: Update the called pocket, but DO NOT change the game state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                    return 0; // Consume the click and stay in CHOOSING_POCKET state
                }

                // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to aiming, not PLAYER1_TURN
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }*/

            /*// --- handle pocket re-selection when choosing 8-ball pocket ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1)
                || (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI))
            {
                POINT pt = { LOWORD(lParam), HIWORD(lParam) };
                for (int i = 0; i < 6; ++i) {
                    float dx = pt.x - pocketPositions[i].x;
                    float dy = pt.y - pocketPositions[i].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // 1) Record the call
                        if (currentPlayer == 1) calledPocketP1 = i;
                        else                  calledPocketP2 = i;
                        // 2) Clear any prompt text
                        pocketCallMessage.clear();
                        // 3) Return to normal aiming state
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        // 4) Redraw (arrow stays because calledPocketP* >= 0)
                        InvalidateRect(hwnd, NULL, FALSE);
                        return 0; // consume click
                    }
                }
                return 0; // clicked outside ? stay in pocket?call until a valid pocket is chosen
            }*/

            // … rest of your click?to?aim logic …

            //replaced /w new code
            /*
            // --- FIX: Add this entire block at the top of WM_LBUTTONDOWN ---
    // This handles input specifically for the pocket selection state.
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // A pocket was clicked. Update the selection but STAY in the choosing state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and wait for the next action.
                }

                // If the player clicks the CUE BALL, that confirms their pocket selection.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }
            // --- END OF THE NEW BLOCK ---
            */
            //new code ends here

            if (cheatModeEnabled) {
                // Allow dragging any ball freely
                for (Ball& ball : balls) {
                    float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                    if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                        isDraggingCueBall = true;
                        draggingBallId = ball.id;
                        if (ball.id == 0) {
                            // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                            if (currentPlayer == 1)
                                currentGameState = BALL_IN_HAND_P1;
                            else if (currentPlayer == 2 && !isPlayer2AI)
                                currentGameState = BALL_IN_HAND_P2;
                        }
                        return 0;
                    }
                }
            }

            Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

            // Check which player is allowed to interact via mouse click
            bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
            // Define states where interaction is generally allowed
            bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == AIMING || currentGameState == BREAKING ||
                currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT);

            // Check Spin Indicator first (Allow if player's turn/aim phase)
            if (canPlayerClickInteract && canInteractState) {
                float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
                if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                    isSettingEnglish = true;
                    float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                    float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                    float dist = GetDistance(dx, dy, 0, 0);
                    if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                    cueSpinX = dx / spinIndicatorRadius;
                    cueSpinY = dy / spinIndicatorRadius;
                    isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                    return 0;
                }
            }

            if (!cueBall) return 0;

            // Check Ball-in-Hand placement/drag
            bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowedToPlace = (isPlacingBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

            if (isPlayerAllowedToPlace) {
                float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                    isDraggingCueBall = true;
                    isAiming = false; isDraggingStick = false;
                }
                else {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                        cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                        cueBall->vx = 0; cueBall->vy = 0;
                        isDraggingCueBall = false;
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                    }
                }
                return 0;
            }

            // Check for starting Aim (Cue Ball OR Stick)
            bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

            if (canAim) {
                const float stickDrawLength = 150.0f * 1.4f;
                float currentStickAngle = cueAngle + PI;
                D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
                D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
                float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
                float stickClickThresholdSq = 36.0f;
                float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

                bool clickedStick = (distToStickSq < stickClickThresholdSq);
                bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

                if (clickedStick || clickedCueArea) {
                    isDraggingStick = clickedStick && !clickedCueArea;
                    isAiming = clickedCueArea;
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    shotPower = 0;
                    float dx = (float)ptMouse.x - cueBall->x;
                    float dy = (float)ptMouse.y - cueBall->y;
                    if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    if (currentGameState != BREAKING) currentGameState = AIMING;
                }
            }
            return 0;
        } // End WM_LBUTTONDOWN


        case WM_LBUTTONUP: {
            // --- FOOLPROOF FIX for Cheat Mode Scoring ---
            if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- This is the new, ""smarter"" logic ---
                            b->isPocketed = true; // Pocket the ball visually.

                            // If the table is open, assign types based on this cheated ball.
                            if (player1Info.assignedType == BallType::NONE && b->id != 0 && b->id != 8) {
                                AssignPlayerBallTypes(b->type, false);
                            }

                            // Now, correctly update the score for the right player.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            break; // Stop checking pockets.
                        }
                    }
                }
            }

            /*if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- Assign ball type on first cheat-pocket if table still open ---
                            if (player1Info.assignedType == BallType::NONE
                                && player2Info.assignedType == BallType::NONE
                                && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                            {
                                // In cheat mode, let's just assign to the current player
                                AssignPlayerBallTypes(b->type);
                            }
                            b->isPocketed = true;
                            pocketedThisTurn.push_back(b->id);

                            // --- FIX FOR CHEAT MODE SCORING ---
                            // Immediately increment the correct player's count based on ball type,
                            // not whose turn it is.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            // --- END FIX ---
                            // --- NEW: If this was the 7th ball, trigger the arrow call UI ---
                            if (b->id != 8) {
                                PlayerInfo& shooter = (currentPlayer == 1 ? player1Info : player2Info);
                                if (shooter.ballsPocketedCount >= 7
                                    && calledPocketP1 < 0
                                    && calledPocketP2 < 0)
                                {
                                    currentGameState = (currentPlayer == 1)
                                        ? CHOOSING_POCKET_P1
                                        : CHOOSING_POCKET_P2;
                                }
                                else {
                                    // For any other cheat?pocket, keep the turn so you can continue aiming
                                    currentGameState = (currentPlayer == 1)
                                        ? PLAYER1_TURN
                                        : PLAYER2_TURN;
                                }
                            }
                            // --- NEW: If it was the 8-Ball, award instant victory ---
                            else {
                                currentGameState = GAME_OVER;
                                gameOverMessage = (currentPlayer == 1 ? player1Info.name : player2Info.name)
                                    + std::wstring(L"" Wins!"");
                            }
                            break;
                        }
                    }
                }
            }*/

            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            Ball* cueBall = GetCueBall(); // Get cueBall pointer

            // Check for releasing aim drag (Stick OR Cue Ball)
            if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                bool wasAiming = isAiming;
                bool wasDraggingStick = isDraggingStick;
                isAiming = false; isDraggingStick = false;

                if (shotPower > 0.15f) { // Check power threshold
                    if (currentGameState != AI_THINKING) {
                        firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false; pocketedThisTurn.clear();
                    }
                }
                else if (currentGameState != AI_THINKING) { // Revert state if power too low
                    if (currentGameState == BREAKING) { /* Still breaking */ }
                    else {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                    }
                }
                shotPower = 0; // Reset power indicator regardless
            }

            // Handle releasing cue ball drag (placement)
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                // Check player allowed to place
                bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
                bool isPlayerAllowed = (isPlacingState &&
                    ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                        (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                        (currentGameState == PRE_BREAK_PLACEMENT)));

                if (isPlayerAllowed && cueBall) {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                        // Finalize position already set by mouse move
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                        /* ----------------------------------------------------
                        If the player who now has the turn is already on the
                        8-ball, immediately switch to pocket-selection state.
                        ---------------------------------------------------- */
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        {
                            CheckAndTransitionToPocketChoice(currentPlayer);
                        }
                    }
                    else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
                }
            }

            // Handle releasing english setting
            if (isSettingEnglish) {
                isSettingEnglish = false;
            }
            return 0;
        } // End WM_LBUTTONUP

        case WM_DESTROY:
            isMusicPlaying = false;
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
                SaveSettings(); // Save settings on exit
            }
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
        return 0;
    }

    // --- Direct2D Resource Management ---

    HRESULT CreateDeviceResources() {
        HRESULT hr = S_OK;

        // Create Direct2D Factory
        if (!pFactory) {
            hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
            if (FAILED(hr)) return hr;
        }

        // Create DirectWrite Factory
        if (!pDWriteFactory) {
            hr = DWriteCreateFactory(
                DWRITE_FACTORY_TYPE_SHARED,
                __uuidof(IDWriteFactory),
                reinterpret_cast<IUnknown**>(&pDWriteFactory)
            );
            if (FAILED(hr)) return hr;
        }

        // Create Text Formats
        if (!pTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                16.0f, L""en-us"", &pTextFormat
            );
            if (FAILED(hr)) return hr;
            // Center align text
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }
        if (!pLargeTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                48.0f, L""en-us"", &pLargeTextFormat
            );
            if (FAILED(hr)) return hr;
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }

        if (!pBallNumFormat && pDWriteFactory)
        {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", nullptr,
                DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                10.0f,                       // << small size for ball decals
                L""en-us"",
                &pBallNumFormat);
            if (SUCCEEDED(hr))
            {
                pBallNumFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pBallNumFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            }
        }


        // Create Render Target (needs valid hwnd)
        if (!pRenderTarget && hwndMain) {
            RECT rc;
            GetClientRect(hwndMain, &rc);
            D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

            hr = pFactory->CreateHwndRenderTarget(
                D2D1::RenderTargetProperties(),
                D2D1::HwndRenderTargetProperties(hwndMain, size),
                &pRenderTarget
            );
            if (FAILED(hr)) {
                // If failed, release factories if they were created in this call
                SafeRelease(&pTextFormat);
                SafeRelease(&pLargeTextFormat);
                SafeRelease(&pDWriteFactory);
                SafeRelease(&pFactory);
                pRenderTarget = nullptr; // Ensure it's null on failure
                return hr;
            }
        }

        return hr;
    }

    void DiscardDeviceResources() {
        SafeRelease(&pRenderTarget);
        SafeRelease(&pTextFormat);
        SafeRelease(&pLargeTextFormat);
        SafeRelease(&pBallNumFormat);            // NEW
        SafeRelease(&pDWriteFactory);
        // Keep pFactory until application exit? Or release here too? Let's release.
        SafeRelease(&pFactory);
    }

    void OnResize(UINT width, UINT height) {
        if (pRenderTarget) {
            D2D1_SIZE_U size = D2D1::SizeU(width, height);
            pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
        }
    }

    // --- Game Initialization ---
    void InitGame() {
        srand((unsigned int)time(NULL)); // Seed random number generator
        isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
        aiPlannedShotDetails.isValid = false; // Reset AI planned shot
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = 0;
        // ... (rest of InitGame())

        // --- Ensure pocketed list is clear from the absolute start ---
        pocketedThisTurn.clear();

        balls.clear(); // Clear existing balls

        // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
        player1Info.assignedType = BallType::NONE;
        player1Info.ballsPocketedCount = 0;
        // Player 1 Name usually remains ""Player 1""
        player2Info.assignedType = BallType::NONE;
        player2Info.ballsPocketedCount = 0;
        // Player 2 Name is set based on gameMode in ShowNewGameDialog
            // --- Reset any 8?Ball call state on new game ---
        lastEightBallPocketIndex = -1;
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage = L"""";
        aiPlannedShotDetails.isValid = false; // THIS IS THE CRITICAL FIX: Reset the AI's plan.

        // Create Cue Ball (ID 0)
        // Initial position will be set during PRE_BREAK_PLACEMENT state
        balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

        // --- Create Object Balls (Temporary List) ---
        std::vector<Ball> objectBalls;
        // Solids (1-7, Yellow)
        for (int i = 1; i <= 7; ++i) {
            //objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
            objectBalls.push_back({ i, BallType::SOLID, 0,0,0,0,
                        GetBallColor(i), false });
        }
        // Stripes (9-15, Red)
        for (int i = 9; i <= 15; ++i) {
            //objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
            objectBalls.push_back({ i, BallType::STRIPE, 0,0,0,0,
                        GetBallColor(i), false });
        }
        // 8-Ball (ID 8) - Add it to the list to be placed
        //objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });
        objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0,0,0,0,
              GetBallColor(8), false });


        // --- Racking Logic (Improved) ---
        float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
        float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

        // Define rack positions (0-14 indices corresponding to triangle spots)
        D2D1_POINT_2F rackPositions[15];
        int rackIndex = 0;
        for (int row = 0; row < 5; ++row) {
            for (int col = 0; col <= row; ++col) {
                if (rackIndex >= 15) break;
                float x = RACK_POS_X + row * spacingX;
                float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
                rackPositions[rackIndex++] = D2D1::Point2F(x, y);
            }
        }

        // Separate 8-ball
        Ball eightBall;
        std::vector<Ball> otherBalls; // Solids and Stripes
        bool eightBallFound = false;
        for (const auto& ball : objectBalls) {
            if (ball.id == 8) {
                eightBall = ball;
                eightBallFound = true;
            }
            else {
                otherBalls.push_back(ball);
            }
        }
        // Ensure 8 ball was actually created (should always be true)
        if (!eightBallFound) {
            // Handle error - perhaps recreate it? For now, proceed.
            eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
        }


        // Shuffle the other 14 balls
        // Use std::shuffle if available (C++11 and later) for better randomness
        // std::random_device rd;
        // std::mt19937 g(rd());
        // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
        std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

        // --- Place balls into the main 'balls' vector in rack order ---
        // Important: Add the cue ball (already created) first.
        // (Cue ball added at the start of the function now)

        // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
        int eightBallRackIndex = 4;
        eightBall.x = rackPositions[eightBallRackIndex].x;
        eightBall.y = rackPositions[eightBallRackIndex].y;
        eightBall.vx = 0;
        eightBall.vy = 0;
        eightBall.isPocketed = false;
        balls.push_back(eightBall); // Add 8 ball to the main vector

        // 2. Place the shuffled Solids and Stripes in the remaining spots
        size_t otherBallIdx = 0;
        //int otherBallIdx = 0;
        for (int i = 0; i < 15; ++i) {
            if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

            if (otherBallIdx < otherBalls.size()) {
                Ball& ballToPlace = otherBalls[otherBallIdx++];
                ballToPlace.x = rackPositions[i].x;
                ballToPlace.y = rackPositions[i].y;
                ballToPlace.vx = 0;
                ballToPlace.vy = 0;
                ballToPlace.isPocketed = false;
                balls.push_back(ballToPlace); // Add to the main game vector
            }
        }
        // --- End Racking Logic ---


        // --- Determine Who Breaks and Initial State ---
        if (isPlayer2AI) {
            /*// AI Mode: Randomly decide who breaks
            if ((rand() % 2) == 0) {
                // AI (Player 2) breaks
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
                aiTurnPending = true; // Trigger AI logic
            }
            else {
                // Player 1 (Human) breaks
                currentPlayer = 1;
                currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
                aiTurnPending = false;*/
            switch (openingBreakMode) {
            case CPU_BREAK:
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            case P1_BREAK:
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
                break;
            case FLIP_COIN_BREAK:
                if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                    currentPlayer = 2; // AI breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = true;
                }
                else {
                    currentPlayer = 1; // Player 1 breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = false;
                }
                break;
            default: // Fallback to CPU break
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            }
        }
        else {
            // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false; // No AI involved
        }

        // Reset other relevant game state variables
        foulCommitted = false;
        gameOverMessage = L"""";
        firstBallPocketedAfterBreak = false;
        // pocketedThisTurn cleared at start
        // Reset shot parameters and input flags
        shotPower = 0.0f;
        cueSpinX = 0.0f;
        cueSpinY = 0.0f;
        isAiming = false;
        isDraggingCueBall = false;
        isSettingEnglish = false;
        cueAngle = 0.0f; // Reset aim angle
    }


    // --------------------------------------------------------------------------------
    // Full GameUpdate(): integrates AI call?pocket ? aim ? shoot (no omissions)
    // --------------------------------------------------------------------------------
    void GameUpdate() {
        // --- 1) Handle an in?flight shot ---
        if (currentGameState == SHOT_IN_PROGRESS) {
            UpdatePhysics();
            // ? clear old 8?ball pocket info before any new pocket checks
            //lastEightBallPocketIndex = -1;
            CheckCollisions();
            CheckPockets(); // FIX: This line was missing. It's essential to check for pocketed balls every frame.

            if (AreBallsMoving()) {
                isAiming = false;
                aiIsDisplayingAim = false;
            }

            if (!AreBallsMoving()) {
                ProcessShotResults();
            }
            return;
        }

        // --- 2) CPU’s turn (table is static) ---
        if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
            // ??? If we've just auto?entered AI_THINKING for the 8?ball call, actually make the decision ???
            if (currentGameState == AI_THINKING && aiTurnPending) {
                aiTurnPending = false;        // consume the pending flag
                AIMakeDecision();             // CPU calls its pocket or plans its shot
                return;                       // done this tick
            }

            // ??? Automate the AI pocket?selection click ???
            if (currentGameState == CHOOSING_POCKET_P2) {
                // AI immediately confirms its call and moves to thinking/shooting
                currentGameState = AI_THINKING;
                aiTurnPending = true;
                return; // process on next tick
            }
            // 2A) If AI is displaying its aim line, count down then shoot
            if (aiIsDisplayingAim) {
                aiAimDisplayFramesLeft--;
                if (aiAimDisplayFramesLeft <= 0) {
                    aiIsDisplayingAim = false;
                    if (aiPlannedShotDetails.isValid) {
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;
                        std::thread([](const TCHAR* soundName) {
                            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
                            }, TEXT(""cue.wav"")).detach();

                            ApplyShot(
                                aiPlannedShotDetails.power,
                                aiPlannedShotDetails.angle,
                                aiPlannedShotDetails.spinX,
                                aiPlannedShotDetails.spinY
                            );
                            aiPlannedShotDetails.isValid = false;
                    }
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false;
                    pocketedThisTurn.clear();
                }
                return;
            }

            // 2B) Immediately after calling pocket, transition into AI_THINKING
            if (currentGameState == CHOOSING_POCKET_P2 && aiTurnPending) {
                // Start thinking/shooting right away—no human click required
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
                return;
            }

            // 2C) If AI has pending actions (break, ball?in?hand, or normal turn)
            if (aiTurnPending) {
                if (currentGameState == BALL_IN_HAND_P2) {
                    AIPlaceCueBall();
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                    AIBreakShot();
                }
                else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) {
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                return;
            }
        }
    }


    // --- Physics and Collision ---
    void UpdatePhysics() {
        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b = balls[i];
            if (!b.isPocketed) {
                b.x += b.vx;
                b.y += b.vy;

                // Apply friction
                b.vx *= FRICTION;
                b.vy *= FRICTION;

                // Stop balls if velocity is very low
                if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                    b.vx = 0;
                    b.vy = 0;
                }

                /* -----------------------------------------------------------------
       Additional clamp to guarantee the ball never escapes the table.
       The existing wall–collision code can momentarily disable the
       reflection test while the ball is close to a pocket mouth;
       that rare case allowed it to ‘slide’ through the cushion and
       leave the board.  We therefore enforce a final boundary check
       after the normal physics step.
       ----------------------------------------------------------------- */
                const float leftBound = TABLE_LEFT + BALL_RADIUS;
                const float rightBound = TABLE_RIGHT - BALL_RADIUS;
                const float topBound = TABLE_TOP + BALL_RADIUS;
                const float bottomBound = TABLE_BOTTOM - BALL_RADIUS;

                if (b.x < leftBound) { b.x = leftBound;   b.vx = fabsf(b.vx); }
                if (b.x > rightBound) { b.x = rightBound;  b.vx = -fabsf(b.vx); }
                if (b.y < topBound) { b.y = topBound;    b.vy = fabsf(b.vy); }
                if (b.y > bottomBound) { b.y = bottomBound; b.vy = -fabsf(b.vy); }
            }
        }
    }

    void CheckCollisions() {
        float left = TABLE_LEFT;
        float right = TABLE_RIGHT;
        float top = TABLE_TOP;
        float bottom = TABLE_BOTTOM;
        const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

        // --- Reset Per-Frame Sound Flags ---
        bool playedWallSoundThisFrame = false;
        bool playedCollideSoundThisFrame = false;
        // ---

        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b1 = balls[i];
            if (b1.isPocketed) continue;

            bool nearPocket[6];
            for (int p = 0; p < 6; ++p) {
                nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
            }
            bool nearTopLeftPocket = nearPocket[0];
            bool nearTopMidPocket = nearPocket[1];
            bool nearTopRightPocket = nearPocket[2];
            bool nearBottomLeftPocket = nearPocket[3];
            bool nearBottomMidPocket = nearPocket[4];
            bool nearBottomRightPocket = nearPocket[5];

            bool collidedWallThisBall = false;

            // --- Ball-Wall Collisions ---
            // (Check logic unchanged, added sound calls and railHitAfterContact update)
            // Left Wall
            if (b1.x - BALL_RADIUS < left) {
                if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                    b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Right Wall
            if (b1.x + BALL_RADIUS > right) {
                if (!nearTopRightPocket && !nearBottomRightPocket) {
                    b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Top Wall
            if (b1.y - BALL_RADIUS < top) {
                if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                    b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Bottom Wall
            if (b1.y + BALL_RADIUS > bottom) {
                if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                    b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }

            // Spin effect (Unchanged)
            if (collidedWallThisBall) {
                if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
                if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
                cueSpinX *= 0.7f; cueSpinY *= 0.7f;
            }


            // --- Ball-Ball Collisions ---
            for (size_t j = i + 1; j < balls.size(); ++j) {
                Ball& b2 = balls[j];
                if (b2.isPocketed) continue;

                float dx = b2.x - b1.x; float dy = b2.y - b1.y;
                float distSq = dx * dx + dy * dy;
                float minDist = BALL_RADIUS * 2.0f;

                if (distSq > 1e-6 && distSq < minDist * minDist) {
                    float dist = sqrtf(distSq);
                    float overlap = minDist - dist;
                    float nx = dx / dist; float ny = dy / dist;

                    // Separation (Unchanged)
                    b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                    b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                    float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                    float velAlongNormal = rvx * nx + rvy * ny;

                    if (velAlongNormal > 0) { // Colliding
                        // --- Play Ball Collision Sound ---
                        if (!playedCollideSoundThisFrame) {
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                            playedCollideSoundThisFrame = true; // Set flag
                        }
                        // --- End Sound ---

                        // --- NEW: Track First Hit and Cue/Object Collision ---
                        if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                            if (b1.id == 0) { // Cue ball hit b2 first
                                firstHitBallIdThisShot = b2.id;
                                cueHitObjectBallThisShot = true;
                            }
                            else if (b2.id == 0) { // Cue ball hit b1 first
                                firstHitBallIdThisShot = b1.id;
                                cueHitObjectBallThisShot = true;
                            }
                            // If neither is cue ball, doesn't count as first hit for foul purposes
                        }
                        else if (b1.id == 0 || b2.id == 0) {
                            // Track subsequent cue ball collisions with object balls
                            cueHitObjectBallThisShot = true;
                        }
                        // --- End First Hit Tracking ---


                        // Impulse (Unchanged)
                        float impulse = velAlongNormal;
                        b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                        b2.vx += impulse * nx; b2.vy += impulse * ny;

                        // Spin Transfer (Unchanged)
                        if (b1.id == 0 || b2.id == 0) {
                            float spinEffectFactor = 0.08f;
                            b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                        }
                    }
                }
            } // End ball-ball loop
        } // End ball loop
    } // End CheckCollisions


    bool CheckPockets() {
        bool anyPocketed = false;
        // FIX: Declare a local flag to ensure the sound only plays ONCE per function call.
        bool ballPocketedThisCheck = false;
        // For each ball not already pocketed:
        for (auto& b : balls) {
            if (b.isPocketed)
                continue;

            // Check against each pocket
            for (int p = 0; p < 6; ++p) {
                float dx = b.x - pocketPositions[p].x;
                float dy = b.y - pocketPositions[p].y;
                if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                    // It's in the pocket—remove it from play
                    // If it's the 8?ball, remember which pocket it went into
                    if (b.id == 8) {
                        lastEightBallPocketIndex = p;   // <-- Must set here!
                    }
                    b.isPocketed = true;
                    b.vx = b.vy = 0.0f;           // kill any movement
                    pocketedThisTurn.push_back(b.id);
                    anyPocketed = true;

                    // --- FIX: Insert your sound logic here ---
                    // The 'if' guard prevents multiple sounds on a multi-ball break.
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound Fix ---

                    break;  // no need to check other pockets for this ball
                }
            }
        }
        return anyPocketed;
    }

    bool AreBallsMoving() {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
                return true;
            }
        }
        return false;
    }

    void RespawnCueBall(bool behindHeadstring) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {
            // Determine the initial target position
            float targetX, targetY;
            if (behindHeadstring) {
                targetX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }
            else {
                targetX = TABLE_LEFT + TABLE_WIDTH / 2.0f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }

            // FOOLPROOF FIX: Check if the target spot is valid. If not, nudge it until it is.
            int attempts = 0;
            while (!IsValidCueBallPosition(targetX, targetY, behindHeadstring) && attempts < 100) {
                // If the spot is occupied, try nudging the ball slightly.
                targetX += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                targetY += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                // Clamp to stay within reasonable bounds
                targetX = std::max(TABLE_LEFT + BALL_RADIUS, std::min(targetX, TABLE_RIGHT - BALL_RADIUS));
                targetY = std::max(TABLE_TOP + BALL_RADIUS, std::min(targetY, TABLE_BOTTOM - BALL_RADIUS));
                attempts++;
            }

            // Set the final, valid position.
            cueBall->x = targetX;
            cueBall->y = targetY;
            cueBall->vx = 0;
            cueBall->vy = 0;
            cueBall->isPocketed = false;

            // Set the correct game state for ball-in-hand.
            if (currentPlayer == 1) {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else {
                currentGameState = BALL_IN_HAND_P2;
                if (isPlayer2AI) {
                    aiTurnPending = true;
                }
            }
        }
    }


    // --- Game Logic ---

    void ApplyShot(float power, float angle, float spinX, float spinY) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {

            // --- Play Cue Strike Sound (Threaded) ---
            if (power > 0.1f) { // Only play if it's an audible shot
                std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
            }
            // --- End Sound ---

            cueBall->vx = cosf(angle) * power;
            cueBall->vy = sinf(angle) * power;

            // Apply English (Spin) - Simplified effect (Unchanged)
            cueBall->vx += sinf(angle) * spinY * 0.5f;
            cueBall->vy -= cosf(angle) * spinY * 0.5f;
            cueBall->vx -= cosf(angle) * spinX * 0.5f;
            cueBall->vy -= sinf(angle) * spinX * 0.5f;

            // Store spin (Unchanged)
            cueSpinX = spinX;
            cueSpinY = spinY;

            // --- Reset Foul Tracking flags for the new shot ---
            // (Also reset in LBUTTONUP, but good to ensure here too)
            firstHitBallIdThisShot = -1;      // No ball hit yet
            cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
            railHitAfterContact = false;     // No rail hit after contact yet
            // --- End Reset ---

                    // If this was the opening break shot, clear the flag
            if (isOpeningBreakShot) {
                isOpeningBreakShot = false; // Mark opening break as taken
            }
        }
    }


    // ---------------------------------------------------------------------
    //  ProcessShotResults()
    // ---------------------------------------------------------------------
    void ProcessShotResults() {
        bool cueBallPocketed = false;
        bool eightBallPocketed = false;
        bool playerContinuesTurn = false;

        // --- Step 1: Update Ball Counts FIRST (THE CRITICAL FIX) ---
        // We must update the score before any other game logic runs.
        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        int ownBallsPocketedThisTurn = 0;

        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (!b) continue;

            if (b->id == 0) {
                cueBallPocketed = true;
            }
            else if (b->id == 8) {
                eightBallPocketed = true;
            }
            else {
                // This is a numbered ball. Update the pocketed count for the correct player.
                if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) {
                    player1Info.ballsPocketedCount++;
                }
                else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) {
                    player2Info.ballsPocketedCount++;
                }

                if (b->type == shootingPlayer.assignedType) {
                    ownBallsPocketedThisTurn++;
                }
            }
        }

        if (ownBallsPocketedThisTurn > 0) {
            playerContinuesTurn = true;
        }

        // --- Step 2: Handle Game-Ending 8-Ball Shot ---
        // Now that the score is updated, this check will have the correct information.
        if (eightBallPocketed) {
            CheckGameOverConditions(true, cueBallPocketed);
            if (currentGameState == GAME_OVER) {
                pocketedThisTurn.clear();
                return;
            }
        }

        // --- Step 3: Check for Fouls ---
        bool turnFoul = false;
        if (cueBallPocketed) {
            turnFoul = true;
        }
        else {
            Ball* firstHit = GetBallById(firstHitBallIdThisShot);
            if (!firstHit) { // Rule: Hitting nothing is a foul.
                turnFoul = true;
            }
            else { // Rule: Hitting the wrong ball type is a foul.
                if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                    // We check if the player WAS on the 8-ball BEFORE this shot.
                    bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);
                    if (wasOnEightBall) {
                        if (firstHit->id != 8) turnFoul = true;
                    }
                    else {
                        if (firstHit->type != shootingPlayer.assignedType) turnFoul = true;
                    }
                }
            }
        } //reenable below disabled for debugging
        //if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
            //turnFoul = true;
        //}
        foulCommitted = turnFoul;

        // --- Step 4: Final State Transition ---
        if (foulCommitted) {
            SwitchTurns();
            RespawnCueBall(false);
        }
        else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
            // Assign types on the break.
            for (int id : pocketedThisTurn) {
                Ball* b = GetBallById(id);
                if (b && b->type != BallType::EIGHT_BALL) {
                    AssignPlayerBallTypes(b->type);
                    break;
                }
            }
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else if (playerContinuesTurn) {
            // The player's turn continues. Now the check will work correctly.
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else {
            SwitchTurns();
        }

        pocketedThisTurn.clear();
    }

    /*
    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (playerContinuesTurn) {
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        SwitchTurns();
    }

    pocketedThisTurn.clear();
    } */

    //  Assign groups AND optionally give the shooter his first count.
    bool AssignPlayerBallTypes(BallType firstPocketedType, bool creditShooter /*= true*/)
    {
        if (firstPocketedType != SOLID && firstPocketedType != STRIPE)
            return false;                                 // safety

        /* ---------------------------------------------------------
           1.  Decide the groups
        --------------------------------------------------------- */
        if (currentPlayer == 1)
        {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }
        else
        {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }

        /* ---------------------------------------------------------
           2.  Count the very ball that made the assignment
        --------------------------------------------------------- */
        if (creditShooter)
        {
            if (currentPlayer == 1)
                ++player1Info.ballsPocketedCount;
            else
                ++player2Info.ballsPocketedCount;
        }
        return true;
    }

    /*bool AssignPlayerBallTypes(BallType firstPocketedType) {
        if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
            if (currentPlayer == 1) {
                player1Info.assignedType = firstPocketedType;
                player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            else {
                player2Info.assignedType = firstPocketedType;
                player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            return true; // Assignment was successful
        }
        return false; // No assignment made (e.g., 8-ball was pocketed on break)
    }*/
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


    // --- Called in ProcessShotResults() after pocket detection ---
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        // Only care if the 8?ball really went in:
        if (!eightBallPocketed) return;

        // Who’s shooting now?
        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        // Which pocket did we CALL?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did it ACTUALLY fall into?
        int actual = lastEightBallPocketIndex;

        // Check legality: must have called a pocket ?0, must match actual,
        // must have pocketed all 7 of your balls first, and must not have scratched.
        bool legal = (called >= 0)
            && (called == actual)
            && (shooter.ballsPocketedCount >= 7)
            && (!cueBallPocketed);

        // Build a message that shows both values for debugging/tracing:
        if (legal) {
            gameOverMessage = shooter.name
                + L"" Wins! ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name
                + L"" Wins! (Illegal 8-Ball) ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }



    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return;

        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;

        // Handle 8-ball on break: re-spot and continue.
        if (player1Info.assignedType == BallType::NONE) {
            Ball* b = GetBallById(8);
            if (b) { b->isPocketed = false; b->x = RACK_POS_X; b->y = RACK_POS_Y; b->vx = b->vy = 0; }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // --- FOOLPROOF WIN/LOSS LOGIC ---
        bool wasOnEightBall = IsPlayerOnEightBall(currentPlayer);
        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = -1;

        // Find which pocket the 8-ball actually went into.
        for (int id : pocketedThisTurn) {
            if (id == 8) {
                Ball* b = GetBallById(8); // This ball is already marked as pocketed, but we need its last coords.
                if (b) {
                    for (int p_idx = 0; p_idx < 6; ++p_idx) {
                        // Check last known position against pocket centers
                        if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                            actualPocket = p_idx;
                            break;
                        }
                    }
                }
                break;
            }
        }

        // Evaluate win/loss based on a clear hierarchy of rules.
        if (!wasOnEightBall) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball Pocketed Early)"";
        }
        else if (cueBallPocketed) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Scratched on 8-Ball)"";
        }
        else if (calledPocket == -1) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Pocket Not Called)"";
        }
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball in Wrong Pocket)"";
        }
        else {
            // WIN! All loss conditions failed, this must be a legal win.
            gameOverMessage = shootingPlayer.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    }*/

    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        // Which pocket did we call?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did the ball really fall into?
        int actual = lastEightBallPocketIndex;

        // Legal victory only if:
        //  1) Shooter had already pocketed 7 of their object balls,
        //  2) They called a pocket,
        //  3) The 8?ball actually fell into that same pocket,
        //  4) They did not scratch on the 8?ball.
        bool legal =
            (shooter.ballsPocketedCount >= 7) &&
            (called >= 0) &&
            (called == actual) &&
            (!cueBallPocketed);

        if (legal) {
            gameOverMessage = shooter.name + L"" Wins! ""
                L""(called: "" + std::to_wstring(called) +
                L"", actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name + L"" Wins! (illegal 8-ball) ""
            // For debugging you can append:
            + L"" (called: "" + std::to_wstring(called)
            + L"", actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    // ????????????????????????????????????????????????????????????????
    //  CheckGameOverConditions()
    //     – Called when the 8-ball has fallen.
    //     – Decides who wins and builds the gameOverMessage.
    // ????????????????????????????????????????????????????????????????
    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;                     // safety

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = lastEightBallPocketIndex;

        bool clearedSeven = (shooter.ballsPocketedCount >= 7);
        bool noScratch = !cueBallPocketed;
        bool callMade = (calledPocket >= 0);

        // helper ? turn “-1” into ""None"" for readability
        auto pocketToStr = [](int idx) -> std::wstring
        {
            return (idx >= 0) ? std::to_wstring(idx) : L""None"";
        };

        if (clearedSeven && noScratch && callMade && actualPocket == calledPocket)
        {
            // legitimate win
            gameOverMessage =
                shooter.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }
        else
        {
            // wrong pocket, scratch, or early 8-ball
            gameOverMessage =
                opponent.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    /* void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return; // Only when 8-ball actually pocketed

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        bool      onEightRoll = IsPlayerOnEightBall(currentPlayer);
        int       calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int       actualPocket = -1;
        Ball* bEight = GetBallById(8);

        // locate which hole the 8-ball went into
        if (bEight) {
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq(bEight->x, bEight->y,
                    pocketPositions[i].x, pocketPositions[i].y)
                    < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                    actualPocket = i; break;
                }
            }
        }

        // 1) On break / pre-assignment: re-spot & continue
        if (player1Info.assignedType == BallType::NONE) {
            if (bEight) {
                bEight->isPocketed = false;
                bEight->x = RACK_POS_X; bEight->y = RACK_POS_Y;
                bEight->vx = bEight->vy = 0;
            }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // 2) Loss if pocketed 8 early
        if (!onEightRoll) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" pocketed 8-ball early)"";
        }
        // 3) Loss if scratched
        else if (cueBallPocketed) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" scratched on 8-ball)"";
        }
        // 4) Loss if no pocket call
        else if (calledPocket < 0) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" did not call a pocket)"";
        }
        // 5) Loss if in wrong pocket
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" 8-ball in wrong pocket)"";
        }
        // 6) Otherwise, valid win
        else {
            gameOverMessage = shooter.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    } */


    // Switch the shooter, handle fouls and decide what state we go to next.
    // ────────────────────────────────────────────────────────────────
    //  SwitchTurns – final version (arrow–leak bug fixed)
    // ────────────────────────────────────────────────────────────────
    void SwitchTurns()
    {
        /* --------------------------------------------------------- */
        /* 1.  Hand the table over to the other player               */
        /* --------------------------------------------------------- */
        currentPlayer = (currentPlayer == 1) ? 2 : 1;

        /* --------------------------------------------------------- */
        /* 2.  Generic per–turn resets                               */
        /* --------------------------------------------------------- */
        isAiming = false;
        shotPower = 0.0f;
        currentlyHoveredPocket = -1;

        /* --------------------------------------------------------- */
        /* 3.  Wipe every previous pocket call                       */
        /*    (the new shooter will choose again if needed)          */
        /* --------------------------------------------------------- */
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage.clear();

        /* --------------------------------------------------------- */
        /* 4.  Handle fouls — cue-ball in hand overrides everything  */
        /* --------------------------------------------------------- */
        if (foulCommitted)
        {
            if (currentPlayer == 1)            // human
            {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else                               // P2
            {
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = isPlayer2AI;   // AI will place cue-ball
            }

            foulCommitted = false;
            return;                            // we're done for this frame
        }

        /* --------------------------------------------------------- */
        /* 5.  Normal flow                                           */
        /*    Will put us in  ∘ PLAYER?_TURN                         */
        /*                    ∘ CHOOSING_POCKET_P?                   */
        /*                    ∘ AI_THINKING  (for CPU)               */
        /* --------------------------------------------------------- */
        CheckAndTransitionToPocketChoice(currentPlayer);
    }


    void AIBreakShot() {
        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
        // AI will place the cue ball and then plan the shot.
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            // Place cue ball in the kitchen randomly
            /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
            float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
            float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
            float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

            // --- AI Places Cue Ball for Break ---
    // Decide if placing center or side. For simplicity, let's try placing slightly off-center
    // towards one side for a more angled break, or center for direct apex hit.
    // A common strategy is to hit the second ball of the rack.

            float placementY = RACK_POS_Y; // Align vertically with the rack center
            float placementX;

            // Randomly choose a side or center-ish placement for variation.
            int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

            if (placementChoice == 0) { // Left-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
            }
            else if (placementChoice == 2) { // Right-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
            }
            else { // Center-ish
                placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
            }
            placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

            bool validPos = false;
            int attempts = 0;
            while (!validPos && attempts < 100) {
                /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
                cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                    validPos = true; // [cite: 1591]*/
                    // Try the chosen X, but vary Y slightly to find a clear spot
                cueBall->x = placementX;
                cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
                cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                    validPos = true;
                }
                attempts++; // [cite: 1592]
            }
            if (!validPos) {
                // Fallback position
                /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
                cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
                if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                    cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                    cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
                }
            }
            cueBall->vx = 0; // [cite: 1595]
            cueBall->vy = 0; // [cite: 1596]

            // Plan a break shot: aim at the center of the rack (apex ball)
            float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
            float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

            float dx = targetX - cueBall->x; // [cite: 1599]
            float dy = targetY - cueBall->y; // [cite: 1600]
            float shotAngle = atan2f(dy, dx); // [cite: 1600]
            float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

                cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
                cueBall->y = RACK_POS_Y;
            }
            cueBall->vx = 0; cueBall->vy = 0;

            // --- AI Plans the Break Shot ---
            float targetX, targetY;
            // If cue ball is near center of kitchen width, aim for apex.
            // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
            float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
            if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
                // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
                targetX = RACK_POS_X; // Apex ball X
                targetY = RACK_POS_Y; // Apex ball Y
            }
            else {
                // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
                // This is a simplification. A more robust way is to find the actual second ball.
                // For now, aim slightly off the apex towards the side the cue ball is on.
                targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
                targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
            }

            float dx = targetX - cueBall->x;
            float dy = targetY - cueBall->y;
            float shotAngle = atan2f(dy, dx);
            float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

            // Store planned shot details for the AI
            /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
            aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
            aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
            aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
            aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

            aiPlannedShotDetails.angle = shotAngle;
            aiPlannedShotDetails.power = shotPowerValue;
            aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
            aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;

            // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
            /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
            ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
            ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
            ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

            ::cueAngle = aiPlannedShotDetails.angle;
            ::shotPower = aiPlannedShotDetails.power;
            ::cueSpinX = aiPlannedShotDetails.spinX;
            ::cueSpinY = aiPlannedShotDetails.spinY;

            // Set up for AI display via GameUpdate
            /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

            currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                            // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                            // and then execute the shot using aiPlannedShotDetails.
                                            // isOpeningBreakShot will be set to false within ApplyShot.

            // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
            currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display
            aiTurnPending = false;

            return; // The break shot is now planned and will be executed by GameUpdate
        }

        // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
        //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
        //    This part can be extended if AIBreakShot needs to handle other scenarios.
        //    For now, the primary logic is above.
    }

    // --- Helper Functions ---

    Ball* GetBallById(int id) {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id == id) {
                return &balls[i];
            }
        }
        return nullptr;
    }

    Ball* GetCueBall() {
        return GetBallById(0);
    }

    float GetDistance(float x1, float y1, float x2, float y2) {
        return sqrtf(GetDistanceSq(x1, y1, x2, y2));
    }

    float GetDistanceSq(float x1, float y1, float x2, float y2) {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
        // Basic bounds check (inside cushions)
        float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
        float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
        float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
        float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

        if (x < left || x > right || y < top || y > bottom) {
            return false;
        }

        // Check headstring restriction if needed
        if (checkHeadstring && x >= HEADSTRING_X) {
            return false;
        }

        // Check overlap with other balls
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
                if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                    return false; // Overlapping another ball
                }
            }
        }

        return true;
    }

    // --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

    // Checks if a player has pocketed all their balls and is now on the 8-ball.
    bool IsPlayerOnEightBall(int player) {
        PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
        if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
            Ball* eightBall = GetBallById(8);
            return (eightBall && !eightBall->isPocketed);
        }
        return false;
    }

    void CheckAndTransitionToPocketChoice(int playerID) {
        bool needsToCall = IsPlayerOnEightBall(playerID);

        if (needsToCall) {
            if (playerID == 1) { // Human Player 1
                currentGameState = CHOOSING_POCKET_P1;
                pocketCallMessage = player1Info.name + L"": Choose a pocket for the 8-Ball..."";
                if (calledPocketP1 == -1) calledPocketP1 = 2; // Default to bottom-right
            }
            else { // Player 2
                if (isPlayer2AI) {
                    // FOOLPROOF FIX: AI doesn't choose here. It transitions to a thinking state.
                    // AIMakeDecision will handle the choice and the pocket call.
                    currentGameState = AI_THINKING;
                    aiTurnPending = true; // Signal the main loop to run AIMakeDecision
                }
                else { // Human Player 2
                    currentGameState = CHOOSING_POCKET_P2;
                    pocketCallMessage = player2Info.name + L"": Choose a pocket for the 8-Ball..."";
                    if (calledPocketP2 == -1) calledPocketP2 = 2; // Default to bottom-right
                }
            }
        }
        else {
            // Player does not need to call a pocket, proceed to normal turn.
            pocketCallMessage = L"""";
            currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (playerID == 2 && isPlayer2AI) {
                aiTurnPending = true;
            }
        }
    }


    template <typename T>
    void SafeRelease(T** ppT) {
        if (*ppT) {
            (*ppT)->Release();
            *ppT = nullptr;
        }
    }

    // --- CPU Ball?in?Hand Placement --------------------------------
    // Moves the cue ball to a legal ""ball in hand"" position for the AI.
    void AIPlaceCueBall() {
        Ball* cue = GetCueBall();
        if (!cue) return;

        // Simple strategy: place back behind the headstring at the standard break spot
        cue->x = TABLE_LEFT + TABLE_WIDTH * 0.15f;
        cue->y = RACK_POS_Y;
        cue->vx = cue->vy = 0.0f;
    }

    // --- Helper Function for Line Segment Intersection ---
    // Finds intersection point of line segment P1->P2 and line segment P3->P4
    // Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
    {
        float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

        // Check if lines are parallel or collinear
        if (fabs(denominator) < 1e-6) {
            return false;
        }

        float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

        // Check if intersection point lies on both segments
        if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
            intersection.x = p1.x + ua * (p2.x - p1.x);
            intersection.y = p1.y + ua * (p2.y - p1.y);
            return true;
        }

        return false;
    }

    // --- INSERT NEW HELPER FUNCTION HERE ---
    // Calculates the squared distance from point P to the line segment AB.
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
        float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
        if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
        // Consider P projecting onto the line AB infinite line
        // t = [(P-A) . (B-A)] / |B-A|^2
        float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
        t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
        // Projection falls on the segment
        D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
        return GetDistanceSq(p.x, p.y, projection.x, projection.y);
    }
    // --- End New Helper ---

    // --- NEW AI Implementation Functions ---

    void AIMakeDecision() {
        // Start with a clean slate for the AI's plan.
        aiPlannedShotDetails.isValid = false;
        Ball* cueBall = GetCueBall();
        if (!cueBall || !isPlayer2AI || currentPlayer != 2) return;

        // Ask the ""expert"" (AIFindBestShot) for the best possible shot.
        AIShotInfo bestShot = AIFindBestShot();

        if (bestShot.possible) {
            // A good shot was found.
            // If it's an 8-ball shot, ""call"" the pocket.
            if (bestShot.involves8Ball) {
                calledPocketP2 = bestShot.pocketIndex;
            }
            else {
                calledPocketP2 = -1; // Ensure no pocket is called on a normal shot.
            }

            // Commit the details of the best shot to the AI's plan.
            aiPlannedShotDetails.angle = bestShot.angle;
            aiPlannedShotDetails.power = bestShot.power;
            aiPlannedShotDetails.spinX = bestShot.spinX;
            aiPlannedShotDetails.spinY = bestShot.spinY;
            aiPlannedShotDetails.isValid = true;

        }
        else {
            // No good offensive shot found, must play a safe defensive shot.
            // (This is a fallback and your current AIFindBestShot should prevent this)
            aiPlannedShotDetails.isValid = false;
        }

        // --- FOOLPROOF FIX: Trigger the Aim Display ---
        // If any valid plan was made, update the visuals and start the display pause.
        if (aiPlannedShotDetails.isValid) {

            // STEP 1: Copy the AI's plan into the global variables used for drawing.
            // This is the critical missing link.
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;

            // STEP 2: Trigger the visual display pause.
            // These are the two lines you correctly identified.
            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;

        }
        else {
            // Absolute fallback: If no plan could be made, switch turns to prevent a freeze.
            SwitchTurns();
        }
    }


    AIShotInfo AIFindBestShot()
    {
        AIShotInfo best;                       // .possible == false
        Ball* cue = GetCueBall();
        if (!cue) return best;

        const bool on8 = IsPlayerOnEightBall(2);
        const BallType wantType = player2Info.assignedType;

        for (Ball& b : balls)
        {
            if (b.isPocketed || b.id == 0) continue;

            // decide if this ball is a legal/interesting target
            bool ok =
                on8 ? (b.id == 8) :
                ((wantType == BallType::NONE) || (b.type == wantType));

            if (!ok) continue;

            for (int p = 0; p < 6; ++p)
            {
                AIShotInfo cand = EvaluateShot(&b, p);
                if (cand.possible &&
                    (!best.possible || cand.score > best.score))
                    best = cand;
            }
        }

        // fall-back: tap cue ball forward (safety) if no potting line exists
        if (!best.possible && cue)
        {
            best.possible = true;
            best.angle = static_cast<float>(rand()) / RAND_MAX * 2.0f * PI;
            best.power = MAX_SHOT_POWER * 0.30f;
            best.spinX = best.spinY = 0.0f;
            best.targetBall = nullptr;
            best.score = -99999.0f;
            best.pocketIndex = -1;
        }
        return best;
    }


    // Evaluate a potential shot at a specific target ball towards a specific pocket
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
        AIShotInfo shotInfo; // Defaults to not possible
        shotInfo.targetBall = targetBall;
        shotInfo.pocketIndex = pocketIndex;
        shotInfo.involves8Ball = (targetBall && targetBall->id == 8);

        Ball* cueBall = GetCueBall();
        if (!cueBall || !targetBall) return shotInfo;

        // 1. Calculate Ghost Ball position (where cue must hit target)
        shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

        // 2. Check Path: Cue Ball -> Ghost Ball Position
        if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
            return shotInfo; // Path blocked, shot is impossible.
        }

        // 3. Calculate Angle and Power
        float dx = shotInfo.ghostBallPos.x - cueBall->x;
        float dy = shotInfo.ghostBallPos.y - cueBall->y;
        shotInfo.angle = atan2f(dy, dx);

        float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
        float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);
        shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

        // 4. Score the shot (simple scoring: closer and straighter is better)
        shotInfo.score = 1000.0f - (cueToGhostDist + targetToPocketDist);

        // If we reached here, the shot is geometrically possible.
        shotInfo.possible = true;
        return shotInfo;
    }


    //  Estimate the power that will carry the cue-ball to the ghost position
    //  *and* push the object-ball the remaining distance to the pocket.
    //
    //  • cueToGhostDist    – pixels from cue to ghost-ball centre
    //  • targetToPocketDist– pixels from object-ball to chosen pocket
    //
    //  The function is fully deterministic (good for AI search) yet produces
    //  human-looking power levels.
    //
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist)
    {
        // Total distance the *energy* must cover (cue path + object-ball path)
        float totalDist = cueToGhostDist + targetToPocketDist;

        // Typical diagonal of the playable area (approx.) – used for scaling
        constexpr float TABLE_DIAG = 900.0f;

        // 1.  Convert distance to a 0-1 number (0: tap-in, 1: table length)
        float norm = std::clamp(totalDist / TABLE_DIAG, 0.0f, 1.0f);

        // 2.  Ease-in curve (smoothstep) for nicer progression
        norm = norm * norm * (3.0f - 2.0f * norm);

        // 3.  Blend between a gentle minimum and the absolute maximum
        const float MIN_POWER = MAX_SHOT_POWER * 0.18f;     // just enough to move
        float power = MIN_POWER + norm * (MAX_SHOT_POWER - MIN_POWER);

        // 4.  Safety clamp (also screens out degenerate calls)
        power = std::clamp(power, 0.15f, MAX_SHOT_POWER);

        return power;
    }

    // ------------------------------------------------------------------
    //  Return the ghost-ball centre needed for the target ball to roll
    //  straight into the chosen pocket.
    // ------------------------------------------------------------------
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex)
    {
        if (!targetBall) return D2D1::Point2F(0, 0);

        D2D1_POINT_2F P = pocketPositions[pocketIndex];

        float vx = P.x - targetBall->x;
        float vy = P.y - targetBall->y;
        float L = sqrtf(vx * vx + vy * vy);
        if (L < 1.0f) L = 1.0f;                // safety

        vx /= L;   vy /= L;

        return D2D1::Point2F(
            targetBall->x - vx * (BALL_RADIUS * 2.0f),
            targetBall->y - vy * (BALL_RADIUS * 2.0f));
    }

    // Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
    // ────────────────────────────────────────────────────────────────
    //   2.  Shot evaluation & search
    // ────────────────────────────────────────────────────────────────

    //  Calculate ghost-ball position so that cue hits target towards pocket
    static inline D2D1_POINT_2F GhostPos(const Ball* tgt, int pocketIdx)
    {
        D2D1_POINT_2F P = pocketPositions[pocketIdx];
        float vx = P.x - tgt->x;
        float vy = P.y - tgt->y;
        float L = sqrtf(vx * vx + vy * vy);
        vx /= L;  vy /= L;
        return D2D1::Point2F(tgt->x - vx * (BALL_RADIUS * 2.0f),
            tgt->y - vy * (BALL_RADIUS * 2.0f));
    }

    //  Heuristic: shorter + straighter + proper group = higher score
    static inline float ScoreShot(float cue2Ghost,
        float tgt2Pocket,
        bool  correctGroup,
        bool  involves8)
    {
        float base = 2000.0f - (cue2Ghost + tgt2Pocket);   // prefer close shots
        if (!correctGroup)  base -= 400.0f;                  // penalty
        if (involves8)      base += 150.0f;                  // a bit more desirable
        return base;
    }

    // Checks if line segment is clear of obstructing balls
    // ────────────────────────────────────────────────────────────────
    //   1.  Low-level helpers – IsPathClear & FindFirstHitBall
    // ────────────────────────────────────────────────────────────────

    //  Test if the capsule [ start … end ] (radius = BALL_RADIUS)
    //  intersects any ball except the ids we want to ignore.
    bool IsPathClear(D2D1_POINT_2F start,
        D2D1_POINT_2F end,
        int ignoredBallId1,
        int ignoredBallId2)
    {
        float dx = end.x - start.x;
        float dy = end.y - start.y;
        float lenSq = dx * dx + dy * dy;
        if (lenSq < 1e-3f) return true;             // degenerate → treat as clear

        for (const Ball& b : balls)
        {
            if (b.isPocketed)      continue;
            if (b.id == ignoredBallId1 ||
                b.id == ignoredBallId2)             continue;

            // project ball centre onto the segment
            float t = ((b.x - start.x) * dx + (b.y - start.y) * dy) / lenSq;
            t = std::clamp(t, 0.0f, 1.0f);

            float cx = start.x + t * dx;
            float cy = start.y + t * dy;

            if (GetDistanceSq(b.x, b.y, cx, cy) < (BALL_RADIUS * BALL_RADIUS))
                return false;                       // blocked
        }
        return true;
    }

    //  Cast an (infinite) ray and return the first non-pocketed ball hit.
    //  `hitDistSq` is distance² from the start point to the collision point.
    Ball* FindFirstHitBall(D2D1_POINT_2F start,
        float        angle,
        float& hitDistSq)
    {
        Ball* hitBall = nullptr;
        float  bestSq = std::numeric_limits<float>::max();
        float  cosA = cosf(angle);
        float  sinA = sinf(angle);

        for (Ball& b : balls)
        {
            if (b.id == 0 || b.isPocketed) continue;         // ignore cue & sunk balls

            float relX = b.x - start.x;
            float relY = b.y - start.y;
            float proj = relX * cosA + relY * sinA;          // distance along the ray

            if (proj <= 0) continue;                         // behind cue

            // closest approach of the ray to the sphere centre
            float closestX = start.x + proj * cosA;
            float closestY = start.y + proj * sinA;
            float dSq = GetDistanceSq(b.x, b.y, closestX, closestY);

            if (dSq <= BALL_RADIUS * BALL_RADIUS)            // intersection
            {
                float back = sqrtf(BALL_RADIUS * BALL_RADIUS - dSq);
                float collDist = proj - back;                // front surface
                float collSq = collDist * collDist;
                if (collSq < bestSq)
                {
                    bestSq = collSq;
                    hitBall = &b;
                }
            }
        }
        hitDistSq = bestSq;
        return hitBall;
    }

    // Basic check for reasonable AI aim angles (optional)
    bool IsValidAIAimAngle(float angle) {
        // Placeholder - could check for NaN or infinity if calculations go wrong
        return isfinite(angle);
    }

    //midi func = start
    void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
        while (isMusicPlaying) {
            MCI_OPEN_PARMS mciOpen = { 0 };
            mciOpen.lpstrDeviceType = TEXT(""sequencer"");
            mciOpen.lpstrElementName = midiPath;

            if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
                midiDeviceID = mciOpen.wDeviceID;

                MCI_PLAY_PARMS mciPlay = { 0 };
                mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

                // Wait for playback to complete
                MCI_STATUS_PARMS mciStatus = { 0 };
                mciStatus.dwItem = MCI_STATUS_MODE;

                do {
                    mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                    Sleep(100); // adjust as needed
                } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    void StartMidi(HWND hwnd, const TCHAR* midiPath) {
        if (isMusicPlaying) {
            StopMidi();
        }
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }

    void StopMidi() {
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) musicThread.join();
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    /*void PlayGameMusic(HWND hwnd) {
        // Stop any existing playback
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) {
                musicThread.join();
            }
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }

        // Get the path of the executable
        TCHAR exePath[MAX_PATH];
        GetModuleFileName(NULL, exePath, MAX_PATH);

        // Extract the directory path
        TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
        if (lastBackslash != NULL) {
            *(lastBackslash + 1) = '\0';
        }

        // Construct the full path to the MIDI file
        static TCHAR midiPath[MAX_PATH];
        _tcscpy_s(midiPath, MAX_PATH, exePath);
        _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

        // Start the background playback
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }*/
    //midi func = end

    // --- Drawing Functions ---

    void OnPaint() {
        HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

        if (SUCCEEDED(hr)) {
            pRenderTarget->BeginDraw();
            DrawScene(pRenderTarget); // Pass render target
            hr = pRenderTarget->EndDraw();

            if (hr == D2DERR_RECREATE_TARGET) {
                DiscardDeviceResources();
                // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
                // But the timer loop will trigger redraw anyway.
            }
        }
        // If CreateDeviceResources failed, EndDraw might not be called.
        // Consider handling this more robustly if needed.
    }

    void DrawScene(ID2D1RenderTarget* pRT) {
        if (!pRT) return;

        //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
        // Set background color to #ffffcd (RGB: 255, 255, 205)
        pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
        //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

        DrawTable(pRT, pFactory);
        DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
        DrawBalls(pRT);
        DrawAimingAids(pRT); // Includes cue stick if aiming
        DrawUI(pRT);
        DrawPowerMeter(pRT);
        DrawSpinIndicator(pRT);
        DrawPocketedBallsIndicator(pRT);
        DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

         // Draw Game Over Message
        if (currentGameState == GAME_OVER && pTextFormat) {
            ID2D1SolidColorBrush* pBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
            if (pBrush) {
                D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
                pRT->DrawText(
                    gameOverMessage.c_str(),
                    (UINT32)gameOverMessage.length(),
                    pTextFormat, // Use large format maybe?
                    &layoutRect,
                    pBrush
                );
                SafeRelease(&pBrush);
            }
        }

    }

    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
        ID2D1SolidColorBrush* pBrush = nullptr;

        // === Draw Full Orange Frame (Table Border) ===
        ID2D1SolidColorBrush* pFrameBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        if (pFrameBrush) {
            D2D1_RECT_F outerRect = D2D1::RectF(
                TABLE_LEFT - CUSHION_THICKNESS,
                TABLE_TOP - CUSHION_THICKNESS,
                TABLE_RIGHT + CUSHION_THICKNESS,
                TABLE_BOTTOM + CUSHION_THICKNESS
            );
            pRT->FillRectangle(&outerRect, pFrameBrush);
            SafeRelease(&pFrameBrush);
        }

        // Draw Table Bed (Green Felt)
        pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
        if (!pBrush) return;
        D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
        pRT->FillRectangle(&tableRect, pBrush);
        SafeRelease(&pBrush);

        // ------------------------------------------------------------------
//  Spotlight overlay (soft radial inside a rounded rectangle)
// ------------------------------------------------------------------
        {
            // 2.1  Build a radial gradient brush (edge = base cloth, centre = lighter)
            ID2D1RadialGradientBrush* pSpot = nullptr;
            ID2D1GradientStopCollection* pStops = nullptr;

            D2D1_COLOR_F centreClr = D2D1::ColorF(
                std::min(1.f, TABLE_COLOR.r * 1.60f),   // lighten ~60 %
                std::min(1.f, TABLE_COLOR.g * 1.60f),
                std::min(1.f, TABLE_COLOR.b * 1.60f));

            const D2D1_GRADIENT_STOP gs[3] =
            {
                { 0.0f, D2D1::ColorF(centreClr.r, centreClr.g, centreClr.b, 0.95f) },
                { 0.6f, D2D1::ColorF(TABLE_COLOR.r, TABLE_COLOR.g, TABLE_COLOR.b, 0.55f) },
                { 1.0f, D2D1::ColorF(TABLE_COLOR.r, TABLE_COLOR.g, TABLE_COLOR.b, 0.0f) }
            };
            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                D2D1_RECT_F rc = tableRect;
                const float PAD = 18.0f;                   // inset so corners stay dark
                rc.left += PAD;  rc.top += PAD;
                rc.right -= PAD;  rc.bottom -= PAD;

                // centre point & radii
                D2D1_POINT_2F centre = D2D1::Point2F(
                    (rc.left + rc.right) / 2.0f,
                    (rc.top + rc.bottom) / 2.0f);

                float rx = (rc.right - rc.left) * 0.55f;
                float ry = (rc.bottom - rc.top) * 0.55f;

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        centre,                       // origin
                        D2D1::Point2F(0, 0),          // offset
                        rx, ry);

                pRT->CreateRadialGradientBrush(props, pStops, &pSpot);
                pStops->Release();
            }

            if (pSpot)
            {
                // Use the same rounded rectangle the pocket bar uses for subtle round corners
                const float RADIUS = 20.0f;                       // corner radius
                D2D1_ROUNDED_RECT spotlightRR =
                    D2D1::RoundedRect(tableRect, RADIUS, RADIUS);

                pRT->FillRoundedRectangle(&spotlightRR, pSpot);
                pSpot->Release();
            }
        }

        // Draw Cushions (Red Border)
        pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
        if (!pBrush) return;
        // Top Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        // Bottom Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        // Left Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        // Right Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        SafeRelease(&pBrush);


        // Draw Pockets (Black Circles)
        pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
        if (!pBrush) return;
        for (int i = 0; i < 6; ++i) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
            pRT->FillEllipse(&ellipse, pBrush);
        }
        SafeRelease(&pBrush);

        // Draw Headstring Line (White)
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        if (!pBrush) return;
        pRT->DrawLine(
            D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
            D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
            pBrush,
            1.0f // Line thickness
        );
        SafeRelease(&pBrush);

        // Draw Semicircle facing West (flat side East)
        // Draw Semicircle facing East (curved side on the East, flat side on the West)
        ID2D1PathGeometry* pGeometry = nullptr;
        HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
        if (SUCCEEDED(hr) && pGeometry)
        {
            ID2D1GeometrySink* pSink = nullptr;
            hr = pGeometry->Open(&pSink);
            if (SUCCEEDED(hr) && pSink)
            {
                float radius = 60.0f; // Radius for the semicircle
                D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

                // For a semicircle facing East (curved side on the East), use the top and bottom points.
                D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

                pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

                D2D1_ARC_SEGMENT arc = {};
                arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
                arc.size = D2D1::SizeF(radius, radius);
                arc.rotationAngle = 0.0f;
                // Use the correct identifier with the extra underscore:
                arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
                arc.arcSize = D2D1_ARC_SIZE_SMALL;

                pSink->AddArc(&arc);
                pSink->EndFigure(D2D1_FIGURE_END_OPEN);
                pSink->Close();
                SafeRelease(&pSink);

                ID2D1SolidColorBrush* pArcBrush = nullptr;
                //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
                pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
                if (pArcBrush)
                {
                    pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                    SafeRelease(&pArcBrush);
                }
            }
            SafeRelease(&pGeometry);
        }




    }


    // ----------------------------------------------
    //  Helper : clamp to [0,1] and lighten a colour
    // ----------------------------------------------
    static D2D1_COLOR_F Lighten(const D2D1_COLOR_F& c, float factor = 1.25f)
    {
        return D2D1::ColorF(
            std::min(1.0f, c.r * factor),
            std::min(1.0f, c.g * factor),
            std::min(1.0f, c.b * factor),
            c.a);
    }

    // ------------------------------------------------
    //  NEW  DrawBalls – radial-gradient “spot-light”
    // ------------------------------------------------
    void DrawBalls(ID2D1RenderTarget* pRT)
    {
        if (!pRT) return;

        ID2D1SolidColorBrush* pStripeBrush = nullptr;    // white stripe
        ID2D1SolidColorBrush* pBorderBrush = nullptr;    // black ring
        ID2D1SolidColorBrush * pNumWhite = nullptr; // NEW – white circle
        ID2D1SolidColorBrush * pNumBlack = nullptr; // NEW – digit colour

        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pNumWhite);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNumBlack);

        for (const Ball& b : balls)
        {
            if (b.isPocketed) continue;

            //------------------------------------------
            // Build the radial gradient for THIS ball
            //------------------------------------------
            ID2D1GradientStopCollection* pStops = nullptr;
            ID2D1RadialGradientBrush* pRad = nullptr;

            D2D1_GRADIENT_STOP gs[3];
            gs[0].position = 0.0f;  gs[0].color = D2D1::ColorF(1, 1, 1, 0.95f);     // bright spot
            gs[1].position = 0.35f; gs[1].color = Lighten(b.color);                 // transitional
            gs[2].position = 1.0f;  gs[2].color = b.color;                          // base colour

            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                // Place the hot-spot slightly towards top-left to look more 3-D
                D2D1_POINT_2F origin = D2D1::Point2F(b.x - BALL_RADIUS * 0.4f,
                    b.y - BALL_RADIUS * 0.4f);

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        origin,                        // gradientOrigin
                        D2D1::Point2F(0, 0),           // offset (not used here)
                        BALL_RADIUS * 1.3f,            // radiusX
                        BALL_RADIUS * 1.3f);           // radiusY

                pRT->CreateRadialGradientBrush(props, pStops, &pRad);
                SafeRelease(&pStops);
            }

            //------------------------------------------
            //  Draw the solid or striped ball itself
            //------------------------------------------
            D2D1_ELLIPSE outer = D2D1::Ellipse(
                D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            if (pRad)  pRT->FillEllipse(&outer, pRad);

            // ----------  Stripe overlay  -------------
            if (b.type == BallType::STRIPE && pStripeBrush)
            {
                // White band
                D2D1_RECT_F stripe = D2D1::RectF(
                    b.x - BALL_RADIUS,
                    b.y - BALL_RADIUS * 0.40f,
                    b.x + BALL_RADIUS,
                    b.y + BALL_RADIUS * 0.40f);
                pRT->FillRectangle(&stripe, pStripeBrush);

                // Inner circle (give stripe area same glossy shading)
                if (pRad)
                {
                    D2D1_ELLIPSE inner = D2D1::Ellipse(
                        D2D1::Point2F(b.x, b.y),
                        BALL_RADIUS * 0.60f,
                        BALL_RADIUS * 0.60f);
                    pRT->FillEllipse(&inner, pRad);
                }
            }

            // --------------------------------------------------------
//  Draw number decal (skip cue ball)
// --------------------------------------------------------
            if (b.id != 0 && pBallNumFormat && pNumWhite && pNumBlack)
            {
                // 1) white circle – slightly smaller on stripes so it fits
                const float decalR = (b.type == BallType::STRIPE) ?
                    BALL_RADIUS * 0.40f : BALL_RADIUS * 0.45f;

                D2D1_ELLIPSE decal = D2D1::Ellipse(
                    D2D1::Point2F(b.x, b.y), decalR, decalR);

                pRT->FillEllipse(&decal, pNumWhite);
                pRT->DrawEllipse(&decal, pNumBlack, 0.8f);   // thin border

                // 2) digit – convert id to printable number
                wchar_t numText[3];
                _snwprintf_s(numText, _TRUNCATE, L""%d"", b.id);

                // layout rectangle exactly the diameter of the decal
                D2D1_RECT_F layout = D2D1::RectF(
                    b.x - decalR, b.y - decalR,
                    b.x + decalR, b.y + decalR);

                pRT->DrawText(numText,
                    (UINT32)wcslen(numText),
                    pBallNumFormat,
                    &layout,
                    pNumBlack);
            }

            // Black border
            if (pBorderBrush)
                pRT->DrawEllipse(&outer, pBorderBrush, 1.5f);

            SafeRelease(&pRad);
        }

        SafeRelease(&pStripeBrush);
        SafeRelease(&pBorderBrush);
        SafeRelease(&pNumWhite);   // NEW
        SafeRelease(&pNumBlack);   // NEW
    }

    /*void DrawBalls(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

        pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

        if (!pBrush || !pStripeBrush) {
            SafeRelease(&pBrush);
            SafeRelease(&pStripeBrush);
            return;
        }


        for (size_t i = 0; i < balls.size(); ++i) {
            const Ball& b = balls[i];
            if (!b.isPocketed) {
                D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

                // Set main ball color
                pBrush->SetColor(b.color);
                pRT->FillEllipse(&ellipse, pBrush);

                // Draw Stripe if applicable
                if (b.type == BallType::STRIPE) {
                    // Draw a white band across the middle (simplified stripe)
                    D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                    // Need to clip this rectangle to the ellipse bounds - complex!
                    // Alternative: Draw two colored arcs leaving a white band.
                    // Simplest: Draw a white circle inside, slightly smaller.
                    D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                    pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                    pBrush->SetColor(b.color); // Set back to stripe color
                    pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                    // Let's try drawing a thick white line across
                    // This doesn't look great. Just drawing solid red for stripes for now.
                }

                // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
                // if (b.id != 0 && pTextFormat) {
                //     std::wstring numStr = std::to_wstring(b.id);
                //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
                //     ID2D1SolidColorBrush* pNumBrush = nullptr;
                //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
                //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
                //     // Create a smaller text format...
                //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
                //     SafeRelease(&pNumBrush);
                // }
            }
        }

        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
    }*/


    /*void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Condition check at start (Unchanged)
        //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
            //currentGameState != BREAKING && currentGameState != AIMING)
        //{
            //return;
        //}
            // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
        // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING);
        // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
        // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
            // NEW Condition: AI is displaying its aim
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

        // Ensure render target is valid
        if (!pRT) return;

        // Create Brushes and Styles (check for failures)
        HRESULT hr;
        hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        if FAILED(hr) { SafeRelease(&pBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
        // Create reflection brush (e.g., lighter shade or different color)
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
        // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
        D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
        if (FAILED(hr)) {
            SafeRelease(&pCyanBrush);
            // handle error if needed
        }
        // Create a Purple brush for primary and secondary lines
        D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
        if (FAILED(hr)) {
            SafeRelease(&pPurpleBrush);
            // handle error if needed
        }

        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
            if FAILED(hr) { pDashedStyle = nullptr; }
        }


        // --- Cue Stick Drawing (Unchanged from previous fix) ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = cueAngle + PI;
        float powerOffset = 0.0f;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
        if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
            powerOffset = shotPower * 5.0f;
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


        // --- Projection Line Calculation ---
        float cosA = cosf(cueAngle);
        float sinA = sinf(cueAngle);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);*/

    void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Determine if aiming aids should be drawn.
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING ||
                currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2);

        // FOOLPROOF FIX: This is the new condition to show the AI's aim.
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 && aiIsDisplayingAim);

        if (!isHumanInteracting && !isAiVisualizingShot) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return;

        // --- Brush and Style Creation (No changes here) ---
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr;
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Cyan), &pCyanBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Purple), &pPurpleBrush);
        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        }
        // --- End Brush Creation ---

        // --- FOOLPROOF FIX: Use the AI's planned angle and power for drawing ---
        float angleToDraw = cueAngle;
        float powerToDraw = shotPower;

        if (isAiVisualizingShot) {
            // When the AI is showing its aim, force the drawing to use its planned shot details.
            angleToDraw = aiPlannedShotDetails.angle;
            powerToDraw = aiPlannedShotDetails.power;
        }
        // --- End AI Aiming Fix ---

        // --- Cue Stick Drawing ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = angleToDraw + PI; // Use the angle we determined
        float powerOffset = 0.0f;
        if ((isAiming || isDraggingStick) || isAiVisualizingShot) {
            powerOffset = powerToDraw * 5.0f; // Use the power we determined
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);

        // --- Projection Line Calculation ---
        float cosA = cosf(angleToDraw); // Use the angle we determined
        float sinA = sinf(angleToDraw);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT;
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

        // Find the first ball hit by the aiming ray
        Ball* hitBall = nullptr;
        float firstHitDistSq = -1.0f;
        D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
        D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

        hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
        if (hitBall) {
            // Calculate the point on the target ball's circumference
            float collisionDist = sqrtf(firstHitDistSq);
            ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
            // Calculate ghost ball position for this specific hit (used for projection consistency)
            ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
        }

        // Find the first rail hit by the aiming ray
        D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
        float minRailDistSq = rayLength * rayLength;
        int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

        // Define table edge segments for intersection checks
        D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
        D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
        D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
        D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

        D2D1_POINT_2F currentIntersection;

        // Check Left Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
        }
        // Check Right Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
        }
        // Check Top Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
        }
        // Check Bottom Rail
        if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
        }


        // --- Determine final aim line end point ---
        D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
        bool aimingAtRail = true;

        if (hitBall && firstHitDistSq < minRailDistSq) {
            // Ball collision is closer than rail collision
            finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
            aimingAtRail = false;
        }

        // --- Draw Primary Aiming Line ---
        pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Draw Target Circle/Indicator ---
        D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
        pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

        // --- Draw Projection/Reflection Lines ---
        if (!aimingAtRail && hitBall) {
            // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
            D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
            pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // Calculate target ball projection based on impact line (cue collision point -> target center)
            float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
            // Clamp angle calculation if distance is tiny
            if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
                targetProjectionAngle = cueAngle; // Fallback if overlapping
            }

            D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
            D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
                hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
                hitBall->y + sinf(targetProjectionAngle) * 50.0f
            );
            // Draw solid line for target projection
            //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

        //new code start

                    // Dual trajectory with edge-aware contact simulation
            D2D1_POINT_2F dir = {
                targetProjectionEnd.x - targetStartPoint.x,
                targetProjectionEnd.y - targetStartPoint.y
            };
            float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
            dir.x /= dirLen;
            dir.y /= dirLen;

            D2D1_POINT_2F perp = { -dir.y, dir.x };

            // Approximate cue ball center by reversing from tip
            D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
                targetStartPoint.x - dir.x * BALL_RADIUS,
                targetStartPoint.y - dir.y * BALL_RADIUS
            };

            // REAL contact-ball center - use your physics object's center:
            // (replace 'objectBallPos' with whatever you actually call it)
            // (targetStartPoint is already hitBall->x, hitBall->y)
            D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
            //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

           // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
           // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
           // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
           // and 'perp' is perpendicular to 'dir'.
           // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
            /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
                (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
                /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                    (targetStartPoint.y - cueBallCenter.y) * perp.y);
                float absOffset = fabsf(offset);
                float side = (offset >= 0 ? 1.0f : -1.0f);*/

                // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
            D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

            // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
            float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
                (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);


            // Actual contact point on target ball edge
            D2D1_POINT_2F contactPoint = {
            contactBallCenter.x + perp.x * BALL_RADIUS * side,
            contactBallCenter.y + perp.y * BALL_RADIUS * side
            };

            // Tangent (cut shot) path from contact point
                // Tangent (cut shot) path: from contact point to contact ball center
            D2D1_POINT_2F objectBallDir = {
                contactBallCenter.x - contactPoint.x,
                contactBallCenter.y - contactPoint.y
            };
            float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
            if (oLen != 0.0f) {
                objectBallDir.x /= oLen;
                objectBallDir.y /= oLen;
            }

            const float PRIMARY_LEN = 150.0f; //default=150.0f
            const float SECONDARY_LEN = 150.0f; //default=150.0f
            const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

            D2D1_POINT_2F primaryEnd = {
                targetStartPoint.x + dir.x * PRIMARY_LEN,
                targetStartPoint.y + dir.y * PRIMARY_LEN
            };

            // Secondary line starts from the contact ball's center
            D2D1_POINT_2F secondaryStart = contactBallCenter;
            D2D1_POINT_2F secondaryEnd = {
                secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
                secondaryStart.y + objectBallDir.y * SECONDARY_LEN
            };

            if (absOffset < STRAIGHT_EPSILON)  // straight shot?
            {
                // Straight: secondary behind primary
                        // secondary behind primary {pDashedStyle param at end}
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            else
            {
                // Cut shot: both visible
                        // both visible for cut shot
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            // End improved trajectory logic

        //new code end

            // -- Cue Ball Path after collision (Optional, requires physics) --
            // Very simplified: Assume cue deflects, angle depends on cut angle.
            // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
            // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
            // D2D1_POINT_2F cueProjectionEnd = ...
            // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // --- Accuracy Comment ---
            // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
            // or shots with spin, is limited by the simplified physics model. Real pool physics involves
            // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
            // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

        }
        else if (aimingAtRail && hitRailIndex != -1) {
            // Aiming at a rail: Draw reflection line
            float reflectAngle = cueAngle;
            // Reflect angle based on which rail was hit
            if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
                reflectAngle = PI - cueAngle; // Reflect horizontal component
            }
            else { // Top or Bottom rail
                reflectAngle = -cueAngle; // Reflect vertical component
            }
            // Normalize angle if needed (atan2 usually handles this)
            while (reflectAngle > PI) reflectAngle -= 2 * PI;
            while (reflectAngle <= -PI) reflectAngle += 2 * PI;


            float reflectionLength = 60.0f; // Length of the reflection line
            D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
                finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
                finalLineEnd.y + sinf(reflectAngle) * reflectionLength
            );

            // Draw the reflection line (e.g., using a different color/style)
            pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
        }

        // Release resources
        SafeRelease(&pBrush);
        SafeRelease(&pGhostBrush);
        SafeRelease(&pCueBrush);
        SafeRelease(&pReflectBrush); // Release new brush
        SafeRelease(&pCyanBrush);
        SafeRelease(&pPurpleBrush);
        SafeRelease(&pDashedStyle);
    }


    void DrawUI(ID2D1RenderTarget* pRT) {
        if (!pTextFormat || !pLargeTextFormat) return;

        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
        if (!pBrush) return;

        //new code
        // --- Always draw AI's 8?Ball call arrow when it's Player?2's turn and AI has called ---
        //if (isPlayer2AI && currentPlayer == 2 && calledPocketP2 >= 0) {
            // FIX: This condition correctly shows the AI's called pocket arrow.
        if (isPlayer2AI && IsPlayerOnEightBall(2) && calledPocketP2 >= 0) {
            // pocket index that AI called
            int idx = calledPocketP2;
            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    { P.x - 15.0f, P.y - 40.0f },
                    { P.x + 15.0f, P.y - 40.0f },
                    { P.x       , P.y - 10.0f }
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrow);
            }
            // draw “Choose a pocket...” prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""AI has called this pocket"",
                (UINT32)wcslen(L""AI has called this pocket""),
                pTextFormat,
                &txt,
                pBrush
            );
            // note: no return here — we still draw fouls/turn text underneath
        }
        //end new code

        // --- Player Info Area (Top Left/Right) --- (Unchanged)
        float uiTop = TABLE_TOP - 80;
        float uiHeight = 60;
        float p1Left = TABLE_LEFT;
        float p1Width = 150;
        float p2Left = TABLE_RIGHT - p1Width;
        D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
        D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

        // Player 1 Info Text (Unchanged)
        std::wostringstream oss1;
        oss1 << player1Info.name.c_str() << L""\n"";
        if (player1Info.assignedType != BallType::NONE) {
            oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss1 << L""(Undecided)"";
        }
        pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
        // Draw Player 1 Side Ball
        if (player1Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player1Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }


        // Player 2 Info Text (Unchanged)
        std::wostringstream oss2;
        oss2 << player2Info.name.c_str() << L""\n"";
        if (player2Info.assignedType != BallType::NONE) {
            oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss2 << L""(Undecided)"";
        }
        pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
        // Draw Player 2 Side Ball
        if (player2Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player2Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }

        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
            arrowBackX = playerBox.left - 25.0f;
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

            float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
            float notchWidth = 10.0f;

            float cx = arrowBackX;
            float cy = arrowCenterY;

            // Define triangle + rectangle tail shape
            D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
            D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
            D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

            // Rectangle coordinates for the tail portion:
            D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
            D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
            D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
            D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

            ID2D1PathGeometry* pPath = nullptr;
            if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
                ID2D1GeometrySink* pSink = nullptr;
                if (SUCCEEDED(pPath->Open(&pSink))) {
                    pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                    pSink->AddLine(baseTop);
                    pSink->AddLine(r2); // transition from triangle into rectangle
                    pSink->AddLine(r1);
                    pSink->AddLine(r4);
                    pSink->AddLine(r3);
                    pSink->AddLine(baseBot);
                    pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                    pSink->Close();
                    SafeRelease(&pSink);
                    pRT->FillGeometry(pPath, pArrowBrush);
                }
                SafeRelease(&pPath);
            }


            SafeRelease(&pArrowBrush);
        }

        //original
    /*
        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            if (currentPlayer == 1) {
    arrowBackX = p1Rect.left - 25.0f; // Position left of the box
                arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
                // Define points for right-pointing arrow
                //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
                //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
                //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
                // Enhanced arrow with base rectangle intersection
        float notchDepth = 6.0f; // Depth of square base ""stem""
        float notchWidth = 4.0f; // Thickness of square part

        D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
        D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
        D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
        D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
        D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(pt2);
                pSink->AddLine(pt3);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
            }


            //==================else player 2
            else { // Player 2
             // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
             // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    arrowBackX = p2Rect.left - 25.0f; // Position left of the box
    arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
    // Define points for right-pointing arrow
    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
            }
            */


            // --- Persistent Blue 8?Ball Call Arrow & Prompt ---
        /*if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
        {
            // determine index (default top?right)
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
        }*/

        // --- Persistent Blue 8?Ball Pocket Arrow & Prompt (once called) ---
    /* if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
    {
        // 1) Determine pocket index
        int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
        // If the other player had called but it's now your turn, still show that call
        if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
        if (idx < 0) idx = 2; // default to top?right if somehow still unset

        // 2) Draw large blue arrow
        ID2D1SolidColorBrush* pArrow = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
        if (pArrow) {
            auto P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                { P.x - 15.0f, P.y - 40.0f },
                { P.x + 15.0f, P.y - 40.0f },
                { P.x       , P.y - 10.0f }
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrow);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrow);
        }

        // 3) Draw persistent prompt text
        D2D1_RECT_F txt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &txt,
            pBrush
        );
        // Note: no 'return'; allow foul/turn text to draw beneath if needed
    } */

    // new code ends here

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
        if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
            ID2D1SolidColorBrush* pFoulBrush = nullptr;
            pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
            if (pFoulBrush && pLargeTextFormat) {
                // Calculate Rect for bottom-middle area
                float foulWidth = 200.0f; // Adjust width as needed
                float foulHeight = 60.0f;
                float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
                // Position below the pocketed balls bar
                float foulTop = pocketedBallsBarRect.bottom + 10.0f;
                D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

                // --- Set text alignment to center for foul text ---
                pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

                // --- Restore default alignment for large text if needed elsewhere ---
                // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                SafeRelease(&pFoulBrush);
            }
        }

        // --- Blue Arrow & Prompt for 8?Ball Call (while choosing or after called) ---
        if ((currentGameState == CHOOSING_POCKET_P1
            || currentGameState == CHOOSING_POCKET_P2)
            || (calledPocketP1 >= 0 || calledPocketP2 >= 0))
        {
            // determine index:
            //  - if a call exists, use it
            //  - if still choosing, use hover if any
            // determine index: use only the clicked call; default to top?right if unset
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt below pockets
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
            // do NOT return here; allow foul/turn text to display under the arrow
        }

        // Removed Obsolete
        /*
        // --- 8-Ball Pocket Selection Arrow & Prompt ---
        if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
            // Determine which pocket to highlight (default to Top-Right if unset)
            int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (idx < 0) idx = 2;

            // Draw the downward arrow
            ID2D1SolidColorBrush* pArrowBrush = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
            if (pArrowBrush) {
                D2D1_POINT_2F P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 10.0f, P.y - 30.0f},
                    {P.x + 10.0f, P.y - 30.0f},
                    {P.x        , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrowBrush);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrowBrush);
            }

            // Draw “Choose a pocket...” text under the table
            D2D1_RECT_F prompt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &prompt,
                pBrush
            );

            return; // Skip normal turn/foul text
        }
        */


        // Show AI Thinking State (Unchanged from previous step)
        if (currentGameState == AI_THINKING && pTextFormat) {
            ID2D1SolidColorBrush* pThinkingBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
            if (pThinkingBrush) {
                D2D1_RECT_F thinkingRect = p2Rect;
                thinkingRect.top += 20; // Offset within P2 box
                // Ensure default text alignment for this
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
                pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
                SafeRelease(&pThinkingBrush);
            }
        }

        SafeRelease(&pBrush);

        // --- Draw CHEAT MODE label if active ---
        if (cheatModeEnabled) {
            ID2D1SolidColorBrush* pCheatBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
            if (pCheatBrush && pTextFormat) {
                D2D1_RECT_F cheatTextRect = D2D1::RectF(
                    TABLE_LEFT + 10.0f,
                    TABLE_TOP + 10.0f,
                    TABLE_LEFT + 200.0f,
                    TABLE_TOP + 40.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
            }
            SafeRelease(&pCheatBrush);
        }
    }

    void DrawPowerMeter(ID2D1RenderTarget* pRT) {
        // Draw Border
        ID2D1SolidColorBrush* pBorderBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        if (!pBorderBrush) return;
        pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
        SafeRelease(&pBorderBrush);

        // Create Gradient Fill
        ID2D1GradientStopCollection* pGradientStops = nullptr;
        ID2D1LinearGradientBrush* pGradientBrush = nullptr;
        D2D1_GRADIENT_STOP gradientStops[4];
        gradientStops[0].position = 0.0f;
        gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
        gradientStops[1].position = 0.45f;
        gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
        gradientStops[2].position = 0.7f;
        gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
        gradientStops[3].position = 1.0f;
        gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

        pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
        if (pGradientStops) {
            D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
            props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
            props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
            pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
            SafeRelease(&pGradientStops);
        }

        // Calculate Fill Height
        float fillRatio = 0;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Determine if power meter should reflect shot power (human aiming or AI preparing)
        bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
        // NEW Condition: AI is displaying its aim, so show its chosen power
        bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
            fillRatio = shotPower / MAX_SHOT_POWER;
        }
        float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
        D2D1_RECT_F fillRect = D2D1::RectF(
            powerMeterRect.left,
            powerMeterRect.bottom - fillHeight,
            powerMeterRect.right,
            powerMeterRect.bottom
        );

        if (pGradientBrush) {
            pRT->FillRectangle(&fillRect, pGradientBrush);
            SafeRelease(&pGradientBrush);
        }

        // Draw scale notches
        ID2D1SolidColorBrush* pNotchBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
        if (pNotchBrush) {
            for (int i = 0; i <= 8; ++i) {
                float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
                pRT->DrawLine(
                    D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                    D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                    pNotchBrush,
                    1.5f
                );
            }
            SafeRelease(&pNotchBrush);
        }

        // Draw ""Power"" Label Below Meter
        if (pTextFormat) {
            ID2D1SolidColorBrush* pTextBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
            if (pTextBrush) {
                D2D1_RECT_F textRect = D2D1::RectF(
                    powerMeterRect.left - 20.0f,
                    powerMeterRect.bottom + 8.0f,
                    powerMeterRect.right + 20.0f,
                    powerMeterRect.bottom + 38.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
                SafeRelease(&pTextBrush);
            }
        }

        // Draw Glow Effect if fully charged or fading out
        static float glowPulse = 0.0f;
        static bool glowIncreasing = true;
        static float glowFadeOut = 0.0f; // NEW: tracks fading out

        if (shotPower >= MAX_SHOT_POWER * 0.99f) {
            // While fully charged, keep pulsing normally
            if (glowIncreasing) {
                glowPulse += 0.02f;
                if (glowPulse >= 1.0f) glowIncreasing = false;
            }
            else {
                glowPulse -= 0.02f;
                if (glowPulse <= 0.0f) glowIncreasing = true;
            }
            glowFadeOut = 1.0f; // Reset fade out to full
        }
        else if (glowFadeOut > 0.0f) {
            // If shot fired, gradually fade out
            glowFadeOut -= 0.02f;
            if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
        }

        if (glowFadeOut > 0.0f) {
            ID2D1SolidColorBrush* pGlowBrush = nullptr;
            float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
            pRT->CreateSolidColorBrush(
                D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
                &pGlowBrush
            );
            if (pGlowBrush) {
                float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
                float glowCenterY = powerMeterRect.top;
                D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                    D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                    12.0f + 3.0f * glowPulse,
                    6.0f + 2.0f * glowPulse
                );
                pRT->FillEllipse(&glowEllipse, pGlowBrush);
                SafeRelease(&pGlowBrush);
            }
        }
    }

    void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pWhiteBrush = nullptr;
        ID2D1SolidColorBrush* pRedBrush = nullptr;

        pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
        pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

        if (!pWhiteBrush || !pRedBrush) {
            SafeRelease(&pWhiteBrush);
            SafeRelease(&pRedBrush);
            return;
        }

        // Draw White Ball Background
        D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
        pRT->FillEllipse(&bgEllipse, pWhiteBrush);
        pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


        // Draw Red Dot for Spin Position
        float dotRadius = 4.0f;
        float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
        float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
        D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
        pRT->FillEllipse(&dotEllipse, pRedBrush);

        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
    }


    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBgBrush = nullptr;
        ID2D1SolidColorBrush* pBallBrush = nullptr;

        // Ensure render target is valid before proceeding
        if (!pRT) return;

        HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
        if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
        if (FAILED(hr)) {
            SafeRelease(&pBgBrush);
            SafeRelease(&pBallBrush);
            return; // Exit if brush creation fails
        }

        // Draw the background bar (rounded rect)
        D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
        float baseAlpha = 0.8f;
        float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
        float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
        pBgBrush->SetOpacity(finalAlpha);
        pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
        pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

        // --- Draw small circles for pocketed balls inside the bar ---

        // Calculate dimensions based on the bar's height for better scaling
        float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
        float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
        float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
        float padding = spacing * 0.75f; // Add padding from the edges
        float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

        // Starting X positions with padding
        float currentX_P1 = pocketedBallsBarRect.left + padding;
        float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

        int p1DrawnCount = 0;
        int p2DrawnCount = 0;
        const int maxBallsToShow = 7; // Max balls per player in the bar

        for (const auto& b : balls) {
            if (b.isPocketed) {
                // Skip cue ball and 8-ball in this indicator
                if (b.id == 0 || b.id == 8) continue;

                bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
                bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

                if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P1 balls from left to right
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p1DrawnCount++;
                }
                else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P2 balls from right to left
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p2DrawnCount++;
                }
                // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
                // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
            }
        }

        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
    }

    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
        if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
            return; // Only show when placing/dragging
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

        if (pGhostBrush) {
            D2D1_POINT_2F drawPos;
            if (isDraggingCueBall) {
                drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
            }
            else {
                // If not dragging but in placement state, show at current ball pos
                drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
            }

            // Check if the placement is valid before drawing differently?
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

            if (!isValid) {
                // Maybe draw red outline if invalid placement?
                pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
            }


            D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
            pRT->FillEllipse(&ghostEllipse, pGhostBrush);
            pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

            SafeRelease(&pGhostBrush);
        }
    }

    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
        /*  Never show the arrow while the player is still placing the
        cue-ball (ball-in-hand) – it otherwise hides behind the
        ghost-ball and can lock the UI.                               */

        /* Still skip the opening-break placement,
       but show the arrow during BALL-IN-HAND */
       // ? skip when no active call for the CURRENT shooter
        if ((currentPlayer == 1 && calledPocketP1 < 0) ||
            (currentPlayer == 2 && calledPocketP2 < 0))    return;
        /*if (currentGameState == PRE_BREAK_PLACEMENT)
            return;*/ //new ai-asked-to-disable
            /*if (currentGameState == BALL_IN_HAND_P1 ||
                currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT)
            {
                return;
            }*/

        int pocketToIndicate = -1;
        // Whenever EITHER player has pocketed their first 7 and has called (human or AI),
        // we forcibly show their arrow—regardless of currentGameState.
        if ((currentPlayer == 1 && player1Info.ballsPocketedCount >= 7 && calledPocketP1 >= 0) ||
            (currentPlayer == 2 && player2Info.ballsPocketedCount >= 7 && calledPocketP2 >= 0))
        {
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        /*// A human player is actively choosing if they are in the CHOOSING_POCKET state.
        bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

        if (isHumanChoosing) {
            // When choosing, show the currently selected pocket (which has a default).
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        else if (IsPlayerOnEightBall(currentPlayer)) {
            // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }*/

        if (pocketToIndicate < 0 || pocketToIndicate > 5) {
            return; // Don't draw if no pocket is selected or relevant.
        }

        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
        if (!pArrowBrush) return;

        // ... The rest of your arrow drawing geometry logic remains exactly the same ...
        // (No changes needed to the points/path drawing, only the logic above)
        D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
        float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
        float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
        float arrowShaftWidth = arrowHeadSize * 0.4f;
        float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
        D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

        if (targetPocketCenter.y == TABLE_TOP) {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
        }
        else {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        }

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
                pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
        SafeRelease(&pArrowBrush);
    }
```

==++ Here's the full source for (file 2/3 (No OOP-based)) ""resource.h""::: ++==
```resource.h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Yahoo-8Ball-Pool-Clone.rc
//
#define IDI_ICON1                       101
// --- NEW Resource IDs (Define these in your .rc file / resource.h) ---
#define IDD_NEWGAMEDLG 106
#define IDC_RADIO_2P   1003
#define IDC_RADIO_CPU  1005
#define IDC_GROUP_AI   1006
#define IDC_RADIO_EASY 1007
#define IDC_RADIO_MEDIUM 1008
#define IDC_RADIO_HARD 1009
// --- NEW Resource IDs for Opening Break ---
#define IDC_GROUP_BREAK_MODE 1010
#define IDC_RADIO_CPU_BREAK  1011
#define IDC_RADIO_P1_BREAK   1012
#define IDC_RADIO_FLIP_BREAK 1013
// Standard IDOK is usually defined, otherwise define it (e.g., #define IDOK 1)

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40002 // Incremented
#define _APS_NEXT_CONTROL_VALUE         1014 // Incremented
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

==++ Here's the full source for (file 3/3 (No OOP-based)) ""Yahoo-8Ball-Pool-Clone.rc""::: ++==
```Yahoo-8Ball-Pool-Clone.rc
// Microsoft Visual C++ generated resource script.
//
#include ""resource.h""

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include ""winres.h""

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
""resource.h\0""
END

2 TEXTINCLUDE
BEGIN
""#include """"winres.h""""\r\n""
""\0""
END

3 TEXTINCLUDE
BEGIN
""\r\n""
""\0""
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    ""D:\\Download\\8Ball_Colored.ico""

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

#include <windows.h> // Needed for control styles like WS_GROUP, BS_AUTORADIOBUTTON etc.

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_NEWGAMEDLG DIALOGEX 0, 0, 220, 185 // Dialog position (x, y) and size (width, height) in Dialog Units (DLUs) - Increased Height
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""New 8-Ball Game""
FONT 8, ""MS Shell Dlg"", 400, 0, 0x1 // Standard dialog font
BEGIN
// --- Game Mode Selection ---
// Group Box for Game Mode (Optional visually, but helps structure)
GROUPBOX        ""Game Mode"", IDC_STATIC, 7, 7, 90, 50

// ""2 Player"" Radio Button (First in this group)
CONTROL         ""&2 Player (Human vs Human)"", IDC_RADIO_2P, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 14, 20, 80, 10

// ""Human vs CPU"" Radio Button
CONTROL         ""Human vs &CPU"", IDC_RADIO_CPU, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 14, 35, 70, 10


// --- AI Difficulty Selection (Inside its own Group Box) ---
GROUPBOX        ""AI Difficulty"", IDC_GROUP_AI, 118, 7, 95, 70

// ""Easy"" Radio Button (First in the AI group)
CONTROL         ""&Easy"", IDC_RADIO_EASY, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 20, 60, 10

// ""Medium"" Radio Button
CONTROL         ""&Medium"", IDC_RADIO_MEDIUM, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 35, 60, 10

// ""Hard"" Radio Button
CONTROL         ""&Hard"", IDC_RADIO_HARD, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 50, 60, 10

// --- Opening Break Modes (For Versus CPU Only) ---
GROUPBOX        ""Opening Break Modes:"", IDC_GROUP_BREAK_MODE, 118, 82, 95, 60

// ""CPU Break"" Radio Button (Default for this group)
CONTROL         ""&CPU Break"", IDC_RADIO_CPU_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 95, 70, 10

// ""P1 Break"" Radio Button
CONTROL         ""&P1 Break"", IDC_RADIO_P1_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 110, 70, 10

// ""FlipCoin Break"" Radio Button
CONTROL         ""&FlipCoin Break"", IDC_RADIO_FLIP_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 125, 70, 10


// --- Standard Buttons ---
DEFPUSHBUTTON   ""Start"", IDOK, 55, 160, 50, 14 // Default button (Enter key) - Adjusted Y position
PUSHBUTTON      ""Cancel"", IDCANCEL, 115, 160, 50, 14 // Adjusted Y position
END
```"
dtUUTMgw,Mesh 1~3 gang Wall Switch (no N),xangin,Python,Friday 18th of July 2025 09:39:12 AM CDT,"from custom_components.xiaomi_gateway3.core.devices import *

DEVICES = [

{
    11572: [None, ""Mesh Single Wall Switch (no N)"", ""babai.switch.301ml""],
    ""spec"": [
        BaseConv(""switch"", ""switch"", mi=""2.p.1""),
        MapConv(""wireless"", ""select"", mi=""2.p.2"", map={0: ""Normal"", 1: ""Wireless"", 2: ""Atom"", 3: ""Scene""}),  # config
        MapConv(""power_on_state"", ""select"", mi=""2.p.3"", map={0: ""Default"", 1: ""Off"", 2: ""On""}),  # config
        BaseConv(""action"", ""sensor"", entity=ENTITY_DISABLED),
        ConstConv(""action"", mi=""6.e.2"", value=BUTTON_SINGLE),
        BaseConv(""Indicator Light Backlight"", ""switch"", mi=""6.p.1""),
        BaseConv(""Indicator Light Power Light"", ""switch"", mi=""6.p.2""),
    ],
}, {
    11574: [None, ""Mesh Double Wall Switch (no N)"", ""babai.switch.302ml""],
    ""spec"": [
        BaseConv(""channel_1"", ""switch"", mi=""2.p.1""),
        BaseConv(""channel_2"", ""switch"", mi=""3.p.1""),
        MapConv(""wireless_1"", ""select"", mi=""2.p.2"", map={0: ""Normal"", 1: ""Wireless"", 2: ""Atom"", 3: ""Scene""}),  # config
        MapConv(""wireless_2"", ""select"", mi=""3.p.2"", map={0: ""Normal"", 1: ""Wireless"", 2: ""Atom"", 3: ""Scene""}),  # config
        MapConv(""power_on_state_1"", ""select"", mi=""2.p.3"", map={0: ""Default"", 1: ""Off"", 2: ""On""}),  # config
        MapConv(""power_on_state_2"", ""select"", mi=""3.p.3"", map={0: ""Default"", 1: ""Off"", 2: ""On""}),  # config
        BaseConv(""action"", ""sensor"", entity=ENTITY_DISABLED),
        ConstConv(""action"", mi=""6.e.1"", value=BUTTON_1_SINGLE),
        ConstConv(""action"", mi=""6.e.3"", value=BUTTON_2_SINGLE),
        BaseConv(""Indicator Light Backlight"", ""switch"", mi=""6.p.1""),
        BaseConv(""Indicator Light Power Light"", ""switch"", mi=""6.p.2""),        
    ],
}, {
    11575: [None, ""Mesh Triple Wall Switch (no N)"", ""babai.switch.303ml""],
    ""spec"": [
        BaseConv(""channel_1"", ""switch"", mi=""2.p.1""),
        BaseConv(""channel_2"", ""switch"", mi=""3.p.1""),
        BaseConv(""channel_3"", ""switch"", mi=""4.p.1""),
        MapConv(""wireless_1"", ""select"", mi=""2.p.2"", map={0: ""Normal"", 1: ""Wireless"", 2: ""Atom"", 3: ""Scene""}),  # config
        MapConv(""wireless_2"", ""select"", mi=""3.p.2"", map={0: ""Normal"", 1: ""Wireless"", 2: ""Atom"", 3: ""Scene""}),  # config
        MapConv(""wireless_3"", ""select"", mi=""4.p.2"", map={0: ""Normal"", 1: ""Wireless"", 2: ""Atom"", 3: ""Scene""}),  # config
        MapConv(""power_on_state_1"", ""select"", mi=""2.p.3"", map={0: ""Default"", 1: ""Off"", 2: ""On""}),  # config
        MapConv(""power_on_state_2"", ""select"", mi=""3.p.3"", map={0: ""Default"", 1: ""Off"", 2: ""On""}),  # config
        MapConv(""power_on_state_3"", ""select"", mi=""4.p.3"", map={0: ""Default"", 1: ""Off"", 2: ""On""}),  # config
        BaseConv(""action"", ""sensor"", entity=ENTITY_DISABLED),
        ConstConv(""action"", mi=""6.e.1"", value=BUTTON_1_SINGLE),
        ConstConv(""action"", mi=""6.e.2"", value=BUTTON_2_SINGLE),
        ConstConv(""action"", mi=""6.e.3"", value=BUTTON_3_SINGLE),
        BaseConv(""Indicator Light Backlight"", ""switch"", mi=""6.p.1""),
        BaseConv(""Indicator Light Power Light"", ""switch"", mi=""6.p.2""),        
    ],    
}

] + DEVICES"
nn3HseTY,Batch Video Cutter & Encoder - Multi,EurenikZ,Batch,Friday 18th of July 2025 09:17:06 AM CDT,":: Dieses Skript verarbeitet alle .mp4-Dateien im aktuellen Verzeichnis, entfernt die angegebenen Sekunden vom Anfang und Ende und komprimiert sie optional per FFmpeg mit einem wählbaren CRF-Wert. Nur Videos mit ausreichender Länge (Videolänge + 3 > Schnittbereich) werden bearbeitet. Der ursprüngliche Zeitstempel der Datei bleibt erhalten, und die Ausgabedateien erhalten angepasste Namen (_cut.mp4 oder _crfXX.mp4).
:: In dieser Version wird für jedes Video einzeln die Schnitt-Zeit angegeben.
:: ""ffmpeg-release-essentials.zip"" hier herunterladen, entpacken und aus dem Ordner ""bin"" die ffmpeg.exe und ffprobe.exe in das Verzeichnis kopieren: https://www.gyan.dev/ffmpeg/builds/
:: Version 1.0 - 18.07.2025

@echo off
setlocal enabledelayedexpansion

:: Benutzerabfrage: Codec-Auswahl
echo Waehle Codec:
echo 1 - H.265 (libx265) - Gute Kompression, schnellere Kodierung, breite Unterstuetzung
echo 2 - AV1 (libaom-av1) - Beste Kompression, aber sehr langsam, fuer neuere Geräte
set /p CODECWAHL=Eingabe (1 oder 2): 

if not ""%CODECWAHL%""==""1"" if not ""%CODECWAHL%""==""2"" (
	echo Ungueltige Eingabe. Standard: H.265 wird verwendet.
	set CODECWAHL=1
)

:: CRF-Abfrage je nach Codec
if ""%CODECWAHL%""==""1"" (
	echo H.265 CRF-Wert ^(18=hoch, 25=normal, 30=niedrig, 35=sehr niedrig^) - Leer lassen = nur schneiden
) else (
	echo AV1 CRF-Wert ^(24=hoch, 32=normal, 38=niedrig, 46=sehr niedrig^) - Leer lassen = nur schneiden
)
set /p CRF_WERT=Welcher CRF-Wert soll verwendet werden?

:: CRF-Wert prüfen falls angegeben
if not ""%CRF_WERT%""=="""" (
	for /f ""delims=0123456789"" %%A in (""%CRF_WERT%"") do (
		echo Ungueltige Eingabe bei CRF-Wert & pause & exit /b
	)
)

echo.
echo Folgende MP4-Videos wurden gefunden:
echo.

:: Zähler für Videos
set VIDEO_COUNT=0

:: Alle MP4-Dateien auflisten und zählen, aber _crf-Dateien ignorieren
set VIDEO_COUNT=0
for %%F in (*.mp4) do (
	echo %%F | findstr /i ""_crf"" >nul
	if errorlevel 1 (
		set /a VIDEO_COUNT+=1
		echo !VIDEO_COUNT!: %%F
	)
)

if !VIDEO_COUNT! EQU 0 (
	echo Keine MP4-Dateien gefunden.
	pause
	exit /b
)

echo.
echo Gib fuer jedes Video die Schnitt-Zeiten ein:
echo.

:: Arrays für die Schnitt-Werte initialisieren
set VIDEO_INDEX=0

:: Schleife durch alle Videos für Eingaben
set VIDEO_INDEX=0
for %%F in (*.mp4) do (
	echo %%F | findstr /i ""_crf"" >nul
	if errorlevel 1 (
		set /a VIDEO_INDEX+=1
		echo Video !VIDEO_INDEX!: %%F

		set /p ""CUT_START_!VIDEO_INDEX!=Wie viele Sekunden vom ANFANG entfernen? ""
		if ""!CUT_START_!VIDEO_INDEX!!""=="""" set ""CUT_START_!VIDEO_INDEX!=0""

		set /p ""CUT_END_!VIDEO_INDEX!=Wie viele Sekunden vom ENDE entfernen? ""
		if ""!CUT_END_!VIDEO_INDEX!!""=="""" set ""CUT_END_!VIDEO_INDEX!=0""

		:: Eingaben prüfen
		call set ""TMPSTART=%%CUT_START_!VIDEO_INDEX!%%""
		if not ""!TMPSTART!""=="""" (
			for /f ""delims=0123456789"" %%A in (""!TMPSTART!"") do (
				echo Ungueltige Eingabe bei Startzeit fuer %%F & pause & exit /b
			)
		)

		call set ""TMPEND=%%CUT_END_!VIDEO_INDEX!%%""
		if not ""!TMPEND!""=="""" (
			for /f ""delims=0123456789"" %%A in (""!TMPEND!"") do (
				echo Ungueltige Eingabe bei Endzeit fuer %%F & pause & exit /b
			)
		)

		echo.
	)
)

echo Alle Eingaben erfasst. Beginne mit der Verarbeitung...
echo.

:: Verarbeitung aller Videos
set VIDEO_INDEX=0
for %%F in (*.mp4) do (
	echo %%F | findstr /i ""_crf"" >nul
	if errorlevel 1 (
		set /a VIDEO_INDEX+=1
		echo Bearbeite Video !VIDEO_INDEX!/!VIDEO_COUNT!: %%F
		
		:: Aktuelle Schnitt-Werte laden
		call set ""CUT_START=%%CUT_START_!VIDEO_INDEX!%%""
		call set ""CUT_END=%%CUT_END_!VIDEO_INDEX!%%""
		
		:: Leere Werte auf 0 setzen
		if ""!CUT_START!""=="""" set ""CUT_START=0""
		if ""!CUT_END!""=="""" set ""CUT_END=0""
		
		set /a CUTS_TOTAL=!CUT_START!+!CUT_END!

		for /f ""usebackq delims="" %%T in (`powershell -NoLogo -NoProfile -Command ""(Get-Item '%%F').LastWriteTime.ToString('yyyy:MM:dd HH:mm:ss')""`) do (
			set ""TIMESTAMP=%%T""
		)

		for /f ""usebackq delims="" %%D in (`ffprobe -v error -select_streams v:0 -show_entries format^=duration -of default^=nokey^=1:noprint_wrappers^=1 ""%%F""`) do (
			set ""DURATION=%%D""
		)

		for /f ""tokens=1 delims=."" %%T in (""!DURATION!"") do set /a INTDURATION=%%T

		set /a VIDEO_PLUS_3=!INTDURATION!+3

		if !VIDEO_PLUS_3! GTR !CUTS_TOTAL! (
			set /a REMAINING=!INTDURATION!-!CUTS_TOTAL!
			if !REMAINING! GEQ 1 (
				set ""OUTFILE=%%~nF""

				if ""%CRF_WERT%""=="""" (
					set ""OUTFILE=!OUTFILE!_cut.mp4""
					if !CUTS_TOTAL! GTR 0 (
						ffmpeg -y -i ""%%F"" -ss !CUT_START! -t !REMAINING! -c copy ""!OUTFILE!""
					) else (
						:: Nur kopieren wenn kein Schnitt nötig
						copy ""%%F"" ""!OUTFILE!""
					)
				) else (
					if ""%CODECWAHL%""==""1"" (
						set ""OUTFILE=!OUTFILE!_crf!CRF_WERT!.mp4""
						if !CUTS_TOTAL! GTR 0 (
							ffmpeg -y -ss !CUT_START! -i ""%%F"" -t !REMAINING! -c:v libx265 -crf !CRF_WERT! -preset slow -movflags +faststart -c:a aac -b:a 160k ""!OUTFILE!""
						) else (
							:: Nur neu kodieren ohne Schnitt
							ffmpeg -y -i ""%%F"" -c:v libx265 -crf !CRF_WERT! -preset slow -movflags +faststart -c:a aac -b:a 160k ""!OUTFILE!""
						)
					) else (
						:: AV1 - CPU-Used dynamisch bestimmen
						if !CRF_WERT! LEQ 20 (
							set ""CPU_USED=2""
						) else if !CRF_WERT! LEQ 28 (
							set ""CPU_USED=4""
						) else if !CRF_WERT! LEQ 35 (
							set ""CPU_USED=6""
						) else (
							set ""CPU_USED=8""
						)
						set ""OUTFILE=!OUTFILE!_AV1_crf!CRF_WERT!.mp4""
						if !CUTS_TOTAL! GTR 0 (
							ffmpeg -y -ss !CUT_START! -i ""%%F"" -t !REMAINING! -c:v libaom-av1 -crf !CRF_WERT! -cpu-used !CPU_USED! -movflags +faststart -c:a aac -b:a 160k ""!OUTFILE!""
						) else (
							:: Nur neu kodieren ohne Schnitt
							ffmpeg -y -i ""%%F"" -c:v libaom-av1 -crf !CRF_WERT! -cpu-used !CPU_USED! -movflags +faststart -c:a aac -b:a 160k ""!OUTFILE!""
						)
					)
				)

				:: Dateizeit zurücksetzen
				powershell -NoLogo -NoProfile -Command ""(Get-Item '!OUTFILE!').LastWriteTimeUtc = [datetime]::ParseExact('!TIMESTAMP!', 'yyyy:MM:dd HH:mm:ss', $null)""
				echo ? Fertig: !OUTFILE! - !REMAINING!s uebrig

				:: NTFS-Zeit via ExifTool in Metadaten schreiben
				exiftool.exe -overwrite_original ^
					""-DateTimeOriginal=!TIMESTAMP!"" ^
					""-CreateDate=!TIMESTAMP!"" ^
					""-ModifyDate=!TIMESTAMP!"" ^
					""-TrackCreateDate=!TIMESTAMP!"" ^
					""-TrackModifyDate=!TIMESTAMP!"" ^
					""-MediaCreateDate=!TIMESTAMP!"" ^
					""-MediaModifyDate=!TIMESTAMP!"" ^
					""-FileCreateDate=!TIMESTAMP!"" ^
					""-FileModifyDate=!TIMESTAMP!"" ^
					""!OUTFILE!""

			) else (
				echo ? Uebersprungen: %%F - nur !REMAINING!s wuerden uebrig bleiben
			)
		) else (
			echo ? Uebersprungen: %%F - !VIDEO_PLUS_3! nicht > !CUTS_TOTAL!
		)
	)
)

echo.
echo Alle Videos wurden verarbeitet.
pause"
x7t9BkCK,LISENSI,Ncek,JSON,Friday 18th of July 2025 08:51:17 AM CDT,"3136313833363137
3335353938313634 2 minggu 18"
LrcmR9Rv,opto_commission,j0h,HTML,Friday 18th of July 2025 08:13:45 AM CDT,"<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv=""content-type"" content=""text/html; charset=UTF-8"">
    <meta charset=""UTF-8"">
    <meta http-equiv=""Content-Language"" content=""en"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1, maximum-scale=1"">
    <meta name=""apple-mobile-web-app-capable"" content=""yes"">
    <meta name=""mobile-web-app-capable"" content=""yes"">
    <meta name=""format-detection"" content=""telephone=no"">

    <title>Create Account</title>
    <link href=""/manage/public/static/images/favicon.ico"" rel=""shortcut icon"">

    <link href=""/auth-static/css/bootstrap.min.css"" rel=""stylesheet"">
    <link href=""/auth-static/css/font-awesome.min.css"" rel=""stylesheet"">
    <link href=""/auth-static/css/keyboard-basic.min.css"" rel=""stylesheet"">
    <link href=""/auth-static/css/EpicKeyboard.min.css"" rel=""stylesheet"">
    <link href=""/login/login.css"" rel=""stylesheet"">
    <link href=""/commissioning/commission.css"" rel=""stylesheet"">

    <script src=""/auth-static/js/jquery-3.2.1.min.js""></script>
    <script src=""/auth-static/js/jquery.keyboard-1.26.26.min.js""></script>
    <script src=""/auth-static/js/EpicKeyboard.js""></script>
    <script>
      var checkCommissionedTimer;

      function getParameterByName(name, url) {
        if (!url) url = window.location.href;
        name = name.replace(/[\[\]]/g, ""\\$&"");
        var regex = new RegExp(""[?&]"" + name + ""(=([^&#]*)|&|#|$)""),
            results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return '';
        return results[2].replace(/\+/g, "" "");
      }

      function showLoginSpinner() {
        $('#submitBtn').html('<i class=""fa fa-sign-in""></i>&nbsp;Creating account&hellip;').attr('disabled', 'disabled');
        $('input').attr('readonly', 'readonly');
      }

      function hideLoginSpinner() {
        $('#submitBtn').html('<i class=""fa fa-sign-in""></i>&nbsp;Create Account').removeAttr('disabled');
        $('input').removeAttr('readonly');
      }

      function isPasswordConfirmed() {
        var n = $('#pwd').val();
        var c = $('#confirmPwd').val();
        return n != """" && n == c;
      }

      function validateInput() {
        showLoginSpinner();
        var validPwd, valid = isValidInputLength('uname');
        $('#uname-container').toggleClass('has-error', !valid);

        validPwd = isValidInputLength('pwd');
        if(!validPwd)
          valid = false;
        $('#pwd-container').toggleClass('has-error', !validPwd);

        validPwd = isPasswordConfirmed();
        if(!validPwd)
          valid = false;
        $('#pwd-confirm-container').toggleClass('has-error', !validPwd);

        $('#warning').toggle(!valid);
        if(!valid)
          hideLoginSpinner();
        else
          clearTimeout(checkCommissionedTimer);

        return valid;
      }

      function checkEnterSubmit(e) {
        if(e.keyCode == 13) {
          document.getElementById('submitBtn').click();
        }
      }

      function isValidInputLength(id) {
        var len = document.getElementById(id).value.length;
        return len >= 1 && len <= 128;
      }

      function checkCommissioned() {
        $.ajax(""/auth/access/user/commission/status"").done(function(isCommissioned) {
          if(isCommissioned == 'true')
            window.location.href = ""/"";
        });
      }
    </script>
  </head>
  <body>
    <div class=""ctr-col"">
      <div class=""jumbotron"">
        <h1>Create an Account</h1>
        <p class=""no-bottom-margin start-prompt"">First, let's create your <em>administrator</em> account. Please set your credentials below.</p>
      </div>
      <div class=""side-pad"">
        <div class=""alert alert-warning"">
          <p>
            <i class=""fa fa-exclamation-triangle fa-lg""></i>&nbsp;
            <strong>Warning:</strong> The account you create here is the first and only <em>Administrator</em>
            account until you add more accounts. Your account password is not recoverable. If you can no
            longer access this device as an <em>Administrator</em> you will be unable to configure the device or
            adjust user accounts. See documentation for more information.
          </p>
        </div>
      </div>
      <div class=""box"">

        <div id=""warning"" class=""alert alert-danger"" style=""display: none"">
            <i class=""fa fa-exclamation-triangle""></i>&nbsp;
            Please fix the errors below and resubmit.
        </div>
        <form id=""form"" action=""/auth/access/user/commission/form"" method=""post"" enctype=""application/x-www-form-urlencoded"" onsubmit=""return validateInput()"">
          <input type=""hidden"" name=""csrf"" value=""wyhYGujph7xj5XiJKQ6QNDfGy2yAt9Xh"">
          <div id=""uname-container"" class=""form-group"">
            <label class=""control-label"" for=""uname"">Username</label>
            <input id=""uname"" name=""uname"" type=""text"" class=""form-control"">
            <div class=""input-err-msg"">Username must be between 1 and 128 characters in length.</div>
          </div>
          <div id=""pwd-container"" class=""form-group"">
            <label class=""control-label"" for=""pwd"">Password</label>
            <input id=""pwd"" name=""pwd"" type=""password"" class=""form-control"">
            <div class=""input-err-msg"">Password must be between 1 and 128 characters in length.</div>
          </div>
          <div id=""pwd-confirm-container"" class=""form-group"">
            <label class=""control-label"" for=""confirmPwd"">Confirm Password</label>
            <input id=""confirmPwd"" name=""confirmPwd"" type=""password"" class=""form-control"" onkeypress=""checkEnterSubmit(event)"">
            <div class=""input-err-msg"">Must match <em>Password</em> above.</div>
          </div>
          <div class=""align-right signin-btns"">
            <button id=""submitBtn"" type=""submit"" class=""btn btn-primary""><i class=""fa fa-sign-in""></i>&nbsp;Create Account</button>
          </div>
        </form>
      </div>
      <div class=""copyright"">
          &copy; Opto&nbsp;22 2017-2022. All rights reserved.<br>
          <em>groov</em> RIO is a registered trademark of Opto&nbsp;22.
      </div>
    </div>

    <script>
      $(document).ready(function() {
        if(getParameterByName(""invalid""))
          $(""#warning"").removeAttr(""style"");

        if(/Groov-(Internal|External)-Browser/.test(navigator.userAgent)) {
          var nameInput = document.getElementById('uname');
          NxtioKeyboard.attachAlphabetKeyboard(nameInput , 'Username');

          var pwdInput = document.getElementById('pwd');
          NxtioKeyboard.attachAlphabetKeyboard(pwdInput , 'Password');

          var confirmPwdInput = document.getElementById('confirmPwd');
          NxtioKeyboard.attachAlphabetKeyboard(confirmPwdInput , 'Confirm Password');
        }
      });

      checkCommissioned();
      checkCommissionedTimer = window.setInterval(checkCommissioned, 3000);
    </script>
  </body>
</html>
"
3ynQBn4T,Untitled,thewitchking,C++,Friday 18th of July 2025 08:09:46 AM CDT,"#include <iostream>
#include <fstream>
#include <string>

// Replaces all standalone occurrences of oldNumber with newNumber in the given file
bool replaceNumberInFile(const std::string& filename, const std::string& oldNumber, const std::string& newNumber) {
    std::ifstream inFile(filename);
    if (!inFile.is_open()) {
        std::cerr << ""Cannot open file for reading: "" << filename << ""\n"";
        return false;
    }

    std::string modifiedContent;
    std::string line;

    while (std::getline(inFile, line)) {
        size_t pos = line.find(oldNumber);
        while (pos != std::string::npos) {
            // Ensure match is a full number (not part of another number)
            bool validStart = (pos == 0 || !isdigit(line[pos - 1]));
            bool validEnd = (pos + oldNumber.size() == line.size() || !isdigit(line[pos + oldNumber.size()]));

            if (validStart && validEnd) {
                line.replace(pos, oldNumber.length(), newNumber);
                pos = line.find(oldNumber, pos + newNumber.length());
            } else {
                pos = line.find(oldNumber, pos + 1);
            }
        }
        modifiedContent += line + ""\n"";
    }

    inFile.close();

    std::ofstream outFile(filename);
    if (!outFile.is_open()) {
        std::cerr << ""Cannot open file for writing: "" << filename << ""\n"";
        return false;
    }

    outFile << modifiedContent;
    outFile.close();

    return true;
}
"
BDp6Y1uz,@/actions/get-user-sessions.action.ts,wzee1,TypeScript,Friday 18th of July 2025 06:51:26 AM CDT,"""use server""

import { cookies } from ""next/headers""

import { WebSessionType, PersonalAccessTokenType } from ""@/types/auth""
import { fetchBackend } from ""@/lib/utils""

/**
 * Fetches the current user's active web sessions and personal access tokens from the backend.
 *
 * @returns {Promise<{ webSessions: WebSessionType[] | null; personalAccessTokens: PersonalAccessTokenType[] | null }>} the web sessions and personal access tokens related to the given user.
 */
export async function getUserSessions(): Promise<{
  webSessions: WebSessionType[] | null
  personalAccessTokens: PersonalAccessTokenType[] | null
}> {
  const cookieList = await cookies()
  const laravelSessionCookie = cookieList.get('laravel_session')?.value
  const xsrfToken = cookieList.get('XSRF-TOKEN')?.value

  if (!laravelSessionCookie) {
    console.warn(""No Laravel session cookie found. Cannot fetch user sessions."")
    return { webSessions: null, personalAccessTokens: null }
  }

  let webSessions: WebSessionType[] | null = null
  let personalAccessTokens: PersonalAccessTokenType[] | null = null

  // Fetch and convert web sessions to camelCase
  /* try {
    const webSessionsRes = await fetchBackend(
      ""/api/user/web-sessions"", ""GET"",
      {}, undefined, xsrfToken
    )

    if (!webSessionsRes || !webSessionsRes.ok) {
      const errorBody = await webSessionsRes?.text()
      console.error(`Failed to fetch web sessions: ${webSessionsRes?.status} ${webSessionsRes?.statusText}`)
      console.error(""Error response body:"", errorBody)
    } else {
      const rawWebSessionsData: any[] = await webSessionsRes.json()

      webSessions = rawWebSessionsData.map(rawSession => ({
        _id: rawSession._id,
        payload: rawSession.payload,
        lastActivity: new Date(rawSession.last_activity * 1000),
        userId: rawSession.user_id,
        ipAddress: rawSession.ip_address,
        userAgent: rawSession.user_agent,
        expiresAt: rawSession.expires_at ? new Date(rawSession.expires_at) : null,
      }))
    }
  } catch (error) {
    console.error(""Error fetching web sessions:"", error)
  }
 */
  // Fetch and convert pats to camelCase
  try {
    const patRes = await fetchBackend(
      ""/api/user/personal-access-tokens"", ""GET"",
      {}, undefined, xsrfToken
    )

    if (!patRes || !patRes.ok) {
      const errorBody = await patRes?.text()
      console.error(`Failed to fetch personal access tokens: ${patRes?.status} ${patRes?.statusText}`)
      console.error(""Error response body:"", errorBody)
    } else {
      const rawPatData: any[] = await patRes.json()

      personalAccessTokens = rawPatData.map(rawToken => ({
        _id: rawToken._id.$oid,
        name: rawToken.name,
        abilities: JSON.parse(rawToken.abilities) as string[],
        expiresAt: rawToken.expires_at ? new Date(rawToken.expires_at) : null,
        updatedAt: new Date(rawToken.updated_at),
        createdAt: new Date(rawToken.created_at),
        lastUsedAt: rawToken.last_used_at ? new Date(rawToken.last_used_at) : null,
        tokenableId: rawToken.tokenable_id.$oid,
        tokenableType: rawToken.tokenable_type
      }))
    }
  } catch (error) {
    console.error(""Error fetching personal access tokens:"", error)
  }

  return { webSessions, personalAccessTokens }
}"
VK4kBG3n,"[site-reviews] replace empty title with assigned ""post name - author name""",geminilabs,PHP,Friday 18th of July 2025 06:41:57 AM CDT,"add_filter('site-reviews/review/value/title', function ($value, $tag) {
    if (!empty($tag->review->title)) {
        return $value;
    }
    $post = $tag->review->assignedPosts()[0] ?? null;
    if (empty($post)) {
        return '';
    }
    $parts = array_filter([
        get_the_title($post),
        get_the_author_meta('display_name', $post->post_author),
    ]);
    return explode(' - ', $parts);
}, 10, 2);
"
22URHvAM,Untitled,messh,C++,Friday 18th of July 2025 06:39:18 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <cmath>
#include <set>
#include <map>
using namespace std;
#define ll long long
#define int long long
const int inf = 1e18;

ll M2 = 1e9 + 9, M1 = 1e9 + 7;
#define ld long double
const int E = 70;
//mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

const int MOD = 1e9 + 7;
const int N = 8e6 + 5;

void solve() {

    string s;
    cin >> s;
    int n = (int)s.size();
    int k;
    cin >> k;
    vector<bool> prime(N, false);
    prime[0] = true;
    prime[1] = true;
    for (int i = 2; i * i < N; ++i) {
        if (!prime[i]) {
            for (int j = 2 * i; j < N; j += i) {
                prime[j] = true;
            }
        }
    }
    vector<vector<int>> dp(n, vector<int> (k));
    vector<int> pref(n);
    for (int i = 0; i < n; ++i) {
        string cur = """";
        int cnt = 0;
        for (int j = i; j >= max(0LL, i - k + 1); --j, cnt++) {
            cur += s[j];
            string now = cur;
            reverse(now.begin(), now.end());
            if (now[0] == '0') continue;
            //cout << now << ' ';
            int a = stoll(now);
            if (prime[a]) continue;
            if (j - 1 >= 0) {
                dp[i][cnt] += pref[j - 1];
                dp[i][cnt] %= MOD;
            } else {
                dp[i][cnt] = 1;
            }
        }
        pref[i] = dp[i][0];
        for (int v = 1; v < k; ++v) {
            pref[i] += dp[i][v];
            pref[i] %= MOD;
        }
    }
    int res = 0;
    for (int i = 0; i < k; ++i) {
        res += dp[n - 1][i];
        res %= MOD;
    }
    cout << res;

}





signed main() {


    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    ll thrush = 1;
    //cin >> thrush;
    while (thrush--) { solve();}
}
"
AmGfu06d,Untitled,messh,C++,Friday 18th of July 2025 06:38:50 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <cmath>
#include <set>
#include <map>
using namespace std;
#define ll long long
#define int long long
const int inf = 1e18;

ll M2 = 1e9 + 9, M1 = 1e9 + 7;
#define ld long double
const int E = 70;
//mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

const int MOD = 1e9 + 7;
const int N = 8e6 + 5;

void solve() {
    int q;
    cin >> q;
    vector<set<string>> st(200);
    while (q--) {
        int n;
        cin >> n;
        vector<string> cur;
        for (int _ = 0; _ < n; ++_) {
            string s;
            cin >> s;
            if (st[s[0]].find(s) != st[s[0]].end()) {
                st[s[0]].erase(s);
            }
            cur.push_back(s);
        }
       // cout << toupper(cur.back().back()) << ' ' << (int)st[toupper(cur.back().back())].size() << '\n';
        if (!st[toupper(cur.back().back())].empty()) {
            cout << *st[toupper(cur.back().back())].begin() << '\n';
        } else {
            cout << ""unknown\n"";
        }
        for (auto &x : cur) st[x[0]].insert(x);

    }
}





signed main() {


    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    ll thrush = 1;
    //cin >> thrush;
    while (thrush--) { solve();}
}
"
TPzRPUr3,Untitled,messh,C++,Friday 18th of July 2025 06:38:25 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <cmath>
#include <set>
#include <map>
using namespace std;
#define ll long long
#define int long long
const int inf = 1e18;

ll M2 = 1e9 + 9, M1 = 1e9 + 7;
#define ld long double
const int E = 70;
//mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

const int MOD = 1e9 + 7;
const int N = 8e6 + 5;

void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (auto &x : a)
        cin >> x;
    int l = 0, r = 1e5 + 5;
    while (r - l > 1) {
        int mid = (r + l) / 2;
        bool flag = true;
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            if (cnt >= k) {
                //cout << mid << '\n';
                flag = false;
                break;
            }
            if (a[i] >= mid) {
                cnt = 0;
            } else {
                cnt++;
            }

        }
        if (flag) {
            l = mid;
        } else {
            r  = mid;
        }
    }
    cout << (l == 1e5 + 4 ? 1e5 : l) << '\n';
}





signed main() {


    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    ll thrush = 1;
    //cin >> thrush;
    while (thrush--) { solve();}
}
"
jdvA2aZX,Untitled,messh,C++,Friday 18th of July 2025 06:38:06 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <cmath>
#include <set>
#include <map>
using namespace std;
#define ll long long
#define int long long
const int inf = 1e18;

ll M2 = 1e9 + 9, M1 = 1e9 + 7;
#define ld long double
const int E = 70;
//mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());



void solve() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n), b(n);
    for (auto &x : a) {
        cin >> x;
    }
    for (auto &x : b) {
        cin >> x;
    }
    int l = 0, r = 1e15;
    while (r - l > 1) {
        __int128 mid = (r + l) / 2;
        __int128 sum = 0;
        for (int i = 0; i < n; ++i) {
            __int128 cur = (__int128)mid * (__int128)a[i];
            cur -= (__int128)b[i];
            if (cur > 0) {

                sum += cur;
            }
        }
        if (sum <= k) {
            l = mid;
        } else {
            r = mid;
        }
    }
    cout << l << '\n';
}





signed main() {


    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    ll thrush = 1;
    //cin >> thrush;
    while (thrush--) { solve();}
}
"
wBm2W7E1,Untitled,messh,C++,Friday 18th of July 2025 06:37:10 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <cmath>
#include <set>
#include <map>
using namespace std;
#define ll long long
#define int long long
const int inf = 1e18;

ll M2 = 1e9 + 9, M1 = 1e9 + 7;
#define ld long double
const int E = 70;
//mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

const int MOD = 1e9 + 7;
const int N = 8e6 + 5;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n);
    int res = 1;
    map<int, int> maps;
    for (auto &x : a) {
        cin >> x;
        maps[x]++;
        while (maps[res]) res++;
        cout << res << ' ';
    }

}





signed main() {


    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    ll thrush = 1;
    //cin >> thrush;
    while (thrush--) { solve();}
}"
yrWwTrYz,2025-07-18T07:07:04.940045,powerampache,PHP,Friday 18th of July 2025 06:07:03 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 50294) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

scrobble() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 50294) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 50294) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
Nh2ZunqU,dataNone,TestGuy1,JSON,Friday 18th of July 2025 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'cc0e710cb8b5be71eff5d54649f4b5bd34d2db4a22afd97a182454357b0a88faf4329d854124f683e5d6f84e901322df7032b758695ae98e2d3721db840a53d217d997991ede137bb44f046e4aae86b8e29a1a5eae6446f992d2582b059da7264824df213e1b318d52d8273b5904305409e4465515fa8fe2a13744fe1ef1d2a8',
  otherdata: [
    '229f7d9b65aed1c50bcacd6e6288027c',
    '8b604f2374aec7d4b1d1c4de0f7aa3cb',
    'a1bd7d1717505951354fbf7245ffd9b9',
    '9ea249a7de62befefe87034358c3d684',
    'db39e28b031624efc4f04e465c93072b',
    '6d3aeacf076daa48af66789c85d3732b',
    'c7bf44ec04a57eed0f4e9e284cc9c202',
    '83d3250a33829e1a5a5f4f52e2ccb3f9'
  ]
}"
3jX9hFqu,FIles,cycycycy,Lua,Friday 18th of July 2025 05:17:55 AM CDT,"Version 1 11
{
	IsStream False
	DescriptorsInOrder False
	Entries
	{
		WaveTrack 0x000E3CFA
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x000E3CFA.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DIRT_SKID_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DIRT_SKID_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0046B51D
		{
			Compression PCM
			Headroom -106
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0046B51D.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_4_B
		{
			Compression PCM
			Headroom -59
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_4_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x004F9AB2
		{
			Compression PCM
			Headroom -181
			LoopPoint 22549
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x004F9AB2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x005467D3
		{
			Compression PCM
			Headroom -150
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x005467D3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x007D4325
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x007D4325.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_ALARM_1
		{
			Compression PCM
			Headroom -199
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_ALARM_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x009284E3
		{
			Compression PCM
			Headroom 406
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x009284E3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SALOON_OLD_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SALOON_OLD_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x00B756EC
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x00B756EC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SQUEAK_01
		{
			Compression PCM
			Headroom -197
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SQUEAK_01.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x00E78992
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x00E78992.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PNEUMATIC_SUSPENSION_UP_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PNEUMATIC_SUSPENSION_UP_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x00F2840F
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x00F2840F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x00FE8F95
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x00FE8F95.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0103B3B2
		{
			Compression PCM
			Headroom -161
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0103B3B2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x01154500
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x01154500.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0122EB9A
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0122EB9A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x013084B8
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x013084B8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_QUICK_03
		{
			Compression PCM
			Headroom -200
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_QUICK_03.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x015223EC
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x015223EC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TRUCK_IGNITION_TAIL
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TRUCK_IGNITION_TAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0161B545
		{
			Compression PCM
			Headroom 728
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0161B545.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x01811DDC
		{
			Compression PCM
			Headroom 770
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x01811DDC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BRAKE_SQUEAK_3
		{
			Compression PCM
			Headroom 585
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BRAKE_SQUEAK_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack START_4_TAIL
		{
			Compression PCM
			Headroom 28
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\START_4_TAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x019AA399
		{
			Compression PCM
			Headroom -150
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x019AA399.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MUSCLE_CAR_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MUSCLE_CAR_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x01AD840B
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x01AD840B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x01B0820C
		{
			Compression PCM
			Headroom -150
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x01B0820C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_7_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_7_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x01E5AEDB
		{
			Compression PCM
			Headroom -116
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x01E5AEDB.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x01EC9A0B
		{
			Compression PCM
			Headroom -63
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x01EC9A0B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x01FD6116
		{
			Compression PCM
			Headroom 673
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x01FD6116.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGE_ONESHOT_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGE_ONESHOT_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SET_CAR_ALARM
		{
			Compression PCM
			Headroom -82
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SET_CAR_ALARM.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LUXURY_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LUXURY_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack OLD_SALOON_TRUNK_OPEN
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\OLD_SALOON_TRUNK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x026FCA26
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x026FCA26.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BLOWOUT_WHEEL_RIM_A
		{
			Compression PCM
			Headroom -171
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BLOWOUT_WHEEL_RIM_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x02A05D75
		{
			Compression PCM
			Headroom 647
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x02A05D75.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x02ACD6DD
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x02ACD6DD.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BREAKDOWN_5
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BREAKDOWN_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack RATTLE_AND_SQUEAK_A
		{
			Compression PCM
			Headroom 102
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\RATTLE_AND_SQUEAK_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack START_2_TAIL
		{
			Compression PCM
			Headroom 25
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\START_2_TAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PROP_PLANE_DOOR_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PROP_PLANE_DOOR_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_5
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_7
		{
			Compression PCM
			Headroom 1947
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x02E2FECA
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x02E2FECA.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x02F502C8
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x02F502C8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x02F66C77
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x02F66C77.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack FLAT_TYRE_LOOP_B
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\FLAT_TYRE_LOOP_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_3_B
		{
			Compression PCM
			Headroom -22
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_3_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HEAVY_GRIND_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HEAVY_GRIND_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0341DA78
		{
			Compression PCM
			Headroom 99
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0341DA78.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x03506D62
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x03506D62.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0365BFE3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0365BFE3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0379B92B
		{
			Compression PCM
			Headroom 719
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0379B92B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LARGE_TRUCK_HORN
		{
			Compression PCM
			Headroom -191
			LoopPoint 5722
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LARGE_TRUCK_HORN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack START_4
		{
			Compression PCM
			Headroom -191
			LoopPoint 3594
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\START_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTERNAL_GEAR_CHANGE_1
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTERNAL_GEAR_CHANGE_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack COPTER_DOOR_CLOSE
		{
			Compression PCM
			Headroom -187
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\COPTER_DOOR_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SMALL_CAR_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SMALL_CAR_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_6
		{
			Compression PCM
			Headroom -191
			LoopPoint 4777
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x03CB7E9A
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x03CB7E9A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x03D0F8B2
		{
			Compression PCM
			Headroom -49
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x03D0F8B2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x03D6094F
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x03D6094F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WET_ROAD_LOOP_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WET_ROAD_LOOP_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MUSCLE_CAR_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MUSCLE_CAR_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0419D41E
		{
			Compression PCM
			Headroom 11
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0419D41E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_10
		{
			Compression PCM
			Headroom 1600
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_10.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x044FC4B2
		{
			Compression PCM
			Headroom 728
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x044FC4B2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x045E13D6
		{
			Compression PCM
			Headroom -191
			LoopPoint 3283
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x045E13D6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x045F4388
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x045F4388.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0469298F
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0469298F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack VAN_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\VAN_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x047D6335
		{
			Compression PCM
			Headroom -82
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x047D6335.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERNAL_GEAR_CHANGE_2
		{
			Compression PCM
			Headroom 800
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERNAL_GEAR_CHANGE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x049F551F
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x049F551F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x04B28C3B
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x04B28C3B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CHOPPER_IGNITION_TAIL
		{
			Compression PCM
			Headroom 599
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CHOPPER_IGNITION_TAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x04C4D021
		{
			Compression PCM
			Headroom -163
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x04C4D021.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack REGULAR_CLOSE_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\REGULAR_CLOSE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x04D74C84
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x04D74C84.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXHAUST_RATTLE_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXHAUST_RATTLE_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack START_3_TAIL
		{
			Compression PCM
			Headroom 21
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\START_3_TAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BUS_DOOR_OPEN
		{
			Compression PCM
			Headroom 44
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BUS_DOOR_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack GEAR_GRIND_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\GEAR_GRIND_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SALOON_OLD_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SALOON_OLD_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUBWAY_DOORS_OPEN
		{
			Compression PCM
			Headroom 134
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUBWAY_DOORS_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BRAKE_SQUEAK_1
		{
			Compression PCM
			Headroom 586
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BRAKE_SQUEAK_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_3
		{
			Compression PCM
			Headroom 1600
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0538BA9B
		{
			Compression PCM
			Headroom 782
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0538BA9B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HEAT_TICK_2
		{
			Compression PCM
			Headroom 1089
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HEAT_TICK_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SALOON_NEW_CLOSE_2
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SALOON_NEW_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PNEUMATIC_SUSPENSION_UP_3
		{
			Compression PCM
			Headroom 255
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PNEUMATIC_SUSPENSION_UP_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x056E03E2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x056E03E2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x057E09B6
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x057E09B6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGE_ONESHOT_4
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGE_ONESHOT_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x05A1E698
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x05A1E698.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x05AE9679
		{
			Compression PCM
			Headroom -101
			LoopPoint 960
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x05AE9679.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUSPENSION_DOWN_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUSPENSION_DOWN_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack RACEBIKE_1000CC_IGNITION
		{
			Compression PCM
			Headroom 599
			LoopPoint 5792
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\RACEBIKE_1000CC_IGNITION.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack AMBULANCE_WARNING
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\AMBULANCE_WARNING.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LOW_REVS_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LOW_REVS_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x05E8A8ED
		{
			Compression PCM
			Headroom 584
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x05E8A8ED.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x05F8A222
		{
			Compression PCM
			Headroom 48
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x05F8A222.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HEAT_TICK_5
		{
			Compression PCM
			Headroom 799
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HEAT_TICK_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXHAUST_DRAG_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXHAUST_DRAG_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_2_A
		{
			Compression PCM
			Headroom -101
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_2_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x06274BD8
		{
			Compression PCM
			Headroom -190
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x06274BD8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_9
		{
			Compression PCM
			Headroom 2192
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_9.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0657AEE7
		{
			Compression PCM
			Headroom -150
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0657AEE7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x065CA799
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x065CA799.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0664361E
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0664361E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x066D4858
		{
			Compression PCM
			Headroom -178
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x066D4858.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WHEEL_GRIND_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WHEEL_GRIND_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x06A92984
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x06A92984.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x06C58F39
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x06C58F39.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MUSCLE_TRUNK_OPEN
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MUSCLE_TRUNK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack GEAR_GRIND_5
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\GEAR_GRIND_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SHUT_DOWN_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SHUT_DOWN_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x06F26549
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x06F26549.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x06F54E9A
		{
			Compression PCM
			Headroom -150
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x06F54E9A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack START_2
		{
			Compression PCM
			Headroom 334
			LoopPoint 5612
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\START_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BLOWOUT_COMPOSITE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BLOWOUT_COMPOSITE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_7_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_7_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0719BD22
		{
			Compression PCM
			Headroom -199
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0719BD22.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0727730C
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0727730C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TYRE_BUMP_1
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TYRE_BUMP_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x073CE3F4
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x073CE3F4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x075B9C4C
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x075B9C4C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SPORTS_HANDBRAKE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SPORTS_HANDBRAKE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TRUCK_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TRUCK_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x076DD14C
		{
			Compression PCM
			Headroom -171
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x076DD14C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MAIN_TARMAC_SKID_A
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MAIN_TARMAC_SKID_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack NEW_SALOON_TRUNK_CLOSE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\NEW_SALOON_TRUNK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EURO_B
		{
			Compression PCM
			Headroom 656
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EURO_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BRAKE_RELEASE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BRAKE_RELEASE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TRUCK_HANDBRAKE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TRUCK_HANDBRAKE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x078DC3C5
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x078DC3C5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TUG_HORN
		{
			Compression PCM
			Headroom -191
			LoopPoint 11747
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TUG_HORN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x079F3607
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x079F3607.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x07A72A2A
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x07A72A2A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x07BB15EC
		{
			Compression PCM
			Headroom 360
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x07BB15EC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack RACEBIKE_1000CC_IGNITION_TAIL
		{
			Compression PCM
			Headroom 1024
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\RACEBIKE_1000CC_IGNITION_TAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack GEAR_CHANGE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\GEAR_CHANGE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGE_ONESHOT_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGE_ONESHOT_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x07CBF623
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x07CBF623.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TRUCK_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TRUCK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x07D63D79
		{
			Compression PCM
			Headroom -143
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x07D63D79.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_12
		{
			Compression PCM
			Headroom 1815
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_12.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERNAL_GEAR_CHANGE_4
		{
			Compression PCM
			Headroom 576
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERNAL_GEAR_CHANGE_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0800B6C4
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0800B6C4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0810B162
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0810B162.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0826DC36
		{
			Compression PCM
			Headroom 4
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0826DC36.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x08320F46
		{
			Compression PCM
			Headroom 107
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x08320F46.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SPORTS_LUX_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SPORTS_LUX_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x084974BF
		{
			Compression PCM
			Headroom -116
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x084974BF.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x085B0209
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x085B0209.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SPORTS_LUX_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SPORTS_LUX_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HORN_01
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HORN_01.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x08AAC044
		{
			Compression PCM
			Headroom -199
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x08AAC044.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DOOR_OPEN
		{
			Compression PCM
			Headroom 950
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DOOR_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x08C0C4C9
		{
			Compression PCM
			Headroom 537
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x08C0C4C9.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x08E1DBAC
		{
			Compression PCM
			Headroom -49
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x08E1DBAC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SQUEAK_04
		{
			Compression PCM
			Headroom -184
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SQUEAK_04.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUV_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUV_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_LIGHT_5
		{
			Compression PCM
			Headroom -191
			LoopPoint 1834
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_LIGHT_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x09136CFF
		{
			Compression PCM
			Headroom -126
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x09136CFF.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0924D8B9
		{
			Compression PCM
			Headroom -153
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0924D8B9.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGE_LOOP_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGE_LOOP_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x094E32A1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x094E32A1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0950F2A7
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0950F2A7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INDICATOR_OLD_CAR_OFF
		{
			Compression PCM
			Headroom 699
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INDICATOR_OLD_CAR_OFF.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PICKUP_CLOSE_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PICKUP_CLOSE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0961D92F
		{
			Compression PCM
			Headroom -53
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0961D92F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BACK_FIRE_POP_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BACK_FIRE_POP_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PNEUMATIC_SUSPENSION_DOWN_2
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PNEUMATIC_SUSPENSION_DOWN_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUBWAY_DOORS_CLOSE
		{
			Compression PCM
			Headroom 26
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUBWAY_DOORS_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x09A7F40D
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x09A7F40D.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x09A95A92
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x09A95A92.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x09A9FC34
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x09A9FC34.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x09BB9056
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x09BB9056.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x09BD3DC0
		{
			Compression PCM
			Headroom -129
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x09BD3DC0.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_2
		{
			Compression PCM
			Headroom -201
			LoopPoint 4270
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INDICATOR_VAN_OFF
		{
			Compression PCM
			Headroom 699
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INDICATOR_VAN_OFF.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x09C64CB4
		{
			Compression PCM
			Headroom -114
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x09C64CB4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_9
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_9.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack REGULAR_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\REGULAR_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUSPENSION_DOWN_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUSPENSION_DOWN_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_5
		{
			Compression PCM
			Headroom 1625
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0A210D41
		{
			Compression PCM
			Headroom -49
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0A210D41.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack GEAR_GRIND_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\GEAR_GRIND_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DETAILED_TYRE_CLOSE
		{
			Compression PCM
			Headroom 99
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DETAILED_TYRE_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0A45CC31
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0A45CC31.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_QUICK_02
		{
			Compression PCM
			Headroom -200
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_QUICK_02.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0A4A576B
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0A4A576B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SMALL_CAR_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SMALL_CAR_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0A604B93
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0A604B93.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack POLICE_WARNING
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\POLICE_WARNING.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_8
		{
			Compression PCM
			Headroom -191
			LoopPoint 1358
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PICKUP_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PICKUP_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_WAIL_02
		{
			Compression PCM
			Headroom -200
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_WAIL_02.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PICKUP_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PICKUP_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SPORTS_TRUNK_OPEN
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SPORTS_TRUNK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0AC37C55
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0AC37C55.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack VAN_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\VAN_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WAGON_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WAGON_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUSPENSION_DOWN
		{
			Compression PCM
			Headroom -200
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUSPENSION_DOWN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0AEFB265
		{
			Compression PCM
			Headroom 21
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0AEFB265.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_2
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0AFD98E3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0AFD98E3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0B309DDC
		{
			Compression PCM
			Headroom 765
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0B309DDC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0B3B314F
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0B3B314F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MUSCLE_CAR_CLOSE_3
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MUSCLE_CAR_CLOSE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack REVERSE_WARNING
		{
			Compression PCM
			Headroom -1
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\REVERSE_WARNING.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0B65A1E4
		{
			Compression PCM
			Headroom -191
			LoopPoint 3169
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0B65A1E4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_ALARM_4
		{
			Compression PCM
			Headroom -192
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_ALARM_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack COP_CAR_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\COP_CAR_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INDICATOR_TRUCK_ON
		{
			Compression PCM
			Headroom 699
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INDICATOR_TRUCK_ON.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0BBD113D
		{
			Compression PCM
			Headroom 647
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0BBD113D.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0BC278C5
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0BC278C5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BUS_DOOR_CLOSE
		{
			Compression PCM
			Headroom -11
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BUS_DOOR_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack RIG_BRAKE_DISC_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\RIG_BRAKE_DISC_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WAGON_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WAGON_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0BDA2D2F
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0BDA2D2F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0C120263
		{
			Compression PCM
			Headroom 613
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0C120263.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack START_3
		{
			Compression PCM
			Headroom -191
			LoopPoint 3486
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\START_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack START_1_TAIL
		{
			Compression PCM
			Headroom 195
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\START_1_TAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_DOOR_LOCK
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_DOOR_LOCK.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BREAKDOWN_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BREAKDOWN_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERNAL_GEAR_CHANGE_1
		{
			Compression PCM
			Headroom 800
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERNAL_GEAR_CHANGE_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack OLD_SALOON_TRUNK_CLOSE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\OLD_SALOON_TRUNK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0CD9EE7E
		{
			Compression PCM
			Headroom -200
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0CD9EE7E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUBWAY_DOOR_TONE
		{
			Compression PCM
			Headroom 1400
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUBWAY_DOOR_TONE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TYRE_BUMP_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TYRE_BUMP_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack FLAT_TYRE_LOOP_A
		{
			Compression PCM
			Headroom -158
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\FLAT_TYRE_LOOP_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_PA20A_WAIL
		{
			Compression PCM
			Headroom -82
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_PA20A_WAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUV_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUV_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MOPED_600_CC_IGNITION
		{
			Compression PCM
			Headroom 599
			LoopPoint 1393
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MOPED_600_CC_IGNITION.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0D3B6FE9
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0D3B6FE9.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack RIG_BRAKE_DISC_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\RIG_BRAKE_DISC_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SMALL_TRUCK_HORN
		{
			Compression PCM
			Headroom -201
			LoopPoint 6408
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SMALL_TRUCK_HORN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0D6EEB77
		{
			Compression PCM
			Headroom 770
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0D6EEB77.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INDICATOR_VAN_ON
		{
			Compression PCM
			Headroom 699
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INDICATOR_VAN_ON.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0D8A6EE8
		{
			Compression PCM
			Headroom 7
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0D8A6EE8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0D8B613F
		{
			Compression PCM
			Headroom 445
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0D8B613F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack COP_CAR_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\COP_CAR_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0D9C1E0D
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0D9C1E0D.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0DBF774F
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0DBF774F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EX_POP_7
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EX_POP_7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HONDA_LAMP_START
		{
			Compression PCM
			Headroom -63
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HONDA_LAMP_START.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BRAKE_DISC_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BRAKE_DISC_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_WAIL_04
		{
			Compression PCM
			Headroom -110
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_WAIL_04.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SQUEAK_02
		{
			Compression PCM
			Headroom -189
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SQUEAK_02.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0E329232
		{
			Compression PCM
			Headroom 1615
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0E329232.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0E37594D
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0E37594D.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SPORTS_LUX_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SPORTS_LUX_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0E781180
		{
			Compression PCM
			Headroom -60
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0E781180.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack AIRHORN_EQD
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\AIRHORN_EQD.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_ALARM_2
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_ALARM_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BRAKE_SQUEAK_2
		{
			Compression PCM
			Headroom 520
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BRAKE_SQUEAK_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HEAT_TICK_1
		{
			Compression PCM
			Headroom 797
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HEAT_TICK_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack RIG_HAND_BRAKE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\RIG_HAND_BRAKE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGE_ONESHOT_5
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGE_ONESHOT_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0F0D34F9
		{
			Compression PCM
			Headroom -116
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0F0D34F9.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0F232D84
		{
			Compression PCM
			Headroom 612
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0F232D84.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERNAL_GEAR_CHANGE_6
		{
			Compression PCM
			Headroom 994
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERNAL_GEAR_CHANGE_6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HONDA_LAMP_END
		{
			Compression PCM
			Headroom 602
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HONDA_LAMP_END.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LUX_SUV_TRUNK_CLOSE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LUX_SUV_TRUNK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_10
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_10.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TRUCK_IGNITION_1
		{
			Compression PCM
			Headroom -191
			LoopPoint 10964
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TRUCK_IGNITION_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0F863D6E
		{
			Compression PCM
			Headroom -191
			LoopPoint 17542
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0F863D6E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_4_A
		{
			Compression PCM
			Headroom 127
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_4_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0FAFA654
		{
			Compression PCM
			Headroom 537
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0FAFA654.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0FB15867
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0FB15867.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0FC6EAA8
		{
			Compression PCM
			Headroom -191
			LoopPoint 1207
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0FC6EAA8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0FC9F604
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0FC9F604.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0FCAA61C
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0FCAA61C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0FDC975C
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0FDC975C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTERNAL_GEAR_CHANGE_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTERNAL_GEAR_CHANGE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x0FEEE07E
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x0FEEE07E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WHEEL_GRIND_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WHEEL_GRIND_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SALOON_NEW_CLOSE_3
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SALOON_NEW_CLOSE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x10177BA5
		{
			Compression PCM
			Headroom -130
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x10177BA5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_6
		{
			Compression PCM
			Headroom 1680
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x101FBFDD
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x101FBFDD.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HEAT_TICK_6
		{
			Compression PCM
			Headroom 799
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HEAT_TICK_6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LUXURY_CLOSE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LUXURY_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERNAL_CABIN_TONE
		{
			Compression PCM
			Headroom 799
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERNAL_CABIN_TONE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_6
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BREAKDOWN_4
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BREAKDOWN_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x10A3ECC5
		{
			Compression PCM
			Headroom 554
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x10A3ECC5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x10A73D85
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x10A73D85.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_5_A
		{
			Compression PCM
			Headroom -101
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_5_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x10CBDFF0
		{
			Compression PCM
			Headroom 515
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x10CBDFF0.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUSPENSION_UP_2
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUSPENSION_UP_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x10D27C84
		{
			Compression PCM
			Headroom -158
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x10D27C84.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HEAVY_GRIND_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HEAVY_GRIND_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x10E16CDB
		{
			Compression PCM
			Headroom -191
			LoopPoint 1410
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x10E16CDB.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x10E65401
		{
			Compression PCM
			Headroom 891
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x10E65401.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x110253F2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x110253F2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack RATTLE_AND_SQUEAK_B
		{
			Compression PCM
			Headroom -80
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\RATTLE_AND_SQUEAK_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack NEW_SALOON_TRUNK_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\NEW_SALOON_TRUNK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x112B08E2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x112B08E2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x112D492A
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x112D492A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SPORTS_TRUNK_CLOSE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SPORTS_TRUNK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_3_A
		{
			Compression PCM
			Headroom 196
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_3_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x118058CD
		{
			Compression PCM
			Headroom 1094
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x118058CD.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SALOON_NEW_CLOSE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SALOON_NEW_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x118A5554
		{
			Compression PCM
			Headroom 655
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x118A5554.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1195C9ED
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1195C9ED.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack GEAR_GRIND_6
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\GEAR_GRIND_6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack START_1
		{
			Compression PCM
			Headroom -156
			LoopPoint 4144
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\START_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_1
		{
			Compression PCM
			Headroom 1600
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_3
		{
			Compression PCM
			Headroom -191
			LoopPoint 4674
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SMALL_TRUNK_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SMALL_TRUNK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x120F7915
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x120F7915.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack KICK_START
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\KICK_START.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12124900
		{
			Compression PCM
			Headroom 129
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12124900.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12127E37
		{
			Compression PCM
			Headroom -201
			LoopPoint 5783
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12127E37.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x121B2660
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x121B2660.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack VAN_TRUNK_CLOSE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\VAN_TRUNK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SMALL_TRUNK_CLOSE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SMALL_TRUNK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x122D2144
		{
			Compression PCM
			Headroom 537
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x122D2144.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12350470
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12350470.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGED_HOOD_SHUT
		{
			Compression PCM
			Headroom 9
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGED_HOOD_SHUT.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x123F2D66
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x123F2D66.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x124FE711
		{
			Compression PCM
			Headroom 155
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x124FE711.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CHOPPER_IGNITION
		{
			Compression PCM
			Headroom 599
			LoopPoint 4562
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CHOPPER_IGNITION.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12799DD1
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12799DD1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack FART
		{
			Compression PCM
			Headroom -128
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\FART.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12906B79
		{
			Compression PCM
			Headroom 728
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12906B79.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXHAUST_RATTLE_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXHAUST_RATTLE_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x129CB11D
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x129CB11D.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DUMP_VALVE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DUMP_VALVE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x129F8BD0
		{
			Compression PCM
			Headroom 107
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x129F8BD0.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EX_POP_5
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EX_POP_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12C3AB66
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12C3AB66.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12C3D106
		{
			Compression PCM
			Headroom 360
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12C3D106.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INDICATOR_OLD_CAR_ON
		{
			Compression PCM
			Headroom 1127
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INDICATOR_OLD_CAR_ON.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12EA68AA
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12EA68AA.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x12F67D53
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x12F67D53.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_COOLING_FAN
		{
			Compression PCM
			Headroom 546
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_COOLING_FAN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x130D49A6
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x130D49A6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PNEUMATIC_SUSPENSION_UP_2
		{
			Compression PCM
			Headroom -53
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PNEUMATIC_SUSPENSION_UP_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1322784A
		{
			Compression PCM
			Headroom -150
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1322784A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_4
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack POP
		{
			Compression PCM
			Headroom -157
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\POP.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SALOON_OLD_CLOSE_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SALOON_OLD_CLOSE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGE_ONESHOT_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGE_ONESHOT_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x13573C2C
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x13573C2C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x13825EA7
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x13825EA7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HEAT_TICK_3
		{
			Compression PCM
			Headroom 799
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HEAT_TICK_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LOW_REVS_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LOW_REVS_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUSPENSION_DOWN_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUSPENSION_DOWN_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x13A772C9
		{
			Compression PCM
			Headroom 615
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x13A772C9.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x13B7E9CA
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x13B7E9CA.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x13DDD782
		{
			Compression PCM
			Headroom 194
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x13DDD782.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TRUCK_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TRUCK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_8
		{
			Compression PCM
			Headroom 1647
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x14140CD7
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x14140CD7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1424464B
		{
			Compression PCM
			Headroom 194
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1424464B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x14430366
		{
			Compression PCM
			Headroom -114
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x14430366.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_QUICK_01
		{
			Compression PCM
			Headroom -200
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_QUICK_01.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x145EFEEE
		{
			Compression PCM
			Headroom -99
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x145EFEEE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SMALL_CAR_CLOSE_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SMALL_CAR_CLOSE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_2
		{
			Compression PCM
			Headroom 2124
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1472E5C3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1472E5C3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x14744B53
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x14744B53.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1478E9A0
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1478E9A0.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x147BA8DE
		{
			Compression PCM
			Headroom 647
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x147BA8DE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x147C3C99
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x147C3C99.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGED_HOOD_OPEN
		{
			Compression PCM
			Headroom 1351
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGED_HOOD_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STANDARD_HANDBRAKE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STANDARD_HANDBRAKE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x14A724EE
		{
			Compression PCM
			Headroom 699
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x14A724EE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack FIRE_TRUCK_HORN
		{
			Compression PCM
			Headroom -191
			LoopPoint 5116
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\FIRE_TRUCK_HORN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x14C63FCC
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x14C63FCC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x14CFB391
		{
			Compression PCM
			Headroom 107
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x14CFB391.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EX_POP_8
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EX_POP_8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack GEAR_GRIND_4
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\GEAR_GRIND_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1525E11F
		{
			Compression PCM
			Headroom -12
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1525E11F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x152EC1C2
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x152EC1C2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x153C75D4
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x153C75D4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_ALARM_3
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_ALARM_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x154FF134
		{
			Compression PCM
			Headroom -95
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x154FF134.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1555B462
		{
			Compression PCM
			Headroom 194
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1555B462.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack COP_CAR_CLOSE_2
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\COP_CAR_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x15687EC5
		{
			Compression PCM
			Headroom 99
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x15687EC5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x15694045
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x15694045.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x156EBEAD
		{
			Compression PCM
			Headroom -120
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x156EBEAD.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1577B169
		{
			Compression PCM
			Headroom -9
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1577B169.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_FIRETRUCK_WAIL_01
		{
			Compression PCM
			Headroom -200
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_FIRETRUCK_WAIL_01.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x15BD9244
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x15BD9244.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EURO_A
		{
			Compression PCM
			Headroom 225
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EURO_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x160286E1
		{
			Compression PCM
			Headroom 91
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x160286E1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_FIRETRUCK_QUICK_01
		{
			Compression PCM
			Headroom -200
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_FIRETRUCK_QUICK_01.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x161CA53F
		{
			Compression PCM
			Headroom 463
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x161CA53F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x161DE705
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x161DE705.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WAGON_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WAGON_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WET_ROAD_LOOP_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WET_ROAD_LOOP_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack VAN_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\VAN_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x16B8CD77
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x16B8CD77.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x16B8EF9B
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x16B8EF9B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x16CED63B
		{
			Compression PCM
			Headroom 172
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x16CED63B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERNAL_GEAR_CHANGE_3
		{
			Compression PCM
			Headroom 576
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERNAL_GEAR_CHANGE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x16DE2752
		{
			Compression PCM
			Headroom -193
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x16DE2752.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WET_SKID_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WET_SKID_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_QUICK_04
		{
			Compression PCM
			Headroom -169
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_QUICK_04.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTERNAL_GEAR_CHANGE_4
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTERNAL_GEAR_CHANGE_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_3
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1748BBD5
		{
			Compression PCM
			Headroom 13
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1748BBD5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SALOON_OLD_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SALOON_OLD_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack COP_CAR_CLOSE_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\COP_CAR_CLOSE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_1
		{
			Compression PCM
			Headroom -191
			LoopPoint 4778
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x17864076
		{
			Compression PCM
			Headroom 383
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x17864076.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x178F054F
		{
			Compression PCM
			Headroom 41
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x178F054F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x17B7A889
		{
			Compression PCM
			Headroom 546
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x17B7A889.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x17B9CC88
		{
			Compression PCM
			Headroom 519
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x17B9CC88.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LUXURY_CLOSE_3
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LUXURY_CLOSE_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack HEAT_TICK_4
		{
			Compression PCM
			Headroom 1104
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\HEAT_TICK_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PICKUP_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PICKUP_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x17D8FACD
		{
			Compression PCM
			Headroom -191
			LoopPoint 4048
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x17D8FACD.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack V_ENGINE_HANDBRAKE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\V_ENGINE_HANDBRAKE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_WAIL_03
		{
			Compression PCM
			Headroom -200
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_WAIL_03.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x17E9AF5D
		{
			Compression PCM
			Headroom -190
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x17E9AF5D.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIDE_TARMAC_SKID_A
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIDE_TARMAC_SKID_A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1809C17F
		{
			Compression PCM
			Headroom 380
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1809C17F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_4
		{
			Compression PCM
			Headroom 1632
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_5
		{
			Compression PCM
			Headroom -191
			LoopPoint 1920
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_2_B
		{
			Compression PCM
			Headroom -101
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_2_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1853E399
		{
			Compression PCM
			Headroom 782
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1853E399.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x185E4F6E
		{
			Compression PCM
			Headroom 166
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x185E4F6E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BACK_FIRE_POP_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BACK_FIRE_POP_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x18751F69
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x18751F69.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack GEAR_GRIND_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\GEAR_GRIND_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x18ABECD5
		{
			Compression PCM
			Headroom 456
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x18ABECD5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x18B49627
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x18B49627.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x18F74769
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x18F74769.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack COP_TRUNK_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\COP_TRUNK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack REGULAR_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\REGULAR_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERIOR_CAR_NOISE_11
		{
			Compression PCM
			Headroom 1771
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERIOR_CAR_NOISE_11.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x192269EA
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x192269EA.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack COPTER_DOOR_OPEN
		{
			Compression PCM
			Headroom 389
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\COPTER_DOOR_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INDICATOR_TRUCK_OFF
		{
			Compression PCM
			Headroom 710
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INDICATOR_TRUCK_OFF.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1970927F
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1970927F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SQUEAK_05
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SQUEAK_05.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x199060ED
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x199060ED.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x19A1DA06
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x19A1DA06.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x19B9B422
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x19B9B422.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x19BFEC83
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x19BFEC83.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x19D6F01D
		{
			Compression PCM
			Headroom -178
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x19D6F01D.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x19DDFF35
		{
			Compression PCM
			Headroom 518
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x19DDFF35.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x19EBD1DD
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x19EBD1DD.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x19F626B5
		{
			Compression PCM
			Headroom 360
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x19F626B5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1A0EB618
		{
			Compression PCM
			Headroom 782
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1A0EB618.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack INTERNAL_GEAR_CHANGE_5
		{
			Compression PCM
			Headroom 576
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\INTERNAL_GEAR_CHANGE_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DAMAGE_LOOP_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DAMAGE_LOOP_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LUXURY_CLOSE_2
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LUXURY_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1A901661
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1A901661.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1ABF0BF0
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1ABF0BF0.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1AD97C22
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1AD97C22.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1AE3EF45
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1AE3EF45.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1B058B7E
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1B058B7E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1B0BFCAF
		{
			Compression PCM
			Headroom -189
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1B0BFCAF.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MOPED_600_CC_IGNITION_TAIL
		{
			Compression PCM
			Headroom 1030
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MOPED_600_CC_IGNITION_TAIL.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PNEUMATIC_SUSPENSION_DOWN_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PNEUMATIC_SUSPENSION_DOWN_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1B16D5C4
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1B16D5C4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MUSCLE_CAR_CLOSE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MUSCLE_CAR_CLOSE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SQUEAK_03
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SQUEAK_03.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TRAWLER_HORN
		{
			Compression PCM
			Headroom -191
			LoopPoint 7303
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TRAWLER_HORN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1B6DCA7C
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1B6DCA7C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SALOON_NEW_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SALOON_NEW_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BREAKDOWN_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BREAKDOWN_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1B76ECBF
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1B76ECBF.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1B7B73D5
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1B7B73D5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack MUSCLE_TRUNK_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\MUSCLE_TRUNK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1B961874
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1B961874.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1BD954DD
		{
			Compression PCM
			Headroom 644
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1BD954DD.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TYRE_BUMP_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TYRE_BUMP_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1BE68C4F
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1BE68C4F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1BF8BA63
		{
			Compression PCM
			Headroom 179
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1BF8BA63.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXHAUST_DRAG_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXHAUST_DRAG_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1C25EF1E
		{
			Compression PCM
			Headroom -201
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1C25EF1E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BRAKE_DISC_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BRAKE_DISC_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1C47936A
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1C47936A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1C492AD2
		{
			Compression PCM
			Headroom 1300
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1C492AD2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack REGULAR_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\REGULAR_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTERNAL_GEAR_CHANGE_5
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTERNAL_GEAR_CHANGE_5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1C6BCC9A
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1C6BCC9A.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1C7840B4
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1C7840B4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1C8B8E92
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1C8B8E92.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EX_POP_SUB
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EX_POP_SUB.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_7
		{
			Compression PCM
			Headroom -191
			LoopPoint 2625
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_WAIL_01
		{
			Compression PCM
			Headroom -200
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_WAIL_01.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1CA030E3
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1CA030E3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_1
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BACK_FIRE_POP_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BACK_FIRE_POP_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1CE95E90
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1CE95E90.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUSPENSION_UP
		{
			Compression PCM
			Headroom -188
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUSPENSION_UP.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1CEFAFAC
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1CEFAFAC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1CF6C7F8
		{
			Compression PCM
			Headroom -150
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1CF6C7F8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1D0D87CC
		{
			Compression PCM
			Headroom -171
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1D0D87CC.wav
			AnimClip null
			Events
			{
				Event
				{
					EventTypeHash 0x00000000
					ParameterHash 0x00000000
					Timestamp 0
					Flags 0x00000000
				}
			}
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BLOWOUT_WHEEL_RIM_B
		{
			Compression PCM
			Headroom -153
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BLOWOUT_WHEEL_RIM_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1D3233FB
		{
			Compression PCM
			Headroom -195
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1D3233FB.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack COP_TRUNK_CLOSE
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\COP_TRUNK_CLOSE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1DB035F7
		{
			Compression PCM
			Headroom 33
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1DB035F7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1DBCDCBA
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1DBCDCBA.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1DC75EAB
		{
			Compression PCM
			Headroom 612
			LoopPoint 30
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1DC75EAB.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SIREN_2
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SIREN_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1DD43E28
		{
			Compression PCM
			Headroom 60
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1DD43E28.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1DD4F817
		{
			Compression PCM
			Headroom -178
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1DD4F817.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1DD52059
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1DD52059.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_8
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1E0BF6F3
		{
			Compression PCM
			Headroom 612
			LoopPoint 30
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1E0BF6F3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1E14F89C
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1E14F89C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTERNAL_GEAR_CHANGE_2
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTERNAL_GEAR_CHANGE_2.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SMALL_CAR_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SMALL_CAR_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack STONE_7
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\STONE_7.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1E5CFD69
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1E5CFD69.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack TYRE_BUMP_4
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\TYRE_BUMP_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUSPENSION_UP_1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUSPENSION_UP_1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EXTRA_DAMAGE_5_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EXTRA_DAMAGE_5_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1E85837B
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1E85837B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1E8A882E
		{
			Compression PCM
			Headroom -191
			LoopPoint 3051
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1E8A882E.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1E9FD81F
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1E9FD81F.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_10
		{
			Compression PCM
			Headroom -191
			LoopPoint 1523
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_10.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack LUX_SUV_TRUNK_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\LUX_SUV_TRUNK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack SUSPENSION_UP_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\SUSPENSION_UP_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack NULL_LOOP
		{
			Compression PCM
			Headroom 0
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\NULL_LOOP.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F1284A6
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F1284A6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F1549A8
		{
			Compression PCM
			Headroom 371
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F1549A8.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_9
		{
			Compression PCM
			Headroom -191
			LoopPoint 6413
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_9.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack VAN_TRUNK_OPEN
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\VAN_TRUNK_OPEN.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F4D7830
		{
			Compression PCM
			Headroom -193
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F4D7830.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F50A52C
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F50A52C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F512FF5
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F512FF5.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F527471
		{
			Compression PCM
			Headroom 433
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F527471.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack BREAKDOWN_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\BREAKDOWN_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WASTE_GATE
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WASTE_GATE.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack CAR_HORN_MED_4
		{
			Compression PCM
			Headroom -201
			LoopPoint 3698
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\CAR_HORN_MED_4.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F66259C
		{
			Compression PCM
			Headroom -201
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F66259C.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F6637D1
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F6637D1.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1F68D690
		{
			Compression PCM
			Headroom 182
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1F68D690.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack PNEUMATIC_SUSPENSION_DOWN_3
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\PNEUMATIC_SUSPENSION_DOWN_3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1FA84DA3
		{
			Compression PCM
			Headroom 125
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1FA84DA3.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1FB5F1AB
		{
			Compression PCM
			Headroom 990
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1FB5F1AB.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack DOOR_LIMIT
		{
			Compression PCM
			Headroom 99
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\DOOR_LIMIT.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack WET_SKID_B
		{
			Compression PCM
			Headroom -191
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\WET_SKID_B.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack EX_POP_6
		{
			Compression PCM
			Headroom -191
			LoopPoint -1
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\EX_POP_6.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
		WaveTrack 0x1FF24DBC
		{
			Compression PCM
			Headroom 770
			LoopPoint 0
			LoopBegin 0
			LoopEnd 0
			PlayBegin 0
			PlayEnd 0
			Wave vehicles\0x1FF24DBC.wav
			AnimClip null
			Events null
			UNKNOWN_23097A2B null
			UNKNOWN_E787895A null
			UNKNOWN_252C20D9 null
		}
	}
}
"
A2JvryhL,2025-07-18T06:08:10.953583,powerampache,PHP,Friday 18th of July 2025 05:08:09 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 34102) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

getSongsFromAlbum() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 34102) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 34102) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
QpBrW1aL,Untitled,Kindane,C,Friday 18th of July 2025 04:03:04 AM CDT,"привет тому кто зашел в этот антик!
Пусть у вас сегодня будет пятница на чилле ;)"
bc6R1Svj,Show / hide advanced search button,gabetu,JavaScript,Friday 18th of July 2025 02:50:41 AM CDT,"<script>
document.addEventListener('DOMContentLoaded', function () {
    const targetLink = document.querySelector('#advanced-search');
    if (!targetLink) return;

    function shouldHideButton(searchParams) {
        // Hide if no query params OR if it contains only ?type=places
		// Change CPT slug here
        return !searchParams || searchParams === '?type=places';
    }

    function updateLinkWithQueryString() {
        const currentParams = window.location.search;
        const baseHref = targetLink.dataset.baseHref || targetLink.getAttribute('href').split('?')[0];

        if (!targetLink.dataset.baseHref) {
            targetLink.dataset.baseHref = baseHref;
        }

        const newHref = currentParams ? `${baseHref}${currentParams}` : baseHref;
        targetLink.setAttribute('href', newHref);

        // Update visibility
        targetLink.style.display = shouldHideButton(currentParams) ? 'none' : 'block';
    }

    // Initial check
    updateLinkWithQueryString();

    // Handle browser navigation (back/forward)
    window.addEventListener('popstate', updateLinkWithQueryString);

    // Handle dynamic URL changes (pushState/replaceState)
    const originalPushState = history.pushState;
    history.pushState = function () {
        originalPushState.apply(history, arguments);
        updateLinkWithQueryString();
    };

    const originalReplaceState = history.replaceState;
    history.replaceState = function () {
        originalReplaceState.apply(history, arguments);
        updateLinkWithQueryString();
    };
});
</script>"
2vr161mt,service registration,Official_Lusi,C#,Friday 18th of July 2025 01:56:07 AM CDT,"public interface ICacheService
{
	public void SetSomething(object something);
	public object GetSomething();
}

public class CacheService : ICacheService
{
	private object _something;
	
	public void SetSomething(object something) => _something = something;
	
	public object GetSomething() => _something;
}

public class Service()
{
	private ICacheService _serviceCache;
	
	public Service(ICacheService cache)
	{
		_serviceCache = cache;
	}
	
	public void DoSomething(object something)
	{
		//stuff 
		
		_cacheService.SetSomething(something);
		
		//other stuff
	}
	
	public object ReturnSomething()
	{
		return _cacheService.GetSomething();
	}
}
	
public class Program{

	private ICacheService _cacheService;
	private Service _service;

	public static int Main(string[] args)
	{
		// inizializzo un service provider ecc...
		IServiceProvider provider = /*serviceProvider*/ ;
		
		_cacheService = new CacheService();
		
		RegisterServices(provider);
		
		DoingSomethingWithServices(provider);
		
		return 0;
	}
	
	private void RegisterServices(IServiceProvider provider)
	{
		provider.Services.AddSingleton<ICacheService>(_cacheService);
		provider.Services.AddTransient<Service>();
	}
	
	private void DoingSomethingWithServices(IServiceProvider provider)
	{
		Service serviceInstance1 = provider.GetService<Service>();
		Service serviceInstance2 = provider.GetService<Service>();
		Service serviceInstance3 = provider.GetService<Service>();
		
		object something = 1;
		serviceInstance1.DoSomething(something);
		
		object something = 2;
		serviceInstance2.DoSomething(something);
		
		object something = 3;
		serviceInstance1.DoSomething(something);
		
		List<object> somethings = new List<object>();
		
		somethings.Add(serviceInstance1.ReturnSomething())
		somethings.Add(serviceInstance2.ReturnSomething())
		somethings.Add(serviceInstance3.ReturnSomething())
		
		// what's inside somethings? 3,3,3 ? or 1,2,3?
	}
}"
Uhn0QL0z,2025-07-18T07:37:50.239,powerampache,PHP,Thursday 17th of July 2025 11:37:51 PM CDT,"1.00-64 (64) - DB: 82
java.lang.NullPointerException
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.scrobbleEverything(SongsRepositoryImpl.kt:593)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.access$scrobbleEverything(SongsRepositoryImpl.kt:77)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl$scrobbleEverything$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)

"
gUfZneQp,Untitled,thewitchking,C++,Thursday 17th of July 2025 11:08:48 PM CDT,"#include <iostream>
#include <vector>
#include <algorithm>

struct Ant {
    int position;
    int direction; // -1 for left, 1 for right
};

int timeUntilAllFall(int plankSize, std::vector<int> left, std::vector<int> right) {
    std::vector<Ant> ants;

    // Initialize ants
    for (int pos : left) ants.push_back({pos, -1});
    for (int pos : right) ants.push_back({pos, 1});

    int time = 0;

    while (!ants.empty()) {
        time++;

        // Move all ants
        for (auto& ant : ants) {
            ant.position += ant.direction;
        }

        // Handle collisions — if two ants are on the same position, switch direction
        for (int i = 0; i < ants.size(); ++i) {
            for (int j = i + 1; j < ants.size(); ++j) {
                if (ants[i].position == ants[j].position) {
                    ants[i].direction *= -1;
                    ants[j].direction *= -1;
                }
            }
        }

        // Remove ants that fall off the plank
        ants.erase(std::remove_if(ants.begin(), ants.end(),
                                  [plankSize](const Ant& ant) {
                                      return ant.position < 0 || ant.position > plankSize;
                                  }),
                   ants.end());
    }

    return time;
}

int main() {
    int plankSize = 10;
    std::vector<int> left = {4, 7};
    std::vector<int> right = {2, 5};

    int totalTime = timeUntilAllFall(plankSize, left, right);
    std::cout << ""Time until all ants fall off: "" << totalTime << "" seconds\n"";

    return 0;
}
"
AvTaAZiV,Untitled,thewitchking,C++,Thursday 17th of July 2025 11:03:43 PM CDT,"#include <iostream>
#include <vector>
#include <unordered_map>

std::pair<int, int> twoSum(const std::vector<int>& nums, int target) {
    std::unordered_map<int, int> freq; // number → count

    for (int i = 0; i < nums.size(); ++i) {
        freq[nums[i]]++;
    }

    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];

        // Case 1: nums[i] != complement
        if (complement != nums[i] && freq[complement] > 0) {
            return {nums[i], complement};
        }

        // Case 2: nums[i] == complement, need at least 2 occurrences
        if (complement == nums[i] && freq[nums[i]] > 1) {
            return {nums[i], nums[i]};
        }
    }

    return {-1, -1}; // Not found
}

int main() {
    std::vector<int> nums = {12, 12, 13};
    int target = 24;

    auto result = twoSum(nums, target);

    if (result.first != -1) {
        std::cout << ""Found: "" << result.first << "" + "" << result.second << "" = "" << target << ""\n"";
    } else {
        std::cout << ""No valid pair found.\n"";
    }

    return 0;
}
"
0x83qfPG,Untitled,thewitchking,C++,Thursday 17th of July 2025 11:00:51 PM CDT,"#include <iostream>
#include <vector>
#include <unordered_map>

std::pair<int, int> twoSum(const std::vector<int>& nums, int target) {
    std::unordered_map<int, int> seen; // key = number, value = index

    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];

        if (seen.find(complement) != seen.end()) {
            return {seen[complement], i}; // return indices of the two numbers
        }

        seen[nums[i]] = i;
    }

    return {-1, -1}; // not found
}

int main() {
    std::vector<int> nums = {8, 3, 5, 7, 1};
    int target = 10;

    std::pair<int, int> result = twoSum(nums, target);

    if (result.first != -1) {
        std::cout << ""Indices: "" << result.first << "", "" << result.second << ""\n"";
        std::cout << ""Numbers: "" << nums[result.first] << "" + "" << nums[result.second] << "" = "" << target << ""\n"";
    } else {
        std::cout << ""No pair found.\n"";
    }

    return 0;
}
"
uQx9S4Y9,Filtering tambahan,Kepin16,PL/SQL,Thursday 17th of July 2025 10:20:19 PM CDT,"SELECT PERSON_ID, PERSON_FULL_NAME
    FROM (SELECT PERSON_ID, PERSON_FULL_NAME, 0 IDX
            FROM HRMS.HR_PEOPLE_ALL
           WHERE PERSON_ID = 9177 -- spv
          UNION
          SELECT A.HIER_PERSON_ID, B.PERSON_FULL_NAME, A.HIER_LEVEL IDX
            FROM SHCM.CM_TGH_MST_HIERARCHIES A, HRMS.HR_PEOPLE_ALL B
           WHERE     A.HIER_PERSON_ID = B.PERSON_ID
                 AND B.PERSON_STATUS IN ('VR', 'WA', 'AC')
                 AND A.HIER_CYCLE = DECODE(:CFIN_AR_BEBAN_GTT.BBN_CYCLE_AWAL,'CN','C0',:CFIN_AR_BEBAN_GTT.BBN_CYCLE_AWAL)
                 AND A.HIER_COYOUTLET_ID = '2634' -- cabang
                 AND A.HIER_COLL_TYPE = NVL(:CTRL.COLL_TYPE,A.HIER_COLL_TYPE)
                 AND A.HIER_PERSON_ID <> :CFIN_AR_BEBAN_GTT.BBN_COLL_ID
                 AND A.HIER_LEVEL IN (SELECT C.PARAM_VALUE
                                        FROM APPL.APPL_MST_PARAM C
                                       WHERE C.PARAM_KEY IN ('JL_COLL'))
                 AND A.HIER_UP_LEVEL || A.HIER_UP_SUB_LEVEL IN
                         (SELECT D.HIER_LEVEL || D.HIER_SUB_LEVEL
                            FROM SHCM.CM_TGH_MST_HIERARCHIES D
                           WHERE D.HIER_PERSON_ID = 9177) -- spv
                 -- TAMBAHAN SETUP SURVEYOR
                 AND PERSON_ID NOT IN
                         (SELECT DTL.SURD_PERSON_ID
                            FROM CFIN.CFIN_MST_SURVEYOR_HDR HDR,
                                 CFIN.CFIN_MST_SURVEYOR_DTL DTL
                           WHERE     HDR.SURH_OUTLET_ID = DTL.SURD_OUTLET_ID
                                 AND HDR.SURH_OUTLET_ID = A.HIER_COYOUTLET_ID
                                 AND DTL.SURD_PERSON_ID = PERSON_ID
                                 AND DTL.SURD_TYPE = 'COL'
                                 AND HDR.SURH_STATUS = 'AC'))
ORDER BY IDX;"
XeUdX0qT,a3-anti-modded-7-15-25,explosive_eggshells,HTML,Thursday 17th of July 2025 10:13:01 PM CDT,"<?xml version=""1.0"" encoding=""utf-8""?>
<html>
  <!--Created by Arma 3 Launcher: https://arma3.com-->
  <head>
    <meta name=""arma:Type"" content=""preset"" />
    <meta name=""arma:PresetName"" content=""AntistasiJuly2025"" />
    <meta name=""generator"" content=""Arma 3 Launcher - https://arma3.com"" />
    <title>Arma 3</title>
    <link href=""https://fonts.googleapis.com/css?family=Roboto"" rel=""stylesheet"" type=""text/css"" />
    <style>
body {
	margin: 0;
	padding: 0;
	color: #fff;
	background: #000;	
}

body, th, td {
	font: 95%/1.3 Roboto, Segoe UI, Tahoma, Arial, Helvetica, sans-serif;
}

td {
    padding: 3px 30px 3px 0;
}

h1 {
    padding: 20px 20px 0 20px;
    color: white;
    font-weight: 200;
    font-family: segoe ui;
    font-size: 3em;
    margin: 0;
}

em {
    font-variant: italic;
    color:silver;
}

.before-list {
    padding: 5px 20px 10px 20px;
}

.mod-list {
    background: #222222;
    padding: 20px;
}

.dlc-list {
    background: #222222;
    padding: 20px;
}

.footer {
    padding: 20px;
    color:gray;
}

.whups {
    color:gray;
}

a {
    color: #D18F21;
    text-decoration: underline;
}

a:hover {
    color:#F1AF41;
    text-decoration: none;
}

.from-steam {
    color: #449EBD;
}
.from-local {
    color: gray;
}

</style>
  </head>
  <body>
    <h1>Arma 3  - Preset <strong>AntistasiJuly2025</strong></h1>
    <p class=""before-list"">
      <em>To import this preset, drag this file onto the Launcher window. Or click the MODS tab, then PRESET in the top right, then IMPORT at the bottom, and finally select this file.</em>
    </p>
    <div class=""mod-list"">
      <table>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">CBA_A3</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=450814997"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=450814997</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Animated Recoil coefficient changer</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2623341670"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2623341670</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Enhanced Movement</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=333310405"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=333310405</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">RHSAFRF</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=843425103"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=843425103</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">RHSUSAF</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=843577117"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=843577117</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Antistasi Ultimate - Mod</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3020755032"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3020755032</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Enhanced Soundscape</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=825179978"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=825179978</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">[RHRM] Real Hero's Ragdoll Mod Cartoony Edition</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2528928775"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2528928775</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">A3 Thermal Improvement</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2041057379"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2041057379</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">AI avoids prone</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2011658088"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2011658088</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">AI Cannot See Small Drones</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2947745583"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2947745583</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">AI Helicopter Decelerate No Climbing</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3496308284"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3496308284</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Animated Corner Shooting</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3351398245"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3351398245</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Anti Aircraft Tracer + Bullet Mod</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1514439943"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1514439943</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">bc036's Invisible Backpacks</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=534897004"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=534897004</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Better Inventory</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2791403093"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2791403093</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">BettIR (Legacy v0.2.1)</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2260572637"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2260572637</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Blastcore Compiled By isky</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2884936024"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2884936024</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Cinematic Lens Flare</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=878502647"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=878502647</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Death and Hit reactions</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2993442344"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2993442344</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Dom's View Distance Mod</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2512672547"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2512672547</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">ANZACSAS Helicopter Dust Efx Mod - Lite</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2866924390"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2866924390</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Enhanced Movement Rework</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2034363662"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2034363662</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Exocet Inspecting Weapons</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2869511168"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2869511168</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">DUI - Squad Radar</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1638341685"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1638341685</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Ghost recon 3rd Person Camera</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1284600102"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1284600102</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">GX - Drones</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3460981677"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3460981677</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Helmet Mounted Camera</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2679569820"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2679569820</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Immerse</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=825172265"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=825172265</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Improved Melee System</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2291129343"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2291129343</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">JSRS SOUNDMOD 2025 Beta - RC3</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3407948300"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3407948300</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">JSRS SOUNDMOD 2025 Beta - AiO Compat Files RC3</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3407970596"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3407970596</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Ladder Tweak Remastered</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2969350304"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2969350304</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Light Blue Water Colour Mod</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1520786131"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1520786131</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Magazine Simulation A3</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1373715042"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1373715042</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">MagRepack</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1593431569"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1593431569</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">MTK - Faster Pistol Swap</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3289651152"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3289651152</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">No More Aircraft Bouncing</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1770265310"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1770265310</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">NVG Animation (with SFX)</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2995666339"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2995666339</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Project Dynamic Dirt</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3512167740"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3512167740</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Project SFX: Footsteps</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2806487814"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2806487814</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Project SFX: Remastered</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2129532219"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2129532219</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Real Flashlights</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3366918628"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3366918628</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Reload While Aiming</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3450227250"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3450227250</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Remove stamina</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=632435682"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=632435682</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Reduced Weapon Sway</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=567737932"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=567737932</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">RHSGREF</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=843593391"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=843593391</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">RHSSAF</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=843632231"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=843632231</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Ride Where You Look</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2153127400"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2153127400</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Simple Dot Crosshair</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2932981862"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2932981862</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Splendid Smoke Rework</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2421048459"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2421048459</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Suppress</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=825174634"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=825174634</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Swim Faster</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1808723766"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1808723766</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Ukraine FPV Drone</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3475006113"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3475006113</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Unit Voice-overs</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1868302880"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1868302880</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">WBK Simple Blood</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3132949782"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3132949782</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Weapon Holster - Remastered</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1562915006"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1562915006</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">WebKnight Flashlights and Headlamps</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2572487482"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2572487482</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Zeus Enhanced</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1779063631"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1779063631</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">WMO - Walkable Moving Objects</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=925018569"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=925018569</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">[A3UE] Syr's Extra Missions</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3458624089"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3458624089</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Arma 3 | Ready Check [Simple Mod | Client Side]</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1645981258"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1645981258</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Enhanced Missile Smoke + Lighting Efx Mod v1.4</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=1484261993"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=1484261993</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Hartman's Armbands</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3330144696"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3330144696</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Improved Craters</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=2886141254"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=2886141254</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Turret Tweaks</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3475038178"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3475038178</a>
          </td>
        </tr>
      </table>
    </div>
    <div class=""dlc-list"">
      <table />
    </div>
    <div class=""footer"">
      <span>Created by Arma 3 Launcher by Bohemia Interactive.</span>
    </div>
  </body>
</html>"
utiSHi4k,ServerError: received 500 HTTP response,basedcount_bot,Python,Thursday 17th of July 2025 09:36:36 PM CDT,"Traceback (most recent call last):
  File ""/home/gmktec-server/Bots/basedcount_bot/basedcount_bot.py"", line 46, in wrapper
    await func(reddit_instance, mongo_client)
  File ""/home/gmktec-server/Bots/basedcount_bot/basedcount_bot.py"", line 123, in check_mail
    async for message in reddit_instance.inbox.unread(limit=None):  # Message
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 37, in __anext__
    await self._next_batch()
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 90, in _next_batch
    self._listing = await self._reddit.get(self.url, params=self.params)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 813, in get
    return await self._objectify_request(method=""GET"", params=params, path=path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 570, in _objectify_request
    await self.request(
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 1061, in request
    return await self._core.request(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 383, in request
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 305, in _request_with_retries
    return await self._do_retry(
           ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 170, in _do_retry
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 305, in _request_with_retries
    return await self._do_retry(
           ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 170, in _do_retry
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 322, in _request_with_retries
    raise self.STATUS_EXCEPTIONS[response.status](response)
asyncprawcore.exceptions.ServerError: received 500 HTTP response
"
Xh0kQkni,A3-Anti-7-15-25,explosive_eggshells,HTML,Thursday 17th of July 2025 08:04:50 PM CDT,"<?xml version=""1.0"" encoding=""utf-8""?>
<html>
  <!--Created by Arma 3 Launcher: https://arma3.com-->
  <head>
    <meta name=""arma:Type"" content=""preset"" />
    <meta name=""arma:PresetName"" content=""BaseAntistasi"" />
    <meta name=""generator"" content=""Arma 3 Launcher - https://arma3.com"" />
    <title>Arma 3</title>
    <link href=""https://fonts.googleapis.com/css?family=Roboto"" rel=""stylesheet"" type=""text/css"" />
    <style>
body {
	margin: 0;
	padding: 0;
	color: #fff;
	background: #000;	
}

body, th, td {
	font: 95%/1.3 Roboto, Segoe UI, Tahoma, Arial, Helvetica, sans-serif;
}

td {
    padding: 3px 30px 3px 0;
}

h1 {
    padding: 20px 20px 0 20px;
    color: white;
    font-weight: 200;
    font-family: segoe ui;
    font-size: 3em;
    margin: 0;
}

em {
    font-variant: italic;
    color:silver;
}

.before-list {
    padding: 5px 20px 10px 20px;
}

.mod-list {
    background: #222222;
    padding: 20px;
}

.dlc-list {
    background: #222222;
    padding: 20px;
}

.footer {
    padding: 20px;
    color:gray;
}

.whups {
    color:gray;
}

a {
    color: #D18F21;
    text-decoration: underline;
}

a:hover {
    color:#F1AF41;
    text-decoration: none;
}

.from-steam {
    color: #449EBD;
}
.from-local {
    color: gray;
}

</style>
  </head>
  <body>
    <h1>Arma 3  - Preset <strong>BaseAntistasi</strong></h1>
    <p class=""before-list"">
      <em>To import this preset, drag this file onto the Launcher window. Or click the MODS tab, then PRESET in the top right, then IMPORT at the bottom, and finally select this file.</em>
    </p>
    <div class=""mod-list"">
      <table>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">CBA_A3</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=450814997"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=450814997</a>
          </td>
        </tr>
        <tr data-type=""ModContainer"">
          <td data-type=""DisplayName"">Antistasi Ultimate - Mod</td>
          <td>
            <span class=""from-steam"">Steam</span>
          </td>
          <td>
            <a href=""https://steamcommunity.com/sharedfiles/filedetails/?id=3020755032"" data-type=""Link"">https://steamcommunity.com/sharedfiles/filedetails/?id=3020755032</a>
          </td>
        </tr>
      </table>
    </div>
    <div class=""dlc-list"">
      <table />
    </div>
    <div class=""footer"">
      <span>Created by Arma 3 Launcher by Bohemia Interactive.</span>
    </div>
  </body>
</html>"
SmPb4B0y,GuneAwakening_anticlutter,zerox2501,INI file,Thursday 17th of July 2025 07:33:10 PM CDT,"[Core.System]
+Suppress=Scriptwarning
+Suppress=Scriptlog
+Suppress=Warning
+Suppress=Error

[Core.Log]
Global=all off
LogAI=all off
LogAnalytics=all off
LogAnimation=all off
LogAudio=all off
LogAudioCaptureCore=all off
LogAudioMixer=all off
LogBlueprint=all off
LogChaosDD=all off
LogConfig=all off
LogCore=all off
LogDerivedDataCache=all off
LogDeviceProfileManager=all off
LogEOSSDK=all off
LogFab=all off
LogFileCache=all off
LogInit=all off
LogInput=all off
LogInteractiveProcess=all off
LogLevelSequenceEditor=all off
LogLinker=all off
LogMemory=all off
LogMemoryProfiler=all off
LogMeshMerging=all off
LogMeshReduction=all off
LogMetaSound=all off
LogNFORDenoise=all off
LogNetwork=all off
LogNetworkingProfiler=all off
LogNiagara=all off
LogNiagaraDebuggerClient=all off
LogNNEDenoiser=all off
LogNNERuntimeORT=all off
LogOnline=all off
LogOnlineEntitlement=all off
LogOnlineEvents=all off
LogOnlineFriend=all off
LogOnlineGame=all off
LogOnlineIdentity=all off
LogOnlinePresence=all off
LogOnlineSession=all off
LogOnlineTitleFile=all off
LogOnlineUser=all off
LogPakFile=all off
LogPhysics=all off
LogPluginManager=all off
LogPython=all off
LogRenderTargetPool=all off
LogRenderer=all off
LogRendererCore=all off
LogShaderCompiler=all off
LogShaderCompilers=all off
LogSlate=all off
LogSourceControl=all off
LogStreaming=all off
LogStudioTelemetry=all off
LogTargetPlatformManager=all off
LogTelemetry=all off
LogTemp=all off
LogTextureEncodingSettings=all off
LogTextureFormatManager=all off
LogTextureFormatOodle=all off
LogTimingProfiler=all off
LogUObject=all off
LogUObjectArray=all off
LogUsd=all off
LogVRS=all off
LogVirtualization=all off
LogWindows=all off
LogWindowsTextInputMethodSystem=all off
LogWorldPartition=all off
LogXGEController=all off
LogZenServiceInstance=all off
PixWinPlugin=all off
RenderDocPlugin=all off"
ZqDeDFLX,Visual FA for Python (work in progress),honey_the_codewitch,Python,Thursday 17th of July 2025 07:28:02 PM CDT,"# Visual FA Python port - work in progress
# copyright (c) 2025 by honey the codewitch
# MIT license
import struct

class _FListNode:
    def __init__(self, q, sl):
        self.next = None
        self.prev = None
        self.state = q
        self.stateList = sl
        if (sl.count == 0):
            sl.count += 1
            sl.first = self
            sl.last = self
        else:
            sl.count += 1
            sl.last.next = self
            self.prev = sl.last
            sl.last = self
    
    def remove(self):
        self.stateList.count -= 1
        if self.stateList.first is self:
            self.stateList.first = self.next
        else:
            self.prev.next = self.next

        if self.stateList.last is self:
            self.stateList.last = self.prev
        else:
            self.next.prev = self.prev
    
class _FList:
    def __init__(self):
        self.count = 0
        self.first = None
        self.last = None
    
    def add(self, q):
        return _FListNode(q, self)
    
class _FKeyPair:
    def __init__(self, key, value):
        self.key = key
        self.value = value

class FAProgress:
    def __init__(self, callback = None):
        self.value = 0
        self._callback = callback
    
    def report(self, value):
        self.value = value
        if self._callback != None:
            self._callback(value)
        
class FARange:
    def __init__(self, min = -1, max = -1):
        self.min = min
        self.max = max
    def __lt__(self,rhs):
        if self.max == rhs.max:
            return self.min < rhs.min
        return self.max < rhs.max
    def intersects(self, rhs):
        return (rhs.min >= self.min and rhs.min <= self.max) or (rhs.max >= self.min and rhs.max <= self.max)
    @staticmethod    
    def toUnpacked(packedRanges):
        result = []
        length = len(packedRanges)/2
        i = 0
        while i < length:
            j = i * 2
            result.append(FARange(packedRanges[j], packedRanges[j + 1]))
            
            i += 1
        return result
    @staticmethod
    def toPacked(pairs):
        result = []
        i = 0
        while i < len(pairs):
            pair = pairs[i]
            j = i * 2
            result.append(pair.min)
            result.append(pair.max)
            i += 1
        return result
    @staticmethod
    def toNotRanges(ranges):
        # expects ranges to be normalized
        last = 0x10ffff
        e = iter(ranges)
        cur = next(e, None)
        if cur is None:
            yield FARange(0x0, 0x10ffff)
            return
        if cur.min > 0:
            yield FARange(0, cur.min - 1)
            last = cur.max
            if  0x10ffff <= last:
                return
        elif cur.min == 0:
            last = cur.max
            if 0x10ffff <= last:
                return
        while cur != None:
            if 0x10ffff <= last:
                return
            if last + 1 < cur.min:
                yield FARange(last + 1, (cur.min - 1))
            last = cur.max
            cur = next(e, None)
        
        if 0x10ffff >= last:
            yield FARange((last + 1), 0x10ffff)
    
class FATransition:
    def __init__(self, to, min = -1, max = -1):
        self.to = to
        self.min = min
        self.max = max

    def isEpsilon(self):
        return self.min == -1 or self.max == -1
    
    def __lt__(self,rhs):
        if self.max == rhs.max:
            return self.min < rhs.min
        return self.max < rhs.max
    
class FA:
    def __init__(self, acceptSymbol = -1):
        self.acceptSymbol = acceptSymbol
        self.transitions = []
        self.__minimizationTag = -1
        self.__isDeterministic = True
        self.__isCompact = True
        self.id = -1

    def isCompact(self):
        return self.__isCompact
    
    def isDeterministic(self):
        return self.__isDeterministic
    
    def isAccepting(self):
        return self.acceptSymbol != -1
    
    def ifFinal(self):
        return len(self.transitions) == 0
    
    def isNeutral(self): 
        return self.acceptSymbol == -1 and len(self.transitions) == 1 and self.transitions[0].isEpsilon()
    
    def isTrap(self):
        return self.acceptSymbol == -1 and len(self.transitions) == 0
    
    def addEpsilon(self, to, compact = True):
        if compact == True:
            i = 0
            while i < len(to.transitions):
                fat = to.transitions[i]
                if fat.isEpsilon() == False:
                    self.addTransition(FARange(fat.min, fat.max), to, True)
                else:
                    self.addEpsilon(to, True)
                i += 1
            if self.acceptSymbol < 0 and to.acceptSymbol > -1:
                self.acceptSymbol = to.acceptSymbol
        else:
            found = False
            i = 0
            while i < len(to.transitions):
                fat = to.transitions[i]
                if fat.isEpsilon() == False:
                    break
                if fat.to is to:
                    found = True
                    break
                i += 1
            if found == False:
                self.transitions.insert(i,FATransition(to))
                self.__isCompact = False
                self.__isDeterministic = False
    
    def addTransition(self, rng, to, compact = True):
        if rng.min == -1 and rng.max == -1:
            self.addEpsilon(to, compact)
            return
        if rng.min > rng.max:
            tmp = rng.min
            rng.min = rng.max
            rng.max = tmp
        i = 0
        insert = -1
        while i < len(self.transitions):
            fat = self.transitions[i]
            if to is fat.to and rng.min == fat.min and rng.max == fat.max:
                return
            if self.__isDeterministic:
                if rng.intersects(FARange(fat.min, fat.max)):
                    self.__isDeterministic = False
            if rng.max > fat.max:
                insert = i
            if self.__isDeterministic == False and rng.max < fat.min:
                break
            i += 1
        self.transitions.insert(insert+1,FATransition(to, rng.min, rng.max))
    
    def clearTransitions(self):
        self.transitions.clear()
        self.__isDeterministic = True
        self.__isCompact = True
    
    @staticmethod
    def getFirstAcceptSymbol(states):
        for state in states:
            if state.acceptSymbol != -1:
                return state.acceptSymbol
        return -1
    
    def fillClosure(self, list = None):
        if list is None:
            list = []
        if self in list:
            return list
        list.append(self)
        i = 0
        while i < len(self.transitions):
            trn = self.transitions[i]
            trn.to.fillClosure(list)
            i += 1
        return list
    
    def fillEpsilonClosure(self, list = None):
        if list is None:
            list = []
        if self in list:
            return list
        list.append(self)
        if self.__isCompact == True:
            return list
        
        i = 0
        while i < len(self.transitions):
            trn = self.transitions[i]
            if trn.isEpsilon() == True:
                if trn.to.__isCompact == True:
                    if not (trn.to in list):
                        list.append(trn.to)
                else:
                    trn.to.fillEpsilonClosure(list)
            else:
                break
            i += 1
        return list
    
    def clone(self):
        closure = self.fillClosure()
        nclosure = []
        i = 0
        while i < len(closure):
            cfa = closure[i]
            nfa = FA(cfa.acceptSymbol)
            nfa.__isDeterministic = cfa.__isDeterministic
            nfa.__isCompact = cfa.__isCompact
            nfa.__minimizationTag = cfa.__minimizationTag
            nfa.id = cfa.id
            nclosure.append(nfa)
            i += 1
        i = 0
        while i< len(nclosure):
            cfa = closure[i]
            nfa = nclosure[i]
            j = 0
            while j < len(cfa.transitions):
                fat = cfa.transitions[j]
                nfa.transitions.append(FATransition(nclosure[closure.index(fat.to)], fat.min, fat.max))
                j += 1
            i += 1
        return nclosure[0]

    def totalize(self, closure = None):
        if closure is None:
            closure = self.fillClosure()
        
        s = FA()
        s.transitions.append(FATransition(s, 0, 0x10ffff))
        for p in closure:
            maxi = 0
            sortedTrans = sorted(p.transitions)
            for t in sortedTrans:
                if t.isEpsilon() == False:
                    if t.min > maxi:
                        p.transitions.append(FATransition(s, maxi, t.min - 1))
                    if t.max + 1 > maxi:
                        maxi = t.max + 1
                    
            if maxi <= 0x10ffff:
                p.transitions.append(FATransition(s, maxi, 0x10ffff))
            
    @staticmethod
    def _determinize(target, progress = None):
        target.setIds()
        if progress is None:
            progress = FAProgress()
        prog = 0
        id = 0
        progress.report(0)
        closure = target.fillClosure()
        p = set()
        for ffa in closure:
            p.add(0)
            for trn in ffa.transitions:
                if trn.isEpsilon() == False:
                    p.add(trn.min)
                    if trn.max < 0x10ffff:
                        p.add(trn.max + 1)
                
        points = sorted(p)

        prog += 1
        progress.report(prog)
        sets = dict() # new Dictionary<_KeySet<FA>, _KeySet<FA>>()
        working = [] # new Queue<_KeySet<FA>>();
        dfaMap =  dict() # new Dictionary<_KeySet<FA>, FA>()
        epscl = []
        ecs = [] # new List<FA>()
        efcs = None # List<FA> 
        epscl = []
        target.fillEpsilonClosure(epscl)
        i = 0
        initial = list()
        while i < len(epscl):
            efa = epscl[i]
            initial.append(efa)
            i += 1
        fsinit = frozenset(initial)
        sets[fsinit]= initial
        
        working.append(initial)
        result = FA()
        result.id = id
        id += 1
        result.__isDeterministic = True
        for afa in initial:
            if afa.acceptSymbol != -1:
                result.acceptSymbol = afa.acceptSymbol
                break
        prog+=1
        progress.report(prog)
        # powerset/subset construction
        dfaMap[frozenset(initial)]= result
        while len(working) > 0:
	        # get the next set
            s = working.pop(0)
	        # get the next DFA out of the map
	        # of (NFA states)->(dfa state)
            dfa = dfaMap.get(frozenset(s))
	        # find the first accepting 
	        # state if any, and assign
	        # it to the new DFA
            for q in s:
                if q.acceptSymbol!=-1:
                    dfa.acceptSymbol = q.acceptSymbol
                    break
            # for each range in the input alphabet
            i = 0
            while i < len(points):
                pnt = points[i]
                dststates = list()
                for c in s:
                    # TODO: Might be able to eliminate the
                    # epsilon closure here. Needs testing
                    ecs.clear()
                    if c.__isCompact == False:
                        c.fillEpsilonClosure(ecs)
                    else:
                        ecs.append(c)
                    j = 0
                    while j < len(ecs):
                        efa = ecs[j]
                        # basically if we intersect somewhere on the input alphabet,
				        # which we should, then we add the destination state(s) to the set
                        k = 0
                        while k < len(efa.transitions):
                            trns = efa.transitions[k]
                            # skip the epsilon closure
                            # we don't need it
                            if trns.isEpsilon() == True:
                                k += 1
                                continue
                            # TODO: can probably early out here
                            # if pnt > trns.Max?
                            if trns.min <= pnt and pnt <= trns.max:
                                if trns.to.__isCompact == True:
                                    if not (trns.to in dststates):
                                        dststates.append(trns.to)
                                else:
                                    if efcs is None:
                                        efcs = []
                                    efcs.clear()
                                    trns.to.fillEpsilonClosure(efcs)
                                    m = 0
                                    while m < len(efcs):
                                        if not (efcs[m] in dststates):
                                            dststates.append(efcs[m])
                                        m += 1
                            k+= 1
                        j +=1
                # is this a new set or an
                # existing one?
                fset = frozenset(dststates)                
                if not (fset in sets):
                    sets[fset]=dststates
                    # add another work item
                    working.append(dststates)
                    # make a new DFA state
                    newfa = FA()
                    newfa.id = id
                    id += 1
                    dfaMap[fset]= newfa

                dst = dfaMap.get(fset)
                # find the first and last range to insert
                first = pnt
                last = -1
                if i + 1 < len(points):
                    last = (points[i + 1] - 1)
                else:
                    last = 0x10ffff
                # this should already be in sorted order
                # otherwise we'd use addTransition()
                dfa.transitions.append(FATransition(dst, first, last))
                prog+=1
                progress.report(prog)
                i += 1
                
            prog+=1
            progress.report(prog)
        # remove dead transitions (destinations with no accept)
        for ffa in result.fillClosure():
            itrns = list(ffa.transitions)
            ffa.transitions.clear()
            for trns in itrns:
                if FA.getFirstAcceptSymbol(trns.to.fillClosure()) != -1:
                    ffa.transitions.append(trns)
            prog += 1
            progress.report(prog)

        prog += 1
        progress.report(prog)
        return result
    
    def toDfa(self, progress = None):
        return self._determinize(self, progress)
    
    def _step(self, input):
        ic = len(self.transitions)
        i = 0
        while i < ic:
            t = self.transitions[i]
            if input >= t.min and input <= t.max:
                return t.to
            i += 1
        return None
        
    @staticmethod
    def _minimize(a, progress):
        prog = 0
        if progress is None:
            progress = FAProgress()
        progress.report(prog)
        a = a.toDfa(progress)
        tr = a.transitions
        if len(tr) == 1:
            t = tr[0]
            if t.to is a and t.min == 0 and t.max == 0x10ffff:
                return a
            
        a.totalize()
        prog += 1
        progress.report(prog)
        cl = a.fillClosure()
        states = []
        mtag = 0
        for q in cl:
            q.__minimizationTag = mtag
            states.append(q)
            mtag += 1

        pp = []
        ic = len(cl)
        i = 0
        while i < ic:
            ffa = cl[i]
            pp.append(0)
            for t in ffa.transitions:
                pp.append(t.min)
                if t.max < 0x10ffff:
                    pp.append(t.max + 1)
            i += 1

        sigma = list(pp)
        sigma.sort()
        # initialize the data structures
        reverse = []
        for s in states:
            arr = [None] * len(sigma)
            reverse.append(arr)
        
        prog += 1
        progress.report(prog)
        reverseNonempty = []
        i = 0
        while i < len(states):
            arr = [False]*len(sigma)
            reverseNonempty.append(arr)
            i += 1
        
        partition = [None]*len(states)
        prog += 1
        progress.report(prog)
        block = [None]*len(states)
        active = []
        i = 0
        while i < len(states):
            arr = [None]*len(sigma)
            active.append(arr)
            i += 1
        
        active2 = []
        i = 0
        while i < len(states):
            arr = [None]*len(sigma)
            active2.append(arr)
            i += 1

        pending = []
        pending2 = []
        i = 0
        while i < len(sigma):
            arr = [False]*len(states)
            pending2.append(arr)
            i+= 1
        split = []
        split2 = [False]*len(states)
        refine = []
        refine2 = [False]*len(states)
        splitBlock = [None] * len(states)
        prog += 1
        progress.report(prog)
        q = 0
        while q < len(states):
            splitBlock[q] = []
            partition[q] = []
            x = 0
            while x < len(sigma):
                reverse[q][x] = []
                active[q][x]= _FList()
                x += 1
            q += 1
        # Find the initial partition and reverse edges
        for qq in states:
            j = 0
            if qq.acceptSymbol == -1:
                j = 1
            partition[j].append(qq)
            block[qq.__minimizationTag] = j
            x = 0
            while x < len(sigma):
                y = sigma[x]
                p = qq._step(y)
                pn = p.__minimizationTag
                if reverse[pn] != None and reverse[pn][x] != None:
                    reverse[pn][x].append(qq)
                reverseNonempty[pn][x] = True
                x += 1
                
            prog += 1
            progress.report(prog)
        
        # initialize the active sets
        j = 0
        while j <= 1:
            x = 0
            while x < len(sigma):
                part = partition[j]
                for qq in part:
                    if reverseNonempty[qq.__minimizationTag][x] == True:
                        active2[qq.__minimizationTag][x] = active[j][x].add(qq)
                x += 1
                prog += 1
                progress.report(prog)
            j += 1
        
        # initialize pending
        x = 0
        while x < len(sigma):
            a0 = active[0][x].count
            a1 = active[1][x].count
            j = 1
            if a0 <= a1:
                j = 0
            pending.append(_FKeyPair(j, x))
            pending2[x][j] = True
            x += 1
        
        # process pending until fixed point
        k = 2
        while len(pending) > 0:
            ip = pending.pop(0)
            p = ip.key
            x = ip.value
            pending2[x][p] = False
            m = active[p][x].first
            while m != None:
                for s in reverse[m.state.__minimizationTag][x]:
                    if split2[s.__minimizationTag] == False:
                        split2[s.__minimizationTag] = True
                        split.append(s)
                        j = block[s.__minimizationTag]
                        splitBlock[j].append(s)
                        if refine2[j] != True:
                            refine2[j] = True
                            refine.append(j)
                m = m.next
            
            prog += 1
            progress.report(prog)
            # refine blocks
            for j in refine:
                if len(splitBlock[j]) < len(partition[j]):
                    b1 = partition[j]
                    b2 = partition[k]
                    e = splitBlock[j]
                    for s in e:
                        b1.pop(b1.index(s)) # b1.splice(b1.indexOf(s), 1);
                        b2.append(s)
                        block[s.__minimizationTag] = k
                        c = 0
                        while c < len(sigma):
                            sn = active2[s.__minimizationTag][c]
                            if sn != None and sn.stateList is active[j][c]:
                                sn.remove()
                                active2[s.__minimizationTag][c] = active[k][c].add(s)
                            c += 1
                        
                    # update pending
                    c = 0
                    while c < len(sigma):
                        aj = active[j][c].count
                        ak = active[k][c].count
                        if pending2[c][j]==False and 0 < aj and aj <= ak:
                            pending2[c][j] = True
                            pending.append(_FKeyPair(j, c))
                        else:
                            pending2[c][k] = True
                            pending.append(_FKeyPair(k, c))
                        c += 1
                    k+= 1
                sbj = splitBlock[j]
                for s in sbj:
                    split2[s.__minimizationTag] = False
                refine2[j] = False
                splitBlock[j].clear()
                prog += 1
                progress.report(prog)
    
            split.clear()
            refine.clear()
        prog += 1
        progress.report(prog)
        # make a new state for each equiv class, set initial state
        newstates = []
        n = 0
        while n < k:
            s = FA()
            s.__isDeterministic = False
            newstates.append(s)
            pn = partition[n]
            for q in pn:
                if q is a:
                    a = s
                s.id = q.id
                s.acceptSymbol = q.acceptSymbol
                s.__minimizationTag = q.__minimizationTag
                q.__minimizationTag = n
            prog += 1
            progress.report(prog)
            n += 1
        # build transitions and set acceptance
        for s in newstates:
            st = states[s.__minimizationTag]
            s.acceptSymbol = st.acceptSymbol
            for t in st.transitions:
                s.transitions.append(FATransition(newstates[t.to.__minimizationTag], t.min, t.max))
            prog += 1
            progress.report(prog)
        
        # remove dead transitions
        for ffa in a.fillClosure():
            itrns = list(ffa.transitions)
            ffa.transitions.clear()
            for trns in itrns:
                if -1 != FA.getFirstAcceptSymbol(trns.to.fillClosure()):
                    ffa.transitions.append(trns)
        return a
    
    def toMinimizedDfa(self, progress = None):
        return FA._minimize(self, progress)
    
    @staticmethod
    def _concat(lhs, rhs, compact):
        acc = filter(lambda value: value.isAccepting(),lhs.fillClosure())
        for afa in acc:
            afa.acceptSymbol = -1
            afa.addEpsilon(rhs, compact)
    
    def toCompact(self):
        result = self.clone()
        closure = result.fillClosure()
        done = False
        while done == False:
            done = True
            i = 0
            while i < len(closure):
                fa = closure[i]
                j = 0
                while j < len(fa.transitions):
                    fat = fa.transitions[j]
                    if fat.isEpsilon():
                        del fa.transitions[j]
                        j -=1
                        fa.addEpsilon(fat.to)
                        done = False
                        break
                    j += 1
                i += 1
            if done == False:
                closure = closure[0].fillClosure()
                break
            fa.__isCompact = True
        return result
    
    def setIds(self):
        i = 0
        for fa in self.fillClosure():
            fa.id = i
            i += 1
    @staticmethod
    def literal(codepoints, accept = 0, compact = True):
        result = FA()
        current = result
        for cp in codepoints:
            current.acceptSymbol = -1
            newFa = FA()
            newFa.acceptSymbol = accept
            current.addTransition(FARange(cp, cp), newFa, compact)
            current = newFa
        return result
    @staticmethod
    def charset(ranges, accept = 0, compact = True):
        result = FA()
        final = FA(accept)
        l = sorted(ranges)
        for rng in l:
            result.addTransition(rng,final,compact)
        return result
    @staticmethod
    def concat(exprs, accept = 0, compact = True):
        result = None
        left = None
        right = None
        for expr in exprs:
            nval = expr.clone()
            if left is None:
                if result is None:
                    result = nval
                left = nval
                continue
            if right is None:
                right = nval
            
            nval = right.clone()
            FA._concat(left, nval, compact)
        target = result
        if right != None:
            target = right
        
        cl = target.fillClosure()
        for cfa in cl:
            if cfa.acceptSymbol != -1:
                cfa.acceptSymbol = accept
        return result
    @staticmethod
    def union(exprs, accept = 0, compact = True):
        result = FA()
        final = FA()
        final.acceptSymbol = accept
        for expr in exprs:
            nfa = expr.clone()
            nacc = nfa.fillClosure()
            for afa in nacc:
                if afa.acceptSymbol != -1:
                    afa.acceptSymbol = -1
                    afa.addEpsilon(final, compact)
            result.addEpsilon(nfa, compact)
        return result
    @staticmethod 
    def optional(expr, accept = 0, compact = True):
        result = expr.clone()
        acc = result.fillClosure()
        for afa in acc:
            if afa.acceptSymbol != -1:
                afa.acceptSymbol = accept
                result.addEpsilon(afa, compact)
        return result
    @staticmethod
    def repeat(expr, minOccurs = -1, maxOccurs = -1, accept = 0, compact = True):
        DEFAULT_OCCURS = [-1,0]
        expr = expr.clone()
        if minOccurs > 0 and maxOccurs > 0 and minOccurs > maxOccurs:
            raise Exception(""Minimum is greater than maximum"")
        result = None
        match minOccurs:
            case minOccurs if minOccurs in DEFAULT_OCCURS:
                match maxOccurs:
                    case maxOccurs if maxOccurs in DEFAULT_OCCURS:
                        result = FA()
                        result.acceptSymbol = accept
                        result.addEpsilon(expr, compact)
                        for afa in expr.fillClosure():
                            if afa.acceptSymbol != -1:
                                afa.addEpsilon(result, compact)
                        return result
                    case 1:
                        result = FA.optional(expr, accept, compact)
                        return result
                    case _:
                        l = []
                        expr = FA.optional(expr, accept, compact)
                        l.append(expr)
                        i = 1
                        while i < maxOccurs:
                            l.append(expr.clone())
                            i += 1
                        result = FA.concat(l, accept, compact)
                        return result
            case 1:
                match maxOccurs:
                    case maxOccurs if maxOccurs in DEFAULT_OCCURS:
                        result = FA.concat([expr, FA.repeat(expr, 0, 0, accept, compact)], accept, compact)
                        return result
                    case 1:
                        return expr
                    case _:
                        result = FA.concat([expr, FA.repeat(expr, 0, maxOccurs - 1, accept, compact)], accept, compact)
                        return result
            case _:
                match maxOccurs:
                    case maxOccurs if maxOccurs in DEFAULT_OCCURS:
                        result = FA.concat([FA.repeat(expr, minOccurs, minOccurs, accept, compact), FA.repeat(expr, 0, 0, accept, compact)], accept, compact)
                        return result
                    case 1:
                        raise Exception(""Should never get here"")
                    case _:
                        if minOccurs == maxOccurs:
                            l = []
                            expr = FA.optional(expr, accept, compact)
                            l.append(expr)
                            i = 1
                            while i < maxOccurs:
                                l.append(expr.clone())
                                i += 1
                            result = FA.concat(l, accept, compact)
                            return result
                        result = FA.concat([FA.repeat(expr, minOccurs, minOccurs, accept, compact), FA.repeat(FA.optional(expr, accept, compact), maxOccurs - minOccurs, maxOccurs - minOccurs, accept, compact)], accept, compact)
                        return result
    
    def fillInputTransitionRangesGroupedByState(self, includeEpsilonTransitions = False, result = None):
        if result is None:
            result = dict()
        
        for fat in self.transitions:
            if includeEpsilonTransitions or fat.isEpsilon()==False:
                res = result.get(fat.to,None)
                if res is None:
                    ndata = [FARange(fat.min, fat.max)]
                    result[fat.to]= ndata
                else:
                    res.append(FARange(fat.min, fat.max))
            
        for values in result.values():
            values.sort()
        return result
    
    @staticmethod
    def toUtf32(text):
        for s in text:
            yield ord(s)

    def toArray(self):
        fa = self
        result = []
        closure = fa.fillClosure()
        stateIndices = []
        i = 0
        while i < len(closure):
            cfa = closure[i]
            stateIndices.append(len(result))
            result.append(cfa.acceptSymbol)
            itrgp = cfa.fillInputTransitionRangesGroupedByState(True)
            result.append(len(itrgp))
            for itr in itrgp.items():
                result.append(closure.index(itr[0]))
                result.append(len(itr[1]))
                for pack in FARange.toPacked(itr[1]):
                    result.append(pack)
            i += 1
        state = 0
        while state < len(result):
            state += 1
            tlen = result[state]
            state += 1
            i = 0
            while i < tlen:
                result[state] = stateIndices[result[state]]
                state += 1
                prlen = result[state]
                state += 1
                state += prlen * 2
                i += 1
        return result
    @staticmethod
    def fromArray(arr):
        if len(arr)==0:
            return FA()
        
        si = 0
        states = dict()
        while si < len(arr):
            newFa = FA()
            states[si]= newFa
            newFa.acceptSymbol = arr[si]
            si += 1
            tlen = arr[si]
            si += 1
            i = 0
            while i < tlen:
                si += 1 # tto
                prlen = arr[si]
                si += 1
                si += prlen * 2
                i += 1
            
        si = 0
        while si < len(arr):
            state = states.get(si)
            si += 1
            tlen = arr[si]
            si += 1
            i = 0
            while i < tlen:
                tto = arr[si]
                si += 1
                prlen = arr[si]
                si += 1
                to = states.get(tto)
                j = 0
                while j < prlen:
                    min = arr[si]
                    si += 1
                    max = arr[si]
                    si += 1
                    state.addTransition(FARange(min, max), to)
                    j += 1
                i += 1
        return states.get(0)
txt = ""h""
compact = False
first = FA.charset([FARange(ord(""A""),ord(""Z"")),FARange(ord(""a""),ord(""z"")),FARange(ord(""_""),ord(""_""))],0,False)
next = FA.charset([FARange(ord(""A""),ord(""Z"")),FARange(ord(""a""),ord(""z"")),FARange(ord(""_""),ord(""_"")),FARange(ord(""0""),ord(""9""))],0,False)
ident = FA.concat([first,FA.repeat(next,-1,-1,0,False)],0,False)
print(ident.toArray())
print(ident.toDfa().toArray())
print(ident.toMinimizedDfa().toArray())"
dvb0wNFy,2025-07-17_stats.json,rdp_snitch,JSON,Thursday 17th of July 2025 07:18:05 PM CDT,"{
  ""ip"": {
    ""167.71.88.198"": 6,
    ""205.210.31.39"": 9,
    ""164.92.192.11"": 624,
    ""2.57.121.247"": 6,
    ""91.238.181.94"": 6,
    ""91.238.181.95"": 6,
    ""161.35.8.106"": 9,
    ""198.235.24.200"": 9,
    ""206.168.34.40"": 3,
    ""103.77.172.156"": 24,
    ""198.235.24.66"": 9,
    ""162.210.245.77"": 6,
    ""165.154.138.107"": 3,
    ""69.50.95.43"": 9,
    ""104.243.47.203"": 9,
    ""198.235.24.112"": 9
  },
  ""asn"": {
    ""AS14061"": 639,
    ""AS396982"": 36,
    ""AS47890"": 6,
    ""AS49434"": 12,
    ""AS398324"": 3,
    ""AS140810"": 24,
    ""AS397651"": 6,
    ""AS135377"": 3,
    ""AS63023"": 9,
    ""AS23470"": 9
  },
  ""isp"": {
    ""DigitalOcean, LLC"": 639,
    ""Google LLC"": 36,
    ""Unmanaged LTD"": 6,
    ""Datacenter location PAR1 France"": 12,
    ""Censys, Inc."": 3,
    ""LIENVPS"": 24,
    ""RCI Broadband"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""GTHost"": 9,
    ""ReliableSite.Net LLC"": 9
  },
  ""org"": {
    ""DigitalOcean, LLC"": 639,
    ""Palo Alto Networks, Inc"": 36,
    ""Unmanaged LTD"": 6,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""Censys, Inc."": 3,
    ""Lienvps Technology Company Limited"": 24,
    ""10x Servers"": 6,
    ""Ucloud Information Technology (hk) Limited"": 3,
    ""GTHost"": 9,
    ""ReliableSite.Net LLC"": 9
  },
  ""regionName"": {
    ""New Jersey"": 15,
    ""California"": 36,
    ""Hesse"": 627,
    ""England"": 6,
    ""\u00cele-de-France"": 12,
    ""Illinois"": 3,
    ""Ho Chi Minh"": 24,
    ""Virginia"": 6,
    ""Colorado"": 9,
    ""Florida"": 9
  },
  ""country"": {
    ""United States"": 78,
    ""Germany"": 627,
    ""United Kingdom"": 6,
    ""France"": 12,
    ""Vietnam"": 24
  },
  ""account"": {
    ""hello"": 681,
    ""ClanhgLCv"": 3,
    ""ucXFJz"": 3,
    ""aQzqmJ"": 3,
    ""Administr"": 6,
    ""Test"": 18,
    ""YtlqmJFPL"": 3,
    ""ynmTOY"": 3,
    ""KfzTyv"": 3,
    ""(empty)"": 3,
    ""exjtFSZYP"": 3,
    ""aalvsS"": 3,
    ""aKyiiE"": 3,
    ""Administrator"": 3,
    ""thjzTmjid"": 3,
    ""XGSPIu"": 3,
    ""imOJBo"": 3
  },
  ""keyboard"": {
    ""Unknown"": 747
  },
  ""client_build"": {
    ""Unknown"": 747
  },
  ""client_name"": {
    ""Unknown"": 747
  },
  ""ip_type"": {
    ""hosting"": 696,
    ""Unknown"": 9,
    ""mobile"": 24,
    ""proxy"": 6,
    ""hosting & proxy"": 3,
    ""mobile & hosting"": 9
  }
}"
0QrB0jMe,2025-07-17_stats.json,rdp_snitch,JSON,Thursday 17th of July 2025 07:16:17 PM CDT,"{
  ""ip"": {
    ""167.71.88.198"": 4,
    ""205.210.31.39"": 6,
    ""164.92.192.11"": 416,
    ""2.57.121.247"": 4,
    ""91.238.181.94"": 4,
    ""91.238.181.95"": 4,
    ""161.35.8.106"": 6,
    ""198.235.24.200"": 6,
    ""206.168.34.40"": 2,
    ""103.77.172.156"": 16,
    ""198.235.24.66"": 6,
    ""162.210.245.77"": 4,
    ""165.154.138.107"": 2,
    ""69.50.95.43"": 6,
    ""104.243.47.203"": 6,
    ""198.235.24.112"": 6
  },
  ""asn"": {
    ""AS14061"": 426,
    ""AS396982"": 24,
    ""AS47890"": 4,
    ""AS49434"": 8,
    ""AS398324"": 2,
    ""AS140810"": 16,
    ""AS397651"": 4,
    ""AS135377"": 2,
    ""AS63023"": 6,
    ""AS23470"": 6
  },
  ""isp"": {
    ""DigitalOcean, LLC"": 426,
    ""Google LLC"": 24,
    ""Unmanaged LTD"": 4,
    ""Datacenter location PAR1 France"": 8,
    ""Censys, Inc."": 2,
    ""LIENVPS"": 16,
    ""RCI Broadband"": 4,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""GTHost"": 6,
    ""ReliableSite.Net LLC"": 6
  },
  ""org"": {
    ""DigitalOcean, LLC"": 426,
    ""Palo Alto Networks, Inc"": 24,
    ""Unmanaged LTD"": 4,
    ""ThinkTech Technology Industrial CO. Limited"": 8,
    ""Censys, Inc."": 2,
    ""Lienvps Technology Company Limited"": 16,
    ""10x Servers"": 4,
    ""Ucloud Information Technology (hk) Limited"": 2,
    ""GTHost"": 6,
    ""ReliableSite.Net LLC"": 6
  },
  ""regionName"": {
    ""New Jersey"": 10,
    ""California"": 24,
    ""Hesse"": 418,
    ""England"": 4,
    ""\u00cele-de-France"": 8,
    ""Illinois"": 2,
    ""Ho Chi Minh"": 16,
    ""Virginia"": 4,
    ""Colorado"": 6,
    ""Florida"": 6
  },
  ""country"": {
    ""United States"": 52,
    ""Germany"": 418,
    ""United Kingdom"": 4,
    ""France"": 8,
    ""Vietnam"": 16
  },
  ""account"": {
    ""hello"": 454,
    ""ClanhgLCv"": 2,
    ""ucXFJz"": 2,
    ""aQzqmJ"": 2,
    ""Administr"": 4,
    ""Test"": 12,
    ""YtlqmJFPL"": 2,
    ""ynmTOY"": 2,
    ""KfzTyv"": 2,
    ""(empty)"": 2,
    ""exjtFSZYP"": 2,
    ""aalvsS"": 2,
    ""aKyiiE"": 2,
    ""Administrator"": 2,
    ""thjzTmjid"": 2,
    ""XGSPIu"": 2,
    ""imOJBo"": 2
  },
  ""keyboard"": {
    ""Unknown"": 498
  },
  ""client_build"": {
    ""Unknown"": 498
  },
  ""client_name"": {
    ""Unknown"": 498
  },
  ""ip_type"": {
    ""hosting"": 464,
    ""Unknown"": 6,
    ""mobile"": 16,
    ""proxy"": 4,
    ""hosting & proxy"": 2,
    ""mobile & hosting"": 6
  }
}"
F6pkyemB,2025-07-17_stats.json,rdp_snitch,JSON,Thursday 17th of July 2025 07:15:08 PM CDT,
RmPvpsrt,BuildRoomInput Updated 1.7.10 (Fueling),DomMOW,Lua,Thursday 17th of July 2025 06:01:47 PM CDT,"--Min is 3 for H--
lengthMax = 50
widthMax = 3
heightMax = 3
orientation = 4
--N=4, E=3, S=2, W=1--
orientations = {""north"", ""east"", ""south"", ""west""}
startDirection = orientation

xCurrent = 0
zCurrent = 0
yCurrent = 0

xHome = 0
zHome = 0
yHome = 0

xBlackcurrant = 0
zBlackcurrant = 0
yBlackcurrant = 0
orientationLast = orientation

zDiff = {-1, 0, 1, 0}
xDiff = {0, 1, 0 ,-1}

turn = 1
turnLast = turn
lengthCurrent = lengthMax
placeTorch = 10
width = widthMax
finishWalk = widthMax
heightCheck = heightMax
heightMax = heightMax - 3
height = heightMax
ending = false
kill = false
said = false
fuelSaid = false
selectedSlot = 16
answer = ""F""
facingAnswer = 0
torchesGoCheck = ""Pickles""
startUpComplete = false
saidYes = ""Rainbows""
fuelYes = ""Cabbages""
hasTorch = false
lengthSet = 0
widthSet = 0
heightSet = 0
fuelLevel = turtle.getFuelLevel()

function fillFacing()
    print(""Fill in which way I'm facing: "")
    print(""North=4, East=3, South=2, West=1"")
    facingAnswer = tonumber(read())
    while not(facingAnswer == 1 or facingAnswer == 2 or facingAnswer == 3 or facingAnswer == 4) do
        print(""ERROR! Please try again!"")
        print(""Fill in which way I'm facing: "")
        print(""North=4, East=3, South=2, West=1"")
        facingAnswer = tonumber(read())
    end
    orientation = facingAnswer
    startDirection = orientation
    orientationLast = orientation
    shell.run(""clear"")
end

function answerWrong()
    print(""ERROR! Please try again!"")
    print(""Do you want to fill in the dimensions? Type: 'Y' or 'N'"")
    print(""If 'N' then I will use the Default"")
    print(""Default: (L: "" .. lengthMax .. "", W: "" .. widthMax .. "", H: "" .. heightCheck .. "")"")
    answer = read()
    shell.run(""clear"")
end

function runStartup()
    if startUpComplete == false then
        shell.run(""clear"")
        print(""I'm going to build you a room, Master."")
        print("" "")
        print(""Do you want to fill in the dimensions? Type: 'Y' or 'N'"")
        print(""If 'N' then I will use the Default"")
        print(""Default: (L: "" .. lengthMax .. "", W: "" .. widthMax .. "", H: "" .. heightCheck .. "")"")
        answer = read()
        while not(answer == ""Y"" or answer == ""N"") do
            print(""ERROR! Please try again!"")
            print(""Do you want to fill in the dimensions? Type: 'Y' or 'N'"")
            print(""If 'N' then I will use the Default"")
            print(""Default: (L: "" .. lengthMax .. "", W: "" .. widthMax .. "", H: "" .. heightCheck .. "")"")
            answer = read()
            shell.run(""clear"")
        end
        if answer == ""N"" then
            fillFacing()
            heightMax = heightMax + 3
            heightCheck = heightMax
            heightMax = heightMax - 3
            height = heightMax
            startUpComplete = true
        elseif answer == ""Y"" then
            shell.run(""clear"")
            print(""Please Fill the Dimensions!"")
            print("" "")
            print(""Fill in the Length:"")
            lengthSet = tonumber(read())
            lengthMax = lengthSet
            lengthCurrent = lengthMax
            while lengthSet == nil do
                print(""ERROR! Please try again!"")
                print(""Fill in the Length:"")
                lengthSet = tonumber(read())
                lengthMax = lengthSet
                lengthCurrent = lengthMax
                shell.run(""clear"")
            end
            shell.run(""clear"")
            print(""Please Fill the Dimensions!"")
            print("" "")
            print(""Fill in the Width:"")
            widthSet = tonumber(read())
            widthMax = widthSet
            width = widthMax
            while widthSet == nil do
                print(""ERROR! Please try again!"")
                print(""Fill in the Width:"")
                widthSet = tonumber(read())
                widthMax = widthSet
                width = widthMax
                shell.run(""clear"")
            end
            shell.run(""clear"")
            print(""Please Fill the Dimensions!"")
            print("" "")
            print(""Fill in the Height:"")
            heightSet = tonumber(read())
            heightMax = heightSet
            heightCheck = heightMax
            heightMax = heightMax - 3
            height = heightMax
            while heightSet == nil or heightSet < 3 do
                print(""ERROR! Please try again!"")
                print(""Fill in the Height:"")
                heightSet = tonumber(read())
                heightMax = heightSet
                heightCheck = heightMax
                heightMax = heightMax - 3
                height = heightMax
                shell.run(""clear"")
            end
            shell.run(""clear"")
            fillFacing()
            shell.run(""clear"")
            print(""I will now start, Master."")
            print("" "")
            startUpComplete = true
        end
    end
end

function torchGo()
    while not(torchesGoCheck == ""Go"") do
        print(""ERROR! Please try Again"")
        print(""Once I have Torches Type: 'Go'"")
        torchesGoCheck = read()
        shell.run(""clear"")
    end
end

function torchAdded()
    while not(saidYes == ""Y"") do
        shell.run(""clear"")
        print(""ERROR! Please try Again"")
        print(""Once I have Torches, Type: 'Y'"")
        saidYes = read()
    end
end

function saidCheck()
    shell.run(""clear"")
    print(""I need Torches in Slot.1, Master."")
    print(""Once I have Torches Type: 'Y'"")
    saidYes = read()
    torchAdded()
end

function torchCheck()
    while not(turtle.getItemDetail(""minecraft:torch"")) do
        if said == false then
            saidCheck()
            hasTorch = true
        end
    end
    if hasTorch == true then
        shell.run(""clear"")
        print(""I'm Ready, Master. Type: 'Go' to Start"")
        torchesGoCheck = read()
        torchGo()
    end
    shell.run(""clear"")
    hasTorch = false
    said = false
end

function fuelCheck()
	fuelLevel = turtle.getFuelLevel()
    while not(fuelLevel > 0) do
        if fuelSaid == false then
            fuelSaidCheck()
            hasFuel = true
        end
		shell.run(""refuel all"")
		fuelLevel = turtle.getFuelLevel()
    end
    if hasFuel == true then
        shell.run(""clear"")
        print(""I'm Ready, Master. Type: 'Go' to Start"")
        fuelGoCheck = read()
        fuelGo()
    end
    shell.run(""clear"")
    hasFuel = false
    fuelSaid = false
end

function fuelGo()
    while not(fuelGoCheck == ""Go"") do
        print(""ERROR! Please try Again"")
        print(""Once I have Fuel Type: 'Go'"")
        fuelGoCheck = read()
        shell.run(""clear"")
    end
end

function fuelAdded()
    while not(fuelYes == ""Y"") do
        shell.run(""clear"")
        print(""ERROR! Please try Again"")
        print(""Once I have Fuel, Type: 'Y'"")
        fuelYes = read()
    end
end

function fuelSaidCheck()
    shell.run(""clear"")
    print(""I need Fuel, Master."")
	print(""Once I have Fuel Type: 'Y'"")
    fuelYes = read()
    fuelAdded()
end

function left()
  orientation = orientation - 1
  orientation = (orientation - 1) % 4
  orientation = orientation + 1

  turtle.turnLeft()
end

function right()
  orientation = orientation - 1
  orientation = (orientation + 1) % 4
  orientation = orientation + 1

  turtle.turnRight()
end

function look(direction)
    while direction ~= orientations[orientation] do
      right()
    end
end

function moveForward()
  while turtle.detect() do
    turtle.dig()
  end
  moved = false
  while not(moved) do
    moved = turtle.forward()
  end
  xCurrent = xCurrent + xDiff[orientation]
  zCurrent = zCurrent + zDiff[orientation]
end

function digForward()
  while turtle.detect() do
    turtle.dig()
  end
end

function digBelow()
  while turtle.detectDown() do
    turtle.digDown()
  end
end

function digAbove()
  while turtle.detectUp() do
    turtle.digUp()
  end
end

function moveUp()
  turtle.digUp()
  moved = false
  while not(moved) do
    digAbove()
    moved = turtle.up()
  end
  yCurrent = yCurrent + 1
end
  
function moveDown()
  turtle.digDown()
  moved = false
  while not(moved) do
    moved = turtle.down()
  end
  yCurrent = yCurrent - 1
end

function goDown()
  moved = false
  while not(moved) do
    turtle.digDown()  
    moved = turtle.down()
  end
  yCurrent = yCurrent - 1
end
  
function goUp()
    moved = false
    while not(moved) do
        digAbove()
      moved = turtle.up()
    end
    yCurrent = yCurrent + 1
end

function upBreak()
  digAbove()
  goUp()
  digAbove()
end

function leftDig()
  left()
  moveForward()
  digAbove()
  digBelow()
  while height > 0 do
    upBreak()
    height = height - 1
  end
  height = heightMax
  while height > 0 do
    moveDown()
    height = height - 1
  end
  height = heightMax
  left()
end
  
function rightDig()
  right()
  moveForward()
  digAbove()
  digBelow()
  while height > 0 do
    upBreak()
    height = height - 1
  end
  height = heightMax
  while height > 0 do
    moveDown()
    height = height - 1
  end
  height = heightMax
  right()
end

function leftWalk()
  left()
  moveForward()
  digAbove()
  digBelow()
  while height > 0 do
    upBreak()
    height = height - 1
  end
  height = heightMax
  while height > 0 do
    moveDown()
    height = height - 1
  end
  height = heightMax
end
    
function rightWalk()
  right()
  moveForward()
  digAbove()
  digBelow()
  while height > 0 do
    upBreak()
    height = height - 1
  end
  height = heightMax
  while height > 0 do
    moveDown()
    height = height - 1
  end
  height = heightMax
end

function goto(xHome, zHome, yHome)
    while yHome < yCurrent do
        moveDown()
    end
    while yHome > yCurrent do
        moveUp()
    end
    if xHome < xCurrent then
      look(""west"")
      while xHome < xCurrent do
        moveForward()
      end
    end
    if xHome > xCurrent then
      look(""east"")
      while xHome > xCurrent do
        moveForward()
      end
    end
    if zHome < zCurrent then
      look(""north"")
      while zHome < zCurrent do
        moveForward()
      end
    end
    if zHome > zCurrent then
      look(""south"")
      while zHome > zCurrent do
        moveForward()
      end
    end
    while not(orientation == startDirection) do
        right()
    end
end

function dropItems()
    turtle.select(16)
    selectedSlot = 16
    while not(selectedSlot == 1) do
        turtle.drop()
        selectedSlot = selectedSlot - 1
        turtle.select(selectedSlot)
    end
end

function lookLast()
    while not(orientation == orientationLast) do
        right()
    end
end

function dropOff()
    xBlackcurrant = xCurrent
    zBlackcurrant = zCurrent
    yBlackcurrant = yCurrent
    orientationLast = orientation
    turtle.select(16)
    if turtle.getItemCount() > 0 then
        print(""Going to Drop Off"")
        goto(xHome, zHome, yHome)
        dropItems()
        goto(xBlackcurrant, zBlackcurrant, yBlackcurrant)
        lookLast()
    elseif turtle.getItemCount() == 0 then
        turtle.select(1)
    end
end

while true do
  if lengthCurrent > 0 and ending == false then
    runStartup()
    dropOff()
    torchCheck()
	fuelCheck()
    moveForward()
    digAbove()
    digBelow()
    while height > 0 do
      upBreak()
      height = height - 1
    end
    height = heightMax
    while height > 0 do
      moveDown()
      height = height - 1
    end
    height = heightMax
    placeTorch = placeTorch - 1
    lengthCurrent = lengthCurrent - 1
    if placeTorch <= 0 then
      placeTorch = 10
      turtle.placeDown()
    end
  end
  if lengthCurrent <= 0 and turn == 1 and width > 0 then
    width = width - 1
    if width > 0 then
      rightDig()
      lengthCurrent = lengthMax
      turn = 2
      print(""Turned Right"")
    end
  end
  if lengthCurrent <= 0 and turn == 2 and width > 0 then
    width = width - 1
    if width > 0 then
      leftDig()
      lengthCurrent = lengthMax
      turn = 1
      print(""Turned Left"")
    end
  end
  if width <= 0 then
    turnLast = turn
    turn = 3
    ending = true
  end
  if width <= 0 and turn == 3 and ending == true then
    print(""Final Walk Home"")
    goto(xHome, zHome, yHome)
    kill = true
    turn = 4
  end
  if kill == true then
    print(""Killing the Program"")
    error()
  end
end
"
vVSBZJmq,Grid Layout for Kemono.su,miyagawamizu,CSS,Thursday 17th of July 2025 05:52:55 PM CDT,"/* ==UserStyle==
@name           kemono.su/fanbox/
@namespace      https://gist.github.com/MiyagawaMizu
@version        1.0.0
@description    Grid Layout Fix for Kemono.su
@author         Mizu
==/UserStyle== */
@-moz-document url-prefix(""https://kemono.su/"") {
    /* Insert code here... */
    /*     ._expanded_425d1db {
        height: 70vh;
    }

    ._expanded_425d1db img {
        height: 100%;
        width: fit-content;
    } */
    .post__files {
        display: block;
        column-gap: 16px;
        columns: 3; /* change number for how much you want*/
    }

    .post__thumbnail {
        display: block;
        margin-bottom: 16px;
        /*         width: fit-content; */
        width: 100%;
    }
    .post__thumbnail * {
        /*         width: fit-content; */
        width: 100%;
    }

    ._content_59c5c91 a {
        padding: 0;
        margin: 0;
        width: fit-content;
        height: fit-content;
    }

    ._content_59c5c91 p {
        padding: 0;
        margin: 0;
        width: fit-content;
        height: fit-content;
    }

    p:has(br) {
        display: none;
    }

    ul {
        padding: 0;
        margin: 0;
    }

    li {
        display: inline-block;
        width: fit-content;
        margin-right: 16px;
    }

    video {
        width: 60vh !important;
    }
}"
LwK70Vvz,2025-07-18T00:50:52.165908,powerampache,PHP,Thursday 17th of July 2025 05:50:50 PM CDT,"1.01-80 (80) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""Connection reset"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

"
fU1smUiD,Untitled,bhgek,C++,Thursday 17th of July 2025 04:49:31 PM CDT,"IP Address	92.53.12.99
Country 
North Macedonia, Bardovci   FAKE VIPER
Browser	Samsung Browser (28.0)
Operating System	Android 10
User Agent	Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/28.0 Chrome/130.0.0.0 Mobile Safari/537.36

paste for /planning

Admin Wifi Mater Router--

WIFI ROUTER---

ID: 91231VZC25Q121
Password: Dnzmaiwjdla
Encrypted Data May Be Secure At All Time
Security Question: Name OF DOG: Rachel
Admin Password GartaNCEMenidi
Id:8f371218-2b6e-4332-9592-434a9a19bfff 
Name: Maria Wotkins

Brand--
a1 makedonija telefoni

Names---
Mom- Unkown ( I have the details )
DAD- Unkown ( I have the details )"
PxngcTkw,Untitled,execution88,Pawn,Thursday 17th of July 2025 04:02:33 PM CDT,"stock Quest:GenerateSapiJson()
{
	SAPI:CreateInsert(""quests"");
    new buffer[10000];

    strcpy(sapi_query_str, ""{"");

    strcpy(buffer, ""{"");
    QuestCategoryDataQuest:GetListSapiJson(buffer, 10000);

    QuestCategoryDataQuest:GetListSapiJson(sapi_query_str, SAPI_INSERT_QUERY_LEN);
    strcpy(buffer, "","");
	strcat(sapi_query_str, "","");

    strcpy(buffer, ""\""quest_list\"":["");
    strcat(sapi_query_str, ""\""quest_list\"":["");
    
	for (new QUEST_CATEGORY:category = QUEST_CATEGORY:0; category < MAX_QUEST_CATEGORY; ++category) 
    {
        if (!QuestCategoryDataCategory:IsInit(category))
        {
            continue;
        }
        
        if (_:category != 0 && QuestCategoryDataQuest:IsInit(category, 0))
        {
            strcat(sapi_query_str, "","");
            strcat(buffer, "","");
        }

        new count;

        for (new quest_id = 0; quest_id < MAX_CATEGORY_QUEST; ++quest_id) 
        {
            if (!QuestCategoryDataCategory:IsValid(category) || !QuestCategoryDataQuest:IsValid(quest_id) || !QuestCategoryDataQuest:IsInit(category, quest_id))
            {
                break;
            }

            QuestCategoryDataQuest:GetSapiJson(category, quest_id, sapi_query_str, count, SAPI_INSERT_QUERY_LEN);
            QuestCategoryDataQuest:GetSapiJson(category, quest_id, buffer, count,10000);

            // if (strlen(sapi_query_str) > 8000)
            // {
            //     sapi_query_str[strlen(sapi_query_str) - 1] = EOS;
            //     buffer[strlen(buffer) - 1] = EOS;
            //     SAPI:SendSingleInsert(sapi_query_str);
            // }

            count ++;
        }
    }

    strcat(buffer, ""]"");
    strcat(buffer, "","");
    strcat(sapi_query_str, ""]"");
    strcat(sapi_query_str, "","");
    if (strlen(sapi_query_str) > 8000)
    {
        // sapi_query_str[strlen(sapi_query_str) - 1] = EOS;
        // buffer[strlen(buffer) - 1] = EOS;
        SAPI:AddInsertJson(sapi_query_str);
        sapi_query_str[0] = EOS;
        SendConsoleQuestDebug(""OTRABOTALOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO #2"", -1);
        SendConsoleQuestDebug(buffer, -1);
    }
    QuestCategoryDataBonus:GetSapiJson(buffer);
    QuestCategoryDataBonus:GetSapiJson(sapi_query_str);
    
    strcat(buffer, "","");
    strcat(sapi_query_str, "","");
    // CHAPTER
    QuestChapterDataChapter:GetSapiJson(sapi_query_str);
    QuestChapterDataChapter:GetSapiJson(buffer);
    strcat(buffer, "","");
    strcat(sapi_query_str, "","");
    if (strlen(sapi_query_str) > 8000)
    {
        buffer[strlen(buffer) - 1] = EOS;
        sapi_query_str[strlen(sapi_query_str) - 1] = EOS;
        SAPI:SendSingleInsert(sapi_query_str);
        SendConsoleQuestDebug(""ОТРАБОТААААААААААААААААААААААААААААААААААААААААААААААААААЛО #2"", -1);
    }

    strcat(buffer, ""\""chapter_quest_list\"":["");
    strcat(sapi_query_str, ""\""chapter_quest_list\"":["");

    for (new QUEST_CHAPTER:chapter = QUEST_CHAPTER:0; chapter < MAX_QUEST_CHAPTER; ++chapter) 
    {
        if (!QuestChapterDataChapter:IsInit(chapter))
        {
            break;
        }

        if (_:chapter != 0)
        {
            strcat(sapi_query_str, "","");
            strcat(buffer, "","");
        }
        
        for (new quest_id = 0; quest_id < MAX_CHAPTER_QUEST; ++quest_id) 
        {
            if (!QuestChapterDataQuest:IsInit(chapter, quest_id))
            {
                break;
            }

            QuestChapterDataQuest:GetSapiJson(chapter, quest_id, buffer, 10000);
            QuestChapterDataTask:GetSapiJson(chapter, quest_id, buffer, 10000);

            QuestChapterDataQuest:GetSapiJson(chapter, quest_id, sapi_query_str, SAPI_INSERT_QUERY_LEN);
            QuestChapterDataTask:GetSapiJson(chapter, quest_id, sapi_query_str, SAPI_INSERT_QUERY_LEN);

            strcat(buffer, "","");
            QuestChapterDataReward:GetListJson(chapter, quest_id, buffer, 10000);
            strcat(buffer, ""}"");

            strcat(sapi_query_str, "","");
            QuestChapterDataReward:GetListJson(chapter, quest_id, sapi_query_str, SAPI_INSERT_QUERY_LEN);
            strcat(sapi_query_str, ""}"");

            if (strlen(sapi_query_str) > 8000)
            {
                sapi_query_str[strlen(sapi_query_str) - 1] = EOS;
                buffer[strlen(buffer)] = EOS;
                SAPI:SendSingleInsert(sapi_query_str);
                SendConsoleQuestDebug(""ОТРАБОТААААААААААААААААААААААААААААААААААААААААААААААААААЛО #3"", -1);
            }
        }
	}

    strcat(sapi_query_str, ""]"");
    strcat(sapi_query_str, ""}"");
    strcat(buffer, ""]"");
    // strcat(buffer, ""}"");

    SendConsoleQuestDebug(""[QUEST]============================================"", -1);
    SendConsoleQuestDebug(buffer, -1);
    if (sapi_query_str[0] != EOS)
    {
	    SAPI:SendSingleInsert(sapi_query_str);
    }

	SAPI:Request(SAPI:JsonTablePurge, .key = ""quests"", .await_queries_handle = connection[HANDLE_GENERAL]);
}"
mkuDXTUV,asdasd,RiseAboveHate,Lua,Thursday 17th of July 2025 03:49:57 PM CDT,"-- dns_client.lua


local modemSide = ""left""


while not peripheral.isPresent(modemSide) or peripheral.getType(modemSide) ~= ""modem"" do
  print(""Waiting for modem on side '"" .. modemSide .. ""'..."")
  sleep(1)
end


rednet.open(modemSide)
print(""Rednet opened on side '"" .. modemSide .. ""'"")


local myName = ""webServer""


while peripheral.isPresent(modemSide) do
  -- 4a) בקשה לקבלת IP ייחודי
  rednet.broadcast({ cmd = ""requestIP"", name = myName }, ""DNS"")
  local sender, reply = rednet.receive(""DNS"", 5)

  if reply and reply.ip then
    print(""Assigned IP:"", reply.ip)
  else
    print(""Registration failed, retrying in 5 seconds..."")
    sleep(5)
    goto continue
  end


  write(""Enter hostname to resolve (or leave blank to skip): "")
  local target = read()
  if target ~= """" then
    rednet.broadcast({ cmd = ""resolve"", name = target }, ""DNS"")
    local _, r2 = rednet.receive(""DNS"", 5)
    if r2 and r2.ip then
      print(target .. "" → "" .. r2.ip)
    else
      print(""No record for '"" .. target .. ""'"")
    end
  end

  ::continue::
  -- 4c) המתן קצת לפני הלולאה הבאה
  sleep(2)
end

print(""Modem disconnected; client stopping."")  
"
hVAmb8aY,dns_server.lua,RiseAboveHate,Lua,Thursday 17th of July 2025 03:36:24 PM CDT,"-- dns_server.lua
-- שרת ראשי של ה־DNS, רץ על מחשב עם מודם

local modemSide = ""back""
rednet.open(modemSide)

-- קונפיגורציה של A ו‑B
local A = 5
local B = 29

-- אתחול מספור X
local nextID = 2

-- טבלת DNS (hostname → IP)
local dnsTable = {}

-- אתחול מחולל אקראיות
math.randomseed(os.time())

print(""DNS server listening…"")
while true do
  -- מקבלים הודעה מסוג טבלה בפרוטוקול ""DNS""
  local senderID, msg = rednet.receive(""DNS"")
  if type(msg) == ""table"" and msg.cmd then

    if msg.cmd == ""requestIP"" then
      local host = msg.name
      if not dnsTable[host] then
        -- בוחרים Y רנדומלי בין 100 ל־250
        local zone = math.random(100, 250)
        -- בונים IP בפורמט 5.29.Y.X
        local ip = string.format(""%d.%d.%d.%d"", A, B, zone, nextID)
        nextID = nextID + 1
        dnsTable[host] = ip
        print(""Registered"", host, ""→"", ip)
      end
      -- שולחים בחזרה את ה‑IP (חדש או קיים)
      rednet.send(senderID, { ip = dnsTable[host] }, ""DNS"")

    elseif msg.cmd == ""resolve"" then
      -- מחזירים IP של hostname קיים (או nil אם לא נמצא)
      rednet.send(senderID, { ip = dnsTable[msg.name] }, ""DNS"")

    elseif msg.cmd == ""list"" then
      -- שולחים את כל הטבלה
      rednet.send(senderID, { table = dnsTable }, ""DNS"")
    end
  end
end
"
vvg5XAvH,dns_client.lua,RiseAboveHate,Lua,Thursday 17th of July 2025 03:35:33 PM CDT,"-- dns_client.lua
-- לקוח DNS, רץ על כל מחשב ברשת עם מודם

local modemSide = ""left""
rednet.open(modemSide)

-- שם ייחודי עבור המחשב הזה
local myName = ""webServer""

-- 1) בקשה לקבלת IP
rednet.broadcast({ cmd = ""requestIP"", name = myName }, ""DNS"")
local _, reply = rednet.receive(""DNS"", 5)
if reply and reply.ip then
  print(""Assigned IP:"", reply.ip)
  local myIP = reply.ip

  -- 2) דוגמה לפיתרון שם של מחשב אחר
  local targetName = ""database""
  rednet.broadcast({ cmd = ""resolve"", name = targetName }, ""DNS"")
  local _, r2 = rednet.receive(""DNS"", 5)
  if r2 and r2.ip then
    print(targetName, ""→"", r2.ip)
  else
    print(""No record for"", targetName)
  end

else
  print(""Failed to register with DNS server."")
end
"
px3X1ZJW,B-Tree using open content,ouija_bh,JavaScript,Thursday 17th of July 2025 03:02:54 PM CDT,"/* An implementation of B-Tree. It has tree methods add, remove, findGE, 
 * findLT, iteratorGE, @@iterator, size, clear, and toString. Ported from 
 * Open Data Structures by Pat Morin. Includes a short demonstration of 
 * those methods.
 */

/** A list of blocks used to simulate external memory storage. credit: Morin BlockStore.java. */
class BlockStore {
  constructor() {
    this.blocks = new Array();  // array of BTNode's
    this.free = new Array();    // array of indexes of available blocks
  }
  
  /** placeBlock() Allocate a new block and return its index.
   * @param {BTNode} block the new block
   * @returns {number} the index of the newly allocated block
   */
  placeBlock(block) {
    var ndx;
    if (this.free.length > 0) { ndx = this.free.pop(); }
    else { ndx = this.blocks.length; }
    this.blocks[ndx] = block;
    return ndx;
  }
  
  /** freeBlock() Free a block, adding its index to the free list.
   * @param {number} ndx the block index to free
   */
  freeBlock(ndx) {
    this.blocks[ndx] = undefined;
    this.free.push(ndx);
  }
  
  /** readBlock() Read a block.
   * @param {number} ndx the index of the block to read
   * @returns {BTNode} the block
   */
  readBlock(ndx) {
    return this.blocks[ndx];
  }
  
  /** writeBlock() Write a block.
   * @param {number} ndx the index of the block
   * @param {BTNode} block the block
   */
  writeBlock(ndx, block) {
    this.blocks[ndx] = block;
  }
  
  clear() {
    this.blocks.length = 0;
    this.free.length = 0;
  }
}

/** Properties of a BTree. */
class BTProps {
  bkSz;     // block size
  hfBS;     // half of block size
  bkSr;     // block store
  rootNdx;  // index of the root node
  numEl;    // number of elements stored in the tree
  compare;  // comparator function
}

/** findIt() Find the index at which a value should be inserted into an 
 *  undefined-padded sorted array. credit: Morin BTree.java.
 * @param {Array} array the sorted array (padded with undefined entries)
 * @param {any} value the value to search for
 * @param {function} comparator function taking (any, any) and returning -1, 0, or 1
 * @returns index or (-index - 1) if array[index] equals value
 */
function findIt(array, value, comparator) {
  var lo = 0, hi = array.length;
  while (hi != lo) {
    var mid = Math.floor((hi + lo) / 2);
    var cmp;
    if (array[mid] == undefined) { cmp = -1; }
    else { cmp = comparator(value, array[mid]); }
    if (cmp < 0) {
      hi = mid;      // look in first half
    } else if (cmp > 0) {
      lo = mid + 1;    // look in second half
    } else {
      return -mid - 1; // found it
    }
  }
  return lo;
}

/** A node in a BTree, or a block in a BlockStore. Has an array of up to bkSz 
 *  keys and up to (bkSz + 1) children. credit: Morin BTree.java Node.
 */
class BTNode {
  index;    // this block's index
  keys;     // array of any
  children; // array of indexes of the children of this block (if any)
  bp;   // BTProps
  /** constructor()
   * @param {BTProps} bp properties of the BTree
   */
  constructor(bp) {
    this.bp = bp;
    this.keys = new Array(this.bp.bkSz);
    this.children = new Array(this.bp.bkSz + 1);
    this.children.fill(-1);
    this.index = bp.bkSr.placeBlock(this);
  }

  /** isLeaf()
   * @returns {boolean}
   */
  isLeaf() {
    return this.children[0] < 0;
  }

  /** isFull() Test if this block is full (contains bkSz keys).
   * @returns {boolean} true if the block is full
   */
  isFull() {
    return this.keys[this.keys.length - 1] != undefined;
  }

  /** size() Count the number of keys in this block, using binary search.
   * @returns {number} the number of keys in this block
   */
  size() {
    var lo = 0, hi = this.keys.length;
    while (hi != lo) {
      var mid = Math.floor((hi + lo) / 2);
      if (this.keys[mid] == undefined) { hi = mid; }
      else { lo = mid + 1; }
    }
    return lo;
  }

  /** add() Add a value to this block.
   * @param {any} value the value to add
   * @param {number} cIndex the index of the child associated with value
   * @returns {boolean} true on success or false if value was not added
   */
  add(value, cIndex) {
    var i = findIt(this.keys, value, this.bp.compare);
    if (i < 0) { return false; }
    if (i < this.keys.length - 1) {
      this.keys = this.keys.copyWithin(i + 1, i, this.bp.bkSz - 1);
    }
    this.keys[i] = value;
    if (i < this.keys.length - 1) {
      this.children = this.children.copyWithin(i + 2, i + 1, this.bp.bkSz);
    }
    this.children[i + 1] = cIndex;
    return true;
  }
  
  /** remove() Remove value at given index from this block. Does not affect 
   *  this block's children.
   * @param {number} index the index of the element to remove
   * @returns {any} the value of the element removed
   */
  remove(index) {
    var value = this.keys[index];
    this.keys = this.keys.copyWithin(index, index + 1, this.keys.length);
    this.keys[this.keys.length - 1] = undefined;
    return value;
  }
  
  /** split() Split this node into two nodes.
   * @returns {BTNode} the newly created block, which has the larger keys
   */
  split() {
    var block = new BTNode(this.bp);
    var mid = this.bp.hfBS;
    var larger = this.keys.slice(mid);
    block.keys.splice(0, larger.length, ...larger);
    this.keys.fill(undefined, mid);
    larger = this.children.slice(mid + 1);
    block.children.splice(0, larger.length, ...larger);
    this.children.fill(-1, mid + 1);
    this.bp.bkSr.writeBlock(this.index, this);
    return block;
  }

  /** toString()
   * @returns {string} this node as a string
   */
  toString() {
    var str = ""["" + this.index + ""]["";
    for (var i = 0; i < this.bp.bkSz; i++) {
      str += ""("";
      if (this.children[i] < 0) { str += "".""; }
      else { str += this.children[i]; }
      str += "")"";
      if (this.keys[i] == undefined) { str += ""_""; }
      else { str += this.keys[i]; }
    }
    str += ""("";
    if (this.children[this.bp.bkSz] < 0) { str += "".""; }
    else { str += this.children[this.bp.bkSz]; }
    str += "")]"";
    return str;
  }
}

/** Iterator of BTree. credit: Morin BTree.java. */
class BTIterator {
  #nodeSk;   // stack of BTNode's
  #indexSk;  // stack of indexes
  bp;   // BTProps
  /** #iterator() Iterator will contain all elements. */
  #iterator() {
    if (this.bp.numEl == 0) { return; }
    var cur = this.bp.rootNdx;
    do {
      var block = this.bp.bkSr.readBlock(cur);
      this.#nodeSk.push(block);
      this.#indexSk.push(0);
      cur = block.children[0];
    } while (cur >= 0);
  }
  
  #advance() {
    var block = this.#nodeSk[this.#nodeSk.length - 1];
    var i = this.#indexSk[this.#indexSk.length - 1];
    if (block.isLeaf()) { // this is a leaf, walk up
      while (this.#nodeSk.length > 0 && i == block.size()) {
        this.#nodeSk.pop();
        this.#indexSk.pop();
        if (this.#nodeSk.length > 0) {
          block = this.#nodeSk[this.#nodeSk.length - 1];
          i = this.#indexSk[this.#indexSk.length - 1];
        }
      }
    } else { // this is an internal node, walk down
      var cur = block.children[i];
      do {
        block = this.bp.bkSr.readBlock(cur);
        this.#nodeSk.push(block);
        this.#indexSk.push(0);
        cur = block.children[0];
      } while (cur >= 0);
    }
  }

  /** constructor() Create an iterator starting with the smallest element in the 
   *  tree that is greater than or equal to value. If value is undefined, create 
   *  an iterator starting with the smallest element in the tree.
   * @param {BTProps} bp properties of the BTree
   * @param {any} value the value
   */
  constructor(bp, value) {
    this.#nodeSk = new Array();
    this.#indexSk = new Array();
    this.bp = bp;
    
    if (this.bp.numEl == 0) { return; }
    if (value == undefined) {
      this.#iterator();
    } else {
      var block, i, cur = this.bp.rootNdx;
      do {
        block = this.bp.bkSr.readBlock(cur);
        i = findIt(block.keys, value, this.bp.compare);
        this.#nodeSk.push(block);
        if (i < 0) {  // found the value, add its index and stop
          this.#indexSk.push(-(i + 1));
          return;
        }
        this.#indexSk.push(i);  // add index of smallest value
        cur = block.children[i];
      } while (cur >= 0);
      if (i == block.size()) { this.#advance(); }
    }
  }

  /** hasNext()
   * @returns {boolean}
   */
  hasNext() {
    return this.#nodeSk.length > 0;
  }

  /** next()
   * @returns {any}
   */
  next() {
    var block = this.#nodeSk[this.#nodeSk.length - 1];
    var i = this.#indexSk[this.#indexSk.length - 1];
    var value = block.keys[i++];
    this.#indexSk[this.#indexSk.length - 1] = i;
    this.#advance();
    return value;
  }
}

/** A simple string buffer. */
class StringBuffer {
  str = """";
}

/** A sorted set. credit: Morin SSet.java, BTree.java. */
class BTree {
  /** constructor()
   * @param {number} blockSize maximum number of children of a node
   * @param {function} comparator function taking (any, any) and returning -1, 0, or 1
   */
  constructor(blockSize, comparator) {
    this.bp = new BTProps();
    blockSize += 1 - (blockSize % 2); // an odd number
    this.bp.bkSz = blockSize;
    this.bp.hfBS = Math.floor(blockSize / 2);
    this.bp.bkSr = new BlockStore();
    this.bp.numEl = 0;
    this.bp.rootNdx = (new BTNode(this.bp)).index;
    this.bp.compare = comparator;
  }

  /** #addRecursive() Add a value to the subtree rooted at the node at given index. 
   *  If that node is split by this operation then the return value is the BTNode 
   *  that was created when node was split.
   * @param {any} value the element to add
   * @param {number} index the index of the node at which to add value
   * @returns {BTNode} a new node that was created when node was split, or 
   *            undefined if node was not split
   */
  #addRecursive(value, index) {
    if (value == undefined) { throw new Error(""undefined value""); }
    var block = this.bp.bkSr.readBlock(index); // BTNode
    var i = findIt(block.keys, value, this.bp.compare);
    if (i < 0) { throw new Error(""duplicate value""); }
    if (block.children[i] < 0) { // leaf node, just add it
      block.add(value, -1);
      this.bp.bkSr.writeBlock(block.index, block);
    } else {
      var newBk = this.#addRecursive(value, block.children[i]);  // BTNode
      if (newBk != undefined) {  // child was split, newBk is new child
        value = newBk.remove(0);
        this.bp.bkSr.writeBlock(newBk.index, newBk);
        block.add(value, newBk.index);
        this.bp.bkSr.writeBlock(block.index, block);
      }
    }
    if (block.isFull()) { return block.split(); }
    return undefined;
  }
  
  /** add() Add a value to this tree.
   * @param {any} value the element to add
   * @returns {boolean} true if value was added, or false if value was already 
   *            in the set or value is undefined
   */
  add(value) {
    var block;  // BTNode
    try {
      block = this.#addRecursive(value, this.bp.rootNdx);
    } catch (err) {
      console.error(""BTree.add() "" + err.message);
      return false;
    }
    if (block != undefined) {   // root was split, make new root
      var newRoot = new BTNode(this.bp);
      value = block.remove(0);
      this.bp.bkSr.writeBlock(block.index, block);
      newRoot.children[0] = this.bp.rootNdx;
      newRoot.keys[0] = value;
      newRoot.children[1] = block.index;
      this.bp.rootNdx = newRoot.index;
      this.bp.bkSr.writeBlock(this.bp.rootNdx, newRoot);
    }
    this.bp.numEl++;
    return true;
  }
  
  /** #merge() Node H will absorb node I.
   * @param {BTNode} block the parent of H and I
   * @param {number} h the index h in block.children
   * @param {BTNode} bkH the left sibling of I
   * @param {BTNode} bkI the right sibling of H
   */
  #merge(block, h, bkH, bkI) {
    if (bkH.index != block.children[h]) { throw new Error(""assert: H mismatch""); }
    if (bkI.index != block.children[h + 1])  { throw new Error(""assert: I mismatch""); }
    var sizeI = bkI.size();
    var sizeH = bkH.size();
    // copy keys from I to H
    var smaller = bkI.keys.slice(0, sizeI);
    bkH.keys.splice(sizeH + 1, smaller.length, ...smaller);
    smaller = bkI.children.slice(0, sizeI + 1);
    bkH.children.splice(sizeH + 1, smaller.length, ...smaller);
    // add key to H and remove it from block
    bkH.keys[sizeH] = block.keys[h];
    block.keys = block.keys.copyWithin(h, h + 1, this.bp.bkSz);
    block.keys[this.bp.bkSz - 1] = undefined;
    block.children = block.children.copyWithin(h + 1, h + 2, this.bp.bkSz + 1);
    block.children[this.bp.bkSz] = -1;
    this.bp.bkSr.freeBlock(bkI.index);
  }
  
  /** #shiftRtoL() Shift keys from node J into node I.
   * @param {BTNode} block the parent of J and I
   * @param {number} i the index i in block.children
   * @param {BTNode} bkJ the right sibling of I
   * @param {BTNode} bkI the left sibling of J
   */
  #shiftRtoL(block, i, bkJ, bkI) {
    var sizeI = bkI.size();
    var sizeJ = bkJ.size();
    var shift = Math.floor((sizeI + sizeJ) / 2) - sizeI;  // num. keys to shift from J to I
    // shift keys and children from J to I
    bkI.keys[sizeI] = block.keys[i];
    var smaller = bkJ.keys.slice(0, shift - 1);
    bkI.keys.splice(sizeI + 1, smaller.length, ...smaller);
    smaller = bkJ.children.slice(0, shift);
    bkI.children.splice(sizeI + 1, smaller.length, ...smaller);
    block.keys[i] = bkJ.keys[shift - 1];
    // delete keys and children from J
    bkJ.keys = bkJ.keys.copyWithin(0, shift, this.bp.bkSz);
    bkJ.keys.fill(undefined, sizeJ - shift, this.bp.bkSz);
    bkJ.children = bkJ.children.copyWithin(0, shift, this.bp.bkSz + 1);
    bkJ.children.fill(-1, sizeJ - shift + 1, this.bp.bkSz + 1);
  }

  /** #checkUnderflowZero() Check if an underflow has occured in the i'th 
   *  child of block and, if so, fix it.
   * @param {BTNode} block block to check
   * @param {number} i the index i in block.children
   */
  #checkUnderflowZero(block, i) {
    var bkI = this.bp.bkSr.readBlock(block.children[i]);  // i'th child of block
    if (bkI.size() < this.bp.hfBS - 1) {  // underflow at I
      var bkJ = this.bp.bkSr.readBlock(block.children[i + 1]); // J right of I
      if (bkJ.size() > this.bp.hfBS) { // I can borrow from J
        this.#shiftRtoL(block, i, bkJ, bkI);
      } else { // I will absorb J
        this.#merge(block, i, bkI, bkJ);
        block.children[i] = bkI.index;
      }
    }
  }

  /** #shiftLtoR() Shift keys from node H into node I.
   * @param {BTNode} block the parent of H and I
   * @param {number} h the index h in block.children
   * @param {BTNode} bkH the left sibling of I
   * @param {BTNode} bkI the right sibling of H
   */
  #shiftLtoR(block, h, bkH, bkI) {
    var sizeI = bkI.size();
    var sizeH = bkH.size();
    var shift = Math.floor((sizeI + sizeH) / 2) - sizeI;  // num. keys to shift from H to I
    // make space for new keys in I
    bkI.keys = bkI.keys.copyWithin(shift, 0, sizeI);
    bkI.children = bkI.children.copyWithin(shift, 0, sizeI + 1);
    // move keys and children out of H and into I (and parent)
    bkI.keys[shift - 1] = block.keys[h];
    block.keys[h] = bkH.keys[sizeH - shift];
    var larger = bkH.keys.slice(sizeH - shift + 1, sizeH);
    bkI.keys.splice(0, larger.length, ...larger);
    bkH.keys.fill(undefined, sizeH - shift, sizeH);
    larger = bkH.children.slice(sizeH - shift + 1, sizeH + 1);
    bkI.children.splice(0, larger.length, ...larger);
    bkH.children.fill(-1, sizeH - shift + 1, sizeH + 1);
  }

  /** #checkUnderflowNonZero() Check if an underflow has occured in the i'th 
   *  child of block and, if so, fix it.
   * @param {BTNode} block block to check
   * @param {number} i the index i in block.children
   */
  #checkUnderflowNonZero(block, i) {
    var bkI = this.bp.bkSr.readBlock(block.children[i]);  // i'th child of block
    if (bkI.size() < this.bp.hfBS - 1) {  // underflow at I
      var bkH = this.bp.bkSr.readBlock(block.children[i - 1]); // H left of I
      if (bkH.size() > this.bp.hfBS) {  // I can borrow from H
        this.#shiftLtoR(block, i - 1, bkH, bkI);
      } else {  // H will absorb I
        this.#merge(block, i - 1, bkH, bkI);
      }
    }
  }
  
  /** #checkUnderflow() Check if an underflow has occurred in the i'th child 
   *  of block and, if so, fix it by borrowing from or merging with a sibling.
   * @param {BTNode} block block to check
   * @param {number} i the index i in block.children
   */
  #checkUnderflow(block, i) {
    if (block.children[i] < 0) { return; }
    if (i == 0) {
      this.#checkUnderflowZero(block, i); // use block's right sibling
    } else {
      this.#checkUnderflowNonZero(block, i);
    }
  }
  
  /** #removeSmallest() Remove the smallest value in the subtree rooted at the 
   *  node with index.
   * @param {number} index the index of a subtree
   * @returns {any} the value that was removed
   */
  #removeSmallest(index) {
    var block = this.bp.bkSr.readBlock(index);
    if (block.isLeaf()) { return block.remove(0); }
    var left = this.#removeSmallest(block.children[0]);
    this.#checkUnderflow(block, 0);
    return left;
  }

  /** #removeRecursive() Remove the value from the subtree rooted at the node with index.
   * @param {any} value the value to remove
   * @param {number} index the index of the subtree to remove value from
   * @returns {boolean} true if value was removed and false otherwise
   */
  #removeRecursive(value, index) {
    if (index < 0) { return false; }  // didn't find it
    var block = this.bp.bkSr.readBlock(index);
    var i = findIt(block.keys, value, this.bp.compare);
    if (i < 0) { // found it
      i = -(i + 1);
      if (block.isLeaf()) {
        block.remove(i);
      } else {
        block.keys[i] = this.#removeSmallest(block.children[i + 1]);
        this.#checkUnderflow(block, i + 1);
      }
      return true;
    } else if (this.#removeRecursive(value, block.children[i])) {
      this.#checkUnderflow(block, i);
      return true;
    }
    return false;
  }

  /** remove() Remove a value from this tree.
   * @param {any} value the value
   * @returns {boolean} true if value was removed and false if value 
   *            was not removed (because value was not present)
   */
  remove(value) {
    if (this.#removeRecursive(value, this.bp.rootNdx)) {
      this.bp.numEl--;
      var rootBk = this.bp.bkSr.readBlock(this.bp.rootNdx);
      if (rootBk.size() == 0 && this.bp.numEl > 0) { // root has only one child
        this.bp.rootNdx = rootBk.children[0];
      }
      return true;
    }
    return false;
  }

  /** findGE() Find the smallest element in the tree that is greater than or equal 
   *  to value. If value is undefined, return the smallest element in the tree.
   * @param {any} value the value
   * @returns {any} the smallest element in the tree that is greater than or equal to
   *            value or undefined if no such element exists. If value is undefined 
   *            then the smallest element in the tree
   */
  findGE(value) {
    var last = undefined;
    var cur = this.bp.rootNdx;
    while (cur >= 0) {
      var block = this.bp.bkSr.readBlock(cur);
      var i = findIt(block.keys, value, this.bp.compare);
      if (i < 0) { return block.keys[-(i + 1)]; } // found it
      if (block.keys[i] != undefined) { last = block.keys[i]; }
      cur = block.children[i];
    }
    return last;
  }

  /** findLT() Find the largest element in the tree that is less than value. 
   *  If value is undefined, return the smallest element in the tree.
   * @param {any} value the value
   * @returns {any} the largest element in the tree that is less than value. If 
   *          value is undefined then the smallest element in the tree
   */
  findLT(value) {
    var last = undefined;
    var cur = this.bp.rootNdx;
    while (cur >= 0) {
      var block = this.bp.bkSr.readBlock(cur);
      var i = findIt(block.keys, value, this.bp.compare);
      if (i < 0) { i = -(i + 1); }
      if (i > 0) { last = block.keys[i - 1]; }
      cur = block.children[i];
    }
    return last;
  }
  
  /** comparator()
   * @returns {function} the comparator of this tree's elements
   */
  comparator() {
    return this.bp.compare;
  }

  /** iteratorGE() Get an iterator of this tree starting with the smallest element 
   *  in the tree that is greater than or equal to value. If value is undefined, 
   *  returns iterator starting with the smallest element in the tree.
   * @param {any} value the value
   * @returns {BTIterator} iterator starting with the smallest element in the 
   *              tree that is greater than or equal to value. If value is undefined, 
   *              iterator starting with the smallest element in the tree.
   */
  iteratorGE(value) {
    return new BTIterator(this.bp, value);
  }

  /** @@iterator() Get an iterator of this tree. */
  *[Symbol.iterator]() {
    var iter = new BTIterator(this.bp, undefined);
    while (iter.hasNext()) {
      yield iter.next();
    }
  }

  /** size()
   * @returns {number} the number of elements in this tree.
   */
  size() {
    return this.bp.numEl;
  }

  /** clear() Remove all elements from this tree. */
  clear() {
    this.bp.numEl = 0;
    this.bp.bkSr.clear();
    this.bp.rootNdx = (new BTNode(this.bp)).index;
  }

  /** #toString() Converts a tree to a string using recursion.
   * @param {number} index index of block
   * @param {StringBuffer} sBuf string buffer
   */
  #toString(index, sBuf) {
    if (index < 0) { return; }
    var block = this.bp.bkSr.readBlock(index);
    var i = 0;
    while(i < this.bp.bkSz && block.keys[i] != undefined) {
      this.#toString(block.children[i], sBuf);
      sBuf.str += block.keys[i++] + "", "";
    }
    this.#toString(block.children[i], sBuf);
  }

  /** toString() Converts this tree to a string.
   * @returns {string} this tree as a string
   */
  toString() {
    if (this.bp.numEl == 0) { return """"; }
    var sBuf = new StringBuffer();
    this.#toString(this.bp.rootNdx, sBuf);
    return sBuf.str.slice(0, sBuf.str.length - 2);
  }

  /** toString2()
   * @returns {string} in-order values formatted as array
   */
  toString2() {
    return JSON.stringify([...this]);
  }
  
  /** blocksToString()
   * @returns {string} this tree's blocks as a string
   */
  blocksToString() {
    var str = ""blocks"";
    for (var i = 0; i < this.bp.bkSr.blocks.length; i++) {
      if (this.bp.bkSr.blocks[i] != undefined) {
        if (i == this.bp.rootNdx) { str += ""{root}""; }
        str += this.bp.bkSr.blocks[i].toString();
        if (i + 1 < this.bp.bkSr.blocks.length && this.bp.bkSr.blocks[i + 1] != undefined) {
          str += "","";
        }
      }
    }
    //str += ""\nfree"" + JSON.stringify([...this.bp.bkSr.free]);
    return str;
  }
}

/** compare() Compare values. This will work for string and number types.
 * @param {any} a a value
 * @param {any} b another value
 * @returns {number} -1 if a < b, 0 if a == b, 1 if a > b
 */
function compare(a, b) {
  if (a < b) { return -1; }
  else if (a > b) { return 1; }
  return 0;
}

/** assertSets() Assert that sizes and values of tree and set are equal.
 * @param {BTree} aTree a tree
 * @param {Set} aSet a set
 */
function assertSets(aTree, aSet) {
  if (aTree.size() == aSet.size) {
    var i = 0, setVals = Array.from(aSet).sort(compare);
    for (const tVal of aTree) {
      if (compare(tVal, setVals[i]) != 0) {
        throw new Error(""assert: value mismatch"");
      }
      i++;
    }
  } else {
    throw new Error(""assert: size mismatch"");
  }
}


var natoValues = [""alpha"", ""bravo"", ""charlie"", ""delta"", ""echo"", ""foxtrot"", ""golf"", ""hotel"",
                  ""india"", ""juliet"", ""kilo"", ""lima"", ""mike"", ""november"", ""oscar"", ""papa"",
                  ""quebec"", ""romeo"", ""sierra"", ""tango"", ""uniform""];
var wuValues = [""adams"", ""boston"", ""chicago"", ""denver"", ""easy"", ""frank"", ""george"", ""henry"",
                ""ida"", ""john"", ""king"", ""lincoln"", ""mary"", ""new york"", ""ocean"", ""peter"",
                ""queen"", ""roger"", ""sugar"", ""thomas"", ""union""];
var bTree = new BTree(15, compare);
var valuesSet = new Set();
var midNV = Math.floor(natoValues.length / 2);

for (var i = 0; i < natoValues.length; i++) {
  bTree.add(natoValues[i]);
  valuesSet.add(natoValues[i]);
}
console.log(""--added "" + natoValues.length + "" nato phonetics--"");
assertSets(bTree, valuesSet);

console.log(bTree.toString());

console.log(""findGE("" + JSON.stringify(wuValues[0]) + "") = "" + bTree.findGE(wuValues[0]));
console.log(""size = "" + bTree.size());

for (var i = wuValues.length - 1; i >= 0; i--) {
  bTree.add(wuValues[i]);
  valuesSet.add(wuValues[i]);
}
console.log(""--added (in reverse order) "" + wuValues.length + "" western union phonetics--"");
assertSets(bTree, valuesSet);

console.log(bTree.toString2());

console.log(""findGE("" + JSON.stringify(wuValues[0]) + "") = "" + bTree.findGE(wuValues[0]));
console.log(""findLT("" + JSON.stringify(natoValues[midNV]) + "") = "" + bTree.findLT(natoValues[midNV]));
console.log(""size = "" + bTree.size());

for (var i = 0; i < midNV; i++) {
  bTree.remove(natoValues[i]);
  valuesSet.delete(natoValues[i]);
}
console.log(""--removed first "" + midNV + "" nato phonetics--"");
assertSets(bTree, valuesSet);

console.log(bTree.toString());

var str = """";
var iter = bTree.iteratorGE(natoValues[midNV]);
while (iter.hasNext()) {
  str += iter.next()
  if (iter.hasNext()) { str += "", ""; }
}
console.log(""findLT("" + JSON.stringify(natoValues[midNV]) + "") = "" + bTree.findLT(natoValues[midNV]));
console.log(""iteratorGE("" + JSON.stringify(natoValues[midNV]) + "") = "" + str);
console.log(""size = "" + bTree.size());
console.log(""blocksToString = "" + bTree.blocksToString());
bTree.clear();
valuesSet.clear();
console.log(""--clear--"");
console.log(bTree.toString2());

/** @version 1.0 */"
XKnKSwbJ,systemScanner.lua,hoodedperson,Lua,Thursday 17th of July 2025 02:10:34 PM CDT,"local function copyTable(...)
    local tArgs = {...}
    local copy = {}
    for _, piece in pairs(tArgs) do
        if piece and type(piece) == ""table"" then
            for key, val in pairs(piece) do
                if type(val) == ""table"" then copy[key] = copyTable( copy[key] or {}, val)
                else copy[key] = val end
            end
        end
    end
    return copy
end

local ticker = peripheral.find(""stockcheckingblock"")

local toMonitor = {""minecraft:cobblestone""}
local itemLocations = {}
local networkSize = ticker.inventorySize()
local emptyTable = {}
local timeTable = {}
local iter = 0
while true do
    iter = iter + 1
    timeTable[iter] = {os.epoch(""utc"")}
    for i=1, networkSize do
        term.clear()
        term.setCursorPos(1,1)
        print(""Getting item locations"")
        print(tostring(iter).."": ""..tostring(i)..""/""..tostring(networkSize)) 
        local item = ticker.itemBasicDetails(i)
        if itemLocations[item.id] == nil then
            itemLocations[item.id] = copyTable(emptyTable)
	    end
        table.insert(itemLocations[item.id], i)
    end
	emptyTable[iter] = -1
    timeTable[iter][2] = os.epoch(""utc"")
    local serialised = textutils.serialise({
        itemLocations = itemLocations,
        timeTable = timeTable,
    })
    local h = fs.open(""systemScan.lon"",""w+"")
    h.write(serialised)
    h.close()
end
"
