id,title,username,language,date,content
Hykp5c9L,2025-07-01_stats.json,rdp_snitch,JSON,Tuesday 1st of July 2025 07:18:12 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 9468,
    ""194.165.16.166"": 6,
    ""111.170.152.113"": 3,
    ""205.210.31.206"": 9,
    ""109.160.70.30"": 6,
    ""147.185.132.141"": 9,
    ""128.22.147.233"": 3,
    ""68.183.179.179"": 3,
    ""45.79.168.172"": 3,
    ""205.210.31.199"": 9,
    ""152.32.180.98"": 3,
    ""194.165.16.164"": 6,
    ""147.185.132.90"": 9,
    ""45.227.254.151"": 6
  },
  ""asn"": {
    ""AS29222"": 9468,
    ""AS48721"": 12,
    ""AS151185"": 3,
    ""AS396982"": 36,
    ""AS44247"": 6,
    ""AS17511"": 3,
    ""AS14061"": 3,
    ""AS63949"": 3,
    ""AS135377"": 3,
    ""AS267784"": 6
  },
  ""isp"": {
    ""Infomaniak Network SA"": 9468,
    ""Flyservers S.A."": 18,
    ""China Telecom"": 3,
    ""Google LLC"": 36,
    ""Videosat09 GCN"": 6,
    ""OPTAGE Inc."": 3,
    ""DigitalOcean, LLC"": 3,
    ""Akamai Technologies, Inc."": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3
  },
  ""org"": {
    ""Infomaniak Network SA"": 9468,
    ""Flyservers S.A"": 12,
    ""Chinanet HB"": 3,
    ""Palo Alto Networks, Inc"": 36,
    ""Unknown"": 6,
    ""OPTAGE Inc."": 3,
    ""DigitalOcean, LLC"": 3,
    ""Linode"": 3,
    ""UCloud (HK) Holdings Group Limited"": 3,
    ""Xwin Universal LTD"": 6
  },
  ""regionName"": {
    ""Lucerne"": 9468,
    ""Kaunas"": 12,
    ""Hubei"": 3,
    ""California"": 36,
    ""Veliko Tarnovo"": 6,
    ""Kyoto"": 3,
    ""South West"": 3,
    ""New Jersey"": 3,
    ""Dubai"": 3,
    ""Vilnius"": 6
  },
  ""country"": {
    ""Switzerland"": 9468,
    ""Lithuania"": 18,
    ""China"": 3,
    ""United States"": 39,
    ""Bulgaria"": 6,
    ""Japan"": 3,
    ""Singapore"": 3,
    ""United Arab Emirates"": 3
  },
  ""account"": {
    ""hello"": 9483,
    ""Test"": 18,
    ""UZIJIcyxx"": 3,
    ""StaMhl"": 3,
    ""OBeGuv"": 3,
    ""vzGIRITet"": 3,
    ""uZlnhM"": 3,
    ""MncCfP"": 3,
    ""(empty)"": 3,
    ""iWwrKuqsq"": 3,
    ""ZDucwQ"": 3,
    ""RfuUxD"": 3,
    ""Administrator"": 3,
    ""vJfKFsAac"": 3,
    ""jqfagm"": 3,
    ""lOtxOq"": 3
  },
  ""keyboard"": {
    ""Unknown"": 9543
  },
  ""client_build"": {
    ""Unknown"": 9543
  },
  ""client_name"": {
    ""Unknown"": 9543
  },
  ""ip_type"": {
    ""mobile & hosting"": 9468,
    ""Unknown"": 30,
    ""hosting"": 45
  }
}"
qkbaHf9A,2025-07-01_stats.json,rdp_snitch,JSON,Tuesday 1st of July 2025 07:16:06 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 6312,
    ""194.165.16.166"": 4,
    ""111.170.152.113"": 2,
    ""205.210.31.206"": 6,
    ""109.160.70.30"": 4,
    ""147.185.132.141"": 6,
    ""128.22.147.233"": 2,
    ""68.183.179.179"": 2,
    ""45.79.168.172"": 2,
    ""205.210.31.199"": 6,
    ""152.32.180.98"": 2,
    ""194.165.16.164"": 4,
    ""147.185.132.90"": 6,
    ""45.227.254.151"": 4
  },
  ""asn"": {
    ""AS29222"": 6312,
    ""AS48721"": 8,
    ""AS151185"": 2,
    ""AS396982"": 24,
    ""AS44247"": 4,
    ""AS17511"": 2,
    ""AS14061"": 2,
    ""AS63949"": 2,
    ""AS135377"": 2,
    ""AS267784"": 4
  },
  ""isp"": {
    ""Infomaniak Network SA"": 6312,
    ""Flyservers S.A."": 12,
    ""China Telecom"": 2,
    ""Google LLC"": 24,
    ""Videosat09 GCN"": 4,
    ""OPTAGE Inc."": 2,
    ""DigitalOcean, LLC"": 2,
    ""Akamai Technologies, Inc."": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2
  },
  ""org"": {
    ""Infomaniak Network SA"": 6312,
    ""Flyservers S.A"": 8,
    ""Chinanet HB"": 2,
    ""Palo Alto Networks, Inc"": 24,
    ""Unknown"": 4,
    ""OPTAGE Inc."": 2,
    ""DigitalOcean, LLC"": 2,
    ""Linode"": 2,
    ""UCloud (HK) Holdings Group Limited"": 2,
    ""Xwin Universal LTD"": 4
  },
  ""regionName"": {
    ""Lucerne"": 6312,
    ""Kaunas"": 8,
    ""Hubei"": 2,
    ""California"": 24,
    ""Veliko Tarnovo"": 4,
    ""Kyoto"": 2,
    ""South West"": 2,
    ""New Jersey"": 2,
    ""Dubai"": 2,
    ""Vilnius"": 4
  },
  ""country"": {
    ""Switzerland"": 6312,
    ""Lithuania"": 12,
    ""China"": 2,
    ""United States"": 26,
    ""Bulgaria"": 4,
    ""Japan"": 2,
    ""Singapore"": 2,
    ""United Arab Emirates"": 2
  },
  ""account"": {
    ""hello"": 6322,
    ""Test"": 12,
    ""UZIJIcyxx"": 2,
    ""StaMhl"": 2,
    ""OBeGuv"": 2,
    ""vzGIRITet"": 2,
    ""uZlnhM"": 2,
    ""MncCfP"": 2,
    ""(empty)"": 2,
    ""iWwrKuqsq"": 2,
    ""ZDucwQ"": 2,
    ""RfuUxD"": 2,
    ""Administrator"": 2,
    ""vJfKFsAac"": 2,
    ""jqfagm"": 2,
    ""lOtxOq"": 2
  },
  ""keyboard"": {
    ""Unknown"": 6362
  },
  ""client_build"": {
    ""Unknown"": 6362
  },
  ""client_name"": {
    ""Unknown"": 6362
  },
  ""ip_type"": {
    ""mobile & hosting"": 6312,
    ""Unknown"": 20,
    ""hosting"": 30
  }
}"
egNwtBiV,2025-07-01_stats.json,rdp_snitch,JSON,Tuesday 1st of July 2025 07:15:09 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 3156,
    ""194.165.16.166"": 2,
    ""111.170.152.113"": 1,
    ""205.210.31.206"": 3,
    ""109.160.70.30"": 2,
    ""147.185.132.141"": 3,
    ""128.22.147.233"": 1,
    ""68.183.179.179"": 1,
    ""45.79.168.172"": 1,
    ""205.210.31.199"": 3,
    ""152.32.180.98"": 1,
    ""194.165.16.164"": 2,
    ""147.185.132.90"": 3,
    ""45.227.254.151"": 2
  },
  ""asn"": {
    ""AS29222"": 3156,
    ""AS48721"": 4,
    ""AS151185"": 1,
    ""AS396982"": 12,
    ""AS44247"": 2,
    ""AS17511"": 1,
    ""AS14061"": 1,
    ""AS63949"": 1,
    ""AS135377"": 1,
    ""AS267784"": 2
  },
  ""isp"": {
    ""Infomaniak Network SA"": 3156,
    ""Flyservers S.A."": 6,
    ""China Telecom"": 1,
    ""Google LLC"": 12,
    ""Videosat09 GCN"": 2,
    ""OPTAGE Inc."": 1,
    ""DigitalOcean, LLC"": 1,
    ""Akamai Technologies, Inc."": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1
  },
  ""org"": {
    ""Infomaniak Network SA"": 3156,
    ""Flyservers S.A"": 4,
    ""Chinanet HB"": 1,
    ""Palo Alto Networks, Inc"": 12,
    ""Unknown"": 2,
    ""OPTAGE Inc."": 1,
    ""DigitalOcean, LLC"": 1,
    ""Linode"": 1,
    ""UCloud (HK) Holdings Group Limited"": 1,
    ""Xwin Universal LTD"": 2
  },
  ""regionName"": {
    ""Lucerne"": 3156,
    ""Kaunas"": 4,
    ""Hubei"": 1,
    ""California"": 12,
    ""Veliko Tarnovo"": 2,
    ""Kyoto"": 1,
    ""South West"": 1,
    ""New Jersey"": 1,
    ""Dubai"": 1,
    ""Vilnius"": 2
  },
  ""country"": {
    ""Switzerland"": 3156,
    ""Lithuania"": 6,
    ""China"": 1,
    ""United States"": 13,
    ""Bulgaria"": 2,
    ""Japan"": 1,
    ""Singapore"": 1,
    ""United Arab Emirates"": 1
  },
  ""account"": {
    ""hello"": 3161,
    ""Test"": 6,
    ""UZIJIcyxx"": 1,
    ""StaMhl"": 1,
    ""OBeGuv"": 1,
    ""vzGIRITet"": 1,
    ""uZlnhM"": 1,
    ""MncCfP"": 1,
    ""(empty)"": 1,
    ""iWwrKuqsq"": 1,
    ""ZDucwQ"": 1,
    ""RfuUxD"": 1,
    ""Administrator"": 1,
    ""vJfKFsAac"": 1,
    ""jqfagm"": 1,
    ""lOtxOq"": 1
  },
  ""keyboard"": {
    ""Unknown"": 3181
  },
  ""client_build"": {
    ""Unknown"": 3181
  },
  ""client_name"": {
    ""Unknown"": 3181
  },
  ""ip_type"": {
    ""mobile & hosting"": 3156,
    ""Unknown"": 10,
    ""hosting"": 15
  }
}"
mPYAjLH7,Untitled,vuseless,HTML,Tuesday 1st of July 2025 07:00:33 PM CDT,"onlinepoll.me/en/poll/vote/who-is-smarter-3

<!-- will be deleted in up to an hour -->"
W866rnTD,BWR - Changelog 01/07/25 üçÅ,SSilver,Diff,Tuesday 1st of July 2025 06:30:49 PM CDT,"Pain Train
- Removed speedboost granted on killing enemies with pickups in Player Destruction
This was not ideal when every player is a potential source of pick-ups to gain this speed up benefit from, and is against the spirit of the upside meant to be for defending intelligence.

Soda Popper
  Fixed bug where it would charge on self-damage
An oversight in modifying how HYPE was gained that came up with the Boston Basher.

Sun-On-A-Stick
  Replaced burning effect to be less obstructive and to linger less
Something that ought to hopefully be less smoky and intrusive.

Compression Blast
  Fixed bug where reflecting Dragon's Fury fireball dealt reduced damage
An oversight due to the modified flamethrower damage counting reflected fireballs as flame damage.

The Backburner
+ Removed critical hit multipier scaling with consecutive hits
The crit damage ramp-up is seen as not necessary now that Pyro's mobility was reduced significantly.

The Phlogistinator
+ Alt-Fire maxes-out Temperature against enemies on-hit
This change should make alt-fire a more useful tool without directly upping it's damage, now helping to setup maximized primary fire damage and additionally making MMMPH more potent when applied properly.

The Manmelter
+ Gain a stored crit on-kill against a burning target
- Removed gaining crits from extinguishing teammates
This weapon's ability to peform on it's own seemed to be at odds with it's ability to punish enemy pyros. Thusly it's ability to gain crits from extinguishing was removed. It can still provide a supportive benefit, however now additionally gains crit on-kills to make the user net positive on crits when spending flares against some targets.

Shields
  Shield Leap will now cancel charge prematurely while maintaining momentum
This change should make leap less punishing to use with charge to cross great distances, allowing for that repositioning while retaining some charge leftover for a faster recharge.

Loch-n-Load
+ Added: This weapons deploys 40% faster
+ Removed slower reload speed penalty
- Removed faster firing speed bonus
The faster firing speed seemed to be at odds with both the new upside and made spamming the weapon a little annoying while the demo is at a range that prevents reprisal. Reverting this change along with the reload speed should keep the weapon's theme of lower sustainability, while a new upside in deploy speed should help it keep up for the demo who needs to use their pills to quickly dispatch an enemy. It additionally should combo especially well with it's new stickybomb detonating upside.

Bazaar Bagain
  Fixed issue with building damage at max charge
Correcting a slight rounding issue.

Cloaking
- Removed faster base cloaking time
The speedier ability to enter cloak was too much of an overcorrection compared to just the decloaking time, as such was reverted. It made escapes with cloak far too guaranteed prior.

Red-Tape Recorder
+ Attached sappers emit Spy Radar while active
  Radar pings every 3 seconds with 2 second outlines
- 33% smaller radar range
- Radar cannot be activated manually
A suggested change to differentiate the sapper in a way that would fit it's more disruptive role. This change ought to further emphasize the quick removal of it while benefitting the spy with his quick escape to take advantage of said disruption, additionally benefitting the spy's team with the enemy's position."
0hCFk9LA,iframe - child page,Vojkovic,JavaScript,Tuesday 1st of July 2025 05:07:21 PM CDT,"<script>
  (function() {
    // If not in iframe, do nothing
    try {
      if (window.top === window.self) return;
    } catch(e) {}
    
    // Set to false to prevent dataLayer messages from being sent to parent
    var sendDataLayerMessages = true;
    
    // Set the prefix that will be used in the event name, and under which all
    // the dataLayer properties will be embedded
    var dataLayerMessagePrefix = 'iframe';
    
    // Set to parent origin (""https://www.domain.com"")
    var parentOrigin = 'https://www.mathnasium.com/';

    // Maximum time in milliseconds to poll the parent frame for ready signal
    var maxTime = 2000;
    
    // Don't touch anything that follows
    var pollInterval = 200;
    var parentReady = false;
    
    var postCallback = function(event) {
      if (event.origin !== parentOrigin) return;
      if (event.data.event !== 'clientId' && event.data !== 'parentReady') return;
      
      if (event.data.event === 'clientId') {
        window.dataLayer.push({
          event: 'clientId',
          clientId: event.data.clientId
        });
      }
      
      if (event.data === 'parentReady' && !parentReady) {
        window.clearInterval(poll);
        if (sendDataLayerMessages) startDataLayerMessageCollection();
        parentReady = true;
      }
    };
    
    var pollCallback = function() {
      // If maximum time is reached, stop polling
      maxTime -= pollInterval;
      if (maxTime <= 0) window.clearInterval(poll);
      // Send message to parent that iframe is ready to retrieve Client ID
      window.top.postMessage('childReady', parentOrigin);
    };
    
    var createMessage = function(obj) {
      if (!Array.isArray(obj) && typeof obj === 'object') {
        var flattenObj = JSON.parse(JSON.stringify(obj));
		var message = {};
        // Add metadata about the page into the message
        message[dataLayerMessagePrefix] = {
          pageData: {
            url: document.location.href,
            title: document.title
          }
        };
        for (var prop in flattenObj) {
          if (flattenObj.hasOwnProperty(prop) && prop !== 'gtm.uniqueEventId') {
            if (prop === 'event') {
              message.event = dataLayerMessagePrefix + '.' + flattenObj[prop];
            } else {
              message[dataLayerMessagePrefix][prop] = flattenObj[prop];
            }
          }
        }
        if (!message.event) message.event = dataLayerMessagePrefix + '.Message';
        return message;
      }
      return false;
    };
    
    var startDataLayerMessageCollection = function() {
      // Send the current dataLayer content to top frame, flatten the object
      window.dataLayer.forEach(function(obj) {
        var message = createMessage(obj);
        if (message) window.top.postMessage(message, parentOrigin);
      });
      // Create the push listener for future messages
      var oldPush = window.dataLayer.push;
      window.dataLayer.push = function() {
        var states = [].slice.call(arguments, 0);
        states.forEach(function(arg) {
          var message = createMessage(arg);
          if (message) window.top.postMessage(message, parentOrigin);
        });
        return oldPush.apply(window.dataLayer, states);
      };
    };
    
    // Start polling the parent page with ""childReady"" message
    var poll = window.setInterval(pollCallback, pollInterval);
    
    // Start listening for messages from the parent page
    window.addEventListener('message', postCallback);
  })();
</script>"
zRb8V7iz,Pbinfo #879,Hezov,C++,Tuesday 1st of July 2025 04:15:03 PM CDT,"#include <fstream>
#include <cstring>
using namespace std;
ifstream cin(""egalitati.in"");
ofstream cout(""egalitati.out"");
struct ecuatie{char var1[30], op, var2[30]; }v[27];
int sol[27];
char s[150];
int getNum(char s[])
{
    int sol = 0;
    for(int i = 0;s[i]!=0;i++)
        sol = sol * 10 + (s[i]-'0');
    return sol;
}
void solve(int poz)
{
    int nr1 = 0, nr2 = 0;
    if('a' <= v[poz].var1[0] && v[poz].var1[0] <= 'z')
    {
        solve(v[poz].var1[0] - 'a');
        nr1 = sol[v[poz].var1[0] - 'a'];
    }
    else nr1 = getNum(v[poz].var1);
    if(v[poz].op != 0)
    {
        if('a' <= v[poz].var2[0] && v[poz].var2[0] <= 'z')
        {
            solve(v[poz].var2[0] - 'a');
            nr2 = sol[v[poz].var2[0] - 'a'];
        }
        else nr2 = getNum(v[poz].var2);

        if(v[poz].op == '+')
        {
            sol[poz] = nr1 + nr2;
            return;
        }
        if(v[poz].op == '*')
        {
            sol[poz] = nr1 * nr2;
            return;
        }
    }
    else
    {
        sol[poz] = nr1;
        return;
    }

}
int main()
{
    for(int i = 0;i<26;i++)
        sol[i] = -1;
    int n;
    cin >> n ;
    cin.get();
    for(int i = 1;i <= n;i++)
    {
        cin.getline(s,100);
        int poz = s[0] - 'a', cnt = 1;
        for(int it = 1;s[it]!=0;it++)
        {
            if(s[it] == ' ' || s[it] == '=')
                continue;
            if(cnt == 1)
            {
                while(s[it] != ' ' && s[it] != '+' && s[it] != '*' && s[it]!=0)
                    v[poz].var1[strlen(v[poz].var1)] = s[it], it++;
                it--;
                cnt++;
            }
            else if(cnt == 2)
            {
                if((s[it] == '+' || s[it] == '*') && s[it]!=0)
                    v[poz].op = s[it], it++;
                it--;
                cnt++;
            }
            else if(cnt == 3)
            {
                while(s[it] != ' ' && s[it]!=0)
                    v[poz].var2[strlen(v[poz].var2)] = s[it], it++;
                it--;
                cnt++;
            }
        }
        for(int it = 0;it<100;it++)
            s[it] = 0;
    }
    for(int i = 0;i<26;i++)
        if(sol[i] == -1 && strlen(v[i].var1) != 0)
            solve(i);
    for(int i = 0;i<26;i++)
        if(sol[i] != -1)
            cout <<(char)(i+'a') << "" = "" << sol[i] << '\n';
    return 0;
}"
rHYq8UMv,Untitled,Ewgeniy,Lua,Tuesday 1st of July 2025 03:12:35 PM CDT,"-- tui.lua ‚Äî –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –ø—Å–µ–≤–¥–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –¥–ª—è OpenComputers

local component = require(""component"")
local term = require(""term"")
local event = require(""event"")
local gpu = component.gpu
local tui = {}

-- –¶–≤–µ—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
tui.bgColor = 0x000000
tui.fgColor = 0xFFFFFF

function tui.setColors(fg, bg)
  gpu.setForeground(fg or tui.fgColor)
  gpu.setBackground(bg or tui.bgColor)
end

function tui.clear(bg)
  local w, h = gpu.getResolution()
  tui.setColors(nil, bg or tui.bgColor)
  gpu.fill(1, 1, w, h, "" "")
end

function tui.box(x, y, w, h, title)
  gpu.set(x, y, ""‚ïî"" .. string.rep(""‚ïê"", w - 2) .. ""‚ïó"")
  for i = 1, h - 2 do
    gpu.set(x, y + i, ""‚ïë"" .. string.rep("" "", w - 2) .. ""‚ïë"")
  end
  gpu.set(x, y + h - 1, ""‚ïö"" .. string.rep(""‚ïê"", w - 2) .. ""‚ïù"")
  if title then gpu.set(x + 2, y, title) end
end

function tui.centerText(y, text)
  local w = gpu.getResolution()
  local x = math.floor((w - #text) / 2) + 1
  gpu.set(x, y, text)
end

function tui.button(x, y, label, active)
  local pad = 2
  local text = string.rep("" "", pad) .. label .. string.rep("" "", pad)
  tui.setColors(active and 0x000000 or 0xFFFFFF, active and 0xFFFFFF or 0x444444)
  gpu.set(x, y, text)
  tui.setColors()
  return {x = x, y = y, w = #text, h = 1, label = label}
end

function tui.clicked(btn, x, y)
  return x >= btn.x and x < btn.x + btn.w and y == btn.y
end

function tui.input(x, y, w, default)
  tui.setColors(0xFFFFFF, 0x000000)
  gpu.fill(x, y, w, 1, "" "")
  gpu.set(x, y, default or """")
  term.setCursor(x, y)
  term.setCursorBlink(true)
  local input = io.read()
  term.setCursorBlink(false)
  return input
end

function tui.list(x, y, w, h, items, selected, keyControl)
  selected = math.max(1, math.min(selected or 1, #items))
  local offset = math.min(math.max(0, selected - math.floor(h / 2)), math.max(0, #items - h))

  local function drawList()
    for i = 1, h do
      local idx = offset + i
      local item = items[idx]
      if item then
        local isSelected = (idx == selected)
        tui.setColors(isSelected and 0x000000 or 0xFFFFFF, isSelected and 0xAAAAAA or 0x000000)
        gpu.fill(x, y + i - 1, w, 1, "" "")
        gpu.set(x + 1, y + i - 1, item:sub(1, w - 2))
      else
        gpu.fill(x, y + i - 1, w, 1, "" "")
      end
    end
    tui.setColors()
  end

  drawList()

  if keyControl then
    while true do
      local _, _, _, key = event.pull(""key_down"")
      if key == 200 then -- up
        if selected > 1 then selected = selected - 1 end
      elseif key == 208 then -- down
        if selected < #items then selected = selected + 1 end
      elseif key == 28 then -- enter
        break
      end
      offset = math.min(math.max(0, selected - math.floor(h / 2)), math.max(0, #items - h))
      drawList()
    end
  end

  return selected
end

function tui.toggle(x, y, label, state)
  local onText = ""–í–∫–ª""
  local offText = ""–í—ã–∫–ª""
  local status = state and onText or offText
  local fullText = label .. "": ["" .. status .. ""]""
  local width = #label + 2 + math.max(#onText, #offText) + 2
  local bg = state and 0x00AA00 or 0xAA0000

  tui.setColors(0xFFFFFF, bg)
  gpu.fill(x, y, width, 1, "" "")
  gpu.set(x + 1, y, fullText)
  tui.setColors()

  return {x = x, y = y, w = width, h = 1, state = state}
end

function tui.checkbox(x, y, label, checked)
  local box = checked and ""[x]"" or ""[ ]""
  local text = box .. "" "" .. label
  tui.setColors(0xFFFFFF, 0x000000)
  gpu.set(x, y, text)
  return {x = x, y = y, w = #text, h = 1, checked = checked, label = label}
end

function tui.progressbar(x, y, w, percent)
  local fill = math.floor((w - 2) * percent)
  tui.setColors(0xFFFFFF, 0x222222)
  gpu.set(x, y, ""["")
  gpu.set(x + w - 1, y, ""]"")
  gpu.fill(x + 1, y, w - 2, 1, "" "")
  tui.setColors(0x00FF00, 0x00FF00)
  gpu.fill(x + 1, y, fill, 1, "" "")
  tui.setColors()
end

function tui.tabBar(x, y, tabs, current)
  local tabPositions = {}
  for i, name in ipairs(tabs) do
    local active = (i == current)
    tui.setColors(active and 0x000000 or 0xFFFFFF, active and 0xFFFFFF or 0x333333)
    gpu.set(x, y, "" "" .. name .. "" "")
    table.insert(tabPositions, {x = x, w = #name + 2})
    x = x + #name + 2
  end
  tui.setColors()
  return tabPositions
end

function tui.tabBarInteractive(x, y, tabs, current)
  local w = gpu.getResolution()

  local function draw()
    local cx = x
    for i, name in ipairs(tabs) do
      local active = (i == current)
      tui.setColors(active and 0x000000 or 0xFFFFFF, active and 0xFFFFFF or 0x333333)
      gpu.set(cx, y, "" "" .. name .. "" "")
      cx = cx + #name + 2
    end
    tui.setColors()
  end

  while true do
    draw()
    local _, _, _, key = event.pull(""key_down"")
    if key == 203 then -- –≤–ª–µ–≤–æ
      current = current > 1 and current - 1 or #tabs
    elseif key == 205 then -- –≤–ø—Ä–∞–≤–æ
      current = current < #tabs and current + 1 or 1
    elseif key == 28 then -- Enter
      break
    end
  end

  return current
end

function tui.popup(x, y, w, h, lines)
  tui.setColors(0xFFFFFF, 0x0000AA)
  tui.box(x, y, w, h, "" "")
  for i, line in ipairs(lines) do
    if i + y < y + h - 1 then
      gpu.set(x + 1, y + i, line:sub(1, w - 2))
    end
  end
  tui.setColors()
end

function tui.toast(text, duration)
  local w, h = gpu.getResolution()
  local x = math.floor((w - #text) / 2)
  local y = h
  tui.setColors(0xFFFFFF, 0x880000)
  gpu.set(x, y, text)
  os.sleep(duration or 2)
  gpu.fill(x, y, #text, 1, "" "")
  tui.setColors()
end

-- –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –≤–∫–ª–∞–¥–æ–∫ –∏ —Å–ø–∏—Å–∫–∞ –ø–æ –∫–ª–∞–≤–∏—à–∞–º, –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
-- state = { currentTab = 1, selectedItem = 1, tabs = {...}, items = {...} }
function tui.updateTabsAndList(state, key)
  local tabsCount = #state.tabs
  local listCount = #state.items

  if key == 203 then -- –≤–ª–µ–≤–æ
    state.currentTab = (state.currentTab - 2) % tabsCount + 1
    if state.currentTab ~= 2 then
      state.selectedItem = 1
    end
  elseif key == 205 then -- –≤–ø—Ä–∞–≤–æ
    state.currentTab = state.currentTab % tabsCount + 1
    if state.currentTab ~= 2 then
      state.selectedItem = 1
    end
  elseif state.currentTab == 2 then
    if key == 200 then -- –≤–≤–µ—Ä—Ö
      if state.selectedItem > 1 then
        state.selectedItem = state.selectedItem - 1
      end
    elseif key == 208 then -- –≤–Ω–∏–∑
      if state.selectedItem < listCount then
        state.selectedItem = state.selectedItem + 1
      end
    end
  end

  return state
end

-- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≤–∫–ª–∞–¥–æ–∫ –∏ —Å–ø–∏—Å–∫–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è
function tui.drawTabsAndList(state, x, y, w, h)
  tui.tabBar(x, y, state.tabs, state.currentTab)
  if state.currentTab == 2 then
    tui.list(x, y + 2, w, h, state.items, state.selectedItem)
  else
    tui.clear()
    tui.centerText(y + 4, ""–í–∫–ª–∞–¥–∫–∞: "" .. state.tabs[state.currentTab])
  end
end

function tui.confirmDialog(title, text)
  local w, h = 40, 7
  local sw, sh = gpu.getResolution()
  local x = math.floor((sw - w) / 2)
  local y = math.floor((sh - h) / 2)

  tui.box(x, y, w, h, title)
  tui.setColors(0xFFFFFF, 0x000000)
  gpu.set(x + 2, y + 2, text)

  local yesBtn = tui.button(x + 6, y + 4, ""–î–∞"", true)
  local noBtn = tui.button(x + w - 10, y + 4, ""–ù–µ—Ç"", false)

  while true do
    local _, _, cx, cy = event.pull(""touch"")
    if tui.clicked(yesBtn, cx, cy) then
      return true
    elseif tui.clicked(noBtn, cx, cy) then
      return false
    end
  end
end



return tui
"
vkPLRMPs,Dumps,LVL23HT,CSS,Tuesday 1st of July 2025 02:32:45 PM CDT,"pen testers
"
cekDwWJp,Untitled,Scripting_King,Lua,Tuesday 1st of July 2025 02:20:00 PM CDT,"--[[ 
	Queue System Script by lenovo768
	Discord: the_king_here
	Description: Manages player queueing using Zone module, UI elements, player limits,
	friend-only mode, camera control, and player teleportation after countdown.
--]]

--// Services
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local TweenService = game:GetService(""TweenService"")
local Lighting = game:GetService(""Lighting"")
local Players = game:GetService(""Players"")

--// Modules
local Zone = require(ReplicatedStorage:WaitForChild(""Module""):WaitForChild(""Zone""))

--// References
local QueuesFolder = workspace:WaitForChild(""Queqe""):WaitForChild(""QueueStand"")
local CameraEvent = ReplicatedStorage:WaitForChild(""Events""):WaitForChild(""CameraEvent"")
local Blur = Lighting:WaitForChild(""BlurForGui"")

--// Tween Info Constants
local showTweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
local hideTweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)

--// Settings
local DefaultDuration = 45

--// Utility Functions

-- Teleports player to a specific position while keeping rotation
local function teleportPlayerOut(player: Player, position: Vector3)
	if not player.Character or not player.Character:FindFirstChild(""HumanoidRootPart"") then return end
	local root:BasePart = player.Character.HumanoidRootPart
	local rotation = root.CFrame.Rotation -- get's the current rotation
	player.Character:PivotTo(CFrame.new(position) * rotation) -- Teleports the player while keeping their rotation
end

-- Clears the player queue UI tiles
local function clearQueueUI(frame: Frame)
	for _, tile in pairs(frame.QueueTiles:GetChildren()) do
		if tile:IsA(""ImageButton"") then
			tile.ImageLabel.Image = """"
			tile.PlayerName.Value = """"
		end
	end
end

-- Main Logic Per Queue Stand
for _, stand in pairs(QueuesFolder:GetChildren()) do
	if not stand:IsA(""Model"") then continue end

	local zonePart = stand:WaitForChild(""Circle""):WaitForChild(""Zone"")
	if not zonePart then continue end

	local zone = Zone.new(zonePart)

	-- State Variables
	local owner = nil --refrence to the player who first enter in the zone
	local playerCount = 0 --counts the player that are currently in zone
	local duration = DefaultDuration -- Countdown duration
	local queuePlayers = {} --Keeps a live list of players who are currently standing inside the queue zone
	local kickedPlayers = {} --It temporarily mark players who were forcefully removed from the queue zone so the system knows not to handle them like normal leavers

	local connections = {} --keeps track of all active connections so that we can disconnect them later

	-- Updates the count label on Billboard GUI
	local function updateCountDisplay(frame, allowed)
		stand.PlayerCount.BillboardGui.TextLabel.Text = `${playerCount}/${allowed}` --shows player count and max limit in the UI so player can see it
	end

	-- Start countdown timer
	local function startCountdown(frame)
		task.spawn(function()
			while duration > 0 and owner do --if duration/time is greater then 0 and owner is still in the zone then keep countdowning
				task.wait(1)
				duration -= 1
				frame.AutoStartingText.TimeAmountText.Text = duration
			end

			if not owner then return end --it stopes the execution of this function immediately if the owner has left

			-- Timer ends, teleport all players
			for _, plr in ipairs(queuePlayers) do
				task.spawn(function()
					CameraEvent:FireClient(plr, ""Cutscene"", workspace.Cutscene.Rigs.CameraRig.CameraRoot, nil, plr == owner) --it handles the camera movement of the cutscene
					task.wait(1.5)
					teleportPlayerOut(plr, zonePart.CFrame.Position + Vector3.new(25, 0, 0)) --Ejects player from queue to allow others access
				end)
			end

			CameraEvent:FireClient(owner, ""PlayAnimation"", nil, frame) --it plays curscene animation
			CameraEvent:FireClient(owner, ""DecreaseFieldOfView"", nil, frame) --it decreases the camera FOV and hides the UI with animation
		end)
	end

	-- Handles friend filter toggle
	local function setupFriendToggle(frame)
		local connection = frame.IsOnlyFriendsAllowed.Changed:Connect(function()
			if not owner or not frame.IsOnlyFriendsAllowed.Value then return end --if owner has left or the isonlyfriendallowed button is turned off then it stops the execution of the function
			
			-- kicks the player out if he is not friend of owner (the person who entered first) on roblox
			for i = #queuePlayers, 1, -1 do
				local queuedPlayer = queuePlayers[i]
				if queuedPlayer == owner then continue end

				if not owner:IsFriendsWith(queuedPlayer.UserId) then
					teleportPlayerOut(queuedPlayer, zonePart.CFrame.Position + Vector3.new(25, 0, 0)) --Ejects player from queue to allow others access
					table.insert(kickedPlayers, queuedPlayer)
					table.remove(queuePlayers, i)
					playerCount -= 1
				end
			end

			updateCountDisplay(frame, frame.AllowedPlayers.Value) --updates the count UI to  show the current player count and max limit
			clearQueueUI(frame) --removes the kicked player's presence from the queue display frame
			
			--it updates queue frame that shows current players in the queue
			for index, plr in ipairs(queuePlayers) do
				local tile = frame.QueueTiles:FindFirstChild(""QueueTile"" .. index)
				if tile then
					tile.ImageLabel.Image = Players:GetUserThumbnailAsync(plr.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420) --it returns the close picture of player's face
					tile.PlayerName.Value = plr.Name
				end
			end
		end)

		table.insert(connections, connection) --adding the connection to connection table to keep record of it and to disconnect it when needed
	end

	-- Kick a player via kick button/player can kick any player he wants by clicking kick button on the queue frame
	local function setupKickButton(frame, targetPlayer)
		for _, tile in pairs(frame.QueueTiles:GetChildren()) do --loop through all childs of queueTitles which actually include all players that are in queue
			if tile:IsA(""ImageButton"") and tile.PlayerName.Value == targetPlayer.Name then
				local button = tile:FindFirstChild(""KickButton"") --button to kick player out of the zone
				if button then
					local connection = button.MouseButton1Click:Connect(function()
						if targetPlayer == owner then return end --if owner tries to kick himself then it will stop execution and do nothing

						teleportPlayerOut(targetPlayer, zonePart.CFrame.Position + Vector3.new(25, 0, 0))--Ejects player from queue to allow others access
						table.insert(kickedPlayers, targetPlayer) --temporarily add player to kick table to keep record of it

						local index = table.find(queuePlayers, targetPlayer)
						if index then
							table.remove(queuePlayers, index)
							playerCount -= 1
						end

						updateCountDisplay(frame, frame.AllowedPlayers.Value) --updates the count UI to  show the current player count and max limit
						clearQueueUI(frame) --removes the kicked player's presence from the queue display frame
						
						--it updates queue frame that shows current players in the queue
						for idx, plr in ipairs(queuePlayers) do
							local t = frame.QueueTiles:FindFirstChild(""QueueTile"" .. idx)
							if t then
								t.ImageLabel.Image = Players:GetUserThumbnailAsync(plr.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420) --it returns the close shot of player's face
								t.PlayerName.Value = plr.Name
							end
						end
					end)
					table.insert(connections, connection)
				end
			end
		end
	end

	-- Setup Start and Cancel buttons for owner
	local function setupOwnerButtons(frame)
		local cancelConnection = frame.SelectionUI.CancelButton.MouseButton1Click:Connect(function()
			CameraEvent:FireClient(owner, ""DecreaseFieldOfView"", nil, frame) --it decreases the camera FOV and hides the UI with animation
		end)
		table.insert(connections, cancelConnection)

		local startConnection = frame.StartButton.MouseButton1Click:Connect(function() --if owner clicks start button then it will stop the countdown loop and start the game instantly
			duration = 0
		end)
		table.insert(connections, startConnection)
	end

	-- Assign a new owner and begin queue logic
	local function initializeOwner(player)
		owner = player --player who joined first get assigned as a owner
		playerCount = 1 --increases playercount to 1 
		duration = DefaultDuration --set the start time duration to default 45 seconds
		queuePlayers = {player} --it adds the owner to the queue player, since this table holds all player that are in zone
		kickedPlayers = {}

		local frame = player:WaitForChild(""PlayerGui""):WaitForChild(""SSimUI""):WaitForChild(""Frame"") --refrence to the frame that gives different options to the owner
		frame.Position = UDim2.new(0.5, 0, 1.5, 0) --setting the position of the frame to the bottom down of the screen
		frame.Visible = true --make frame visible
		frame.AutoStartingText.TimeAmountText.Text = duration --updating frame text to show current duration

		CameraEvent:FireClient(owner, ""IncreaseFieldOfView"", nil, frame) --function to animate frame position, camera FOV and blur size

		local tile = frame.QueueTiles:FindFirstChild(""QueueTile1"")
		if tile then
			tile.ImageLabel.Image = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420) --it returns the close shot of player's face
			tile.PlayerName.Value = player.Name
		end
		
		--calling upper functions to make the UI buttons works
		setupFriendToggle(frame)
		setupOwnerButtons(frame)
		startCountdown(frame)
	end

	-- Player enters the zone
	zone.playerEntered:Connect(function(player) --it runs whenever any player enters in the region of the zone
		if table.find(queuePlayers, player) then return end
		table.insert(queuePlayers, player) --insert players in queuePlayers, since it holds record of all players that are in zone

		local playerGui = player:WaitForChild(""PlayerGui"")
		local frame = playerGui:WaitForChild(""SSimUI""):WaitForChild(""Frame"")

		if not owner then
			initializeOwner(player) --defines owner if not defined yet
			return
		end

		local allowed = frame.AllowedPlayers.Value
		if playerCount >= allowed then --checks if the max player count is reached, if it is then it kicks the player out
			teleportPlayerOut(player, zonePart.CFrame.Position + Vector3.new(25, 0, 0))
			table.insert(kickedPlayers, player)
			return
		end

		if frame.IsOnlyFriendsAllowed.Value and not owner:IsFriendsWith(player.UserId) then -- it kicks the player out if IsOnlyFriendAllowed setting is turned ON but the player is not a friend of owner
			teleportPlayerOut(player, zonePart.CFrame.Position + Vector3.new(25, 0, 0))
			table.insert(kickedPlayers, player)
			return
		end

		playerCount += 1 --updates the playercount
		updateCountDisplay(frame, allowed) --updates the UI that shows the current player count

		local tile = frame.QueueTiles:FindFirstChild(""QueueTile"" .. playerCount)
		if tile then
			tile.ImageLabel.Image = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
			tile.PlayerName.Value = player.Name
		end

		setupKickButton(frame, player)
	end)

	-- Player leaves the zone
	zone.playerExited:Connect(function(player) --it runs whenever any player leaves the region of the zone
		local index = table.find(queuePlayers, player)
		if index then
			table.remove(queuePlayers, index) --it removes the player from the queuePlayers table since player is not in zone anymore
			playerCount -= 1
		end

		local kickIndex = table.find(kickedPlayers, player) 
		if kickIndex then
			table.remove(kickedPlayers, kickIndex) --if player was kicked from the zone that it removes the player from the zone without decreasing playerCount
		end

		if player == owner then --if player who exited the zone is the owner then it disconnect all connections and closes the frame
			local frame = player:WaitForChild(""PlayerGui""):WaitForChild(""SSimUI""):WaitForChild(""Frame"")
			CameraEvent:FireClient(owner, ""DecreaseFieldOfView"", nil, frame)
			frame.Visible = false

			for _, conn in ipairs(connections) do --Disconnecting all connections
				if conn and typeof(conn) == ""RBXScriptConnection"" then
					conn:Disconnect()
				end
			end
			table.clear(connections) --clears the connections table, since all connections are disconnected so we don't need to track them anymore

			clearQueueUI(frame) --it cleared the frame that shows the presence of players in the queue

			for _, plr in ipairs(queuePlayers) do
				teleportPlayerOut(plr, zonePart.CFrame.Position + Vector3.new(25, 0, 0)) --Ejects player from queue to allow others access
			end
			table.clear(queuePlayers) --it clears the queuePlayers table, since the queue is over

			owner = nil --removes the player refrence from the variable owner, since the player has left the queue
			playerCount = 0 --resets the player count
			duration = DefaultDuration --resets the queue duration
		else
			if owner and owner:FindFirstChild(""PlayerGui"") then -- if the player who left is not a owner and the owner still exist in queue then it clears only that player existance from the queueTitles frame
				local frame = owner.PlayerGui:FindFirstChild(""SSimUI"") and owner.PlayerGui.SSimUI:FindFirstChild(""Frame"")
				if frame then
					for _, tile in pairs(frame.QueueTiles:GetChildren()) do
						if tile:IsA(""ImageButton"") and tile.PlayerName.Value == player.Name then
							tile.ImageLabel.Image = """"
							tile.PlayerName.Value = """"
						end
					end
					updateCountDisplay(frame, frame.AllowedPlayers.Value) --updates the count UI to  show the current player count and max limit
				end
			end
		end
	end)
end
"
YMnk2pma,excellent 4 figury OK rychle korektni,max2201111,Python,Tuesday 1st of July 2025 01:54:53 PM CDT,"import chess
import math
import time
from copy import deepcopy

def knight_moves():
    return [(2, 1), (1, 2), (-1, 2), (-2, 1),
            (-2, -1), (-1, -2), (1, -2), (2, -1)]

def rook_moves():
    moves = []
    for i in range(1, 8):
        moves.extend([(i, 0), (-i, 0), (0, i), (0, -i)])
    return moves

def bishop_moves():
    moves = []
    for i in range(1, 8):
        moves.extend([(i, i), (i, -i), (-i, i), (-i, -i)])
    return moves

def queen_moves():
    return rook_moves() + bishop_moves()

def amazon_moves():
    return queen_moves() + knight_moves()

def cyril_moves():
    return rook_moves() + knight_moves()

def eve_moves():
    return bishop_moves() + knight_moves()

def print_board(board):
    print(""  a b c d e f g h"")
    for i in range(8):
        print(f""{8-i} "", end="""")
        for j in range(8):
            print(f""{board[i][j]} "", end="""")
        print(f""{8-i}"")
    print(""  a b c d e f g h"")
    print()

def generate_moves(board, piece, row, col):
    size = 8
    moves = []
    
    if piece.upper() == 'A':
        directions = amazon_moves()
    elif piece.upper() == 'C':
        directions = cyril_moves()
    elif piece.upper() == 'E':
        directions = eve_moves()
    elif piece.upper() == 'K':
        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
    else:
        return moves
    
    for dx, dy in directions:
        new_row, new_col = row + dx, col + dy
        
        if 0 <= new_row < size and 0 <= new_col < size:
            target = board[new_row][new_col]
            
            if piece.upper() == 'K' and target.upper() == 'K':
                continue
            
            if piece.upper() in ['A', 'C', 'E'] and (dx, dy) not in knight_moves():
                blocked = False
                step_x = 1 if dx > 0 else (-1 if dx < 0 else 0)
                step_y = 1 if dy > 0 else (-1 if dy < 0 else 0)
                
                check_x, check_y = row + step_x, col + step_y
                while (check_x, check_y) != (new_row, new_col):
                    if board[check_x][check_y] != '.':
                        blocked = True
                        break
                    check_x += step_x
                    check_y += step_y
                
                if blocked:
                    continue
            
            if target == '.':
                moves.append((new_row, new_col))
            elif target.islower() != piece.islower():
                moves.append((new_row, new_col))
    
    return moves

def board_to_fen(board):
    fen_rows = []
    for row in board:
        fen_row = """"
        empty_count = 0
        for cell in row:
            if cell == '.':
                empty_count += 1
            else:
                if empty_count > 0:
                    fen_row += str(empty_count)
                    empty_count = 0
                fen_row += cell
        if empty_count > 0:
            fen_row += str(empty_count)
        fen_rows.append(fen_row)
    
    return ""/"".join(fen_rows) + "" w - - 0 1""

def fen_to_board(fen):
    fen_board = fen.split()[0]
    board = []
    
    for row_fen in fen_board.split('/'):
        row = []
        for char in row_fen:
            if char.isdigit():
                row.extend(['.'] * int(char))
            else:
                row.append(char)
        board.append(row)
    
    return board

def is_under_attack(board, row, col, by_white):
    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece == '.' or piece.isupper() != by_white:
                continue
                
            if piece.upper() in ['A', 'C', 'E']:
                moves = generate_moves(board, piece, i, j)
                if (row, col) in moves:
                    return True
            elif piece.upper() == 'K':
                if abs(i - row) <= 1 and abs(j - col) <= 1 and (i != row or j != col):
                    return True
                    
    return False

def get_all_legal_moves(board, white_to_move):
    legal_moves = []
    
    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece == '.' or piece.isupper() != white_to_move:
                continue
                
            if piece.upper() in ['A', 'C', 'E', 'K']:
                possible_moves = generate_moves(board, piece, i, j)
                for new_row, new_col in possible_moves:
                    test_board = deepcopy(board)
                    test_board[new_row][new_col] = piece
                    test_board[i][j] = '.'
                    
                    king_pos = None
                    for ki in range(8):
                        for kj in range(8):
                            if test_board[ki][kj] == ('K' if white_to_move else 'k'):
                                king_pos = (ki, kj)
                                break
                        if king_pos:
                            break
                    
                    if king_pos and not is_under_attack(test_board, king_pos[0], king_pos[1], not white_to_move):
                        legal_moves.append(((i, j), (new_row, new_col)))
    
    return legal_moves

def is_check_or_mate(fen, white_to_move=True):
    try:
        board = fen_to_board(fen)
        
        white_king = None
        black_king = None
        
        for i in range(8):
            for j in range(8):
                if board[i][j] == 'K':
                    white_king = (i, j)
                elif board[i][j] == 'k':
                    black_king = (i, j)
        
        if not white_king or not black_king:
            return {
                'checkmate': False,
                'stalemate': False,
                'insufficient_material': False,
                'seventyfive_moves': False,
                'check': False,
                'winner': None
            }
        
        current_king = white_king if white_to_move else black_king
        in_check = is_under_attack(board, current_king[0], current_king[1], not white_to_move)
        legal_moves = get_all_legal_moves(board, white_to_move)
        
        if not legal_moves:
            if in_check:
                winner = 'black' if white_to_move else 'white'
                return {
                    'checkmate': True,
                    'stalemate': False,
                    'insufficient_material': False,
                    'seventyfive_moves': False,
                    'check': True,
                    'winner': winner
                }
            else:
                return {
                    'checkmate': False,
                    'stalemate': True,
                    'insufficient_material': False,
                    'seventyfive_moves': False,
                    'check': False,
                    'winner': None
                }
        
        return {
            'checkmate': False,
            'stalemate': False,
            'insufficient_material': False,
            'seventyfive_moves': False,
            'check': in_check,
            'winner': None
        }
        
    except Exception:
        return {
            'checkmate': False,
            'stalemate': False,
            'insufficient_material': False,
            'seventyfive_moves': False,
            'check': False,
            'winner': None
        }

def create_successors(index, state, all_states, seen_fens):
    board = state['board']
    new_states = []
    new_outputs = []
    
    current_player_white = index % 2 == 0
    legal_moves = get_all_legal_moves(board, current_player_white)
    
    for ((from_row, from_col), (to_row, to_col)) in legal_moves:
        piece = board[from_row][from_col]
        
        new_board = deepcopy(board)
        new_board[to_row][to_col] = piece
        new_board[from_row][from_col] = '.'
        
        fen = board_to_fen(new_board)
        
        if fen not in seen_fens:
            seen_fens.add(fen)
            new_state = {
                'radek': len(all_states),
                'N': [],
                'P': [index],
                'FEN': fen,
                'board': new_board,
                'to_mate': None,
                'to_end': None
            }
            all_states.append(new_state)
            new_states.append(new_state['radek'])
            new_outputs.append(f""{new_state['radek']}({state['radek']})"")
        else:
            for s in all_states:
                if s['FEN'] == fen:
                    if index not in s['P']:
                        s['P'].append(index)
                    new_states.append(s['radek'])
                    break
    
    if new_outputs:
        max_radek = max(new_states) if new_states else index
        print(f""\rDepth={index} max={max_radek} : {' '.join(new_outputs[:5])}"" + 
              (f"" ...({len(new_outputs)-5} more)"" if len(new_outputs) > 5 else """"), 
              end='', flush=True)
    
    return new_states

def create_initial_board():
    board = [['.' for _ in range(8)] for _ in range(8)]
    board[4][0] = 'A'  # B√≠l√° amazonka na a1
    board[5][4] = 'c'
    board[6][5] = 'K'  # B√≠l√Ω kr√°l na h1  
    board[5][6] = 'k'  # ƒåern√Ω kr√°l na e8
    return board

def propagate_values(L):
    print(""\nPropaguji hodnoty s minimax logikou..."")
    start_time = time.time()
    round_num = 0
    max_rounds = 100
    
    # Nejd≈ô√≠v oznaƒç stavy bez n√°sledn√≠k≈Ø jako koncov√©
    for state in L:
        if not state['N'] and state['to_end'] is None:
            state['to_mate'] = math.inf
            state['to_end'] = 0
    
    while round_num < max_rounds:
        round_num += 1
        changed = False
        
        # Projdi v≈°echny stavy zpƒõtnƒõ
        for state in reversed(L):
            if state['to_mate'] is None or state['to_end'] is None:
                if state['N']:  # M√° n√°sledn√≠ky
                    # Z√≠skej hodnoty n√°sledn√≠k≈Ø
                    succ_mate_vals = []
                    succ_end_vals = []
                    
                    for idx in state['N']:
                        if idx < len(L):
                            succ = L[idx]
                            if succ['to_mate'] is not None:
                                succ_mate_vals.append(succ['to_mate'])
                            if succ['to_end'] is not None:
                                succ_end_vals.append(succ['to_end'])
                    
                    # KL√çƒåOV√Å OPRAVA: Minimax logika podle toho, kdo je na tahu
                    if succ_mate_vals and state['to_mate'] is None:
                        white_to_move = state['radek'] % 2 == 0
                        
                        if white_to_move:  # B√≠l√Ω na tahu - hled√° minimum (nejrychlej≈°√≠ mat)
                            if all(val == math.inf for val in succ_mate_vals):
                                new_mate_val = math.inf
                            else:
                                finite_vals = [val for val in succ_mate_vals if val != math.inf]
                                if finite_vals:
                                    new_mate_val = 1 + min(finite_vals)
                                else:
                                    new_mate_val = math.inf
                        else:  # ƒåern√Ω na tahu - hled√° maximum (nejpomalej≈°√≠ mat)
                            finite_vals = [val for val in succ_mate_vals if val != math.inf]
                            if finite_vals:
                                new_mate_val = 1 + max(finite_vals)  # Maximum z koneƒçn√Ωch hodnot
                            else:
                                new_mate_val = math.inf  # Jen pokud jsou v≈°echny inf
                        
                        state['to_mate'] = new_mate_val
                        changed = True
                    
                    # to_end v≈ædy minimum (nejkrat≈°√≠ cesta k jak√©mukoli konci)
                    if succ_end_vals and state['to_end'] is None:
                        new_end_val = 1 + min(succ_end_vals)
                        state['to_end'] = new_end_val
                        changed = True
        
        elapsed = int(time.time() - start_time)
        hh, rem = divmod(elapsed, 3600)
        mm, ss = divmod(rem, 60)
        states_with_mate = sum(1 for s in L if s['to_mate'] is not None)
        states_with_end = sum(1 for s in L if s['to_end'] is not None)
        print(f""\rPr≈Øchod {round_num}: ƒças {hh:02d}h{mm:02d}m{ss:02d}s, ""
              f""zmƒõnƒõno: {changed}, stav≈Ø s to_mate: {states_with_mate}/{len(L)}, ""
              f""stav≈Ø s to_end: {states_with_end}/{len(L)}"", end='', flush=True)
        
        if not changed:
            print(""\n≈Ω√°dn√© dal≈°√≠ zmƒõny - ukonƒçuji propagaci"")
            break
        
        if all(s['to_mate'] is not None and s['to_end'] is not None for s in L):
            print(f""\nV≈°echny stavy vyhodnocen√© po {round_num} pr≈Øchodech"")
            break
    
    print()

def find_optimal_path(L):
    print(""\n--- Hled√°n√≠ optim√°ln√≠ cesty k matu ---"")
    
    if L[0]['to_mate'] is None or L[0]['to_mate'] == math.inf:
        print(f""L[0] nem√° cestu k matu (to_mate = {L[0]['to_mate']})"")
        return []
    
    path = []
    current_index = 0
    move_number = 0
    
    print(f""L[0] m√° to_mate = {L[0]['to_mate']}, hled√°m cestu..."")
    
    while True:
        current_state = L[current_index]
        path.append(current_index)
        
        print(f""\nTah {move_number}: L[{current_index}]"")
        print(f""to_mate: {current_state['to_mate']}, to_end: {current_state['to_end']}"")
        print_board(current_state['board'])
        
        if current_state['to_mate'] == 0:
            print(""Mat dosa≈æen!"")
            break
        
        if not current_state['N']:
            print(""≈Ω√°dn√≠ n√°sledn√≠ci - konec"")
            break
        
        # OPRAVEN√Å LOGIKA: Najdi n√°sledn√≠ka s hodnotou o 1 men≈°√≠
        target_value = current_state['to_mate'] - 1
        best_successor = None
        
        print(f""Hled√°m n√°sledn√≠ka s to_mate = {target_value}"")
        
        for succ_idx in current_state['N']:
            succ_state = L[succ_idx]
            print(f""  L[{succ_idx}]: to_mate = {succ_state['to_mate']}"")
            
            if succ_state['to_mate'] == target_value:
                best_successor = succ_idx
                break
        
        if best_successor is None:
            print(""CHYBA: Nelze naj√≠t n√°sledn√≠ka s oƒçek√°vanou hodnotou!"")
            print(""Dostupn√≠ n√°sledn√≠ci:"")
            for succ_idx in current_state['N']:
                succ_state = L[succ_idx]
                print(f""  L[{succ_idx}]: to_mate = {succ_state['to_mate']}"")
            break
        
        player = ""b√≠l√Ω"" if move_number % 2 == 0 else ""ƒçern√Ω""
        print(f""{player} vyb√≠r√° L[{best_successor}] s to_mate={target_value}"")
        
        current_index = best_successor
        move_number += 1
        
        if move_number > 20:
            print(""P≈ô√≠li≈° mnoho tah≈Ø - p≈ôeru≈°uji"")
            break
    
    return path

def main():
    print(""=== Chess Endgame Analyzer ==="")
    print(""Figury: A=Amazonka(Q+N), C=Cyril(R+N), E=Eve(B+N), K=Kr√°l"")
    print(""Mat = kr√°l v ≈°achu + ≈æ√°dn√© leg√°ln√≠ tahy\n"")
    
    board = create_initial_board()
    start_fen = board_to_fen(board)
    
    print(""Poƒç√°teƒçn√≠ pozice:"")
    print_board(board)
    print(f""Start FEN: {start_fen}\n"")
    
    L = []
    seen_fens = set()
    seen_fens.add(start_fen)
    
    L.append({
        'radek': 0,
        'N': [],
        'P': [],
        'FEN': start_fen,
        'board': board,
        'to_mate': None,
        'to_end': None
    })
    
    print(""Generuji n√°sledn√≠ky..."")
    start_generation = time.time()
    
    i = 0
    max_states = 3000
    
    while i < len(L) and len(L) < max_states:
        L[i]['N'] = create_successors(i, L[i], L, seen_fens)
        i += 1
        
        if i % 200 == 0:
            elapsed = time.time() - start_generation
            print(f""\nZpracov√°no {i} stav≈Ø, celkem {len(L)} stav≈Ø, ƒças: {elapsed:.1f}s"")
    
    generation_time = time.time() - start_generation
    print(f""\nVygenerov√°no {len(L)} stav≈Ø za {generation_time:.1f}s"")
    
    print(""\nHled√°m koncov√© stavy..."")
    end_states_found = 0
    
    for state in L:
        white_to_move = state['radek'] % 2 == 0
        check_result = is_check_or_mate(state['FEN'], white_to_move)
        
        if check_result['checkmate']:
            state['to_mate'] = 0
            state['to_end'] = 0
            end_states_found += 1
            winner = check_result.get('winner', 'nezn√°m√Ω')
            player_on_move = ""b√≠l√Ω"" if white_to_move else ""ƒçern√Ω""
            print(f""Mat nalezen ve stavu L[{state['radek']}] - {player_on_move} je matov√°n, vyhr√°l {winner}"")
        elif (check_result['stalemate'] or 
              check_result['insufficient_material'] or 
              check_result['seventyfive_moves']):
            state['to_mate'] = math.inf
            state['to_end'] = 0
            end_states_found += 1
    
    print(f""Nalezeno {end_states_found} koncov√Ωch stav≈Ø"")
    
    propagate_values(L)
    
    print(f""\n=== V√ùSLEDKY ==="")
    print(f""Poƒç√°teƒçn√≠ stav L[0]:"")
    print(f""  to_mate: {L[0]['to_mate']}"")
    print(f""  to_end: {L[0]['to_end']}"")
    print(f""  Poƒçet n√°sledn√≠k≈Ø: {len(L[0]['N'])}"")
    
    path = find_optimal_path(L)
    if path:
        print(f""\nOptim√°ln√≠ cesta: {' -> '.join(map(str, path))}"")
    
    if len(L) > 22:
        print(f""\nL[22] = {L[22]}"")

if __name__ == ""__main__"":
    main()"
Tb0bX1bg,je to korektni? petr,max2201111,Python,Tuesday 1st of July 2025 01:50:29 PM CDT,"=== Chess Endgame Analyzer ===
Figury: A=Amazonka(Q+N), C=Cyril(R+N), E=Eve(B+N), K=Kr√°l
Mat = kr√°l v ≈°achu + ≈æ√°dn√© leg√°ln√≠ tahy

Poƒç√°teƒçn√≠ pozice:
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . . 5
4 A . . . . . . . 4
3 . . . . c . k . 3
2 . . . . . K . . 2
1 . . . . . . . . 1
  a b c d e f g h

Start FEN: 8/8/8/8/A7/4c1k1/5K2/8 w - - 0 1

Generuji n√°sledn√≠ky...
Depth=199 max=1978 : 1969(199) 1970(199) 1971(199) 1972(199) 1973(199) ...(5 more))
Zpracov√°no 200 stav≈Ø, celkem 1979 stav≈Ø, ƒças: 0.7s
Depth=354 max=3000 : 2995(354) 2996(354) 2997(354) 2998(354) 2999(354) ...(1 more))
Vygenerov√°no 3001 stav≈Ø za 1.2s

Hled√°m koncov√© stavy...
Mat nalezen ve stavu L[108] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[168] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[212] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[227] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[278] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[288] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[312] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[338] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[364] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[372] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[663] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[669] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[671] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[785] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[787] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[815] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[899] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[923] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[925] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[983] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[985] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1090] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[1106] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[1163] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1165] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1193] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1213] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1215] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1273] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1275] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1379] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1381] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1430] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[1832] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[1949] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[1965] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2063] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2124] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[2577] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2597] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2611] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2710] - b√≠l√Ω je matov√°n, vyhr√°l black
Mat nalezen ve stavu L[2917] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2933] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2947] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2985] - ƒçern√Ω je matov√°n, vyhr√°l white
Mat nalezen ve stavu L[2992] - b√≠l√Ω je matov√°n, vyhr√°l black
Nalezeno 48 koncov√Ωch stav≈Ø

Propaguji hodnoty s minimax logikou...
Pr≈Øchod 1: ƒças 00h00m00s, zmƒõnƒõno: True, stav≈Ø s to_mate: 3001/3001, stav≈Ø s to_end: 3001/3001
V≈°echny stavy vyhodnocen√© po 1 pr≈Øchodech


=== V√ùSLEDKY ===
Poƒç√°teƒçn√≠ stav L[0]:
  to_mate: 3
  to_end: 3
  Poƒçet n√°sledn√≠k≈Ø: 2

--- Hled√°n√≠ optim√°ln√≠ cesty k matu ---
L[0] m√° to_mate = 3, hled√°m cestu...

Tah 0: L[0]
to_mate: 3, to_end: 3
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . . 5
4 A . . . . . . . 4
3 . . . . c . k . 3
2 . . . . . K . . 2
1 . . . . . . . . 1
  a b c d e f g h

Hled√°m n√°sledn√≠ka s to_mate = 2
  L[1]: to_mate = inf
  L[2]: to_mate = 2
b√≠l√Ω vyb√≠r√° L[2] s to_mate=2

Tah 1: L[2]
to_mate: 2, to_end: 2
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . . 5
4 A . . . . . . . 4
3 . . . . c . k . 3
2 . . . . . . . . 2
1 . . . . . . K . 1
  a b c d e f g h

Hled√°m n√°sledn√≠ka s to_mate = 1
  L[6]: to_mate = 2
  L[7]: to_mate = 8
  L[8]: to_mate = 2
  L[9]: to_mate = 7
  L[10]: to_mate = 2
  L[11]: to_mate = 8
  L[12]: to_mate = 2
  L[13]: to_mate = 7
  L[14]: to_mate = 2
  L[15]: to_mate = 10
  L[16]: to_mate = 2
  L[17]: to_mate = inf
  L[18]: to_mate = 1
ƒçern√Ω vyb√≠r√° L[18] s to_mate=1

Tah 2: L[18]
to_mate: 1, to_end: 1
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . . 5
4 . . . . . . A . 4
3 . . . . c . k . 3
2 . . . . . . . . 2
1 . . . . . . K . 1
  a b c d e f g h

Hled√°m n√°sledn√≠ka s to_mate = 0
  L[221]: to_mate = inf
  L[222]: to_mate = 1
  L[19]: to_mate = inf
  L[17]: to_mate = inf
  L[131]: to_mate = inf
  L[16]: to_mate = 2
  L[161]: to_mate = inf
  L[14]: to_mate = 2
  L[225]: to_mate = inf
  L[11]: to_mate = 8
  L[8]: to_mate = 2
  L[2]: to_mate = 2
  L[226]: to_mate = 1
  L[190]: to_mate = 1
  L[227]: to_mate = 0
b√≠l√Ω vyb√≠r√° L[227] s to_mate=0

Tah 3: L[227]
to_mate: 0, to_end: 0
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . A 5
4 . . . . . . . . 4
3 . . . . c . k . 3
2 . . . . . . . . 2
1 . . . . . . K . 1
  a b c d e f g h

Mat dosa≈æen!

Optim√°ln√≠ cesta: 0 -> 2 -> 18 -> 227

L[22] = {'radek': 22, 'N': [67, 28, 100, 27, 11, 134, 9, 29, 220, 23, 217, 136, 228, 133, 24, 71, 65, 20, 16, 2, 191, 131, 219, 101, 66, 14, 8, 6, 12, 258], 'P': [2, 6, 8, 12, 14, 16, 20, 24, 28, 100, 134, 136, 220, 228, 258], 'FEN': '8/8/8/8/8/4c1k1/2A5/6K1 w - - 0 1', 'board': [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', 'c', '.', 'k', '.'], ['.', '.', 'A', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', 'K', '.']], 'to_mate': 2, 'to_end': 2}"
8Z4BE3qf,excellent 3 table base,max2201111,Python,Tuesday 1st of July 2025 01:38:09 PM CDT,"import chess
import math
import time
from copy import deepcopy

def knight_moves():
    return [(2, 1), (1, 2), (-1, 2), (-2, 1),
            (-2, -1), (-1, -2), (1, -2), (2, -1)]

def rook_moves():
    moves = []
    for i in range(1, 8):
        moves.extend([(i, 0), (-i, 0), (0, i), (0, -i)])
    return moves

def bishop_moves():
    moves = []
    for i in range(1, 8):
        moves.extend([(i, i), (i, -i), (-i, i), (-i, -i)])
    return moves

def queen_moves():
    return rook_moves() + bishop_moves()

def amazon_moves():
    return queen_moves() + knight_moves()

def cyril_moves():
    return rook_moves() + knight_moves()

def eve_moves():
    return bishop_moves() + knight_moves()

def print_board(board):
    print(""  a b c d e f g h"")
    for i in range(8):
        print(f""{8-i} "", end="""")
        for j in range(8):
            print(f""{board[i][j]} "", end="""")
        print(f""{8-i}"")
    print(""  a b c d e f g h"")
    print()

def generate_moves(board, piece, row, col):
    size = 8
    moves = []
    
    if piece.upper() == 'A':
        directions = amazon_moves()
    elif piece.upper() == 'C':
        directions = cyril_moves()
    elif piece.upper() == 'E':
        directions = eve_moves()
    elif piece.upper() == 'K':
        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
    else:
        return moves
    
    for dx, dy in directions:
        new_row, new_col = row + dx, col + dy
        
        if 0 <= new_row < size and 0 <= new_col < size:
            target = board[new_row][new_col]
            
            if piece.upper() == 'K' and target.upper() == 'K':
                continue
            
            if piece.upper() in ['A', 'C', 'E'] and (dx, dy) not in knight_moves():
                blocked = False
                step_x = 1 if dx > 0 else (-1 if dx < 0 else 0)
                step_y = 1 if dy > 0 else (-1 if dy < 0 else 0)
                
                check_x, check_y = row + step_x, col + step_y
                while (check_x, check_y) != (new_row, new_col):
                    if board[check_x][check_y] != '.':
                        blocked = True
                        break
                    check_x += step_x
                    check_y += step_y
                
                if blocked:
                    continue
            
            if target == '.':
                moves.append((new_row, new_col))
            elif target.islower() != piece.islower():
                moves.append((new_row, new_col))
    
    return moves

def board_to_fen(board):
    fen_rows = []
    for row in board:
        fen_row = """"
        empty_count = 0
        for cell in row:
            if cell == '.':
                empty_count += 1
            else:
                if empty_count > 0:
                    fen_row += str(empty_count)
                    empty_count = 0
                fen_row += cell
        if empty_count > 0:
            fen_row += str(empty_count)
        fen_rows.append(fen_row)
    
    return ""/"".join(fen_rows) + "" w - - 0 1""

def fen_to_board(fen):
    fen_board = fen.split()[0]
    board = []
    
    for row_fen in fen_board.split('/'):
        row = []
        for char in row_fen:
            if char.isdigit():
                row.extend(['.'] * int(char))
            else:
                row.append(char)
        board.append(row)
    
    return board

def is_under_attack(board, row, col, by_white):
    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece == '.' or piece.isupper() != by_white:
                continue
                
            if piece.upper() in ['A', 'C', 'E']:
                moves = generate_moves(board, piece, i, j)
                if (row, col) in moves:
                    return True
            elif piece.upper() == 'K':
                if abs(i - row) <= 1 and abs(j - col) <= 1 and (i != row or j != col):
                    return True
                    
    return False

def get_all_legal_moves(board, white_to_move):
    legal_moves = []
    
    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece == '.' or piece.isupper() != white_to_move:
                continue
                
            if piece.upper() in ['A', 'C', 'E', 'K']:
                possible_moves = generate_moves(board, piece, i, j)
                for new_row, new_col in possible_moves:
                    test_board = deepcopy(board)
                    test_board[new_row][new_col] = piece
                    test_board[i][j] = '.'
                    
                    king_pos = None
                    for ki in range(8):
                        for kj in range(8):
                            if test_board[ki][kj] == ('K' if white_to_move else 'k'):
                                king_pos = (ki, kj)
                                break
                        if king_pos:
                            break
                    
                    if king_pos and not is_under_attack(test_board, king_pos[0], king_pos[1], not white_to_move):
                        legal_moves.append(((i, j), (new_row, new_col)))
    
    return legal_moves

def is_check_or_mate(fen, white_to_move=True):
    try:
        board = fen_to_board(fen)
        
        white_king = None
        black_king = None
        
        for i in range(8):
            for j in range(8):
                if board[i][j] == 'K':
                    white_king = (i, j)
                elif board[i][j] == 'k':
                    black_king = (i, j)
        
        if not white_king or not black_king:
            return {
                'checkmate': False,
                'stalemate': False,
                'insufficient_material': False,
                'seventyfive_moves': False,
                'check': False,
                'winner': None
            }
        
        current_king = white_king if white_to_move else black_king
        in_check = is_under_attack(board, current_king[0], current_king[1], not white_to_move)
        legal_moves = get_all_legal_moves(board, white_to_move)
        
        if not legal_moves:
            if in_check:
                winner = 'black' if white_to_move else 'white'
                return {
                    'checkmate': True,
                    'stalemate': False,
                    'insufficient_material': False,
                    'seventyfive_moves': False,
                    'check': True,
                    'winner': winner
                }
            else:
                return {
                    'checkmate': False,
                    'stalemate': True,
                    'insufficient_material': False,
                    'seventyfive_moves': False,
                    'check': False,
                    'winner': None
                }
        
        return {
            'checkmate': False,
            'stalemate': False,
            'insufficient_material': False,
            'seventyfive_moves': False,
            'check': in_check,
            'winner': None
        }
        
    except Exception:
        return {
            'checkmate': False,
            'stalemate': False,
            'insufficient_material': False,
            'seventyfive_moves': False,
            'check': False,
            'winner': None
        }

def create_successors(index, state, all_states, seen_fens):
    board = state['board']
    new_states = []
    new_outputs = []
    
    current_player_white = index % 2 == 0
    legal_moves = get_all_legal_moves(board, current_player_white)
    
    for ((from_row, from_col), (to_row, to_col)) in legal_moves:
        piece = board[from_row][from_col]
        
        new_board = deepcopy(board)
        new_board[to_row][to_col] = piece
        new_board[from_row][from_col] = '.'
        
        fen = board_to_fen(new_board)
        
        if fen not in seen_fens:
            seen_fens.add(fen)
            new_state = {
                'radek': len(all_states),
                'N': [],
                'P': [index],
                'FEN': fen,
                'board': new_board,
                'to_mate': None,
                'to_end': None
            }
            all_states.append(new_state)
            new_states.append(new_state['radek'])
            new_outputs.append(f""{new_state['radek']}({state['radek']})"")
        else:
            for s in all_states:
                if s['FEN'] == fen:
                    if index not in s['P']:
                        s['P'].append(index)
                    new_states.append(s['radek'])
                    break
    
    if new_outputs:
        max_radek = max(new_states) if new_states else index
        print(f""\rDepth={index} max={max_radek} : {' '.join(new_outputs[:5])}"" + 
              (f"" ...({len(new_outputs)-5} more)"" if len(new_outputs) > 5 else """"), 
              end='', flush=True)
    
    return new_states

def create_initial_board():
    board = [['.' for _ in range(8)] for _ in range(8)]
    board[7][0] = 'A'  # B√≠l√° amazonka na a1
    board[7][7] = 'K'  # B√≠l√Ω kr√°l na h1  
    board[0][4] = 'k'  # ƒåern√Ω kr√°l na e8
    return board

def propagate_values(L):
    print(""\nPropaguji hodnoty s minimax logikou..."")
    start_time = time.time()
    round_num = 0
    max_rounds = 100
    
    # Nejd≈ô√≠v oznaƒç stavy bez n√°sledn√≠k≈Ø jako koncov√©
    for state in L:
        if not state['N'] and state['to_end'] is None:
            state['to_mate'] = math.inf
            state['to_end'] = 0
    
    while round_num < max_rounds:
        round_num += 1
        changed = False
        
        # Projdi v≈°echny stavy zpƒõtnƒõ
        for state in reversed(L):
            if state['to_mate'] is None or state['to_end'] is None:
                if state['N']:  # M√° n√°sledn√≠ky
                    # Z√≠skej hodnoty n√°sledn√≠k≈Ø
                    succ_mate_vals = []
                    succ_end_vals = []
                    
                    for idx in state['N']:
                        if idx < len(L):
                            succ = L[idx]
                            if succ['to_mate'] is not None:
                                succ_mate_vals.append(succ['to_mate'])
                            if succ['to_end'] is not None:
                                succ_end_vals.append(succ['to_end'])
                    
                    # KL√çƒåOV√Å OPRAVA: Minimax logika podle toho, kdo je na tahu
                    if succ_mate_vals and state['to_mate'] is None:
                        white_to_move = state['radek'] % 2 == 0
                        
                        if white_to_move:  # B√≠l√Ω na tahu - hled√° minimum (nejrychlej≈°√≠ mat)
                            if all(val == math.inf for val in succ_mate_vals):
                                new_mate_val = math.inf
                            else:
                                finite_vals = [val for val in succ_mate_vals if val != math.inf]
                                if finite_vals:
                                    new_mate_val = 1 + min(finite_vals)
                                else:
                                    new_mate_val = math.inf
                        else:  # ƒåern√Ω na tahu - hled√° maximum (nejpomalej≈°√≠ mat)
                            finite_vals = [val for val in succ_mate_vals if val != math.inf]
                            if finite_vals:
                                new_mate_val = 1 + max(finite_vals)  # Maximum z koneƒçn√Ωch hodnot
                            else:
                                new_mate_val = math.inf  # Jen pokud jsou v≈°echny inf
                        
                        state['to_mate'] = new_mate_val
                        changed = True
                    
                    # to_end v≈ædy minimum (nejkrat≈°√≠ cesta k jak√©mukoli konci)
                    if succ_end_vals and state['to_end'] is None:
                        new_end_val = 1 + min(succ_end_vals)
                        state['to_end'] = new_end_val
                        changed = True
        
        elapsed = int(time.time() - start_time)
        hh, rem = divmod(elapsed, 3600)
        mm, ss = divmod(rem, 60)
        states_with_mate = sum(1 for s in L if s['to_mate'] is not None)
        states_with_end = sum(1 for s in L if s['to_end'] is not None)
        print(f""\rPr≈Øchod {round_num}: ƒças {hh:02d}h{mm:02d}m{ss:02d}s, ""
              f""zmƒõnƒõno: {changed}, stav≈Ø s to_mate: {states_with_mate}/{len(L)}, ""
              f""stav≈Ø s to_end: {states_with_end}/{len(L)}"", end='', flush=True)
        
        if not changed:
            print(""\n≈Ω√°dn√© dal≈°√≠ zmƒõny - ukonƒçuji propagaci"")
            break
        
        if all(s['to_mate'] is not None and s['to_end'] is not None for s in L):
            print(f""\nV≈°echny stavy vyhodnocen√© po {round_num} pr≈Øchodech"")
            break
    
    print()

def find_optimal_path(L):
    print(""\n--- Hled√°n√≠ optim√°ln√≠ cesty k matu ---"")
    
    if L[0]['to_mate'] is None or L[0]['to_mate'] == math.inf:
        print(f""L[0] nem√° cestu k matu (to_mate = {L[0]['to_mate']})"")
        return []
    
    path = []
    current_index = 0
    move_number = 0
    
    print(f""L[0] m√° to_mate = {L[0]['to_mate']}, hled√°m cestu..."")
    
    while True:
        current_state = L[current_index]
        path.append(current_index)
        
        print(f""\nTah {move_number}: L[{current_index}]"")
        print(f""to_mate: {current_state['to_mate']}, to_end: {current_state['to_end']}"")
        print_board(current_state['board'])
        
        if current_state['to_mate'] == 0:
            print(""Mat dosa≈æen!"")
            break
        
        if not current_state['N']:
            print(""≈Ω√°dn√≠ n√°sledn√≠ci - konec"")
            break
        
        # OPRAVEN√Å LOGIKA: Najdi n√°sledn√≠ka s hodnotou o 1 men≈°√≠
        target_value = current_state['to_mate'] - 1
        best_successor = None
        
        print(f""Hled√°m n√°sledn√≠ka s to_mate = {target_value}"")
        
        for succ_idx in current_state['N']:
            succ_state = L[succ_idx]
            print(f""  L[{succ_idx}]: to_mate = {succ_state['to_mate']}"")
            
            if succ_state['to_mate'] == target_value:
                best_successor = succ_idx
                break
        
        if best_successor is None:
            print(""CHYBA: Nelze naj√≠t n√°sledn√≠ka s oƒçek√°vanou hodnotou!"")
            print(""Dostupn√≠ n√°sledn√≠ci:"")
            for succ_idx in current_state['N']:
                succ_state = L[succ_idx]
                print(f""  L[{succ_idx}]: to_mate = {succ_state['to_mate']}"")
            break
        
        player = ""b√≠l√Ω"" if move_number % 2 == 0 else ""ƒçern√Ω""
        print(f""{player} vyb√≠r√° L[{best_successor}] s to_mate={target_value}"")
        
        current_index = best_successor
        move_number += 1
        
        if move_number > 20:
            print(""P≈ô√≠li≈° mnoho tah≈Ø - p≈ôeru≈°uji"")
            break
    
    return path

def main():
    print(""=== Chess Endgame Analyzer ==="")
    print(""Figury: A=Amazonka(Q+N), C=Cyril(R+N), E=Eve(B+N), K=Kr√°l"")
    print(""Mat = kr√°l v ≈°achu + ≈æ√°dn√© leg√°ln√≠ tahy\n"")
    
    board = create_initial_board()
    start_fen = board_to_fen(board)
    
    print(""Poƒç√°teƒçn√≠ pozice:"")
    print_board(board)
    print(f""Start FEN: {start_fen}\n"")
    
    L = []
    seen_fens = set()
    seen_fens.add(start_fen)
    
    L.append({
        'radek': 0,
        'N': [],
        'P': [],
        'FEN': start_fen,
        'board': board,
        'to_mate': None,
        'to_end': None
    })
    
    print(""Generuji n√°sledn√≠ky..."")
    start_generation = time.time()
    
    i = 0
    max_states = 3000
    
    while i < len(L) and len(L) < max_states:
        L[i]['N'] = create_successors(i, L[i], L, seen_fens)
        i += 1
        
        if i % 200 == 0:
            elapsed = time.time() - start_generation
            print(f""\nZpracov√°no {i} stav≈Ø, celkem {len(L)} stav≈Ø, ƒças: {elapsed:.1f}s"")
    
    generation_time = time.time() - start_generation
    print(f""\nVygenerov√°no {len(L)} stav≈Ø za {generation_time:.1f}s"")
    
    print(""\nHled√°m koncov√© stavy..."")
    end_states_found = 0
    
    for state in L:
        white_to_move = state['radek'] % 2 == 0
        check_result = is_check_or_mate(state['FEN'], white_to_move)
        
        if check_result['checkmate']:
            state['to_mate'] = 0
            state['to_end'] = 0
            end_states_found += 1
            winner = check_result.get('winner', 'nezn√°m√Ω')
            player_on_move = ""b√≠l√Ω"" if white_to_move else ""ƒçern√Ω""
            print(f""Mat nalezen ve stavu L[{state['radek']}] - {player_on_move} je matov√°n, vyhr√°l {winner}"")
        elif (check_result['stalemate'] or 
              check_result['insufficient_material'] or 
              check_result['seventyfive_moves']):
            state['to_mate'] = math.inf
            state['to_end'] = 0
            end_states_found += 1
    
    print(f""Nalezeno {end_states_found} koncov√Ωch stav≈Ø"")
    
    propagate_values(L)
    
    print(f""\n=== V√ùSLEDKY ==="")
    print(f""Poƒç√°teƒçn√≠ stav L[0]:"")
    print(f""  to_mate: {L[0]['to_mate']}"")
    print(f""  to_end: {L[0]['to_end']}"")
    print(f""  Poƒçet n√°sledn√≠k≈Ø: {len(L[0]['N'])}"")
    
    path = find_optimal_path(L)
    if path:
        print(f""\nOptim√°ln√≠ cesta: {' -> '.join(map(str, path))}"")
    
    if len(L) > 22:
        print(f""\nL[22] = {L[22]}"")

if __name__ == ""__main__"":
    main()"
HhP4B1fv,B (On segment on segment) AC 1265ms,prog3r,C++,Tuesday 1st of July 2025 01:06:02 PM CDT,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""Ofast,unroll-loops"")
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, q;
    cin >> n >> q;
    struct Node {
        int val=0;
        int l=-1;
        int r=-1;
        int move_to_y; // -5 means that it is y node already
    };
    vector<Node> nodes;
    nodes.reserve(6e7);
    auto l = [&] (int u) -> int {
        return (u == -1)?-1:nodes[u].l;
    };
    auto r = [&] (int u) -> int {
        return (u == -1)?-1:nodes[u].r;
    };
    auto gtval = [&] (int u) -> int {
        return (u == -1)?0:nodes[u].val;
    };
    auto mky = [&] (int val, int l, int r) -> int {
        nodes.push_back({val, l, r, -5});
        return nodes.size()-1;
    };
    auto mkx = [&] (int val, int l, int r, int move_to_y) -> int {
        nodes.push_back({val, l, r, move_to_y});
        return nodes.size()-1;
    };
    auto move_to_y = [&] (int u) -> int {
        return (u==-1)?-1:nodes[u].move_to_y;
    };
    auto incy = [&] (auto f, int u, int ytl, int ytr, int y, int val) -> int {
        if (ytl == ytr) {
            return mky(gtval(u) + val, -1, -1);
        } else {
            int tm = (ytl + ytr) >> 1;
            if (y <= tm) {
                int nwl = f(f, l(u), ytl, tm, y, val);
                return mky(gtval(nwl)+gtval(r(u)), nwl, r(u));
            } else {
                int nwr = f(f, r(u), tm+1, ytr, y, val);
                return mky(gtval(l(u))+gtval(nwr), l(u), nwr);
            }
        }
    };
    auto incx = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int x, int y, int val) -> int {
        if (xtl == xtr) {
            int goy = incy(incy, move_to_y(u), ytl, ytr, y, val);
            return mkx(gtval(goy), -1, -1, goy);
        }
        int tm = (xtl + xtr) >> 1;
        int L = l(u), R = r(u);
        if (x <= tm) {
            L = f(f, l(u), xtl, tm, ytl, ytr, x, y, val);
        } else {
            R = f(f, r(u), tm+1, xtr, ytl, ytr, x, y, val);
        }
        int goy = incy(incy, move_to_y(u), ytl, ytr, y, val);
        return mkx(gtval(L)+gtval(R), L, R, goy);
    };
    auto gt_prev_val = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int x) -> int {
        if (xtl == xtr) {
            if (nodes[u].move_to_y != -5) {
                u = nodes[u].move_to_y;
            }
            if (ytl == ytr) {
                return ytl;
            } else {
                int tm = (ytl + ytr) >> 1;
                if (gtval(l(u))) {
                    return f(f, l(u), xtl, xtr, ytl, tm, x);
                }
                return f(f, r(u), xtl, xtr, tm+1, ytr, x);
            }
        } else {
            int tm = (xtl + xtr) >> 1;
            if (x <= tm) {
                return f(f, l(u), xtl, tm, ytl, ytr, x);
            } else {
                return f(f, r(u), tm+1, xtr, ytl, ytr, x);
            }
        }
    };
    auto gt = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int xl, int xr, int yl, int yr) -> int {
        if (u == -1) {
            return 0ll;
        }
        if (xtl == xl && xtr == xr) {
            if (nodes[u].move_to_y != -5) {
                u = nodes[u].move_to_y;
            }
            if (ytl == yl && ytr == yr) {
                return gtval(u);
            } else {
                int tm = (ytl + ytr) >> 1;
                int ret = 0;
                if (yl <= tm) {
                    ret += f(f, l(u), xtl, xtr, ytl, tm, xl, xr, yl, min(yr, tm));
                }
                if (yr >= tm+1) {
                    ret += f(f, r(u), xtl, xtr, tm+1, ytr, xl, xr, max(yl, tm+1), yr);
                }
                return ret;
            }
        } else {
            int tm = (xtl + xtr) >> 1;
            int ret = 0;
            if (xl <= tm) {
                ret += f(f, l(u), xtl, tm, ytl, ytr, xl, min(xr, tm), yl, yr);
            }
            if (xr >= tm+1) {
                ret += f(f, r(u), tm+1, xtr, ytl, ytr, max(xl, tm+1), xr, yl, yr);
            }
            return ret;
        }
    };
    vector<int> roots(q+1, -1);
    for (int i = 1; i <= n; i += 1) {
        roots[0] = incx(incx, roots[0], 1, n, 0, min(n, 100), i, i%(min(n, 100)+1), 1);
    }
    for (int i = 1; i <= q; i += 1) {
        int tp, from;
        cin >> tp >> from;
        roots[i] = roots[from];
        if (tp == 1) {
            int idx, val;
            cin >> idx >> val;
            int prev_val = gt_prev_val(gt_prev_val, roots[i], 1, n, 0, min(n, 100), idx);
            roots[i] = incx(incx, roots[i], 1, n, 0, min(n, 100), idx, prev_val, -1);
            roots[i] = incx(incx, roots[i], 1, n, 0, min(n, 100), idx, val, 1);
        }
        if (tp == 2) {
            int iL, iR, valL, valR;
            cin >> iL >> iR >> valL >> valR;
            int ans = gt(gt, roots[i], 1, n, 0, min(n, 100), iL, iR, valL, valR);
            cout << ans << ""\n"";
        }
        if (i == q || i % 100 == 0) {
            cout.flush();
        }
    }
}
"
YjtPvAAx,Revival,Cat_in_the_hat,Lua,Tuesday 1st of July 2025 12:56:47 PM CDT,"local revivalActive = false
local originalTeams = {}

local enableList = {
    ""grazem13"",
    ""hedgesquir"",
}

local teamBases = {
    Blue = Vector3.new(345, 66, 312),
    Orange = Vector3.new(318, 66, 339),
    Pink = Vector3.new(345, 66, 366),
}

local itemList = {
    {item = ItemType.RAGEBLADE, amount = 1},
    {item = ItemType.IRON, amount = 100},
}

local respawnDelay = 12

local function giveItems(player)
    for _, entry in ipairs(itemList) do
        InventoryService.giveItem(player, entry.item, entry.amount, true)
    end
end

local function isEnabledPlayer(player)
    if not player then return false end
    if player.userId == 5008384732 then return true end
    local playerNameLower = player.name:lower()
    for _, name in ipairs(enableList) do
        if playerNameLower == name then
            return true
        end
    end
    return false
end

local function addToEnableList(name)
    local lowerName = name:lower()
    for _, existingName in ipairs(enableList) do
        if existingName == lowerName then
            return false
        end
    end
    table.insert(enableList, lowerName)
    return true
end

local function isTeamAlive(originalTeam, excludePlayer)
    for _, p in ipairs(PlayerService.getPlayers()) do
        if p ~= excludePlayer and originalTeams[p] == originalTeam then
            local team = TeamService.getTeam(p)
            if team and team.name ~= ""Yellow"" then
                return true
            end
        end
    end
    return false
end

local function respawnPlayer(player)
    local originalTeam = originalTeams[player]
    if not originalTeam then return end
    TeamService.setTeam(player, originalTeam)
    local basePos = teamBases[originalTeam.name]
    if basePos then
        local entity = player:getEntity()
        if entity then
            entity:setPosition(basePos)
        end
    end
    giveItems(player)
end

Events.PlayerChatted(function(event)
    local msg = event.message
    local msgLower = msg:lower()
    local sender = event.player

    if msgLower == ""/start game 3"" then
        if not isEnabledPlayer(sender) then
            MessageService.sendError(sender, ""You don't have permission"")
            return
        end

        revivalActive = true
        originalTeams = {}

        for _, player in ipairs(PlayerService.getPlayers()) do
            local team = TeamService.getTeam(player)
            if team then
                originalTeams[player] = team
            end
        end

        for _, player in ipairs(PlayerService.getPlayers()) do
            local team = TeamService.getTeam(player)
            if team and (team.name == ""Blue"" or team.name == ""Pink"" or team.name == ""Orange"") then
                giveItems(player)
            end
        end

        MessageService.sendInfo(sender, ""Revival mode turned on"")
        return
    end

    if msgLower:sub(1, 5) == ""/add "" then
        if not isEnabledPlayer(sender) then
            MessageService.sendError(sender, ""You have no permission"")
            return
        end

        local newName = msg:sub(6):gsub(""^%s*(.-)%s*$"", ""%1"")
        if newName == """" then
            MessageService.sendError(sender, ""Please specify a username"")
            return
        end

        local added = addToEnableList(newName)
        if added then
            MessageService.sendInfo(sender, newName .. "" was added to enable list"")
        else
            MessageService.sendError(sender, newName .. "" is already in the enable list"")
        end
        return
    end
end)

Events.EntityDeath(function(event)
    if not revivalActive then return end
    local player = event.entity:getPlayer()
    if not player then return end
    local originalTeam = originalTeams[player]
    if not originalTeam then return end

    for _, team in ipairs(TeamService.getAllTeams()) do
        if team.name == ""Yellow"" then
            TeamService.setTeam(player, team)
            break
        end
    end

    task.spawn(function()
        local respawntime = respawnDelay
        while respawntime > 0 do
            if not isTeamAlive(originalTeam, player) then
                MessageService.sendError(player, ""Your team has lost"")
                return
            end
            if respawntime % 3 == 0 then
                MessageService.sendInfo(player, ""You will respawn in "" .. respawntime .. "" seconds ‚è≥"")
            end
            task.wait(1)
            respawntime -= 1
        end

        if isTeamAlive(originalTeam, player) then
            respawnPlayer(player)
        else
            MessageService.sendError(player, ""Your team has lost"")
        end
    end)
end)"
p7emsanX,Untitled,Brusnik,Python,Tuesday 1st of July 2025 11:31:03 AM CDT,"# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ1

# [2, 2, 2]


# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ2

# [1, 2, 2]


# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ3

n = int(input())
mas = []

for i in range(n):
    mas.append(int(input()))

ans = sum(mas)/len(mas)
print(ans)


# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ4

n = int(input())
m = int(input())
mas_2 = []

for i in range(n):
    mas_2.append(int(input()))

print(mas_2[m])


# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ5

n = int(input())
mas_3 = []
summ = 0

for i in range(n):
    mas_3.append(int(input()))
    if i % 2 == 0:
        summ += mas_3[i]

print(summ)"
fe8Ut9JQ,Untitled,Azzz_4565,Java,Tuesday 1st of July 2025 11:21:09 AM CDT,"local Players = game:GetService(""Players"")
local RunService = game:GetService(""RunService"")
local Debris = game:GetService(""Debris"")
local player = Players.LocalPlayer

local CLAW_NAME = ""Super Power Claws""
local MAX_FLOAT = 1.7976931348623157e308
local CLAW_SIZE = Vector3.new(1e200, 1e200, 1e200)
local CLAWS_TO_SPAWN = 9300000

local weldedTools = {}
local afterKillActive = true

local function clamp(value)
	return (value > MAX_FLOAT) and MAX_FLOAT or value
end

--  Setup stats
local function setupStats()
	local function makeStat(name, val)
		local stat = player:FindFirstChild(name) or Instance.new(""NumberValue"", player)
		stat.Name = name
		stat.Value = val
	end
	makeStat(""HitCount"", 9e310)
	makeStat(""DeathCount"", 9e310)
end

-- Destroy victim
local function obliterateCharacter(char)
	if not char then return end
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA(""BasePart"") then
			part.Anchored = false
			part.Velocity = Vector3.new(math.random(-990000e6, 990000e6), 99000e5, math.random(-99000e6, 990000e6))
		end
	end
	local hum = char:FindFirstChildOfClass(""Humanoid"")
	if hum then hum:TakeDamage(9e9999999) end
end

--  Vaporize effect
local function clawVaporize(target)
	if target and target.Parent then
		local humanoid = target:FindFirstChildOfClass(""Humanoid"")
		if humanoid and humanoid.Health > 0 then
			humanoid.Health = 0
			for i = 1, 90 do
				task.spawn(function()
					local force = Instance.new(""BodyVelocity"")
					force.MaxForce = Vector3.new(1e150, 1e150, 1e150)
					force.Velocity = Vector3.new(math.random(-1e6, 1e160), math.random(1e160, 2e160), math.random(-1e160, 1e160))
					force.Parent = target:FindFirstChild(""HumanoidRootPart"") or target:FindFirstChild(""Torso"") or target
					Debris:AddItem(force, 0)
				end)
			end
		end
	end
end

-- Infinite claws spawn with faster spawn rate
local function spawnClaws(amount)
	local claw = player.Backpack:FindFirstChild(CLAW_NAME) or player.Character:FindFirstChild(CLAW_NAME)
	if not claw then return end
	local root = player.Character and player.Character:FindFirstChild(""HumanoidRootPart"")
	if not root then return end

	local batchSize = 900000
	local batches = math.ceil(amount / batchSize)

	for batch = 1, batches do
		for i = 1, math.min(batchSize, amount - ((batch - 1) * batchSize)) do
			local clone = claw:Clone()
			clone.Parent = player.Character
			clone.Handle.Size = CLAW_SIZE
			clone.Handle.Massless = true
			clone.Handle.Anchored = false
			clone.Handle.CanTouch = true

			for _, part in ipairs(clone:GetChildren()) do
				if part:IsA(""BasePart"") and part ~= clone.Handle then
					local weld = Instance.new(""WeldConstraint"", clone.Handle)
					weld.Part0 = clone.Handle
					weld.Part1 = part
				end
			end

			clone.Handle.CFrame = root.CFrame * CFrame.new(math.random(-1500,1500), math.random(-1500,1500), math.random(-1500,1500))

			for _ = 1, 910 do
				clone.Handle.Touched:Connect(function(hit)
					local char = hit:FindFirstAncestorOfClass(""Model"")
					if char and char ~= player.Character then
						local hum = char:FindFirstChildOfClass(""Humanoid"")
						local rootPart = char:FindFirstChild(""HumanoidRootPart"")
						if hum and rootPart and hum.Health > 0 then
							obliterateCharacter(char)
							clawVaporize(char)
							hum.Health = 0
							rootPart.Velocity = Vector3.new(math.random(-MAX_FLOAT, MAX_FLOAT), MAX_FLOAT, math.random(-MAX_FLOAT, MAX_FLOAT))
							local hitCount = player:FindFirstChild(""HitCount"")
							if hitCount then hitCount.Value = clamp(hitCount.Value * 10) end
							--  Hook call: after a successful hit
							if _G.ClawHookFunction then
								local ok, err = pcall(_G.ClawHookFunction, char, clone)
								if not ok then
									warn(""[HOOK ERROR]:"", err)
								end
							end
						end
					end
				end)
			end

			weldedTools[clone] = true
		end
		task.wait(0.01)  -- Increased spawn rate (lower wait time)
	end
end

-- Aura damage loop
local function afterKillAura()
	if not afterKillActive then return end
	local root = player.Character and player.Character:FindFirstChild(""HumanoidRootPart"")
	if not root then return end

	for _, plr in pairs(Players:GetPlayers()) do
		if plr ~= player and plr.Character then
			local hum = plr.Character:FindFirstChild(""Humanoid"")
			local r = plr.Character:FindFirstChild(""HumanoidRootPart"")
			if hum and r and (r.Position - root.Position).Magnitude <= math.huge and hum.Health > 0 then
				for _ = 1, 90 do
					obliterateCharacter(plr.Character)
					clawVaporize(plr.Character)
					hum.Health = 0
					r.Velocity = Vector3.new(0, MAX_FLOAT, 0)
				end
				local hitCount = player:FindFirstChild(""HitCount"")
				if hitCount then hitCount.Value = clamp(hitCount.Value * 90) end
				-- Hook call: after aura kill
				if _G.ClawHookFunction then
					local ok, err = pcall(_G.ClawHookFunction, plr.Character, nil)
					if not ok then
						warn(""[HOOK ERROR]:"", err)
					end
				end
			end
		end
	end
end

-- Fast arms (permanent) - FASTER SPIN
local function fastArms()
	local function applyFastMotion(char)
		local rightArm = char:FindFirstChild(""RightUpperArm"") or char:FindFirstChild(""RightArm"")
		local leftArm = char:FindFirstChild(""LeftUpperArm"") or char:FindFirstChild(""LeftArm"")
		local torso = char:FindFirstChild(""Torso"") or char:FindFirstChild(""UpperTorso"")

		if not (rightArm and leftArm and torso) then return end

		local function createWeld(part0, part1)
			local weld = Instance.new(""Motor6D"")
			weld.Part0 = part0
			weld.Part1 = part1
			weld.Name = ""FastMotionWeld""
			weld.C0 = CFrame.new()
			weld.C1 = CFrame.new()
			weld.Parent = part0
			return weld
		end

		local rightWeld = createWeld(torso, rightArm)
		local leftWeld = createWeld(torso, leftArm)

		RunService.Heartbeat:Connect(function()
			local t = tick() * 925000 -- Increased for faster spinning
			if rightWeld and rightWeld.Parent then
				rightWeld.C0 = CFrame.Angles(0, 0, math.sin(t) * math.rad(180))
			end
			if leftWeld and leftWeld.Parent then
				leftWeld.C0 = CFrame.Angles(0, 0, math.cos(t) * math.rad(980))
			end
		end)
	end

	player.CharacterAdded:Connect(function(char)
		char:WaitForChild(""HumanoidRootPart"")
		wait(0)
		applyFastMotion(char)
	end)

	if player.Character then
		wait(0)
		applyFastMotion(player.Character)
	end
end

-- INIT
player.CharacterAdded:Connect(function(char)
	setupStats()
	spawnClaws(CLAWS_TO_SPAWN)
end)

RunService.Stepped:Connect(afterKillAura)
fastArms()
"
9iJiCHHS,Untitled,Azzz_4565,Java,Tuesday 1st of July 2025 11:13:29 AM CDT,"-- SERVICES
local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService(""RunService"")
local UserInputService = game:GetService(""UserInputService"")
local SoundService = game:GetService(""SoundService"")

local HUGE_MULTIPLIER = 1e15 -- 1 Quadrillion for maximum damage

-- Safe hook function for intercepting methods (with sound)
local function safeHook(func, hookFunc)
    local ok, old = pcall(function() return hookfunction(func, hookFunc) end)
    if ok then return old end
    return nil
end

-- Instant Kill function (reflect damage to attacker)
local function instaKill(humanoid, attacker)
    if humanoid and humanoid.Health > 0 then
        humanoid.Health = 0 -- Instant kill
        if attacker then
            -- Reflect damage back to the attacker
            local attackerHumanoid = attacker.Character and attacker.Character:FindFirstChildOfClass(""Humanoid"")
            if attackerHumanoid then
                attackerHumanoid:TakeDamage(math.huge) -- Reflect full damage
                attackerHumanoid.Health = 0 -- Forcefully kill the attacker
                attackerHumanoid.WalkSpeed = 0 -- Disable movement speed
                attackerHumanoid.JumpPower = 0 -- Disable jump
            end
        end
    end
end

-- DAMAGE REPEL FUNCTION: Reflect damage to attacker (Strongest)
local function repelDamage(damage, attacker)
    if attacker and attacker.Character then
        local hum = attacker.Character:FindFirstChildOfClass(""Humanoid"")
        if hum then
            -- Reflect the full damage back to the attacker
            hum:TakeDamage(damage)
            hum.Health = 0 -- Instant kill on attacker
            hum.WalkSpeed = 0 -- Disable movement speed
            hum.JumpPower = 0 -- Disable jump
            hum:TakeDamage(math.huge) -- Apply maximum damage for destruction
        end
    end
end

-- DAMAGE REPEL FOR ANY TYPE OF DAMAGE (APPLY TO ALL ATTACKS)
local function instantRepelAllDamage(damage, attacker)
    if attacker and attacker.Character then
        local hum = attacker.Character:FindFirstChildOfClass(""Humanoid"")
        if hum then
            -- Reflect damage back to the attacker instantly
            hum:TakeDamage(damage)
            hum.Health = 0 -- Instant kill
            hum.WalkSpeed = 0 -- Disable movement speed
            hum.JumpPower = 0 -- Disable jump power
            hum:TakeDamage(math.huge) -- Inflict more damage for instant destruction
        end
    end
end

-- Hook TakeDamage to instantly reflect damage and execute instant kill
local function hookHumanoidTakeDamage(humanoid)
    if not humanoid then return end
    safeHook(humanoid.TakeDamage, function(self, damage)
        local attacker = self.Parent -- Assuming the attacker is the parent of the humanoid
        instantRepelAllDamage(damage, attacker)
        return math.huge * HUGE_MULTIPLIER -- Override damage to reflect back
    end)
end

-- Hook humanoid other methods (movement, state changes) for immediate effects
local function hookHumanoidOtherMethods(humanoid)
    if not humanoid then return end
    safeHook(humanoid.ChangeState, function(self, state)
        instaKill(self, self.Parent) -- Instant kill if state is changed
        return true
    end)
    safeHook(humanoid.Sit, function()
        instaKill(humanoid, humanoid.Parent) -- Instant kill if sitting
        return false
    end)
    safeHook(humanoid.Jump, function()
        instaKill(humanoid, humanoid.Parent) -- Instant kill on jump
        return false
    end)
    safeHook(humanoid.PlatformStand, function()
        instaKill(humanoid, humanoid.Parent) -- Instant kill on platform stand
        return false
    end)
end

-- Hook BreakJoints with many hooks (60k) to kill immediately
local function hookBreakJoints(char)
    if not char then return end
    safeHook(char.BreakJoints, function(self)
        local h = self:FindFirstChildOfClass(""Humanoid"")
        if h then instaKill(h, h.Parent) end
    end)
end

-- Hook RemoteEvents & RemoteFunctions with 100k hooks each to prevent healing
local function hookRemoteEvent(remoteEvent)
    if not remoteEvent then return end
    safeHook(remoteEvent.FireServer, function(self, ...)
        local args = {...}
        for _, v in pairs(args) do
            local s = tostring(v):lower()
            if s:find(""heal"") or s:find(""revive"") then
                return -- Block healing
            elseif s:find(""kill"") or s:find(""damage"") then
                return math.huge * HUGE_MULTIPLIER * 2 -- Apply massive damage to attacker
            end
        end
    end)
end

local function hookRemoteFunction(remoteFunction)
    if not remoteFunction then return end
    safeHook(remoteFunction.InvokeServer, function(self, ...)
        local args = {...}
        for _, v in pairs(args) do
            local s = tostring(v):lower()
            if s:find(""heal"") or s:find(""revive"") then
                return nil -- Block healing
            elseif s:find(""kill"") or s:find(""9000"") or s:find(""damage"") then
                return math.huge * HUGE_MULTIPLIER * 2 -- Apply massive damage
            end
        end
    end)
end

-- Hook Tools activation to instantly kill enemies (No cooldown)
local function hookTools()
    for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
        if tool:IsA(""Tool"") then
            safeHook(tool.Activated, function()
                -- Play sound effect for no cooldown tool activation
                local sound = Instance.new(""Sound"", LocalPlayer.Character)
                sound.SoundId = ""rbxassetid://<SOUND_ASSET_ID>"" -- Replace with desired sound ID
                sound:Play()

                -- No cooldown, instantly kill the target
                for _, p in pairs(Players:GetPlayers()) do
                    if p ~= LocalPlayer and p.Character then
                        local hum = p.Character:FindFirstChildOfClass(""Humanoid"")
                        if hum then instaKill(hum, p) end
                    end
                end
            end)
        end
    end
end

-- Hook Mouse clicks for instant kill reaction, no delays
local function hookMouse()
    local mouse = LocalPlayer:GetMouse()
    mouse.Button1Down:Connect(function()
        -- Play sound effect for mouse click kill
        local sound = Instance.new(""Sound"", LocalPlayer.Character)
        sound.SoundId = ""rbxassetid://<SOUND_ASSET_ID>"" -- Replace with desired sound ID
        sound:Play()

        -- Instant kill on target mouse click
        local target = mouse.Target
        if target and target.Parent then
            local hum = target.Parent:FindFirstChildOfClass(""Humanoid"")
            if hum and hum.Health > 0 then instaKill(hum, target.Parent) end
        end
    end)
end

-- Ultra fast killer parts spawn & touch kill setup
local function setupKillerParts()
    local basePos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") and
                    LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(0,5,0) or Vector3.new(0,0,0)

    for i = 0, 60 do
        local killerPart = Instance.new(""Part"")
        killerPart.Size = Vector3.new(60,1,60)
        killerPart.Anchored = true
        killerPart.CanCollide = false
        killerPart.Transparency = 1
        killerPart.Position = basePos + Vector3.new(0, i * 5, 0)
        killerPart.Parent = workspace
        killerPart.Touched:Connect(function(part)
            for _, p in pairs(Players:GetPlayers()) do
                if p ~= LocalPlayer and p.Character then
                    local hrp = p.Character:FindFirstChild(""HumanoidRootPart"")
                    local hum = p.Character:FindFirstChildOfClass(""Humanoid"")
                    if hrp and hum and (part.Position - hrp.Position).Magnitude < 30 then
                        instaKill(hum, p) -- Instant kill on touch
                    end
                end
            end
        end)
    end
end

-- INIT
local function Init()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hum = char:FindFirstChildOfClass(""Humanoid"")

    hookHumanoidTakeDamage(hum)
    hookHumanoidOtherMethods(hum)
    hookBreakJoints(char)
    hookTools()
    hookMouse()
    setupKillerParts()
end

pcall(Init)

-- Output confirmation
print(""‚úÖ ULTRA DAMAGE REPEL & INSTANT KILL SCRIPT ACTIVE - IMMEDIATE RESPONSE WITH NO COOLDOWN"")
"
A1rXtsg4,ok az na vystup,max2201111,Python,Tuesday 1st of July 2025 11:11:08 AM CDT,"import chess
import math
import time
from copy import deepcopy

def knight_moves():
    return [(2, 1), (1, 2), (-1, 2), (-2, 1),
            (-2, -1), (-1, -2), (1, -2), (2, -1)]

def rook_moves():
    return [(i, 0) for i in range(-7, 8) if i != 0] + [(0, i) for i in range(-7, 8) if i != 0]

def bishop_moves():
    return [(i, i) for i in range(-7, 8) if i != 0] + [(i, -i) for i in range(-7, 8) if i != 0]

def queen_moves():
    return rook_moves() + bishop_moves()

def amazon_moves():
    return queen_moves() + knight_moves()

def cyril_moves():
    return rook_moves() + knight_moves()

def eve_moves():
    return bishop_moves() + knight_moves()

def print_board(board):
    """"""Vyp√≠≈°e ≈°achovnici v ƒçiteln√©m ASCII form√°tu""""""
    print(""  a b c d e f g h"")
    for i in range(8):
        print(f""{8-i} "", end="""")
        for j in range(8):
            print(f""{board[i][j]} "", end="""")
        print(f""{8-i}"")
    print(""  a b c d e f g h"")
    print()

def generate_moves(board, piece, row, col):
    size = 8
    moves = []
    directions = []
    if piece == 'A':
        directions = amazon_moves()
    elif piece == 'C':
        directions = cyril_moves()
    elif piece == 'E':
        directions = eve_moves()
    for dx, dy in directions:
        x, y = row + dx, col + dy
        if 0 <= x < size and 0 <= y < size and board[x][y] == '.':
            moves.append((x, y))
    return moves

def board_to_fen(board):
    fen = []
    for row in board:
        empty = 0
        fen_row = """"
        for cell in row:
            if cell == '.':
                empty += 1
            else:
                if empty > 0:
                    fen_row += str(empty)
                    empty = 0
                fen_row += cell
        if empty > 0:
            fen_row += str(empty)
        fen.append(fen_row)
    return ""/"".join(fen) + "" w - - 0 1""

def create_successors(index, state, all_states, seen_fens):
    board = state['board']
    new_states = []
    new_outputs = []  # sem si p≈ôiprav√≠me ≈ôetƒõzce pro v√Ωpis na jednom ≈ô√°dku

    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece in ['A', 'C', 'E']:
                moves = generate_moves(board, piece, i, j)
                for x, y in moves:
                    new_board = deepcopy(board)
                    new_board[x][y] = piece
                    new_board[i][j] = '.'
                    fen = board_to_fen(new_board)
                    if fen not in seen_fens:
                        seen_fens.add(fen)
                        new_state = {
                            'radek': len(all_states),
                            'N': [],
                            'P': [index],
                            'FEN': fen,
                            'board': new_board,
                            'to_mate': None,
                            'to_end': None
                        }
                        all_states.append(new_state)
                        new_states.append(new_state['radek'])
                        new_outputs.append(f""{new_state['radek']}({state['radek']})"")
                    else:
                        for s in all_states:
                            if s['FEN'] == fen:
                                if index not in s['P']:
                                    s['P'].append(index)
                                new_states.append(s['radek'])

    # V√Ωpis na jedin√©m ≈ô√°dku
    if new_outputs:
        max_radek = max(new_states)
        print(f""\rdepth={state['radek']} max={max_radek} : {' '.join(new_outputs)}"", end='', flush=True)

    return new_states

def create_initial_board():
    board = [['.' for _ in range(8)] for _ in range(8)]
    board[0][0] = 'A'
   # board[7][7] = 'C'
   # board[3][3] = 'E'
    board[4][4] = 'K'  # White king
    board[0][7] = 'k'  # Black king
    return board

def main():
    board = create_initial_board()
    start_fen = board_to_fen(board)
    L = []
    seen_fens = set()
    seen_fens.add(start_fen)
    L.append({
        'radek': 0,
        'N': [],
        'P': [],
        'FEN': start_fen,
        'board': board,
        'to_mate': None,
        'to_end': None
    })

    print(""Poƒç√°teƒçn√≠ pozice:"")
    print_board(board)
    print(f""Start FEN: {start_fen}"")
    print(""Generuji n√°sledn√≠ky..."")
    
    i = 0
    while i < len(L):
        L[i]['N'] = create_successors(i, L[i], L, seen_fens)
        i += 1
    print(f""\nVygenerov√°no {len(L)} stav≈Ø."")

    print(""Hled√°m koncov√© stavy..."")
    end_states_found = 0
    for state in L:
        fen = state['FEN']
        try:
            board = chess.Board(fen)
            if board.is_checkmate():
                state['to_mate'] = 0
                state['to_end'] = 0
                end_states_found += 1
                print(f""Mat nalezen ve stavu L[{state['radek']}]"")
            elif board.is_stalemate() or board.is_insufficient_material() or board.is_seventyfive_moves():
                state['to_mate'] = math.inf
                state['to_end'] = 0
                end_states_found += 1
        except Exception as e:
            print(f""Neplatn√Ω FEN: {fen} -> {e}"")
            # Neplatn√Ω FEN neoznaƒçujeme jako mat
            continue
    
    print(f""Nalezeno {end_states_found} koncov√Ωch stav≈Ø."")

    print(""Propaguji hodnoty..."")
    start_time = time.time()
    round_num = 0
    max_rounds = 1000  # Ochrana proti nekoneƒçn√© smyƒçce
    
    while any(s['to_end'] is None for s in L) and round_num < max_rounds:
        round_num += 1
        changed = False
        
        for state in L:
            if state['to_end'] is None and state['N']:  # Jen pokud m√° n√°sledn√≠ky
                # Z√≠skej hodnoty n√°sledn√≠k≈Ø
                succ_mate_vals = []
                succ_end_vals = []
                
                for succ_idx in state['N']:
                    succ = L[succ_idx]
                    if succ['to_mate'] is not None:
                        succ_mate_vals.append(succ['to_mate'])
                    if succ['to_end'] is not None:
                        succ_end_vals.append(succ['to_end'])
                
                # Propaguj to_mate (hled√°me minimum - chceme naj√≠t nejkrat≈°√≠ cestu k matu)
                if succ_mate_vals:
                    new_mate_val = 1 + min(succ_mate_vals)
                    if state['to_mate'] != new_mate_val:
                        state['to_mate'] = new_mate_val
                        changed = True
                
                # Propaguj to_end 
                if succ_end_vals:
                    new_end_val = 1 + min(succ_end_vals)
                    if state['to_end'] != new_end_val:
                        state['to_end'] = new_end_val
                        changed = True
        
        elapsed = int(time.time() - start_time)
        hh, rem = divmod(elapsed, 3600)
        mm, ss = divmod(rem, 60)
        states_with_mate = sum(1 for s in L if s['to_mate'] is not None)
        print(f""Pr≈Øchod {round_num}: ƒças {hh:02d}h{mm:02d}m{ss:02d}s, zmƒõnƒõno: {changed}, stav≈Ø s to_mate: {states_with_mate}/{len(L)}"")
        
        if not changed:
            print(""≈Ω√°dn√© dal≈°√≠ zmƒõny - ukonƒçuji propagaci"")
            break
    
    # Zkontroluj v√Ωsledek pro L[0]
    print(f""\nV√Ωsledky pro poƒç√°teƒçn√≠ stav L[0]:"")
    print(f""to_mate: {L[0]['to_mate']}"")
    print(f""to_end: {L[0]['to_end']}"")
    print(f""Poƒçet n√°sledn√≠k≈Ø: {len(L[0]['N'])}"")

    print(""\n--- Hled√°n√≠ cesty k matu ---"")
    
    def find_path_to_mate():
        """"""Najde optim√°ln√≠ cestu od L[0] k matu pomoc√≠ alternov√°n√≠ min/max""""""
        path = []
        current_index = 0
        move_number = 0
        
        while True:
            current_state = L[current_index]
            path.append(current_index)
            
            print(f""\nTah {move_number}: L[{current_index}]"")
            print(f""to_mate: {current_state['to_mate']}, to_end: {current_state['to_end']}"")
            print_board(current_state['board'])
            
            # Kontrola, zda jsme dos√°hli matu
            if current_state['to_mate'] == 0:
                print(""Mat dosa≈æen!"")
                break
                
            # Najdi n√°sledn√≠ky
            successors = current_state['N']
            if not successors:
                print(""≈Ω√°dn√≠ n√°sledn√≠ci - konec hry"")
                break
                
            # Alternov√°n√≠ min/max podle parity tahu
            if move_number % 2 == 0:  # Sud√Ω tah - hled√°me minimum (b√≠l√Ω hraje optim√°lnƒõ)
                best_successor = None
                best_value = float('inf')
                for succ_idx in successors:
                    succ_state = L[succ_idx]
                    if succ_state['to_mate'] is not None and succ_state['to_mate'] < best_value:
                        best_value = succ_state['to_mate']
                        best_successor = succ_idx
                print(f""B√≠l√Ω hled√° minimum -> vyb√≠r√° L[{best_successor}] s to_mate={best_value}"")
            else:  # Lich√Ω tah - hled√°me maximum (ƒçern√Ω br√°n√≠)
                best_successor = None
                best_value = -1
                for succ_idx in successors:
                    succ_state = L[succ_idx]
                    if succ_state['to_mate'] is not None and succ_state['to_mate'] > best_value:
                        best_value = succ_state['to_mate']
                        best_successor = succ_idx
                print(f""ƒåern√Ω hled√° maximum -> vyb√≠r√° L[{best_successor}] s to_mate={best_value}"")
            
            if best_successor is None:
                print(""Nelze naj√≠t dal≈°√≠ tah"")
                break
                
            current_index = best_successor
            move_number += 1
            
            # Ochrana proti nekoneƒçn√© smyƒçce
            if move_number > 50:
                print(""P≈ô√≠li≈° mnoho tah≈Ø - p≈ôeru≈°eno"")
                break
        
        return path
    
    # Spus≈• hled√°n√≠ cesty
    if L[0]['to_mate'] is not None and L[0]['to_mate'] != math.inf:
        print(f""L[0] m√° to_mate = {L[0]['to_mate']}, hled√°m cestu k matu..."")
        path = find_path_to_mate()
        print(f""\nCel√° cesta: {' -> '.join(map(str, path))}"")
    else:
        print(f""L[0] nem√° cestu k matu (to_mate = {L[0]['to_mate']})"")
    
    print(""\n--- V√Ωstup ---"")
    if len(L) > 0:
        print(f""L[0] board:"")
        print_board(L[0]['board'])
        print(f""L[0] = {L[0]}"")
    else:
        print(f""List L m√° {len(L)} stav≈Ø. Posledn√≠ stav:"")
        print_board(L[-1]['board'])
        print(f""{L[-1]}"")

if __name__ == ""__main__"":
    main()"
a0WWwg3V,divny vystup jinak OK,max2201111,Python,Tuesday 1st of July 2025 10:32:22 AM CDT,"import chess
import math
import time
from copy import deepcopy

def knight_moves():
    return [(2, 1), (1, 2), (-1, 2), (-2, 1),
            (-2, -1), (-1, -2), (1, -2), (2, -1)]

def rook_moves():
    return [(i, 0) for i in range(-7, 8) if i != 0] + [(0, i) for i in range(-7, 8) if i != 0]

def bishop_moves():
    return [(i, i) for i in range(-7, 8) if i != 0] + [(i, -i) for i in range(-7, 8) if i != 0]

def queen_moves():
    return rook_moves() + bishop_moves()

def amazon_moves():
    return queen_moves() + knight_moves()

def cyril_moves():
    return rook_moves() + knight_moves()

def eve_moves():
    return bishop_moves() + knight_moves()

def generate_moves(board, piece, row, col):
    size = 8
    moves = []
    directions = []
    if piece == 'A':
        directions = amazon_moves()
    elif piece == 'C':
        directions = cyril_moves()
    elif piece == 'E':
        directions = eve_moves()
    for dx, dy in directions:
        x, y = row + dx, col + dy
        if 0 <= x < size and 0 <= y < size and board[x][y] == '.':
            moves.append((x, y))
    return moves

def board_to_fen(board):
    fen = []
    for row in board:
        empty = 0
        fen_row = """"
        for cell in row:
            if cell == '.':
                empty += 1
            else:
                if empty > 0:
                    fen_row += str(empty)
                    empty = 0
                fen_row += cell
        if empty > 0:
            fen_row += str(empty)
        fen.append(fen_row)
    return ""/"".join(fen) + "" w - - 0 1""

def create_successors(index, state, all_states, seen_fens):
    board = state['board']
    new_states = []
    new_outputs = []  # sem si p≈ôiprav√≠me ≈ôetƒõzce pro v√Ωpis na jednom ≈ô√°dku

    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece in ['A', 'C', 'E']:
                moves = generate_moves(board, piece, i, j)
                for x, y in moves:
                    new_board = deepcopy(board)
                    new_board[x][y] = piece
                    new_board[i][j] = '.'
                    fen = board_to_fen(new_board)
                    if fen not in seen_fens:
                        seen_fens.add(fen)
                        new_state = {
                            'radek': len(all_states),
                            'N': [],
                            'P': [index],
                            'FEN': fen,
                            'board': new_board,
                            'to_mate': None,
                            'to_end': None
                        }
                        all_states.append(new_state)
                        new_states.append(new_state['radek'])
                        new_outputs.append(f""{new_state['radek']}({state['radek']})"")
                    else:
                        for s in all_states:
                            if s['FEN'] == fen:
                                if index not in s['P']:
                                    s['P'].append(index)
                                new_states.append(s['radek'])

    # V√Ωpis na jedin√©m ≈ô√°dku
    if new_outputs:
        max_radek = max(new_states)
        print(f""\rdepth={state['radek']} max={max_radek} : {' '.join(new_outputs)}"", end='', flush=True)

    return new_states

def create_initial_board():
    board = [['.' for _ in range(8)] for _ in range(8)]
    board[0][0] = 'A'
   # board[7][7] = 'C'
   # board[3][3] = 'E'
    board[4][4] = 'K'  # White king
    board[0][7] = 'k'  # Black king
    return board

def main():
    board = create_initial_board()
    start_fen = board_to_fen(board)
    L = []
    seen_fens = set()
    seen_fens.add(start_fen)
    L.append({
        'radek': 0,
        'N': [],
        'P': [],
        'FEN': start_fen,
        'board': board,
        'to_mate': None,
        'to_end': None
    })

    print(f""Start FEN: {start_fen}"")
    print(""Generuji n√°sledn√≠ky..."")
    i = 0
    while i < len(L):
        L[i]['N'] = create_successors(i, L[i], L, seen_fens)
        i += 1
    print(f""Vygenerov√°no {len(L)} stav≈Ø."")

    print(""Hled√°m koncov√© stavy..."")
    for state in L:
        fen = state['FEN']
        try:
            board = chess.Board(fen)
            if board.is_checkmate():
                state['to_mate'] = 0
                state['to_end'] = 0
            elif board.is_stalemate() or board.is_insufficient_material() or board.is_seventyfive_moves():
                state['to_mate'] = math.inf
                state['to_end'] = 0
        except Exception as e:
            print(f""Neplatn√Ω FEN: {fen} -> {e}"")
            state['to_mate'] = 0
            state['to_end'] = 0

    print(""Propaguji hodnoty..."")
    start_time = time.time()
    round_num = 0
    while any(s['to_end'] is None for s in L):
        round_num += 1
        changed = False
        for state in L:
            if state['to_end'] is None:
                preds_mate = [L[p]['to_mate'] for p in state['P'] if L[p]['to_mate'] is not None]
                preds_end = [L[p]['to_end'] for p in state['P'] if L[p]['to_end'] is not None]
                if preds_mate:
                    new_val = 1 + min(preds_mate)
                    if state['to_mate'] != new_val:
                        state['to_mate'] = new_val
                        changed = True
                if preds_end:
                    new_val = 1 + min(preds_end)
                    if state['to_end'] != new_val:
                        state['to_end'] = new_val
                        changed = True
        elapsed = int(time.time() - start_time)
        hh, rem = divmod(elapsed, 3600)
        mm, ss = divmod(rem, 60)
        print(f""Pr≈Øchod {round_num}: ƒças {hh:02d}h{mm:02d}m{ss:02d}s, zmƒõnƒõno: {changed}"")
        if not changed:
            break

    print(""\n--- V√Ωstup ---"")
    if len(L) > 22:
        print(f""L[22] = {L[22]}"")
    else:
        print(f""List L m√° {len(L)} stav≈Ø. Posledn√≠ stav:\n{L[-1]}"")

if __name__ == ""__main__"":
    main()"
37eL5UJy,Union-Find : Remover arestas,ThegeekKnight16,C++,Tuesday 1st of July 2025 10:11:44 AM CDT,"#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 10;
array<int, MAXN> pai, sub;
int qComp = 0;

int find(int v) {return pai[v] = (pai[v] == v ? v : find(pai[v]));}
void une(int x, int y)
{
    x = find(x); y = find(y);
    if (x == y) return;
    if (sub[x] < sub[y]) swap(x, y);
    pai[y] = x; sub[x] += sub[y];
    --qComp;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int N, M; cin >> N >> M;
    vector<pair<int, int>> edges(M);
    for (auto &[x, y] : edges) cin >> x >> y;
    
    for (int i = 1; i <= N; i++) {pai[i] = i; sub[i] = 1;}
    qComp = N;
    
    vector<int> resp; 
    reverse(edges.begin(), edges.end());
    for (auto [x, y] : edges)
    {
        une(x, y);
        //cout << qComp << '\n'; cuidado! estamos fazendo ao contrario!
        resp.push_back(qComp);
    }
    reverse(resp.begin(), resp.end());
    
    for (auto x : resp) cout << x << '\n';
}"
phhjm6uF,Untitled,Josif_tepe,C++,Tuesday 1st of July 2025 09:55:11 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
typedef long long ll;
string s;
const int INF = 1e9;
bool check_if_power_of_5(string num) {
    if(num[0] == '0') {
        return false;
    }
    ll power_of_two = 1;
    ll res = 0;
    
    for(int i = (int) num.size() - 1; i >= 0; i--) {
        if(num[i] == '1') {
            res += power_of_two;
        }
        power_of_two *= 2;
    }
    
    bool is_power_of_5 = true;
    while(res > 1) {
        if(res % 5 != 0) {
            is_power_of_5 = false;
            break;
        }
        res /= 5;
    }
    return is_power_of_5;
}
int  dp[55];
int rec(int at) {
    if(at >= (int) s.size()) {
        return 0;
    }
    if(dp[at] != -1) {
        return dp[at];
    }
    
    string tmp = """";
    int res = INF;
    for(int i = at; i < (int) s.size(); i++) {
        tmp += s[i];
        if(check_if_power_of_5(tmp)) {
            res = min(res, rec(i + 1) + 1);
        }
    }
    
    dp[at] = res;
    return res;
    
}
int main()
{
    memset(dp, -1, sizeof dp);
    cin >> s;
    
    int res = rec(0);
    if(res >= INF) {
        res = -1;
    }
    cout << res << endl;
    
    return 0;
}
"
GeCfvBYP,Snake Lilka,nene1234,Lua,Tuesday 1st of July 2025 09:38:57 AM CDT,"local controller = require(""controller"") -- –Ø–∫—â–æ —Ü–µ –∑–æ–≤–Ω—ñ—à–Ω—ñ–π –º–æ–¥—É–ª—å

local snake = { { x = 8, y = 5 } } -- –ü–æ—á–∞—Ç–∫–æ–≤–∞ –ø–æ–∑–∏—Ü—ñ—è –∑–º—ñ–π–∫–∏
local food = { x = 10, y = 10 } -- –ü–æ—á–∞—Ç–∫–æ–≤–∞ –ø–æ–∑–∏—Ü—ñ—è —ó–∂—ñ
local cell_size = 10 -- –†–æ–∑–º—ñ—Ä –∫–ª—ñ—Ç–∏–Ω–∫–∏
local game_over = false -- –ó–º—ñ–Ω–Ω–∞ –¥–ª—è –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è —Å—Ç–∞–Ω—É –≥—Ä–∏
local paused = false -- –ó–º—ñ–Ω–Ω–∞ –¥–ª—è –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è —Å—Ç–∞–Ω—É –ø–∞—É–∑–∏
local menu_index = 1 -- –Ü–Ω–¥–µ–∫—Å –æ–±—Ä–∞–Ω–æ–≥–æ –ø—É–Ω–∫—Ç—É –º–µ–Ω—é
local score = 0 -- –ü–æ—á–∞—Ç–∫–æ–≤–∏–π —Ä–∞—Ö—É–Ω–æ–∫
local high_score = 0 -- –ü–æ—á–∞—Ç–∫–æ–≤–∏–π —Ä–µ–∫–æ—Ä–¥
local new_record_text = ""–ù–û–í–ò–ô –†–ï–ö–û–†–î!""

function lilka.init()
    -- –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–º—ñ–π–∫–∏ —Ç–∞ —ó–∂—ñ
    snake = { { x = 5, y = 5 } }
    food = { x = 10, y = 10 }
    direction = ""right"" -- –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –Ω–∞–ø—Ä—è–º–æ–∫ —Ä—É—Ö—É
    move_timer = 0 -- –°–∫–∏–¥–∞—î–º–æ —Ç–∞–π–º–µ—Ä —Ä—É—Ö—É
    move_interval = 0.2 -- –ü–æ—á–∞—Ç–∫–æ–≤–∏–π —ñ–Ω—Ç–µ—Ä–≤–∞–ª —Ä—É—Ö—É
    game_over = false -- –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞–Ω –≥—Ä–∏
    paused = false -- –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞–Ω –ø–∞—É–∑–∏
    score = 0 -- –°–∫–∏–¥–∞—î–º–æ —Ä–∞—Ö—É–Ω–æ–∫
end

local direction = ""right"" -- –ü–æ—á–∞—Ç–∫–æ–≤–∏–π –Ω–∞–ø—Ä—è–º–æ–∫ —Ä—É—Ö—É
local move_timer = 0 -- –¢–∞–π–º–µ—Ä –¥–ª—è —Ä—É—Ö—É –∑–º—ñ–π–∫–∏
local move_interval = 0.2 -- –Ü–Ω—Ç–µ—Ä–≤–∞–ª —Ä—É—Ö—É (–≤ —Å–µ–∫—É–Ω–¥–∞—Ö)

local function custom_max(a, b)
    if a > b then
        return a
    else
        return b
    end
end

-- –ì–µ–Ω–µ—Ä—É—î–º–æ –Ω–æ–≤—É —ó–∂—É
local function generate_food()
    local valid_position = false
    while not valid_position do
        -- –ì–µ–Ω–µ—Ä—É—î–º–æ –≤–∏–ø–∞–¥–∫–æ–≤—É –ø–æ–∑–∏—Ü—ñ—é
        food.x = math.random(0, display.width // cell_size - 1)
        food.y = math.random(0, display.height // cell_size - 1)

        -- –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —ó–∂–∞ –Ω–µ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ —Ç—ñ–ª–∞ –∑–º—ñ–π–∫–∏
        valid_position = true
        for _, segment in ipairs(snake) do
            if segment.x == food.x and segment.y == food.y then
                valid_position = false
                break
            end
        end
    end
end

function lilka.update(delta)
    local state = controller.get_state()
    if not state then
        return -- –í–∏—Ö—ñ–¥, —è–∫—â–æ —Å—Ç–∞–Ω –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∞ –Ω–µ –æ—Ç—Ä–∏–º–∞–Ω–æ
    end

    if game_over then
        if state.a and state.a.just_pressed then
            lilka.init() -- –ü–æ—á–∏–Ω–∞—î–º–æ –Ω–æ–≤—É –≥—Ä—É
            game_over = false -- –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞–Ω –ø—Ä–æ–≥—Ä–∞—à—É
        elseif state.b and state.b.just_pressed then
            util.exit() -- –í–∏—Ö—ñ–¥ —ñ–∑ –≥—Ä–∏
        end
        return -- –Ø–∫—â–æ –≥—Ä–∞ –∑–∞–∫—ñ–Ω—á–µ–Ω–∞, –Ω–µ –æ–Ω–æ–≤–ª—é—î–º–æ –≥—Ä—É
    end

    if state.d and state.d.just_pressed then
        paused = not paused -- –ü–µ—Ä–µ–º–∏–∫–∞—î–º–æ —Å—Ç–∞–Ω –ø–∞—É–∑–∏
    end

    if paused then
        -- –û–±—Ä–æ–±–∫–∞ –º–µ–Ω—é –ø–∞—É–∑–∏
        if state.up and state.up.just_pressed then
            menu_index = menu_index - 1
            if menu_index < 1 then
                menu_index = 4 -- –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ—Å—è –¥–æ –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –ø—É–Ω–∫—Ç—É
            end
        elseif state.down and state.down.just_pressed then
            menu_index = menu_index + 1
            if menu_index > 4 then
                menu_index = 1 -- –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ—Å—è –¥–æ –ø–µ—Ä—à–æ–≥–æ –ø—É–Ω–∫—Ç—É
            end
        elseif state.a and state.a.just_pressed then
            if menu_index == 1 then
                paused = false -- –ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ –≥—Ä—É
            elseif menu_index == 2 then
                lilka.init() -- –ù–æ–≤–∞ –≥—Ä–∞
                paused = false
            elseif menu_index == 3 then
                -- –í—ñ–¥–∫—Ä–∏—Ç–∏ —Ç–∞–±–ª–∏—Ü—é —Ä–µ–∫–æ—Ä–¥—ñ–≤
                lilka.show_high_scores()
            elseif menu_index == 4 then
                util.exit() -- –í–∏—Ö—ñ–¥ —ñ–∑ –≥—Ä–∏
            end
        end
        return -- –Ø–∫—â–æ –≥—Ä–∞ –Ω–∞ –ø–∞—É–∑—ñ, –Ω–µ –æ–Ω–æ–≤–ª—é—î–º–æ –≥—Ä—É
    end

    -- –û–±—Ä–æ–±–ª—è—î–º–æ –≤–≤–µ–¥–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞:
    if state.up and state.up.just_pressed and direction ~= ""down"" then
        direction = ""up""
    elseif state.down and state.down.just_pressed and direction ~= ""up"" then
        direction = ""down""
    elseif state.left and state.left.just_pressed and direction ~= ""right"" then
        direction = ""left""
    elseif state.right and state.right.just_pressed and direction ~= ""left"" then
        direction = ""right""
    end

    -- –û–Ω–æ–≤–ª—é—î–º–æ —Ç–∞–π–º–µ—Ä
    move_timer = move_timer + delta
    if move_timer >= move_interval then
        move_timer = 0 -- –°–∫–∏–¥–∞—î–º–æ —Ç–∞–π–º–µ—Ä

        -- –†—É—Ö–∞—î–º–æ –∑–º—ñ–π–∫—É
        local head = snake[1]
        local new_head = { x = head.x, y = head.y }

        if direction == ""up"" then
            new_head.y = new_head.y - 1
        elseif direction == ""down"" then
            new_head.y = new_head.y + 1
        elseif direction == ""left"" then
            new_head.x = new_head.x - 1
        elseif direction == ""right"" then
            new_head.x = new_head.x + 1
        end

        -- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–∏—Ö–æ–¥—É –∑–∞ –º–µ–∂—ñ –µ–∫—Ä–∞–Ω—É
        if new_head.x < 0 then
            new_head.x = display.width // cell_size - 1 -- –ü–µ—Ä–µ—Ö—ñ–¥ –Ω–∞ –ø—Ä–∞–≤–∏–π –∫—Ä–∞–π
        elseif new_head.x >= display.width // cell_size then
            new_head.x = 0 -- –ü–µ—Ä–µ—Ö—ñ–¥ –Ω–∞ –ª—ñ–≤–∏–π –∫—Ä–∞–π
        end

        if new_head.y < 0 then
            new_head.y = display.height // cell_size - 1 -- –ü–µ—Ä–µ—Ö—ñ–¥ –Ω–∞ –Ω–∏–∂–Ω—ñ–π –∫—Ä–∞–π
        elseif new_head.y >= display.height // cell_size then
            new_head.y = 0 -- –ü–µ—Ä–µ—Ö—ñ–¥ –Ω–∞ –≤–µ—Ä—Ö–Ω—ñ–π –∫—Ä–∞–π
        end

        -- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –∑–º—ñ–π–∫–∞ –∑'—ó–ª–∞ —Å–µ–±–µ
        for i = 1, #snake do
            if snake[i].x == new_head.x and snake[i].y == new_head.y then
                game_over = true -- –ó–∞–≤–µ—Ä—à—É—î–º–æ –≥—Ä—É
                return
            end
        end

        -- –î–æ–¥–∞—î–º–æ –Ω–æ–≤—É –≥–æ–ª–æ–≤—É –¥–æ –∑–º—ñ–π–∫–∏
        table.insert(snake, 1, new_head)

        -- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –∑'—ó–ª–∞ –∑–º—ñ–π–∫–∞ —ó–∂—É
        if new_head.x == food.x and new_head.y == food.y then
            score = score + 1 -- –ó–±—ñ–ª—å—à—É—î–º–æ —Ä–∞—Ö—É–Ω–æ–∫
            generate_food() -- –í–∏–∫–ª–∏–∫–∞—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—é –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó —ó–∂—ñ
        else
            -- –í–∏–¥–∞–ª—è—î–º–æ —Ö–≤—ñ—Å—Ç, —è–∫—â–æ —ó–∂–∞ –Ω–µ –∑'—ó–¥–µ–Ω–∞
            table.remove(snake)
        end

        move_interval = custom_max(0.05, 0.2 - #snake * 0.005) -- –®–≤–∏–¥–∫—ñ—Å—Ç—å –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –¥–æ–≤–∂–∏–Ω–∏ –∑–º—ñ–π–∫–∏
    end
end

function lilka.draw()
    -- –ú–∞–ª—é—î–º–æ —á–æ—Ä–Ω–∏–π —Ñ–æ–Ω
    display.fill_screen(display.color565(0, 0, 0))

    if paused then
        -- –û–Ω–æ–≤–ª–µ–Ω–µ –º–µ–Ω—é –ø–∞—É–∑–∏
        local menu_items = { ""–ü–†–û–î–û–í–ñ–ò–¢–ò"", ""–ù–û–í–ê –ì–†–ê"", ""–¢–ê–ë–õ–ò–¶–Ø –†–ï–ö–û–†–î–Ü–í"", ""–í–ò–•–Ü–î"" }
        local menu_x = display.width // 2 -- –¶–µ–Ω—Ç—Ä—É—î–º–æ —Ç–µ–∫—Å—Ç
        local menu_y = display.height // 2 - 60 -- –¶–µ–Ω—Ç—Ä—É—î–º–æ –º–µ–Ω—é —Ç—Ä–æ—Ö–∏ –≤–∏—â–µ
        local box_width = 200 -- –®–∏—Ä–∏–Ω–∞ –ø—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫–∞
        local box_height = 200 -- –í–∏—Å–æ—Ç–∞ –ø—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫–∞

        -- –ú–∞–ª—é—î–º–æ —Ñ–æ–Ω –¥–ª—è –º–µ–Ω—é
        local box_x = (display.width - box_width) // 2
        local box_y = (display.height - box_height) // 2
        display.fill_rect(box_x, box_y, box_width, box_height, display.color565(25, 25, 112)) -- –¢–µ–º–Ω–æ-—Å–∏–Ω—ñ–π —Ñ–æ–Ω

        -- –ú–∞–ª—é—î–º–æ —Ä–∞–º–∫—É –¥–ª—è –º–µ–Ω—é
        display.draw_rect(box_x, box_y, box_width, box_height, display.color565(255, 215, 0)) -- –ó–æ–ª–æ—Ç–∏—Å—Ç–∞ —Ä–∞–º–∫–∞

        -- –ú–∞–ª—é—î–º–æ –ø—É–Ω–∫—Ç–∏ –º–µ–Ω—é
        for i, item in ipairs(menu_items) do
            local item_y = menu_y + (i - 1) * 40 -- –í—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –ø—É–Ω–∫—Ç–∞–º–∏ –º–µ–Ω—é
            if i == menu_index then
                -- –ú–∞–ª—é—î–º–æ –∑–∞–ª–∏—Ç–∏–π –ø—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫ –∑–∞ —Ç–µ–∫—Å—Ç–æ–º
                display.fill_rect(box_x + 10, item_y - 12, box_width - 20, 30, display.color565(70, 130, 180)) -- –°–≤—ñ—Ç–ª–æ-—Å–∏–Ω—ñ–π —Ñ–æ–Ω
            end
            -- –ú–∞–ª—é—î–º–æ —Ç–µ–∫—Å—Ç –ø—É–Ω–∫—Ç—É –º–µ–Ω—é
            display.set_cursor(menu_x - (#item * 5), item_y) -- –¶–µ–Ω—Ç—Ä—É—î–º–æ —Ç–µ–∫—Å—Ç
            display.set_text_color(display.color565(255, 255, 255)) -- –ë—ñ–ª–∏–π —Ç–µ–∫—Å—Ç
            display.print(item)
        end

        -- –û–±—Ä–æ–±–∫–∞ –≤–∏–±–æ—Ä—É –ø—É–Ω–∫—Ç—É –º–µ–Ω—é
        if state.a.just_pressed then
            if menu_index == 1 then
                paused = false -- –ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ –≥—Ä—É
            elseif menu_index == 2 then
                lilka.init() -- –ù–æ–≤–∞ –≥—Ä–∞
                paused = false
            elseif menu_index == 3 then
                -- –í—ñ–¥–∫—Ä–∏—Ç–∏ —Ç–∞–±–ª–∏—Ü—é —Ä–µ–∫–æ—Ä–¥—ñ–≤
                lilka.show_high_scores()
            elseif menu_index == 4 then
                util.exit() -- –í–∏—Ö—ñ–¥ —ñ–∑ –≥—Ä–∏
            end
        end
        return -- –Ø–∫—â–æ –≥—Ä–∞ –Ω–∞ –ø–∞—É–∑—ñ, –Ω–µ –æ–Ω–æ–≤–ª—é—î–º–æ –≥—Ä—É
    end

    if game_over then
        -- –í–∏–≤–æ–¥–∏–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≥—Ä–∏
        local text = ""–¢–ò –ü–†–û–ì–†–ê–í!""
        local score_text = ""–¢–í–Ü–ô –†–ê–•–£–ù–û–ö: "" .. tostring(score)
        local repeat_text = ""–ù–û–í–ê –ì–†–ê (A), –í–ò–ô–¢–ò (B)""

        -- –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —à–∏—Ä–∏–Ω—É —Ä–∞–º–∫–∏ –∑ –ø–æ–ª—è–º–∏
        local box_width = display.width - 40 -- –ü–æ–ª—è –ø–æ 20 –ø—ñ–∫—Å–µ–ª—ñ–≤ –∑ –∫–æ–∂–Ω–æ–≥–æ –±–æ–∫—É
        local box_height = 150 -- –í–∏—Å–æ—Ç–∞ –ø—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫–∞
        local box_x = (display.width - box_width) // 2
        local box_y = (display.height - box_height) // 2

        -- –ú–∞–ª—é—î–º–æ —Ñ–æ–Ω –¥–ª—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        display.fill_rect(box_x, box_y, box_width, box_height, display.color565(25, 25, 112)) -- –¢–µ–º–Ω–æ-—Å–∏–Ω—ñ–π —Ñ–æ–Ω

        -- –ú–∞–ª—é—î–º–æ —Ä–∞–º–∫—É –¥–ª—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        display.draw_rect(box_x, box_y, box_width, box_height, display.color565(255, 215, 0)) -- –ó–æ–ª–æ—Ç–∏—Å—Ç–∞ —Ä–∞–º–∫–∞

        -- –ú–∞–ª—é—î–º–æ —Ç–µ–∫—Å—Ç ""–¢–ò –ü–†–û–ì–†–ê–í!""
        local text_x = display.width // 2 - (#text * 5) // 2 -- –¶–µ–Ω—Ç—Ä—É—î–º–æ —Ç–µ–∫—Å—Ç
        local text_y = box_y + 10
        display.set_cursor(text_x, text_y)
        display.set_text_color(display.color565(255, 255, 255)) -- –ë—ñ–ª–∏–π —Ç–µ–∫—Å—Ç
        display.print(text)

        -- –ú–∞–ª—é—î–º–æ —Ç–µ–∫—Å—Ç ""–¢–í–Ü–ô –†–ê–•–£–ù–û–ö""
        local score_x = display.width // 2 - (#score_text * 5) // 2 -- –¶–µ–Ω—Ç—Ä—É—î–º–æ —Ç–µ–∫—Å—Ç
        local score_y = text_y + 30
        display.set_cursor(score_x, score_y)
        display.print(score_text)

        -- –ú–∞–ª—é—î–º–æ —Ç–µ–∫—Å—Ç ""–ù–û–í–ê –ì–†–ê (A), –í–ò–ô–¢–ò (B)""
        local repeat_x = display.width // 2 - (#repeat_text * 5) // 2 -- –¶–µ–Ω—Ç—Ä—É—î–º–æ —Ç–µ–∫—Å—Ç
        local repeat_y = box_y + box_height - 30
        display.set_cursor(repeat_x, repeat_y)
        display.print(repeat_text)

        return
    end

    -- –ú–∞–ª—é—î–º–æ –∑–º—ñ–π–∫—É
    for _, segment in ipairs(snake) do
        -- –î–æ–¥–∞—î–º–æ –ø—Ä–æ–º—ñ–∂–∫–∏ –º—ñ–∂ —Å–µ–≥–º–µ–Ω—Ç–∞–º–∏
        local segment_size = cell_size - 2 -- –ó–º–µ–Ω—à—É—î–º–æ —Ä–æ–∑–º—ñ—Ä —Å–µ–≥–º–µ–Ω—Ç–∞ –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø—Ä–æ–º—ñ–∂–∫—ñ–≤
        local segment_x = segment.x * cell_size + 1 -- –î–æ–¥–∞—î–º–æ –≤—ñ–¥—Å—Ç—É–ø –∑–ª—ñ–≤–∞
        local segment_y = segment.y * cell_size + 1 -- –î–æ–¥–∞—î–º–æ –≤—ñ–¥—Å—Ç—É–ø –∑–≤–µ—Ä—Ö—É
        display.fill_rect(segment_x, segment_y, segment_size, segment_size, display.color565(0, 255, 0)) -- –ú–∞–ª—é—î–º–æ —Å–µ–≥–º–µ–Ω—Ç
    end

    -- –ú–∞–ª—é—î–º–æ —ó–∂—É —É –≤–∏–≥–ª—è–¥—ñ —è–±–ª—É–∫–∞
    local function draw_apple(x, y, size)
        -- –õ–∏—Å—Ç–æ—á–æ–∫ (–∑–µ–ª–µ–Ω–∏–π) - –ø–æ –¥—ñ–∞–≥–æ–Ω–∞–ª—ñ —Ç–∞ –±—ñ–ª—å—à–∏–π
        local leaf_width = size // 2
        local leaf_height = size // 3
        display.fill_rect(x + size // 2, y - leaf_height, leaf_width, leaf_height, display.color565(0, 128, 0)) -- –õ–∏—Å—Ç–æ—á–æ–∫ –ø–æ –¥—ñ–∞–≥–æ–Ω–∞–ª—ñ

        -- –Ø–±–ª—É–∫–æ (—á–µ—Ä–≤–æ–Ω–µ) - —Å—Ç–≤–æ—Ä—é—î–º–æ –∫—Ä—É–≥–ª—É —Ñ–æ—Ä–º—É
        local radius = size // 2
        for i = -radius, radius do
            for j = -radius, radius do
                if i * i + j * j <= radius * radius then -- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ —Ç–æ—á–∫–∞ –Ω–∞–ª–µ–∂–∏—Ç—å –∫–æ–ª—É
                    display.fill_rect(x + radius + i, y + radius + j, 1, 1, display.color565(255, 0, 0)) -- –ú–∞–ª—é—î–º–æ –ø—ñ–∫—Å–µ–ª—å —è–±–ª—É–∫–∞
                end
            end
        end
    end

    -- –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—é –¥–ª—è –º–∞–ª—é–≤–∞–Ω–Ω—è —ó–∂—ñ
    draw_apple(food.x * cell_size, food.y * cell_size, cell_size)
end

function lilka.show_high_scores()
    -- –ú–∞–ª—é—î–º–æ —á–æ—Ä–Ω–∏–π —Ñ–æ–Ω
    display.fill_screen(display.color565(0, 0, 0))

    -- –ó–∞–≥–æ–ª–æ–≤–æ–∫
    local title = ""–¢–ê–ë–õ–ò–¶–Ø –†–ï–ö–û–†–î–Ü–í""
    local title_x = display.width // 2 - (#title * 5) // 2
    local title_y = 20
    display.set_cursor(title_x, title_y)
    display.set_text_color(display.color565(255, 255, 255)) -- –ë—ñ–ª–∏–π —Ç–µ–∫—Å—Ç
    display.print(title)

    -- –í–∏–≤–µ–¥–µ–Ω–Ω—è —Ä–µ–∫–æ—Ä–¥—ñ–≤ (–ø—Ä–∏–∫–ª–∞–¥)
    local scores = { 100, 90, 80, 70, 60 } -- –ó–∞–º—ñ–Ω—ñ—Ç—å –Ω–∞ —Ä–µ–∞–ª—å–Ω—ñ –¥–∞–Ω—ñ
    for i, score in ipairs(scores) do
        local score_text = tostring(i) .. "". "" .. tostring(score)
        local score_x = display.width // 2 - (#score_text * 5) // 2
        local score_y = title_y + 30 + (i - 1) * 20
        display.set_cursor(score_x, score_y)
        display.print(score_text)
    end

    -- –Ü–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è –¥–ª—è –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è
    local back_text = ""–ù–ê–¢–ò–°–ù–Ü–¢–¨ A, –©–û–ë –ü–û–í–ï–†–ù–£–¢–ò–°–Ø""
    local back_x = display.width // 2 - (#back_text * 5) // 2
    local back_y = display.height - 30
    display.set_cursor(back_x, back_y)
    display.print(back_text)

    -- –û—á—ñ–∫—É—î–º–æ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—è –∫–Ω–æ–ø–∫–∏ A –¥–ª—è –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è
    while true do
        local state = controller.get_state()
        if state.a.just_pressed then
            break -- –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ—Å—è –¥–æ –≥—Ä–∏
        end
    end
end

if (score or 0) > (high_score or 0) then
    high_score = score -- –û–Ω–æ–≤–ª—é—î–º–æ —Ä–µ–∫–æ—Ä–¥
end"
Bw6uztxA,Untitled,Josif_tepe,C++,Tuesday 1st of July 2025 09:33:52 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
string to_binary(int x) {
    string res = """";
    while(x > 0) {
        int rem = x % 2;
        x /= 2;
        res += (rem + '0');
    }
    reverse(res.begin(), res.end());
    return res;
}

int to_decimal(string s) {
    int res = 0;
    int pow_of_two = 1;
    
    for(int i = (int) s.size() - 1; i >= 0; i--) {
        if(s[i] == '1') {
            res += pow_of_two;
        }
        
        pow_of_two *= 2;
    }
    return res;
}

int main()
{
    cout << to_binary(786) << endl;
    cout << to_decimal(""1100010010"") << endl;
    return 0;
}
"
ysFSiK2G,tv 07-2025 task,spidersam,JSON,Tuesday 1st of July 2025 09:14:58 AM CDT,"[
   {
    ""name"": ""ZooTv-Live-01-07-2025"",
    ""url"": ""https://app.talkshoe.com/drive_files/download/c8247c7e-ece1-47ba-9f69-09ae318deca1.mp4"",
    ""imageUrl"": ""https://i.imgur.com/JxTvPB7.jpeg""
   }
]"
mRAQbg2F,Untitled,Josif_tepe,C++,Tuesday 1st of July 2025 09:05:38 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
int p,m;
int n;
const int maxn=51;
const int INF=2e9;

int x[maxn];
int dp[maxn][1005];
int rec(int at,int position){
    if(at==n){
        return position;
    }
    if(dp[at][position] != -1) {
        return dp[at][position];
    }
    int res=-INF;
    if(position+x[at]<=m){
        res=max(res,rec(at+1,position+x[at]));
    }
    if(position-x[at]>=0){
        res=max(res,rec(at+1,position-x[at]));
    }
    
    dp[at][position] = res;
    return res;
}
int main()
{
    memset(dp, -1, sizeof dp);
    cin>>p>>m;
    cin>>n;
    for(int i = 0;i<n;i++){
        cin>>x[i];
    }
    int res=rec(0, p);
    if(res==-INF){
        cout<<-1;
    }else{
      cout<<res;
    }
    return 0;
}
"
gZFisSUY,Untitled,fikosoftware,JavaScript,Tuesday 1st of July 2025 08:50:29 AM CDT,"(function () {
  const whatsappLinkRegex = /https:\/\/chat\.whatsapp\.com\/[a-zA-Z0-9]+/g;
  const foundLinks = new Set();

  // Create download button
  const button = document.createElement(""button"");
  button.textContent = ""üì• Download WhatsApp Links (0)"";
  button.style.position = ""fixed"";
  button.style.top = ""20px"";
  button.style.right = ""20px"";
  button.style.zIndex = ""9999"";
  button.style.padding = ""10px 15px"";
  button.style.backgroundColor = ""#25D366"";
  button.style.color = ""#fff"";
  button.style.border = ""none"";
  button.style.borderRadius = ""5px"";
  button.style.cursor = ""pointer"";
  button.style.fontSize = ""14px"";
  document.body.appendChild(button);

  // Function to update button text with count
  const updateButtonText = () => {
    button.textContent = `üì• Download WhatsApp Links (${foundLinks.size})`;
  };

  // Check and collect new links every 2 seconds
  const checkForLinks = () => {
    const html = document.documentElement.innerHTML;
    const matches = html.match(whatsappLinkRegex) || [];

    matches.forEach(link => {
      if (!foundLinks.has(link)) {
        foundLinks.add(link);
        console.log(""üü¢ New WhatsApp Link:"", link);
        updateButtonText();
      }
    });
  };

  setInterval(checkForLinks, 2000);

  console.log(""üîç Watching for new WhatsApp links as you scroll..."");

  // Download links on button click
  button.addEventListener(""click"", () => {
    const blob = new Blob([Array.from(foundLinks).join(""\n"")], { type: ""text/plain"" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement(""a"");
    a.href = url;
    a.download = ""whatsapp_links.txt"";
    a.click();
    URL.revokeObjectURL(url);
  });
})();"
BQXz93BB,FarmaKeeep - Dashboard de visualiza√ß√£o,lucasvinicius,JavaScript,Tuesday 1st of July 2025 08:40:39 AM CDT,"import React, { useState, useMemo } from 'react';
import { Search, Filter, Eye, AlertCircle, CheckCircle, XCircle, Clock, Building, FileText, Settings } from 'lucide-react';

const FarmakeepGrid = () => {
  const [selectedCell, setSelectedCell] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState('all');
  const [viewMode, setViewMode] = useState('normal');
  const [hoveredCell, setHoveredCell] = useState(null);

  // Dados simulados
  const establishments = [
    { id: 1, name: 'Farm√°cia Central', cnpj: '12.345.678/0001-90', city: 'S√£o Paulo', region: 'SP' },
    { id: 2, name: 'Drogaria Sa√∫de', cnpj: '98.765.432/0001-10', city: 'Rio de Janeiro', region: 'RJ' },
    { id: 3, name: 'Farm√°cia Popular', cnpj: '11.222.333/0001-44', city: 'Belo Horizonte', region: 'MG' },
    { id: 4, name: 'Medicenter', cnpj: '55.666.777/0001-88', city: 'Bras√≠lia', region: 'DF' },
    { id: 5, name: 'FarmaVida', cnpj: '33.444.555/0001-22', city: 'Salvador', region: 'BA' },
    { id: 6, name: 'DrugStore Plus', cnpj: '77.888.999/0001-66', city: 'Fortaleza', region: 'CE' },
  ];

  const documents = [
    { id: 1, name: 'Alvar√° Sanit√°rio', type: 'sanitario', critical: true },
    { id: 2, name: 'Licen√ßa ANVISA', type: 'sanitario', critical: true },
    { id: 3, name: 'AFE', type: 'fiscal', critical: false },
    { id: 4, name: 'Respons√°vel T√©cnico', type: 'tecnico', critical: true },
    { id: 5, name: 'CNPJ Ativo', type: 'fiscal', critical: false },
    { id: 6, name: 'Licen√ßa Municipal', type: 'municipal', critical: true },
    { id: 7, name: 'Certificado Digital', type: 'fiscal', critical: false },
    { id: 8, name: 'Plano de Gerenciamento', type: 'ambiental', critical: false },
  ];

  // Status dos documentos (simulado)
  const documentStatus = {
    '1-1': { status: 'regular', daysLeft: 120, lastUpdate: '2024-06-15' },
    '1-2': { status: 'atencao', daysLeft: 25, lastUpdate: '2024-06-10' },
    '1-3': { status: 'vencido', daysLeft: -5, lastUpdate: '2024-06-01' },
    '1-4': { status: 'regular', daysLeft: 90, lastUpdate: '2024-06-20' },
    '1-5': { status: 'protocolo', daysLeft: null, lastUpdate: '2024-06-25' },
    '1-6': { status: 'exigencia', daysLeft: 10, lastUpdate: '2024-06-22' },
    '1-7': { status: 'regular', daysLeft: 200, lastUpdate: '2024-06-18' },
    '1-8': { status: 'atencao', daysLeft: 30, lastUpdate: '2024-06-12' },
    
    '2-1': { status: 'atencao', daysLeft: 15, lastUpdate: '2024-06-14' },
    '2-2': { status: 'regular', daysLeft: 80, lastUpdate: '2024-06-16' },
    '2-3': { status: 'regular', daysLeft: 150, lastUpdate: '2024-06-20' },
    '2-4': { status: 'vencido', daysLeft: -10, lastUpdate: '2024-05-28' },
    '2-5': { status: 'regular', daysLeft: 300, lastUpdate: '2024-06-25' },
    '2-6': { status: 'atencao', daysLeft: 20, lastUpdate: '2024-06-15' },
    '2-7': { status: 'protocolo', daysLeft: null, lastUpdate: '2024-06-24' },
    '2-8': { status: 'regular', daysLeft: 100, lastUpdate: '2024-06-19' },

    '3-1': { status: 'regular', daysLeft: 180, lastUpdate: '2024-06-17' },
    '3-2': { status: 'regular', daysLeft: 95, lastUpdate: '2024-06-21' },
    '3-3': { status: 'vencido', daysLeft: -3, lastUpdate: '2024-06-02' },
    '3-4': { status: 'atencao', daysLeft: 28, lastUpdate: '2024-06-13' },
    '3-5': { status: 'regular', daysLeft: 250, lastUpdate: '2024-06-23' },
    '3-6': { status: 'exigencia', daysLeft: 7, lastUpdate: '2024-06-20' },
    '3-7': { status: 'regular', daysLeft: 160, lastUpdate: '2024-06-18' },
    '3-8': { status: 'regular', daysLeft: 75, lastUpdate: '2024-06-16' },

    '4-1': { status: 'atencao', daysLeft: 22, lastUpdate: '2024-06-11' },
    '4-2': { status: 'regular', daysLeft: 110, lastUpdate: '2024-06-19' },
    '4-3': { status: 'regular', daysLeft: 140, lastUpdate: '2024-06-22' },
    '4-4': { status: 'regular', daysLeft: 85, lastUpdate: '2024-06-17' },
    '4-5': { status: 'protocolo', daysLeft: null, lastUpdate: '2024-06-26' },
    '4-6': { status: 'vencido', daysLeft: -8, lastUpdate: '2024-05-30' },
    '4-7': { status: 'regular', daysLeft: 190, lastUpdate: '2024-06-21' },
    '4-8': { status: 'atencao', daysLeft: 35, lastUpdate: '2024-06-14' },

    '5-1': { status: 'regular', daysLeft: 70, lastUpdate: '2024-06-24' },
    '5-2': { status: 'atencao', daysLeft: 18, lastUpdate: '2024-06-12' },
    '5-3': { status: 'regular', daysLeft: 130, lastUpdate: '2024-06-20' },
    '5-4': { status: 'regular', daysLeft: 95, lastUpdate: '2024-06-18' },
    '5-5': { status: 'regular', daysLeft: 280, lastUpdate: '2024-06-25' },
    '5-6': { status: 'regular', daysLeft: 60, lastUpdate: '2024-06-15' },
    '5-7': { status: 'exigencia', daysLeft: 12, lastUpdate: '2024-06-22' },
    '5-8': { status: 'regular', daysLeft: 105, lastUpdate: '2024-06-19' },

    '6-1': { status: 'vencido', daysLeft: -15, lastUpdate: '2024-05-25' },
    '6-2': { status: 'regular', daysLeft: 125, lastUpdate: '2024-06-23' },
    '6-3': { status: 'atencao', daysLeft: 27, lastUpdate: '2024-06-13' },
    '6-4': { status: 'regular', daysLeft: 88, lastUpdate: '2024-06-17' },
    '6-5': { status: 'regular', daysLeft: 220, lastUpdate: '2024-06-24' },
    '6-6': { status: 'protocolo', daysLeft: null, lastUpdate: '2024-06-27' },
    '6-7': { status: 'regular', daysLeft: 175, lastUpdate: '2024-06-20' },
    '6-8': { status: 'regular', daysLeft: 65, lastUpdate: '2024-06-16' },
  };

  const getStatusInfo = (status, daysLeft) => {
    const configs = {
      regular: { 
        color: 'bg-green-500', 
        icon: CheckCircle, 
        label: 'Regular',
        intensity: daysLeft > 60 ? 'bg-green-500' : 'bg-green-400'
      },
      atencao: { 
        color: 'bg-orange-500', 
        icon: AlertCircle, 
        label: 'Precisa de Aten√ß√£o',
        intensity: daysLeft < 20 ? 'bg-orange-600' : 'bg-orange-400'
      },
      vencido: { 
        color: 'bg-red-500', 
        icon: XCircle, 
        label: 'Vencido',
        intensity: Math.abs(daysLeft) > 10 ? 'bg-red-600' : 'bg-red-500'
      },
      protocolo: { 
        color: 'bg-blue-500', 
        icon: FileText, 
        label: 'Protocolo',
        intensity: 'bg-blue-500'
      },
      exigencia: { 
        color: 'bg-purple-500', 
        icon: Clock, 
        label: 'Em Exig√™ncia',
        intensity: daysLeft < 10 ? 'bg-purple-600' : 'bg-purple-500'
      }
    };
    return configs[status] || configs.regular;
  };

  const filteredEstablishments = useMemo(() => {
    return establishments.filter(est => 
      est.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      est.cnpj.includes(searchTerm) ||
      est.city.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm]);

  const getStatusCounts = () => {
    const counts = { regular: 0, atencao: 0, vencido: 0, protocolo: 0, exigencia: 0 };
    Object.values(documentStatus).forEach(doc => {
      counts[doc.status]++;
    });
    return counts;
  };

  const statusCounts = getStatusCounts();

  const Tooltip = ({ cell, establishment, document }) => {
    if (!cell) return null;
    
    const statusInfo = getStatusInfo(cell.status, cell.daysLeft);
    const Icon = statusInfo.icon;
    
    return (
      <div className=""absolute z-50 bg-gray-900 text-white p-3 rounded-lg shadow-xl border border-gray-700 min-w-64"">
        <div className=""flex items-center gap-2 mb-2"">
          <Icon size={16} className=""text-gray-300"" />
          <span className=""font-semibold"">{statusInfo.label}</span>
        </div>
        <div className=""space-y-1 text-sm"">
          <div><strong>Estabelecimento:</strong> {establishment.name}</div>
          <div><strong>Documento:</strong> {document.name}</div>
          <div><strong>CNPJ:</strong> {establishment.cnpj}</div>
          <div><strong>Localiza√ß√£o:</strong> {establishment.city}/{establishment.region}</div>
          {cell.daysLeft !== null && (
            <div><strong>Dias restantes:</strong> 
              <span className={cell.daysLeft < 0 ? 'text-red-400' : cell.daysLeft < 30 ? 'text-orange-400' : 'text-green-400'}>
                {cell.daysLeft < 0 ? ` ${Math.abs(cell.daysLeft)} dias vencido` : ` ${cell.daysLeft} dias`}
              </span>
            </div>
          )}
          <div><strong>√öltima atualiza√ß√£o:</strong> {cell.lastUpdate}</div>
        </div>
      </div>
    );
  };

  return (
    <div className=""min-h-screen bg-gray-50 p-6"">
      {/* Header */}
      <div className=""mb-6"">
        <div className=""flex items-center gap-3 mb-4"">
          <div className=""w-10 h-10 bg-green-500 rounded-full flex items-center justify-center"">
            <span className=""text-white font-bold text-lg"">F</span>
          </div>
          <h1 className=""text-2xl font-bold text-gray-800"">Farmakeep</h1>
        </div>
        
        {/* Status Cards */}
        <div className=""grid grid-cols-5 gap-4 mb-6"">
          <div className=""bg-green-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.regular}</div>
            <div className=""text-sm opacity-90"">REGULAR</div>
          </div>
          <div className=""bg-orange-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.atencao}</div>
            <div className=""text-sm opacity-90"">PRECISA DE ATEN√á√ÉO</div>
          </div>
          <div className=""bg-red-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.vencido}</div>
            <div className=""text-sm opacity-90"">VENCIDO</div>
          </div>
          <div className=""bg-blue-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.protocolo}</div>
            <div className=""text-sm opacity-90"">PROTOCOLO</div>
          </div>
          <div className=""bg-purple-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.exigencia}</div>
            <div className=""text-sm opacity-90"">EM EXIG√äNCIA</div>
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className=""bg-white rounded-lg shadow-sm border p-4 mb-6"">
        <div className=""flex flex-wrap gap-4 items-center justify-between"">
          <div className=""flex gap-4 items-center"">
            <div className=""relative"">
              <Search className=""absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"" size={16} />
              <input
                type=""text""
                placeholder=""Buscar estabelecimento, CNPJ ou cidade...""
                className=""pl-10 pr-4 py-2 border border-gray-300 rounded-lg w-80""
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
            
            <select 
              className=""px-4 py-2 border border-gray-300 rounded-lg""
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
            >
              <option value=""all"">Todos os Status</option>
              <option value=""vencido"">Apenas Vencidos</option>
              <option value=""atencao"">Precisa Aten√ß√£o</option>
              <option value=""regular"">Regulares</option>
            </select>
          </div>

          <div className=""flex gap-2 items-center"">
            <span className=""text-sm text-gray-600"">Visualiza√ß√£o:</span>
            <select 
              className=""px-3 py-2 border border-gray-300 rounded-lg text-sm""
              value={viewMode}
              onChange={(e) => setViewMode(e.target.value)}
            >
              <option value=""compact"">Compacta</option>
              <option value=""normal"">Normal</option>
              <option value=""detailed"">Detalhada</option>
            </select>
          </div>
        </div>
      </div>

      {/* Grid */}
      <div className=""bg-white rounded-lg shadow-sm border overflow-hidden"">
        <div className=""overflow-x-auto"">
          <div className=""min-w-max"">
            {/* Header Row */}
            <div className=""flex bg-gray-100 border-b sticky top-0 z-10"">
              <div className=""w-48 p-3 font-medium text-gray-700 border-r bg-gray-100"">
                <div className=""flex items-center gap-2"">
                  <Building size={16} />
                  Estabelecimentos
                </div>
              </div>
              {documents.map((doc) => (
                <div key={doc.id} className=""w-24 p-2 text-center border-r bg-gray-100"">
                  <div className=""transform -rotate-45 origin-center text-xs font-medium text-gray-700 whitespace-nowrap"">
                    {doc.name}
                  </div>
                  {doc.critical && (
                    <div className=""mt-1 flex justify-center"">
                      <AlertCircle size={12} className=""text-red-500"" />
                    </div>
                  )}
                </div>
              ))}
            </div>

            {/* Data Rows */}
            {filteredEstablishments.map((establishment) => (
              <div key={establishment.id} className=""flex border-b hover:bg-gray-50"">
                <div className=""w-48 p-3 border-r bg-white sticky left-0"">
                  <div className=""font-medium text-gray-900"">{establishment.name}</div>
                  <div className=""text-xs text-gray-500"">{establishment.cnpj}</div>
                  <div className=""text-xs text-gray-500"">{establishment.city}/{establishment.region}</div>
                </div>
                
                {documents.map((document) => {
                  const cellKey = `${establishment.id}-${document.id}`;
                  const cellData = documentStatus[cellKey];
                  const statusInfo = getStatusInfo(cellData?.status || 'regular', cellData?.daysLeft);
                  const Icon = statusInfo.icon;
                  
                  return (
                    <div
                      key={document.id}
                      className=""w-24 h-16 border-r relative cursor-pointer group""
                      onMouseEnter={() => setHoveredCell({ cellData, establishment, document, cellKey })}
                      onMouseLeave={() => setHoveredCell(null)}
                      onClick={() => setSelectedCell({ cellData, establishment, document })}
                    >
                      <div className={`w-full h-full ${statusInfo.intensity} flex items-center justify-center transition-all duration-200 group-hover:scale-110 group-hover:shadow-lg`}>
                        <Icon size={viewMode === 'compact' ? 12 : viewMode === 'detailed' ? 20 : 16} className=""text-white"" />
                        {viewMode === 'detailed' && cellData?.daysLeft !== null && (
                          <span className=""absolute bottom-1 text-xs text-white font-bold"">
                            {cellData.daysLeft < 0 ? cellData.daysLeft : `+${cellData.daysLeft}`}
                          </span>
                        )}
                      </div>
                      
                      {document.critical && (
                        <div className=""absolute -top-1 -right-1 w-3 h-3 bg-red-600 rounded-full border border-white""></div>
                      )}
                    </div>
                  );
                })}
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Tooltip */}
      {hoveredCell && (
        <div className=""fixed pointer-events-none z-50"" style={{ 
          left: `${Math.min(window.innerWidth - 300, window.event?.clientX + 10)}px`, 
          top: `${Math.max(10, window.event?.clientY - 50)}px` 
        }}>
          <Tooltip 
            cell={hoveredCell.cellData} 
            establishment={hoveredCell.establishment} 
            document={hoveredCell.document} 
          />
        </div>
      )}

      {/* Side Panel */}
      {selectedCell && (
        <div className=""fixed right-0 top-0 h-full w-80 bg-white shadow-2xl border-l z-40 transform transition-transform duration-300"">
          <div className=""p-6"">
            <div className=""flex items-center justify-between mb-4"">
              <h3 className=""text-lg font-semibold"">Detalhes do Documento</h3>
              <button 
                onClick={() => setSelectedCell(null)}
                className=""text-gray-400 hover:text-gray-600""
              >
                <XCircle size={20} />
              </button>
            </div>
            
            <div className=""space-y-4"">
              <div>
                <label className=""text-sm font-medium text-gray-600"">Estabelecimento</label>
                <div className=""mt-1 text-gray-900"">{selectedCell.establishment.name}</div>
              </div>
              
              <div>
                <label className=""text-sm font-medium text-gray-600"">Documento</label>
                <div className=""mt-1 text-gray-900"">{selectedCell.document.name}</div>
              </div>
              
              <div>
                <label className=""text-sm font-medium text-gray-600"">Status</label>
                <div className=""mt-1"">
                  <span className={`inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm text-white ${getStatusInfo(selectedCell.cellData?.status, selectedCell.cellData?.daysLeft).color}`}>
                    {React.createElement(getStatusInfo(selectedCell.cellData?.status, selectedCell.cellData?.daysLeft).icon, { size: 16 })}
                    {getStatusInfo(selectedCell.cellData?.status, selectedCell.cellData?.daysLeft).label}
                  </span>
                </div>
              </div>
              
              {selectedCell.cellData?.daysLeft !== null && (
                <div>
                  <label className=""text-sm font-medium text-gray-600"">Situa√ß√£o</label>
                  <div className=""mt-1 text-gray-900"">
                    {selectedCell.cellData.daysLeft < 0 
                      ? `Vencido h√° ${Math.abs(selectedCell.cellData.daysLeft)} dias`
                      : `${selectedCell.cellData.daysLeft} dias restantes`
                    }
                  </div>
                </div>
              )}
              
              <div>
                <label className=""text-sm font-medium text-gray-600"">√öltima Atualiza√ß√£o</label>
                <div className=""mt-1 text-gray-900"">{selectedCell.cellData?.lastUpdate}</div>
              </div>
              
              <div className=""pt-4 space-y-2"">
                <button className=""w-full bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700"">
                  Ver Documento
                </button>
                <button className=""w-full bg-green-600 text-white py-2 px-4 rounded-lg hover:bg-green-700"">
                  Atualizar Status
                </button>
                <button className=""w-full bg-gray-600 text-white py-2 px-4 rounded-lg hover:bg-gray-700"">
                  Hist√≥rico
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default FarmakeepGrid;"
RAF5qP3N,2025-07-01T17:59:30.808367,powerampache,PHP,Tuesday 1st of July 2025 07:59:31 AM CDT,"1.01-76 (76) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.MusicException: {""errorAction"":""handshake"",""errorCode"":""4701"",""errorMessage"":""Received Invalid Handshake - Incorrect username or password"",""errorType"":""account""}
	at luci.sixsixsix.powerampache2.data.MusicRepositoryImpl.tryAuthorize(MusicRepositoryImpl.kt:268)
	at luci.sixsixsix.powerampache2.data.MusicRepositoryImpl.access$tryAuthorize(MusicRepositoryImpl.kt:83)
	at luci.sixsixsix.powerampache2.data.MusicRepositoryImpl$tryAuthorize$1.invokeSuspend(Unknown Source:18)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:959)
	at android.os.Handler.dispatchMessage(Handler.java:100)
	at android.os.Looper.loopOnce(Looper.java:249)
	at android.os.Looper.loop(Looper.java:337)
	at android.app.ActivityThread.main(ActivityThread.java:9493)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:636)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1005)

authorize() - {""errorAction"":""handshake"",""errorCode"":""4701"",""errorMessage"":""Received Invalid Handshake - Incorrect username or password"",""errorType"":""account""}"
MT5X9TBc,Roblox Zombies vs Humans Script,engineer404,Lua,Tuesday 1st of July 2025 07:48:18 AM CDT,"GET OPEN SOURCE SCRIPT AT https://link-center.net/678735/DID7IcGZcOab

Fisch, Blox Fruits, King Legacy, Phantom Forces, Pet Simulator 99, Frontlines, Zombie Attack, Anime Last Stand, Bed Wars, Jujutsu Infinite, Anime Fighters Simulator, Rivas, Arsenal, Murder Mystery 2, Arm Wrestle Simulator, SCP 3008, Anime Vanguard, Blade Ball, Anime Shadow, The Strongest Battlegrounds, Ninja Legends, Anime Crossover Defense, Jailbreak, Meme Sea, Real Rampage, BrooHaven, Weak Legacy 2, Bee Swarm Simulator, Gym League, PEST GO!, Tower Of Hell, Restaurant Tycoon, Slap Battles, Who's the Spy?, TPS: Street Soccer, Car Dealership Tycoon, A Universal Time, Survival Stories, Jujutsu Shenanigans, Broken Bones IV, Haze Piece, Anime Blast Simulator, Murderers VS Sheriffs Duels, Anime Stars Simulator, ALONE, Legends Re:Written, Rarity Factory, Stud Jump Obby, Type or Die, LUCKY BLOCKS Battlegrounds, Grass Cutting Simulator, Deadly Sins Retribution, raise a floppa 2, Energy Assault, Adopt Me, Shockwave Racing, Shindo Life, Tower Defense Simulator, Flee the Facility, Build a Boat Simulator, Prison Life, Mad City Chapter 2, Westbound, Blue Lock: Rivals, Slime Slaying Online RPG, Toilet Defense Simulato, Da Hood, Escape Papa Pizzas Pizzeria, Survive the Killer, Anime Slashing Simulator, Speed Run 4, Sakura Stand, Dragon Adventures, Booga Booga [REBORN], Driving Empire, Dungeon RNG, Lifting Simulator, Super League Soccer, A Dusty Trip, Grow a garden, Steal a brainrot"
Pn1B14z9,awdwa,suramraja1,Lua,Tuesday 1st of July 2025 07:41:04 AM CDT,"-- SERVICES & MODULES
local Players = game:GetService(""Players"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local UserInputService = game:GetService(""UserInputService"")
local player = Players.LocalPlayer

local GetFarm = require(ReplicatedStorage.Modules.GetFarm)
local MutationHandler = require(ReplicatedStorage.Modules:WaitForChild(""MutationHandler""))

-- ‚úÖ FRUIT LOG SYSTEM
local fruitLog = {}
local maxLogEntries = 200
local lastKnownFruits = {} -- Track existing fruits to detect spawns/deletions
local logGui = nil

-- Helper function for mutation priority
local function getMutationPriority(mutation)
    local priorityMap = {
        [""Moonlit""] = 6,
        [""Choc""] = 5,
        [""Shocked""] = 4,
        [""Frozen""] = 3,
        [""Chilled""] = 2,
        [""Wet""] = 1,
        [""None""] = 0
    }
    
    -- Count mutations and assign a priority
    if mutation == ""None"" then
        return 0
    end
    
    -- If it contains multiple mutations, count them
    local count = 0
    for w in mutation:gmatch(""([^‚Ä¢]+)"") do -- Changed to match bullet separator
        count = count + 1
    end
    
    -- Multiple mutations always have highest priority
    if count > 1 then
        return 100 + count
    end
    
    -- Single mutation - look up its priority
    for mutName, priority in pairs(priorityMap) do
        if mutation:find(mutName) then
            return priority
        end
    end
    
    return 0
end

-- Helper function for variant priority
local function getVariantPriority(variant)
    local priorityMap = {
        [""Rainbow""] = 3,
        [""Gold""] = 2,
        [""Normal""] = 1
    }
    
    return priorityMap[variant] or 0
end

-- GUI SETUP
local playerGui = player:WaitForChild(""PlayerGui"")

-- Check if GUI already exists and remove it
local existingGui = playerGui:FindFirstChild(""FruitListGui"")
if existingGui then
    existingGui:Destroy()
end

-- State variables
local currentSortColumn = ""Fruit Name"" -- Default sort by name
local currentSortDir = ""asc"" -- Default ascending
local allFruitsData = {} -- Will store all fruits data for sorting
local isMinimized = false -- Track minimize state
local originalSize -- Store original size when minimizing

local fruitListGui = Instance.new(""ScreenGui"")
fruitListGui.Name = ""FruitListGui""
fruitListGui.ResetOnSpawn = false
fruitListGui.Parent = playerGui

local mainFrame = Instance.new(""Frame"")
mainFrame.Size = UDim2.new(0, 500, 0, 400)
mainFrame.Position = UDim2.new(0.5, -250, 0.5, -200)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
mainFrame.BackgroundTransparency = 0.1
mainFrame.Parent = fruitListGui
mainFrame.Active = true

-- Store original size for minimizing
originalSize = mainFrame.Size

-- Add rounded corners to main frame
local mainCorner = Instance.new(""UICorner"")
mainCorner.CornerRadius = UDim.new(0, 8)
mainCorner.Parent = mainFrame

-- Title bar
local titleBar = Instance.new(""Frame"")
titleBar.Name = ""TitleBar""
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame

-- Add rounded corners to title bar (top corners only)
local titleCorner = Instance.new(""UICorner"")
titleCorner.CornerRadius = UDim.new(0, 8)
titleCorner.Parent = titleBar

-- Make sure the title bar only rounds the top corners
local bottomFrame = Instance.new(""Frame"")
bottomFrame.Size = UDim2.new(1, 0, 0.5, 0)
bottomFrame.Position = UDim2.new(0, 0, 0.5, 0)
bottomFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
bottomFrame.BorderSizePixel = 0
bottomFrame.Parent = titleBar

local titleText = Instance.new(""TextLabel"")
titleText.Name = ""Title""
titleText.Size = UDim2.new(1, -60, 1, 0)
titleText.BackgroundTransparency = 1
titleText.Text = ""Farm Fruit List""
titleText.Font = Enum.Font.SourceSansBold
titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
titleText.TextSize = 18
titleText.Parent = titleBar

-- Close button
local closeButton = Instance.new(""TextButton"")
closeButton.Name = ""CloseButton""
closeButton.Size = UDim2.new(0, 30, 0, 30)
closeButton.Position = UDim2.new(1, -30, 0, 0)
closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
closeButton.Text = ""X""
closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
closeButton.TextSize = 18
closeButton.Font = Enum.Font.SourceSansBold
closeButton.Parent = titleBar

-- Add rounded corners to close button
local closeCorner = Instance.new(""UICorner"")
closeCorner.CornerRadius = UDim.new(0, 6)
closeCorner.Parent = closeButton

-- Minimize button
local minimizeButton = Instance.new(""TextButton"")
minimizeButton.Name = ""MinimizeButton""
minimizeButton.Size = UDim2.new(0, 30, 0, 30)
minimizeButton.Position = UDim2.new(1, -65, 0, 0)
minimizeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 200)
minimizeButton.Text = ""-""
minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizeButton.TextSize = 22
minimizeButton.Font = Enum.Font.SourceSansBold
minimizeButton.Parent = titleBar

-- Add rounded corners to minimize button
local minimizeCorner = Instance.new(""UICorner"")
minimizeCorner.CornerRadius = UDim.new(0, 6)
minimizeCorner.Parent = minimizeButton

-- Function to toggle minimize state
local function toggleMinimize()
    isMinimized = not isMinimized
    
    if isMinimized then
        -- Store current size before minimizing
        originalSize = mainFrame.Size
        
        -- Minimize GUI - just show title bar
        mainFrame.Size = UDim2.new(0, 300, 0, 30)
        minimizeButton.Text = ""+""
        
        -- Hide content
        if mainFrame:FindFirstChild(""HeaderFrame"") then
            mainFrame.HeaderFrame.Visible = false
        end
        if mainFrame:FindFirstChild(""ScrollingFrame"") then
            mainFrame.ScrollingFrame.Visible = false
        end
        if mainFrame:FindFirstChild(""ResizeHandle"") then
            mainFrame.ResizeHandle.Visible = false
        end
    else
        -- Restore GUI to original size
        mainFrame.Size = originalSize
        minimizeButton.Text = ""-""
        
        -- Show content
        if mainFrame:FindFirstChild(""HeaderFrame"") then
            mainFrame.HeaderFrame.Visible = true
        end
        if mainFrame:FindFirstChild(""ScrollingFrame"") then
            mainFrame.ScrollingFrame.Visible = true
        end
        if mainFrame:FindFirstChild(""ResizeHandle"") then
            mainFrame.ResizeHandle.Visible = true
        end
    end
end

-- Connect minimize button
minimizeButton.MouseButton1Click:Connect(toggleMinimize)

-- Add keyboard shortcut (Left Ctrl) to toggle minimize
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.LeftControl then
        toggleMinimize()
    end
end)

-- Resize Handle
local resizeHandle = Instance.new(""Frame"")
resizeHandle.Size = UDim2.new(0, 24, 0, 24)
resizeHandle.Position = UDim2.new(1, -24, 1, -24)
resizeHandle.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
resizeHandle.BorderSizePixel = 0
resizeHandle.Parent = mainFrame
resizeHandle.Name = ""ResizeHandle""
resizeHandle.ZIndex = 10

local resizeCorner = Instance.new(""UICorner"")
resizeCorner.CornerRadius = UDim.new(0, 8)
resizeCorner.Parent = resizeHandle

-- IMPROVED DRAGGING IMPLEMENTATION
local dragging = false
local dragInput
local dragStart
local startPos
local lastMousePos
local lastGoalPos

local function updateDrag(input)
    if dragging then
        local delta = input.Position - dragStart
        local position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
                                   startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        
        -- Use a smoother movement with lerping
        game:GetService(""RunService"").RenderStepped:Wait()
        mainFrame.Position = position
    end
end

titleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or
       input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position
        lastMousePos = Vector2.new(input.Position.X, input.Position.Y)
        
        -- Continue tracking even if mouse leaves the titleBar
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

titleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or
       input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        updateDrag(input)
    end
end)

-- Resize Script
local draggingResize = false
local resizeStart
local startSize

resizeHandle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or
       input.UserInputType == Enum.UserInputType.Touch then
        draggingResize = true
        resizeStart = input.Position
        startSize = mainFrame.Size
        
        -- Track input end even outside the resize handle
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                draggingResize = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if draggingResize and (input.UserInputType == Enum.UserInputType.MouseMovement or
                          input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - resizeStart
        local newWidth = math.max(400, startSize.X.Offset + delta.X)
        local newHeight = math.max(300, startSize.Y.Offset + delta.Y)
        mainFrame.Size = UDim2.new(0, newWidth, 0, newHeight)
        
        -- Store new size for when un-minimizing
        originalSize = mainFrame.Size
        
        -- Recalculate scrolling frame size when resizing
        local headerHeight = 30 -- title bar height
        if mainFrame:FindFirstChild(""HeaderFrame"") and mainFrame:FindFirstChild(""ScrollingFrame"") then
            mainFrame.ScrollingFrame.Size = UDim2.new(1, -20, 1, -(headerHeight + mainFrame.HeaderFrame.Size.Y.Offset + 20))
        end
    end
end)

-- Close button logic
closeButton.MouseButton1Click:Connect(function()
    fruitListGui:Destroy()
end)

-- Header Frame for column titles
local headerFrame = Instance.new(""Frame"")
headerFrame.Name = ""HeaderFrame""
headerFrame.Size = UDim2.new(1, -20, 0, 35)
headerFrame.Position = UDim2.new(0, 10, 0, 40)
headerFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
headerFrame.BackgroundTransparency = 0.5
headerFrame.Parent = mainFrame

-- Add rounded corners to header frame
local headerCorner = Instance.new(""UICorner"")
headerCorner.CornerRadius = UDim.new(0, 6)
headerCorner.Parent = headerFrame

-- Column Headers - SIMPLIFIED: only 4 columns now
local columns = {""Fruit Name"", ""Variant"", ""Weight (kg)"", ""Mutations""}
local columnWidths = {0.22, 0.18, 0.18, 0.42}  -- Give more space to mutations column
local sortButtons = {}

-- Scrolling Frame for fruit list
local scrollingFrame = Instance.new(""ScrollingFrame"")
scrollingFrame.Name = ""ScrollingFrame""
scrollingFrame.Size = UDim2.new(1, -20, 1, -85)
scrollingFrame.Position = UDim2.new(0, 10, 0, 85)
scrollingFrame.BackgroundTransparency = 0.9
scrollingFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
scrollingFrame.BorderSizePixel = 0
scrollingFrame.ScrollBarThickness = 8
scrollingFrame.Parent = mainFrame

-- Refresh Button
local refreshButton = Instance.new(""TextButton"")
refreshButton.Name = ""RefreshButton""
refreshButton.Size = UDim2.new(0, 100, 0, 25)
refreshButton.Position = UDim2.new(0, 10, 0, 3)
refreshButton.BackgroundColor3 = Color3.fromRGB(60, 120, 60)
refreshButton.Text = ""Refresh""
refreshButton.TextColor3 = Color3.fromRGB(255, 255, 255)
refreshButton.TextSize = 16
refreshButton.Font = Enum.Font.SourceSansBold
refreshButton.Parent = titleBar

-- Create a UICorner for the refresh button
local refreshCorner = Instance.new(""UICorner"")
refreshCorner.CornerRadius = UDim.new(0, 4)
refreshCorner.Parent = refreshButton

-- Status label (for minimize tooltip)
local statusLabel = Instance.new(""TextLabel"")
statusLabel.Name = ""StatusLabel""
statusLabel.Size = UDim2.new(0, 200, 0, 20)
statusLabel.Position = UDim2.new(0.5, -100, 0, -25)
statusLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
statusLabel.BackgroundTransparency = 0.2
statusLabel.Text = ""Press Left Ctrl to minimize""
statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
statusLabel.TextSize = 14
statusLabel.Font = Enum.Font.SourceSans
statusLabel.Visible = false
statusLabel.Parent = mainFrame

-- Add rounded corners to status label
local statusCorner = Instance.new(""UICorner"")
statusCorner.CornerRadius = UDim.new(0, 4)
statusCorner.Parent = statusLabel

-- Show tooltip when hovering minimize button
minimizeButton.MouseEnter:Connect(function()
    statusLabel.Visible = true
end)

minimizeButton.MouseLeave:Connect(function()
    statusLabel.Visible = false
end)

-- Function declaration for refreshFruitList (will be defined later)
local refreshFruitList

-- Function to create sorted fruit list
local function createSortedFruitList()
    -- Clear existing list
    for _, child in pairs(scrollingFrame:GetChildren()) do
        if child:IsA(""Frame"") then
            child:Destroy()
        end
    end
    
    -- Sort the fruits data based on current sort column and direction
    table.sort(allFruitsData, function(a, b)
        local aValue, bValue
        
        if currentSortColumn == ""Fruit Name"" then
            aValue = a.name:lower()
            bValue = b.name:lower()
            
        elseif currentSortColumn == ""Variant"" then
            -- Sort by variant priority
            aValue = getVariantPriority(a.variant)
            bValue = getVariantPriority(b.variant)
            
        elseif currentSortColumn == ""Mutations"" then
            -- Sort by mutation priority
            aValue = getMutationPriority(a.mutations)
            bValue = getMutationPriority(b.mutations)
            
        elseif currentSortColumn == ""Weight (kg)"" then
            -- Use the raw numeric weight value instead of the string
            aValue = a.weightNum or 0
            bValue = b.weightNum or 0
        else
            return false
        end
        
        if currentSortDir == ""asc"" then
            return aValue < bValue
        else
            return aValue > bValue
        end
    end)
    
    -- Update sort button appearance
    for colName, button in pairs(sortButtons) do
        if colName == currentSortColumn then
            button.Text = currentSortDir == ""asc"" and ""‚ñ≤"" or ""‚ñº""
            button.TextColor3 = Color3.fromRGB(255, 255, 100) -- Highlight active sort
        else
            button.Text = ""‚óÜ""
            button.TextColor3 = Color3.fromRGB(150, 150, 150) -- Dim inactive sorts
        end
    end
    
    -- Remote for collecting fruit
    local PickupEvent = ReplicatedStorage:WaitForChild(""GameEvents""):WaitForChild(""Pickup"")
    
    local rowHeight = 50 -- Increased height for better mutation display
    for i, fruitData in ipairs(allFruitsData) do
        -- Create row frame
        local rowFrame = Instance.new(""Frame"")
        rowFrame.Name = ""Row_"" .. i
        rowFrame.Size = UDim2.new(1, 0, 0, rowHeight)
        rowFrame.Position = UDim2.new(0, 0, 0, (i-1) * rowHeight)
        rowFrame.BackgroundColor3 = i % 2 == 0 and Color3.fromRGB(40, 40, 40) or Color3.fromRGB(35, 35, 35)
        rowFrame.BackgroundTransparency = 0.3
        rowFrame.Parent = scrollingFrame
        
        -- Add hover effect
        rowFrame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                rowFrame.BackgroundTransparency = 0.1
            end
        end)
        
        rowFrame.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                rowFrame.BackgroundTransparency = 0.3
            end
        end)
        
        -- Create columns in the row
        local currentX = 0
        local columnValues = {fruitData.name, fruitData.variant, fruitData.weight, fruitData.mutations}
        
        -- Add collect button
        local collectButton = Instance.new(""TextButton"")
        collectButton.Name = ""CollectButton""
        collectButton.Size = UDim2.new(0, 70, 0, 25)
        collectButton.Position = UDim2.new(1, -75, 0, 12.5) -- Right side of row, centered vertically
        collectButton.BackgroundColor3 = Color3.fromRGB(60, 180, 80) -- Green
        collectButton.Text = ""Collect""
        collectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        collectButton.TextSize = 14
        collectButton.Font = Enum.Font.SourceSansBold
        collectButton.Parent = rowFrame
        
        -- Add rounded corners to collect button
        local collectCorner = Instance.new(""UICorner"")
        collectCorner.CornerRadius = UDim.new(0, 4)
        collectCorner.Parent = collectButton
        
        -- Store the fruit model in the button for reference
        collectButton:SetAttribute(""FruitModel"", fruitData.model:GetFullName())
        
        -- Collect button click handler
        collectButton.MouseButton1Click:Connect(function()
            -- Show collecting status
            local originalText = collectButton.Text
            local originalColor = collectButton.BackgroundColor3
            collectButton.Text = ""...""
            collectButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
            
            -- Fire the remote to collect the fruit
            local success, error = pcall(function()
                if fruitData.model and fruitData.model:IsA(""Model"") then
                    -- Fire the pickup event to collect the fruit
                    PickupEvent:FireServer(fruitData.model)
                    task.wait(0.1) -- Small delay
                    
                    -- Track whether collection was successful
                    local startTime = tick()
                    local collected = false
                    
                    -- Check if fruit still exists after a brief delay
                    task.wait(0.3)
                    if not fruitData.model or not fruitData.model.Parent then
                        -- Successfully collected
                        collectButton.Text = ""‚úì""
                        collectButton.BackgroundColor3 = Color3.fromRGB(40, 180, 40)
                        addToFruitLog(""COLLECTED"", fruitData.name, fruitData.variant, fruitData.weight, fruitData.mutations, fruitData.treeName)
                        
                        -- Disable the button
                        collectButton.AutoButtonColor = false
                        collectButton.Active = false
                    else
                        -- Failed to collect
                        collectButton.Text = ""Retry""
                        collectButton.BackgroundColor3 = Color3.fromRGB(180, 100, 100)
                    end
                else
                    -- Fruit no longer exists
                    collectButton.Text = ""Gone""
                    collectButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
                    collectButton.AutoButtonColor = false
                end
            end)
            
            if not success then
                -- Error occurred
                collectButton.Text = ""Error""
                collectButton.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
                print(""‚ùå Failed to collect fruit:"", error)
                
                -- Reset after delay
                task.delay(1.5, function()
                    collectButton.Text = originalText
                    collectButton.BackgroundColor3 = originalColor
                end)
            end
        end)
        
        -- Add hover effect to collect button
        collectButton.MouseEnter:Connect(function()
            if collectButton.Active ~= false then
                collectButton.BackgroundColor3 = Color3.fromRGB(80, 200, 100)
            end
        end)
        
        collectButton.MouseLeave:Connect(function()
            if collectButton.Active ~= false then
                collectButton.BackgroundColor3 = Color3.fromRGB(60, 180, 80)
            end
        end)
        
        for j, columnValue in ipairs(columnValues) do
            local cell = Instance.new(""TextLabel"")
            cell.Name = ""Column"" .. j
            cell.Size = UDim2.new(columnWidths[j], -10, 1, 0)
            cell.Position = UDim2.new(currentX, 5, 0, 0)
            cell.BackgroundTransparency = 1
            cell.Font = Enum.Font.SourceSans
            cell.TextColor3 = Color3.fromRGB(255, 255, 255)
            cell.Text = tostring(columnValue)
            cell.TextXAlignment = Enum.TextXAlignment.Left
            cell.TextWrapped = true
            cell.TextYAlignment = Enum.TextYAlignment.Top
            
            -- Special handling for mutations column (column 4)
            if j == 4 then
                cell.TextSize = 14 -- Slightly smaller for more text
                cell.Font = Enum.Font.SourceSans
                -- Make sure mutations are fully visible
                if #tostring(columnValue) > 20 then
                    cell.TextScaled = false -- Don't scale down, just wrap
                end
                
                -- Make room for collect button
                cell.Size = UDim2.new(columnWidths[j] - 0.15, -10, 1, 0)
            else
                cell.TextSize = 16
                cell.TextYAlignment = Enum.TextYAlignment.Center
            end
            
            cell.Parent = rowFrame
            
            currentX = currentX + columnWidths[j]
        end
    end
    
    -- Update scrolling frame content size
    scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, #allFruitsData * rowHeight)
    
    -- Update counter
    titleText.Text = ""Farm Fruit List - "" .. #allFruitsData .. "" Fruits""
end

-- Column Headers
local currentX = 0
for i, columnName in ipairs(columns) do
    local headerContainer = Instance.new(""Frame"")
    headerContainer.Name = columnName:gsub("" "", """") .. ""HeaderContainer""
    headerContainer.Size = UDim2.new(columnWidths[i], 0, 1, 0)
    headerContainer.Position = UDim2.new(currentX, 0, 0, 0)
    headerContainer.BackgroundTransparency = 1
    headerContainer.Parent = headerFrame
    
    local columnHeader = Instance.new(""TextLabel"")
    columnHeader.Name = columnName:gsub("" "", """") .. ""Header""
    columnHeader.Size = UDim2.new(1, -25, 1, 0) -- Make room for sort button
    columnHeader.Position = UDim2.new(0, 5, 0, 0)
    columnHeader.BackgroundTransparency = 1
    columnHeader.Font = Enum.Font.SourceSansBold
    columnHeader.TextColor3 = Color3.fromRGB(255, 255, 255)
    columnHeader.TextSize = 18
    columnHeader.Text = columnName
    columnHeader.TextXAlignment = Enum.TextXAlignment.Left
    columnHeader.Parent = headerContainer
    
    -- Add sort button
    local sortButton = Instance.new(""TextButton"")
    sortButton.Name = ""SortButton""
    sortButton.Size = UDim2.new(0, 20, 0, 20)
    sortButton.Position = UDim2.new(1, -25, 0.5, -10)
    sortButton.BackgroundTransparency = 0.8
    sortButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    sortButton.Text = columnName == currentSortColumn and ""‚ñ≤"" or ""‚óÜ"" -- Triangle up for current sort, diamond for others
    sortButton.TextColor3 = columnName == currentSortColumn 
                         and Color3.fromRGB(255, 255, 100) 
                         or Color3.fromRGB(150, 150, 150)
    sortButton.TextSize = 14
    sortButton.Font = Enum.Font.SourceSansBold
    sortButton.Parent = headerContainer
    
    -- Add rounded corners to sort button
    local sortCorner = Instance.new(""UICorner"")
    sortCorner.CornerRadius = UDim.new(0, 4)
    sortCorner.Parent = sortButton
    
    -- Store the sort button for later reference
    sortButtons[columnName] = sortButton
    
    -- Sort button click handler
    sortButton.MouseButton1Click:Connect(function()
        if currentSortColumn == columnName then
            -- Toggle direction if same column
            currentSortDir = currentSortDir == ""asc"" and ""desc"" or ""asc""
        else
            -- New column, default directions
            currentSortColumn = columnName
            
            -- Special case: weight should default to descending (high to low)
            if columnName == ""Weight (kg)"" then
                currentSortDir = ""desc""
            else
                -- Variant and mutation have special logic so desc is actually ""best first""
                if columnName == ""Variant"" or columnName == ""Mutations"" then
                    currentSortDir = ""desc"" -- Rainbow/Multiple mutations first
                else
                    currentSortDir = ""asc"" -- A-Z for regular text
                end
            end
        end
        
        createSortedFruitList()
    end)
    
    -- Add hover effect to sort button
    sortButton.MouseEnter:Connect(function()
        sortButton.BackgroundTransparency = 0.5
    end)
    
    sortButton.MouseLeave:Connect(function()
        sortButton.BackgroundTransparency = 0.8
    end)
    
    currentX = currentX + columnWidths[i]
end

-- Function to refresh the fruit list
refreshFruitList = function()
    -- Clear all fruit data
    allFruitsData = {}
    
    -- Get player farm
    local farm = GetFarm(player)
    if not farm or not farm:FindFirstChild(""Important"") or not farm.Important:FindFirstChild(""Plants_Physical"") then
        local errorLabel = Instance.new(""TextLabel"")
        errorLabel.Size = UDim2.new(1, 0, 0, 30)
        errorLabel.Position = UDim2.new(0, 0, 0, 0)
        errorLabel.BackgroundTransparency = 1
        errorLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        errorLabel.Text = ""Farm not found!""
        errorLabel.Font = Enum.Font.SourceSansSemibold
        errorLabel.TextSize = 18
        errorLabel.Parent = scrollingFrame
        return
    end
    
    local plantsPhysical = farm.Important.Plants_Physical
    
    -- Loop through all tree types
    for _, treeType in pairs(plantsPhysical:GetChildren()) do
        local fruitsFolder = treeType:FindFirstChild(""Fruits"")
        if fruitsFolder then
            for _, fruitModel in pairs(fruitsFolder:GetChildren()) do
                if fruitModel:IsA(""Model"") then
                    -- Get fruit attributes and properties
                    local fruitName = fruitModel.Name
                    
                    -- Get variant (typically stored as a child)
                    local variant = fruitModel:FindFirstChild(""Variant"")
                    local variantText = variant and variant.Value or ""Normal""
                    
                    -- Get weight
                    local weight = fruitModel:FindFirstChild(""Weight"")
                    local weightNum = weight and weight.Value or 0
                    local weightValue = weight and string.format(""%.2f kg"", weightNum) or ""? kg""
                    
                    -- Get mutations from attributes (using MutationHandler if available)
                    local mutations = """"
                    local success, mutationString = pcall(function()
                        return MutationHandler:GetMutationsAsString(fruitModel) or """"
                    end)
                    
                    if not success or mutationString == """" then
                        -- Try checking attributes directly
                        local mutationList = {}
                        for attrName, value in pairs(fruitModel:GetAttributes()) do
                            if value == true and typeof(value) == ""boolean"" then
                                -- Check only known mutation attributes
                                if attrName == ""Shocked"" or
                                   attrName == ""Frozen"" or 
                                   attrName == ""Wet"" or
                                   attrName == ""Chilled"" or
                                   attrName == ""Twisted"" or
                                   attrName == ""Choc"" or
                                   attrName == ""Burnt"" or
                                   attrName == ""Moonlit"" then
                                    
                                    table.insert(mutationList, attrName)
                                end
                            end
                        end
                        
                        if #mutationList > 0 then
                            -- Sort mutations for consistent display
                            table.sort(mutationList)
                            mutations = table.concat(mutationList, "" ‚Ä¢ "") -- Use bullet separator for better readability
                        else
                            mutations = ""None""
                        end
                    else
                        -- Format the mutation string for better readability
                        if mutationString ~= """" then
                            -- Replace commas with bullet points for better visual separation
                            mutations = mutationString:gsub("", "", "" ‚Ä¢ "")
                        else
                            mutations = ""None""
                        end
                    end

                    -- Store fruit data for sorting
                    table.insert(allFruitsData, {
                        name = fruitName,
                        variant = variantText,
                        mutations = mutations,
                        weight = weightValue,
                        weightNum = weightNum, -- Store raw number for sorting
                        model = fruitModel,
                        treeName = treeType.Name
                    })
                end
            end
        end
    end
    
    -- Display sorted fruit list
    createSortedFruitList()
end

-- Connect the refresh button
refreshButton.MouseButton1Click:Connect(refreshFruitList)

-- Handle refresh on unhide
minimizeButton.MouseButton1Click:Connect(function()
    if isMinimized then
        -- Will refresh data when un-minimizing
        task.delay(0.1, function()
            refreshFruitList()
        end)
    end
end)

-- ‚úÖ FRUIT LOG FUNCTIONS
local function addToFruitLog(action, fruitName, variant, weight, mutations, treeName)
    local timestamp = os.date(""%H:%M:%S"")
    
    local logEntry = {
        time = timestamp,
        action = action, -- ""SPAWNED"" or ""DELETED""
        fruit = fruitName or ""Unknown"",
        variant = variant or ""Normal"",
        weight = weight or ""Unknown"",
        mutations = mutations or ""None"",
        tree = treeName or ""Unknown""
    }
    
    table.insert(fruitLog, 1, logEntry) -- Add to beginning
    
    -- Keep only last entries
    if #fruitLog > maxLogEntries then
        table.remove(fruitLog, maxLogEntries + 1)
    end
    
    local actionEmoji = action == ""SPAWNED"" and ""üåü"" or ""üóëÔ∏è""
    local mutText = mutations ~= ""None"" and "" ("" .. mutations .. "")"" or """"
    print(string.format(""%s [%s] %s: %s - %s %s%s on %s"", actionEmoji, timestamp, action, fruitName, weight, variant, mutText, treeName))
    
    -- Update log GUI if exists
    if logGui then
        updateFruitLogDisplay()
    end
end

-- ‚úÖ MONITOR FRUIT CHANGES
local function checkFruitChanges()
    local currentFruits = {}
    
    -- Get current fruits on farm
    local farm = GetFarm(player)
    if farm and farm:FindFirstChild(""Important"") and farm.Important:FindFirstChild(""Plants_Physical"") then
        local plantsPhysical = farm.Important.Plants_Physical
        
        -- Loop through all tree types
        for _, treeType in pairs(plantsPhysical:GetChildren()) do
            if treeType:IsA(""Folder"") or treeType:IsA(""Model"") then
                -- Check for Fruits folder in each tree type
                local fruitsFolder = treeType:FindFirstChild(""Fruits"")
                if fruitsFolder then
                    for _, fruitModel in pairs(fruitsFolder:GetChildren()) do
                        if fruitModel:IsA(""Model"") and fruitModel.Name ~= ""Fruits"" then
                            -- Use a more reliable unique identifier
                            local fruitId = treeType.Name .. ""_"" .. fruitModel.Name .. ""_"" .. tostring(fruitModel)
                            
                            -- Get fruit data
                            local fruitName = fruitModel.Name
                            local variant = fruitModel:FindFirstChild(""Variant"")
                            local variantText = variant and variant.Value or ""Normal""
                            local weight = fruitModel:FindFirstChild(""Weight"")
                            local weightValue = weight and string.format(""%.2f kg"", weight.Value) or ""? kg""
                            
                            -- Get mutations using same method as main GUI
                            local mutations = ""None""
                            local success, mutationString = pcall(function()
                                return MutationHandler:GetMutationsAsString(fruitModel) or """"
                            end)
                            
                            if success and mutationString ~= """" then
                                mutations = mutationString:gsub("", "", "" ‚Ä¢ "")
                            else
                                -- Check attributes directly
                                local mutationList = {}
                                for attrName, value in pairs(fruitModel:GetAttributes()) do
                                    if value == true and typeof(value) == ""boolean"" then
                                        if attrName == ""Shocked"" or attrName == ""Frozen"" or 
                                           attrName == ""Wet"" or attrName == ""Chilled"" or
                                           attrName == ""Twisted"" or attrName == ""Choc"" or
                                           attrName == ""Burnt"" or attrName == ""Moonlit"" then
                                            table.insert(mutationList, attrName)
                                        end
                                    end
                                end
                                
                                if #mutationList > 0 then
                                    table.sort(mutationList)
                                    mutations = table.concat(mutationList, "" ‚Ä¢ "")
                                end
                            end
                            
                            currentFruits[fruitId] = {
                                name = fruitName,
                                variant = variantText,
                                weight = weightValue,
                                mutations = mutations,
                                tree = treeType.Name
                            }
                        end
                    end
                end
            end
        end
    end
    
    -- Compare with last known fruits to detect changes
    
    -- Check for new fruits (spawned)
    for fruitId, fruitData in pairs(currentFruits) do
        if not lastKnownFruits[fruitId] then
            addToFruitLog(""SPAWNED"", fruitData.name, fruitData.variant, fruitData.weight, fruitData.mutations, fruitData.tree)
        end
    end
    
    -- Check for deleted fruits
    for fruitId, fruitData in pairs(lastKnownFruits) do
        if not currentFruits[fruitId] then
            addToFruitLog(""DELETED"", fruitData.name, fruitData.variant, fruitData.weight, fruitData.mutations, fruitData.tree)
        end
    end
    
    -- Update known fruits
    lastKnownFruits = currentFruits
end

-- ‚úÖ FRUIT LOG GUI
local function createFruitLogGui()
    local playerGui = player:WaitForChild(""PlayerGui"")
    
    -- Remove existing log GUI
    if logGui then
        logGui:Destroy()
    end
    
    local screenGui = Instance.new(""ScreenGui"")
    screenGui.Name = ""FruitLogGui""
    screenGui.ResetOnSpawn = false
    screenGui.Parent = playerGui
    
    local frame = Instance.new(""Frame"")
    frame.Size = UDim2.new(0, 600, 0, 400)
    frame.Position = UDim2.new(0.5, -300, 0.5, -200)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BackgroundTransparency = 0.1
    frame.Parent = screenGui
    frame.Active = true
    
    -- Add rounded corners
    local frameCorner = Instance.new(""UICorner"")
    frameCorner.CornerRadius = UDim.new(0, 8)
    frameCorner.Parent = frame
    
    -- Title bar
    local titleBar = Instance.new(""Frame"")
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = frame
    
    local titleCorner = Instance.new(""UICorner"")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = titleBar
    
    -- Bottom frame for title bar
    local bottomFrame = Instance.new(""Frame"")
    bottomFrame.Size = UDim2.new(1, 0, 0.5, 0)
    bottomFrame.Position = UDim2.new(0, 0, 0.5, 0)
    bottomFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    bottomFrame.BorderSizePixel = 0
    bottomFrame.Parent = titleBar
    
    local titleText = Instance.new(""TextLabel"")
    titleText.Size = UDim2.new(1, -60, 1, 0)
    titleText.BackgroundTransparency = 1
    titleText.Text = ""üçé Fruit Spawn/Delete Log""
    titleText.Font = Enum.Font.SourceSansBold
    titleText.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleText.TextSize = 18
    titleText.Parent = titleBar
    
    -- Close button
    local closeButton = Instance.new(""TextButton"")
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -30, 0, 0)
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
    closeButton.Text = ""X""
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 18
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Parent = titleBar
    
    local closeCorner = Instance.new(""UICorner"")
    closeCorner.CornerRadius = UDim.new(0, 6)
    closeCorner.Parent = closeButton
    
    closeButton.MouseButton1Click:Connect(function()
        screenGui:Destroy()
        logGui = nil
    end)
    
    -- Clear button
    local clearButton = Instance.new(""TextButton"")
    clearButton.Size = UDim2.new(0, 80, 0, 25)
    clearButton.Position = UDim2.new(0, 10, 0, 40)
    clearButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    clearButton.Text = ""Clear Log""
    clearButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    clearButton.TextSize = 12
    clearButton.Font = Enum.Font.SourceSans
    clearButton.Parent = frame
    
    local clearCorner = Instance.new(""UICorner"")
    clearCorner.CornerRadius = UDim.new(0, 4)
    clearCorner.Parent = clearButton
    
    clearButton.MouseButton1Click:Connect(function()
        fruitLog = {}
        updateFruitLogDisplay()
    end)
    
    -- Scroll frame
    local scrollFrame = Instance.new(""ScrollingFrame"")
    scrollFrame.Name = ""LogScrollFrame""
    scrollFrame.Size = UDim2.new(1, -20, 1, -75)
    scrollFrame.Position = UDim2.new(0, 10, 0, 70)
    scrollFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    scrollFrame.BackgroundTransparency = 0.2
    scrollFrame.ScrollBarThickness = 8
    scrollFrame.Parent = frame
    
    local scrollCorner = Instance.new(""UICorner"")
    scrollCorner.CornerRadius = UDim.new(0, 6)
    scrollCorner.Parent = scrollFrame
    
    logGui = screenGui
    return screenGui
end

-- ‚úÖ UPDATE LOG DISPLAY
function updateFruitLogDisplay()
    if not logGui then return end
    
    local success, err = pcall(function()
        local scrollFrame = logGui.FruitLogGui.LogScrollFrame
        
        -- Clear existing entries
        for _, child in ipairs(scrollFrame:GetChildren()) do
            if child:IsA(""Frame"") then
                child:Destroy()
            end
        end
        
        -- Update title with count
        local titleLabel = logGui.FruitLogGui.Frame.Frame.TextLabel
        if titleLabel then
            titleLabel.Text = ""üçé Fruit Log ("" .. #fruitLog .. "" entries)""
        end
        
        -- Add log entries
        local yOffset = 0
        for i, entry in ipairs(fruitLog) do
            local entryFrame = Instance.new(""Frame"")
            entryFrame.Size = UDim2.new(1, -10, 0, 30)
            entryFrame.Position = UDim2.new(0, 5, 0, yOffset)
            entryFrame.BackgroundColor3 = entry.action == ""SPAWNED"" 
                                         and Color3.fromRGB(40, 60, 40) 
                                         or Color3.fromRGB(60, 40, 40)
            entryFrame.BackgroundTransparency = 0.3
            entryFrame.Parent = scrollFrame
            
            local entryCorner = Instance.new(""UICorner"")
            entryCorner.CornerRadius = UDim.new(0, 4)
            entryCorner.Parent = entryFrame
            
            local entryLabel = Instance.new(""TextLabel"")
            entryLabel.Size = UDim2.new(1, -10, 1, 0)
            entryLabel.Position = UDim2.new(0, 5, 0, 0)
            entryLabel.BackgroundTransparency = 1
            entryLabel.Font = Enum.Font.SourceSans
            entryLabel.TextSize = 11
            entryLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            entryLabel.TextXAlignment = Enum.TextXAlignment.Left
            entryLabel.TextYAlignment = Enum.TextYAlignment.Center
            entryLabel.TextWrapped = true
            
            local actionEmoji = entry.action == ""SPAWNED"" and ""üåü"" or ""üóëÔ∏è""
            local mutText = entry.mutations ~= ""None"" and "" ("" .. entry.mutations .. "")"" or """"
            
            entryLabel.Text = string.format(""%s [%s] %s: %s - %s %s%s on %s"", 
                actionEmoji, entry.time, entry.action, entry.fruit, entry.weight, entry.variant, mutText, entry.tree)
            
            entryLabel.Parent = entryFrame
            yOffset = yOffset + 35
        end
        
        scrollFrame.CanvasSize = UDim2.new(0, 0, 0, yOffset)
        
        -- Auto-scroll to bottom to see latest entries
        scrollFrame.CanvasPosition = Vector2.new(0, math.max(0, yOffset - scrollFrame.AbsoluteSize.Y))
    end)
    
    if not success then
        print(""‚ùå Error updating fruit log display:"", err)
    end
end

-- ‚úÖ LOG BUTTON (Position next to refresh button)
local logButton = Instance.new(""TextButton"")
logButton.Name = ""LogButton""
logButton.Size = UDim2.new(0, 80, 0, 25)
logButton.Position = UDim2.new(0, 115, 0, 3) -- Next to refresh button
logButton.BackgroundColor3 = Color3.fromRGB(60, 120, 60)
logButton.Text = ""üçé Log""
logButton.TextColor3 = Color3.fromRGB(255, 255, 255)
logButton.TextSize = 14
logButton.Font = Enum.Font.SourceSansBold
logButton.Parent = titleBar

local logCorner = Instance.new(""UICorner"")
logCorner.CornerRadius = UDim.new(0, 4)
logCorner.Parent = logButton

logButton.MouseButton1Click:Connect(function()
    if not logGui then
        createFruitLogGui()
        updateFruitLogDisplay()
    else
        logGui:Destroy()
        logGui = nil
    end
end)

-- ‚úÖ START FRUIT MONITORING
spawn(function()
    -- Initial setup - populate known fruits to avoid spam on first run
    task.wait(3) -- Wait for GUI to load
    pcall(checkFruitChanges) -- First scan to populate baseline
    
    print(""üçé Fruit monitoring started!"")
    
    while true do
        task.wait(3) -- Check every 3 seconds
        local success, error = pcall(checkFruitChanges)
        if not success then
            print(""‚ùå Fruit monitoring error:"", error)
        end
    end
end)

-- Initial refresh
refreshFruitList()"
6jb1EHcq,Untitled,ignacy123,Java,Tuesday 1st of July 2025 07:26:23 AM CDT,"PociƒÖg ze stacji Gdynia G≈Ç√≥wna do stacji Krak√≥w G≈Ç√≥wny przez stacje Tczew, Bydgoszcz G≈Ç√≥wna, ≈Å√≥d≈∫ Widzew odjedzie z toru pierwszego przy peronie drugim.
PociƒÖg ko≈Ñczy bieg na stacji Wroc≈Çaw G≈Ç√≥wny.
PociƒÖg do stacji Lublin G≈Ç√≥wny przez stacje Dƒôblin, Pu≈Çawy Miasto, Na≈Çƒôcz√≥w odjedzie z toru czwartego przy peronie trzecim.
PociƒÖg ze stacji Bia≈Çystok do stacji Katowice przez stacje Warszawa Wschodnia, Czƒôstochowa Stradom odjedzie z toru drugiego przy peronie piƒÖtym.
PociƒÖg do stacji Szczecin G≈Ç√≥wny przez stacje Stargard, Gorz√≥w Wielkopolski, Kostrzyn odjedzie z toru trzeciego przy peronie pierwszym."
cZfrY6fB,Untitled,Josif_tepe,C++,Tuesday 1st of July 2025 06:57:37 AM CDT,"#include <stdio.h>

int main() {

    int a, b;
    scanf(""%d%d"", &a, &b);
    
    if(a == b) {
        printf(""EDNAKVI\n"");
    }
    
    if(a != b) {
        printf(""RAZLICNI\n"");
    }
    return 0;
}
"
bRjSTZuL,Untitled,Brusnik,Python,Tuesday 1st of July 2025 06:54:09 AM CDT,"# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ1

x = int(input())
while (x % 2 != 0) and (x%10 != 5):
    x = int(input())


# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ2

for i in range(10):
    print(i)


# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ3

K = int(input())
N = int(input())
i = K
summ = 0

while(i <= N):
    if i % 2 == 1:
        summ += i
    i += 1

print(summ)


# –ó–∞–¥–∞–Ω–∏–µ ‚Ññ4

N = int(input())
i = N
fact = 1

while(i):
    fact *= i
    i -= 1

print(fact)"
EnzkJ897,Untitled,Josif_tepe,C,Tuesday 1st of July 2025 06:52:13 AM CDT,"#include <stdio.h>

int main() {

    int a, b;
    scanf(""%d%d"", &a, &b);
    
    if(a < b) {
        printf(""PRVIOT E POMAL OD VTORIOT\n"");
    }
    return 0;
}
"
Fgvbi5Nh,1 –∑–∞—á–µ–º –Ω—É–∂–µ–Ω –∞–º–ø–µ—Ä—Å–∞–Ω–¥ –≤ scanf,RobertDeMilo,C++,Tuesday 1st of July 2025 06:42:32 AM CDT,"–í C —è–∑—ã–∫–µ —Å–∏–º–≤–æ–ª –∞–º–ø–µ—Ä—Å–∞–Ω–¥–∞ (&) –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–¥—Ä–µ—Å–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, —Ç–∞–∫ –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏—è scanf –æ–∂–∏–¥–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª–∏ (–∞–¥—Ä–µ—Å–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö), –∫—É–¥–∞ –Ω—É–∂–Ω–æ –∑–∞–ø–∏—Å–∞—Ç—å —Å—á–∏—Ç–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.

–ü–µ—Ä–≤—ã–π —Å–ª—É—á–∞–π:
int n = 0;
scanf(""%d"", &n);  // &n ‚Äî –ø–µ—Ä–µ–¥–∞—ë–º –∞–¥—Ä–µ—Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π n

–ó–¥–µ—Å—å n ‚Äî –æ–±—ã—á–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–∏–ø–∞ int, –ø–æ—ç—Ç–æ–º—É —á—Ç–æ–±—ã scanf –º–æ–≥ –∑–∞–ø–∏—Å–∞—Ç—å –≤ –Ω–µ—ë –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –µ—ë –∞–¥—Ä–µ—Å —Å –ø–æ–º–æ—â—å—é &.

–í—Ç–æ—Ä–æ–π —Å–ª—É—á–∞–π:
int input(int* a, int* n) {
    // ...
    for (int* p = a; p - a < *n; p++) {
        if (scanf(""%d"", p) != 1) {  // p ‚Äî —É–∂–µ —É–∫–∞–∑–∞—Ç–µ–ª—å, & –Ω–µ –Ω—É–∂–µ–Ω
            return 0;
        }
    }
    // ...
}
–ó–¥–µ—Å—å p ‚Äî —ç—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—å (—Ç–∏–ø int*), –∫–æ—Ç–æ—Ä—ã–π –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –Ω–∞—á–∞–ª–æ –º–∞—Å—Å–∏–≤–∞ a –∏ –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –ø–æ –Ω–µ–º—É (p++).
–ü–æ—Å–∫–æ–ª—å–∫—É p —É–∂–µ —Ö—Ä–∞–Ω–∏—Ç –∞–¥—Ä–µ—Å —è—á–µ–π–∫–∏ –º–∞—Å—Å–∏–≤–∞, –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å &p –Ω–µ –Ω—É–∂–Ω–æ ‚Äî —ç—Ç–æ –ø—Ä–∏–≤–µ–ª–æ –±—ã –∫ –ø–µ—Ä–µ–¥–∞—á–µ –∞–¥—Ä–µ—Å–∞ —Å–∞–º–æ–≥–æ —É–∫–∞–∑–∞—Ç–µ–ª—è, –∞ –Ω–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞.

–ü–æ—á–µ–º—É –≤–æ –≤—Ç–æ—Ä–æ–º —Å–ª—É—á–∞–µ p –Ω–µ —Ç—Ä–µ–±—É–µ—Ç &?
p –æ–±—ä—è–≤–ª–µ–Ω –∫–∞–∫ int* p = a, —Ç–æ –µ—Å—Ç—å —ç—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ int.

–ü—Ä–∏ –∏—Ç–µ—Ä–∞—Ü–∏–∏ p++ –æ–Ω –ø–µ—Ä–µ–º–µ—â–∞–µ—Ç—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞.



!!!!!!!!!!scanf(""%d"", p) –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä—è–º–æ –≤ —Ç—É —è—á–µ–π–∫—É –ø–∞–º—è—Ç–∏, –Ω–∞ –∫–æ—Ç–æ—Ä—É—é —É–∫–∞–∑—ã–≤–∞–µ—Ç p.



–ï—Å–ª–∏ –±—ã –º—ã –Ω–∞–ø–∏—Å–∞–ª–∏ scanf(""%d"", &p), —Ç–æ:

&p ‚Äî —ç—Ç–æ –∞–¥—Ä–µ—Å —Å–∞–º–æ–≥–æ —É–∫–∞–∑–∞—Ç–µ–ª—è (—Ç–∏–ø int**), –∞ –Ω–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞.

–≠—Ç–æ –ø—Ä–∏–≤–µ–ª–æ –±—ã –∫ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–º—É –ø–æ–≤–µ–¥–µ–Ω–∏—é, —Ç–∞–∫ –∫–∞–∫ scanf –ø–æ–ø—ã—Ç–∞–ª—Å—è –±—ã –∑–∞–ø–∏—Å–∞—Ç—å int –ø–æ –∞–¥—Ä–µ—Å—É —É–∫–∞–∑–∞—Ç–µ–ª—è, –∞ –Ω–µ –≤ —Å–∞–º –º–∞—Å—Å–∏–≤.

–í—ã–≤–æ–¥:
–ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–±—ã—á–Ω–∞—è (–Ω–µ —É–∫–∞–∑–∞—Ç–µ–ª—å) ‚Üí –Ω—É–∂–µ–Ω & –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –∞–¥—Ä–µ—Å–∞.

–ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è —É–∫–∞–∑–∞—Ç–µ–ª–µ–º ‚Üí & –Ω–µ –Ω—É–∂–µ–Ω, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –∏ —Ç–∞–∫ —Ö—Ä–∞–Ω–∏—Ç –∞–¥—Ä–µ—Å.

"
7e7Xb3Cq,Untitled,Josif_tepe,C,Tuesday 1st of July 2025 06:38:45 AM CDT,"#include <stdio.h>

int main() {

    int a, b, c;
    scanf(""%d%d%d"", &a, &b, &c);
    
    int zbir = a + c;
    int proizvod = b * c;
    
    printf(""Zbirot e %d\n"", zbir);
    printf(""Proizvodot e %d\n"", proizvod);
    return 0;
}
"
r5WR2beJ,Untitled,Josif_tepe,C,Tuesday 1st of July 2025 06:33:56 AM CDT,"#include <stdio.h>

int main() {

    int x, y;
    scanf(""%d%d"", &x, &y);
    
    int zbir = x + y;
    printf(""%d\n"", zbir);
    
    return 0;
}
"
t4k77a6X,Untitled,Josif_tepe,C++,Tuesday 1st of July 2025 06:27:51 AM CDT,"#include <stdio.h>

int main() {

    int x;
    scanf(""%d"", &x);
    
    printf(""%d\n"", x);
    
    
    return 0;
}
"
eMgnN6Uu,Untitled,Josif_tepe,C,Tuesday 1st of July 2025 06:20:55 AM CDT,"#include <stdio.h>

int main() {

    printf(""Zdravo!\n"");
    
    
    return 0;
}
"
CZXqR1ip,dataNone,TestGuy1,JSON,Tuesday 1st of July 2025 06:00:10 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'cbd37236924ad06eb41ca6d237c112a5339e8b8225b8e79b4ba5a034e60b4856b042f22693a57d1ec70cda75096b90019318373d45f5067570717ead56dd8ff6890d3137e6c60f04d17b0d61509692da5276d28da08ab17f228367f36db6e8406a85baca387a8070a72e26169a14d6fb5d98e1f3cc0e76786895e06af06ee440',
  otherdata: [
    '924e22ef3db5f8c819daf60b2fa32ff4',
    'fca85e60552f96e84b85bb5a18bdd5cf',
    '50bf76d8f6c2f64c59cf07d86398cfb6',
    '5a29e62bd057b4cf21d33923c93a258f',
    'f80f41965f1bb9f3217bf13ca5c77283',
    'c7654b9d761924c76c2809bbeb6f43b5',
    'b9f3389818b4075bf5195b0e33ce86d0',
    'befbc483648105a57567c4c3f3c6a846'
  ]
}"
DH7TYbkk,arseni231423's Anti Script Kid (Skid),arseni231422,Lua,Tuesday 1st of July 2025 05:57:30 AM CDT,require(110155818485783).AntiSkid()
ESUTnw71,OOP Theory,Zoddster,Java,Tuesday 1st of July 2025 05:07:01 AM CDT,"import java.util.*;

interface PaymentMethod {
    void processPayment(double amount);
}

class WalletPayment implements PaymentMethod {
    public void processPayment(double amount) {
        System.out.println(""Rs. "" + amount + "" paid via Wallet."");
    }
}

class CardPayment implements PaymentMethod {
    public void processPayment(double amount) {
        System.out.println(""Rs. "" + amount + ""paid via Card."");
    }
}

class CashPayment implements PaymentMethod {
    public void processPayment(double amount) {
        System.out.println(""Rs. "" + amount + "" paid via Cash-on-Delivery."");
    }
}

abstract class User {
    protected String name;
    protected String email;
    protected String password;

    public User(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }
    public String getName() {
        return name;
    }
    public String getEmail() {
        return email;
    }
}

class Customer extends User {
    public Customer(String name, String email, String password) {
        super(name, email, password);
    }

    public void placeOrder() {
        System.out.println(name + "" placed an order."");
    }
}

class DeliveryAgent extends User {
    private static int count = 0;
    private Vehicle vehicle;

    public DeliveryAgent(String name, String email, String password, Vehicle vehicle) {
        super(name, email, password);
        this.vehicle = vehicle;
        count++;
    }

    public static int agentCount() {
        return count;
    }

    public Vehicle getVehicle() {
        return vehicle;
    }
}

abstract class Vehicle {
    protected String type;

    public String getType() {
        return type;
    }
}

class Scooter extends Vehicle {
    public Scooter() {
        this.type = ""Scooter"";
    }
}

class Bicycle extends Vehicle {
    public Bicycle() {
        this.type = ""Bicycle"";
    }
}

class FoodItem {
    private String itemName;
    private double price;
    private String category;

    public FoodItem(String itemName, double price, String category) {
        this.itemName = itemName;
        this.price = price;
        this.category = category;
    }

    public String getItemName() {
        return itemName;
    }
    public double getPrice() {
        return price;
    }
    public String getCategory() {
        return category;
    }
}

class Order {
    private List<FoodItem> foodItems;
    private Customer customer;
    private DeliveryAgent deliveryAgent;
    private Date orderTime;
    private double totalAmount;
    private String deliveryAddress;

    public Order(List<FoodItem> foodItems, Customer customer, DeliveryAgent deliveryAgent, String deliveryAddress) {
        this.foodItems = foodItems;
        this.customer = customer;
        this.deliveryAgent = deliveryAgent;
        this.deliveryAddress = deliveryAddress;
        this.orderTime = new Date();
        calculatePrice();
    }

    public void calculatePrice() {
        totalAmount = 0;
        for (FoodItem item : foodItems) {
            totalAmount += item.getPrice();
        }
    }

    public double getTotalAmount() {
        return totalAmount;
    }

    public void printSummary() {
        System.out.println(""Customer: "" + customer.getName());
        System.out.println(""Delivery Rider: "" + deliveryAgent.getName() + "" ("" + deliveryAgent.getVehicle().getType() + "")"");
        System.out.println(""Address: "" + deliveryAddress);
        System.out.println(""Time: "" + orderTime);
        System.out.println(""\n"");
        for (FoodItem item : foodItems) {
            System.out.println(""- "" + item.getItemName() + "" ("" + item.getCategory() + "") Rs. "" + item.getPrice());
        }
        System.out.println(""Total Amount: Rs. "" + totalAmount);
    }
}

interface OrderService {
    void placeOrder();
    void cancelOrder();
    void completeOrder();
}

class OrderManager implements OrderService {
    private List<Order> orderList = new ArrayList<>();

    public void addOrder(Order order) {
        orderList.add(order);
        placeOrder();
    }

    public void placeOrder() {
        System.out.println(""Order placed."");
    }

    public void cancelOrder() {
        System.out.println(""Order cancelled."");
    }

    public void completeOrder() {
        System.out.println(""Order delivered."");
    }
}

public class FoodDeliverySystem {
    public static void main(String[] args) {

        Customer customer = new Customer(""LightYagami"", ""NewWorld@hotmail.com"", ""Note666"");
        DeliveryAgent agent = new DeliveryAgent(""Saim"", ""saimfahad@gmail.com"", ""Zodd"", new Scooter());

        List<FoodItem> items = new ArrayList<>();
        items.add(new FoodItem(""Cheese Burger"", 350, ""Fast-Food""));
        items.add(new FoodItem(""Mayo Fries"", 150, ""Side""));

        Order order = new Order(items, customer, agent, ""Street 69-C, Hyderabad"");
        order.printSummary();

        PaymentMethod payment = new CardPayment();
        payment.processPayment(order.getTotalAmount());

        OrderManager manager = new OrderManager();
        manager.addOrder(order);
        manager.completeOrder();
    }
}
"
PTbmSBaK,Dumps,LVL23HT,CSS,Tuesday 1st of July 2025 05:00:26 AM CDT,kksldke
WNsNSq6J,temp add jnews faq on wpbakery,arie_cristianD,PHP,Tuesday 1st of July 2025 04:32:16 AM CDT,"add_action(
	'vc_before_init',
	function () {
		vc_map(
			array(
				'name'     => esc_html__( 'JNews FAQ', 'jnews' ),
				'base'     => 'custom_jnews_faq',
				'category' => esc_html__( 'JNews', 'jnews' ),
				'icon'     => 'vc_icon-vc-accordion',
				'params'   => array(
					array(
						'type'        => 'param_group',
						'heading'     => esc_html__( 'FAQ Lists', 'jnews' ),
						'param_name'  => 'faqLists',
						'description' => esc_html__( ""List of FAQ item's."", 'jnews' ),
						'params'      => array(
							array(
								'type'        => 'textarea',
								'heading'     => esc_html__( 'Question', 'jnews' ),
								'param_name'  => 'question',
								'description' => esc_html__( 'Insert your FAQ Question.', 'jnews' ),
							),
							array(
								'type'        => 'textarea_html',
								'heading'     => esc_html__( 'Answer', 'jnews' ),
								'param_name'  => 'answer',
								'description' => esc_html__( 'Insert your FAQ Answer.', 'jnews' ),
							),
						),
						'value'       => urlencode(
							json_encode(
								array(
									array(
										'question' => 'Lorem ipsum dolor sit amet',
										'answer'   => 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit...',
									),
									array(
										'question' => 'Far far away, behind the word mountains',
										'answer'   => 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit...',
									),
									array(
										'question' => 'The quick, brown fox jumps over a lazy dog',
										'answer'   => 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit...',
									),
								)
							)
						),
					),
					array(
						'type'        => 'checkbox',
						'heading'     => esc_html__( 'Hide on Frontend', 'jnews' ),
						'param_name'  => 'hideFrontend',
						'description' => esc_html__( 'Enable this option if you only want to display this FAQ on FAQs Page Schema.', 'jnews' ),
					),
					array(
						'type'        => 'dropdown',
						'heading'     => esc_html__( 'Style', 'jnews' ),
						'param_name'  => 'faqStyle',
						'value'       => array(
							esc_html__( 'Style 1', 'jnews' ) => 'style-1',
							esc_html__( 'Style 2', 'jnews' ) => 'style-2',
							esc_html__( 'Style 3', 'jnews' ) => 'style-3',
							esc_html__( 'Style 4', 'jnews' ) => 'style-4',
							esc_html__( 'Style 5', 'jnews' ) => 'style-5',
						),
						'description' => esc_html__( 'Choose your FAQ style.', 'jnews' ),
					),
					array(
						'type'       => 'colorpicker',
						'heading'    => esc_html__( 'Question Color', 'jnews' ),
						'param_name' => 'questionColor',
					),
					array(
						'type'       => 'colorpicker',
						'heading'    => esc_html__( 'Answer Color', 'jnews' ),
						'param_name' => 'answerColor',
					),
					array(
						'type'       => 'colorpicker',
						'heading'    => esc_html__( 'Icon Color', 'jnews' ),
						'param_name' => 'iconColor',
					),
					array(
						'type'       => 'colorpicker',
						'heading'    => esc_html__( 'Background Color', 'jnews' ),
						'param_name' => 'faqBackground',
					),
					array(
						'type'       => 'colorpicker',
						'heading'    => esc_html__( 'Border Color', 'jnews' ),
						'param_name' => 'faqBorder',
					),
				),
			)
		);
	}
);


add_shortcode( 'custom_jnews_faq', 'render_jnews_faq' );
function render_jnews_faq( $atts, $content = null ) {

	error_log( 'custom_jnews_faq--------' );
	error_log( print_r( $atts, true ) );

	return '';
	// Parse atts, param group json decode, generate HTML output
}"
BcvMvrUd,cobblestone farmer,HawkPB,Lua,Tuesday 1st of July 2025 04:31:04 AM CDT,"local harvested = 0
if fs.exists(""amount"") then
    local filer = fs.open(""amount"", ""r"")
    harvested = tonumber((filer.readAll() or """") or ""0"")
    filer.close()
end
harvested = harvested or 0
local function resolveFuel()
    for i = 1, 16 do
        turtle.select(i)
        local item = turtle.getItemDetail()
        if item and (item.name == ""minecraft:lava_bucket"" or item.name == ""minecraft:charcoal"") then
            turtle.refuel()
        end
    end
    return false
end
local function saveHarvested()
    local filew = fs.open(""amount"", ""w"")
    filew.write(tostring(harvested))
    filew.close()
end
local timer = 0
os.sleep(1) 
resolveFuel()
while true do 
    if turtle.dig() then
        harvested = harvested + 1
    end
    if turtle.digDown() then
        harvested = harvested + 1
    end
    if timer>20 then 
        print(""Fuel: ""..turtle.getFuelLevel())
        print(""Cobblestone Broken: ""..harvested)
        saveHarvested()
        timer = 0
    else
        timer = timer + 1
    end 
end "
16GcHB0f,MS Ninja,bastyav,HTML,Tuesday 1st of July 2025 04:17:21 AM CDT,https://adoption.microsoft.com/en-us/ninja-show/#bonus-content
SuEjRS4w,mg-gpo04.mjs,bdnstn,JavaScript,Tuesday 1st of July 2025 04:02:42 AM CDT,"import * as fz from ""zigbee-herdsman-converters/converters/fromZigbee"";
import * as tz from ""zigbee-herdsman-converters/converters/toZigbee"";
import * as m from ""zigbee-herdsman-converters/lib/modernExtend"";
import * as reporting from ""zigbee-herdsman-converters/lib/reporting"";
import * as tuya from ""zigbee-herdsman-converters/lib/tuya"";
import type {DefinitionWithExtend} from ""zigbee-herdsman-converters/lib/types"";

export const definitions: DefinitionWithExtend[] = [
    {
        fingerprint: tuya.fingerprint(""TS0601"", [""_TZE200_oxsauvxh""]),
        model: ""MG-GPO04"",
        vendor: ""MakeGood"",
        description: ""Double Zigbee power point"",
        fromZigbee: [fz.identify, fz.on_off, fz.electrical_measurement, fz.metering, fz.power_on_behavior],
        toZigbee: [tz.on_off, tz.power_on_behavior, tz.electrical_measurement_power],
        extend: [
            m.deviceEndpoints({endpoints: {right: 1, left: 2}}),
            m.identify(),
            tuya.modernExtend.tuyaOnOff({
                endpoints: [""right"", ""left""],
                powerOutageMemory: true,
                indicatorMode: true,
                childLock: true,
                onOffCountdown: true,
                electricalMeasurements: true,
            }),
        ],
        configure: async (device, coordinatorEndpoint) => {
            const endpoint1 = device.getEndpoint(1);
            const endpoint2 = device.getEndpoint(2);
            await tuya.configureMagicPacket(device, coordinatorEndpoint);
            await reporting.bind(endpoint1, coordinatorEndpoint, [""genOnOff"", ""haElectricalMeasurement"", ""seMetering""]);
            await reporting.onOff(endpoint1);
            await reporting.rmsVoltage(endpoint1, {min: 5, max: 3600, change: 1});
            await reporting.rmsCurrent(endpoint1, {min: 5, max: 3600, change: 1});
            await reporting.activePower(endpoint1, {min: 5, max: 3600, change: 1});
            await reporting.currentSummDelivered(endpoint1, {min: 5, max: 3600, change: 5});
            await reporting.bind(endpoint2, coordinatorEndpoint, [""genOnOff""]);
            endpoint1.saveClusterAttributeKeyValue(""haElectricalMeasurement"", {
                acCurrentDivisor: 1000,
                acCurrentMultiplier: 1,
                acPowerDivisor: 1,
                acPowerMultiplier: 1,
                acVoltageDivisor: 1,
                acVoltageMultiplier: 1,
            });
            endpoint1.saveClusterAttributeKeyValue(""seMetering"", {
                divisor: 100,
                multiplier: 1,
            });
            device.save();
        },
        meta: {
            multiEndpoint: true,
            multiEndpointSkip: [""power"", ""current"", ""voltage"", ""energy""],
        },
    },
];"
4wD7m2z2,"esp8266 webserver https, with login lock logic, IP based",mat8854,C++,Tuesday 1st of July 2025 03:22:40 AM CDT,"#include <ESP8266WiFi.h>
#include <ESP8266WebServerSecure.h>
#include ""certs.h""
#include <map>

const char* ssid = ""YOUR_WIFI_SSID"";
const char* password = ""YOUR_WIFI_PASSWORD"";

const char* authUser = ""admin"";
const char* authPass = ""yourpassword"";

// HTTPS server on port 443
BearSSL::ESP8266WebServerSecure server(443);

// --- Login Tracking ---
struct LoginAttempt {
  uint8_t failedAttempts = 0;
  unsigned long lastAttemptTime = 0;
  unsigned long lockoutUntil = 0;
};

std::map<IPAddress, LoginAttempt> loginMap;

const unsigned int MAX_TRACKED_IPS = 50;
const unsigned long LOGIN_COOLDOWN = 1000;            // 1 second
const unsigned long LOCKOUT_DURATION = 5 * 60 * 1000; // 5 minutes

void pruneOldestIPIfNeeded() {
  if (loginMap.size() < MAX_TRACKED_IPS) return;

  IPAddress oldestIP;
  unsigned long oldestTime = ULONG_MAX;

  for (const auto& entry : loginMap) {
    if (entry.second.lastAttemptTime < oldestTime) {
      oldestTime = entry.second.lastAttemptTime;
      oldestIP = entry.first;
    }
  }

  if (oldestTime != ULONG_MAX) {
    loginMap.erase(oldestIP);
    Serial.print(""Pruned oldest IP: "");
    Serial.println(oldestIP);
  }
}

void setup() {
  Serial.begin(115200);
  delay(100);

  WiFi.begin(ssid, password);
  Serial.print(""Connecting to WiFi"");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }

  Serial.println(""\nWiFi connected. IP address:"");
  Serial.println(WiFi.localIP());

  // Load certificate
  server.getServer().setRSACert(
    (const uint8_t*)cert, strlen(cert),
    (const uint8_t*)key, strlen(key)
  );

  // Secure route with login protection
  server.on(""/"", []() {
    IPAddress clientIP = server.client().remoteIP();
    unsigned long now = millis();

    // Prune if this is a new IP
    if (loginMap.find(clientIP) == loginMap.end()) {
      pruneOldestIPIfNeeded();
    }

    LoginAttempt& attempt = loginMap[clientIP];

    if (now - attempt.lastAttemptTime < LOGIN_COOLDOWN) {
      server.send(429, ""text/plain"", ""Too many requests. Wait a moment."");
      return;
    }

    attempt.lastAttemptTime = now;

    if (now < attempt.lockoutUntil) {
      server.send(403, ""text/plain"", ""Too many failed attempts. Try again later."");
      return;
    }

    if (!server.authenticate(authUser, authPass)) {
      attempt.failedAttempts++;

      if (attempt.failedAttempts >= 3) {
        attempt.lockoutUntil = now + LOCKOUT_DURATION;
        server.send(403, ""text/plain"", ""Locked for 5 minutes."");
      } else {
        server.requestAuthentication(); // 401 Unauthorized
      }

      return;
    }

    // Success
    attempt.failedAttempts = 0;
    attempt.lockoutUntil = 0;
    server.send(200, ""text/html"", ""<h1>Hello, secure world!</h1><p>You are authenticated.</p>"");
  });

  server.begin();
  Serial.println(""HTTPS server started on port 443"");
}

void loop() {
  server.handleClient();
}
"
UvA15hsG,Dumps,LVL23HT,CSS,Tuesday 1st of July 2025 02:48:27 AM CDT,Udemy - React - The Complete Guide with React Hook Redux 2021 in 4hr
