id,title,username,language,date,content
f3SGsPxn,⭐⭐⭐Exploit 500$ in 15 Minutes⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:07:58 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

PQuEdGjb
"
My0B0bZW,⭐⭐⭐MAKE $9OO INSTANTLY D M⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:07:47 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

ZetGpjTl
"
C5w2kwNr,⭐⭐⭐Exchange Exploit T I⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:07:36 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

prbrxrut
"
mYXj1zBU,⭐⭐⭐Instant Profit Method⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:07:25 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

iUMDfpn6
"
Edu3A9QU,⭐⭐⭐MAKE $1000 INSTANTLY⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:07:14 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

j9AJekc9
"
BBfaSUXW,⭐⭐⭐Make $15OO in 2O minutesV E⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:07:03 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

7G1FFEsz
"
sDE95caW,⭐⭐⭐Make $1500 in 20 minutes⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:06:52 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

f9HWxFgU
"
XHq8NpR1,⭐⭐⭐MAKE $500 IN 15 MIN⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:06:40 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

tVHtb3CN
"
ZHFt4fs6,⭐⭐⭐Make $15OO in 2O minutesV E⭐⭐,arcamo,Java,Wednesday 22nd of October 2025 01:06:29 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

845eVPCe
"
gkSnNrzm,Obsidian Bases: Obsidian's Biggest Upgrade (Complete Guide),AmourSpirit,Markdown,Wednesday 22nd of October 2025 01:05:04 PM CDT,"# Obsidian Bases: Obsidian's Biggest Upgrade (Complete Guide)

## Summary

Based on the transcript, this video is a comprehensive tutorial and exploration of Obsidian Bases, a new core plugin that turns notes into powerful databases. Here's a clear, cohesive summary:

**Main Points:**

1. **Introduction to Bases**: Obsidian Bases is now publicly available and represents a significant upgrade. The speaker, Nick Milo, explains that Bases allows users to transform any collection of notes into a flexible database for organizing projects, reading lists, travel plans, and more.

2. **Key Features**:
   - **Speed**: Instantaneous performance, optimized for handling large tables and vaults with tens of thousands of files.
   - **Multiple Views**: A single base can have various filtered views (e.g., table or card layouts) for different subsets of data, such as books, shows, or sources.
   - **Live Editing**: Real-time updates and autocomplete make it easy to edit properties and see immediate changes.

3. **How Bases Work**: 
   - Bases leverage **properties** (metadata within notes) to organize and display data. Users can add custom properties (e.g., ratings, authors) or use global ones (e.g., file creation dates).
   - **Views** allow filtering and sorting. For example, a ""sources"" base can have views for books, movies, or quotes, each with specific filters (e.g., folder location).

4. **Dynamic Links**: A standout feature where embedded bases auto-update based on the active note. For instance, clicking a director’s name dynamically displays their movies from the database, enriching context and connectivity.

5. **Practical Applications**:
   - **Sidebar Integration**: Bases can be embedded in the sidebar to create ""dynamic links,"" offering a 3D-like navigation through linked notes and enhancing creativity and memory.
   - **AI Assistance**: The speaker used AI (Claude Code) to automate adding book cover images to notes, demonstrating how AI can populate properties efficiently.

6. **Comparison and Advantages**:
   - **Vs. Notion**: Bases are faster, support offline use, and aren’t locked into a cloud ecosystem. However, Notion remains better for team collaboration.
   - **Vs. DataView Plugin**: Bases offer a more user-friendly, seamless experience for most use cases, though DataView allows deeper customization for advanced users.

7. **Best Practices**:
   - **Start Broad**: Create a base that encompasses a large dataset (e.g., all notes in a folder) and use views to narrow down.
   - **Baby Steps**: Begin with small, manageable bases (e.g., 20 movies) rather than overhauling entire vaults.
   - **Tend As You Go**: Update properties gradually during note revision to avoid burnout.

8. **Future Developments**: Upcoming features include an API for plugins, grouping and summaries, new view types (e.g., Kanban), and support for Obsidian Publish.

**Conclusion**: Bases revolutionize note-linking and context-building in Obsidian, empowering users to enhance creativity, memory, and idea connectivity. The speaker encourages starting small and leveraging dynamic links for a more enriched thinking environment.

## Details

- Duration: 1h 2m 0s
- URL: [Obsidian Bases: Obsidian's Biggest Upgrade (Complete Guide)](https://www.youtube.com/watch?v=9Yt52zJIIG0)

## Tags
- ObsidianBases
- NoteTaking
- DatabasePlugin
- ProductivityTools
- KnowledgeManagement
- ObsidianFeatures
- DynamicLinks
- PropertiesView
- YouTube
- Video
- Obsidian
"
JEfZYQx1,Untitled,vitormartinotti,Python,Wednesday 22nd of October 2025 12:57:24 PM CDT,"import tkinter as tk
from tkinter import ttk, messagebox
import matplotlib
# Configura o backend do Matplotlib para funcionar com Tkinter
matplotlib.use('TkAgg')

from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class AppPessoas(tk.Tk):
    """"""Classe principal da aplicação Tkinter.""""""
    def __init__(self):
        super().__init__()
        self.title(""Cadastro e Gráfico de Pessoas"")
        self.geometry(""800x600"")

        # Lista para armazenar os dados de pessoas: [{""idade"": 30, ""peso"": 75}, ...]
        self.dados_pessoas = []

        # Configura as abas
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(pady=10, padx=10, expand=True, fill=""both"")

        # Cria as abas
        self.aba_cadastro = ttk.Frame(self.notebook)
        self.aba_grafico = ttk.Frame(self.notebook)

        self.notebook.add(self.aba_cadastro, text=""1. Cadastro"")
        self.notebook.add(self.aba_grafico, text=""2. Gráfico"")
        
        # Vincula a função de atualização ao evento de mudança de aba
        self.notebook.bind(""<<NotebookTabChanged>>"", self.on_tab_change)

        # Configura o conteúdo de cada aba
        self.setup_aba_cadastro()
        self.setup_aba_grafico()

    def setup_aba_cadastro(self):
        """"""Configura os widgets na aba de Cadastro.""""""
        
        # Frame principal para centralizar
        frame_cadastro = ttk.Frame(self.aba_cadastro, padding=""20"")
        frame_cadastro.pack(expand=True, anchor=""center"")

        # Rótulo e campo para Idade
        ttk.Label(frame_cadastro, text=""Idade (anos):"").grid(row=0, column=0, pady=10, sticky=""w"")
        self.entry_idade = ttk.Entry(frame_cadastro, width=15)
        self.entry_idade.grid(row=0, column=1, pady=10, padx=5, sticky=""ew"")

        # Rótulo e campo para Peso
        ttk.Label(frame_cadastro, text=""Peso (kg):"").grid(row=1, column=0, pady=10, sticky=""w"")
        self.entry_peso = ttk.Entry(frame_cadastro, width=15)
        self.entry_peso.grid(row=1, column=1, pady=10, padx=5, sticky=""ew"")

        # Botão para adicionar
        botao_adicionar = ttk.Button(frame_cadastro, text=""Adicionar Pessoa"", command=self.adicionar_pessoa)
        botao_adicionar.grid(row=2, column=0, columnspan=2, pady=20)
        
        # Rótulo para mostrar a contagem de pessoas
        self.label_contagem = ttk.Label(frame_cadastro, text=f""Pessoas cadastradas: {len(self.dados_pessoas)}"")
        self.label_contagem.grid(row=3, column=0, columnspan=2, pady=10)

    def adicionar_pessoa(self):
        """"""Coleta, valida e armazena os dados de idade e peso.""""""
        try:
            idade = int(self.entry_idade.get())
            peso = float(self.entry_peso.get().replace(',', '.'))
            
            if idade <= 0 or peso <= 0:
                 raise ValueError(""Idade e Peso devem ser maiores que zero."")

            # Armazena os dados
            self.dados_pessoas.append({""idade"": idade, ""peso"": peso})
            
            # Limpa os campos de entrada
            self.entry_idade.delete(0, tk.END)
            self.entry_peso.delete(0, tk.END)
            
            # Atualiza a contagem
            self.label_contagem.config(text=f""Pessoas cadastradas: {len(self.dados_pessoas)}"")
            
            messagebox.showinfo(""Sucesso"", f""Pessoa adicionada: Idade {idade}, Peso {peso}kg."")
            
        except ValueError as e:
            messagebox.showerror(""Erro de Entrada"", f""Por favor, insira valores válidos: {e}"")
        except Exception as e:
            messagebox.showerror(""Erro"", f""Ocorreu um erro: {e}"")

    def setup_aba_grafico(self):
        """"""Configura a área de desenho do gráfico na aba de Gráfico.""""""
        
        # Cria a Figura (área de desenho) do Matplotlib
        self.figura = Figure(figsize=(5, 5), dpi=100)
        self.eixo = self.figura.add_subplot(111)

        # Cria o Canvas do Tkinter a partir da Figura
        self.canvas = FigureCanvasTkAgg(self.figura, master=self.aba_grafico)
        
        # Adiciona o widget do canvas à aba
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.pack(side=tk.TOP, fill=tk.BOTH, expand=1)

        # Desenha o gráfico inicial vazio
        self.plotar_grafico()

    def plotar_grafico(self):
        """"""Gera o gráfico de Dispersão (Scatter Plot) com frequência de peso por idade.""""""
        
        # Limpa o gráfico anterior
        self.eixo.clear()

        if not self.dados_pessoas:
            self.eixo.text(0.5, 0.5, 'Nenhum dado cadastrado para exibir.', 
                           ha='center', va='center', transform=self.eixo.transAxes)
            self.figura.canvas.draw()
            return

        # 1. Preparar os dados para contagem de frequência
        # Cria tuplas (idade, peso) e conta a frequência de cada combinação
        combinacoes = [(d['idade'], d['peso']) for d in self.dados_pessoas]
        from collections import Counter
        frequencias = Counter(combinacoes)

        # 2. Separar os dados contados
        idades = [c[0] for c in frequencias.keys()]
        pesos = [c[1] for c in frequencias.keys()]
        contagens = np.array(list(frequencias.values()))

        # 3. Mapear a contagem para o tamanho do ponto (escala visual)
        # O tamanho (s) dos pontos no scatter plot será proporcional à frequência
        # Usamos log para suavizar grandes diferenças e adicionamos um offset
        tamanhos = (np.log(contagens + 1) * 200) + 50
        
        # 4. Desenhar o gráfico de dispersão (Scatter Plot)
        scatter = self.eixo.scatter(idades, pesos, s=tamanhos, alpha=0.6, edgecolors='w', linewidth=1)

        # 5. Configurar rótulos e título
        self.eixo.set_title(""Frequência de Peso por Idade (Tamanho do Ponto = Frequência)"")
        self.eixo.set_xlabel(""Idade (anos)"")
        self.eixo.set_ylabel(""Peso (kg)"")
        self.eixo.grid(True, linestyle='--', alpha=0.7)
        self.eixo.margins(0.1)
        
        # Garante que os valores dos eixos sejam inteiros se forem todos inteiros
        if all(isinstance(i, int) for i in idades) and idades:
            self.eixo.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(integer=True))

        # 6. Forçar o redesenho do canvas
        self.figura.canvas.draw()

    def on_tab_change(self, event):
        """"""Chamado quando o usuário muda de aba. Atualiza o gráfico se for para a aba de Gráfico.""""""
        aba_selecionada = self.notebook.tab(self.notebook.select(), ""text"")
        
        if aba_selecionada == ""2. Gráfico"":
            self.plotar_grafico()

# Ponto de entrada do programa
if __name__ == ""__main__"":
    app = AppPessoas()
    app.mainloop()"
Lv3i77cb,Untitled,Josif_tepe,C++,Wednesday 22nd of October 2025 12:51:04 PM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <map>
using namespace std;
typedef long long ll;
 

int main() {
    int n, m, K;
    cin >> n >> m >> K;
    
    vector<int> desired(n);
    vector<int> apartment_size(m);
    
    for(int i = 0; i < n; i++) {
        cin >> desired[i];
    }
    for(int i = 0; i < m; i++) {
        cin >> apartment_size[i];
    }
    
    sort(desired.begin(), desired.end());
    sort(apartment_size.begin(), apartment_size.end());
    
    queue<int> A, B;
    
    for(int i = 0; i < n; i++) {
        A.push(desired[i]);
    }
    for(int i = 0; i < m; i++) {
        B.push(apartment_size[i]);
    }
    
    int res = 0;
    
    while(!A.empty() and !B.empty()) {
        int a = A.front();
        int b = B.front();
        
        if(abs(a - b) <= K) {
            res++;
            A.pop();
            B.pop();
        }
        else if(a < b) {
            A.pop();
        }
        else {
            B.pop();
        }
    }
  
    cout << res << endl;
    return 0;
}
"
ws8DC7en,⭐⭐⭐Instant Profit Method⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:48:06 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

pqhHJrOy
"
DaJ0dwie,⭐⭐⭐Instant Profit Method⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:47:55 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

bgOkBWRv
"
FRQ9cqUX,⭐⭐⭐Swapzone.io Glitch (Working)⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:47:43 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

ea2B1Ran
"
0LUqsMBP,⭐⭐⭐MAKE $9OO INSTANTLY D G⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:47:31 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

VsKMuMRU
"
GncNgnUG,⭐⭐⭐Make $15OO in 2O minutesV E⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:47:18 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

C4rEdvS4
"
BREJFDZz,⭐⭐⭐MAKE $9OO INSTANTLY D G⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:47:06 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

NbaU4ppQ
"
qy2ftS6S,⭐⭐⭐Make $1500 in 20 minutes⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:46:54 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

me1ojxiO
"
qAWy6ayc,⭐⭐⭐MAKE $900 INSTANTLY⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:46:43 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

QLd2R34J
"
z8e0Mw8j,⭐⭐⭐Make $1500 in 20 minutes⭐⭐,almiralmir,Java,Wednesday 22nd of October 2025 12:46:30 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

HtDMBkZf
"
zdHviVDy,Elevator System LLD,vky3831,Java,Wednesday 22nd of October 2025 12:38:54 PM CDT,"enum ElevatorState {
   MOVING_UP, MOVING_DOWN, IDLE
}

enum Direction {
   UP, DOWN
}

class Request {
   private int sourceFloor;
   private Direction direction;

   public Request(int sourceFloor, Direction direction) {
       this.sourceFloor = sourceFloor;
       this.direction = direction;
   }

   public int getSourceFloor() { return sourceFloor; }
   public Direction getDirection() { return direction; }
}

class Elevator {
   private int currentFloor;
   private ElevatorState state;
   private TreeSet<Integer> upRequests = new TreeSet<>();
   private TreeSet<Integer> downRequests = new TreeSet<>(Comparator.reverseOrder());

   public Elevator() {
       this.currentFloor = 0;
       this.state = ElevatorState.IDLE;
   }

   public void addRequest(int floor) {
       if (floor > currentFloor) {
           upRequests.add(floor);
       } else if (floor < currentFloor) {
           downRequests.add(floor);
       }
   }

   public void addInternalRequest(int destinationFloor) {
       addRequest(destinationFloor);
   }

   /**
    * Simulates the elevator's state transition.
    *
    * IDLE:
    *   - Move to MOVING_UP if upRequests exist
    *   - Move to MOVING_DOWN if no upRequests but downRequests exist
    *
    * MOVING_UP:
    *   - Increment currentFloor
    *   - Stop if currentFloor is in upRequests, remove it, allow destination input
    *   - If upRequests are empty, switch to MOVING_DOWN if downRequests exist
    *   - Else, return to IDLE
    *
    * MOVING_DOWN:
    *   - Decrement currentFloor
    *   - Stop if currentFloor is in downRequests, remove it, allow destination input
    *   - If downRequests are empty, switch to MOVING_UP if upRequests exist
    *   - Else, return to IDLE
    */
   public void step() {
       if (state == ElevatorState.IDLE) {
           if (!upRequests.isEmpty()) {
               state = ElevatorState.MOVING_UP;
           } else if (!downRequests.isEmpty()) {
               state = ElevatorState.MOVING_DOWN;
           } else {
               return;
           }
       }

       if (state == ElevatorState.MOVING_UP) {
           currentFloor++;
           System.out.println(""Elevator moving up to floor: "" + currentFloor);
           if (upRequests.remove(currentFloor)) {
               System.out.println(""Stopping at floor: "" + currentFloor);
               int destination = simulateUserDestination();
               addInternalRequest(destination);
           }

           if (upRequests.isEmpty() && !downRequests.isEmpty()) {
               state = ElevatorState.MOVING_DOWN;
           } else if (upRequests.isEmpty()) {
               state = ElevatorState.IDLE;
           }

       } else if (state == ElevatorState.MOVING_DOWN) {
           currentFloor--;
           System.out.println(""Elevator moving down to floor: "" + currentFloor);
           if (downRequests.remove(currentFloor)) {
               System.out.println(""Stopping at floor: "" + currentFloor);
               int destination = simulateUserDestination();
               addInternalRequest(destination);
           }

           if (downRequests.isEmpty() && !upRequests.isEmpty()) {
               state = ElevatorState.MOVING_UP;
           } else if (downRequests.isEmpty()) {
               state = ElevatorState.IDLE;
           }
       }
   }

   private int simulateUserDestination() {
       Random random = new Random();
       int destination = random.nextInt(10);
       while (destination == currentFloor) {
           destination = random.nextInt(10);
       }
       System.out.println(""User entered destination floor: "" + destination);
       return destination;
   }

   public int getCurrentFloor() { return currentFloor; }
   public ElevatorState getState() { return state; }
}

class ElevatorController {
   private List<Elevator> elevators;

   public ElevatorController(int numberOfElevators) {
       elevators = new ArrayList<>();
       for (int i = 0; i < numberOfElevators; i++) {
           elevators.add(new Elevator());
       }
   }

   public void handleExternalRequest(Request request) {
       Elevator bestElevator = findBestElevator(request.getSourceFloor(), request.getDirection());
       bestElevator.addRequest(request.getSourceFloor());
   }

   /**
    * Selects the best elevator for the request.
    * Priority is given to elevators that:
    * - Are IDLE
    * - Are moving in the same direction as the request and heading towards the request floor
    * - Otherwise, selects the closest elevator by default
    */
   private Elevator findBestElevator(int floor, Direction direction) {
       Elevator selected = null;
       int minDistance = Integer.MAX_VALUE;

       for (Elevator elevator : elevators) {
           int distance = Math.abs(elevator.getCurrentFloor() - floor);
           boolean suitable = false;

           if (elevator.getState() == ElevatorState.IDLE) {
               suitable = true;
           } else if (elevator.getState() == ElevatorState.MOVING_UP && direction == Direction.UP && elevator.getCurrentFloor() <= floor) {
               suitable = true;
           } else if (elevator.getState() == ElevatorState.MOVING_DOWN && direction == Direction.DOWN && elevator.getCurrentFloor() >= floor) {
               suitable = true;
           }

           if (suitable && distance < minDistance) {
               minDistance = distance;
               selected = elevator;
           }
       }

       return selected != null ? selected : elevators.get(0);
   }

   public void stepAllElevators() {
       for (Elevator elevator : elevators) {
           elevator.step();
           System.out.println(""Elevator at floor: "" + elevator.getCurrentFloor() + "" State: "" + elevator.getState());
       }
   }
}

/**
* ElevatorSystemDemo demonstrates the elevator system by initializing a controller,
* submitting some example external requests, and simulating the elevator steps over time.
*/
public class ElevatorSystemDemo {
   public static void main(String[] args) throws InterruptedException {
       ElevatorController controller = new ElevatorController(3);

       controller.handleExternalRequest(new Request(5, Direction.UP));
       controller.handleExternalRequest(new Request(2, Direction.DOWN));

       for (int i = 0; i < 15; i++) {
           System.out.println(""Step "" + i);
           controller.stepAllElevators();
           Thread.sleep(1000);
       }
   }
}
"
thQ74nCJ,Parking Lot LLD,vky3831,Java,Wednesday 22nd of October 2025 12:37:50 PM CDT,"enum VehicleType {
   CAR, BIKE, TRUCK
}

abstract class Vehicle {
   private String licenseNumber;
   private VehicleType type;

   public Vehicle(String licenseNumber, VehicleType type) {
       this.licenseNumber = licenseNumber;
       this.type = type;
   }

   public VehicleType getType() {
       return type;
   }

   public String getLicenseNumber() {
       return licenseNumber;
   }
}

class Car extends Vehicle {
   public Car(String licenseNumber) {
       super(licenseNumber, VehicleType.CAR);
   }
}

class Bike extends Vehicle {
   public Bike(String licenseNumber) {
       super(licenseNumber, VehicleType.BIKE);
   }
}

class Truck extends Vehicle {
   public Truck(String licenseNumber) {
       super(licenseNumber, VehicleType.TRUCK);
   }
}

class ParkingSpot {
   private final int spotNumber;
   private final VehicleType supportedType;
   private boolean isOccupied;
   private Vehicle parkedVehicle;

   public ParkingSpot(int spotNumber, VehicleType supportedType) {
       this.spotNumber = spotNumber;
       this.supportedType = supportedType;
       this.isOccupied = false;
   }

   public boolean canPark(Vehicle vehicle) {
       return !isOccupied && vehicle.getType() == supportedType;
   }

   public void park(Vehicle vehicle) {
       if (canPark(vehicle)) {
           this.parkedVehicle = vehicle;
           this.isOccupied = true;
       }
   }

   public void vacate() {
       this.parkedVehicle = null;
       this.isOccupied = false;
   }

   public boolean isOccupied() {
       return isOccupied;
   }

   public int getSpotNumber() {
       return spotNumber;
   }
}

class ParkingFloor {
   private final int floorNumber;
   private List<ParkingSpot> spots;

   public ParkingFloor(int floorNumber, List<ParkingSpot> spots) {
       this.floorNumber = floorNumber;
       this.spots = spots;
   }

   public ParkingSpot findAvailableSpot(Vehicle vehicle) {
       for (ParkingSpot spot : spots) {
           if (spot.canPark(vehicle)) {
               return spot;
           }
       }
       return null;
   }

   public int getFloorNumber() {
       return floorNumber;
   }

   public List<ParkingSpot> getSpots() {
       return spots;
   }
}

class Ticket {
   private Vehicle vehicle;
   private int floorNumber;
   private int spotNumber;
   private LocalDateTime entryTime;
   private LocalDateTime exitTime;
   private double costPerHour = 10.0;

   public Ticket(Vehicle vehicle, int floorNumber, int spotNumber) {
       this.vehicle = vehicle;
       this.floorNumber = floorNumber;
       this.spotNumber = spotNumber;
       this.entryTime = LocalDateTime.now();
   }

   public void markExit() {
       this.exitTime = LocalDateTime.now();
   }

   public double calculateBill() {
       if (exitTime == null) {
           throw new IllegalStateException(""Vehicle has not exited yet!"");
       }
       long durationInHours = Math.max(1, Duration.between(entryTime, exitTime).toHours());
       return durationInHours * costPerHour;
   }

   public Vehicle getVehicle() {
       return vehicle;
   }

   public int getFloorNumber() {
       return floorNumber;
   }

   public int getSpotNumber() {
       return spotNumber;
   }
}

class ParkingLot {
   private List<ParkingFloor> floors;
   private Map<String, Ticket> activeTickets = new HashMap<>();

   public ParkingLot(List<ParkingFloor> floors) {
       this.floors = floors;
   }

   public Ticket parkVehicle(Vehicle vehicle) {
       for (ParkingFloor floor : floors) {
           ParkingSpot spot = floor.findAvailableSpot(vehicle);
           if (spot != null) {
               spot.park(vehicle);
               Ticket ticket = new Ticket(vehicle, floor.getFloorNumber(), spot.getSpotNumber());
               activeTickets.put(vehicle.getLicenseNumber(), ticket);
               System.out.println(""Vehicle parked at floor "" + floor.getFloorNumber() + "" in spot "" + spot.getSpotNumber());
               return ticket;
           }
       }
       System.out.println(""No available spot for vehicle type: "" + vehicle.getType());
       return null;
   }

   public double vacateSpot(String licenseNumber) {
       Ticket ticket = activeTickets.get(licenseNumber);
       if (ticket == null) {
           System.out.println(""No active ticket found for vehicle: "" + licenseNumber);
           return 0.0;
       }
       ParkingFloor floor = floors.get(ticket.getFloorNumber());
       ParkingSpot spot = floor.getSpots().get(ticket.getSpotNumber());
       spot.vacate();

       ticket.markExit();
       double bill = ticket.calculateBill();
       activeTickets.remove(licenseNumber);
       System.out.println(""Vehicle with license "" + licenseNumber + "" exited. Bill: $"" + bill);
       return bill;
   }
}

public class ParkingLotDemo {
   public static void main(String[] args) throws InterruptedException {
       List<ParkingSpot> floor1Spots = new ArrayList<>();
       floor1Spots.add(new ParkingSpot(0, VehicleType.CAR));
       floor1Spots.add(new ParkingSpot(1, VehicleType.BIKE));

       List<ParkingSpot> floor2Spots = new ArrayList<>();
       floor2Spots.add(new ParkingSpot(0, VehicleType.TRUCK));
       floor2Spots.add(new ParkingSpot(1, VehicleType.CAR));

       ParkingFloor floor1 = new ParkingFloor(0, floor1Spots);
       ParkingFloor floor2 = new ParkingFloor(1, floor2Spots);

       ParkingLot parkingLot = new ParkingLot(Arrays.asList(floor1, floor2));

       Vehicle car1 = new Car(""CAR123"");
       Vehicle bike1 = new Bike(""BIKE456"");
       Vehicle truck1 = new Truck(""TRUCK789"");

       Ticket ticket1 = parkingLot.parkVehicle(car1);
       Ticket ticket2 = parkingLot.parkVehicle(bike1);
       Ticket ticket3 = parkingLot.parkVehicle(truck1);

       Thread.sleep(2000); // Simulate time spent in parking

       parkingLot.vacateSpot(car1.getLicenseNumber());
       parkingLot.vacateSpot(bike1.getLicenseNumber());
       parkingLot.vacateSpot(truck1.getLicenseNumber());
   }
}

/*
UML Diagram
visit to visualize: https://www.planttext.com/

@startuml

enum VehicleType {
   CAR
   BIKE
   TRUCK
}

abstract class Vehicle {
   - licenseNumber: String
   - type: VehicleType
   + getLicenseNumber(): String
   + getType(): VehicleType
}

class Car
class Bike
class Truck

Vehicle <|-- Car
Vehicle <|-- Bike
Vehicle <|-- Truck

class ParkingSpot {
   - spotNumber: int
   - supportedType: VehicleType
   - isOccupied: boolean
   - parkedVehicle: Vehicle
   + canPark(Vehicle): boolean
   + park(Vehicle): void
   + vacate(): void
}

class ParkingFloor {
   - floorNumber: int
   - spots: List<ParkingSpot>
   + findAvailableSpot(Vehicle): ParkingSpot
   + getFloorNumber(): int
   + getSpots(): List<ParkingSpot>
}

class Ticket {
   - vehicle: Vehicle
   - floorNumber: int
   - spotNumber: int
   - entryTime: LocalDateTime
   - exitTime: LocalDateTime
   - costPerHour: double
   + markExit(): void
   + calculateBill(): double
}

class ParkingLot {
   - floors: List<ParkingFloor>
   - activeTickets: Map<String, Ticket>
   + parkVehicle(Vehicle): Ticket
   + vacateSpot(String): double
}

Vehicle --> VehicleType
ParkingFloor ""1"" *-- ""*"" ParkingSpot
ParkingLot ""1"" o-- ""*"" ParkingFloor
ParkingLot --> Ticket
Ticket --> Vehicle

@enduml


*/
"
iS7Yq1eF,⭐⭐⭐Profit Method⭐⭐,VivBling,Java,Wednesday 22nd of October 2025 12:36:30 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

jBxyWQaX
"
GGjG3FUd,Notification System LLD,vky3831,Java,Wednesday 22nd of October 2025 12:36:05 PM CDT,"// Core Notification System LLD in Java - Robust & Optimized

import java.util.*;
import java.util.concurrent.*;

// Notification Service Interface
interface NotificationService {
   void sendNotification(NotificationRequest request);
}

// Notification Channel Interface
interface NotificationChannel {
   boolean send(NotificationMessage message);
}

// User Preference Service Interface
interface UserPreferenceService {
   UserPreferences getPreferences(String userId);
}

// Data Classes
class NotificationRequest {
   private String requestId;
   private String notificationType;
   private Map<String, String> recipient;
   private List<String> channels;
   private Map<String, String> message;
   private ScheduleDetails schedule;
   private Map<String, String> metadata;

   // Constructors, Getters, Setters omitted for brevity
}

class NotificationEvent {
   private String messageId;
   private String timestamp;
   private String notificationType;
   private String channel;
   private Map<String, String> recipient;
   private Map<String, String> messageContent;
   private Map<String, String> metadata;

   // Constructors, Getters, Setters omitted for brevity
}

class NotificationMessage {
   private String messageId;
   private String channel;
   private Map<String, String> recipient;
   private String content;

   // Constructors, Getters, Setters omitted for brevity
}

class UserPreferences {
   private String userId;
   private List<String> preferredChannels;
   private Map<String, Boolean> optOutStatus;
   private Map<String, Integer> rateLimits;

   // Constructors, Getters, Setters omitted for brevity
}

class ScheduleDetails {
   private Date scheduledTime;

   // Constructors, Getters, Setters omitted for brevity
}

// Concrete Implementations
class NotificationServiceImpl implements NotificationService {
   private final BlockingQueue<NotificationEvent> notificationQueue = new LinkedBlockingQueue<>();
   private final UserPreferenceService userPreferenceService = new UserPreferenceServiceImpl();
   private final SchedulerService schedulerService = new SchedulerService();
   private final RateLimiterService rateLimiter = new RateLimiterService();
   private final NotificationChannelFactory channelFactory = new NotificationChannelFactory();
   private final RetryMechanism retryMechanism = new RetryMechanism();

   @Override
   public void sendNotification(NotificationRequest request) {
       UserPreferences preferences = userPreferenceService.getPreferences(request.getRecipient().get(""userId""));

       for (String channel : request.getChannels()) {
           if (!preferences.getPreferredChannels().contains(channel) ||
               preferences.getOptOutStatus().getOrDefault(channel, false) ||
               !RateLimiterService.allow(preferences.getUserId(), channel)) {
               continue;
           }

           NotificationEvent event = createEvent(request, channel);

           if (request.getSchedule() != null) {
               schedulerService.scheduleNotification(event);
           } else {
               notificationQueue.add(event);
               processEvent(event);
           }
       }
   }

   private NotificationEvent createEvent(NotificationRequest request, String channel) {
       // Event creation logic (populate fields)
       return new NotificationEvent();
   }

   private void processEvent(NotificationEvent event) {
       NotificationMessage message = new NotificationMessage(); // populate
       NotificationChannel channel = channelFactory.getChannel(event.getChannel());

       boolean success = channel.send(message);
       if (!success) {
           retryMechanism.retry(event);
       }
   }
}

// Channel Implementations
class EmailNotificationChannel implements NotificationChannel {
   public boolean send(NotificationMessage message) {
       System.out.println(""Email sent to: "" + message.getRecipient());
       return true;
   }
}

class SMSNotificationChannel implements NotificationChannel {
   public boolean send(NotificationMessage message) {
       System.out.println(""SMS sent to: "" + message.getRecipient());
       return true;
   }
}

class PushNotificationChannel implements NotificationChannel {
   public boolean send(NotificationMessage message) {
       System.out.println(""Push notification sent to: "" + message.getRecipient());
       return true;
   }
}

// Channel Factory for Dynamic Channel Retrieval
class NotificationChannelFactory {
   private final Map<String, NotificationChannel> channels = new HashMap<>();

   public NotificationChannelFactory() {
       channels.put(""EMAIL"", new EmailNotificationChannel());
       channels.put(""SMS"", new SMSNotificationChannel());
       channels.put(""PUSH"", new PushNotificationChannel());
   }

   public NotificationChannel getChannel(String channelType) {
       return channels.get(channelType);
   }
}

class UserPreferenceServiceImpl implements UserPreferenceService {
   public UserPreferences getPreferences(String userId) {
       // Fetch preferences from DB/cache (mocked here)
       return new UserPreferences();
   }
}

class SchedulerService {
   public void scheduleNotification(NotificationEvent event) {
       System.out.println(""Notification scheduled: "" + event);
   }
}

class RateLimiterService {
   public boolean allow(String userId, String channel) {
       // Rate limiting logic (mocked true)
       return true;
   }
}

class RetryMechanism {
   public void retry(NotificationEvent event) {
       System.out.println(""Retrying for event: "" + event);
       // Implement retry logic here
   }
}

/*

UML Diagram
visit to visualize: https://www.planttext.com/

@startuml

interface NotificationService {
   + sendNotification(request: NotificationRequest)
}

interface NotificationChannel {
   + send(message: NotificationMessage): boolean
}

interface UserPreferenceService {
   + getPreferences(userId: String): UserPreferences
}

class NotificationRequest {
   - requestId: String
   - notificationType: String
   - recipient: Map<String, String>
   - channels: List<String>
   - message: Map<String, String>
   - schedule: ScheduleDetails
   - metadata: Map<String, String>
}

class NotificationEvent {
   - messageId: String
   - timestamp: String
   - notificationType: String
   - channel: String
   - recipient: Map<String, String>
   - messageContent: Map<String, String>
   - metadata: Map<String, String>
}

class NotificationMessage {
   - messageId: String
   - channel: String
   - recipient: Map<String, String>
   - content: String
}

class UserPreferences {
   - userId: String
   - preferredChannels: List<String>
   - optOutStatus: Map<String, Boolean>
   - rateLimits: Map<String, Integer>
}

class ScheduleDetails {
   - scheduledTime: Date
}

class NotificationServiceImpl {
   + sendNotification(request: NotificationRequest)
   - createEvent(request: NotificationRequest, channel: String): NotificationEvent
   - processEvent(event: NotificationEvent)
}

class EmailNotificationChannel {
   + send(message: NotificationMessage): boolean
}

class SMSNotificationChannel {
   + send(message: NotificationMessage): boolean
}

class PushNotificationChannel {
   + send(message: NotificationMessage): boolean
}

class NotificationChannelFactory {
   + getChannel(channelType: String): NotificationChannel
}

class UserPreferenceServiceImpl {
   + getPreferences(userId: String): UserPreferences
}

class SchedulerService {
   + scheduleNotification(event: NotificationEvent)
}

class RateLimiterService {
   + allow(userId: String, channel: String): boolean
}

class RetryMechanism {
   + retry(event: NotificationEvent)
}

NotificationService <|-- NotificationServiceImpl
NotificationServiceImpl --> NotificationRequest
NotificationServiceImpl --> NotificationEvent
NotificationServiceImpl --> NotificationChannelFactory
NotificationServiceImpl --> UserPreferenceService
NotificationServiceImpl --> SchedulerService
NotificationServiceImpl --> RateLimiterService
NotificationServiceImpl --> RetryMechanism

NotificationChannel <|-- EmailNotificationChannel
NotificationChannel <|-- SMSNotificationChannel
NotificationChannel <|-- PushNotificationChannel

NotificationChannelFactory --> NotificationChannel

UserPreferenceService <|-- UserPreferenceServiceImpl
UserPreferenceServiceImpl --> UserPreferences

SchedulerService --> NotificationEvent
RateLimiterService --> NotificationEvent
RetryMechanism --> NotificationEvent

@enduml


*/
"
s0qA4n3H,Untitled,Josif_tepe,C++,Wednesday 22nd of October 2025 12:25:34 PM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;
typedef long long ll;
 

int main() {
    int n, K;
    cin >> n >> K;
    
    vector<int> v(n);
    map<int, int> cnt;
    
    for(int i = 0; i < n; i++) {
        cin >> v[i];
        
        cnt[v[i]]++;
    }
    
    ll res = 0;
    for(int i = 0; i < n; i++) {
        res += cnt[v[i] + K];
    }
    
    if(K == 0) {
        res -= n;
        res /= 2;
    }
    cout << res << endl;
  
    return 0;
}
"
EH86J7pN,⭐⭐⭐Exchange Exploit T I⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:19:01 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

P6yHIs0W
"
NzRbukBZ,⭐⭐⭐MAKE $900 INSTANTLY⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:18:47 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

HgWpDbJ3
"
w7UfHR0c,⭐⭐⭐Make $15OO in 2O minutesV E⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:18:34 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

S4qB2nQC
"
f2vzWAmU,⭐⭐⭐Instant Profit Method⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:18:21 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

AzkHq6Ok
"
Myj2HNrZ,⭐⭐⭐GMAIL Logs (2FA disabled)⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:18:08 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

sKc0GRif
"
6DZjtqep,⭐⭐⭐Exploit 500$ in 15 Minutes⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:17:56 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

2qWX1tdn
"
fRsCDsWi,⭐⭐⭐MAKE $1000 INSTANTLY⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:17:44 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

5fIDSAuw
"
xZFiqcUU,⭐⭐⭐Exchange Exploit⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:17:32 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

s7ktzU0u
"
beX5bua1,⭐⭐⭐Make $1500 in 20 minutes⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:17:20 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

BEjSHoKg
"
LSicQipW,⭐⭐⭐Exchange Exploit T I⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:17:07 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

O7T1wvNK
"
KgJjzKRL,⭐⭐⭐Crypto Accounts⭐⭐,Tapjdm,Java,Wednesday 22nd of October 2025 12:16:53 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

4HKvvZEH
"
gGtmQBDB,⭐⭐⭐Exchange Exploit⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:08:39 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

ev0dA1lN
"
0LSS5Hjn,⭐⭐⭐Make $1500 in 20 minutes⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:08:27 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

TZCv53RI
"
TszS75B3,⭐⭐⭐Exchange Exploit T 3⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:08:16 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

GRPculuW
"
hG7Pt8c8,⭐⭐⭐Instant Profit Method⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:08:05 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

TPNbTa26
"
M94cFNDS,⭐⭐⭐Make $15OO in 2O minutesV E⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:07:52 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

p0qXyQoe
"
nYRcCpm0,⭐⭐⭐Crypto Accounts⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:07:41 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

C5mpSYji
"
FRj5Q5Ca,⭐⭐⭐MAKE $9OO INSTANTLY D A⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:07:29 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

EC8QCCVu
"
h9q3AmhQ,⭐⭐⭐Profit Method⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:07:17 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

F8SlY0d1
"
6qStWWxT,⭐⭐⭐Instant Profit Method⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:07:04 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

jC7L2DRQ
"
GCKKZmvF,⭐⭐⭐Exchange Exploit T 3⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:06:53 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

4bznmDQl
"
nAw4Zeis,⭐⭐⭐MAKE $9OO INSTANTLY D M⭐⭐,Sean737,Java,Wednesday 22nd of October 2025 12:06:40 PM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

WXjvBG4Y
"
6N1dyyjG,⭐⭐⭐Profit Method⭐⭐,MAKI2012,Java,Wednesday 22nd of October 2025 11:58:29 AM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

Q6CffavT
"
F6jqnjn1,⭐⭐⭐Swapzone.io Glitch (Working)⭐⭐,MAKI2012,Java,Wednesday 22nd of October 2025 11:58:18 AM CDT,"


JOIN USING THE LINK BELOW


t.me/s/hy4546

Rhg0S5M3
"
