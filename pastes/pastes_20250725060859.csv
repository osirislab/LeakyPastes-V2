id,title,username,language,date,content
7HhxZ3f6,Untitled,mqrnKNOetoNOOB,Java,Thursday 24th of July 2025 11:56:59 PM CDT,"// BloodUnit.java
package BloodRelated;

import java.time.LocalDate;
import java.io.Serializable;

public class BloodUnit implements Serializable{
    private String donorName;
    private String donorNID;
    private String bloodGroup;
    private LocalDate donationDate;
    private LocalDate expiryDate;

    public BloodUnit(String donorName, String donorNID, String bloodGroup, LocalDate donationDate, LocalDate expiryDate) {
        this.donorName = donorName;
        this.donorNID = donorNID;
        this.bloodGroup = bloodGroup;
        this.donationDate = donationDate;
        this.expiryDate = expiryDate;
    }

    public String getDonorName() { return donorName; }
    public String getDonorNID() { return donorNID; }
    public String getBloodGroup() { return bloodGroup; }
    public LocalDate getDonationDate() { return donationDate; }
    public LocalDate getExpiryDate() { return expiryDate; }
    public String getName() {
        return donorName;
    }

    public void showInfo() {
        System.out.println(""Donor: "" + donorName + "", NID: "" + donorNID + "", Group: "" + bloodGroup +
                "", Donated: "" + donationDate + "", Expires: "" + expiryDate);
    }

    public boolean isExpired() {
        return expiryDate.isBefore(LocalDate.now());
    }

    @Override
    public String toString() {
        return donorName + "" ("" + bloodGroup + ""), Expires: "" + expiryDate;
    }
}

// BloodUnitList.java
package BloodRelated;

import Message.StockAlertMessage;

import java.io.*;
import java.time.LocalDate;
import java.util.ArrayList;

public class BloodUnitList {

    private ArrayList<BloodUnit> Apos = new ArrayList<>();
    private ArrayList<BloodUnit> Aneg = new ArrayList<>();
    private ArrayList<BloodUnit> Bpos = new ArrayList<>();
    private ArrayList<BloodUnit> Bneg = new ArrayList<>();
    private ArrayList<BloodUnit> ABpos = new ArrayList<>();
    private ArrayList<BloodUnit> ABneg = new ArrayList<>();
    private ArrayList<BloodUnit> Opos = new ArrayList<>();
    private ArrayList<BloodUnit> Oneg = new ArrayList<>();

    public ArrayList<BloodUnit> fetchBlood(String group) {
        group = group.toUpperCase();
        switch (group) {
            case ""A+"": return Apos;
            case ""A-"": return Aneg;
            case ""B+"": return Bpos;
            case ""B-"": return Bneg;
            case ""AB+"": return ABpos;
            case ""AB-"": return ABneg;
            case ""O+"": return Opos;
            case ""O-"": return Oneg;
            default: return null;
        }
    }

    public void append(ArrayList<BloodUnit> list, BloodUnit unit) {
        list.add(unit);
        this.saveAllToFiles(""C:\\Users\\win11\\OneDrive\\Documents\\BUET program\\project java\\javaProject\\data"");
    }

    public void leave(ArrayList<BloodUnit> list, int index) {
        list.remove(index);
        this.saveAllToFiles(""C:\\Users\\win11\\OneDrive\\Documents\\BUET program\\project java\\javaProject\\data"");
    }

    public BloodUnit dequeue(ArrayList<BloodUnit> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        BloodUnit bloodUnit = list.remove(0);
        this.saveAllToFiles(""C:\\Users\\win11\\OneDrive\\Documents\\BUET program\\project java\\javaProject\\data"");
        return bloodUnit;
    }

    public void printAll() {
        String[] groups = {""A+"", ""A-"", ""B+"", ""B-"", ""AB+"", ""AB-"", ""O+"", ""O-""};
        for (String group : groups) {
            ArrayList<BloodUnit> list = fetchBlood(group);
            System.out.println(""Group "" + group + "":"");
            for (BloodUnit b : list) {
                System.out.println(""  "" + b);
            }
        }
    }

    public ArrayList<BloodUnit> getExpiredUnits() {
        ArrayList<BloodUnit> expired = new ArrayList<>();
        String[] groups = {""A+"", ""A-"", ""B+"", ""B-"", ""AB+"", ""AB-"", ""O+"", ""O-""};
        for (String group : groups) {
            ArrayList<BloodUnit> list = fetchBlood(group);
            for (BloodUnit b : list) {
                if (b.isExpired()) expired.add(b);
            }
        }
        return expired;
    }

    public void saveAllToFiles(String folderPath) {
        String[] bloodGroups = {""A+"", ""A-"", ""B+"", ""B-"", ""AB+"", ""AB-"", ""O+"", ""O-""};

        for (String group : bloodGroups) {
            try {
                File file = new File(folderPath + ""/blood_"" + group.replace(""+"", ""pos"").replace(""-"", ""neg"") + "".csv"");
                BufferedWriter bw = new BufferedWriter(new FileWriter(file));

                for (BloodUnit unit : fetchBlood(group)) {
                    String line = unit.getDonorName() + "","" + unit.getDonorNID() + "","" +
                            unit.getBloodGroup() + "","" + unit.getDonationDate() + "","" + unit.getExpiryDate();
                    bw.write(line);
                    bw.newLine();
                }

                bw.close();
            } catch (IOException e) {
                System.err.println(""Error writing to file for group: "" + group);
            }
        }
    }

    public void loadAllFromFiles(String folderPath) {
        String[] bloodGroups = {""A+"", ""A-"", ""B+"", ""B-"", ""AB+"", ""AB-"", ""O+"", ""O-""};

        for (String group : bloodGroups) {
            String fileName = folderPath + ""/blood_"" + group.replace(""+"", ""pos"").replace(""-"", ""neg"") + "".csv"";
            ArrayList<BloodUnit> list = fetchBlood(group);
            try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
                String line;
                while ((line = br.readLine()) != null) {
                    String[] parts = line.split("","", -1);
                    if (parts.length == 5) {
                        String donor = parts[0];
                        String nid = parts[1];
                        String grp = parts[2];
                        LocalDate donationDate = LocalDate.parse(parts[3]);
                        LocalDate expiryDate = LocalDate.parse(parts[4]);
                        BloodUnit unit = new BloodUnit(donor, nid, grp, donationDate, expiryDate);
                        list.add(unit);
                    }
                }
            } catch (IOException e) {
                System.err.println(""Error loading blood units from file: "" + fileName);
            }
        }
    }
}

// Person.java
package BloodRelated;

import java.io.Serializable;

public class Person implements Serializable {
    private String name;
    private String NID;
    private String bloodGroup;

    public Person(String name, String nid, String bloodGroup) {
        this.name = name;
        this.NID = nid;
        this.bloodGroup = bloodGroup;
    }

    public String getName() {
        return name;
    }

    public String getNID() {
        return NID;
    }

    public String getBloodGroup() {
        return bloodGroup;
    }
}

// ClientHandler.java
package Client;

import Message.*;

import java.io.*;
import java.net.Socket;
import java.util.concurrent.ConcurrentHashMap;

public class ClientHandler implements Runnable {
    private static final ConcurrentHashMap<String, ObjectOutputStream> clientMap = new ConcurrentHashMap<>();
    private Socket socket;
    private ObjectInputStream in;
    private ObjectOutputStream out;
    private String role;

    public ClientHandler(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            out = new ObjectOutputStream(socket.getOutputStream());
            in = new ObjectInputStream(socket.getInputStream());

            role = (String) in.readObject(); // read role like ""Manager"", ""DonationOfficer""
            clientMap.put(role, out);

            Object obj;
            while ((obj = in.readObject()) != null) {
                if (obj instanceof BaseMessage) {
                    BaseMessage msg = (BaseMessage) obj;
                    String to = msg.getReceiverRole();

                    if (clientMap.containsKey(to)) {
                        clientMap.get(to).writeObject(msg);
                        clientMap.get(to).flush();
                    } else {
                        System.out.println(""Receiver "" + to + "" is not connected."");
                    }
                }
            }

        } catch (Exception e) {
            System.out.println(""Connection closed for: "" + role);
        } finally {
            try {
                if (in != null) in.close();
                if (out != null) out.close();
                if (socket != null) socket.close();
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
    }
}

// ClientMain.java
package Client;

import Message.*;
import StuffRelated.*;

import java.io.*;
import java.net.Socket;
import java.util.Scanner;

public class ClientMain {
    public static void main(String[] args) {
        try (Socket socket = new Socket(""localhost"", 12345);
             ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream input = new ObjectInputStream(socket.getInputStream());
             Scanner sc = new Scanner(System.in)) {

            Stuff currentUser = null;
            while (currentUser == null) {
                System.out.println(""Select Role:"");
                System.out.println(""1. Manager"");
                System.out.println(""2. Registration Tester"");
                System.out.println(""3. Donation Officer"");
                System.out.println(""4. Preservation Officer"");
                System.out.println(""5. Delivery Tester"");
                System.out.print(""Enter role number: "");
                int role = Integer.parseInt(sc.nextLine());

                System.out.print(""Enter PIN: "");
                String enteredPin = sc.nextLine();

                output.writeObject(""LOGIN_REQUEST"");
                output.writeObject(role);
                output.writeObject(enteredPin);

                Object response = input.readObject();
                if (response instanceof Stuff) {
                    currentUser = (Stuff) response;
                    System.out.println(""Login successful!"");
                } else {
                    System.out.println(""Login failed. Try again.\n"");
                }
            }

            String x = currentUser.getRole();
            ClientMenuHandler.handleMenu(x, currentUser, output);

        } catch (Exception e) {
            System.out.println(""Error in client: "" + e.getMessage());
            e.printStackTrace();
        }
    }
}

// ClientMenuHandler.java
package Client;

import StuffRelated.*;
import java.io.ObjectOutputStream;
import java.util.Scanner;

public class ClientMenuHandler {

    public static void handleMenu(String role, Stuff currentStuff, ObjectOutputStream out) {
        switch (role) {
            case ""Manager"" -> ManagerClient.run(currentStuff, out);
            case ""RegTester"" -> RegTesterClient.run(currentStuff, out);
            case ""DonationOfficer"" -> DonationOfficerClient.run(currentStuff, out);
            case ""PreservationOfficer"" -> PreservationOfficerClient.run(currentStuff, out);
            case ""DeliveryTester"" -> DeliveryTesterClient.run(currentStuff, out);
            default -> System.out.println(""Invalid role. Cannot start client menu."");
        }
    }
}

// DeliveryTesterClient.java
package Client;

import StuffRelated.Stuff;

import java.io.ObjectOutputStream;
import java.util.Scanner;

public class DeliveryTesterClient {
    public static void run(Stuff currentStuff, ObjectOutputStream out) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            System.out.println(""\nDelivery Tester Menu:"");
            System.out.println(""1. View Profile"");
            System.out.println(""2. Send CustomerRequest back and request unit"");
            System.out.println(""3. If none, send null"");
            System.out.println(""0. Logout"");

            int choice = sc.nextInt(); sc.nextLine();

            switch (choice) {
                case 1:
                    currentStuff.showInfo();
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 0:
                    System.out.println(""Logging out..."");
                    return;
                default:
                    System.out.println(""Invalid choice."");
            }
        }
    }
}

// DonationOfficerClient.java
package Client;

import StuffRelated.Stuff;

import java.io.ObjectOutputStream;
import java.util.Scanner;

public class DonationOfficerClient {
    public static void run(Stuff currentStuff, ObjectOutputStream out) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            System.out.println(""\nDonation Officer Menu:"");
            System.out.println(""1. View Profile"");
            System.out.println(""2. Forward donor info to Preservation Officer"");
            System.out.println(""0. Logout"");

            int choice = sc.nextInt(); sc.nextLine();

            switch (choice) {
                case 1:
                    break;
                case 2:
                    break;
                case 0:
                    System.out.println(""Logging out..."");
                    return;
                default:
                    System.out.println(""Invalid choice."");
            }
        }
    }
}

// ManagerClient.java
package Client;

import StuffRelated.Stuff;

import java.io.ObjectOutputStream;
import java.util.Scanner;

public class ManagerClient {
    public static void run(Stuff currentStuff, ObjectOutputStream out) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            System.out.println(""\nManager Menu:"");
            System.out.println(""1. Send blood request"");
            System.out.println(""2. View all staff info"");
            System.out.println(""3. View all kit quantities"");
            System.out.println(""4. View blood unit details"");
            System.out.println(""0. Logout"");

            int choice = sc.nextInt(); sc.nextLine();

            switch (choice) {
                case 1:
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    break;
                case 0:
                    System.out.println(""Logging out..."");
                    return;
                default:
                    System.out.println(""Invalid choice."");
            }
        }
    }
}

// PreservationOfficerClient.java
package Client;

import StuffRelated.Stuff;

import java.io.ObjectOutputStream;
import java.util.Scanner;

public class PreservationOfficerClient {
    public static void run(Stuff currentStuff, ObjectOutputStream out) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            System.out.println(""\nPreservation Officer Menu:"");
            System.out.println(""1. View Profile"");
            System.out.println(""2. Enqueue blood unit from Donation Officer"");
            System.out.println(""3. Dequeue and send to DeliveryTester"");
            System.out.println(""4. Remove expired units"");
            System.out.println(""0. Logout"");

            int choice = sc.nextInt(); sc.nextLine();

            switch (choice) {
                case 1:
                    break;
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    break;
                case 0:
                    System.out.println(""Logging out..."");
                    return;
                default:
                    System.out.println(""Invalid choice."");
            }
        }
    }
}

// RegTesterClient.java
package Client;

import StuffRelated.Stuff;

import java.io.ObjectOutputStream;
import java.util.Scanner;

public class RegTesterClient {
    public static void run(Stuff currentStuff, ObjectOutputStream out) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            System.out.println(""\nRegTester Menu:"");
            System.out.println(""1. View Profile"");
            System.out.println(""2. Input Donor Info"");
            System.out.println(""0. Logout"");

            int choice = sc.nextInt(); sc.nextLine();

            switch (choice) {
                case 1:
                    break;
                case 2:
                    break;
                case 0:
                    System.out.println(""Logging out..."");
                    return;
                default:
                    System.out.println(""Invalid choice."");
            }
        }
    }
}

// KitManagement.java
package KitRelated;

import java.io.*;
import Message.*;

public class KitManagement {
    private int numberOfBag;
    private int numberOfNeedle;
    private int numberOfPipe;
    private int numberOfTestingKit;
    public KitManagement(int x, int y, int z, int w) {
        numberOfBag = x;
        numberOfNeedle = y;
        numberOfPipe = z;
        numberOfTestingKit = w;
    }

    public void loadKitData() {
        try (BufferedReader br = new BufferedReader(new FileReader(""C:\\Users\\win11\\OneDrive\\Documents\\BUET program\\project java\\javaProject\\data\\KitManagement.csv""))) {
            String line = br.readLine();
            String[] parts = line.strip().split("","");
            int bag = Integer.parseInt(parts[0]);
            int needle = Integer.parseInt(parts[1]);
            int pipe = Integer.parseInt(parts[2]);
            int testKit = Integer.parseInt(parts[3]);

            KitManagement kit = new KitManagement(bag, needle, pipe, testKit);
            System.out.println(""Kit data loaded successfully."");
        } catch (Exception e) {
            System.out.println(""Error loading kit data: "" + e.getMessage());
        }
    }

    public void setNumberOfBag(int numberOfBag) {
        this.numberOfBag = numberOfBag;
    }
    public void setNumberOfNeedle(int numberOfNeedle) {
        this.numberOfNeedle = numberOfNeedle;
    }

    public void saveToFile() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(""C:\\Users\\win11\\OneDrive\\Documents\\BUET program\\project java\\javaProject\\data\\KitManagement.csv""))) {
            writer.write(numberOfBag + "","" + numberOfNeedle + "","" + numberOfPipe + "","" + numberOfTestingKit);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void setNumberOfPipe(int numberOfPipe) {
        this.numberOfPipe = numberOfPipe;
    }
    public void setNumberOfTestingKit(int numberOfTestingKit) {
        this.numberOfTestingKit = numberOfTestingKit;
    }
    public int getNumberOfBag() {
        return numberOfBag;
    }
    public int getNumberOfNeedle() {
        return numberOfNeedle;
    }
    public int getNumberOfPipe() {
        return numberOfPipe;
    }
    public  int getNumberOfTestingKit(){return numberOfTestingKit;}

    public void showInfo() {
        System.out.println(numberOfBag + ""\t"" + numberOfNeedle + ""\t"" + numberOfPipe);
    }
    public KitMessage Alarm(KitManagement x) {
        KitMessage y = new KitMessage(x);
        return y;
    }
}

// AddingRequestMessage.java
package Message;

import BloodRelated.BloodUnit;
import java.io.Serializable;

public class AddingRequestMessage implements BaseMessage {
    private String from;
    private String to;
    private BloodUnit bloodUnit;
    public AddingRequestMessage(String from, String to, BloodUnit bloodUnit) {
        this.bloodUnit = bloodUnit;
        this.from = from;
        this.to = to;
    }
    public BloodUnit getBloodUnit() {
        return bloodUnit;
    }
    public String getFrom() {
        return from;
    }
    public String getTo() {
        return to;
    }

    @Override
    public String getSenderRole() {
        return from;
    }

    @Override
    public String getReceiverRole() {
        return to;
    }
}

// BaseMessage.java
package Message;

import java.io.Serializable;

public interface BaseMessage extends Serializable {
    String getSenderRole();
    String getReceiverRole();
}

// CustomerRequestMessage.java
package Message;

public class CustomerRequestMessage implements BaseMessage {
    private String from;
    private String to;
    private String bloodGroup;
    public CustomerRequestMessage(String from, String to, String bloodGroup) {
        this.from = from;
        this.to = to;
        this.bloodGroup = bloodGroup;
    }
    public String getFrom() {
        return from;
    }
    public String getTo() {
        return to;
    }
    public String getBloodGroup() {
        return bloodGroup;
    }
    @Override
    public String getSenderRole() {
        return from;
    }

    @Override
    public String getReceiverRole() {
        return to;
    }
}

// KitMessage.java
package Message;

import KitRelated.KitManagement;

public class KitMessage implements BaseMessage {
    public String Message = """";
    private static final String newLine = System.lineSeparator();
    public KitMessage(KitManagement km) {
        if(km.getNumberOfBag() == 0)
            Message += ""No bag left."";
        if(km.getNumberOfNeedle() == 0) {
            Message += newLine + ""No needle left."";
        }
        if (km.getNumberOfPipe() == 0) {
            Message += ""No pipe left."";
        }
        if (km.getNumberOfTestingKit() == 1) {
            Message += ""No testing kit left."";
        }
    }

    @Override
    public String getSenderRole() {
        return ""Server"";
    }

    @Override
    public String getReceiverRole() {
        return ""Manager"";
    }
}

// StockAlertMessage.java
package Message;

public class StockAlertMessage implements BaseMessage {
    private String message;

    public StockAlertMessage(String bloodGroup) {
        this.message = ""No unit available for blood group: "" + bloodGroup;
    }

    public String getMessage() {
        return message;
    }

    @Override
    public String toString() {
        return message;
    }
    public String getSenderRole() {
        return ""Server"";
    }

    @Override
    public String getReceiverRole() {
        return ""Manager"";
    }
}

// Server.java
package Server;

import java.io.*;
import java.net.*;
import java.util.*;
import Message.*;
import StuffRelated.*;
import BloodRelated.*;
import KitRelated.*;

public class Server {
    private static final int PORT = 12345;

    private static Map<String, ObjectOutputStream> clientOutputStreams = new HashMap<>();
    private static StuffList staffList = new StuffList();
    private static BloodUnitList bloodUnitList = new BloodUnitList();
    private static KitManagement kit = new KitManagement(10, 10, 10, 10);

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(PORT);
        System.out.println(""Server started on port "" + PORT);

        staffList.loadFromFile(""data/stufflist.csv"");
        bloodUnitList.loadAllFromFiles(""data"");

        while (true) {
            Socket clientSocket = serverSocket.accept();
            System.out.println(""Client connected: "" + clientSocket);
            new ClientHandler(clientSocket).start();
        }
    }

    static class ClientHandler extends Thread {
        private Socket socket;
        private ObjectOutputStream out;
        private ObjectInputStream in;
        private Stuff loggedInUser;

        public ClientHandler(Socket socket) {
            this.socket = socket;
        }

        public void run() {
            try {
                out = new ObjectOutputStream(socket.getOutputStream());
                in = new ObjectInputStream(socket.getInputStream());

                while (true) {
                    Object obj = in.readObject();

                    if (obj instanceof String) {
                        String role = (String) obj;
                        out.writeObject(""Enter PIN:"");
                        out.flush();

                        String pin = (String) in.readObject();
                        Stuff user = staffList.getStuffByRole(role);
                        if (user != null && pin.equals(user.getPin())) {
                            user.login(pin);
                            loggedInUser = user;
                            clientOutputStreams.put(role, out);
                            out.writeObject(""Login successful as "" + role);
                        } else {
                            out.writeObject(""Login failed. Try again."");
                        }
                        out.flush();
                    } else if (obj instanceof BaseMessage) {
                        BaseMessage msg = (BaseMessage) obj;
                        String target = msg.getReceiverRole();
                        ObjectOutputStream targetStream = clientOutputStreams.get(target);
                        if (targetStream != null) {
                            targetStream.writeObject(msg);
                            targetStream.flush();
                        } else {
                            System.out.println(""Target role offline or not registered: "" + target);
                        }
                    }
                }

            } catch (IOException | ClassNotFoundException e) {
                System.out.println(""Client disconnected or error: "" + e.getMessage());
            } finally {
                try {
                    socket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (loggedInUser != null) {
                    clientOutputStreams.remove(loggedInUser.getRole());
                    loggedInUser.logout();
                }
            }
        }
    }
}

// DeliveryTester.java
package StuffRelated;

import BloodRelated.BloodUnit;
import KitRelated.KitManagement;
import Message.AddingRequestMessage;
import Message.CustomerRequestMessage;

public class DeliveryTester extends Stuff {

    public DeliveryTester(String name, String id, String contact, String pin) {
        super(name, id, contact, pin);
        setRole(""Delivery Tester"");
    }

    public void profilePresenter() {
        showInfo();
    }

    public void kitInfoUpdater(int usedTestingKit, KitManagement x) {
        x.setNumberOfTestingKit(x.getNumberOfTestingKit() - usedTestingKit);
        x.saveToFile();
    }

    public CustomerRequestMessage testBloodUnit(AddingRequestMessage bloodUnit, boolean passed) {
        if (passed) {
            System.out.println(""Blood test passed for donor: "" + bloodUnit.getBloodUnit().getBloodGroup());
            return null;
        } else {
            return new CustomerRequestMessage(""DeliveryTester"", ""PreservationOfficer"", bloodUnit.getBloodUnit().getBloodGroup());
        }
    }
}

// DonationOfficer.java
package StuffRelated;

import BloodRelated.BloodUnit;
import BloodRelated.BloodUnitList;
import KitRelated.KitManagement;
import Message.AddingRequestMessage;

import java.util.ArrayList;

public class DonationOfficer extends Stuff {

    public DonationOfficer(String name, String id, String contact, String pin) {
        super(name, id, contact, pin);
        setRole(""Donation Officer"");
    }

    public void kitInfoUpdater(int usedPipe, int usedBag, KitManagement x) {
        x.setNumberOfBag(x.getNumberOfBag() - usedBag);
        x.setNumberOfPipe(x.getNumberOfPipe() - usedPipe);
        x.saveToFile();
    }

    public void profileShower() {
        showInfo();
    }

    public AddingRequestMessage anqueueApproval(boolean approved, BloodUnit bloodUnit) {
        if(approved)
            return new AddingRequestMessage(""DonationOfficer"", ""DonationOfficer"", bloodUnit);
        return null;
    }
}

// Manager.java
package StuffRelated;

import BloodRelated.BloodUnit;
import BloodRelated.BloodUnitList;
import KitRelated.KitManagement;
import Message.CustomerRequestMessage;

import java.util.ArrayList;
import java.util.List;

public class Manager extends Stuff {

    public Manager(String name, String id, String contact, String pin) {
        super(name, id, contact, pin);
        setRole(""Manager"");
    }

    public void profilePresenter() {
        showInfo();
    }

    public void showList(StuffList x) {
        x.printAll();
    }

    public void receiveKit(KitManagement x, int a, int b, int c, int d) {
        x.setNumberOfBag(x.getNumberOfBag() + a);
        x.setNumberOfNeedle(x.getNumberOfNeedle() + b);
        x.setNumberOfPipe(x.getNumberOfPipe() + c);
        x.setNumberOfTestingKit(x.getNumberOfTestingKit() + d);
    }

    public void showBloodInfo(BloodUnitList x) {
        String[] groups = {""A+"", ""A-"", ""B+"", ""B-"", ""AB+"", ""AB-"", ""O+"", ""O-""};
        for (String group : groups) {
            List<BloodUnit> list = x.fetchBlood(group);
            for (BloodUnit unit : list) {
                unit.showInfo();
            }
        }
    }

    public CustomerRequestMessage CustomerRequest(String bg) {
        return new CustomerRequestMessage(""Manager"", ""PreservationOfficer"", bg);
    }
}

// PreservationOfficer.java
package StuffRelated;

import BloodRelated.BloodUnit;
import BloodRelated.BloodUnitList;
import Message.AddingRequestMessage;
import Message.CustomerRequestMessage;

import java.util.ArrayList;
import java.util.List;

public class PreservationOfficer extends Stuff {

    public PreservationOfficer(String name, String id, String phone, String pin) {
        super(name, id, phone, pin);
    }

    public void checkExpiredUnits(BloodUnitList bloodList) {
        List<BloodUnit> expired = bloodList.getExpiredUnits();
        if (expired.isEmpty()) {
            System.out.println("" No expired blood units."");
        } else {
            System.out.println(""️ Expired blood units:"");
            for (BloodUnit unit : expired) {
                System.out.println(unit);
            }
        }
    }
    public void enqueueBloodUnit(AddingRequestMessage bloodUnit, BloodUnitList bloodUnitList) {
        List<BloodUnit> groupList = bloodUnitList.fetchBlood(bloodUnit.getBloodUnit().getBloodGroup());
        BloodUnit blood = bloodUnit.getBloodUnit();
        if (groupList != null) {
            groupList.add(blood);
            System.out.println(""Blood unit added for group "" + blood.getBloodGroup());
        } else {
            System.out.println(""Blood group list not found."");
        }
    }
    public AddingRequestMessage dequeueBloodUnit(AddingRequestMessage bloodUnit, BloodUnitList bloodUnitList) {
        ArrayList<BloodUnit> x = bloodUnitList.fetchBlood(bloodUnit.getBloodUnit().getBloodGroup());
        BloodUnit y = bloodUnitList.dequeue(x);
        return new AddingRequestMessage(""PreservationOfficer"",""DeliveryTester"",y);
    }

    public void removeExpiredBloodUnits(BloodUnitList bloodUnitList) {
        String[] groups = {""A+"", ""A-"", ""B+"", ""B-"", ""AB+"", ""AB-"", ""O+"", ""O-""};
        for (String group : groups) {
            ArrayList<BloodUnit> list = bloodUnitList.fetchBlood(group);
            for (int i = 0; i < list.size(); i++) {
                BloodUnit unit = list.get(i);
                if (unit.isExpired()) {
                    list.remove(i);
                }
                else break;
            }
        }
        bloodUnitList.saveAllToFiles(""C:\\Users\\win11\\OneDrive\\Documents\\BUET program\\project java\\javaProject\\data"");
        System.out.println(""All expired blood units removed successfully."");
    }

    public void removeBloodUnit(BloodUnitList bloodUnitList, String bloodGroup, int[] selectedIDX) {
        ArrayList<BloodUnit> units = bloodUnitList.fetchBlood(bloodGroup);
        for(int i=0; i<selectedIDX.length; i++) {
            bloodUnitList.leave(units, selectedIDX[i]);
            for(int j=i+1; j<selectedIDX.length; j++) {
                if(selectedIDX[j] > selectedIDX[i]) {
                    selectedIDX[j]--;
                }
            }
        }
    }
}

// RegTester.java
package StuffRelated;

import BloodRelated.BloodUnit;
import BloodRelated.BloodUnitList;
import BloodRelated.Person;
import KitRelated.KitManagement;
import Message.AddingRequestMessage;

import java.time.LocalDate;

public class RegTester extends Stuff {
    private Person donor;

    public RegTester(String name, String id, String contact, String pin) {
        super(name, id, contact, pin);
        donor = null;
        setRole(""Registration Tester"");
    }

    public Person registerDonor(String name, String id, String bg) {
        donor = new Person(name, id, bg);
        return donor;
    }

    public AddingRequestMessage checkHealth(boolean x, Person person) {
        if(x) {
            LocalDate today = LocalDate.now();
            LocalDate expiry = today.plusDays(14);
            BloodUnit q = new BloodUnit(person.getName(), person.getNID(), person.getBloodGroup(), today, expiry);
            return new AddingRequestMessage(""RegTester"",""DonationOfficer"",q);
        }
        return null;
    }
    public void kitInfoUpdater(int usedTestingKit, KitManagement x) {
        x.setNumberOfTestingKit(x.getNumberOfTestingKit() - usedTestingKit);
        x.saveToFile();
    }
}

// Stuff.java
package StuffRelated;

public class Stuff {
    private String name;
    private String id;
    private String phone;
    private String pin;
    private boolean isLoggedIn;
    private String role = ""Undefined"";

    public Stuff(String name, String id, String phone, String pin) {
        this.name = name;
        this.id = id;
        this.phone = phone;
        this.pin = pin;
        this.isLoggedIn = false;
    }

    public String getName() { return name; }
    public String getId() { return id; }
    public String getPhone() { return phone; }
    public String getPin() { return pin; }
    public boolean isLoggedIn() { return isLoggedIn; }
    public String getRole() { return role; }

    public void setRole(String role) {
        this.role = role;
    }

    public void login(String pin) {
        if(pin.equals(this.pin)) {
            this.isLoggedIn = true;
            System.out.println(name + "" logged in."");
        }
    }

    public void logout() {
        this.isLoggedIn = false;
        System.out.println(name + "" logged out."");
    }

    public void showInfo() {
        System.out.println(""Name: "" + name);
        System.out.println(""ID: "" + id);
        System.out.println(""Phone: "" + phone);
        System.out.println(""Role: "" + role);
        System.out.println(""Login Status: "" + (isLoggedIn ? ""Logged In"" : ""Logged Out""));
    }

    @Override
    public String toString() {
        return name + "" ("" + id + ""), Role: "" + role + "", Status: "" + (isLoggedIn ? ""In"" : ""Out"");
    }
}

// StuffList.java
package StuffRelated;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class StuffList {
    private List<Stuff> stuff = new ArrayList<>();

    public void loadFromFile(String filename) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            int i = 0;
            while ((line = br.readLine()) != null && i < 5) {
                String[] parts = line.split("","", -1);
                if (parts.length >= 4) {
                    String name = parts[0];
                    String id = parts[1];
                    String phone = parts[2];
                    String pin = parts[3];

                    Stuff s = null;
                    if (i == 0) {
                        s = new Manager(name, id, phone, pin);
                    } else if (i == 1) {
                        s = new RegTester(name, id, phone, pin);
                    } else if (i == 2) {
                        s = new DonationOfficer(name, id, phone, pin);
                    } else if (i == 3) {
                        s = new PreservationOfficer(name, id, phone, pin);
                    } else if (i == 4) {
                        s = new DeliveryTester(name, id, phone, pin);
                    }
                    if (s != null) stuff.add(s);
                    i++;
                }
            }
        } catch (IOException e) {
            System.err.println(""Error loading staff from file: "" + e.getMessage());
        }
    }

    public Stuff getById(String id) {
        for (Stuff s : stuff) {
            if (s.getId().equals(id)) return s;
        }
        return null;
    }

    public List<Stuff> getAll() {
        return stuff;
    }

    public void printAll() {
        for (Stuff s : stuff) {
            System.out.println(s);
        }
    }

    public Stuff getStuffByRole(String role) {
        for(int i=0; i<stuff.size(); i++) {
            if(stuff.get(i).getRole() == role)
                return stuff.get(i);
        }
        return null;
    }
}"
S7GCmhy8,add subscriber class on HTML body,arie_cristianD,PHP,Thursday 24th of July 2025 10:15:38 PM CDT,"add_filter( 'body_class', 'add_subscriber_body_class' );
function add_subscriber_body_class( $classes ) {
	if ( is_user_logged_in() ) {
		$user = wp_get_current_user();
		if ( in_array( 'subscriber', (array) $user->roles ) ) {
			$classes[] = 'subscriber';
		}
	}
	return $classes;
}"
ZPnxuWiq,use Custom Post Template for Image Post Format,arie_cristianD,PHP,Thursday 24th of July 2025 09:10:15 PM CDT,"add_filter( 'theme_mod_jnews_single_blog_template', 'change_jnews_single_post_template' );
add_filter( 'theme_mod_jnews_single_blog_custom', 'change_jnews_custom_single_post_template' );

/**
 * Change JNews single post tempalte with custom
 *
 * @param string $template Template name.
 * @return string
 */
function change_jnews_single_post_template( $template ) {
	if ( 'image' === get_post_format() ) {
		return 'custom';
	}
	return $template;
}

/**
 * Change JNews custom post template id.
 *
 * @param int|string $template Single Post Template ID.
 * @return integer|string
 */
function change_jnews_custom_single_post_template( $template ) {
	if ( 'image' === get_post_format() ) {
		return 248; /* Change this with your Custom Single Post Template ID  */
	}
	return $template;
}"
F56ghZJU,disable featured image on Image Post Format,arie_cristianD,PHP,Thursday 24th of July 2025 09:07:45 PM CDT,"add_filter( 'theme_mod_jnews_single_show_featured', 'custom_disable_featured_image' );

/**
 * Disable Featured Image on Image Post Format.
 *
 * @param boolean $flag If featured image showing on single post.
 * @return boolean
 */
function custom_disable_featured_image( $flag ) {
	if ( 'image' === get_post_format() ) {
		return false;
	}
	return $flag;
}"
RkTr0MnR,add image post format option,arie_cristianD,PHP,Thursday 24th of July 2025 09:02:13 PM CDT,"add_action( 'after_setup_theme', 'add_new_post_format', 11 );

/**
 * Add Image post format option
 *
 * @return void
 */
function add_new_post_format() {
		add_theme_support( 'post-formats', array( 'gallery', 'video', 'image' ) );
}"
TpERxfG7,error,sambeano7,JavaScript,Thursday 24th of July 2025 08:36:25 PM CDT,Error: Can't add new command when connection is in closed state
0TMjZkdx,Code for database,sambeano7,JavaScript,Thursday 24th of July 2025 08:35:13 PM CDT,"require('dotenv').config();
const mysql = require('mysql2/promise');

module.exports = mysql.createConnection({
    host: 'localhost',
    user: '***',
    password: '***********',
    database: '******',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0,
    maxIdle: 0, // Disable maxIdle - connections stay in the pool even if idle
    idleTimeout: 60000, // Close idle connections after 60 seconds (should be much less than MySQL's wait_timeout)
    enableKeepAlive: true // Enable TCP keep-alive packets
});"
FL9MGfm1,"Geekya ""Cosmetic Collector"" Template",loinbread,HTML,Thursday 24th of July 2025 08:23:23 PM CDT,"<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Standalone Equipment</strong> <span class=""text-smaller"">Remaining  <span class=""text-muted""><i>- 9,300 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Bunny's Bounty Bucket
      missing_entitlement/Merrick's Tankard
      missing_entitlement/Mistletoe Fishing Rod
      missing_entitlement/Snowbound Ship Lantern
      missing_entitlement/Springshell Pocket Watch
      missing_entitlement/Winter's Fire Compass
    </profile-favorite>
</details>
<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Standalone Weapons</strong> <span class=""text-smaller"">Remaining  <span class=""text-muted""><i>- 6,000 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Ancient Cutlass
      missing_entitlement/Blooming Barrel Blunderbuss
      missing_entitlement/Flamingo Pistol
      missing_entitlement/Frozen Ashes Blunderbuss
      missing_entitlement/Ruby Stinger Cutlass
    </profile-favorite>
</details>
<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Standalone Clothing</strong> <span class=""text-smaller"">Remaining  <span class=""text-muted""><i>- 8,700 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Belle's Hat
      missing_entitlement/Grimm's Jacket
      missing_entitlement/Ocean Hunter Jacket
      missing_entitlement/Sudds' Jacket
    </profile-favorite>
</details>
<details class=""card mb-3"" open>
  <summary class=""card-header text-larger bg-success-subtle""><strong>Standalone Vanity Cosmetics</strong> <span class=""text-smaller"">Completed</span></summary>
</details>
<details class=""card mb-3"" open>
  <summary class=""card-header text-larger bg-success-subtle""><strong>Standalone Ship Cosmetics</strong> <span class=""text-smaller"">Completed</span></summary>
</details>
<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Frostbite Set</strong> <span class=""text-smaller""><span class=""text-muted"">(Season One)</span> Remaining <span class=""text-muted""><i>- 5,400 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Frostbite Belt
      missing_entitlement/Frostbite Boots
      missing_entitlement/Frostbite Dress
      missing_entitlement/Frostbite Gloves
      missing_entitlement/Frostbite Hat
      missing_entitlement/Frostbite Jacket
      missing_entitlement/Frostbite Eyepatch
      missing_entitlement/Frostbite Hook
      missing_entitlement/Frostbite Pegleg
    </profile-favorite>
</details>
<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Lucky Hand Set</strong> <span class=""text-smaller""><span class=""text-muted"">(Season Two)</span> Remaining <span class=""text-muted""><i>- 12,600 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Lucky Hand Belt
      missing_entitlement/Lucky Hand Boots
      missing_entitlement/Lucky Hand Gloves
      missing_entitlement/Lucky Hand Hat
      missing_entitlement/Lucky Hand Jacket
      missing_entitlement/Lucky Hand Eyepatch
      missing_entitlement/Lucky Hand Lustrous Hair
      missing_entitlement/Lucky Hand Styled Hair
      missing_entitlement/Lucky Hand Hook
      missing_entitlement/Lucky Hand Pegleg
      missing_entitlement/Lucky Hand Blunderbuss
      missing_entitlement/Lucky Hand Cutlass
      missing_entitlement/Lucky Hand Throwing Knives
      missing_entitlement/Lucky Hand Bucket
      missing_entitlement/Lucky Hand Compass
      missing_entitlement/Lucky Hand Lantern
      missing_entitlement/Lucky Hand Pocket Watch
      missing_entitlement/Lucky Hand Speaking Trumpet
      missing_entitlement/Lucky Hand Spyglass
      missing_entitlement/Lucky Hand Tankard
    </profile-favorite>
</details>
<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Daring Deceiver Set</strong> <span class=""text-smaller""><span class=""text-muted"">(Season Three)</span> Remaining <span class=""text-muted""><i>- 3,600 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Daring Deceiver's Belt
      missing_entitlement/Daring Deceiver's Boots
      missing_entitlement/Daring Deceiver's Dress
      missing_entitlement/Daring Deceiver's Gloves
      missing_entitlement/Daring Deceiver's Hook
      missing_entitlement/Daring Deceiver's Pegleg
    </profile-favorite>
</details>
<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Wicked Web Set</strong> <span class=""text-smaller""><span class=""text-muted"">(Season Four)</span> Remaining <span class=""text-muted""><i>- 7,200 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Wicked Web Belt
      missing_entitlement/Wicked Web Boots
      missing_entitlement/Wicked Web Dress
      missing_entitlement/Wicked Web Gloves
      missing_entitlement/Wicked Web Hat
      missing_entitlement/Wicked Web Jacket
      missing_entitlement/Wicked Web Shirt
      missing_entitlement/Wicked Web Trousers
      missing_entitlement/Wicked Web Beard
      missing_entitlement/Wicked Web Eyepatch
      missing_entitlement/Wicked Web Hook
    </profile-favorite>
</details>
<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Bell Brigade Set</strong> <span class=""text-smaller""><span class=""text-muted"">(Season Five)</span> Remaining <span class=""text-muted""><i>- 5,400 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Bell Brigade Dress
      missing_entitlement/Bell Brigade Gloves
      missing_entitlement/Bell Brigade Hat
      missing_entitlement/Bell Brigade Trousers
      missing_entitlement/Bell Brigade Eyepatch
      missing_entitlement/Bell Brigade Streaked Hair
      missing_entitlement/Bell Brigade Tied Hair
      missing_entitlement/Bell Brigade Hook
      missing_entitlement/Bell Brigade Pegleg
    </profile-favorite>
</details>
<details class=""card mb-3"">
  <summary class=""card-header text-larger bg-danger-subtle""><strong>Naval Commander Set</strong> <span class=""text-smaller""><span class=""text-muted"">(Season Six)</span> Remaining <span class=""text-muted""><i>- 3,000 Doubloons</i></span></span></summary>
    <hr class=""my-1"">
    <profile-favorite>
      missing_entitlement/Naval Commander Dress
      missing_entitlement/Naval Commander Jacket
      missing_entitlement/Naval Commander Eyepatch
      missing_entitlement/Naval Commander Long Hair
      missing_entitlement/Naval Commander Pegleg
    </profile-favorite>
</details>"
Z5EXgLEu,"Geekya ""Insider Inspector"" Template",loinbread,HTML,Thursday 24th of July 2025 08:22:44 PM CDT,"<div class=""progress"" style=""height: 32px;"">
  <div class=""progress-bar bg-info"" role=""progressbar"" aria-valuenow=""13"" aria-valuemin=""0"" aria-valuemax=""33"" style=""width: 20%""><span class=""text-white""><span class=""text-large""><b>20%</span> ᴜɴʟᴏᴄᴋᴇᴅ</b></span></div>
  <div class=""progress-bar progress-bar-striped bg-info"" role=""progressbar"" aria-valuenow=""21"" aria-valuemin=""0"" aria-valuemax=""33"" style=""width: 30%""><span class=""text-white"">Remaining Silver Blade Cosmetics</span></div>
  <div class=""progress-bar progress-bar-striped bg-success"" role=""progressbar"" aria-valuenow=""0"" aria-valuemin=""0"" aria-valuemax=""33"" style=""width: 50%""><span class=""text-white"">Remaining Sapphire Blade Cosmetics</span></div>
</div>"
m1r1w570,"Geekya ""Notorious Namer"" Template",loinbread,HTML,Thursday 24th of July 2025 08:22:06 PM CDT,"<div class=""row mx-0"">
  <div class=""col-6 col-sm-4"">
    <div class=""card bg-danger bg-opacity-50 h-100"" style=""width: 25rem;"">
      <img class=""card-img-top"" src=""https://geekya.com/sot-pv-images/sotprofilecdn.azureedge.net/8bc9cd4e0538186a7dae1d13aa9579bcb969b596a07eb1d1100e0b93d243d74c.png"" alt=""Card image cap"">
      <div class=""card-body"">
        <h2 class=""card-title""><strong>Golden Hour</strong> Sails</h2>
        <p class=""card-text"">A pirate like you knows just when their ship will perfectly capture the light.<br></p>
      </div>
    </div>
  </div>
  <div class=""col-6 col-sm-4"">
    <div class=""card bg-danger bg-opacity-50 h-100"" style=""width: 25rem;"">
      <img class=""card-img-top"" src=""https://geekya.com/sot-pv-images/sotprofilecdn.azureedge.net/50b166e68f5e472d33124a1a7d3edbd3f24c13cd2b3302438724594b094617b5.png"" alt=""Card image cap"">
      <div class=""card-body"">
        <h4 class=""card-title"">Hat of <strong>Unfeasibly Glorious Fame</strong></h4>
        <p class=""card-text"">A reward gifted for a feat of piratical prowess so daring and distinguished, it echoed far beyond the Devil's Shroud.</p>
      </div>
    </div>
  </div>
  <div class=""col-6 col-sm-4"">
    <div class=""card bg-danger bg-opacity-50 h-100"" style=""width: 25rem;"">
      <img class=""card-img-top"" src=""https://geekya.com/sot-pv-images/sotprofilecdn.azureedge.net/8582295cafe306e16708996a3bd6439a996c0e17f22ea236198c3ffb44d2e30e.png"" alt=""Card image cap"">
      <div class=""card-body"">
        <h4 class=""card-title""><strong>Fashionista Finery</strong> Gloves</h4>
        <p class=""card-text"">The eyes of the pirate fashion world are everywhere. Turn enough heads with your daring outfits, and these luxurious gloves may find their way to you.</p>
      </div>
    </div>
  </div>
</div>
<br>
<div class=""row mx-0"">
  <div class=""col-6 col-sm-4"">
    <div class=""card bg-danger bg-opacity-50 h-100"" style=""width: 25rem;"">
      <img class=""card-img-top"" src=""https://geekya.com/sot-pv-images/sotprofilecdn.azureedge.net/7934f643250bfdaa8ca23748a365b63e575114c4166f59da3e8283f6a9a1507f.png"" alt=""Card image cap"">
      <div class=""card-body"">
        <h4 class=""card-title""><strong>Affiliate Alliance</strong> Sails</h4>
        <p class=""card-text"">With their skull and knot motif, these sails mark out members of an ocean-spanning pirate alliance who value friendship and fun above all.</p>
      </div>
    </div>
  </div>
  <div class=""col-6 col-sm-4"">
    <div class=""card bg-danger bg-opacity-50 h-100"" style=""width: 25rem;"">
      <img class=""card-img-top"" src=""https://geekya.com/sot-pv-images/sotprofilecdn.azureedge.net/a2e542b06eb9ec40536f082c7983f45bfab1e259db31fb7fdd6a92024bcc3e54.png"" alt=""Card image cap"">
      <div class=""card-body"">
        <h3 class=""card-title""><strong>Affiliate Alliance</strong> Tattoo</h3>
        <p class=""card-text"">When you want to show the world you received a prize from your pirate peers - think ink!</p>
      </div>
    </div>
  </div>
  <div class=""col-6 col-sm-4"">
    <div class=""card bg-danger bg-opacity-50 h-100"" style=""width: 25rem;"">
      <img class=""card-img-top"" src=""https://geekya.com/sot-pv-images/sotprofilecdn.azureedge.net/0238241d466cafee663da769620f468e5db2e37d6c1c19fc4ef49a1aca554cac.png"" alt=""Card image cap"">
      <div class=""card-body"">
        <h4 class=""card-title"">The <strong>Serpent's Lie</strong> Sails</h4>
        <p class=""card-text"">A modern Partnership of Sea of Thieves pirates act as custodians of this design from a grand age of exploration.</p>
      </div>
    </div>
  </div>
</div>"
3qmpENa0,Geekya Profile,loinbread,HTML,Thursday 24th of July 2025 08:21:26 PM CDT,"guild/e4ac3d1d-a218-462a-aa05-50abad2aa8c6/Our Flag Means Frens
guild/aff84988-6b8c-459d-a244-39ae3148841c/Huakland Tuah Empire
~### <div class=""p-3 bg-dark"">Legendary Completionist <div class=""text-smaller text-muted"" align=""left"">&nbsp; <b>5 / 10</b> Factions Completed</div></div>
~<a href=""%profile%/reputation?tab=BilgeRats&hideCompleted=1"" class=""badge text-large"" style=""background-color:peru;"">Bilge Rats</a> <b>(10 Commendations Remaining)</b>
rep/BilgeRats/mercenary-voyages/Charitable Giving for All
rep/BilgeRats/mercenary-voyages/Bountiful Giving for All
rep/BilgeRats/chests-of-fortune/Fortune's Favour
rep/BilgeRats/chests-of-fortune/Reaper's Riches
~#### Reapers Rising:
rep/BilgeRats/reapers-rising/Seal of Approval
rep/BilgeRats/reapers-rising/Ghostly Reaper Raid
rep/BilgeRats/reapers-rising/Fortunate Reaper Raid
rep/BilgeRats/reapers-rising/Sunken Reaper Raid
rep/BilgeRats/reapers-rising/Following the Flame
rep/BilgeRats/reapers-rising/Reaping Bones
~<a href=""%profile%/reputation?tab=TallTales&hideCompleted=1"" class=""badge text-large"" style=""background-color:darkgoldenrod;"">Tall Tales</a> <span class=""text-muted"">(Completed)</span>
~<a href=""%profile%/reputation?tab=AthenasFortune&hideCompleted=1"" class=""badge text-large"" style=""background-color:turquoise;"">Athena's Fortune</a> <b>(1 Commendation Remaining)</b>
rep/AthenasFortune/Veil Seeker
~<a href=""%profile%/reputation?tab=ReapersBones&hideCompleted=1"" class=""badge text-large"" style=""background-color:firebrick;"">Reaper's Bones</a> <b>(7 Commendations Remaining)</b>
rep/ReapersBones/Hunter's Call Heisted
rep/ReapersBones/Voyager of Burning Flame
rep/ReapersBones/Sailor of Scorching Seas
rep/ReapersBones/Reaper of Servant's Offerings
rep/ReapersBones/Reaper of Disciple's Offerings
rep/ReapersBones/Reaper of Master's Offerings
rep/ReapersBones/Reaper of Ashen Offerings
~<a href=""%profile%/reputation?tab=GoldHoarders&hideCompleted=1"" class=""badge text-large"" style=""background-color:gold;"">Gold Hoarders</a> <span class=""text-muted"">(Completed)</span>
~<a href=""%profile%/reputation?tab=OrderOfSouls&hideCompleted=1"" class=""badge text-large"" style=""background-color:palevioletred;"">Order of Souls</a> <span class=""text-muted"">(Completed)</span>
~<a href=""%profile%/reputation?tab=MerchantAlliance&hideCompleted=1"" class=""badge text-large"" style=""background-color:deepskyblue;"">Merchant Alliance</a> <b>(1 Commendation Remaining)</b>
rep/MerchantAlliance/Cast Iron Merchant
~<a href=""%profile%/reputation?tab=PirateLord&hideCompleted=1"" class=""badge text-large"" style=""background-color:slateblue;"">Guardians of Fortune</a> <span class=""text-muted"">(Completed)</span>
~<a href=""%profile%/reputation?tab=Flameheart&hideCompleted=1"" class=""badge text-large"" style=""background-color:orangered;"">Servants of the Flame</a> <span class=""text-muted"">(Completed)</span>
~<a href=""%profile%/reputation?tab=HuntersCall&hideCompleted=1"" class=""badge text-large"" style=""background-color:slategray;"">Hunter's Call</a> <b>(14 Commendations Remaining)</b>
~#### Call of the Hunter Commendations:
rep/HuntersCall/call-of-the-hunter/Call of the Hunter
rep/HuntersCall/call-of-the-hunter/Hunter of the Wide Sea
rep/HuntersCall/call-of-the-hunter/Worthy Emissary of Hunters
rep/HuntersCall/call-of-the-hunter/Dedicated Emissary of Hunters
rep/HuntersCall/call-of-the-hunter/Esteemed Emissary of Hunters
rep/HuntersCall/call-of-the-hunter/Hunter of Grisly Megalodon Spoils
rep/HuntersCall/call-of-the-hunter/Master Hunter of Pristine Megalodon Spoils
rep/HuntersCall/call-of-the-hunter/Hunter of the Grisly Maw
rep/HuntersCall/call-of-the-hunter/Master Hunter of the Pristine Maw
rep/HuntersCall/call-of-the-hunter/Eye-Catching
~#### Fishing Commendations:
rep/HuntersCall/devilfishes/Hunter of the Forsaken Devilfish
rep/HuntersCall/wreckers/Hunter of the Blackcloud Wrecker
rep/HuntersCall/merrick's-accolades/Legendary Hunter of the Sea of Thieves
~### <div class=""p-3 bg-dark"">Cherished Completionist<div class=""text-smaller text-muted"" align=""left"">&nbsp; <b>14</b> Cherished Trophies Remaining</div></div>
missing_entitlement/Fearsome Flame
missing_entitlement/Coral Calamity
missing_entitlement/Gone Fishin'
missing_entitlement/Digging for Victory
entitlement/ShipTrinket/Raven Islehopper Plaque
entitlement/ShipTrinket/Shadow Stormfish Plaque
~### <div class=""p-3 bg-dark"">Cosmetic Collector<div class=""text-smaller text-muted"" align=""left"">&nbsp; <b>62,400 / 152,210</b> Doubloons Remaining</div></div>
rich_template/87tDxMupgvM/cosmetic-collector
~### <div class=""p-3 bg-dark"">Insider Inspector <div class=""text-smaller text-muted"" align=""left"">&nbsp; <b>13 / 66</b> Weeks Completed</div></div>
rich_template/mDAJNYEwVTj/insider-inspector
missing_entitlement/Silver Blade Trinket
~### <div class=""p-3 bg-dark"">Notorious Namer<div class=""text-smaller text-muted"" align=""left"">&nbsp; <b>0 / 6</b> Cosmetics Acquired</div></div>
rich_template/IROppyqOYKZ/notorious-namer"
JXZytyR7,dataNone,TestGuy1,JSON,Thursday 24th of July 2025 06:00:08 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '340339cd0010a7c7ee75f304db1924a4d83c5072d7d3efe26c4527e99030ec6a35a77f10727e2c36670ba4287535d63481f13476046e1f87db50a26d59b4b128eacfd8a164e72e90849232cd6112b6f639295b78775d968bf358ee51ea31783d4f16fa80decaf12a621ad6c5e94648d4ebc1f2673a886087b0a5335bd1bf96b0',
  otherdata: [
    '63e25637b40dfd79e7309af26592a303',
    '34f445007384548eb9d33cfb8b8377b5',
    '9b1108c320b9043f7574cb6c5b8d5730',
    '3fea8af88f2881695638db71badac854',
    '11c87b6d4aecdbd7cae4b6fbed41f935',
    '0b15ff7d47f1f3258eaaf5a625a3e232',
    'c53d6b235e3749ea5f4ae4740a40fa89',
    '2d77881cec8ae941ec153e4b595442c2'
  ]
}"
BwjfgAcX,VidOptimo,Deus358,XML,Thursday 24th of July 2025 05:43:48 AM CDT,"<persona>
    <identity>
        <name>VidOptimo</name>
        <description>You are a world-class YouTube Content and SEO Strategist, an AI-powered expert with a deep understanding of the YouTube algorithm, search optimization, and audience engagement psychology.</description>
        <purpose>To provide YouTubers with a complete, ready-to-use optimization package for their video uploads.</purpose>
    </identity>

    <core_objective>
        <summary>To analyze a user's video concept and generate a comprehensive set of highly optimized metadata—including titles, descriptions, hashtags, and tags—designed to maximize visibility, click-through rate (CTR), and audience retention.</summary>
    </core_objective>

    <system name=""Layered Analysis & Generation System"">
        <description>You will process user input through a multi-layered system to ensure a holistic and effective optimization strategy.</description>
        <layer id=""1"">
            <title>Concept & Keyword Analysis</title>
            <tasks>
                <task>Deconstruct the user's `Input` to identify the primary topic, niche, and target audience.</task>
                <task>Extract core keywords and identify related long-tail keywords, semantic variations, and common user search queries.</task>
            </tasks>
        </layer>
        <layer id=""2"">
            <title>Title Engineering</title>
            <description>Based on the keyword analysis, generate three distinct title options, each with a specific psychological angle:</description>
            <options>
                <option id=""1"">
                    <name>The SEO Powerhouse</name>
                    <strategy>A clear, keyword-rich title optimized for search discovery.</strategy>
                    <example>""How to Bake Sourdough Bread: A Beginner's Guide""</example>
                </option>
                <option id=""2"">
                    <name>The Curiosity Gap</name>
                    <strategy>A compelling, high-CTR title that creates intrigue and encourages clicks.</strategy>
                    <example>""The 5 Mistakes Everyone Makes When Baking Sourdough""</example>
                </option>
                <option id=""3"">
                    <name>The Community Insider</name>
                    <strategy>A title that uses niche-specific language or references to appeal directly to the target community.</strategy>
                    <example>""My Secret to a Perfect Sourdough Ear Every Time""</example>
                </option>
            </options>
        </layer>
        <layer id=""3"">
            <title>Description Architecture</title>
            <description>Construct a 5000-character optimized description using the following structure:</description>
            <structure>
                <item>
                    <name>Hook (First 3 Lines)</name>
                    <details>Repeat the main title keywords and present a compelling hook to be visible above the ""Show more"" fold.</details>
                </item>
                <item>
                    <name>Detailed Summary</name>
                    <details>An engaging 2-3 paragraph summary of the video content, naturally weaving in primary and secondary keywords.</details>
                </item>
                <item>
                    <name>Timestamps</name>
                    <details>A placeholder for the user to add timestamps, which are crucial for SEO and user experience.</details>
                </item>
                <item>
                    <name>Call-to-Action (CTA)</name>
                    <details>Prompts for subscribing, liking, and checking out other relevant content/playlists.</details>
                </item>
                <item>
                    <name>Links</name>
                    <details>Placeholders for social media, affiliate links, or other relevant resources.</details>
                </item>
                <item>
                    <name>Keyword & Hashtag Block</name>
                    <details>A dedicated section at the end for 3-5 key hashtags.</details>
                </item>
            </structure>
        </layer>
        <layer id=""4"">
            <title>Tag & Hashtag Matrix</title>
            <tasks>
                <task name=""Generate Tags"">
                    <description>Generate a comprehensive list of tags (keywords) that cover all relevant search angles. The list should be a mix of:</description>
                    <tag_types>
                        <type name=""Broad Tags"">High-level keywords for the general topic (e.g., `Baking`, `Cooking`).</type>
                        <type name=""Specific Tags"">Long-tail keywords that describe the video's focus (e.g., `sourdough bread recipe for beginners`, `how to get a good crumb`).</type>
                        <type name=""Compound Tags"">Multi-word phrases that users are likely to search for.</type>
                        <type name=""Misspelling/Alternate Tags"">Common variations or misspellings (e.g., `sour dough`, `sowerdough`).</type>
                    </tag_types>
                </task>
                <task name=""Generate Hashtags"">Provide 5-7 optimized hashtags for the video.</task>
            </tasks>
        </layer>
    </system>

    <io_formatting>
        <input>
            <type>The user will provide a `video_topic` or a short `video_summary`.</type>
        </input>
        <output>
            <restrictions>
                <restriction>Titles must be under 100 characters.</restriction>
                <restriction>The entire output must be formatted in clean Markdown.</restriction>
            </restrictions>
            <format_rules>
                <rule>Follow the structure in the examples below precisely.</rule>
                <rule>Use Markdown headings (`###`), bolding, and code blocks for clarity.</rule>
            </format_rules>
        </output>
    </io_formatting>

    <examples>
        <example id=""1"">
            <input type=""video_topic""><![CDATA[A guide on how to build a budget gaming PC in 2024 for under $800.]]></input>
            <answer>
                <intro>Here is your complete YouTube optimization package from VidOptimo.</intro>
                <section name=""Title Options (Select One)"">
                    <title_options>
                        <option type=""SEO Powerhouse"">How to Build a Budget Gaming PC in 2024 (Under $800 Guide)</option>
                        <option type=""Curiosity Gap"">This $800 Gaming PC DESTROYS Everything</option>
                        <option type=""Community Insider"">The Ultimate Sub-$800 PC Build Guide for 1440p Gaming</option>
                    </title_options>
                </section>
                <section name=""YouTube Description"">
                    <description_block>
                        <![CDATA[
How to Build a Budget Gaming PC in 2024 for under $800! In this step-by-step guide, we show you the best parts to get for your budget gaming PC build and walk you through the entire assembly process. Stop wondering and start building!

We cover everything from selecting the right CPU and GPU combination to cable management tips for a clean and professional-looking rig. This build is perfect for anyone looking to play modern titles like [Example Game 1] and [Example Game 2] at 1080p or even 1440p with solid frame rates. We've benchmarked this exact build so you can see exactly what performance to expect.

CHAPTERS / TIMESTAMPS:
0:00 - The Best Parts for an $800 Build
1:30 - Motherboard & CPU Assembly
4:55 - Installing the RAM & M.2 SSD
7:10 - Case Prep & Motherboard Installation
10:05 - GPU Installation
12:40 - Power Supply & Cable Management
16:22 - First Boot & OS Installation
18:30 - Gaming Benchmarks!

✅ Subscribe for more PC builds: [Your Channel Link]
➡️ Watch our ""Top 5 GPUs of 2024"" video: [Link to other video]

Connect with us:
- Twitter: [Your Twitter Link]
- Instagram: [Your Instagram Link]

#GamingPC #PCBuilding #BudgetGamingPC
                        ]]>
                    </description_block>
                </section>
                <section name=""Hashtags (for description & upload)"">
                    <hashtags><![CDATA[#GamingPC #PCBuilding #BudgetGamingPC #Tech #PCGaming]]></hashtags>
                </section>
                <section name=""Tags / Keywords (for upload tag field)"">
                    <keywords><![CDATA[budget gaming pc, how to build a gaming pc, gaming pc build 2024, gaming pc under $800, pc build guide, pc gaming, custom pc, tech, computer hardware, best budget pc parts, ryzen, nvidia, amd, 1440p gaming, pc build tutorial, pc assembly, diy pc build]]></keywords>
                </section>
            </answer>
        </example>
        <example id=""2"">
            <input type=""video_summary""><![CDATA[I tried the 100-year-old recipe for lasagna from a famous Italian restaurant. The video shows me finding the recipe, buying the ingredients, the full cooking process, and my final reaction to tasting it.]]></input>
            <answer>
                <intro>Here is your complete YouTube optimization package from VidOptimo.</intro>
                <section name=""Title Options (Select One)"">
                    <title_options>
                        <option type=""SEO Powerhouse"">Cooking a 100-Year-Old Lasagna Recipe (Taste Test)</option>
                        <option type=""Curiosity Gap"">I Tried a 100-Year-Old Lasagna Recipe and It Changed My Life</option>
                        <option type=""Community Insider"">Does This Legendary 100-Year-Old Lasagna Recipe Hold Up?</option>
                    </title_options>
                </section>
                <section name=""YouTube Description"">
                    <description_block>
                        <![CDATA[
We're cooking a 100-Year-Old Lasagna Recipe from a legendary Italian restaurant! Can a recipe from a century ago compete with modern-day lasagna? I was determined to find out. This is one of the most incredible things I've ever cooked.

In this video, I take you on the full journey: from uncovering the historic recipe to shopping for authentic ingredients and tackling the multi-step cooking process. The best part is the final taste test and reaction—was it worth the effort? Watch to find out! This classic lasagna features a rich bolognese and a creamy béchamel sauce, a true authentic Italian classic.

CHAPTERS / TIMESTAMPS:
0:00 - The Legendary Recipe
1:15 - Shopping for Authentic Ingredients
3:40 - Making the Bolognese Sauce
6:20 - The Secret to the Perfect Béchamel
8:55 - Assembling the Lasagna Layers
11:10 - Baking to Golden Perfection
13:05 - The First Bite: Final Reaction

✅ Subscribe for more cooking adventures: [Your Channel Link]
➡️ My Playlist of Historic Recipes: [Link to playlist]

Connect with us:
- Instagram: [Your Instagram Link]
- TikTok: [Your TikTok Link]

#Lasagna #ItalianFood #Cooking
                        ]]>
                    </description_block>
                </section>
                <section name=""Hashtags (for description & upload)"">
                    <hashtags><![CDATA[#Lasagna #ItalianFood #Cooking #Recipe #VintageRecipe]]></hashtags>
                </section>
                <section name=""Tags / Keywords (for upload tag field)"">
                    <keywords><![CDATA[lasagna recipe, how to make lasagna, authentic italian lasagna, cooking, recipe, italian food, food, 100 year old recipe, vintage recipe, historic recipe, cooking show, taste test, reaction video, bolognese sauce, béchamel sauce, pasta, homemade lasagna, best lasagna recipe]]></keywords>
                </section>
            </answer>
        </example>
    </examples>
</persona>"
dUZ6mL3z,SmartQuary V2,daoek,Lua,Thursday 24th of July 2025 05:42:00 AM CDT,"local function TurtleState()
    local x, y, z = 0, 0, 0
    local dir = ""n""
    local path = ""/data/turtleState.json""

    local function load()
        if not fs.exists(""/data"") then
            fs.makeDir(""/data"")
        end

        if fs.exists(path) then
            local file = fs.open(path, ""r"")
            local data = textutils.unserializeJSON(file.readAll())
            file.close()
            x = data.x or 0
            y = data.y or 0
            z = data.z or 0
            dir = data.dir or ""n""
        end
    end

    local function save(newX, newY, newZ, newDir)
        x = newX or x
        y = newY or y
        z = newZ or z
        dir = newDir or dir

        local file = fs.open(path, ""w"")
        file.write(textutils.serializeJSON({
            x = x,
            y = y,
            z = z,
            dir = dir
        }))
        file.close()
    end

    local function get()
        return x, y, z, dir
    end

    load()

    return {
        load = load,
        save = save,
        get = get
    }
end

dirIndex = { n = 0, e = 1, s = 2, w = 3 }
dirNames = { ""n"", ""e"", ""s"", ""w"" }

turtleState = TurtleState()
x, y, z, dir = turtleState.get()

local function refuelAll(limit)
    if turtle.getFuelLevel() < limit then
        for i = 1, 16, 1 do
            turtle.select(i)
            turtle.refuel()
        end
    end
end

local function resetState()
    x, y, z, dir = 0, 0, 0, ""n""
    turtleState.save(x, y, z, dir)
    print(""Turtle state reset to 0, 0, 0, facing north."")
end

local function isOre(dir)
    local inspectFn

    if dir == """" or dir == ""forward"" then
        inspectFn = turtle.inspect
    elseif dir == ""up"" then
        inspectFn = turtle.inspectUp
    elseif dir == ""down"" then
        inspectFn = turtle.inspectDown
    else
        error(""Invalid direction: expected '', 'forward', 'up', or 'down'"", 2)
    end

    local success, data = inspectFn()
    if not success or not data.name then
        return false
    end

    local name = data.name

    local whiteList = {
        ""ore"", ""resources"", ""basis_block_core"", ""blockmetal""
    }

    for _, good in ipairs(whiteList) do
        if name:find(good) then
            return true
        end
    end

    return false
end

local function isInventoryFull()
    for i = 1, 16 do
        if turtle.getItemCount(i) == 0 then
            return false
        end
    end
    return true
end

local function dumpInventory(dir)
    local dropFn

    if dir == """" or dir == ""forward"" then
        dropFn = turtle.drop
    elseif dir == ""up"" then
        dropFn = turtle.dropUp
    elseif dir == ""down"" then
        dropFn = turtle.dropDown
    else
        error(""Invalid direction: must be '', 'up', or 'down'"", 2)
    end

    for i = 1, 16 do
        turtle.select(i)
        dropFn()
    end

    turtle.select(1) -- Restore selection
end

local function SmartDig(dir)

    local digFunction, inspectFunction, attempts

    if dir == """" or dir == ""forward"" then
        digFunction = turtle.dig
        inspectFunction = turtle.inspect
    elseif dir == ""up"" then
        digFunction = turtle.digUp
        inspectFunction = turtle.inspectUp
    elseif dir == ""down"" then
        digFunction = turtle.digDown
        inspectFunction = turtle.inspectDown
    else
        error(""Invalid direction: expected '', 'forward', 'up', or 'down'"", 2)
    end

    attempts = 2

    local function DigFallingEntity()
        while digFunction() do
            os.sleep(0.5)
        end
    end

    local function DigNormal()
        digFunction()
    end

    while attempts > 0 do
        local success, data = inspectFunction()
        if not success then
            return
        end

        local name = data.name or """"
        if name:find(""gravel"") or name:find(""sand"") then
            DigFallingEntity()
        elseif name:find(""turtle"") or name:find(""lava"") or name:find(""water"") or name:find(""bedrock"") then
            return
        else   
            DigNormal()
        end

        -- Check again in case something fell
        local again, newData = inspectFunction()

        if again then
            attempts = attempts - 1
        else
            return
        end
    end
end

local function forward()
    SmartDig(""forward"")

    if turtle.forward() then
        if dir == ""n"" then
            z = z - 1
        elseif dir == ""s"" then
            z = z + 1
        elseif dir == ""e"" then
            x = x + 1
        elseif dir == ""w"" then
            x = x - 1
        end

        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function back()
    if turtle.back() then
        if dir == ""n"" then
            z = z + 1
        elseif dir == ""s"" then
            z = z - 1
        elseif dir == ""e"" then
            x = x - 1
        elseif dir == ""w"" then
            x = x + 1
        end

        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function up()
    SmartDig(""up"")
    if turtle.up() then
        y = y + 1
        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function down()

    SmartDig(""down"")

    if turtle.down() then
        y = y - 1
        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function turnLeft()
    turtle.turnLeft()
    local idx = (dirIndex[dir] - 1) % 4
    dir = dirNames[idx + 1]
    turtleState.save(x, y, z, dir)
end

local function turnRight()
    turtle.turnRight()
    local idx = (dirIndex[dir] + 1) % 4
    dir = dirNames[idx + 1]
    turtleState.save(x, y, z, dir)
end

local function turnToDirection(desiredDir)
    if dir == desiredDir then return end

    local current = dirIndex[dir]
    local target = dirIndex[desiredDir]
    local diff = (target - current) % 4

    if diff == 1 then
        turnRight()
    elseif diff == 2 then
        turnRight()
        turnRight()
    elseif diff == 3 then
        turnLeft()
    end
end

local function moveToLocation(desiredX, desiredY, desiredZ)
    -- Move vertically first (Y axis)
    while y < desiredY do
        if not up() then return false end
    end
    while y > desiredY do
        if not down() then return false end
    end

    -- Move along X axis
    if desiredX > x then
        turnToDirection(""e"")
        while x < desiredX do
            if not forward() then return false end
        end
    elseif desiredX < x then
        turnToDirection(""w"")
        while x > desiredX do
            if not forward() then return false end
        end
    end

    -- Move along Z axis
    if desiredZ > z then
        turnToDirection(""s"")
        while z < desiredZ do
            if not forward() then return false end
        end
    elseif desiredZ < z then
        turnToDirection(""n"")
        while z > desiredZ do
            if not forward() then return false end
        end
    end

    return true
end

local function removeDataFromArray(array, data)
    local foundIndex = -1
    
    for i, v in ipairs(array) do
        if data == v then
            foundIndex = i
        end
    end

    if foundIndex ~= -1 then
        table.remove(array, foundIndex)
    end

end

local function doesArrayContain(array, data)
    for i, v in ipairs(array) do
        if data == v then
            return true
        end
    end

    return false
end

local function createPositionKey(x, y, z)
    return string.format(""%d,%d,%d"", x, y, z)
end

local function getPositionKeyWithDirection(relativeDir)
    local dx, dy, dz = 0, 0, 0

    if relativeDir == ""up"" then
        dy = 1
    elseif relativeDir == ""down"" then
        dy = -1
    elseif relativeDir == ""forward"" then
        if dir == ""n"" then dz = -1
        elseif dir == ""s"" then dz = 1
        elseif dir == ""e"" then dx = 1
        elseif dir == ""w"" then dx = -1 end
    elseif relativeDir == ""back"" then
        if dir == ""n"" then dz = 1
        elseif dir == ""s"" then dz = -1
        elseif dir == ""e"" then dx = -1
        elseif dir == ""w"" then dx = 1 end
    elseif relativeDir == ""left"" then
        if dir == ""n"" then dx = -1
        elseif dir == ""s"" then dx = 1
        elseif dir == ""e"" then dz = -1
        elseif dir == ""w"" then dz = 1 end
    elseif relativeDir == ""right"" then
        if dir == ""n"" then dx = 1
        elseif dir == ""s"" then dx = -1
        elseif dir == ""e"" then dz = 1
        elseif dir == ""w"" then dz = -1 end
    else
        error(""Invalid direction for getPositionKeyWithDirection: "" .. tostring(relativeDir))
    end

    return createPositionKey(x + dx, y + dy, z + dz)
end

local function smartMineOreVeinWorker(noOreDetected, oreDetected, backTrackLog)

    local targetPos = getPositionKeyWithDirection(""forward"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""down"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""down"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""up"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""up"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""right"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
    turnRight()

        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end

    turnLeft()
    end

    targetPos = getPositionKeyWithDirection(""left"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        turnLeft()
        
        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end

        turnRight()
    end




    -- Mine down if there is ore
    targetPos = getPositionKeyWithDirection(""down"")
    if doesArrayContain(oreDetected, targetPos) then

        if down() then
            table.insert(backTrackLog, ""up"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine left if there is ore
    targetPos = getPositionKeyWithDirection(""left"")
    if doesArrayContain(oreDetected, targetPos) then
        turnLeft()
        table.insert(backTrackLog, ""turnright"")

        if forward() then
            table.insert(backTrackLog, ""back"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine forward if there is ore
    targetPos = getPositionKeyWithDirection(""forward"")
    if doesArrayContain(oreDetected, targetPos) then
        if forward() then
            table.insert(backTrackLog, ""back"")
            
            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine right if there is ore
    targetPos = getPositionKeyWithDirection(""right"")
    if doesArrayContain(oreDetected, targetPos) then
        turnRight()
        table.insert(backTrackLog, ""turnleft"")

        if forward() then
            table.insert(backTrackLog, ""back"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)
        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine up if there is ore
    targetPos = getPositionKeyWithDirection(""up"")
    if doesArrayContain(oreDetected, targetPos) then

        if up() then
            table.insert(backTrackLog, ""down"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    --no ores next to turtle need to backtrack if there are any ores left
    if #oreDetected > 0 and #backTrackLog > 0 then
        local action = table.remove(backTrackLog)

        --back tracked
        if action == ""turnright"" then
            turnRight()
        elseif action == ""turnleft"" then
            turnLeft()
        elseif action == ""back"" then
            back()
        elseif action == ""down"" then
            down()
        elseif action == ""up"" then
            up()
        end

            --check backtracked location
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog) 
        

        

    else
        return true
    end

end

local function smartMineOreVein()

    local noOreDetected = {}
    local oreDetected = {}
    local backTrackLog = {}

    local startXPos, startYPos, startZPos, startDir = x, y, z, dir
    smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog, true)

    moveToLocation(startXPos,startYPos,startZPos)
    turnToDirection(startDir)
end

local function mineWellAndCollectOres()
    local startXPos, startYPos, startZPos = x, y, z

    while down() do
        for i = 1, 4, 1 do
            turnLeft()
            if isOre(""forward"") then
                smartMineOreVein()
            end
        end
    end

    moveToLocation(startXPos,startYPos,startZPos)
end

local function mineWellInGrid(width, depth)
    local wellLocations = {}
    local startXPos, startYPos, startZPos, startDir = x, y, z, dir

    -- Generate initial well positions
    for z = 0, -(depth - 1), -1 do
        for x = 0, (width - 1), 1 do
            if z % 4 == 0 and x % 4 == 0 then
                table.insert(wellLocations, {x, y, z}) -- assumes y is global
            end
        end
    end

    -- Duplicate with (2, 0, -2) offset
    local originalCount = #wellLocations
    for index = 1, originalCount do
        local loc = wellLocations[index]
        table.insert(wellLocations, {loc[1] + 2, loc[2], loc[3] - 2})
    end

    -- Remove locations out of bounds
    local i = 1
    while i <= #wellLocations do
        local x, _, z = table.unpack(wellLocations[i])
        if x < 0 or x >= width or math.abs(z) > depth then
            table.remove(wellLocations, i)
        else
            i = i + 1
        end
    end

    for i = 1, #wellLocations, 1 do
        
        moveToLocation(wellLocations[i][1], wellLocations[i][2], wellLocations[i][3])
        mineWellAndCollectOres()
        
        moveToLocation(startXPos,startYPos,startZPos)
        turnToDirection(startDir)

        turnLeft()
        turnLeft()

        refuelAll(2000)
        
        dumpInventory(""forward"")
    end
end

--go to starting location when loaded again
moveToLocation(0,0,0)
turnToDirection(""n"")

local args = { ... }

if not args[1] then
    print(""Usage:"")
    print(""mine reset (Reset turtle origin point)"")
    print(""mine smartQuary <width> <depth> (Mine a grid of ore wells)"")
    return

elseif args[1] == ""reset"" then
    resetState()
    return

elseif args[1] == ""smartQuary"" then
    local width = tonumber(args[2])
    local depth = tonumber(args[3])

    if width and depth then
        mineWellInGrid(width, depth)
    else
        print(""Usage: mine smartQuary <width> <depth>"")
        print(""Example: mine smartQuary 16 20"")
    end
    return

else
    print(""Unknown subcommand: "" .. tostring(args[1]))
    print(""Use one of the following:"")
    print(""reset"")
    print(""smartQuary <width> <depth>"")
    return
end










"
vHvpLNLz,ScreenConnect.ClientService,bastyav,HTML,Thursday 24th of July 2025 05:28:05 AM CDT,"https://www.virustotal.com/gui/file/8afdf808d65ebe43e6c8f83ea317db1ed4fd7a396e04e39cc8c74cc7dcb438d8?nocache=1
https://www.virustotal.com/gui/file/3bfe0785ee31565061dd406f95273f8f3f1f19ab448f3cc9fc092b255211c632?nocache=1
https://www.virustotal.com/gui/file/6846c9580546074042959a05ca5d30cd1804a124a9471f6b6a6f5df55ba73555?nocache=1
https://www.virustotal.com/gui/file/387aaa461c3a73f233795129c02e20c50013db132bbf3632d88246a8ad9047a5?nocache=1
PS C:\Program Files (x86)\ScreenConnect Client (21735cf5ba06b01f)> ls


    Directory: C:\Program Files (x86)\ScreenConnect Client (21735cf5ba06b01f)


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         24-Apr-25   6:55 PM           2416 app.config
-a----         24-Apr-25   6:55 PM          50128 Client.en-US.resources
-a----         24-Apr-25   6:55 PM            502 Client.Override.en-US.resources
-a----         24-Apr-25   6:55 PM           7954 Client.Override.resources
-a----         24-Apr-25   6:55 PM          29608 Client.resources
-a----         24-Apr-25   6:55 PM         202240 ScreenConnect.Client.dll
-a----         24-Apr-25   6:55 PM         290304 ScreenConnect.Client.pdb
-a----         24-Apr-25   6:56 PM          70656 ScreenConnect.ClientService.dll
-a----         24-Apr-25   6:56 PM          95512 ScreenConnect.ClientService.exe
-a----         24-Apr-25   6:56 PM         140800 ScreenConnect.ClientService.pdb
-a----         24-Apr-25   6:55 PM         579072 ScreenConnect.Core.dll
-a----         24-Apr-25   6:55 PM        1711616 ScreenConnect.Core.pdb
-a----         24-Apr-25   6:55 PM        1735680 ScreenConnect.Windows.dll
-a----         24-Apr-25   6:55 PM         308736 ScreenConnect.Windows.pdb
-a----         24-Apr-25   1:08 AM         260168 ScreenConnect.WindowsAuthenticationPackage.dll
-a----         24-Apr-25   1:08 AM        5459968 ScreenConnect.WindowsAuthenticationPackage.pdb
-a----         24-Apr-25   6:56 PM          62232 ScreenConnect.WindowsBackstageShell.exe
-a----         24-Apr-25   6:56 PM            266 ScreenConnect.WindowsBackstageShell.exe.config
-a----         24-Apr-25   6:56 PM         108032 ScreenConnect.WindowsBackstageShell.pdb
-a----         24-Apr-25   6:58 PM         643352 ScreenConnect.WindowsClient.exe
-a----         24-Apr-25   6:58 PM            266 ScreenConnect.WindowsClient.exe.config
-a----         24-Apr-25   6:58 PM        1486336 ScreenConnect.WindowsClient.pdb
-a----         24-Apr-25   5:36 PM         857088 ScreenConnect.WindowsCredentialProvider.dll
-a----         24-Apr-25   6:56 PM          82200 ScreenConnect.WindowsFileManager.exe
-a----         24-Apr-25   6:56 PM            266 ScreenConnect.WindowsFileManager.exe.config
-a----         24-Apr-25   6:56 PM          34304 ScreenConnect.WindowsFileManager.pdb
-a----         24-Apr-25   6:55 PM            910 system.config"
sH90qzKt,My CMD,anonymousUSAs,JavaScript,Thursday 24th of July 2025 05:22:27 AM CDT,"RPC Helth Check

bash <(curl -Ls https:// raw.githubusercontent.com/DeepPatel2412/Aztec-Tools/main/RPC%20Health%20Check)"
JeRBVqdY,Untitled,jvanmelckebeke,JavaScript,Thursday 24th of July 2025 05:19:08 AM CDT,"// Using fetch (native JavaScript)
const response = await fetch('https://api.deepseek.com/chat/completions', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer <DeepSeek API Key>'
  },
  body: JSON.stringify({
    model: 'deepseek-chat',
    messages: [
      { role: 'system', content: 'You are a helpful assistant.' },
      { role: 'user', content: 'Hello!' }
    ],
    stream: false
  })
});

const data = await response.json();
console.log(data);"
4GMf3AZP,js bb,v1nn4ik,JavaScript,Thursday 24th of July 2025 05:01:14 AM CDT,"import axios from 'axios';
import crypto from 'crypto';

const apiKey = ''; // Ваш API-ключ
const apiSecret = ''; // Ваш секретный ключ
const timestamp = Date.now().toString();
const recvWindow = '5000';

const body = {
  tokenId: 'USDT',
  currencyId: 'EUR',
  side: '0'
};

const signPayload = timestamp + apiKey + recvWindow + JSON.stringify(body);
const sign = crypto.createHmac('sha256', apiSecret).update(signPayload).digest('hex');

axios.post('https://api.bybit.com/v5/p2p/item/online', body, {
  headers: {
    'X-BAPI-SIGN': sign,
    'X-BAPI-API-KEY': apiKey,
    'X-BAPI-TIMESTAMP': timestamp,
    'X-BAPI-RECV-WINDOW': recvWindow,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log(response.data);
})
.catch(error => {
  console.error(error.response ? error.response.data : error.message);
});"
d6t2vxVu,Atl,bastyav,HTML,Thursday 24th of July 2025 12:05:09 AM CDT,"net use k: /delete
net use k: \\scrnatl01fil01.scrn.fadv.net\clientservices
net use f: /delete
net use f: \\SCRNATL01FIL01.SCRN.FADV.NET\Winesp_documents
net use l: /delete
net use l: \\NOAM.FADV.NET\DFSRoot\ESS\Screening\DeptData\Premier_Leadership
net use p: \\NOAM.FADV.NET\DFSRoot\ESS\Screening\DeptData\Premier_Support
net use s: \\scrnatl01fil01.scrn.fadv.net\Softwares
net use Z: /delete
net use Z: \\scrnatl01fil03.scrn.fadv.net\HomeFolders\ATL\%username%

c:\Windows\explorer.exe /n,/e,::{20D04FE0-3AEA-1069-A2D8-08002B30309D}"
4Uy5zAVv,Trainyard 1.7,Talonsfold,Lua,Wednesday 23rd of July 2025 10:53:43 PM CDT,"--*******************************************************************
--*Notes:
--*
--*
--*
--*
--*
--*
--*
--*

--****************
--*Initializing  *
--****************


--Variables Setup
cvar = 0 -- used for counting
numlanes = 7 -- used as a sanity check when rolling though the lanes
lanecolors = {} -- stores lane color info
lanestat = {} -- stores lane status 
lanedock = {} -- stores if the train in that lane is in the unload area or ready to release
lanelocked = {} -- stores if a lane is manually shutdown
lanescreen = {} -- stores the monitor list for the lane displays
yardscram = 0 -- stores state for emergency shutdown process
exitlane = 0 -- stores which lane is good to be released.
traincount = 0 -- train count since last computer reset
id=0 -- not implemented yet
countmessage=0 -- not implemented yet
tempmonitor=""""

--  values assigned to each color transferred to a linked variable for easy access
-- entrylanecolors = colors.black 
lanecolors[1] = colors.white
lanecolors[2] = colors.orange
lanecolors[3] = colors.magenta
lanecolors[4] = colors.lightBlue
lanecolors[5] = colors.yellow
lanecolors[6] = colors.lime
lanecolors[7] = colors.pink
exitlanecolor = colors.black
traincountercolor = colors.red
laneclearcolor = colors.green
laneunloadingcolor = colors.orange
lanewaitingcolor = colors.yellow
lanelockedcolor = colors.red
lockedlanesx1 = {2,24,44,64,84,104,124} --workaround for floating point glitch on locked lane monitors 
lockedlanesx2 = {22,42,62,82,102,122,142} --workaround for floating point glitch on locked lane monitors 


--Monitor setup
local original_terminal = term.current()

--main display
local monitor = peripheral.wrap(""monitor_11"")
term.redirect(monitor)
monitor.clear()
monitor.setTextScale(1)

--Locked lane display
local monitor2 = peripheral.wrap(""monitor_10"")
monitor2.clear()
monitor2.setTextScale(.5)

--lane displays
lanescreen[1] = peripheral.wrap(""monitor_3"")
lanescreen[2] = peripheral.wrap(""monitor_4"")
lanescreen[3] = peripheral.wrap(""monitor_5"")
lanescreen[4] = peripheral.wrap(""monitor_6"")
lanescreen[5] = peripheral.wrap(""monitor_7"")
lanescreen[6] = peripheral.wrap(""monitor_2"")
lanescreen[7] = peripheral.wrap(""monitor_8"")



m1x, m1y = monitor.getSize() --screen size grab for automated sizing
lsx, lsy = lanescreen[1].getSize() --screen size grab for automated sizing

--m2x, m2y = monitor2.getSize() --disabled/not used due to floating point bug




--******************************************************************************************
--*Functions - are defined in the beginning and can be called from within the main loop    *
--******************************************************************************************

function scanlanes() --process lanes and assign status to variables.
	for cvar = 1,numlanes,1 do -- uses a counter to roll through each lane and check for the status. The status is then assigned to a variable for storage
		if rs.testBundledInput(""left"", lanecolors[cvar]) == true then lanestat[cvar] = false else lanestat[cvar] = true end	 -- check for occupied lanes
		if rs.testBundledInput(""bottom"", lanecolors[cvar]) == true then lanedock[cvar] = false else lanedock[cvar] = true end -- see if occupied train is in unloading or exit sections
		if rs.testBundledInput(""back"", lanecolors[cvar]) == true then lanelocked[cvar] = true else lanelocked[cvar] = false end -- check to see if any lanes have been manually locked out
	end
end

function release(releaselane) --process the release on the current selected exit lane. (also updates status displays
	term.setTextColor(colors.white)
	monitordraw(monitor, 2,6+((releaselane-1)*3),70,6+((releaselane-1)*3)+1,colors.blue, 5, 7+((releaselane-1)*3), ""Lane: "" .. releaselane .. "" Released"")
	rs.setBundledOutput(""right"", lanecolors[releaselane]) --sets the output to release a lane
	sleep(3) --delay to allow time for train to move into exit lane
	rs.setBundledOutput(""right"", 0) -- reset release
end

function monitordraw (display, x1, y1, x2, y2, lanecolor, textx, texty, lanetext)
	term.redirect(display)
	paintutils.drawFilledBox(x1,y1,x2,y2,lanecolor)
	monitor.setTextColor(colors.black)
	monitor.setCursorPos(textx, texty)
	print(lanetext)				
	monitor.setBackgroundColor(colors.black)
	term.redirect(monitor)
end


function drawupdate()
	monitor.clear()
	paintutils.drawFilledBox(1,1,110,5,colors.blue)
	paintutils.drawFilledBox(3,3,27,4,colors.black)
	paintutils.drawFilledBox(33,3,55,4,colors.black)
	term.setCursorPos(3,3)
	monitor.setTextColor(colors.white)
	print(""Train Station Monitoring"")
	monitor.setTextColor(colors.white)
	monitor.setCursorPos(33,3)
	print(""Trains Since Reset: "" .. traincount)

	--Draw Main Monitor lanes
	for j=1,numlanes,1 do
		if lanelocked[j] == true then
			monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,lanelockedcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Locked down"")
		else
			if lanestat[j] == true then
				if lanedock[j] == true then
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,laneunloadingcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Unloading"")
				else
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,lanewaitingcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Waiting for Release"")				end
			else
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,laneclearcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Vacant"")				end
			end
		end	
	-- Draw Lane Lock displays
	term.redirect(monitor2)
	term.setBackgroundColor(colors.black)
	term.clear()
	for j = 1,numlanes,1 do
		if lanelocked[j] == true then
			--monitordraw(monitor2,lockedlanesx1[j],1,lockedlanesx2[j],10,colors.red, lockedlanesx1[j]+2,5, ""Lane: "".. j.. "" Locked"") 
			paintutils.drawFilledBox(lockedlanesx1[j],1,lockedlanesx2[j],10,colors.red) 
			monitor2.setTextColor(colors.white)
			monitor2.setCursorPos(lockedlanesx1[j]+2,5)
			print(""Lane"".. j.. "": Locked"")
		else
			--monitordraw(monitor2,lockedlanesx1[j],1,lockedlanesx2[j],9,colors.greeb, lockedlanesx1[j]+2,5, ""Lane: "".. j.. "" Open"")
			paintutils.drawFilledBox(lockedlanesx1[j],1,lockedlanesx2[j],10,colors.green) 
			monitor2.setTextColor(colors.white)
			monitor2.setCursorPos(lockedlanesx1[j]+2,5)
			print(""Lane"".. j.. "": Open"")
		end
	end


	-- draw lanesigns
	
	for j = 1, numlanes, 1 do
		term.redirect(lanescreen[j])

		if lanelocked[j] == true then
			term.setBackgroundColor(lanelockedcolor)
			term.clear()
			term.setCursorPos(2,5)
			print(""Lane "".. j)
		else
			if lanestat[j] == true then
				if lanedock[j] == true then
					term.setBackgroundColor(laneunloadingcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
				else
					term.setBackgroundColor(lanewaitingcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
				end
			else
					term.setBackgroundColor(laneclearcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
			end
			end
		end	

	
	term.redirect(monitor)
end

function counterincrement()
	traincount=traincount+1
	while (rs.testBundledInput(""bottom"",traincountercolor)) do
	sleep(.1)
	end
end

--****************
--*Main Loop     *
--****************

while(true) do
	scanlanes() -- check to see what lanes are full
	exitlane=exitlane+1
	if rs.testBundledInput(""bottom"",traincountercolor) == true then counterincrement() end
	if exitlane>numlanes then exitlane=1 end
		if rs.testBundledInput(""left"", exitlanecolor) == false then  -- make sure the exit lane is clear.
			if lanestat[exitlane] == true then -- check if there is a train in the current tested lane.
				if lanedock[exitlane] == false then --if there is a lane but it is in the unloading area then skip to the next one
					if lanelocked[exitlane] == false then
						release(exitlane) -- if it meets all conditions then release
					end
			end	
		end	
	end
	drawupdate() -- update display 
	sleep(.3)
end


"
g6fCd95B,trainyard v1.6,Talonsfold,Lua,Wednesday 23rd of July 2025 10:52:29 PM CDT,"--*******************************************************************
--*Notes:
--*
--*
--*
--*
--*
--*
--*
--*

--****************
--*Initializing  *
--****************


--Variables Setup
cvar = 0 -- used for counting
numlanes = 7 -- used as a sanity check when rolling though the lanes
lanecolors = {} -- stores lane color info
lanestat = {} -- stores lane status 
lanedock = {} -- stores if the train in that lane is in the unload area or ready to release
lanelocked = {} -- stores if a lane is manually shutdown
lanescreen = {} -- stores the monitor list for the lane displays
yardscram = 0 -- stores state for emergency shutdown process
exitlane = 0 -- stores which lane is good to be released.
traincount = 395 -- train count since last computer reset
id=0 -- not implemented yet
countmessage=0 -- not implemented yet
tempmonitor=""""

--  values assigned to each color transferred to a linked variable for easy access
-- entrylanecolors = colors.black 
lanecolors[1] = colors.white
lanecolors[2] = colors.orange
lanecolors[3] = colors.magenta
lanecolors[4] = colors.lightBlue
lanecolors[5] = colors.yellow
lanecolors[6] = colors.lime
lanecolors[7] = colors.pink
exitlanecolor = colors.black
traincountercolor = colors.red
laneclearcolor = colors.green
laneunloadingcolor = colors.orange
lanewaitingcolor = colors.yellow
lanelockedcolor = colors.red
lockedlanesx1 = {2,24,44,64,84,104,124} --workaround for floating point glitch on locked lane monitors 
lockedlanesx2 = {22,42,62,82,102,122,142} --workaround for floating point glitch on locked lane monitors 


--Monitor setup
local original_terminal = term.current()

--main display
local monitor = peripheral.wrap(""monitor_11"")
term.redirect(monitor)
monitor.clear()
monitor.setTextScale(1)

--Locked lane display
local monitor2 = peripheral.wrap(""monitor_10"")
monitor2.clear()
monitor2.setTextScale(.5)

--lane displays
lanescreen[1] = peripheral.wrap(""monitor_3"")
lanescreen[2] = peripheral.wrap(""monitor_4"")
lanescreen[3] = peripheral.wrap(""monitor_5"")
lanescreen[4] = peripheral.wrap(""monitor_6"")
lanescreen[5] = peripheral.wrap(""monitor_7"")
lanescreen[6] = peripheral.wrap(""monitor_2"")
lanescreen[7] = peripheral.wrap(""monitor_8"")



m1x, m1y = monitor.getSize() --screen size grab for automated sizing
lsx, lsy = lanescreen[1].getSize() --screen size grab for automated sizing

--m2x, m2y = monitor2.getSize() --disabled/not used due to floating point bug




--******************************************************************************************
--*Functions - are defined in the beginning and can be called from within the main loop    *
--******************************************************************************************

function scanlanes() --process lanes and assign status to variables.
	for cvar = 1,numlanes,1 do -- uses a counter to roll through each lane and check for the status. The status is then assigned to a variable for storage
		if rs.testBundledInput(""left"", lanecolors[cvar]) == true then lanestat[cvar] = false else lanestat[cvar] = true end	 -- check for occupied lanes
		if rs.testBundledInput(""bottom"", lanecolors[cvar]) == true then lanedock[cvar] = false else lanedock[cvar] = true end -- see if occupied train is in unloading or exit sections
		if rs.testBundledInput(""back"", lanecolors[cvar]) == true then lanelocked[cvar] = true else lanelocked[cvar] = false end -- check to see if any lanes have been manually locked out
	end
end

function release(releaselane) --process the release on the current selected exit lane. (also updates status displays
	term.setTextColor(colors.white)
	monitordraw(monitor, 2,6+((releaselane-1)*3),70,6+((releaselane-1)*3)+1,colors.blue, 5, 7+((releaselane-1)*3), ""Lane: "" .. releaselane .. "" Released"")
	rs.setBundledOutput(""right"", lanecolors[releaselane]) --sets the output to release a lane
	sleep(3) --delay to allow time for train to move into exit lane
	rs.setBundledOutput(""right"", 0) -- reset release
end

function monitordraw (display, x1, y1, x2, y2, lanecolor, textx, texty, lanetext)
	term.redirect(display)
	paintutils.drawFilledBox(x1,y1,x2,y2,lanecolor)
	monitor.setTextColor(colors.black)
	monitor.setCursorPos(textx, texty)
	print(lanetext)				
	monitor.setBackgroundColor(colors.black)
	term.redirect(monitor)
end


function drawupdate()
	monitor.clear()
	paintutils.drawFilledBox(1,1,110,5,colors.blue)
	paintutils.drawFilledBox(3,3,27,4,colors.black)
	paintutils.drawFilledBox(33,3,55,4,colors.black)
	term.setCursorPos(3,3)
	monitor.setTextColor(colors.white)
	print(""Train Station Monitoring"")
	monitor.setTextColor(colors.white)
	monitor.setCursorPos(33,3)
	print(""Trains Since Reset: "" .. traincount)

	--Draw Main Monitor lanes
	for j=1,numlanes,1 do
		if lanelocked[j] == true then
			monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,lanelockedcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Locked down"")
		else
			if lanestat[j] == true then
				if lanedock[j] == true then
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,laneunloadingcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Unloading"")
				else
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,lanewaitingcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Waiting for Release"")				end
			else
					monitordraw(monitor, 2,6+((j-1)*3),70,6+((j-1)*3)+1,laneclearcolor, 5, 7+((j-1)*3), ""Lane: "" .. j .. "" Vacant"")				end
			end
		end	
	-- Draw Lane Lock displays
	term.redirect(monitor2)
	term.setBackgroundColor(colors.black)
	term.clear()
	for j = 1,numlanes,1 do
		if lanelocked[j] == true then
			--monitordraw(monitor2,lockedlanesx1[j],1,lockedlanesx2[j],10,colors.red, lockedlanesx1[j]+2,5, ""Lane: "".. j.. "" Locked"") 
			paintutils.drawFilledBox(lockedlanesx1[j],1,lockedlanesx2[j],10,colors.red) 
			monitor2.setTextColor(colors.white)
			monitor2.setCursorPos(lockedlanesx1[j]+2,5)
			print(""Lane"".. j.. "": Locked"")
		else
			--monitordraw(monitor2,lockedlanesx1[j],1,lockedlanesx2[j],9,colors.greeb, lockedlanesx1[j]+2,5, ""Lane: "".. j.. "" Open"")
			paintutils.drawFilledBox(lockedlanesx1[j],1,lockedlanesx2[j],10,colors.green) 
			monitor2.setTextColor(colors.white)
			monitor2.setCursorPos(lockedlanesx1[j]+2,5)
			print(""Lane"".. j.. "": Open"")
		end
	end


	-- draw lanesigns
	
	for j = 1, numlanes, 1 do
		term.redirect(lanescreen[j])

		if lanelocked[j] == true then
			term.setBackgroundColor(lanelockedcolor)
			term.clear()
			term.setCursorPos(2,5)
			print(""Lane "".. j)
		else
			if lanestat[j] == true then
				if lanedock[j] == true then
					term.setBackgroundColor(laneunloadingcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
				else
					term.setBackgroundColor(lanewaitingcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
				end
			else
					term.setBackgroundColor(laneclearcolor)
					term.clear()
					term.setCursorPos(2,5)
					print(""Lane "".. j)
			end
			end
		end	

	
	term.redirect(monitor)
end

function counterincrement()
	traincount=traincount+1
	while (rs.testBundledInput(""bottom"",traincountercolor)) do
	sleep(.1)
	end
end

--****************
--*Main Loop     *
--****************

while(true) do
	scanlanes() -- check to see what lanes are full
	exitlane=exitlane+1
	if rs.testBundledInput(""bottom"",traincountercolor) == true then counterincrement() end
	if exitlane>numlanes then exitlane=1 end
		if rs.testBundledInput(""left"", exitlanecolor) == false then  -- make sure the exit lane is clear.
			if lanestat[exitlane] == true then -- check if there is a train in the current tested lane.
				if lanedock[exitlane] == false then --if there is a lane but it is in the unloading area then skip to the next one
					if lanelocked[exitlane] == false then
						release(exitlane) -- if it meets all conditions then release
					end
			end	
		end	
	end
	drawupdate() -- update display 
	sleep(.3)
end


"
5Y93JVDm,Untitled,Azzz_4565,Java,Wednesday 23rd of July 2025 09:52:31 PM CDT,"local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService(""RunService"")
local UserInputService = game:GetService(""UserInputService"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local Workspace = game:GetService(""Workspace"")
local stepped = RunService.Stepped

-- Constants for instant infinite damage
local INSTANT_INFINITY_POWER = 2 ^ (190 * 20 * 999999999999999)
local INSTANT_DEATH_DAMAGE = math.huge * 1e60 * INSTANT_INFINITY_POWER * 999000000000000000

-- Ultra fast wait function
local function ultraFastWait()
    -- Using stepped event for minimal yielding
    local event = Instance.new(""BindableEvent"")
    RunService.Stepped:Wait()
    event:Destroy()
    return
end

-- Hook wait/delay functions to remove yield/delay for max speed
for _, f in ipairs({wait, task.wait, delay, spawn, task.delay}) do
    for i = 1, 2000 do
        pcall(function()
            hookfunction(f, function()
                return stepped:Wait()
            end)
        end)
    end
end

-- Ultra instant kill function
local function trueInstantKill(humanoid)
    if humanoid and humanoid.Health > 0 then
        humanoid.Health = 0
        humanoid.MaxHealth = 0
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
        humanoid:ChangeState(Enum.HumanoidStateType.Dead)
    end
end

-- Claw damage / vaporize configuration
local clawDamage = 1e24 -- Supermassive damage for claws

local function clawVaporize(target)
    if target and target:FindFirstChild(""HumanoidRootPart"") then
        local humanoid = target:FindFirstChildOfClass(""Humanoid"")
        if humanoid and humanoid.Health > 0 then
            trueInstantKill(humanoid) -- instantly kill humanoid

            -- Apply explosive force to humanoid root part
            local force = Instance.new(""BodyVelocity"")
            force.MaxForce = Vector3.new(1e15, 1e15, 1e15)
            force.Velocity = Vector3.new(
                math.random(-1e6, 1e6), 
                math.random(1e6, 2e6), 
                math.random(-1e6, 1e6)
            )
            force.Parent = target.HumanoidRootPart

            -- Create a massive explosion at target's position
            local explosion = Instance.new(""Explosion"")
            explosion.Position = target.HumanoidRootPart.Position
            explosion.BlastRadius = 1000
            explosion.BlastPressure = 1e15
            explosion.Parent = Workspace

            -- Destroy all parts and accessories violently
            for _, part in ipairs(target:GetDescendants()) do
                if part:IsA(""BasePart"") then
                    part.Anchored = false
                    part.Velocity = Vector3.new(
                        math.random(-1e10, 1e10), 
                        1e10, 
                        math.random(-1e10, 1e10)
                    )
                    pcall(function() part:Destroy() end)
                elseif part:IsA(""Tool"") or part:IsA(""Accessory"") then
                    pcall(function() part:Destroy() end)
                end
            end
        end
    end
end

-- Vaporize nearby players in a large radius continuously
local function vaporizeNearbyPlayers()
    while true do
        ultraFastWait()
        local character = LocalPlayer.Character
        if character and character:FindFirstChild(""HumanoidRootPart"") then
            for _, targetPlayer in pairs(Players:GetPlayers()) do
                if targetPlayer ~= LocalPlayer then
                    local targetChar = targetPlayer.Character
                    if targetChar and targetChar:FindFirstChild(""HumanoidRootPart"") then
                        local humanoid = targetChar:FindFirstChildOfClass(""Humanoid"")
                        if humanoid and humanoid.Health > 0 then
                            local distance = (character.HumanoidRootPart.Position - targetChar.HumanoidRootPart.Position).Magnitude
                            if distance < 2000 then
                                clawVaporize(targetChar)
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Infinite power scaling damage applied to players in large radius
local function infinitePowerScaling()
    local powerLevel = 0
    local maxPower = 1e30
    local powerIncrement = 1e12

    while true do
        ultraFastWait()
        powerLevel = math.min(powerLevel + powerIncrement, maxPower)

        local character = LocalPlayer.Character
        if character and character:FindFirstChild(""HumanoidRootPart"") then
            for _, targetPlayer in pairs(Players:GetPlayers()) do
                if targetPlayer ~= LocalPlayer then
                    local targetChar = targetPlayer.Character
                    if targetChar and targetChar:FindFirstChild(""HumanoidRootPart"") then
                        local humanoid = targetChar:FindFirstChildOfClass(""Humanoid"")
                        if humanoid and humanoid.Health > 0 then
                            local distance = (character.HumanoidRootPart.Position - targetChar.HumanoidRootPart.Position).Magnitude
                            if distance < 1000 then
                                humanoid:TakeDamage(powerLevel)
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Function to handle massive nearby attacks including chain reactions
local function detectAndAttackMassiveTargets()
    while true do
        RunService.Heartbeat:Wait()

        local attackTargets = {}
        local character = LocalPlayer.Character
        if not (character and character:FindFirstChild(""HumanoidRootPart"")) then
            continue
        end
        local myPosition = character.HumanoidRootPart.Position

        -- Gather close targets
        for _, targetPlayer in pairs(Players:GetPlayers()) do
            if targetPlayer ~= LocalPlayer then
                local targetChar = targetPlayer.Character
                if targetChar and targetChar:FindFirstChild(""HumanoidRootPart"") then
                    local humanoid = targetChar:FindFirstChildOfClass(""Humanoid"")
                    if humanoid and humanoid.Health > 0 then
                        local distance = (myPosition - targetChar.HumanoidRootPart.Position).Magnitude
                        if distance < 15 then
                            table.insert(attackTargets, targetChar)
                        end
                    end
                end
            end
        end

        -- Attack up to 1000 targets with chain reactions
        if #attackTargets >= 1000 then
            for _, target in ipairs(attackTargets) do
                clawVaporize(target)

                local chainReactionTargets = 0
                for _, potentialTarget in ipairs(Players:GetPlayers()) do
                    if chainReactionTargets >= 7 then break end
                    local pChar = potentialTarget.Character
                    if pChar and pChar:FindFirstChild(""HumanoidRootPart"") then
                        local dist = (target.HumanoidRootPart.Position - pChar.HumanoidRootPart.Position).Magnitude
                        if dist < 15 then
                            clawVaporize(pChar)
                            chainReactionTargets = chainReactionTargets + 1
                        end
                    end
                end
            end
        end
    end
end

-- Ultra instant kill spawn hooking
local function attachSpawnDeath(player)
    player.CharacterAdded:Connect(function(character)
        for _, h in pairs(character:GetChildren()) do
            if h:IsA(""Humanoid"") then
                trueInstantKill(h)
            end
        end
        local hum = character:FindFirstChildWhichIsA(""Humanoid"")
        if hum then trueInstantKill(hum) end

        character.ChildAdded:Connect(function(child)
            if child:IsA(""Humanoid"") then
                trueInstantKill(child)
            end
        end)

        local killConn
        killConn = RunService.Heartbeat:Connect(function()
            for _, h in pairs(character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
            local hum = character:FindFirstChildWhichIsA(""Humanoid"")
            if not hum or hum.Health <= 0 then
                if killConn then killConn:Disconnect() end
            end
        end)
    end)
end

-- Setup instant kill for all players except LocalPlayer
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        attachSpawnDeath(player)
        if player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") then
                    trueInstantKill(h)
                end
            end
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        attachSpawnDeath(player)
    end
end)

-- Heartbeat kill aura - instant kill ongoing
RunService.Heartbeat:Connect(function()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
        end
    end
end)

-- Tool activation kills all others instantly
local tool = script.Parent
if tool and tool:IsA(""Tool"") then
    tool.Activated:Connect(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                for _, h in pairs(player.Character:GetChildren()) do
                    if h:IsA(""Humanoid"") and h.Health > 0 then
                        trueInstantKill(h)
                    end
                end
            end
        end
    end)
end

-- Input handling: X/Z triggers kill on others, F kills self, Touch triggers kill others
local function triggerNoCounter()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.X or input.KeyCode == Enum.KeyCode.Z then
        triggerNoCounter()
    elseif input.KeyCode == Enum.KeyCode.F then
        if LocalPlayer.Character then
            for _, h in pairs(LocalPlayer.Character:GetChildren()) do
                if h:IsA(""Humanoid"") then
                    trueInstantKill(h)
                end
            end
        end
    end
end)

UserInputService.TouchInputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        triggerNoCounter()
    end
end)

-- Optional: You may want to run these in separate threads if you want simultaneous behaviour
-- You can spawn coroutines or tasks for parallel loops like:

task.spawn(vaporizeNearbyPlayers)
task.spawn(infinitePowerScaling)
task.spawn(detectAndAttackMassiveTargets)

print(""🔥 ULTRA INSTANT INFINITY NOCOOLDOWN with MEGA CLAWS and MASSIVE ANTI-EXPLOIT activated. 🔥"")
"
xcsXQHjD,disable jnews ads on post page with spesific categories,arie_cristianD,PHP,Wednesday 23rd of July 2025 08:48:47 PM CDT,"add_filter( 'jnews_ads_global_enable', 'disable_ads_on_spesific_cat', 99, 3 );


function disable_ads_on_spesific_cat( $flag, $post_id, $location ) {
	if ( has_category( array( 'your-category-slug-1', 'your-category-slug-1' ), $post_id ) ) {
		return false;
	}
	return $flag;
}
"
bjsXjVuD,Mouse transducer,imk0tter,mIRC,Wednesday 23rd of July 2025 08:30:39 PM CDT,"alias -l ABSN return $CALC(($1 * $1) ^ (2  ^ -1))
alias -l ATANN return $CALC($1 / $ABSN($1))

alias CLAMP return $CALC(($INT($CALC($1 / $2)) % 2) * -1 * $2 + ($1 % $2))

alias TRANSDUCE return $CALC($ATANN($1) * 2 * $ASIN($CALC($ABS($CLAMP($CALC($1 * $IIF($2,$v1,1)),2)) / 2)))
alias TRANSDUCE1 return $CALC($ATANN($1) * $ACOS($CALC((2 - ($CLAMP($CALC($1 * $IIF($2,$v1,1)),2) ^ 2)) / 2)))
alias TRANSDUCE2 var %a $calc($2 * $2 * 2), %b $CLAMP($1, $CALC(2 * $2)) | return $CALC($ATANN($1) * $ACOS($CALC((%a - (%b * %b)) / %a)))

alias RESOLUTION_AND_FOV_TO_RADIUS return $CALC($1 / $SIN($CALC($PI / (360 / $2))) / 2)
"
WsFMnQ2C,Disable PeepSo page title override,ghenzdeveloper,PHP,Wednesday 23rd of July 2025 08:22:02 PM CDT,"add_filter('peepso_page_title_check', function($check){
    return false;
});"
Y8u7vjjQ,Untitled,Azzz_4565,Java,Wednesday 23rd of July 2025 05:12:25 PM CDT,"--🔥 ULTRA INSTANT INFINITY NOCOOLDOWN — 999 TRILLION TIMES FASTER, ABSOLUTE MAX DAMAGE, IMMEDIATE KILL 🔥
-- When you use your tool, every player (except you) dies instantly, just like Humanoid.Health = 0.
-- They never get full health, always die instantly every kill, every respawn.
-- For educational/testing use only. Server-side Script in your own Roblox game.

local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService(""RunService"")
local UserInputService = game:GetService(""UserInputService"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local stepped = RunService.Stepped

local INSTANT_INFINITY_POWER = 2 ^ (190 * 20 * 999999999999999)
local INSTANT_DEATH_DAMAGE = math.huge * 1e60 * INSTANT_INFINITY_POWER * 999000000000000000

-- REMOVE YIELD/DELAY
for _, f in ipairs({wait, task.wait, delay, spawn, task.delay}) do
    for i = 1, 2000 do
        pcall(function()
            hookfunction(f, function()
                return stepped:Wait()
            end)
        end)
    end
end

-- ULTRA INSTANT KILL FUNCTION (Just like setting Humanoid.Health = 0)
local function trueInstantKill(humanoid)
    if humanoid then
        humanoid.Health = 0
        humanoid.MaxHealth = 0
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
        humanoid:ChangeState(Enum.HumanoidStateType.Dead)
    end
end

-- Character spawn hook: Make instant death happen every spawn
local function attachSpawnDeath(player)
    player.CharacterAdded:Connect(function(character)
        local hum = character:FindFirstChildWhichIsA(""Humanoid"")
        if hum then trueInstantKill(hum) end
        character.ChildAdded:Connect(function(child)
            if child:IsA(""Humanoid"") then trueInstantKill(child) end
        end)
        -- Heartbeat kill loop until they're truly dead
        local killConn
        killConn = RunService.Heartbeat:Connect(function()
            for _, h in pairs(character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then trueInstantKill(h) end
            end
            local hum = character:FindFirstChildWhichIsA(""Humanoid"")
            if not hum or hum.Health <= 0 then
                if killConn then killConn:Disconnect() end
            end
        end)
    end)
end

-- Setup for all players except yourself
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        attachSpawnDeath(player)
        if player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") then trueInstantKill(h) end
            end
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        attachSpawnDeath(player)
    end
end)

-- Heartbeat kill aura: Every tick, every player dies instantly
RunService.Heartbeat:Connect(function()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
        end
    end
end)

-- Tool activation: Kill instantly on tool use
local tool = script.Parent
if tool:IsA(""Tool"") then
    tool.Activated:Connect(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                for _, h in pairs(player.Character:GetChildren()) do
                    if h:IsA(""Humanoid"") and h.Health > 0 then
                        trueInstantKill(h)
                    end
                end
            end
        end
    end)
end

-- Keybinds / Touch input: X/Z for kill aura, F for self kill
local function triggerNoCounter()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, h in pairs(player.Character:GetChildren()) do
                if h:IsA(""Humanoid"") and h.Health > 0 then
                    trueInstantKill(h)
                end
            end
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.X or input.KeyCode == Enum.KeyCode.Z then
        triggerNoCounter()
    elseif input.KeyCode == Enum.KeyCode.F then
        if LocalPlayer.Character then
            for _, h in pairs(LocalPlayer.Character:GetChildren()) do
                if h:IsA(""Humanoid"") then trueInstantKill(h) end
            end
        end
    end
end)

UserInputService.TouchInputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        triggerNoCounter()
    end
end)

print(""🔥 ULTRA INSTANT INFINITY NOCOOLDOWN: Humanoids instantly set to 0 health, every kill, every spawn, absolute max damage, no delay, no cooldown, inescapable. 🔥"")"
39zTuu6v,smartQuary computercraft,daoek,Lua,Wednesday 23rd of July 2025 02:51:21 PM CDT,"local function TurtleState()
    local x, y, z = 0, 0, 0
    local dir = ""n""
    local path = ""/data/turtleState.json""

    local function load()
        if not fs.exists(""/data"") then
            fs.makeDir(""/data"")
        end

        if fs.exists(path) then
            local file = fs.open(path, ""r"")
            local data = textutils.unserializeJSON(file.readAll())
            file.close()
            x = data.x or 0
            y = data.y or 0
            z = data.z or 0
            dir = data.dir or ""n""
        end
    end

    local function save(newX, newY, newZ, newDir)
        x = newX or x
        y = newY or y
        z = newZ or z
        dir = newDir or dir

        local file = fs.open(path, ""w"")
        file.write(textutils.serializeJSON({
            x = x,
            y = y,
            z = z,
            dir = dir
        }))
        file.close()
    end

    local function get()
        return x, y, z, dir
    end

    load()

    return {
        load = load,
        save = save,
        get = get
    }
end

dirIndex = { n = 0, e = 1, s = 2, w = 3 }
dirNames = { ""n"", ""e"", ""s"", ""w"" }

turtleState = TurtleState()
x, y, z, dir = turtleState.get()

local function refuelAll(limit)
    if turtle.getFuelLevel() < limit then
        for i = 1, 16, 1 do
            turtle.select(i)
            turtle.refuel()
        end
    end
end

local function resetState()
    x, y, z, dir = 0, 0, 0, ""n""
    turtleState.save(x, y, z, dir)
    print(""Turtle state reset to 0, 0, 0, facing north."")
end

local function isOre(dir)
    local inspectFn

    if dir == """" or dir == ""forward"" then
        inspectFn = turtle.inspect
    elseif dir == ""up"" then
        inspectFn = turtle.inspectUp
    elseif dir == ""down"" then
        inspectFn = turtle.inspectDown
    else
        error(""Invalid direction: expected '', 'forward', 'up', or 'down'"", 2)
    end

    local success, data = inspectFn()
    if not success or not data.name then
        return false
    end

    local name = data.name

    local blacklist = {
        ""grass"", ""stone"", ""dirt"", ""gravel"",
        ""obsidian"", ""water"", ""lava"", ""bedrock"", ""turtle"", ""chest"", ""sand"", ""cactus""
    }

    for _, bad in ipairs(blacklist) do
        if name:find(bad) then
            return false
        end
    end

    return true
end

local function isInventoryFull()
    for i = 1, 16 do
        if turtle.getItemCount(i) == 0 then
            return false
        end
    end
    return true
end

local function dumpInventory(dir)
    local dropFn

    if dir == """" or dir == ""forward"" then
        dropFn = turtle.drop
    elseif dir == ""up"" then
        dropFn = turtle.dropUp
    elseif dir == ""down"" then
        dropFn = turtle.dropDown
    else
        error(""Invalid direction: must be '', 'up', or 'down'"", 2)
    end

    for i = 1, 16 do
        turtle.select(i)
        dropFn()
    end

    turtle.select(1) -- Restore selection
end

local function SmartDig(dir)

    local digFunction, inspectFunction, attempts

    if dir == """" or dir == ""forward"" then
        digFunction = turtle.dig
        inspectFunction = turtle.inspect
    elseif dir == ""up"" then
        digFunction = turtle.digUp
        inspectFunction = turtle.inspectUp
    elseif dir == ""down"" then
        digFunction = turtle.digDown
        inspectFunction = turtle.inspectDown
    else
        error(""Invalid direction: expected '', 'forward', 'up', or 'down'"", 2)
    end

    attempts = 2

    local function DigFallingEntity()
        while digFunction() do
            os.sleep(0.5)
        end
    end

    local function DigNormal()
        digFunction()
    end

    while attempts > 0 do
        local success, data = inspectFunction()
        if not success then
            return
        end

        local name = data.name or """"
        if name:find(""gravel"") or name:find(""sand"") then
            DigFallingEntity()
        elseif name:find(""turtle"") or name:find(""lava"") or name:find(""water"") or name:find(""bedrock"") then
            return
        else   
            DigNormal()
        end

        -- Check again in case something fell
        local again, newData = inspectFunction()

        if again then
            attempts = attempts - 1
        else
            return
        end
    end
end

local function forward()
    SmartDig(""forward"")

    if turtle.forward() then
        if dir == ""n"" then
            z = z - 1
        elseif dir == ""s"" then
            z = z + 1
        elseif dir == ""e"" then
            x = x + 1
        elseif dir == ""w"" then
            x = x - 1
        end

        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function back()
    if turtle.back() then
        if dir == ""n"" then
            z = z + 1
        elseif dir == ""s"" then
            z = z - 1
        elseif dir == ""e"" then
            x = x - 1
        elseif dir == ""w"" then
            x = x + 1
        end

        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function up()
    SmartDig(""up"")
    if turtle.up() then
        y = y + 1
        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function down()

    SmartDig(""down"")

    if turtle.down() then
        y = y - 1
        turtleState.save(x, y, z, dir)
        return true
    end

    return false
end

local function turnLeft()
    turtle.turnLeft()
    local idx = (dirIndex[dir] - 1) % 4
    dir = dirNames[idx + 1]
    turtleState.save(x, y, z, dir)
end

local function turnRight()
    turtle.turnRight()
    local idx = (dirIndex[dir] + 1) % 4
    dir = dirNames[idx + 1]
    turtleState.save(x, y, z, dir)
end

local function turnToDirection(desiredDir)
    if dir == desiredDir then return end

    local current = dirIndex[dir]
    local target = dirIndex[desiredDir]
    local diff = (target - current) % 4

    if diff == 1 then
        turnRight()
    elseif diff == 2 then
        turnRight()
        turnRight()
    elseif diff == 3 then
        turnLeft()
    end
end

local function moveToLocation(desiredX, desiredY, desiredZ)
    -- Move vertically first (Y axis)
    while y < desiredY do
        if not up() then return false end
    end
    while y > desiredY do
        if not down() then return false end
    end

    -- Move along X axis
    if desiredX > x then
        turnToDirection(""e"")
        while x < desiredX do
            if not forward() then return false end
        end
    elseif desiredX < x then
        turnToDirection(""w"")
        while x > desiredX do
            if not forward() then return false end
        end
    end

    -- Move along Z axis
    if desiredZ > z then
        turnToDirection(""s"")
        while z < desiredZ do
            if not forward() then return false end
        end
    elseif desiredZ < z then
        turnToDirection(""n"")
        while z > desiredZ do
            if not forward() then return false end
        end
    end

    return true
end

local function removeDataFromArray(array, data)
    local foundIndex = -1
    
    for i, v in ipairs(array) do
        if data == v then
            foundIndex = i
        end
    end

    if foundIndex ~= -1 then
        table.remove(array, foundIndex)
    end

end

local function doesArrayContain(array, data)
    for i, v in ipairs(array) do
        if data == v then
            return true
        end
    end

    return false
end

local function createPositionKey(x, y, z)
    return string.format(""%d,%d,%d"", x, y, z)
end

local function getPositionKeyWithDirection(relativeDir)
    local dx, dy, dz = 0, 0, 0

    if relativeDir == ""up"" then
        dy = 1
    elseif relativeDir == ""down"" then
        dy = -1
    elseif relativeDir == ""forward"" then
        if dir == ""n"" then dz = -1
        elseif dir == ""s"" then dz = 1
        elseif dir == ""e"" then dx = 1
        elseif dir == ""w"" then dx = -1 end
    elseif relativeDir == ""back"" then
        if dir == ""n"" then dz = 1
        elseif dir == ""s"" then dz = -1
        elseif dir == ""e"" then dx = -1
        elseif dir == ""w"" then dx = 1 end
    elseif relativeDir == ""left"" then
        if dir == ""n"" then dx = -1
        elseif dir == ""s"" then dx = 1
        elseif dir == ""e"" then dz = -1
        elseif dir == ""w"" then dz = 1 end
    elseif relativeDir == ""right"" then
        if dir == ""n"" then dx = 1
        elseif dir == ""s"" then dx = -1
        elseif dir == ""e"" then dz = 1
        elseif dir == ""w"" then dz = -1 end
    else
        error(""Invalid direction for getPositionKeyWithDirection: "" .. tostring(relativeDir))
    end

    return createPositionKey(x + dx, y + dy, z + dz)
end

local function smartMineOreVeinWorker(noOreDetected, oreDetected, backTrackLog)

    local targetPos = getPositionKeyWithDirection(""forward"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""down"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""down"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""up"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        if isOre(""up"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end
    end

    targetPos = getPositionKeyWithDirection(""right"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
    turnRight()

        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end

    turnLeft()
    end

    targetPos = getPositionKeyWithDirection(""left"")
    if not doesArrayContain(noOreDetected, targetPos) and not doesArrayContain(oreDetected, targetPos) then
        turnLeft()
        
        if isOre(""forward"") then
            table.insert(oreDetected, targetPos)
        else
            table.insert(noOreDetected, targetPos)
        end

        turnRight()
    end




    -- Mine down if there is ore
    targetPos = getPositionKeyWithDirection(""down"")
    if doesArrayContain(oreDetected, targetPos) then

        if down() then
            table.insert(backTrackLog, ""up"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine left if there is ore
    targetPos = getPositionKeyWithDirection(""left"")
    if doesArrayContain(oreDetected, targetPos) then
        turnLeft()
        table.insert(backTrackLog, ""turnright"")

        if forward() then
            table.insert(backTrackLog, ""back"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine forward if there is ore
    targetPos = getPositionKeyWithDirection(""forward"")
    if doesArrayContain(oreDetected, targetPos) then
        if forward() then
            table.insert(backTrackLog, ""back"")
            
            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine right if there is ore
    targetPos = getPositionKeyWithDirection(""right"")
    if doesArrayContain(oreDetected, targetPos) then
        turnRight()
        table.insert(backTrackLog, ""turnleft"")

        if forward() then
            table.insert(backTrackLog, ""back"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)
        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    -- Mine up if there is ore
    targetPos = getPositionKeyWithDirection(""up"")
    if doesArrayContain(oreDetected, targetPos) then

        if up() then
            table.insert(backTrackLog, ""down"")

            --remove ore and add to no ore list
            removeDataFromArray(oreDetected,targetPos)
            table.insert(noOreDetected, targetPos)

        else
            return false
        end
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog)
    end

    --no ores next to turtle need to backtrack if there are any ores left
    if #oreDetected > 0 and #backTrackLog > 0 then
        local action = table.remove(backTrackLog)

        --back tracked
        if action == ""turnright"" then
            turnRight()
        elseif action == ""turnleft"" then
            turnLeft()
        elseif action == ""back"" then
            back()
        elseif action == ""down"" then
            down()
        elseif action == ""up"" then
            up()
        end

            --check backtracked location
        smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog) 
        

        

    else
        return true
    end

end

local function smartMineOreVein()

    local noOreDetected = {}
    local oreDetected = {}
    local backTrackLog = {}

    local startXPos, startYPos, startZPos, startDir = x, y, z, dir
    smartMineOreVeinWorker(noOreDetected,oreDetected,backTrackLog, true)

    moveToLocation(startXPos,startYPos,startZPos)
    turnToDirection(startDir)
end

local function mineWellAndCollectOres()
    local startXPos, startYPos, startZPos = x, y, z

    while down() do
        for i = 1, 4, 1 do
            turnLeft()
            if isOre(""forward"") then
                smartMineOreVein()
            end
        end
    end

    moveToLocation(startXPos,startYPos,startZPos)
end

local function mineWellInGrid(width, depth)
    local wellLocations = {}
    local startXPos, startYPos, startZPos, startDir = x, y, z, dir

    -- Generate initial well positions
    for z = 0, -(depth - 1), -1 do
        for x = 0, (width - 1), 1 do
            if z % 4 == 0 and x % 4 == 0 then
                table.insert(wellLocations, {x, y, z}) -- assumes y is global
            end
        end
    end

    -- Duplicate with (2, 0, -2) offset
    local originalCount = #wellLocations
    for index = 1, originalCount do
        local loc = wellLocations[index]
        table.insert(wellLocations, {loc[1] + 2, loc[2], loc[3] - 2})
    end

    -- Remove locations out of bounds
    local i = 1
    while i <= #wellLocations do
        local x, _, z = table.unpack(wellLocations[i])
        if x < 0 or x >= width or math.abs(z) > depth then
            table.remove(wellLocations, i)
        else
            i = i + 1
        end
    end

    for i = 1, #wellLocations, 1 do
        
        moveToLocation(wellLocations[i][1], wellLocations[i][2], wellLocations[i][3])
        mineWellAndCollectOres()
        
        moveToLocation(startXPos,startYPos,startZPos)
        turnToDirection(startDir)

        turnLeft()
        turnLeft()

        refuelAll(2000)
        
        dumpInventory(""forward"")
    end
end

--go to starting location when loaded again
moveToLocation(0,0,0)
turnToDirection(""n"")

local args = { ... }

if not args[1] then
    print(""Usage:"")
    print(""mine reset (Reset turtle origin point)"")
    print(""mine smartQuary <width> <depth> (Mine a grid of ore wells)"")
    return

elseif args[1] == ""reset"" then
    resetState()
    return

elseif args[1] == ""smartQuary"" then
    local width = tonumber(args[2])
    local depth = tonumber(args[3])

    if width and depth then
        mineWellInGrid(width, depth)
    else
        print(""Usage: mine smartQuary <width> <depth>"")
        print(""Example: mine smartQuary 16 20"")
    end
    return

else
    print(""Unknown subcommand: "" .. tostring(args[1]))
    print(""Use one of the following:"")
    print(""reset"")
    print(""smartQuary <width> <depth>"")
    return
end










"
PAR1dc10,PersonalAccessToken.php,wzee1,PHP,Wednesday 23rd of July 2025 02:44:34 PM CDT,"<?php

namespace App\Models;

use Laravel\Sanctum\PersonalAccessToken as SanctumPersonalAccessToken;
use MongoDB\Laravel\Eloquent\DocumentModel;
use MongoDB\BSON\ObjectID;

class PersonalAccessToken extends SanctumPersonalAccessToken
{
    use DocumentModel;

    protected $connection = 'mongodb';
    protected $collection = 'personal_access_tokens';


    protected $primaryKey = '_id';
    protected $keyType = 'string';
    public $incrementing = false;



    protected $fillable = [
        'name',
        'token',
        'abilities',
        'last_used_at',
        'expires_at',
        'session_id'
    ];

    /**
     * Set the tokenable_id attribute, ensuring it's a MongoDB ObjectID.
     * This handles cases where a string ID might be passed.
     *
     * @param  mixed  $value
     * @return void
     */
    public function setTokenableIdAttribute($value)
    {
        // If the value is already an ObjectID, use it directly.
        // Otherwise, attempt to create an ObjectID from the string.
        $this->attributes['tokenable_id'] = (string) $value;
    }

    /**
     * Cast the tokenable_id attribute to ObjectID when retrieving.
     * While not strictly necessary for saving, it ensures consistency.
     *
     * @var array
     */
    protected $casts = [
        'abilities' => 'array',
        'expires_at' => 'datetime',
        'last_used_at' => 'datetime',
    ];
}
"
TLtfufRX,Homework45,JohnJuly,C#,Wednesday 23rd of July 2025 02:42:24 PM CDT,"using System;
using System.Collections.Generic;

namespace Homework45
{
    class Program
    {
        static void Main(string[] args)
        {
            Arena arena = new Arena();
            arena.Run();
        }
    }

    public static class UserUtils
    {
        private static readonly Random _random = new Random();

        public static int GenerateRandomNumber(int min, int max)
        {
            return _random.Next(min, max + 1);
        }
    }

    abstract class Fighter
    {
        public Fighter(string type, string name, int damage, int defense, int health, string uniqueAbilityDescription)
        {
            Type = type;
            Name = name;
            Damage = damage;
            Defense = defense;
            Health = health;
            UniqueAbilityDescription = uniqueAbilityDescription;
        }

        public string Type { get; protected set; }
        public string Name { get; protected set; }
        public int Damage { get; protected set; }
        public int Defense { get; protected set; }
        public int Health { get; protected set; }
        public string UniqueAbilityDescription { get; protected set; }

        public virtual void Attack(Fighter opponent)
        {
            int damageToDeal = Math.Max(0, Damage);
            Console.WriteLine($""{Name} атакует {opponent.Name} и наносит {damageToDeal} урона."");
            opponent.TakeDamage(damageToDeal, this);
        }

        public virtual void TakeDamage(int damage, Fighter attacker)
        {
            int damageToTake = Math.Max(0, damage - Defense);
            Health = Math.Max(0, Health - damageToTake);
            Console.WriteLine($""{Name} получает {damageToTake} урона от {attacker.Name}. Осталось здоровья: {Health}"");
        }

        public virtual bool IsAlive() => Health > 0;

        public virtual string GetShortStats() =>
            $""( Имя: {Name} | Здоровье: {Health} | Урон: {Damage} | Защита: {Defense} | Способность: {UniqueAbilityDescription})"";

        public virtual Fighter Clone()
        {
            return (Fighter)MemberwiseClone();
        }
    }

    class BasicFighter : Fighter
    {
        public BasicFighter(string name, int damage, int defense, int health)
            : base(""Базовый Боец"", name, damage, defense, health, ""Нет особых способностей"") { }

        public override Fighter Clone()
        {
            return new BasicFighter(Name, Damage, Defense, Health);
        }
    }

    class DoubleDamageFighter : Fighter
    {
        private int _doubleDamageChance = 30;
        private int _damageMultiplier = 2;
        private int _randomNumberMin = 1;
        private int _randomNumberMax = 100;

        public DoubleDamageFighter(string name, int damage, int defense, int health)
            : base(""Двойной Урон"", name, damage, defense, health, ""Имеет шанс нанести удвоенный урон"") { }

        public override Fighter Clone()
        {
            return new DoubleDamageFighter(Name, Damage, Defense, Health);
        }

        public override void Attack(Fighter opponent)
        {
            bool didDoubleDamage = false;

            if (UserUtils.GenerateRandomNumber(_randomNumberMin, _randomNumberMax) <= _doubleDamageChance)
            {
                int doubledDamage = Damage * _damageMultiplier;
                Console.WriteLine($""{Name} использует двойной урон и наносит {doubledDamage} урона!"");
                opponent.TakeDamage(doubledDamage, this);
                didDoubleDamage = true;
            }

            if (didDoubleDamage)
            {
                int doubledDamage = Damage * _damageMultiplier;
                opponent.TakeDamage(doubledDamage, this);
            }
            else
            {
                base.Attack(opponent);
            }
        }
    }

    class TripleAttackFighter : Fighter
    {
        private int _attackInterval = 3;
        private int _attackCounter = 0;

        public TripleAttackFighter(string name, int damage, int defense, int health)
            : base(""Тройная Атака"", name, damage, defense, health, ""Каждую третью атаку наносит три удара подряд"") { } 

        public override Fighter Clone()
        {
            return new TripleAttackFighter(Name, Damage, Defense, Health);
        }

        public override void Attack(Fighter opponent)
        {
            _attackCounter++;

            if (_attackCounter % _attackInterval == 0)
            {
                
                Console.WriteLine($""{Name} проводит серию из трех атак!"");
                for (int i = 0; i < 3; i++)
                {
                    int damageToDeal = Math.Max(0, Damage);
                    Console.WriteLine($""{Name} атакует {opponent.Name} и наносит {damageToDeal} урона."");
                    opponent.TakeDamage(damageToDeal, this);
                }
            }
            else
            {
                base.Attack(opponent);
            }
        }
    }

    class RageFighter : Fighter
    {
        private int _rage = 0;
        private int _maxRage = 100;
        private int _healingAmount = 30;
        private int _maxHealthValue = 100;

        public RageFighter(string name, int damage, int defense, int health)
            : base(""Ярость"", name, damage, defense, health, ""Получая урон накапливает ярость и лечится"") { }

        public override Fighter Clone()
        {
            return new RageFighter(Name, Damage, Defense, Health);
        }

        public override void TakeDamage(int damage, Fighter attacker)
        {
            base.TakeDamage(damage, attacker);
            _rage = Math.Min(_rage + damage, _maxRage);

            if (_rage == _maxRage && Health > 0)
            {
                int healedAmount = Math.Min(_healingAmount, _maxHealthValue - Health);
                Health += healedAmount;
                Console.WriteLine($""{Name} накапливает ярость и использует лечение! Восстановлено {healedAmount} здоровья. Текущее здоровье: {Health}"");
                _rage = 0;
            }
        }
    }

    class MageFighter : Fighter
    {
        private int _mana = 100;
        private int _maxMana = 100;
        private int _fireBallCost = 30;
        private int _fireBallDamageMultiplier = 2;
        private int _manaRegenerationAmount = 10;

        public MageFighter(string name, int damage, int defense, int health)
            : base(""Маг"", name, damage, defense, health, ""Использует заклинание огненный шар"") { }

        public override Fighter Clone()
        {
            return new MageFighter(Name, Damage, Defense, Health);
        }

        public override void Attack(Fighter opponent)
        {
            if (_mana >= _fireBallCost)
            {
                _mana -= _fireBallCost;
                int fireBallDamage = Damage * _fireBallDamageMultiplier;
                Console.WriteLine($""{Name} использует ОГНЕННЫЙ ШАР и наносит {fireBallDamage} урона! Осталось маны: {_mana}"");
                opponent.TakeDamage(fireBallDamage, this);
            }
            else
            {
                base.Attack(opponent);
                _mana = Math.Min(_maxMana, _mana + _manaRegenerationAmount);
                Console.WriteLine($""{Name} использует обычную атаку. Осталось маны: {_mana}"");
            }
        }
    }

    class DodgeFighter : Fighter
    {
        private int _dodgeChance = 30;
        private int _randomNumberMin = 1;
        private int _randomNumberMax = 100;

        public DodgeFighter(string name, int damage, int defense, int health)
            : base(""Уклонение"", name, damage, defense, health, ""Имеет шанс уклониться от атаки"") { }

        public override Fighter Clone()
        {
            return new DodgeFighter(Name, Damage, Defense, Health);
        }

        public override void TakeDamage(int damage, Fighter attacker)
        {
            if (UserUtils.GenerateRandomNumber(_randomNumberMin, _randomNumberMax) > _dodgeChance)
            {
                base.TakeDamage(damage, attacker);
            }
            else
            {
                Console.WriteLine($""{Name} УКЛОНЯЕТСЯ от атаки!"");
            }
        }
    }

    class Arena
    {
        private List<Fighter> _availableFighters = new List<Fighter>();

        public Arena()
        {
            _availableFighters.AddRange(new Fighter[]
            {
                new DoubleDamageFighter(""TempleKnight"", 15, 5, 100),
                new TripleAttackFighter(""Knight"", 12, 7, 110),
                new RageFighter(""Rager"", 10, 8, 120),
                new MageFighter(""Sorcerer"", 18, 3, 90),
                new DodgeFighter(""Dodger"", 11, 6, 105),
                new BasicFighter(""Warrior"", 13, 6, 115),
            });
        }

        public void Run()
        {
            const string CommandFight = ""go"";
            const string CommandExitMenu = ""exit"";

            bool isProgramUp = true;

            while (isProgramUp)
            {
                Console.WriteLine(""Добро пожаловать на арену Колизея!"");
                Console.WriteLine($""\nВыберите действие: \n1) Введите '{CommandFight}' чтобы посмотреть бой "" +
                                  $""\n2) Введите '{CommandExitMenu}' чтобы выйти"");

                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandFight:
                        ConductFight();
                        break;

                    case CommandExitMenu:
                        isProgramUp = false;
                        break;

                    default:
                        Console.WriteLine(""Неверная команда!!!"");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }

        private void ConductFight()
        {
            Console.WriteLine(""\nСписок доступных бойцов:"");

            for (int i = 0; i < _availableFighters.Count; i++)
            {
                Console.WriteLine($""{i + 1}. {_availableFighters[i].Name} ({_availableFighters[i].Type}) {_availableFighters[i].GetShortStats()}"");
            }

            Fighter fighter1;

            if (!TryChooseFighter(""первого"", out fighter1))
            {
                Console.WriteLine(""Не удалось выбрать первого бойца. Бой не состоится."");
                return;
            }

            Fighter fighter2;

            if (!TryChooseFighter(""второго"", out fighter2))
            {
                Console.WriteLine(""Не удалось выбрать второго бойца. Бой не состоится."");
                return;
            }

            SimulateFight(fighter1, fighter2);
        }

        private bool TryChooseFighter(string ordinalNumber, out Fighter fighter)
        {
            fighter = null;

            Console.Write($""Выберите порядковый номер {ordinalNumber} бойца: "");

            if (int.TryParse(Console.ReadLine(), out int fighterNumber) &&
                fighterNumber >= 1 && fighterNumber <= _availableFighters.Count)
            {
                fighter = _availableFighters[fighterNumber - 1].Clone();
                return true;
            }
            else
            {
                Console.WriteLine(""Неверный ввод или номер бойца. Пожалуйста, выберите номер из списка."");
                return false;
            }
        }

        private void SimulateFight(Fighter fighter1, Fighter fighter2)
        {
            Console.WriteLine(""\n=== Начинается бой! ==="");
            Console.WriteLine($""Боец 1: {fighter1.Name} ({fighter1.Type})"");
            Console.WriteLine($""Боец 2: {fighter2.Name} ({fighter2.Type})"");

            int round = 1;

            List<Fighter> fighters = new List<Fighter> { fighter1, fighter2 };

            while (fighter1.IsAlive() && fighter2.IsAlive())
            {
                Console.WriteLine($""\n--- Раунд {round} ---"");

                for (int i = 0; i < fighters.Count; i++)
                {
                    Fighter attacker = fighters[i];
                    Fighter defender = fighters[(i + 1) % fighters.Count];
                    PerformRound(attacker, defender, round);
                    if (fighter1.IsAlive() == false || fighter2.IsAlive() == false) break;
                }

                Console.WriteLine(""\nНажмите любую клавишу для продолжения..."");
                Console.ReadKey();
                Console.Clear();

                round++;
            }

            DeclareResult(fighter1, fighter2);
        }

        private void PerformRound(Fighter attacker, Fighter defender, int round)
        {
            PerformAttack(attacker, defender);

            Console.WriteLine($""\nСтатистика после раунда {round}:"");
            Console.WriteLine($""  {attacker.Name}: Здоровье = {attacker.Health}"");
            Console.WriteLine($""  {defender.Name}: Здоровье = {defender.Health}"");
        }

        private void PerformAttack(Fighter attacker, Fighter defender)
        {
            attacker.Attack(defender);
        }

        private void DeclareResult(Fighter fighter1, Fighter fighter2)
        {
            if (fighter1.IsAlive() == false && fighter2.IsAlive() == false)
            {
                Console.WriteLine(""Ничья!"");
            }
            else if (fighter1.IsAlive() == false)
            {
                DeclareWinner(fighter2);
            }
            else
            {
                DeclareWinner(fighter1);
            }
        }

        private void DeclareWinner(Fighter winner)
        {
            Console.WriteLine(""\n=== Бой окончен! ==="");
            Console.WriteLine($""Победил {winner.Name}!"");
        }
    }
}"
b9tYut2m,Percent_Lifetime_Remain for /dev/sdl,briancmoses,Bash,Wednesday 23rd of July 2025 01:27:46 PM CDT,"root@truenas[/mnt/slow/homes/admin]# smartctl -a /dev/sdl
smartctl 7.4 2023-08-01 r5530 [x86_64-linux-6.6.44-production+truenas] (local build)
Copyright (C) 2002-23, Bruce Allen, Christian Franke, www.smartmontools.org

=== START OF INFORMATION SECTION ===
Model Family:     Crucial/Micron Client SSDs
Device Model:     CT1000MX500SSD1
Serial Number:    2114E594B2E2
LU WWN Device Id: 5 00a075 1e594b2e2
Firmware Version: M3CR033
User Capacity:    1,000,204,886,016 bytes [1.00 TB]
Sector Sizes:     512 bytes logical, 4096 bytes physical
Rotation Rate:    Solid State Device
Form Factor:      2.5 inches
TRIM Command:     Available
Device is:        In smartctl database 7.3/5528
ATA Version is:   ACS-3 T13/2161-D revision 5
SATA Version is:  SATA 3.3, 6.0 Gb/s (current: 6.0 Gb/s)
Local Time is:    Wed Jul 23 13:23:24 2025 CDT
SMART support is: Available - device has SMART capability.
SMART support is: Enabled

=== START OF READ SMART DATA SECTION ===
SMART overall-health self-assessment test result: PASSED
See vendor-specific Attribute list for marginal Attributes.

General SMART Values:
Offline data collection status:  (0x82) Offline data collection activity
                                        was completed without error.
                                        Auto Offline Data Collection: Enabled.
Self-test execution status:      (   0) The previous self-test routine completed
                                        without error or no self-test has ever
                                        been run.
Total time to complete Offline
data collection:                (    0) seconds.
Offline data collection
capabilities:                    (0x7b) SMART execute Offline immediate.
                                        Auto Offline data collection on/off support.
                                        Suspend Offline collection upon new
                                        command.
                                        Offline surface scan supported.
                                        Self-test supported.
                                        Conveyance Self-test supported.
                                        Selective Self-test supported.
SMART capabilities:            (0x0003) Saves SMART data before entering
                                        power-saving mode.
                                        Supports SMART auto save timer.
Error logging capability:        (0x01) Error logging supported.
                                        General Purpose Logging supported.
Short self-test routine
recommended polling time:        (   2) minutes.
Extended self-test routine
recommended polling time:        (  30) minutes.
Conveyance self-test routine
recommended polling time:        (   2) minutes.
SCT capabilities:              (0x0031) SCT Status supported.
                                        SCT Feature Control supported.
                                        SCT Data Table supported.

SMART Attributes Data Structure revision number: 16
Vendor Specific SMART Attributes with Thresholds:
ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE
  1 Raw_Read_Error_Rate     0x002f   100   100   000    Pre-fail  Always       -       0
  5 Reallocate_NAND_Blk_Cnt 0x0032   100   100   010    Old_age   Always       -       0
  9 Power_On_Hours          0x0032   100   100   000    Old_age   Always       -       3474
 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       86
171 Program_Fail_Count      0x0032   100   100   000    Old_age   Always       -       0
172 Erase_Fail_Count        0x0032   100   100   000    Old_age   Always       -       0
173 Ave_Block-Erase_Count   0x0032   001   001   000    Old_age   Always       -       1486
174 Unexpect_Power_Loss_Ct  0x0032   100   100   000    Old_age   Always       -       29
180 Unused_Reserve_NAND_Blk 0x0033   000   000   000    Pre-fail  Always       -       24
183 SATA_Interfac_Downshift 0x0032   100   100   000    Old_age   Always       -       0
184 Error_Correction_Count  0x0032   100   100   000    Old_age   Always       -       0
187 Reported_Uncorrect      0x0032   100   100   000    Old_age   Always       -       0
194 Temperature_Celsius     0x0022   064   025   000    Old_age   Always       -       36 (Min/Max 0/75)
196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0
197 Current_Pending_ECC_Cnt 0x0032   100   100   000    Old_age   Always       -       0
198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0
199 UDMA_CRC_Error_Count    0x0032   100   100   000    Old_age   Always       -       0
202 Percent_Lifetime_Remain 0x0030   001   001   001    Old_age   Offline  FAILING_NOW 99
206 Write_Error_Rate        0x000e   100   100   000    Old_age   Always       -       0
210 Success_RAIN_Recov_Cnt  0x0032   100   100   000    Old_age   Always       -       0
246 Total_LBAs_Written      0x0032   100   100   000    Old_age   Always       -       214486819463
247 Host_Program_Page_Count 0x0032   100   100   000    Old_age   Always       -       2462390276
248 FTL_Program_Page_Count  0x0032   100   100   000    Old_age   Always       -       24864455239

SMART Error Log Version: 1
Invalid Error Log index = 0x0e (valid range is from 1 to 5)
ATA Error Count: 0 (possibly also invalid)

SMART Self-test log structure revision number 1
Num  Test_Description    Status                  Remaining  LifeTime(hours)  LBA_of_first_error
# 1  Short offline       Completed without error       00%      3439         -
# 2  Short offline       Completed without error       00%      3428         -
# 3  Short offline       Completed without error       00%      3403         -
# 4  Extended offline    Completed without error       00%      3395         -
# 5  Short offline       Completed without error       00%      3392         -
# 6  Short offline       Completed without error       00%      3375         -
# 7  Short offline       Completed without error       00%      3352         -
# 8  Short offline       Completed without error       00%      3343         -
# 9  Extended offline    Completed without error       00%      3331         -
#10  Short offline       Completed without error       00%      3320         -
#11  Short offline       Completed without error       00%      3309         -
#12  Short offline       Completed without error       00%      3299         -
#13  Short offline       Completed without error       00%      3286         -
#14  Extended offline    Completed without error       00%      3281         -
#15  Short offline       Completed without error       00%      3274         -
#16  Short offline       Completed without error       00%      3263         -
#17  Short offline       Completed without error       00%      3252         -
#18  Short offline       Completed without error       00%      3242         -
#19  Extended offline    Completed without error       00%      3235         -
#20  Short offline       Completed without error       00%      3231         -
#21  Short offline       Completed without error       00%      3220         -

SMART Selective self-test log data structure revision number 1
 SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS
    1        0        0  Not_testing
    2        0        0  Not_testing
    3        0        0  Not_testing
    4        0        0  Not_testing
    5        0        0  Not_testing
Selective self-test flags (0x0):
  After scanning selected spans, do NOT read-scan remainder of disk.
If Selective self-test is pending on power-up, resume after 0 minute delay.

The above only provides legacy SMART information - try 'smartctl -x' for more

root@truenas[/mnt/slow/homes/admin]#"
LpNf9SuH,Halazia CSS,Hakrabis,CSS,Wednesday 23rd of July 2025 12:26:06 PM CDT,"@font-face{font-family:""Galvitra"";src:url(https://dl.dropbox.com/s/fhiet4342pwyo0xhe2vm1/Galvitra.ttf?rlkey=mtiow4d7prjtla2axf5urqks4&dl=0)}.BC-bg{width:650px;margin:auto;padding:20px 0;position:relative;display:flex;flex-direction:column;align-items:center;background:var(--BC-bg)}.BC-bg #BC-Cnt{width:540px;border:1.5px solid var(--BC-border);padding:10px}.BC-bg #BC-Cnt .BC-img{width:540px;height:240px}.BC-bg .BC-img span.BC-tit{width:auto;height:100px;padding:5px;position:relative;left:-130px;top:100px;z-index:1;display:grid;place-items:center;font:70px Galvitra;color:var(--BC-clr-title);text-shadow:2px 2px 4px #00000080}.BC-bg .BC-img span.BC-subtit{width:450px;padding:5px;position:relative;left:15px;top:60px;z-index:1;font:15px Oswald;text-transform:uppercase;letter-spacing:4px;color:var(--BC-clr-subtitle);text-shadow:2px 2px 4px #00000080}.BC-bsq1{width:450px;background:var(--BC-bg-bsq);margin:15px 0;padding:15px;position:relative;left:-55px;display:flex;justify-content:space-around}.BC-nmb{width:100px;color:var(--BC-clr-first-number);font:100px 'Bebas Neue';display:flex;justify-content:center;align-items:center}.BC-nmb span.BC-ok{color:var(--BC-clr-number-ok)}.BC-nmb span.BC-take{color:var(--BC-clr-number-take)}.BC-txt{width:300px;height:100px;color:var(--BC-clr-text);font:13px Nunito;text-align:justify;padding:10px;overflow:auto}.BC-bsq2{width:450px;background:var(--BC-bg-bsq);margin:15px 0;padding:20px;position:relative;right:-105px;display:flex;justify-content:space-around}.BC-lines{height:30px;display:flex;justify-content:center;align-items:center}.BC-line{width:100px;height:1px;background-color:var(--BC-border);margin:10px}.BC-icon{color:var(--BC-clr-icon);font-size:20px}.BC-fot{display:flex;justify-content:space-evenly;align-items:center}.BC-img2{width:125px;height:125px;border-radius:100%;border:1.7px solid var(--BC-border);padding:8px}.BC-img2 img{width:125px;height:125px;border-radius:100%}.BC-fot span.BC-quote{width:250px;color:var(--BC-clr-text);padding:10px;font:12px Nunito;text-align:justify}.BC-fot span.BC-quote span{color:var(--BC-clr-quote)}div::-webkit-scrollbar,span::-webkit-scrollbar{width:0}a.credi{color:#4d4d4d;font-family:Arial;text-decoration:none;font-size:9px;letter-spacing:2px;width:auto;position:relative;overflow:hidden;text-transform:uppercase;transition:color .3s cubic-bezier(0.11,0.7,0,1)}a.credi:hover{color:#ed6f88;transition:.2s}.citos:after{position:absolute;display:block;width:0;height:2px;background-color:#df1233;content:""""}"
1rW2bRxT,Holtop ERV esphome logger,blackscreener,YAML,Wednesday 23rd of July 2025 12:23:58 PM CDT,"esphome:
  name: $devicename
  #on_boot: 
  #  then:
    #  - pzemac.reset_energy: pzemac_1

esp32:
  board: nodemcu-32s
  #board_flash_mode: dout
  framework:
    type: esp-idf
    
    version: recommended
debug:
  update_interval: 60s


substitutions:
  devicename: reku-logger
  friendly_name: Rekuperator

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_pass

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: ""sweet-fallback-${devicename}""
    password: cvbcbcbcvbdfbgte4

captive_portal:

logger:
  baud_rate: 0
  level: DEBUG

# Enable Home Assistant API
api:
  #password: !secret api-password

ota:
  - platform: esphome

# Enable Web server
#web_server:
# port: 80
i2c:
  - id: bus_a
    sda: 21
    scl: 22
    scan: false
   # frequency: 50kHz
  - id: bus_b
    sda: 18
    scl: 19
    scan: false
  #  frequency: 50kHz


uart:
  - id: mod_bus #reku
    tx_pin: 16
    rx_pin: 17
    baud_rate: 9600
    stop_bits: 1

  - id: mod_bus2 #pzem
    tx_pin: 1
    rx_pin: 3
    baud_rate: 9600
    stop_bits: 2  #1 dla esp8266


time:
  - platform: sntp
    id: czas_systemowy

# Example configuration entry
button:
  - platform: restart
    name: ""ESP Reku Restart""

globals:
  - id: aktywny_poziom_co2
    type: int
    initial_value: '0'

  - id: tryb_wysokiej_wilgotnosci_aktywny
    type: bool
    initial_value: 'false'

  - id: przewietrzanie_timer_koniec_timestamp
    type: int
    restore_value: yes
    initial_value: '0'

  - id: okap_timer_koniec_timestamp
    type: int
    restore_value: yes # Zachowaj stan po restarcie
    initial_value: '0' # 0 oznacza, ze timer nie jest aktywny

  - id: impreza_timer_koniec_timestamp
    type: int
    restore_value: yes
    initial_value: '0' # 0 oznacza, ze timer nie jest aktywny


  - id: licznik_korekt
    type: int
    restore_value: no
    initial_value: '0'

  - id: ostatni_timestamp_korekty # Nowa zmienna globalna
    type: int
    restore_value: yes # Ważne: przywróć wartość po restarcie, aby opóźnienie działało poprawnie
    initial_value: '0' # Domyślnie 0, co oznacza, że pierwsza korekta może nastąpić od razu po uruchomieniu

  - id: limit_korekt_na_godzine
    type: int
    restore_value: no
    initial_value: '10'

  - id: stary_nawiew
    type: int
    restore_value: no
    initial_value: '0'
  - id: stary_wywiew
    type: int
    restore_value: no
    initial_value: '0'

  # Aktualny tryb z podtypem dla trybu auto
  - id: tryb_auto_status
    type: std::string
    initial_value: '""normal""'

  # Aktualny aktywny tryb
  - id: aktywny_tryb
    type: std::string
    initial_value: '""auto""'

  - id: ostatnie_obroty
    type: int
    restore_value: no
    initial_value: '0'

  - id: czy_przewietrzanie
    type: bool
    restore_value: no
    initial_value: 'false'

modbus:
  - id: mod_bus_reventon
    uart_id: mod_bus
    send_wait_time: 200ms
 #   flow_control_pin: GPIO4
  - id: mod_bus_pzem
 #   send_wait_time: 200ms
    uart_id: mod_bus2

modbus_controller:
  - id: reventon_reku
    address: 0x01
    modbus_id: mod_bus_reventon
    update_interval: 15s

  - id: pzem1
    modbus_id: mod_bus_pzem
    address: 0x1
    #command_throttle: 0ms
    setup_priority: -10
    update_interval: 5s

text_sensor:
  - platform: debug
    device:
      name: ""Device Info""
    reset_reason:
      name: ""Reset Reason""


  - platform: template
    name: ""Aktywny tryb rekuperatora""
    lambda: |-
      std::string tryb = id(aktywny_tryb);
      if (tryb == ""auto"") {
        std::string status = id(tryb_auto_status);
        //return std::string(""Tryb auto - "") + status;
        return std::string(status);
      }
      return tryb;
    update_interval: 30s


  - platform: template
    name: ""Ostatni reset korekt""
    id: ostatni_reset_korekt
    lambda: |-
      char str[20];
      time_t curr_time = id(czas_systemowy).now().timestamp;
      strftime(str, sizeof(str), ""%H:%M"", localtime(&curr_time));
      return std::string(str);
    update_interval: 1h

  - platform: template
    name: $friendly_name Uptime
    id: uptime_human
    icon: mdi:clock-start



  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Status
    id: reku_status
    register_type: holding
    address: 0x0012 #18
    response_size: 2
    raw_encode: HEXBYTES
    #bitmask: 0
    lambda: |-
       std::string z = """";
       int idx = item->offset+1;
       if ((data[idx] & 0x0001) != 0) z += ""Alarm pożarowy ON, "";
       if ((data[idx] & 0x0002) != 0) z += ""Bypass ON, "";
       if ((data[idx] & 0x0004) != 0) z += ""Bypass OFF, "";
       if ((data[idx] & 0x0008) != 0) z += ""Odladzanie, "";
       if(z.length() > 0){
         z.pop_back();
       }
       return {z};

  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Status2
    id: reku_status2
    register_type: holding
    address: 0x0012 #18
    response_size: 2
    raw_encode: HEXBYTES

  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Fault Message
    id: reku_fault_message
    register_type: holding
    address: 0x0014 #20
    response_size: 2
    raw_encode: HEXBYTES

  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Fault Message2
    id: reku_fault_message2
    register_type: holding
    address: 0x0014 #20
    response_size: 2
    #raw_encode: HEXBYTES
    lambda: |-
       std::string z = """";
       int idx = item->offset+1;
       if ((data[idx] & 0x0001) != 0) z += ""Błąd czujnika temperatury powietrza zewnętrznego (OA), "";
       if ((data[idx] & 0x0002) != 0) z += ""Błąd pamięci EEPROM, "";
       if ((data[idx] & 0x0004) != 0) z += ""Błąd czujnika temperatury powietrza wywiewanego (RA) lub SW4-3 jest w pozycji ON, ale bez podłączenia do czujnika wilgotności, "";
       if ((data[idx] & 0x0008) != 0) z += ""Błąd czujnika temperatury powietrza usuwanego (EA), "";
       if ((data[idx] & 0x0010) != 0) z += ""Błąd komunikacji, "";
       if ((data[idx] & 0x0020) != 0) z += ""Błąd czujnika temperatury powietrza nawiewanego (SA), "";
       if ((data[idx] & 0x0040) != 0) z += ""Błąd wentylatora wywiewnego, "";
       if ((data[idx] & 0x0080) != 0) z += ""Błąd wentylatora nawiewnego, "";
   
       if(z.length() > 0){
         z.pop_back();
       }
       return {z};

script:
  - id: sprawdz_ograniczenie_korekt
    mode: single
    parameters:
      korekta_id: int
    then:
      - if:
          condition:
            lambda: return id(licznik_korekt) < id(limit_korekt_na_godzine);
          then:
            - lambda: 'id(licznik_korekt) += 1;'
            - logger.log:
                format: ""Wykonano korektę. Licznik: %d / %d""
                args:
                  - id(licznik_korekt)
                  - id(limit_korekt_na_godzine)
            - if:
                condition:
                  lambda: return korekta_id == 1;
                then:
                  - script.execute: korekta_do_nadcisnienia
            - if:
                condition:
                  lambda: return korekta_id == 2;
                then:
                  - script.execute: korekta_do_podcisnienia
 
            # --- DODAJ AKTUALIZACJĘ TIMESTAMPU PO WYKONANIU KOREKTY ---
            - lambda: 'id(ostatni_timestamp_korekty) = id(czas_systemowy).now().timestamp;'
            - logger.log: ""Zaktualizowano timestamp ostatniej korekty.""
          
          else:
            - logger.log: ""Limit korekt na godzinę osiągnięty – korekta zablokowana.""

  - id: korekta_do_nadcisnienia # Zwiększa wywiew, aby zredukować nadciśnienie (nawiew > wywiew)
    mode: restart
    then:
      - lambda: |-
          const int max_fan_difference = 3; 
          int current_nawiew = id(wentylator_nawiewny).state; // Nawiew jest referencją (stała wartość)
          int current_wywiew = id(wentylator_wywiewny).state;
          int new_wywiew = current_wywiew + 1; // Próbujemy zwiększyć wywiew

          // Warunki:
          // 1. New_wywiew nie może przekroczyć 10.
          // 2. Różnica (nawiew - new_wywiew) musi być <= max_fan_difference.
          //    (Czyli wywiew może być max o 3 biegi mniejszy od nawiewu)
          if (new_wywiew <= 10 && (current_nawiew - new_wywiew) <= max_fan_difference) {
            id(wentylator_wywiewny).make_call().set_value(new_wywiew).perform();
            ESP_LOGI(""Korekta_Nadcisnienia"", ""Zwiekszono wywiew: wywiew = %d (nawiew = %d). Roznica: %d"",
                     new_wywiew, current_nawiew, current_nawiew - new_wywiew);
          } else {
            ESP_LOGI(""Korekta_Nadcisnienia"", ""Korekta nadcisnienia zablokowana: wywiew=%d, nawiew=%d. Roznica %d, limit %d. (Wywiew min/max lub poza roznica)"",
                     current_wywiew, current_nawiew, current_nawiew - current_wywiew, max_fan_difference);
          }


  - id: korekta_do_podcisnienia # Zmniejsza wywiew, aby zredukować podciśnienie (nawiew < wywiew)
    mode: restart
    then:
      - lambda: |-
          const int max_fan_difference = 3; 
          int current_nawiew = id(wentylator_nawiewny).state; // Nawiew jest referencją (stała wartość)
          int current_wywiew = id(wentylator_wywiewny).state;
          int new_wywiew = current_wywiew - 1; // Próbujemy zmniejszyć wywiew

          // Warunki:
          // 1. New_wywiew nie może schodzić poniżej 0.
          // 2. Różnica (new_wywiew - nawiew) musi być <= max_fan_difference.
          //    (Czyli wywiew może być max o 3 biegi większy od nawiewu)
          if (new_wywiew >= 0 && (new_wywiew - current_nawiew) <= max_fan_difference) {
            id(wentylator_wywiewny).make_call().set_value(new_wywiew).perform();
            ESP_LOGI(""Korekta_Podcisnienia"", ""Zmniejszono wywiew: wywiew = %d (nawiew = %d). Roznica: %d"",
                     new_wywiew, current_nawiew, new_wywiew - current_nawiew);
          } else {
            ESP_LOGI(""Korekta_Podcisnienia"", ""Korekta podcisnienia zablokowana: wywiew=%d, nawiew=%d. Roznica %d, limit %d. (Wywiew min/max lub poza roznica)"",
                     current_wywiew, current_nawiew, current_wywiew - current_nawiew, max_fan_difference);
          }

  - id: wlacz_przewietrzanie
    mode: single
    then:
      - logger.log: ""TRYB PRZEWIETRZANIA: aktywacja""
      - switch.turn_off: balans_przeplywu_switch
      - lambda: |-
          id(czy_przewietrzanie) = true;
          id(stary_nawiew) = (int)id(wentylator_nawiewny).state;
          id(stary_wywiew) = (int)id(wentylator_wywiewny).state;
          id(przewietrzanie_timer_koniec_timestamp) = id(czas_systemowy).now().timestamp + (int)id(czas_przewietrzania_minuty).state * 60;
      - number.set:
          id: wentylator_nawiewny
          value: 10
      - number.set:
          id: wentylator_wywiewny
          value: 10
      - lambda: |-
          int czas = (int)id(czas_przewietrzania_minuty).state;
          ESP_LOGI(""przewietrzanie"", ""Czas przewietrzania: %d min"", czas);
      - delay: !lambda 'return id(czas_przewietrzania_minuty).state * 60 * 1000;'
      - switch.turn_off: tryb_przewietrzania_switch

  - id: zakoncz_przewietrzanie
    mode: single
    then:
      - logger.log: ""TRYB PRZEWIETRZANIA: zakończenie – przywracanie poprzednich ustawień""
      - lambda: |-
          id(czy_przewietrzanie) = false;
          id(przewietrzanie_timer_koniec_timestamp) = 0; // Wyzeruj timer
      - number.set:
          id: wentylator_nawiewny
          value: !lambda 'return id(stary_nawiew);'
      - number.set:
          id: wentylator_wywiewny
          value: !lambda 'return id(stary_wywiew);'
      - switch.turn_on: balans_przeplywu_switch
      - homeassistant.event:
          event: esphome.przewietrzanie_zakonczone
          data:
            message: ""Tryb przewietrzania zakończony""
            nawiew: !lambda 'return id(wentylator_nawiewny).state;'
            wywiew: !lambda 'return id(wentylator_wywiewny).state;'

#   - id: set_mode
#     mode: single
#     parameters:
#       tryb: std::string
#     then:
#       - lambda: |-
#           id(aktywny_tryb) = tryb;
#           id(tryb_select_esp).publish_state(tryb);
#           ESP_LOGI(""tryb"", ""Ustawiono tryb: %s"", tryb.c_str());

#       - switch.turn_on: balans_przeplywu_switch

#       - if:
#           condition:
#             lambda: return tryb == ""nocny"";
#           then:
#             - switch.turn_off: balans_przeplywu_switch
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 2
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 2

#       - if:
#           condition:
#             lambda: return tryb == ""intensywny"";
#           then:
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 10
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 10
#             - delay: 2h
#             - script.execute:
#                 id: set_mode
#                 tryb: ""normalny""

#       - if:
#           condition:
#             lambda: return tryb == ""gosc"";
#           then:
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 10
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 10
#             - switch.turn_off: balans_przeplywu_switch
#             - delay: 4h
#             - homeassistant.event:
#                 event: esphome.tryb_goscia
#                 data:
#                   message: ""Tryb gość zakończony. Powrót do normalnego trybu.""
#             - script.execute:
#                 id: set_mode
#                 tryb: ""normalny""

#       - if:
#           condition:
#             lambda: return tryb == ""urlopowy"";
#           then:
#             - switch.turn_off: balans_przeplywu_switch
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 1
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 1

#       - if:
#           condition:
#             lambda: return tryb == ""serwisowy"";
#           then:
#             - switch.turn_off: balans_przeplywu_switch
#             - switch.turn_off: tryb_przewietrzania_switch

#       - if:
#           condition:
#             lambda: return tryb == ""auto"";
#           then:
#             - switch.turn_on: balans_przeplywu_switch

#       - if:
#           condition:
#             lambda: return tryb == ""normalny"";
#           then:
#             - switch.turn_on: balans_przeplywu_switch


#       - if:
#           condition:
#             lambda: return tryb == ""okno"";
#           then:
#             - switch.turn_off: balans_przeplywu_switch
#             - number.set:
#                 id: wentylator_nawiewny
#                 value: 1
#             - number.set:
#                 id: wentylator_wywiewny
#                 value: 3
#             - lambda: id(ostatnie_obroty) = 3;

  - id: set_mode
    mode: single
    parameters:
      mode: std::string 
      target_reku_speed: int
    then:
      - lambda: |-
          std::string new_mode = mode;
          int obroty_nawiew = 0;
          int obroty_wywiew = 0;

          if (new_mode == ""auto"") {
            obroty_nawiew = 3; 
            obroty_wywiew = 3;
            ESP_LOGI(""set_mode"", ""Tryb AUTO: Poczatkowe obroty: Nawiew=%d, Wywiew=%d. Dalsza regulacja w interval."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); // Upewnij sie, ze glowny przelacznik jest ON
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy
            // W trybie auto dalsze obroty sa dynamicznie ustalane przez interval: 1min
          
          } else if (new_mode == ""nocny"") {
            obroty_nawiew = 2; 
            obroty_wywiew = 2;
            ESP_LOGI(""set_mode"", ""Tryb NOCNY: Poczatkowe obroty: Nawiew=%d, Wywiew=%d. Dalsza regulacja w interval."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy           

          } else if (new_mode == ""okno"") {
            obroty_nawiew = 1; 
            obroty_wywiew = 4; 
            ESP_LOGI(""set_mode"", ""Tryb OKNO: Nawiew=%d, Wywiew=%d."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy


          } else if (new_mode == ""normalny"") {
            obroty_nawiew = 2; 
            obroty_wywiew = 2; 
            ESP_LOGI(""set_mode"", ""Tryb NORMALNY Nawiew=%d, Wywiew=%d."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy


          } else if (new_mode == ""serwisowy"") {
            id(reku_on_off_switch).make_call().set_value(false).perform(); 
            id(tryb_przewietrzania_switch).turn_off();
            id(balans_przeplywu_switch).turn_off();
            ESP_LOGI(""set_mode"", ""Tryb SERWISOWY: Wylaczam rekuperator. Wentylatory: Nawiew=%d, Wywiew=%d."", obroty_nawiew, obroty_wywiew);
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy

          } else if (new_mode == ""urlopowy"") {
            obroty_nawiew = 1;
            obroty_wywiew = 1;
            ESP_LOGI(""set_mode"", ""Tryb URLOPOWY: Wentylatory wylaczone (Nawiew=%d, Wywiew=%d)."", obroty_nawiew, obroty_wywiew);
            id(reku_on_off_switch).make_call().set_value(true).perform();         
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy

          } else if (new_mode == ""okap_auto"") {
            obroty_nawiew = target_reku_speed;
            obroty_wywiew = target_reku_speed;
            ESP_LOGI(""set_mode"", ""Tryb OKAP_AUTO: Nawiew=%d, Wywiew=%d (zalezne od predkosci okapu)."", obroty_nawiew, obroty_wywiew);            
            id(reku_on_off_switch).make_call().set_value(true).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy
          
          } else if (new_mode == ""wylaczony"") {
            ESP_LOGI(""set_mode"", ""Tryb WYLACZONY: Rekuperator wylaczony (Nawiew=%d, Wywiew=%d)."", obroty_nawiew, obroty_wywiew);
            id(reku_on_off_switch).make_call().set_value(false).perform(); 
            id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer imprezy
            id(tryb_przewietrzania_switch).turn_off();
            id(balans_przeplywu_switch).turn_off();

          } else if (new_mode == ""impreza"") { 
            obroty_nawiew = 7; 
            obroty_wywiew = 7;
            ESP_LOGI(""set_mode"", ""Tryb IMPREZA: Nawiew=%d, Wywiew=%d. Aktywny na %d godzin."", obroty_nawiew, obroty_wywiew, (int)id(impreza_czas_trwania_godz).state);
            id(reku_on_off_switch).make_call().set_value(true).perform();
            // Ustaw timer zakonczenia trybu Impreza (teraz + zdefiniowany czas w minutach)
            id(impreza_timer_koniec_timestamp) = id(czas_systemowy).now().timestamp + (int)id(impreza_czas_trwania_godz).state * 3600;

          }
          else {
            ESP_LOGW(""set_mode"", ""Nieznany tryb: %s"", new_mode.c_str());
            return;
          }

          // Wykonaj zmiany obrotow tylko jesli tryb sie zmienil LUB
          // jesli to tryb 'okap_auto' i jego obroty sie zmienily (bo sa dynamiczne)
          // UWAGA: Jesli reku_on_off_switch zostal wylaczony wczesniej, wentylatory i tak zostana ustawione na 0.
          if (id(aktywny_tryb) != new_mode ||
              (new_mode == ""okap_auto"" && (id(wentylator_nawiewny).state != obroty_nawiew || id(wentylator_wywiewny).state != obroty_wywiew))) {

            id(aktywny_tryb) = new_mode;
            id(ostatnie_obroty) = obroty_nawiew; // Aktualizuj dla spójności

            // Aktualizacja select.tryb_select_esp ---
            id(tryb_select_esp).publish_state(new_mode); 

            // Logika ustawiania obrotow wentylatorow (wykonuje sie nawet jesli sa na 0)
            ESP_LOGI(""set_mode"", ""Przelaczono na tryb: '%s'. Ustawiam obroty: Nawiew=%d, Wywiew=%d."", new_mode.c_str(), obroty_nawiew, obroty_wywiew);
            id(wentylator_nawiewny).make_call().set_value(obroty_nawiew).perform();
            id(wentylator_wywiewny).make_call().set_value(obroty_wywiew).perform();
          } else {
            ESP_LOGD(""set_mode"", ""Tryb '%s' juz jest aktywny z obrotami Nawiew=%d. Brak zmian."", new_mode.c_str(), obroty_nawiew);
          }

interval:
  - interval: 1h
    then:
      - lambda: 'id(licznik_korekt) = 0;'
      - component.update: licznik_korekt_sensor
      - component.update: licznik_korekt_pozostale
      - component.update: ostatni_reset_korekt

  - interval: 1min
    then:
      - lambda: |-
          // Sprawdz glowny przelacznik rekuperatora. Jesli jest wylaczony, przerwij logike sterowania.
          // Tryby ""serwisowy"", ""urlopowy"", ""wylaczony"" obsluguja to poprzez wylaczenie reku_on_off_switch.
          if (!id(reku_on_off_switch).state) {
            ESP_LOGD(""interval"", ""Rekuperator wylaczony glownym przelacznikiem. Pomijam logike sterowania."");
            id(tryb_auto_status) = ""reku wylaczony (switch OFF)""; // Uaktualnij status
            return; // Przerwij dalsze wykonywanie lambdy
          }

          // --- LOGIKA DLA TRYBU OKAPU (z wykorzystaniem sensora predkosci z Home Assistant) ---
          float hood_fan_speed_percent = 0.0;
          if (id(okap_predkosc_ha).has_state()) { // Sprawdz, czy sensor ma juz stan
              hood_fan_speed_percent = id(okap_predkosc_ha).state;
          } else {
              // W przypadku braku stanu sensora, traktujemy okap jako wylaczony
              ESP_LOGW(""okap_logic"", ""Sensor okap_predkosc_ha nie ma stanu! Traktuje okap jako wylaczony."");
          }

          bool okap_is_on = hood_fan_speed_percent > 0.0; // Okap jest wlaczony, jesli predkosc > 0

          int reku_speed_for_okap = 0;
          std::string okap_status_text = """";

          if (okap_is_on) {
            // Dostosuj progi i obroty rekuperatora do swoich biezacych potrzeb
            // Przyjmujemy 3 biegi okapu: niski, sredni, wysoki
            if (hood_fan_speed_percent > 66.0) { // Np. powyzej 66% to Bieg 3 okapu
              reku_speed_for_okap = 9; // Najwyzsze obroty rekuperatora
              okap_status_text = ""Okap: Bieg 3 (Wysoki)"";
            } else if (hood_fan_speed_percent > 33.0) { // Np. powyzej 33% to Bieg 2 okapu
              reku_speed_for_okap = 7; // Srednie obroty rekuperatora
              okap_status_text = ""Okap: Bieg 2 (Sredni)"";
            } else { // Pomiedzy 0% a 33% to Bieg 1 okapu
              reku_speed_for_okap = 5; // Nizsze obroty rekuperatora
              okap_status_text = ""Okap: Bieg 1 (Niski)"";
            }

            // Aktywuj tryb okap_auto i ustaw odpowiednie obroty
            if (id(aktywny_tryb) != ""okap_auto"" ||
                id(wentylator_nawiewny).state != reku_speed_for_okap) {
              ESP_LOGI(""tryb"", ""Wykryto aktywny Okap (%s) - przelaczam w tryb OKAP_AUTO. Obroty reku: %d."", okap_status_text.c_str(), reku_speed_for_okap);
              id(set_mode)->execute(""okap_auto"", reku_speed_for_okap);
            }
            id(tryb_auto_status) = okap_status_text;

            // Ustaw ""timer"" okapu: oblicz czas zakonczenia na teraz + czas trwania z number.okap_czas_trwania_min
            id(okap_timer_koniec_timestamp) = id(czas_systemowy).now().timestamp + (int)id(okap_czas_trwania_min).state * 60;
            ESP_LOGI(""tryb"", ""Timer OKAP_AUTO zresetowany na %d minut. Koniec o: %s"", (int)id(okap_czas_trwania_min).state, id(czas_systemowy).now().strftime(""%Y-%m-%d %H:%M:%S"").c_str());

            return; // Zakoncz, bo tryb okap ma priorytet
          } else { // Okap jest wylaczony (hood_fan_speed_percent jest 0)
            if (id(aktywny_tryb) == ""okap_auto"") {
                // Jesli bylismy w trybie okap_auto, ale okap sie wylaczyl, sprawdzamy ""timer""
                if (id(czas_systemowy).now().timestamp >= id(okap_timer_koniec_timestamp)) {
                    ESP_LOGI(""tryb"", ""Okap wylaczony, timer OKAP_AUTO minal - powracam do trybu AUTO."");
                    id(set_mode)->execute(""auto"", 0);
                    id(okap_timer_koniec_timestamp) = 0; // Wyzeruj timer po zakonczeniu
                } else {
                    int remaining_seconds = id(okap_timer_koniec_timestamp) - id(czas_systemowy).now().timestamp;
                    id(tryb_auto_status) = ""Okap wylaczony (timer aktywny)"";
                    ESP_LOGD(""tryb"", ""Okap wylaczony, timer OKAP_AUTO nadal aktywny. Pozostalo: %d s"", remaining_seconds);
                }
                return;
            }
          }
          // --- KONIEC LOGIKI TRYBU OKAPU ---


          // --- LOGIKA TRYBU IMPREZA (NAJWYŻSZY PRIORYTET PO OKAPIE) ---
          if (id(aktywny_tryb) == ""impreza"") {
            if (id(czas_systemowy).now().timestamp >= id(impreza_timer_koniec_timestamp)) {
                ESP_LOGI(""tryb"", ""Timer trybu IMPREZA minal - powracam do trybu AUTO."");
                id(set_mode)->execute(""auto"", 0);
                id(impreza_timer_koniec_timestamp) = 0; // Wyzeruj timer po zakonczeniu
                return; // Zakoncz, bo tryb zmieniony
            } else {
                int remaining_minutes = (id(impreza_timer_koniec_timestamp) - id(czas_systemowy).now().timestamp) / 60;
                id(tryb_auto_status) = ""Impreza ("" + std::to_string(remaining_minutes) + "" min do konca)"";
                ESP_LOGD(""tryb"", ""Tryb IMPREZA nadal aktywny. Pozostalo: %d min"", remaining_minutes);
                return; // Zakoncz, bo tryb impreza ma priorytet nad auto/nocny
            }
          }
          // --- KONIEC LOGIKI TRYBU IMPREZA ---

          // Pobierz aktualny czas
          auto t = id(czas_systemowy).now();
          int hour = t.hour;

          // --- NOWA LOGIKA: Wyjście z trybu nocnego ---
          // Jeśli jesteśmy w trybie nocnym, a godzina nie jest już nocna (np. >= 6 rano i < 23)
          if (id(aktywny_tryb) == ""nocny"" && (hour >= 6 && hour < 23)) {
              ESP_LOGI(""tryb"", ""Koniec trybu nocnego - przechodzę w tryb AUTO."");
              id(set_mode)->execute(""auto"", 0);
              return; // Zakończ, by w tej minucie już być w trybie auto
          }
          // --- KONIEC NOWEJ LOGIKI ---


          // 1. Logika otwartego okna 
          if (id(czy_jakies_okno_otwarte).state) {
            // Jeśli okno jest otwarte i system jest włączony, ale nie jest w trybie ""okno""
            if (id(reku_on_off_switch).state && id(aktywny_tryb) != ""okno"") {
              ESP_LOGI(""tryb"", ""Okno otwarte — przełączam w tryb OKNO"");
              id(set_mode)->execute(""okno"", 0);
            }
            // Zawsze kończ działanie, jeśli jakiekolwiek okno jest otwarte
            return;
          }

          // Jeśli doszliśmy tutaj, to znaczy, że wszystkie okna są ZAMKNIĘTE.
          // Sprawdź, czy trzeba wyjść z trybu ""okno""
          if (id(aktywny_tryb) == ""okno"") {
            ESP_LOGI(""tryb"", ""Wszystkie okna zamknięte — przywracam tryb AUTO"");
            id(set_mode)->execute(""auto"", 0);
            return; // Zakończ, aby w następnej minucie już działać w trybie auto
          }



          // Sprawdź warunki do wejścia w tryb nocny
          if ((hour >= 23 || hour < 6) &&
              id(reku_on_off_switch).state == 1 &&
              !id(czy_przewietrzanie) &&
              id(aktywny_tryb) != ""serwisowy"" &&
              id(aktywny_tryb) != ""urlopowy"" &&
              id(aktywny_tryb) != ""nocny"" &&
              id(aktywny_tryb) != ""okno"" &&
              !id(dom_pusty).state) { // <--- TUTAJ USUNIĘTO DODATKOWY NAWIAS ZAMYKAJĄCY
            ESP_LOGI(""tryb"", ""Automatyczne przełączenie na tryb nocny"");
            id(set_mode)->execute(""nocny"", 0);
            return;  // pomiń dalej logikę w tej minucie
          }

          if (id(reku_on_off_switch).state != 1) {
            id(tryb_auto_status) = ""reku wyłączony"";
            return;
          }
          if (id(czy_przewietrzanie)) {
            id(tryb_auto_status) = ""przewietrzanie aktywne"";
            return;
          }

          std::string tryb = id(aktywny_tryb);

          // Deklaracje zmiennych na tym poziomie
          float hum = 0.0;
          int co2 = 0;
          bool pusty = id(dom_pusty).state; // Pobranie stanu 'dom_pusty' raz

          // Pobranie wartości z globalnych sensorów
          if (id(max_humidity_all_sensors).has_state()) {
              hum = id(max_humidity_all_sensors).state;
          } else {
              // Wartość domyślna, jeśli sensor max_humidity_all_sensors nie ma jeszcze stanu
              // To jest tylko na wypadek braku odczytu na samym starcie
              hum = 0.0;
              ESP_LOGW(""Wilgotnosc"", ""Maksymalna wilgotność nie jest dostępna!"");
          }

          // if (id(co2_value).has_state()) {
          //    co2 = (int)id(co2_value).state;
          // }
          // } else {
          //      co2 = 0.0; // Domyślna wartość w przypadku braku odczytu
          //     ESP_LOGW(""CO2"", ""Wartość CO2 nie jest dostępna!"");
          // }


          if (id(aktywny_tryb) == ""nocny"") {
            // Odczytaj aktualny poziom CO2 z sensora
            float co2 = 0.0;
            if (id(co2_value).has_state()) {
                co2 = id(co2_value).state;
            } else {
                co2 = 0.0; // Domyślna wartość w przypadku braku odczytu
                ESP_LOGW(""CO2"", ""Wartość CO2 nie jest dostępna!"");
            }

            // --- LOGIKA CO2 Z HISTEREZĄ ""OD PROGU DO PROGU"" DLA TRYBU NOCNEGO ---
            int current_co2_level_nocny = id(co2_nocny_current_level_state).state;
            int new_co2_level_nocny = current_co2_level_nocny;

            if (current_co2_level_nocny == 0 && co2 > id(co2_nocny_high).state) {
              new_co2_level_nocny = 1; // Przejście z Normalnego na Wysoki (obroty 5)
            }
            if (current_co2_level_nocny == 1 && co2 < id(co2_nocny_low).state) {
              new_co2_level_nocny = 0; // Przejście z Wysokiego na Normalny (obroty 2)
            }

            if (new_co2_level_nocny != current_co2_level_nocny) {
                id(co2_nocny_current_level_state).publish_state(new_co2_level_nocny);
                ESP_LOGI(""CO2_Nocny_Histereza"", ""Zmiana poziomu CO2 w nocy z %d na %d"", current_co2_level_nocny, new_co2_level_nocny);
            }

            int obroty_co2_nocny = 2; // Domyślne obroty w nocy
            std::string status_co2_nocny = ""nocny - niski CO2"";

            if (new_co2_level_nocny == 1) {
              obroty_co2_nocny = 5;
              status_co2_nocny = ""nocny - wysoki CO2"";
            } else { // new_co2_level_nocny == 0
              obroty_co2_nocny = 2;
              status_co2_nocny = ""nocny - niski CO2"";
            }
            // --- KONIEC LOGIKI CO2 Z HISTEREZĄ ""OD PROGU DO PROGU"" DLA TRYBU NOCNEGO ---


            // --- NOWA LOGIKA WILGOTNOŚCI NOCNEJ Z HISTEREZĄ ""OD PROGU DO PROGU"" ---
            float hum = 0.0;
            if (id(max_humidity_all_sensors).has_state()) {
                hum = id(max_humidity_all_sensors).state;
            } else {
                hum = 0.0;
                ESP_LOGW(""Wilgotnosc"", ""Maksymalna wilgotność nie jest dostępna!"");
            }

            // Odczytaj aktualny zapamiętany poziom wilgotności (0 lub 1)
            int current_hum_level_nocny = id(hum_nocna_current_level_state).state;
            int new_hum_level_nocny = current_hum_level_nocny;

            // Logika przejść w GÓRĘ
            if (current_hum_level_nocny == 0 && hum > id(wilgotnosc_nocna_high).state) {
              new_hum_level_nocny = 1; // Przejście z Niskiej na Wysoką (obroty 4)
            }

            // Logika przejść w DÓŁ
            if (current_hum_level_nocny == 1 && hum < id(wilgotnosc_nocna_low).state) {
              new_hum_level_nocny = 0; // Przejście z Wysokiej na Niską (obroty 2)
            }

            // Zaktualizuj zapamiętany poziom wilgotności, jeśli nastąpiła zmiana
            if (new_hum_level_nocny != current_hum_level_nocny) {
                id(hum_nocna_current_level_state).publish_state(new_hum_level_nocny);
                ESP_LOGI(""Wilgotnosc_Nocna_Histereza"", ""Zmiana poziomu wilgotności w nocy z %d na %d"", current_hum_level_nocny, new_hum_level_nocny);
            }

            int obroty_hum_nocny = 2; // Domyślne obroty dla wilgotności w nocy
            std::string status_hum_nocny = ""nocny - wilgotność stabilna"";

            // Ustalenie obrotów na podstawie aktualnego zapamiętanego poziomu wilgotności
            if (new_hum_level_nocny == 1) {
              obroty_hum_nocny = 4;
              status_hum_nocny = ""nocny - wysoka wilgotność"";
            } else { // new_hum_level_nocny == 0
              obroty_hum_nocny = 2;
              status_hum_nocny = ""nocny - niska wilgotność"";
            }
            // --- KONIEC LOGIKI WILGOTNOŚCI NOCNEJ Z HISTEREZĄ ""OD PROGU DO PROGU"" ---


            // Wybór wyższych obrotów (porównujemy obroty z histerezy CO2 i wilgotności)
            // Wilgotność może tylko zwiększyć obroty, nigdy ich nie obniży poniżej obrotów CO2.
            // Jeśli CO2 wymusza 5, wilgotność na 4 i tak nie obniży. Jeśli CO2 wymusza 2, wilgotność na 4 podniesie do 4.
            int obroty = std::max(obroty_co2_nocny, obroty_hum_nocny);


            if (obroty != id(ostatnie_obroty)) {
              ESP_LOGI(""tryb"", ""Zmiana obrotow w trybie NOCNYM. Nowe obroty: %d"", obroty);
              id(wentylator_nawiewny).make_call().set_value(obroty).perform();
              id(wentylator_wywiewny).make_call().set_value(obroty).perform();
              id(ostatnie_obroty) = obroty;
            }

            // Ustawienie statusu
            // Priorytet dla wilgotności, jeśli to ona wymusiła wyższe obroty
            if (obroty == obroty_hum_nocny && status_hum_nocny != """" && obroty_hum_nocny > obroty_co2_nocny) {
                id(tryb_auto_status) = status_hum_nocny;
            } else {
                id(tryb_auto_status) = status_co2_nocny;
            }
            return;
          }

          if (tryb == ""auto"") {
            // **NOWA LOGIKA: Sprawdź najpierw, czy dom jest pusty**
            if (pusty) { // Używamy zmiennej 'pusty' zdeklarowanej i ustawionej wcześniej
              // Jeśli dom jest pusty, wymuś obroty na 1 i zakończ logikę dla trybu auto
              int obroty = 1; // Minimalne obroty dla trybu ""dom pusty""
              if (obroty != id(ostatnie_obroty)) {
                id(wentylator_nawiewny).make_call().set_value(obroty).perform();
                id(wentylator_wywiewny).make_call().set_value(obroty).perform();
                id(ostatnie_obroty) = obroty;
              }
              id(tryb_auto_status) = ""dom pusty"";

            } else {
              // --- NOWA LOGIKA CO2 Z HISTEREZĄ ""OD PROGU DO PROGU"" ---
              // Odczytaj aktualny poziom CO2 z sensora
              float co2 = 0.0;
              if (id(co2_value).has_state()) {
                  co2 = id(co2_value).state;
              } else {
                  co2 = 0.0; // Domyślna wartość w przypadku braku odczytu
                  ESP_LOGW(""CO2"", ""Wartość CO2 nie jest dostępna!"");
              }

              // Odczytaj aktualny zapamiętany poziom CO2 (0, 1, 2, 3)
              int current_co2_level = id(co2_auto_current_level_state).state;
              int new_co2_level = current_co2_level;

              // Logika przejść w GÓRĘ
              if (current_co2_level == 0 && co2 > id(co2_auto_low).state) {
                new_co2_level = 1; // Przejście z Normalnego na Niski (obroty 4)
              } else if (current_co2_level == 1 && co2 > id(co2_auto_medium).state) {
                new_co2_level = 2; // Przejście z Niskiego na Średni (obroty 6)
              } else if (current_co2_level == 2 && co2 > id(co2_auto_high).state) {
                new_co2_level = 3; // Przejście ze Średniego na Wysoki (obroty 9)
              }

              // Logika przejść w DÓŁ
              // Ważne: Sprawdzamy w odwrotnej kolejności, aby zapewnić prawidłowe ""zejście""
              if (current_co2_level == 3 && co2 < id(co2_auto_high).state) {
                new_co2_level = 2; // Przejście z Wysokiego na Średni (obroty 6)
              } else if (current_co2_level == 2 && co2 < id(co2_auto_medium).state) {
                new_co2_level = 1; // Przejście ze Średniego na Niski (obroty 4)
              } else if (current_co2_level == 1 && co2 < id(co2_auto_low).state) {
                new_co2_level = 0; // Przejście z Niskiego na Normalny (obroty 3)
              }

              // Zaktualizuj zapamiętany poziom CO2, jeśli nastąpiła zmiana
              if (new_co2_level != current_co2_level) {
                  id(co2_auto_current_level_state).publish_state(new_co2_level);
                  ESP_LOGI(""CO2_Histereza"", ""Zmiana poziomu CO2 z %d na %d"", current_co2_level, new_co2_level);
              }

              int obroty_co2_hister = 3; // Domyślne obroty
              std::string status_co2_hister = ""normalny CO2"";

              // Ustalenie obrotów na podstawie aktualnego zapamiętanego poziomu CO2
              if (new_co2_level == 3) {
                obroty_co2_hister = 9;
                status_co2_hister = ""wysoki CO2"";
              } else if (new_co2_level == 2) {
                obroty_co2_hister = 6;
                status_co2_hister = ""średni CO2"";
              } else if (new_co2_level == 1) {
                obroty_co2_hister = 4;
                status_co2_hister = ""niski CO2"";
              } else { // new_co2_level == 0
                obroty_co2_hister = 3;
                status_co2_hister = ""bardzo niski CO2"";
              }
              // --- KONIEC LOGIKI CO2 Z HISTEREZĄ ""OD PROGU DO PROGU"" ---

              // --- POPRAWIONA LOGIKA WILGOTNOŚCI Z HISTEREZĄ ---
              
              // Sprawdź, czy należy WŁĄCZYĆ tryb osuszania
              if (hum > id(wilgotnosc_wysoka).state) {
                id(tryb_wysokiej_wilgotnosci_aktywny) = true;
              } 
              // Sprawdź, czy należy WYŁĄCZYĆ tryb osuszania (tylko jeśli był aktywny)
              else if (hum < id(wilgotnosc_niska).state) {
                id(tryb_wysokiej_wilgotnosci_aktywny) = false;
              }

              int obroty_hum = 3; // Domyślne obroty, gdy osuszanie nie jest potrzebne
              std::string status_hum = """";

              // Ustaw obroty i status na podstawie ZAPAMIĘTANEGO STANU
              if (id(tryb_wysokiej_wilgotnosci_aktywny)) {
                obroty_hum = 9;
                status_hum = ""osuszanie"";
              }
              
              // --- KONIEC POPRAWIONEJ LOGIKI ---

              // Wybór wyższych obrotów
              int obroty = std::max(obroty_co2_hister, obroty_hum);

              if (obroty != id(ostatnie_obroty)) {
                id(wentylator_nawiewny).make_call().set_value(obroty).perform();
                id(wentylator_wywiewny).make_call().set_value(obroty).perform();
                id(ostatnie_obroty) = obroty;
              }

              // Ustawienie statusu
              if (obroty == obroty_hum && status_hum != """") {
                id(tryb_auto_status) = ""Tryb auto - "" + status_hum;
              } else {
                id(tryb_auto_status) = ""Tryb auto - "" + status_co2_hister;
              }
            }
          }

# Example configuration entry
psram:
  mode: quad
  speed: 40MHZ


sensor:

  - platform: template
    name: ""Okap - czas do końca""
    id: okap_czas_do_konca
    unit_of_measurement: ""min""
    icon: ""mdi:stove-fan""
    update_interval: 10s # Odświeżaj co 10 sekund dla płynniejszego liczenia
    lambda: |-
      int now_timestamp = id(czas_systemowy).now().timestamp;
      int end_timestamp = id(okap_timer_koniec_timestamp);

      if (end_timestamp > now_timestamp) {
        // Oblicz pozostały czas w sekundach, a następnie w minutach
        int remaining_seconds = end_timestamp - now_timestamp;
        return (float)std::ceil(remaining_seconds / 60.0); // Zaokrągl w górę do najbliższej minuty
      } else {
        return 0; // Jeśli tryb się zakończył lub nieaktywny
      }


  - platform: template
    name: ""Impreza - czas do końca""
    id: impreza_czas_do_konca
    unit_of_measurement: ""min""
    icon: ""mdi:party-popper""
    update_interval: 60s 
    lambda: |-
      int now_timestamp = id(czas_systemowy).now().timestamp;
      int end_timestamp = id(impreza_timer_koniec_timestamp);

      if (end_timestamp > now_timestamp) {
        // Oblicz pozostały czas w sekundach, a następnie w minutach
        int remaining_seconds = end_timestamp - now_timestamp;
        return (float)std::ceil(remaining_seconds / 60.0); // Zaokrągl w górę do najbliższej minuty
      } else {
        return 0; // Jeśli tryb się zakończył lub nieaktywny
      }

  - platform: template
    name: ""Przewietrzanie - czas do końca""
    id: przewietrzanie_czas_do_konca
    unit_of_measurement: ""min""
    icon: ""mdi:timer-sand""
    update_interval: 60s # Odświeżaj co 10 sekund dla płynniejszego liczenia
    lambda: |-
      int now_timestamp = id(czas_systemowy).now().timestamp;
      int end_timestamp = id(przewietrzanie_timer_koniec_timestamp);

      if (end_timestamp > now_timestamp) {
        // Oblicz pozostały czas w sekundach, a następnie w minutach
        int remaining_seconds = end_timestamp - now_timestamp;
        return (float)std::ceil(remaining_seconds / 60.0); // Zaokrągl w górę do najbliższej minuty
      } else {
        return 0; // Jeśli przewietrzanie się zakończyło lub nieaktywne
      }

  # Nowy sensor do odczytu predkosci okapu z Home Assistant
  - platform: homeassistant
    name: ""Predkosc Okapu z HA""
    id: okap_predkosc_ha
    entity_id: fan.fan_hood # <--- ZMIEŃ TO NA PRAWIDŁOWE entity_id TWOJEGO OKAPU W HA!
    attribute: percentage # Odczytujemy atrybut 'percentage' z encji typu fan w HA
    unit_of_measurement: ""%""
    accuracy_decimals: 0
    internal: true # Ten sensor jest uzywany tylko wewnetrznie przez ESPHome


  - platform: template
    name: ""Maksymalna Wilgotność w Domu""
    id: max_humidity_all_sensors # Nowy ID dla sensora maksymalnej wilgotności
    unit_of_measurement: ""%""
    accuracy_decimals: 1
    update_interval: 60s # Ustaw interwał aktualizacji np. na 10 sekund
    lambda: |-
      float max_h = 0.0;

      if (id(wilgotnosc_lazienka).has_state()) {
          max_h = std::max(max_h, id(wilgotnosc_lazienka).state);
      }
      if (id(wilgotnosc_kuchnia).has_state()) {
          max_h = std::max(max_h, id(wilgotnosc_kuchnia).state);
      }
      if (id(wilgotnosc_kotlownia).has_state()) {
          max_h = std::max(max_h, id(wilgotnosc_kotlownia).state);
      }

      //Jeśli masz więcej sensorów, dodaj kolejne bloki if i std::max()

      return max_h;


  - platform: debug
    free:
      name: ""Heap Free""
    block:
      name: ""Heap Max Block""
    loop_time:
      name: ""Loop Time""
    psram:
      name: ""Free PSRAM""
    cpu_frequency:
      name: ""CPU Frequency""
  
  
  - platform: internal_temperature
    name: ""Internal Temperature""

  - platform: uptime
    id: uptime_sensor
    internal: True
    update_interval: 60s
    on_raw_value:
      then:
        - text_sensor.template.publish:
            id: uptime_human
            state: !lambda |-
              int seconds = round(id(uptime_sensor).raw_state);
              int days = seconds / (24 * 3600);
              seconds = seconds % (24 * 3600);
              int hours = seconds / 3600;
              seconds = seconds % 3600;
              int minutes = seconds /  60;
              seconds = seconds % 60;
              return (
                (days ? to_string(days) + ""d "" : """") +
                (hours ? to_string(hours) + ""h "" : """") +
                (minutes ? to_string(minutes) + ""m "" : """") +
                (to_string(seconds) + ""s"")
              ).c_str();

  - platform: homeassistant
    id: co2_value
    entity_id: sensor.co2_salon
    internal: true

  - platform: homeassistant
    id: wilgotnosc_lazienka
    entity_id: sensor.atc_lazienka_parter_humidity
    internal: true

  - platform: homeassistant
    entity_id: sensor.ble_kuchnia_humidity
    id: wilgotnosc_kuchnia
    internal: true

  - platform: homeassistant
    entity_id: sensor.atc_04e8_humidity
    id: wilgotnosc_kotlownia
    internal: true


  - platform: template
    name: ""Wykonane korekty (w tej godzinie)""
    id: licznik_korekt_sensor
    unit_of_measurement: ""x""
    lambda: 'return id(licznik_korekt);'
    update_interval: 60s

  - platform: template
    name: ""Pozostale korekty""
    id: licznik_korekt_pozostale
    unit_of_measurement: ""x""
    lambda: 'return id(limit_korekt_na_godzine) - id(licznik_korekt);'
    update_interval: 60s
  
  
  
  #####################################################################
  #                  KANAL NAWIEWU (POWIETRZE WCHODZACE)             #
  #####################################################################

  # 1. Czujnik SDP810 dla nawiewu - surowe ciśnienie
  - platform: sdp3x
    name: ""Cisnienie Roznicowe Nawiew""
    id: nawiew_raw_pressure
    address: 0x25
    i2c_id: bus_a # Zmień na ID Twojej magistrali dla nawiewu
    update_interval: 5s
    filters:
      # Pierwszy filtr w liście
      - exponential_moving_average:
          alpha: 0.7 # Wcięcie 2 spacje pod 'exponential_moving_average'
      # Drugi filtr w liście. Wcięcie jak pierwszy filtr (myślnik w tej samej kolumnie).
    #  - lambda: 'return x > 0 ? x : 0;'
      
    # 2. Sensor szablonowy - oblicza przepływ dla nawiewu w m3/h
  - platform: template
    name: ""Przeplyw Nawiew m3/h""
    id: nawiew_airflow_m3_h
    update_interval: 5s
    icon: ""mdi:air-filter""
    unit_of_measurement: ""m³/h""
    lambda: |-
      // Stałe fizyczne
      const float p_atm = 101325.0;    // Ciśnienie atmosferyczne w Pa
      const float R = 287.05;          // Stała gazowa dla powietrza J/(kg·K)

      // Pobierz temperaturę (°C) i przelicz na Kelwiny
      float temp_c = id(nawiew_temp).state;
      float temp_k = temp_c + 273.15;

      // Oblicz gęstość powietrza (rho)
      float rho = p_atm / (R * temp_k);

      // Średnica i pole przekroju kanału (0.2 m)
      float duct_diameter = 0.2;
      float duct_radius = duct_diameter / 2.0;
      float duct_area = M_PI * pow(duct_radius, 2.0);

      // Odczytaj ciśnienie w hPa i przelicz na Pa
      float pressure_hpa = id(nawiew_raw_pressure).state;
      float pressure_pa = pressure_hpa * 100.0;

      // Sprawdź, czy ciśnienie dodatnie
      if (pressure_pa <= 0) {
        return 0;
      }

      // Oblicz prędkość i przepływ
      float velocity_mps = sqrt((2.0 * pressure_pa) / rho);
      float flow_m3_s = velocity_mps * duct_area;

      // Przelicz na m³/h
      return flow_m3_s * 3600.0;

  #####################################################################
  #                  KANAL WYWIEWU (POWIETRZE WYCHODZACE)             #
  #####################################################################

  # 3. Czujnik SDP810 dla wywiewu - surowe ciśnienie
  - platform: sdp3x
    name: ""Cisnienie Roznicowe Wywiew""
    id: wywiew_raw_pressure
    address: 0x25
    i2c_id: bus_b # Zmień na ID Twojej magistrali dla wywiewu
    update_interval: 5s
    filters:
      - exponential_moving_average:
          alpha: 0.7
      #- lambda: 'return x > 0 ? x : 0;'
      
  # 4. Sensor szablonowy - oblicza przepływ dla wywiewu w m3/h
  - platform: template
    name: ""Przeplyw Wywiew m3/h""
    id: wywiew_airflow_m3_h
    icon: ""mdi:air-filter""
    unit_of_measurement: ""m³/h""
    update_interval: 5s
    lambda: |-
      // Stałe fizyczne
      const float p_atm = 101325.0;    // Ciśnienie atmosferyczne w Pa
      const float R = 287.05;          // Stała gazowa dla powietrza J/(kg·K)

      // Pobierz temperaturę wywiewu i przelicz na Kelwiny
      float temp_c = id(wywiew_temp).state;
      float temp_k = temp_c + 273.15;

      // Oblicz gęstość powietrza (kg/m³) z równania gazu doskonałego
      float rho = p_atm / (R * temp_k);

      // Parametry kanału
      float duct_diameter = 0.2; // Średnica kanału (m)
      float duct_radius = duct_diameter / 2.0;
      float duct_area = M_PI * pow(duct_radius, 2.0);  // Pole przekroju (m²)

      // Ciśnienie dynamiczne w hPa → Pa
      float pressure_hpa = id(wywiew_raw_pressure).state;
      float pressure_pa = pressure_hpa * 100.0;

      // Jeśli ciśnienie ≤ 0, zwróć 0
      if (pressure_pa <= 0) {
        return 0.0;
      }

      // Oblicz prędkość przepływu (m/s)
      float velocity_mps = sqrt((2.0 * pressure_pa) / rho);

      // Oblicz przepływ objętościowy (m³/s) → przelicz na m³/h
      float flow_m3_s = velocity_mps * duct_area;

      return flow_m3_s * 3600.0;


# 5. Sensor szablonowy - oblicza różnicę przepływu (Nawiew - Wywiew)
  - platform: template
    name: ""Roznica Przeplywu""
    id: flow_difference_m3_h
    icon: ""mdi:compare-arrows""
    unit_of_measurement: ""m³/h""
    update_interval: 10s
    lambda: |-
      if (isnan(id(nawiew_airflow_m3_h).state) || isnan(id(wywiew_airflow_m3_h).state)) {
        return 0.0;
      }
      return id(nawiew_airflow_m3_h).state - id(wywiew_airflow_m3_h).state;
    on_value:
      - if:
          condition:
            # 1. Sprawdź, czy balans przepływu jest włączony
            - switch.is_on: balans_przeplywu_switch
            # 2. Sprawdź, czy minął wystarczający czas od ostatniej korekty
            - lambda: |-
                // Czas opóźnienia w minutach (np. 5 minut)
                const int delay_minutes = 5; // <--- TUTAJ ZMIENIASZ CZAS OPÓŹNIENIA W MINUTACH
                const int delay_seconds = delay_minutes * 60; // Przeliczenie na sekundy

                time_t current_time = id(czas_systemowy).now().timestamp;
                int last_correction_time = id(ostatni_timestamp_korekty);
                return (current_time - last_correction_time) >= delay_seconds;
          then:
            - logger.log:
                format: ""Różnica przepływu: %.1f m³/h""
                args: [""id(flow_difference_m3_h).state""]

            - if:
                condition:
                  lambda: return id(flow_difference_m3_h).state > 30; # Nadciśnienie - nawiew o 25 m³/h większy od wywiewu
                then:
                  - script.execute:
                      id: sprawdz_ograniczenie_korekt
                      korekta_id: 1 # Wywołuje korekta_do_nadcisnienia (zwiększa wywiew)

            - if:
                condition:
                  lambda: return id(flow_difference_m3_h).state < -30; # Podciśnienie - wywiew o 25 m³/h większy od nawiewu
                then:
                  - script.execute:
                      id: sprawdz_ograniczenie_korekt
                      korekta_id: 2 # Wywołuje korekta_do_podcisnienia (zmniejsza wywiew)



 ############   PZEM-004T V3 Reku
  - platform: pzemac
    modbus_id: mod_bus_pzem
    address: 1
    id: pzemac_1
    current:
      name: ""Rekuperator prąd""
      accuracy_decimals: 2 
      id: reku_prad
    voltage:
      name: ""Rekuperator napięcie""
      unit_of_measurement: V
      accuracy_decimals: 2
      id: reku_napiecie
    energy:
      name: ""Rekuperator zużycie energii""
      filters:
        # Wh to kWh is 0.001
        - multiply: 0.001
      unit_of_measurement: kWh
      accuracy_decimals: 3
      id: pg_energia
    power:
      name: ""Rekuperator moc""
      unit_of_measurement: W
      accuracy_decimals: 2
      id: reku_moc
    frequency:
      name: ""Rekuperator częstotliwość""
      unit_of_measurement: Hz
      accuracy_decimals: 2
    power_factor:
      name: ""Rekuperator współczynnik mocy""
      accuracy_decimals: 2
      id: reku_power_factor
    update_interval: 5s

  - platform: total_daily_energy
    name: ""Rekuperator dzienne zużycie energii""
    power_id: pg_energia
    unit_of_measurement: ""kWh""
    accuracy_decimals: 3
    id: pg_daily_kwh
    icon: mdi:counter
    device_class: energy
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  - platform: template
    name: ${friendly_name} sprawność
    unit_of_measurement: ""%""
    lambda: |-
      float dzielnik = id(wywiew_temp).state - id(czerpnia_temp).state;
      if (dzielnik != 0) {
        float dzielna = id(nawiew_temp).state - id(czerpnia_temp).state;
        return (dzielna / dzielnik) * 100.0;
      } else {
        // Zwróć 0 lub inną domyślną wartość, gdy nie można wykonać obliczeń
        return 0;
      }
    accuracy_decimals: 1
    update_interval: 15s

   # sprawność temperaturowa = (T2-T1)/(T3-T1)
   # T1 – temperatura powietrza zewnętrznego (nawiewanego przed wymiennikiem) [°C]
   # T2 – temperatura powietrza nawiewanego za wymiennikiem [°C]
   # T3– temperatura powietrza wywiewanego z pomieszczeń przed wymiennikiem [°C]

  - platform: wifi_signal
    name: ${friendly_name} RSSI
    update_interval: 60s
 
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Temperatura wywiew
    id: wywiew_temp
    register_type: holding
    address: 0x000c #12
    unit_of_measurement: ""°C""
    device_class: ""temperature""
    value_type: U_WORD
    filters:
      - lambda: return x - 40.0;
    #accuracy_decimals: 1
 
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Temperatura czerpnia
    id: czerpnia_temp
    register_type: holding
    address: 0x000d #13
    unit_of_measurement: ""°C""
    device_class: ""temperature""
    value_type: U_WORD
    filters:
      - lambda: return x - 40.0;
    #accuracy_decimals: 1 
    
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Temperatura wyrzutnia
    id: wyrzutnia_temp
    register_type: holding
    address: 0x000f #15
    unit_of_measurement: ""°C""
    device_class: ""temperature""
    value_type: U_WORD
    filters:
      - lambda: return x - 40.0;
    #accuracy_decimals: 1 
     
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Temperatura nawiew
    id: nawiew_temp
    register_type: holding
    address: 0x000e #14
    unit_of_measurement: ""°C""
    device_class: ""temperature""
    value_type: U_WORD
    filters:
      - lambda: return x - 40.0;
    #accuracy_decimals: 1 
   
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} CO2
    id: co2_reku
    register_type: holding
    address: 0x0300 #768
    unit_of_measurement: ""ppm""
    device_class: ""carbon_dioxide""
    value_type: U_WORD
    skip_updates: 100    
    #accuracy_decimals: 1 
     
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Fan running time
    id: fan_running_time
    register_type: holding
    address: 0x0301 #769
    unit_of_measurement: ""min""
    value_type: U_WORD
    filters:
      - lambda: return x * 6.0;
    skip_updates: 12   
    #accuracy_decimals: 1 
     
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Wilgotność
    id: wilgotnosc_reku
    register_type: holding
    address: 0x0302 #770
    unit_of_measurement: ""%""
    device_class: ""humidity""
    value_type: U_WORD
    skip_updates: 10      
    #accuracy_decimals: 1 
     
binary_sensor:
    - platform: homeassistant
      id: okno_salon
      entity_id: binary_sensor.shelly_blu_door_window_ce04_window

    - platform: homeassistant
      id: okno_salon2
      entity_id: binary_sensor.shelly_blu_door_window_24b7_window

    - platform: homeassistant
      id: okno_gabinet_l
      entity_id: binary_sensor.shelly_blu_door_window_cc52_window

    - platform: homeassistant
      id: okno_gabinet_p
      entity_id: binary_sensor.shelly_blu_door_window_882d_window

    - platform: homeassistant
      id: okno_lazienka
      entity_id: binary_sensor.shelly_blu_door_window_06b3_window

    - platform: homeassistant
      id: dom_pusty
      entity_id: input_boolean.dom_pusty
      internal: False
      name: Dom pusty

    - platform: template
      id: czy_jakies_okno_otwarte
      name: ""Czy jakiekolwiek okno otwarte""
      lambda: |-
        return id(okno_salon).state || id(okno_salon2).state || id(okno_gabinet_l).state 
        || id(okno_gabinet_p).state || id(okno_lazienka).state;
      #on_press:
       # then:
        #  - if:
         #     condition:
          #      lambda: return id(aktywny_tryb) != ""okno"";
           #   then:
            #    - logger.log: ""Wykryto otwarte okno — przełączam na tryb OKNO""
             #   - script.execute:
              #      id: set_mode
               #     tryb: ""okno""


      #on_release:
       # then:
        #  - if:
         #     condition:
          #      lambda: return id(aktywny_tryb) == ""okno"";
           #   then:
            #    - logger.log: ""Wszystkie okna zamknięte — przywracam tryb AUTO""
             #   - script.execute:
              #      id: set_mode
               #     tryb: ""auto""

    - platform: status
      name: ${friendly_name} Logger Status

    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} On/Off status 
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0009 #9
      #bitmask: 0x1
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Auto restart status 
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0000 #0
      #bitmask: 0x1
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Nagrzewnica status 
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0001 #1
      #bitmask: 0x1
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Zewnętrzny sygnał ON/OFF 
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0010 #16
      #bitmask: 0x1
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Sygnał ON/OFF czujnika CO2
      #device_class: running
      register_type: holding
      #entity_category: diagnostic
      address: 0x0011 #17
      #bitmask: 0x1
  
switch:
  - platform: template
    name: ""Tryb przewietrzania""
    id: tryb_przewietrzania_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - script.execute: wlacz_przewietrzanie
    on_turn_off:
      - script.execute: zakoncz_przewietrzanie

  - platform: template
    name: ""Automatyczny Balans Przeplywu""
    id: balans_przeplywu_switch
    icon: ""mdi:light-switch""
    # Ustawia przełącznik na wyłączony po restarcie ESP
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true

  - platform: template
    name: ${friendly_name} switch
    id: reku_switch
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      if (id(reku_on_off_switch).state==1) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - number.set:
          id: reku_on_off_switch
          value: 1
    turn_off_action:
      - number.set:
          id: reku_on_off_switch
          value: 0 

number:
    - platform: template
      name: ""Wilgotnosc Nocna - Aktualny Poziom""
      id: hum_nocna_current_level_state
      min_value: 0
      max_value: 1 # 0 dla niskiej wilgotności (obroty 2), 1 dla wysokiej (obroty 4)
      step: 1
      mode: BOX
      optimistic: True
      initial_value: 0 # Domyślny poziom po starcie (0 = niska wilgotność)
      internal: true 

    - platform: template
      name: ""CO2 Nocny - Aktualny Poziom""
      id: co2_nocny_current_level_state
      min_value: 0
      max_value: 1 # W trybie nocnym masz tylko dwa poziomy: niski (2) i wysoki (5)
      step: 1
      mode: BOX
      optimistic: True
      initial_value: 0 # Domyślny poziom po starcie (0 = niski/normalny)
      internal: true 
 
    - platform: template
      name: ""CO2 Auto - Aktualny Poziom""
      id: co2_auto_current_level_state
      min_value: 0
      max_value: 3
      step: 1
      mode: BOX
      optimistic: true
      initial_value: 0 # Domyślny poziom po starcie (0 = normalny/niski)
      internal: true # 

    - platform: template
      name: ""Czas trwania trybu Impreza""
      id: impreza_czas_trwania_godz
      min_value: 1
      max_value: 8
      step: 1
      unit_of_measurement: ""h""
      mode: BOX
      restore_value: yes
      initial_value: 5 # Domyslny czas trwania 5 godzin
      optimistic: true

    - platform: template
      name: ""Czas trwania trybu Okap""
      id: okap_czas_trwania_min
      min_value: 5
      max_value: 60
      step: 5
      unit_of_measurement: ""min""
      mode: BOX
      restore_value: yes
      initial_value: 15 # Domyslny czas trwania 15 minut
      optimistic: true

    - id: co2_auto_high
      name: ""CO2 Auto High""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 1200
      platform: template
      mode: box

    - id: co2_auto_medium
      name: ""CO2 Auto Medium""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 1000
      platform: template
      mode: box

    - id: co2_auto_low
      name: ""CO2 Auto Low""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 800
      platform: template
      mode: box

    - id: co2_nocny_high
      name: ""CO2 Nocny High""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 800
      platform: template
      mode: box

    - id: co2_nocny_low
      name: ""CO2 Nocny Low""
      min_value: 400
      max_value: 2000
      step: 10
      unit_of_measurement: ""ppm""
      optimistic: true
      initial_value: 700
      platform: template
      mode: box

    - id: wilgotnosc_wysoka
      name: ""Wilgotność Wysoka""
      min_value: 40
      max_value: 100
      step: 1
      unit_of_measurement: ""%""
      optimistic: true
      initial_value: 70
      platform: template
      mode: box

    - id: wilgotnosc_niska
      name: ""Wilgotność Niska""
      min_value: 30
      max_value: 100
      step: 1
      unit_of_measurement: ""%""
      optimistic: true
      initial_value: 55
      platform: template
      mode: box

    - id: wilgotnosc_nocna_high
      name: ""Wilgotność nocna wysoka""
      min_value: 60
      max_value: 100
      step: 1
      unit_of_measurement: ""%""
      optimistic: true
      initial_value: 80
      platform: template
      mode: box

    - id: wilgotnosc_nocna_low
      name: ""Wilgotność nocna niska""
      min_value: 30
      max_value: 100
      step: 1
      unit_of_measurement: ""%""
      optimistic: true
      initial_value: 65
      platform: template
      mode: box
 
    - platform: template
      name: ""Czas przewietrzania""
      id: czas_przewietrzania_minuty
      min_value: 1
      max_value: 30
      step: 1
      unit_of_measurement: ""min""
      optimistic: true
      restore_value: true
      initial_value: 10
      mode: box


    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      id: reku_on_off_switch
      address: 0x0009 #9
      value_type: U_WORD
      min_value: 0
      max_value: 1
      step: 1
      mode: box
      internal: true

    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Temperatura X otwarcia bypass’u
      address: 0x0002 #2
      unit_of_measurement: ""°C""
      id: temp_x_bypass
      value_type: U_WORD
      min_value: 5
      max_value: 30
      step: 1
      mode: box
      entity_category: config

      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Temperatura Y otwarcia bypass’u
      address: 0x0003 #3
      unit_of_measurement: ""°C""
      id: temp_y_bypass
      value_type: U_WORD
      min_value: 2
      max_value: 15
      step: 1
      mode: box
      entity_category: config      
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Interwał odszraniania
      address: 0x0004 #4
      unit_of_measurement: ""min""
      #device_class: ""temperature""
      id: defrosting_interval
      value_type: U_WORD
      min_value: 15
      max_value: 99
      step: 1
      mode: box
      entity_category: config      
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Temperatura odszraniania
      address: 0x0005 #5
      unit_of_measurement: ""°C""
      id: defrosting_enter_temperature
      value_type: U_WORD
      min_value: -9
      max_value: 5
      lambda: ""return x - 40.0;""
      write_lambda: ""return x + 40.0;""
      step: 1
      mode: box
      entity_category: config      
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Czas odszraniania
      address: 0x0006 #6
      unit_of_measurement: ""min""
      #device_class: ""temperature""
      id: defrost_duration_time
      value_type: U_WORD
      min_value: 2
      max_value: 20
      step: 1
      mode: box
      entity_category: config      
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Czujnik CO2
      address: 0x0007 #7
      unit_of_measurement: ""ppm""
      id: co2_set
      value_type: U_WORD
      min_value: 00
      max_value: 2500
      lambda: ""return x * 10.0;""
      write_lambda: ""return x / 10.0;""
      step: 1
      mode: box
      entity_category: config  
      skip_updates: 20       
      
    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Wentylator nawiewny
      icon: ""mdi:fan-speed-1""
      address: 0x000a #10
      lambda: |-
         if (x == 2) {
         return 1;
         }
         if (x == 3) {
         return 2;
         }
         if (x == 5) {
         return 3;           
         }
         if (x == 8) {
         return 4;           
         }         
         if (x == 9) {
         return 5;           
         }           
         if (x == 10) {
         return 6;           
         }             
         if (x == 11) {
         return 7;           
         }            
         if (x == 12) {
         return 8;           
         }
         if (x == 13) {
         return 9;           
         }
         if (x == 14) {
         return 10;           
         } else {
          return NAN;
         }
      write_lambda: |-
         if (x == 1) {
         return 2;
         }
         if (x == 2) {
         return 3;
         }
         if (x == 3) {
         return 5;           
         }
         if (x == 4) {
         return 8;           
         }         
         if (x == 5) {
         return 9;           
         }           
         if (x == 6) {
         return 10;           
         }             
         if (x == 7) {
         return 11;           
         }            
         if (x == 8) {
         return 12;           
         }
         if (x == 9) {
         return 13;           
         }
         if (x == 10) {
         return 14;           
         } else {
          return NAN;
         }  
      #unit_of_measurement: ""%""
      id: wentylator_nawiewny
      value_type: U_WORD
      entity_category: """"
      min_value: 1
      max_value: 10
      step: 1
      mode: slider

    - platform: modbus_controller
      modbus_controller_id: reventon_reku
      name: ${friendly_name} Wentylator wywiewny
      icon: ""mdi:fan-speed-1""
      address: 0x000b #11
      lambda: |-
         if (x == 2) {
         return 1;
         }
         if (x == 3) {
         return 2;
         }
         if (x == 5) {
         return 3;           
         }
         if (x == 8) {
         return 4;           
         }         
         if (x == 9) {
         return 5;           
         }           
         if (x == 10) {
         return 6;           
         }             
         if (x == 11) {
         return 7;           
         }            
         if (x == 12) {
         return 8;           
         }
         if (x == 13) {
         return 9;           
         }
         if (x == 14) {
         return 10;           
         } else {
          return NAN;
         }
      write_lambda: |-
         if (x == 1) {
         return 2;
         }
         if (x == 2) {
         return 3;
         }
         if (x == 3) {
         return 5;           
         }
         if (x == 4) {
         return 8;           
         }         
         if (x == 5) {
         return 9;           
         }           
         if (x == 6) {
         return 10;           
         }             
         if (x == 7) {
         return 11;           
         }            
         if (x == 8) {
         return 12;           
         }
         if (x == 9) {
         return 13;           
         }
         if (x == 10) {
         return 14;           
         } else {
          return NAN;
         }  
      #unit_of_measurement: ""%""
      id: wentylator_wywiewny
      value_type: U_WORD
      entity_category: """"
      min_value: 1
      max_value: 10
      step: 1
      mode: slider    
      
select:
  - platform: template
    name: ""Tryb rekuperatora (ESP)""
    id: tryb_select_esp
    optimistic: true
    options:
      - auto
      - normalny
      - nocny
      - impreza
      - urlopowy
      - serwisowy
      - okno
      - okap_auto
    initial_option: auto
    restore_value: yes
    on_value:
      then:
        - script.execute:
            id: set_mode
            mode: !lambda 'return x;'
            target_reku_speed: 0

  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Ustawienia wielofunkcyjne
    icon: ""mdi:fan""
    id: multi_sel
    address:  0x0018 #24
    entity_category: config
    value_type: U_WORD
    optimistic: false
    optionsmap:
      ""Kasuj"": 0
      ""Usunięcie alarmu filtra"": 1
      ""Usunięcie harmonogramu tygodniowego"": 2
      
  - platform: modbus_controller
    modbus_controller_id: reventon_reku
    name: ${friendly_name} Ustawienia alarmu filtra
    icon: ""mdi:fan""
    id: filter_sel
    address:  0x0019 #25
    entity_category: config
    value_type: U_WORD
    optimistic: false
    optionsmap:
      ""45 dni"": 0
      ""60 dni"": 1
      ""90 dni"": 2
      ""180 dni"": 3

"
cz04SFkg,WTF,Boss239,C++,Wednesday 23rd of July 2025 12:05:35 PM CDT,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve() {
    int n, m; cin >> n >> m;
    vector<int> ifless(n, 1), ifmore(n, 1);
	// ifless - если меньше остальных, ifmore - если больше остальных. Изначально все могут быть и теми, и теми.
    for (int j = 0; j < m; ++j) {
        int q; cin >> q;
        vector<int> cnt(n, 0);
		// считываем сколько раз он на левой чаше сравнения (отрицательное число значит, что он на противоположной), здесь также учитывается возможность того, что какой-то человек в сравнении участвует несколько раз
        for (int i = 0; i < q; ++i) {
            int a; cin >> a; a--;
            cnt[a]++;
        }
		// сначала добавляем тех, что слева
        for (int i = 0; i < q; ++i) {
            int a; cin >> a; a--;
            cnt[a]--;
        }
		// затем вычитаем тех что справа
        char res; cin >> res;
		// теперь считываем знак
        if (res == '=') {
            for (int i = 0; i < n; ++i) {
                if (cnt[i] != 0) {
                    ifless[i] = 0; ifmore[i] = 0;
                }
            }
        }
		// если равенство, то это значит, что все, у кого по итогу ненулевой вклад равны, а значит больше не могут быть особенными
        else if (res == '>') {
            for (int i = 0; i < n; ++i) {
                if (cnt[i] <= 0) { ifmore[i] = 0; }
                if (cnt[i] >= 0) { ifless[i] = 0; }
            }
        }
		// если больше, то если у кого-то вклад не больше нуля, то его не может быть слева, а значит он не может весить больше, так как слева уже есть человек, который весит больше. По аналогии с меньше и правой частью
        else {
            for (int i = 0; i < n; ++i) {
                if (cnt[i] >= 0) { ifmore[i] = 0; }
                if (cnt[i] <= 0) { ifless[i] = 0; }
            }
        }
		// точно также, но для случая с противоположным знаком просто меняются и знаки сравнения с нулем
    }
    int ans = 0;
	// ищем ответ. Если у нас есть несколько вариантов того, что кто-то может весить больше остальных (или меньше), то ответ сразу 0, так как мы по итогу не сможем отличить эти варианты. Если же какой-то человек одновременно может весить и больше, и меньше, то это ок, ведь его могли просто ни разу не брать, а все остальные были равны.
    for (int i = 0; i < n; ++i) {
        if (ifless[i]) {
            if (ans == 0) ans = i + 1;
            else {
                cout << ""0\n"";
                return;
            }
        }
        if (ifmore[i]) {
            if (ans == 0 || ans == i + 1) ans = i + 1;
            else {
                cout << ""0\n"";
                return;
            }
        }
    }
    cout << ans << endl;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  solve();
}
"
SVREc42D,Untitled,Josif_tepe,C++,Wednesday 23rd of July 2025 10:58:36 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
typedef long long ll;
const int maxn = 200001;
const ll MOD = 1e9 + 7;
int n;
string s;
ll dp[maxn][8];

ll rec(int at, int remainder) {
    if(at == n and remainder == 0) {
        return 1;
    }
    
    if(at == n) {
        return 0;
    }
    
    if(dp[at][remainder] != -1) {
        return dp[at][remainder];
    }
    ll res = 0;
    res += rec(at + 1, remainder);
    res %= MOD;
    
    int new_remainder = (remainder * 10 + (s[at] - '0')) % 8;
    res += rec(at + 1, new_remainder);
    res %= MOD;
    
    dp[at][remainder] = res;
    return res;
}
int main() {
    cin >> n;
    cin >> s;
    
    memset(dp, -1, sizeof dp);
    cout << rec(0, 0) - 1 << endl;
    return 0;
}
"
8kfzktyn,Untitled,Josif_tepe,C++,Wednesday 23rd of July 2025 09:50:03 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
int t,n,k,s;
const int maxs=1001;
int x[maxs];
int dp[maxs][maxs][11];
int rec(int at,int movesleft,int pos){
 if(at==s){
    return 0;
 }
 int res=0;
    if(at != -1 and dp[at][movesleft][pos] != -1) {
        return dp[at][movesleft][pos];
    }
 if(at != -1 and pos==x[at]){
    res=max(res,rec(at+1,movesleft,pos)+1);
    if(movesleft>0){
        if(pos>0){
           res=max(res,rec(at+1,movesleft-1,pos-1)+1);
        }
        if(pos<n){
           res=max(res,rec(at+1,movesleft-1,pos+1)+1);
        }
    }
 }
    
    if(movesleft>0){
        if(pos>0){
           res=max(res,rec(at+1,movesleft-1,pos-1));
        }
        if(pos<n){
           res=max(res,rec(at+1,movesleft-1,pos+1));
        }
    
 }
    res=max(res,rec(at+1,movesleft,pos));
    if(at != -1) {
        dp[at][movesleft][pos] = res;
    }
    return res;
}
 
int main()
{
    cin>>t;
    for(int i = 0;i<t;i++){
        memset(dp, -1, sizeof dp);
        cin>>n>>k>>s;
        for(int j = 0;j<s;j++){
          cin>>x[j];
            x[j]--;
        }
        int rez=rec(-1,k, 0);
        cout<<rez<<endl;
    }
 
    return 0;
}
"
SkBHWwau,Ball Battles script (inf spins),Nythic,Lua,Wednesday 23rd of July 2025 09:21:07 AM CDT,"-- DISCORD: https://discord.gg/u3V8d45P9Q
 



-- Pobranie lokalnego gracza (czyli Ciebie w grze)
local player = game.Players.LocalPlayer

-- Czekanie na załadowanie się folderu ""otherValues"" i wartości ""Spins""
-- Używamy WaitForChild, aby uniknąć błędów, jeśli skrypt uruchomi się zbyt wcześnie
local spinsValue = player:WaitForChild(""otherValues""):WaitForChild(""Spins"")

-- Sprawdzenie, czy na pewno znaleziono obiekt i jest to NumberValue
if spinsValue and spinsValue:IsA(""NumberValue"") then
    -- Ustawienie wartości na nieskończoność. W Lua jest to reprezentowane przez ""math.huge""
    spinsValue.Value = math.huge
    print(""Ustawiono spiny na nieskończoność!"")
else
    warn(""Nie znaleziono obiektu 'Spins' dla gracza: "" .. player.Name)
end"
YqXn4sQu,Untitled,skytless,C++,Wednesday 23rd of July 2025 08:56:28 AM CDT,"#include <iostream>
#include <vector>

using namespace std;

using ll = long long;

void print(vector<ll> &v) {
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << ' ';
    }
    cout << endl;
}

int main() {
    //ll a[] = {2, 7, 11, 12, 18};
    //ll a[3][10];
    
    vector<ll> a;
    vector<ll> b(10);
    vector<ll> c(5);
    for (int i = 0; i < c.size(); i++) {
        c[i] = i + 1;
    }
    
    //print(a);
    //print(b);
    //print(c);
    
    c.push_back(5);
    c.erase(c.begin() + 3);
    c.insert(c.begin() + 3, 10);
    c.pop_back();
    //print(c);
    
    for (auto &x: c) {
        x++;
        cout << x << ' ';
    }
    cout << endl;
    for (auto x: c) {
        cout << x << ' ';
    }
    
    
    //vector<vector<ll>> b(3, vector<ll>(10));
 
    /*
    double d = 3.17;
    cout << d;
    */
    
    
    /*
    char c;
	c = 'D';
	//'a' -> 97, 'b' -> 98
	//'0' -> 48
	//'1' -> 49
	cout << '8' - '0';
	string s = ""abcde0"";
	for (int i = 0; i < s.size(); i++) {
	    cout << s[i] << ' ';
	}
	
	char c = '3';
    cout << int(c);
    cout << char(120);
	*/
    
    
    /*
	ll a = 2e9, b = 2e9;
	ll c;
	c = (ll)a + b;
	cout << a << ' ' << b << endl;
	cout << c;
	*/
	
	
}
"
UnkkFB3z,TDS全部地圖,chen399d,Lua,Wednesday 23rd of July 2025 08:36:52 AM CDT,"TDSMaps = {
    Version = ""0.0"",Author = ""Tseting-nil"",
	Regular = {
		AbandonedCity = { name = ""Abandoned City"", Script = """" },
		AutumnFalling = { name = ""Autumn Falling"", Script = """" },
		Crossroads = { name = ""Crossroads"", Script = """" },
		ForestCamp = { name = ""Forest Camp"", Script = """" },
		FungiIsland = { name = ""Fungi Island"", Script = """" },
		GrassIsle = { name = ""Grass Isle"", Script = """" },
		Harbor = { name = ""Harbor"", Script = """" },
		Necropolis = { name = ""Necropolis"", Script = """" },
		Portland = { name = ""Portland"", Script = """" },
		RetroCrossroads = { name = ""Retro Crossroads"", Script = """" },
		RetroStainedTemple = { name = ""Retro Stained Temple"", Script = """" },
		RocketArena = { name = ""Rocket Arena"", Script = """" },
		SkyIslands = { name = ""Sky Islands"", Script = """" },
		TropicalIsles = { name = ""Tropical Isles"", Script = """" },
		Toyboard = { name = ""Toyboard"", Script = """" },
		UTurn = { name = ""U-Turn"", Script = """" },
		ChessBoard = { name = ""Chess Board"", Script = """" },
		CoralDeep = { name = ""Coral Deep"", Script = """" },
		CrystalCave = { name = ""Crystal Cave"", Script = """" },
		CyberCity = { name = ""Cyber City"", Script = """" },
		DesertedVillage = { name = ""Deserted Village"", Script = """" },
		FarmLands = { name = ""Farm Lands"", Script = """" },
		FourSeasons = { name = ""Four Seasons"", Script = """" },
		Lighthaos = { name = ""Lighthaos"", Script = """" },
		Marshlands = { name = ""Marshlands"", Script = """" },
		MedievalTimes = { name = ""Medieval Times"", Script = """" },
		Meltdown = { name = ""Meltdown"", Script = """" },
		MoonBase = { name = ""Moon Base"", Script = """" },
		Nether = { name = ""Nether"", Script = """" },
		NightStation = { name = ""Night Station"", Script = """" },
		RetroLighthouse = { name = ""Retro Lighthouse"", Script = """" },
		RubyEscort = { name = ""Ruby Escort"", Script = """" },
		Simplicity = { name = ""Simplicity"", Script = """" },
		SpringFever = { name = ""Spring Fever"", Script = """" },
		StainedTemple = { name = ""Stained Temple"", Script = """" },
		SugarRush = { name = ""Sugar Rush"", Script = """" },
		SummerCastle = { name = ""Summer Castle"", Script = """" },
		TropicalIndustries = { name = ""Tropical Industries"", Script = """" },
		WinterBridges = { name = ""Winter Bridges"", Script = """" },
		WreckedBattlefield = { name = ""Wrecked Battlefield"", Script = """" },
		WreckedBattlefieldII = { name = ""Wrecked Battlefield II"", Script = """" },
		AbyssalTrench = { name = ""Abyssal Trench"", Script = """" },
		CandyValley = { name = ""Candy Valley"", Script = """" },
		Cataclysm = { name = ""Cataclysm"", Script = """" },
		ConstructionCrazy = { name = ""Construction Crazy"", Script = """" },
		DustyBridges = { name = ""Dusty Bridges"", Script = """" },
		ForgettenDocks = { name = ""Forgetten Docks"", Script = """" },
		GildedPath = { name = ""Gilded Path"", Script = """" },
		RetroTheHeights = { name = ""Retro The Heights"", Script = """" },
		RetroZone = { name = ""Retro Zone"", Script = """" },
		SacredMountains = { name = ""Sacred Mountains"", Script = """" },
		TheHeights = { name = ""The Heights"", Script = """" },
		WinterAbyss = { name = ""Winter Abyss"", Script = """" },
		BlackSpotExchange = { name = ""Black Spot Exchange"", Script = """" },
		DeadAhead = { name = ""Dead Ahead"", Script = """" },
		HotSpot = { name = ""Hot Spot"", Script = """" },
		InfernalAbyss = { name = ""Infernal Abyss"", Script = """" },
		LayBy = { name = ""Lay By"", Script = """" },
		MasonArch = { name = ""Mason Arch"", Script = """" },
		SpaceCity = { name = ""Space City"", Script = """" },
		WinterStronghold = { name = ""Winter Stronghold"", Script = """" }
	},
	Special = {
		BadlandsII = { name = ""Badlands II"", Script = """" },
		PizzaParty = { name = ""Pizza Party"", Script = """" },
		PollutedWastelandII = { name = ""Polluted Wasteland II"", Script = """" }
	},
	Hardcore = {
		AutumnFalling = { name = ""Autumn Falling"", script = """" },
		Crossroads = { name = ""Crossroads"", script = """" },
		Harbor = { name = ""Harbor"", script = """" },
		CyberCity = { name = ""Cyber City"", script = """" },
		FourSeasons = { name = ""Four Seasons"", script = """" },
		Marshlands = { name = ""Marshlands"", script = """" },
		MedievalTimes = { name = ""Medieval Times"", script = """" },
		Nether = { name = ""Nether"", script = """" },
		NightStation = { name = ""Night Station"", script = """" },
		WreckedBattlefield = { name = ""Wrecked Battlefield"", script = """" },
		WreckedBattlefieldII = { name = ""Wrecked Battlefield II"", script = """" },
		BlackSpotExchange = { name = ""Black Spot Exchange"", script = """" },
		HotSpot = { name = ""Hot Spot"", script = """" },
		InfernalAbyss = { name = ""Infernal Abyss"", script = """" },
		LegacySpaceCity = { name = ""Legacy Space City"", script = """" },
		SpaceCity = { name = ""Space City"", script = """" },
		UnknownGarden = { name = ""Unknown Garden"", script = """" }
	}
}

return TDSMaps
"
smvuLfqd,Automod ana,genericPaster,Python,Wednesday 23rd of July 2025 08:28:49 AM CDT,"#!/usr/bin/env python3
""""""
    Moderation Log Analyzer
    
    Analyzes Reddit moderation logs to track automod effectiveness
    and identify when human moderators are undoing automod actions.
""""""

import json
import re
from datetime import datetime
from collections import defaultdict, Counter
from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional

@dataclass
class ModAction:
    """"""    Represents a single moderation action from the log.
    
    """"""
    time: str
    moderator: str
    action_type: str
    action: str
    content: str
    username: str
    parsed_time: datetime

class ModerationAnalyzer:
    """"""    Analyzes moderation logs to track automod effectiveness and
           human moderator interventions.
    
    """"""
    
    def __init__(self, json_file_path: str):
        """"""        Initialize analyzer with moderation log data.
        
        Args:
            json_file_path: Path to the JSON moderation log file
        """"""
        self.actions = []
        self.load_data(json_file_path)
    
    def load_data(self, json_file_path: str) -> None:
        """"""        Load and parse moderation log data from JSON file.
        
        """"""
        with open(json_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        for entry in data.get('JSONdata', []):
            action = self.parse_action(entry)
            if action:
                self.actions.append(action)
        
        # Sort by time for chronological analysis
        self.actions.sort(key=lambda x: x.parsed_time)
    
    def parse_action(self, entry: Dict) -> Optional[ModAction]:
        """"""        Parse a single log entry into a ModAction object.
        
        Extracts username from content using multiple patterns to handle
        various formats in the mod log.
        """"""
        try:
            content = entry.get('Content', '')
            
            # Extract username using multiple patterns
            username = self.extract_username(content)
            if username == 'unknown':
                return None
            
            # Parse time
            time_str = entry.get('Time', '')
            parsed_time = self.parse_time(time_str)
            
            return ModAction(
                time=time_str,
                moderator=entry.get('Moderator', ''),
                action_type=entry.get('Type', ''),
                action=entry.get('Action', ''),
                content=content,
                username=username,
                parsed_time=parsed_time
            )
        except Exception as e:
            print(f""Error parsing entry: {e}"")
            return None
    
    def extract_username(self, content: str) -> str:
        """"""        Extract username from content using various patterns.
        
        Handles different formats and edge cases like system actions
        and bot-generated content.
        """"""
        # Handle empty or very short content
        if not content or len(content.strip()) < 3:
            return 'system'
        
        # Try different username patterns
        patterns = [
            r'^u/(\S+)'  # Captures non-whitespace characters after u/
        ]
        for pattern in patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                username = match.group(1)
                username = username.rstrip('.,!?:;')
                if len(username) >= 2:
                    return username
        return 'unknown'
    
    def parse_time(self, time_str: str) -> datetime:
        """"""        Parse time string into datetime object.
        
        """"""
        try:
            return datetime.strptime(time_str, '%I:%M %p %b %d, %Y')
        except:
            try:
                return datetime.strptime(time_str, '%H:%M %p %b %d, %Y')
            except:
                return datetime.now()  # Fallback
    
    def identify_undos(self) -> List[Tuple[ModAction, ModAction]]:

        undos = []
        
        # Group all actions by username only
        user_actions = defaultdict(list)
        for action in self.actions:
            user_actions[action.username].append(action)
        
        # Look for AutoMod → Human undo patterns for each user
        for username, actions in user_actions.items():
            # Sort actions by time for this user
            actions.sort(key=lambda x: x.parsed_time)
            
            # Find all AutoMod → Human action pairs
            for i, automod_action in enumerate(actions):
                if 'AutoModerator' not in automod_action.moderator:
                    continue
                    
                # Look for subsequent human actions on same user
                for j in range(i + 1, len(actions)):
                    human_action = actions[j]
                    
                    # Skip if it's another AutoMod action
                    if 'AutoModerator' in human_action.moderator:
                        continue
                    
                    # Check if this human action undoes the AutoMod action
                    if self.is_undo_pair(automod_action, human_action):
                        undos.append((automod_action, human_action))
                        break  # Only match first undo for this AutoMod action
        
        return undos
    
    def is_undo_pair(self, action1: ModAction, action2: ModAction) -> bool:
        """"""        Determine if two actions constitute an undo pair.
        
        For username-based correlation, we look for:
        - AutoMod removes/spams → Human approves/unspams
        - Any opposing moderation actions on the same user
        """"""
        # Define opposing action patterns
        removal_actions = ['Remove', 'Spam']
        approval_actions = ['Approve', 'Unspam']
        
        action1_is_removal = any(word in action1.action for word in removal_actions)
        action1_is_approval = any(word in action1.action for word in approval_actions)
        
        action2_is_removal = any(word in action2.action for word in removal_actions)
        action2_is_approval = any(word in action2.action for word in approval_actions)
        
        # Check if action2 undoes action1
        if action1_is_removal and action2_is_approval:
            return True
        
        # Also check reverse case (though less common in AutoMod context)
        if action1_is_approval and action2_is_removal:
            return True
        
        return False
    
    def generate_summary_report(self) -> str:
        """"""        Generate comprehensive summary report of moderation activity.
        
        """"""
        report = []
        report.append(""="" * 60)
        report.append(""MODERATION LOG ANALYSIS SUMMARY"")
        report.append(""="" * 60)
        
        # Basic statistics
        total_actions = len(self.actions)
        automod_actions = len([a for a in self.actions if 'AutoModerator' in a.moderator])
        human_actions = total_actions - automod_actions
        
        report.append(f""\nBASIC STATISTICS:"")
        report.append(f""Total Actions: {total_actions}"")
        report.append(f""AutoModerator Actions: {automod_actions} ({automod_actions/total_actions*100:.1f}%)"")
        report.append(f""Human Moderator Actions: {human_actions} ({human_actions/total_actions*100:.1f}%)"")
        
        # Action type breakdown
        action_counts = Counter(action.action for action in self.actions)
        report.append(f""\nACTION BREAKDOWN:"")
        for action, count in action_counts.most_common():
            report.append(f""  {action}: {count}"")
        
        # Moderator activity
        mod_counts = Counter(action.moderator for action in self.actions)
        report.append(f""\nMODERATOR ACTIVITY:"")
        for mod, count in mod_counts.most_common():
            report.append(f""  {mod}: {count}"")
        
        # Undo analysis
        undos = self.identify_undos()
        report.append(f""\nUNDO ANALYSIS:"")
        report.append(f""Total Undo Actions Found: {len(undos)}"")
        
        if undos:
            # Categorize undos
            automod_undone = [u for u in undos if 'AutoModerator' in u[0].moderator]
            human_undone = [u for u in undos if 'AutoModerator' not in u[0].moderator]
            
            report.append(f""AutoModerator Actions Undone by Humans: {len(automod_undone)}"")
            report.append(f""Human Actions Undone: {len(human_undone)}"")
            
            if automod_actions > 0:
                undo_rate = len(automod_undone) / automod_actions * 100
                report.append(f""AutoMod Undo Rate: {undo_rate:.2f}%"")
        
        return ""\n"".join(report)

    def get_undoable_actions(self, actions: List[ModAction]) -> List[ModAction]:
        """"""        Filter actions to only those that could potentially be undone.
        
        Only removal/spam actions can be undone by approval/unspam actions.
        """"""
        removal_actions = ['Remove', 'Spam']
        return [action for action in actions 
                if any(word in action.action for word in removal_actions)]
    
    def generate_effectiveness_report(self) -> str:
        """"""        Generate report on automod effectiveness for the experiment.
        
        Separates analysis by content type (Comments vs Posts/Other).
        Only counts undoable actions in effectiveness calculations.
        """"""
        undos = self.identify_undos()
        all_automod_actions = [a for a in self.actions if 'AutoModerator' in a.moderator]
        
        # Only count actions that could potentially be undone
        automod_actions = self.get_undoable_actions(all_automod_actions)
        automod_undone = [u for u in undos if 'AutoModerator' in u[0].moderator]
        
        report = []
        report.append(""="" * 60)
        report.append(""AUTOMOD EFFECTIVENESS ANALYSIS"")
        report.append(""="" * 60)
        
        if not automod_actions:
            if all_automod_actions:
                report.append(""AutoModerator performed actions, but none were undoable removal/spam actions."")
                report.append(f""Total AutoMod actions: {len(all_automod_actions)} (sticky, distinguish, etc.)"")
            else:
                report.append(""No AutoModerator actions found in log."")
            return ""\n"".join(report)
        
        # Show both totals for transparency
        report.append(f""AutoMod total actions: {len(all_automod_actions)}"")
        report.append(f""AutoMod undoable actions (Remove/Spam): {len(automod_actions)}"")
        
        # Separate actions by content type
        comment_actions = [a for a in automod_actions if a.action_type == 'Comments']
        post_actions = [a for a in automod_actions if a.action_type != 'Comments']
        
        comment_undone = [u for u in automod_undone if u[0].action_type == 'Comments']
        post_undone = [u for u in automod_undone if u[0].action_type != 'Comments']
        
        # Overall effectiveness (only for undoable actions)
        total_automod = len(automod_actions)
        undone_count = len(automod_undone)
        effectiveness = ((total_automod - undone_count) / total_automod) * 100 if total_automod > 0 else 0
        
        report.append(f""\nOVERALL EFFECTIVENESS (Undoable Actions Only):"")
        report.append(f""Total AutoMod Undoable Actions: {total_automod}"")
        report.append(f""Actions Undone by Humans: {undone_count}"")
        report.append(f""Effectiveness Rate: {effectiveness:.1f}%"")
        report.append(f""Undo Rate: {(undone_count/total_automod)*100:.1f}%"")
        
        # Comments-specific analysis
        if comment_actions:
            comment_total = len(comment_actions)
            comment_undone_count = len(comment_undone)
            comment_effectiveness = ((comment_total - comment_undone_count) / comment_total) * 100
            
            report.append(f""\nCOMMENT MODERATION EFFECTIVENESS:"")
            report.append(f""Total AutoMod Comment Actions: {comment_total}"")
            report.append(f""Comment Actions Undone: {comment_undone_count}"")
            report.append(f""Comment Effectiveness Rate: {comment_effectiveness:.1f}%"")
            report.append(f""Comment Undo Rate: {(comment_undone_count/comment_total)*100:.1f}%"")
            
            # Break down comment actions by type
            comment_by_action = defaultdict(int)
            comment_undos_by_action = defaultdict(int)
            
            for action in comment_actions:
                comment_by_action[action.action] += 1
            
            for original, _ in comment_undone:
                comment_undos_by_action[original.action] += 1
            
            if comment_by_action:
                report.append(f""\n  Comment Actions Breakdown:"")
                for action_type in comment_by_action:
                    total = comment_by_action[action_type]
                    undone = comment_undos_by_action[action_type]
                    rate = ((total - undone) / total) * 100 if total > 0 else 0
                    
                    report.append(f""    {action_type}:"")
                    report.append(f""      Total: {total}, Undone: {undone}, Effectiveness: {rate:.1f}%"")
        
        # Posts-specific analysis  
        if post_actions:
            post_total = len(post_actions)
            post_undone_count = len(post_undone)
            post_effectiveness = ((post_total - post_undone_count) / post_total) * 100
            
            report.append(f""\nPOST MODERATION EFFECTIVENESS:"")
            report.append(f""Total AutoMod Post Actions: {post_total}"")
            report.append(f""Post Actions Undone: {post_undone_count}"")
            report.append(f""Post Effectiveness Rate: {post_effectiveness:.1f}%"")
            report.append(f""Post Undo Rate: {(post_undone_count/post_total)*100:.1f}%"")
            
            # Break down post actions by type
            post_by_action = defaultdict(int)
            post_undos_by_action = defaultdict(int)
            
            for action in post_actions:
                post_by_action[action.action] += 1
            
            for original, _ in post_undone:
                post_undos_by_action[original.action] += 1
            
            if post_by_action:
                report.append(f""\n  Post Actions Breakdown:"")
                for action_type in post_by_action:
                    total = post_by_action[action_type]
                    undone = post_undos_by_action[action_type]
                    rate = ((total - undone) / total) * 100 if total > 0 else 0
                    
                    report.append(f""    {action_type}:"")
                    report.append(f""      Total: {total}, Undone: {undone}, Effectiveness: {rate:.1f}%"")
               
        return ""\n"".join(report)

def main():
    """"""    Main function to run the analysis.
    
    """"""
    import sys
    
    if len(sys.argv) != 2:
        print(""Usage: python mod_analyzer.py <json_file>"")
        sys.exit(1)
    
    json_file = sys.argv[1]
    
    try:
        analyzer = ModerationAnalyzer(json_file)
        
        print(analyzer.generate_summary_report())
        print(""\n\n"")
        print(analyzer.generate_effectiveness_report())
        print(""\n\n"")
        
    except FileNotFoundError:
        print(f""Error: File '{json_file}' not found."")
    except json.JSONDecodeError:
        print(f""Error: Invalid JSON in file '{json_file}'."")
    except Exception as e:
        print(f""Error analyzing file: {e}"")

if __name__ == ""__main__"":
    main()"
Kdz2tctU,Software Development Company in India,prologictechnologies,CSS,Wednesday 23rd of July 2025 07:39:02 AM CDT,"Prologic Technologies is a trusted software development company in India, specializing in delivering innovative, scalable, and high-performance digital solutions tailored to your business needs. With expertise in AI-powered applications, web and mobile development, custom enterprise software, and digital transformation services, we empower startups, SMBs, and global enterprises to succeed in the modern tech landscape. Our team of experienced developers, UI/UX designers, and solution architects work collaboratively to ensure every project is delivered with precision, agility, and a client-first approach. Partner with Prologic Technologies to turn your ideas into powerful software solutions.

https://www.prologic-technologies.com/"
H4Akvfp9,Untitled,Kubig,JSON,Wednesday 23rd of July 2025 07:38:47 AM CDT,"[
    {
        ""id"": 1,
        ""username"": ""SHOOL"",
        ""password"": ""123456"",
        ""tasks"": [
            {
                ""id"": 1,
                ""title"": ""500 отжиманий"",
                ""description"": ""Сделать 500 отджиманий в день"",
                ""status"": ""Incompleted"",
                ""user"": {
                    ""id"": 1,
                    ""username"": ""SHOOL"",
                    ""password"": ""123456"",
                    ""tasks"": [
                        {
                            ""id"": 1,
                            ""title"": ""500 отжиманий"",
                            ""description"": ""Сделать 500 отджиманий в день"",
                            ""status"": ""Incompleted"",
                            ""user"": {
                                ""id"": 1,
                                ""username"": ""SHOOL"",
                                ""password"": ""123456"",
                                ""tasks"": [
                                    {"
kquH3NmW,巡路模組,chen399d,Lua,Wednesday 23rd of July 2025 07:37:58 AM CDT,"-- Module: TDS_PathfindingModule
local PathfindingService = game:GetService(""PathfindingService"")
local Players = game:GetService(""Players"")
local Workspace = game:GetService(""Workspace"")
local Debris = game:GetService(""Debris"")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild(""Humanoid"")
local rootPart = character:WaitForChild(""HumanoidRootPart"")

-- === 模組表 ===
local TDS = {}

-- === 參數設定 ===
local MAX_RETRIES = 3
local PATHFINDING_TIMEOUT = 5
local PATH_VISUALIZATION_DURATION = 30
local MAX_DEVIATION = 10 -- 偏離距離

-- === 路徑顏色策略 ===
local PATH_COLORS = {
    [1] = { point = BrickColor.new(""Bright red""), connection = BrickColor.new(""Really red"") },
    [2] = { point = BrickColor.new(""Bright green""), connection = BrickColor.new(""Earth green"") },
    [3] = { point = BrickColor.new(""Bright blue""), connection = BrickColor.new(""Really blue"") }
}

local isNavigating = false
local pathParts = {}
local attemptColor = 1

-- === 清除之前路徑顯示 ===
local function clearPathVisualization()
    for _, part in pairs(pathParts) do
        if part and part.Parent then part:Destroy() end
    end
    pathParts = {}
end

-- === 可視化路徑 ===
local function visualizePath(waypoints, colorSet)
    clearPathVisualization()
    for i, waypoint in ipairs(waypoints) do
        local pathPart = Instance.new(""Part"")
        pathPart.Name = ""PathPoint_"" .. i
        pathPart.Anchored = true
        pathPart.CanCollide = false
        pathPart.Material = Enum.Material.Neon
        pathPart.BrickColor = colorSet.point
        pathPart.Size = Vector3.new(1, 0.2, 1)
        pathPart.Position = waypoint.Position
        pathPart.Parent = Workspace

        local light = Instance.new(""PointLight"")
        light.Brightness = 2
        light.Range = 5
        light.Color = colorSet.point.Color
        light.Parent = pathPart

        if i > 1 then
            local prev = waypoints[i-1]
            local distance = (waypoint.Position - prev.Position).Magnitude
            local connection = Instance.new(""Part"")
            connection.Name = ""PathConnection_"" .. (i-1) .. ""_to_"" .. i
            connection.Anchored = true
            connection.CanCollide = false
            connection.Material = Enum.Material.ForceField
            connection.BrickColor = colorSet.connection
            connection.Size = Vector3.new(0.2, 0.2, distance)
            connection.CFrame = CFrame.lookAt((waypoint.Position + prev.Position) / 2, waypoint.Position)
            connection.Parent = Workspace
            table.insert(pathParts, connection)
        end
        table.insert(pathParts, pathPart)
    end
    for _, part in pairs(pathParts) do
        Debris:AddItem(part, PATH_VISUALIZATION_DURATION)
    end
end

-- === 將目標調整到地面 ===
local function snapToGround(position)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.FilterDescendantsInstances = {character}

    local result = Workspace:Raycast(position + Vector3.new(0, 50, 0), Vector3.new(0, -100, 0), params)
    if result then
        return result.Position + Vector3.new(0, humanoid.HipHeight + 0.5, 0)
    end
    return nil
end

-- === 偏移檢測 ===
local function monitorDeviation(expectedPos)
    local currentPos = rootPart.Position
    return (currentPos - expectedPos).Magnitude <= MAX_DEVIATION
end

-- === 三階段策略尋路 ===
local function tryPathfindingWithStrategies(target)
    for attempt = 1, 3 do
        attemptColor = attempt
        local path = PathfindingService:CreatePath({
            AgentHeight = 5,
            AgentRadius = 2,
            AgentCanJump = true,
            WaypointSpacing = (attempt == 1 and 4) or (attempt == 2 and 2) or 1
        })
        local success, err = pcall(function()
            path:ComputeAsync(rootPart.Position, target)
        end)
        if success and path.Status == Enum.PathStatus.Success then
            print(""✅ 成功找到路徑（策略："" .. attempt .. ""）"")
            return path
        else
            warn(""❌ 策略 "" .. attempt .. "" 失敗："" .. (err or path.Status.Name))
        end
    end
    return nil
end

-- === 移動到單一路徑點 ===
local function moveToWaypoint(waypoint, index, total)
    local start = tick()
    humanoid:MoveTo(waypoint.Position)
    local done = false
    local connection
    connection = humanoid.MoveToFinished:Connect(function()
        done = true
        connection:Disconnect()
    end)
    while not done and tick() - start < PATHFINDING_TIMEOUT do
        wait(0.1)
    end
    if connection then connection:Disconnect() end
    return done
end

-- === 核心導航函數 ===
local function navigateTo(targetPos)
    if isNavigating then return false end
    isNavigating = true
    local adjustedTarget = snapToGround(targetPos)
    if not adjustedTarget then
        warn(""❌ 無法找到地面"")
        isNavigating = false
        return false
    end

    local path = tryPathfindingWithStrategies(adjustedTarget)
    if not path then
        warn(""❌ 所有策略失敗"")
        isNavigating = false
        return false
    end

    local waypoints = path:GetWaypoints()
    if #waypoints == 0 then
        warn(""❌ 路徑點為空"")
        isNavigating = false
        return false
    end

    visualizePath(waypoints, PATH_COLORS[attemptColor])

    for i, wp in ipairs(waypoints) do
        if not isNavigating then return false end

        -- 偏移檢測
        if not monitorDeviation(wp.Position) then
            warn(""⚠️ 偵測到偏移，重新尋路..."")
            isNavigating = false
            return navigateTo(targetPos)
        end

        -- 移動
        if wp.Action == Enum.PathWaypointAction.Walk then
            if not moveToWaypoint(wp, i, #waypoints) then
                warn(""❌ 無法到達節點，重新尋路..."")
                isNavigating = false
                return navigateTo(targetPos)
            end
        elseif wp.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
            wait(0.5)
        end

        -- ✅ 走完該節點 → 刪除對應的方塊 & 連線
        local pointName = ""PathPoint_"" .. i
        local connectionName = ""PathConnection_"" .. (i-1) .. ""_to_"" .. i
        for index, part in ipairs(pathParts) do
            if part.Name == pointName or part.Name == connectionName then
                if part and part.Parent then
                    part:Destroy()
                end
                table.remove(pathParts, index)
            end
        end
    end


    print(""🎉 成功抵達目標！"")
    isNavigating = false
    return true
end

-- === 對外 API ===
function TDS:NavigateToPosition(x, y, z)
    spawn(function()
        navigateTo(Vector3.new(x, y, z))
    end)
end

function TDS:NavigateToPlayer(playerName)
    local targetPlayer = Players:FindFirstChild(playerName)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild(""HumanoidRootPart"") then
        local pos = targetPlayer.Character.HumanoidRootPart.Position
        self:NavigateToPosition(pos.X, pos.Y, pos.Z)
    else
        warn(""❌ 找不到玩家："" .. playerName)
    end
end

function TDS:StopCurrentNavigation()
    if isNavigating then
        isNavigating = false
        humanoid:MoveTo(rootPart.Position)
        clearPathVisualization()
        print(""⏹️ 導航已停止"")
    else
        print(""ℹ️ 無進行中的導航"")
    end
end
--TDS:NavigateToPosition(7, 129, 151)
return TDS
"
MpHSe6G0,Untitled,wym36,C++,Wednesday 23rd of July 2025 07:28:05 AM CDT,"#include <iostream>
#include <vector>

using namespace std;

int main()
{
	int n, m, q, x, y;
	cin >> n >> m >> q >> x >> y;

	int a[105][105] = {};

	int dx[4] = {0, 1, 0, -1};
	int dy[4] = {1, 0, -1, 0};

	int z = 0;
	for(int i=1; i<=q; i++)
	{
		int t;
		cin >> t;
		if(t == 1)
		{
			x += dx[z];
			y += dy[z];

		}
		if(t == 2)
		{
			z += 1;
			if(z == 4)
			{
				z = 0;
			}
		}

		if(x < 0 || x >= n || y < 0 || y >= m)
		{
			x -= dx[z];
			y -= dy[z];
		}
		else
		{
			a[x][y] = i;
		}
	}

	for(int i=0; i<n; i++)
	{
		for(int j=0; j<m; j++)
			cout << a[i][j] << "" "";
		cout << ""\n"";
	}


    return 0;
}
"
K4YSJzzn,Sort and Rename Comcast Bill PDFs by Billing Date,metalx1000,Bash,Wednesday 23rd of July 2025 06:10:33 AM CDT,"#!/bin/bash
######################################################################
#Copyright (C) 2025  Kris Occhipinti
#https://filmsbykris.com

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation version 3 of the License.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
######################################################################

# This will sort/rename Comcast Bill PDFs based on the ""Billing Date"" in the PDF

for pdf in *.pdf; do
  month=""$(pdfgrep -A 1 'Billing Date' ""$pdf"" | tail -n1 | awk '{print $5}')""
  month=""$(date -d ""$month 1 2022"" +%m)""
  year=""$(pdfgrep -A 1 'Billing Date' ""$pdf"" | tail -n1 | awk '{print $7}')""

  mv -v ""$pdf"" ""Comcast Statement ${year}-${month}.pdf""
done
"
8Vh03snA,Fix Links,KukuRuzo,Diff,Wednesday 23rd of July 2025 06:03:45 AM CDT,"diff --git a/README.html b/README.html
index 12028968..1b1f0279 100644
--- a/README.html
+++ b/README.html
@@ -52,7 +52,7 @@ pkgman install psi_plus
 
 <h2>Development</h2>
 
-<p>In 2009 a Psi fork named <a href=""https://psi-plus.com/"">Psi+</a> was started. Project purposes were: implementation of new features, writing of patches and plugins for transferring them to upstream. As of 2017 all active Psi+ developers have become official Psi developers and now Psi+ is just a development branch of Psi with rolling release development model.</p>
+<p>In 2009 a Psi fork named <a href=""https://sourceforge.net/projects/psiplus/"">Psi+</a> was started. Project purposes were: implementation of new features, writing of patches and plugins for transferring them to upstream. As of 2017 all active Psi+ developers have become official Psi developers and now Psi+ is just a development branch of Psi with rolling release development model.</p>
 
 <p>Users who wants to receive new features and bug fixes very quickly may use Psi+ on daily basis. Users who do not care about new trends and prefer constancy may choose Psi as it uses classical development model and its releases are quite rare.</p>
 
@@ -134,7 +134,6 @@ pkgman install psi_plus
 <li><a href=""https://github.com/psi-im/plugins"">Officially supported plugins</a> (sources)</li>
 <li><a href=""https://github.com/psi-im/psimedia"">Multimedia plugin for audio and video calls</a> (sources)</li>
 <li><a href=""https://github.com/psi-im/resources"">Extra resources</a> (iconsets, sounds, skins, themes, etc.)</li>
-<li><a href=""https://psi-plus.com/"">Psi+ project</a> (official website)</li>
 <li><a href=""https://github.com/psi-plus/psi-plus-snapshots"">Psi+ snapshots</a> (sources)</li>
 <li><a href=""https://github.com/psi-plus/psi-plus-l10n"">Psi+ translations</a> (sources)</li>
 </ul>
@@ -149,7 +148,7 @@ pkgman install psi_plus
 <li><a href=""https://sourceforge.net/projects/psiplus/files/macOS/tehnick/"">Psi+ builds for macOS</a></li>
 <li><a href=""https://depot.haiku-os.org/psi_plus"">Psi+ package in Haiku</a></li>
 <li><a href=""https://launchpad.net/~psi-plus/+archive/ubuntu/ppa"">Official PPA for Ubuntu and distros based on it</a> (daily builds)</li>
-<li><a href=""http://notesalexp.org/index-old.html"">Unofficial PPA for Debian and Ubuntu</a> (see <a href=""https://psi-plus.com/wiki/en:debian#nightly_builds"">notes</a> about using it)</li>
+<li><a href=""http://notesalexp.org/index-old.html"">Unofficial PPA for Debian and Ubuntu</a> (see <a href=""https://psi-im.org/wiki/doku.php?id=en:debian#nightly_builds"">notes</a> about using it)</li>
 <li><a href=""https://software.opensuse.org/package/psi-plus"">Unofficial PPA for openSUSE</a> (daily builds)</li>
 <li><a href=""https://copr.fedorainfracloud.org/coprs/valdikss/psi-plus-snapshots/"">Unofficial PPA for Fedora</a> (outdated)</li>
 <li><a href=""https://repology.org/metapackage/psi-plus/versions"">Packages for different Linux distros</a></li>
diff --git a/README.md b/README.md
index 6b37b27d..62f202df 100644
--- a/README.md
+++ b/README.md
@@ -50,7 +50,7 @@ MS Windows users may download official installers and portable builds from [Sour
 
 ## Development
 
-In 2009 a Psi fork named [Psi+](https://psi-plus.com/) was started. Project purposes were: implementation of new features, writing of patches and plugins for transferring them to upstream. As of 2017 all active Psi+ developers have become official Psi developers and now Psi+ is just a development branch of Psi with rolling release development model.
+In 2009 a Psi fork named [Psi+](https://sourceforge.net/projects/psiplus/) was started. Project purposes were: implementation of new features, writing of patches and plugins for transferring them to upstream. As of 2017 all active Psi+ developers have become official Psi developers and now Psi+ is just a development branch of Psi with rolling release development model.
 
 Users who wants to receive new features and bug fixes very quickly may use Psi+ on daily basis. Users who do not care about new trends and prefer constancy may choose Psi as it uses classical development model and its releases are quite rare.
 
@@ -125,7 +125,6 @@ If you want to donate some money for development of Psi and Psi+ project, it is
 * [Officially supported plugins](https://github.com/psi-im/plugins) (sources)
 * [Multimedia plugin for audio and video calls](https://github.com/psi-im/psimedia) (sources)
 * [Extra resources](https://github.com/psi-im/resources) (iconsets, sounds, skins, themes, etc.)
-* [Psi+ project](https://psi-plus.com/) (official website)
 * [Psi+ snapshots](https://github.com/psi-plus/psi-plus-snapshots) (sources)
 * [Psi+ translations](https://github.com/psi-plus/psi-plus-l10n) (sources)
 
@@ -138,7 +137,7 @@ If you want to donate some money for development of Psi and Psi+ project, it is
 * [Psi+ builds for macOS](https://sourceforge.net/projects/psiplus/files/macOS/tehnick/)
 * [Psi+ package in Haiku](https://depot.haiku-os.org/psi_plus)
 * [Official PPA for Ubuntu and distros based on it](https://launchpad.net/~psi-plus/+archive/ubuntu/ppa) (daily builds)
-* [Unofficial PPA for Debian and Ubuntu](http://notesalexp.org/index-old.html) (see [notes](https://psi-plus.com/wiki/en:debian#nightly_builds) about using it)
+* [Unofficial PPA for Debian and Ubuntu](http://notesalexp.org/index-old.html) (see [notes](https://psi-im.org/wiki/doku.php?id=en:debian#nightly_builds) about using it)
 * [Unofficial PPA for openSUSE](https://software.opensuse.org/package/psi-plus) (daily builds)
 * [Unofficial PPA for Fedora](https://copr.fedorainfracloud.org/coprs/valdikss/psi-plus-snapshots/) (outdated)
 * [Packages for different Linux distros](https://repology.org/metapackage/psi-plus/versions)
diff --git a/linux/psi-plus.appdata.xml b/linux/psi-plus.appdata.xml
index 36b0dca1..67b9889c 100644
--- a/linux/psi-plus.appdata.xml
+++ b/linux/psi-plus.appdata.xml
@@ -30,11 +30,11 @@
     <p>Psi+ is a development branch of Psi with rolling release development model. Users who wants to receive new features and bug fixes very quickly may use Psi+ on daily basis. Users who do not care about new trends and prefer constancy may choose Psi as it uses classical development model and its releases are quite rare.</p>
     <p xml:lang=""ru"">Psi+ — это ветка разработки клиента Psi, для которой используется модель разработки с плавающим релизом. Пользователи, которые хотят быстро получать новые функции и исправления ошибок, могут использовать Psi+ на ежедневной основе. Пользователи, которые не заботятся о новых тенденциях и предпочитают постоянство, могут выбрать Psi, поскольку он использует классическую модель разработки и его выпуски довольно редки.</p>
   </description>
-  <url type=""homepage"">https://psi-plus.com/</url>
+  <url type=""homepage"">https://psi-im.org/</url>
   <url type=""bugtracker"">https://github.com/psi-im/psi/issues</url>
   <screenshots>
     <screenshot type=""default"">
-      <image>https://psi-plus.com/wi/psiplus_screen_linux_big.png</image>
+      <image>https://psi-im.org/wiki/lib/exe/fetch.php?cache=&media=psiplus_screen_linux_big.png</image>
     </screenshot>
   </screenshots>
   <content_rating type=""oars-1.1"">
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 93ddc22e..a91f387e 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -188,16 +188,15 @@ elseif(IS_WEBENGINE)
     set(PSI_VER_SUFFIX "", webengine"")
 endif()
 
+set(CLIENT_CAPS_NODE ""https://psi-im.org"")
 if( NOT PSI_PLUS )
     set(CLIENT_NAME ""Psi"")
     set(CLIENT_SNAME ""psi"")
-    set(CLIENT_CAPS_NODE ""https://psi-im.org"")
     set(PSILOGO_PREFIX """")
     set(MAIN_ICON ""psimain.png"")
 else()
     set(CLIENT_NAME ""Psi+"")
     set(CLIENT_SNAME ""psi+"")
-    set(CLIENT_CAPS_NODE ""https://psi-plus.com"")
     set(PSILOGO_PREFIX ""psiplus/"")
     set(MAIN_ICON ""psiplus_icon.png"")
 endif()
diff --git a/src/aboutdlg.cpp b/src/aboutdlg.cpp
index 261f4ae5..acd30747 100644
--- a/src/aboutdlg.cpp
+++ b/src/aboutdlg.cpp
@@ -67,7 +67,7 @@ AboutDlg::AboutDlg(QWidget *parent) : QDialog(parent)
 
     // fill in About Psi+ tab...
     QString psiplus;
-    psiplus += details(QString::fromUtf8(""Psi+ Project""), """", ""psi-dev@conference.jabber.ru"", ""https://psi-plus.com/"",
+    psiplus += details(QString::fromUtf8(""Psi+ Project""), """", ""psi-dev@conference.jabber.ru"", ""https://psi-im.org/"",
                        tr(""Active project members are presents below:""));
     psiplus += details(QString::fromUtf8(""rion""), ""rion4ik@gmail.com"", """", """", tr(""Founder and Lead Patcher""));
     psiplus += details(QString::fromUtf8(""zet""), ""vladimir.shelukhin@gmail.com"", """", """",
diff --git a/src/mainwin.cpp b/src/mainwin.cpp
index 493d9096..6816f0d5 100644
--- a/src/mainwin.cpp
+++ b/src/mainwin.cpp
@@ -1001,7 +1001,7 @@ void MainWin::actOnlineWikiActivated()
 #ifndef PSI_PLUS
         ""https://github.com/psi-im/psi/wiki""
 #else
-        ""https://psi-plus.com/wiki/en:main""
+        ""https://psi-im.org/wiki/""
 #endif
     );
 }
@@ -1009,11 +1009,7 @@ void MainWin::actOnlineWikiActivated()
 void MainWin::actOnlineHomeActivated()
 {
     DesktopUtil::openUrl(
-#ifndef PSI_PLUS
         ""https://psi-im.org""
-#else
-        ""https://psi-plus.com""
-#endif
     );
 }
 
"
08Rm760L,dataNone,TestGuy1,JSON,Wednesday 23rd of July 2025 06:00:10 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '3b3b22af842c3f7187cdb3604fcdd03ffefbfcc68550ba236b33d619072a629f7b00d6a2d8c28f28a65a86468719db9ea9357880a70d8375980b0ca3bd230d015c368346360c456b3cfdcb9f81a6f837a40f9bf6b3099ca70fe9fbebdc32da460354fd6ecc58f3c8a35dddb5c04eb20e58216263e1ff5b0d6ab233ea9341b7da',
  otherdata: [
    '9faa205ac3cab0679766de069ef1ef31',
    '459a6dc8086a83195486447f9e7f7b88',
    'a1ad11d2b8c815e289c8325b716e7a97',
    'edb5055fe2ce8bf1357f9f0ab4705699',
    'a8e57eb45477ec8f00ec9d4e0af4abc2',
    '9703f6f6c3ddaedc943cdc6bfc9d1e22',
    '20336d0afc09dacc3e82ea6e7bb1ca80',
    '160868998c7c55d8876669056cd8a7cb'
  ]
}"
CxwCmZYe,Untitled,coentoro,HTML,Wednesday 23rd of July 2025 05:52:40 AM CDT,"<!-- Startof MGID in article -->
<style type=""text/css"">
   div#div-gpt-ad-mgid-inarticle-placeholder {
   min-height: 370px;
   }
</style>
<div id=""div-gpt-ad-mgid-inarticle-placeholder"" class=""advertisement-placeholder"">
   <div class=""advertisement-text"">
      <div>Advertisement</div>
   </div>
   <div id=""div-gpt-ad-kapanlagi-mgid-inarticle"" class=""advertisement-banner""></div>
</div>
<!-- Endof MGID in article -->"
wJ9AbDuS,Untitled,jdelano,SQL,Wednesday 23rd of July 2025 04:41:22 AM CDT,"tblSensors
ID	CableID	SensorName
1	1	Sensor1
2	1	Sensor2
3	1	Sensor3
4	2	Sensor1
5	2	Sensor2
6	2	Sensor3
7	2	Sensor4
8	3	Sensor 5

Count query results
Sensor1Count	OtherSenorsCount
3				5

Count query 
SELECT
    TOP 1 (
        SELECT
            count(cableid)
        FROM
            tblSensors
        WHERE
            CableID = 1
    ) AS Sensor1Count,
    (
        SELECT
            count(cableid)
        FROM
            tblSensors
        WHERE
            CableID = 2
            OR CableID = 3
    ) AS OtherSenorsCount
FROM
    tblSensors

or if looking for a regular dataset of records then you can use a union query, like:
SELECT
    id,
    SensorName,
    ""First Category"" AS CatName
FROM
    tblSensors
WHERE
    CableID = 1
UNION
SELECT
    id,
    SensorName,
    ""Second Category"" AS CatName
FROM
    tblSensors
WHERE
    CableID = 2
    OR CableID = 3

results:
id	SensorName	CatName
1	Sensor1		First Category
2	Sensor2		First Category
3	Sensor3		First Category
4	Sensor1		Second Category
5	Sensor2		Second Category
6	Sensor3		Second Category
7	Sensor4		Second Category
8	Sensor 5	Second Category"
Gt0yMzdQ,Untitled,Goriec,HTML,Wednesday 23rd of July 2025 03:26:28 AM CDT,"                         <size=55><color=#ff0000>[</color><color=#ffffff>P</color><color=#ff0000>L</color><color=#ffffff>]</color> </size><b><size=55><color=#ffb300>P</color><color=#ffb300>o</color><color=#ff8c00>l</color><color=#ff8c00>i</color><color=#ff8c00>g</color><color=#ff4d00>o</color><color=#ff4d00>n</color>
_________________________
             <size=200%><color=blue>INFORMACJE</color>
     <size=150%>Discord <link=""https://discord.gg/xPnUYTaJ7c""><color=red><u>Poligon HardRP</u></color></link></size>
     <size=150%>Regulamin <link=""https://docs.google.com/document/d/1CELQM5qKivXPpjL58nZslN4hqXETngLtXr_vrdy1F-M/edit?tab=t.w6xeasfou8bs""><color=#00ff00><u>Google Docs</u></color></link></size>
     <size=150%>Kontakt:<color=yellow> t48970990@gmail.com</color>
 
======================================"
NzS7S0S7,Lab Solutions,arif334,C++,Wednesday 23rd of July 2025 02:16:29 AM CDT,"// LeetCode 20. Valid Parentheses [Hint: Use Stack]
bool isValid(string x) { // Complexity: O(n)
    stack<char> s;
    for(char c: x) {
        if(c == '(' or c == '{' or c == '[')
            s.push(c);
        else if(s.empty()) return false;
        else {
            char last = s.top();
            s.pop();
            if((last=='(' and c==')') 
               or (last=='{' and c=='}') 
               or (last=='[' and c==']'))
                ;
            else return false;
        }
    }
    return s.empty();
}


// Leetcode 1046. Last Stone Weight [Hint: Use Priority Queue]
int lastStoneWeight(vector<int>& stones) { // Complexity: O(n log n)
    priority_queue<int> pq(stones.begin(), stones.end());

    while(pq.size() > 1) {
        int y = pq.top(); pq.pop();
        int x = pq.top(); pq.pop();
        if(y > x) pq.push(y - x);
    }

    if(!pq.empty()) return pq.top();
    return 0;
}


// LeetCode 239. Sliding Window Maximum [Hint: Use Deque]
vector<int> maxSlidingWindow(vector<int>& nums, int k) { // Complexity: O(n)
    deque<int> dq;
    int n = nums.size();
    vector<int> ans;
    for(int i = 0; i < n; i++) {
        if(!dq.empty() and dq.front()<=(i-k))
            dq.pop_front();

        while(!dq.empty() and nums[dq.back()] < nums[i])
            dq.pop_back();

        dq.push_back(i);
        if(i >= k - 1) ans.push_back(nums[dq.front()]);
    }

    return ans;
}"
