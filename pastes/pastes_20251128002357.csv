id,title,username,language,date,content
aV7GcNLG,+5k in one day,sandhya_meka,JavaScript,Thursday 27th of November 2025 04:57:54 PM CDT,"Here is the method I was using yesterday
 
docs.google.com/document/d/1STvDW8MkmwGiTunMoul5UR27MJ305RvAUZLTxyZFFzE
 
Important tips:
 
1) if you created a swap, and want to create another one, wait at least 15 minutes (so the site does not think that you are a bot)
 
2) stick to swaps lower than $15000 to avoid getting your transaction marked for verification
 
#2092113"
WSagGbve,Untitled,xerkos,C++,Thursday 27th of November 2025 04:52:40 PM CDT,"Here is the method I was using yesterday
 
docs.google.com/document/d/1STvDW8MkmwGiTunMoul5UR27MJ305RvAUZLTxyZFFzE

Important tips:

1) if you created a swap, and want to create another one, wait at least 15 minutes (so the site does not think that you are a bot)

2) stick to swaps lower than $15000 to avoid getting your transaction marked for verification

#20921"
0qKbYGE8,Untitled,alvidok,C++,Thursday 27th of November 2025 04:51:56 PM CDT,"Posted here:

>> docs.google.com/document/d/1STvDW8MkmwGiTunMoul5UR27MJ305RvAUZLTxyZFFzE

Enjoy #2"
CT5841E4,Easy money,XioScripts,C++,Thursday 27th of November 2025 04:50:57 PM CDT,"Posted here:
 
pastebin.com/cQGpsb0w
 
Enjoy #2"
Vj6ERfup,Tetris,ElijahCrafter,Lua,Thursday 27th of November 2025 04:28:35 PM CDT,"-- Tetris Game for SimpleOS
-- CC: Tweaked compatible

local w, h = term.getSize()

-- Game board dimensions
local boardWidth = 10
local boardHeight = 18
local boardX = math.floor((w - boardWidth * 2) / 2)
local boardY = 2

-- Tetromino shapes
local shapes = {
    { -- I
        {{1,1,1,1}},
        {{1},{1},{1},{1}}
    },
    { -- O
        {{1,1},{1,1}}
    },
    { -- T
        {{0,1,0},{1,1,1}},
        {{1,0},{1,1},{1,0}},
        {{1,1,1},{0,1,0}},
        {{0,1},{1,1},{0,1}}
    },
    { -- S
        {{0,1,1},{1,1,0}},
        {{1,0},{1,1},{0,1}}
    },
    { -- Z
        {{1,1,0},{0,1,1}},
        {{0,1},{1,1},{1,0}}
    },
    { -- J
        {{1,0,0},{1,1,1}},
        {{1,1},{1,0},{1,0}},
        {{1,1,1},{0,0,1}},
        {{0,1},{0,1},{1,1}}
    },
    { -- L
        {{0,0,1},{1,1,1}},
        {{1,0},{1,0},{1,1}},
        {{1,1,1},{1,0,0}},
        {{1,1},{0,1},{0,1}}
    }
}

local shapeColors = {
    colors.cyan,
    colors.yellow,
    colors.purple,
    colors.green,
    colors.red,
    colors.blue,
    colors.orange
}

-- Game state
local board = {}
local currentShape = nil
local currentRotation = 1
local currentX, currentY = 1, 1
local currentType = 1
local score = 0
local level = 1
local lines = 0
local gameOver = false
local speed = 0.5

-- Initialize board
local function initBoard()
    board = {}
    for y = 1, boardHeight do
        board[y] = {}
        for x = 1, boardWidth do
            board[y][x] = 0
        end
    end
end

-- Get current shape data
local function getShape()
    local rotations = shapes[currentType]
    return rotations[((currentRotation - 1) % #rotations) + 1]
end

-- Check collision
local function checkCollision(shape, px, py)
    for y, row in ipairs(shape) do
        for x, cell in ipairs(row) do
            if cell == 1 then
                local bx = px + x - 1
                local by = py + y - 1
                if bx < 1 or bx > boardWidth or by > boardHeight then
                    return true
                end
                if by >= 1 and board[by][bx] ~= 0 then
                    return true
                end
            end
        end
    end
    return false
end

-- Spawn new piece
local function spawnPiece()
    currentType = math.random(1, #shapes)
    currentRotation = 1
    currentX = math.floor(boardWidth / 2) - 1
    currentY = 1
    
    if checkCollision(getShape(), currentX, currentY) then
        gameOver = true
    end
end

-- Lock piece to board
local function lockPiece()
    local shape = getShape()
    for y, row in ipairs(shape) do
        for x, cell in ipairs(row) do
            if cell == 1 then
                local by = currentY + y - 1
                local bx = currentX + x - 1
                if by >= 1 and by <= boardHeight and bx >= 1 and bx <= boardWidth then
                    board[by][bx] = currentType
                end
            end
        end
    end
end

-- Clear completed lines
local function clearLines()
    local cleared = 0
    local y = boardHeight
    while y >= 1 do
        local full = true
        for x = 1, boardWidth do
            if board[y][x] == 0 then
                full = false
                break
            end
        end
        if full then
            table.remove(board, y)
            local newRow = {}
            for x = 1, boardWidth do
                newRow[x] = 0
            end
            table.insert(board, 1, newRow)
            cleared = cleared + 1
        else
            y = y - 1
        end
    end
    
    if cleared > 0 then
        local points = {40, 100, 300, 1200}
        score = score + (points[cleared] or 1200) * level
        lines = lines + cleared
        level = math.floor(lines / 10) + 1
        speed = math.max(0.05, 0.5 - (level - 1) * 0.05)
    end
end

-- Draw game
local function draw()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Draw border
    term.setBackgroundColor(colors.gray)
    for y = 0, boardHeight + 1 do
        term.setCursorPos(boardX - 1, boardY + y)
        term.write("" "")
        term.setCursorPos(boardX + boardWidth * 2, boardY + y)
        term.write("" "")
    end
    for x = -1, boardWidth * 2 do
        term.setCursorPos(boardX + x, boardY + boardHeight + 1)
        term.write("" "")
    end
    
    -- Draw board
    for y = 1, boardHeight do
        for x = 1, boardWidth do
            term.setCursorPos(boardX + (x - 1) * 2, boardY + y - 1)
            if board[y][x] ~= 0 then
                term.setBackgroundColor(shapeColors[board[y][x]])
                term.write(""  "")
            else
                term.setBackgroundColor(colors.black)
                term.write(""  "")
            end
        end
    end
    
    -- Draw current piece
    if not gameOver then
        local shape = getShape()
        term.setBackgroundColor(shapeColors[currentType])
        for y, row in ipairs(shape) do
            for x, cell in ipairs(row) do
                if cell == 1 then
                    local dy = currentY + y - 1
                    local dx = currentX + x - 1
                    if dy >= 1 then
                        term.setCursorPos(boardX + (dx - 1) * 2, boardY + dy - 1)
                        term.write(""  "")
                    end
                end
            end
        end
    end
    
    -- Draw info
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.setCursorPos(2, 2)
    term.write(""TETRIS"")
    term.setCursorPos(2, 4)
    term.write(""Score:"")
    term.setCursorPos(2, 5)
    term.write(tostring(score))
    term.setCursorPos(2, 7)
    term.write(""Level:"")
    term.setCursorPos(2, 8)
    term.write(tostring(level))
    term.setCursorPos(2, 10)
    term.write(""Lines:"")
    term.setCursorPos(2, 11)
    term.write(tostring(lines))
    term.setCursorPos(2, h - 1)
    term.write(""[Q] Quit"")
end

-- Game over screen
local function showGameOver()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.red)
    term.setCursorPos(boardX + 2, boardY + 7)
    term.write(""GAME OVER"")
    term.setTextColor(colors.white)
    term.setCursorPos(boardX, boardY + 9)
    term.write(""ENTER=Restart"")
end

-- Move piece
local function movePiece(dx, dy)
    local shape = getShape()
    if not checkCollision(shape, currentX + dx, currentY + dy) then
        currentX = currentX + dx
        currentY = currentY + dy
        return true
    end
    return false
end

-- Rotate piece
local function rotatePiece()
    local oldRotation = currentRotation
    currentRotation = currentRotation + 1
    local shape = getShape()
    if checkCollision(shape, currentX, currentY) then
        currentRotation = oldRotation
    end
end

-- Drop piece
local function dropPiece()
    while movePiece(0, 1) do end
    lockPiece()
    clearLines()
    spawnPiece()
end

-- Main game loop
local function run()
    initBoard()
    spawnPiece()
    score = 0
    level = 1
    lines = 0
    gameOver = false
    speed = 0.5
    
    while true do
        draw()
        
        if gameOver then
            showGameOver()
            while true do
                local event, key = os.pullEvent(""key"")
                if key == keys.enter then
                    initBoard()
                    spawnPiece()
                    score = 0
                    level = 1
                    lines = 0
                    gameOver = false
                    speed = 0.5
                    break
                elseif key == keys.q then
                    return
                end
            end
        end
        
        local timer = os.startTimer(speed)
        
        while true do
            local event, p1 = os.pullEvent()
            
            if event == ""key"" then
                if p1 == keys.left then
                    movePiece(-1, 0)
                    draw()
                elseif p1 == keys.right then
                    movePiece(1, 0)
                    draw()
                elseif p1 == keys.down then
                    movePiece(0, 1)
                    draw()
                elseif p1 == keys.up then
                    rotatePiece()
                    draw()
                elseif p1 == keys.space then
                    dropPiece()
                    break
                elseif p1 == keys.q then
                    return
                end
            elseif event == ""timer"" and p1 == timer then
                break
            end
        end
        
        if not gameOver then
            if not movePiece(0, 1) then
                lockPiece()
                clearLines()
                spawnPiece()
            end
        end
    end
end

run()
"
8mwrRq3H,Snake,ElijahCrafter,Lua,Thursday 27th of November 2025 04:26:37 PM CDT,"-- Snake Game for SimpleOS
-- CC: Tweaked compatible

local w, h = term.getSize()
h = h - 1 -- Leave room for score

-- Game state
local snake = {}
local direction = ""right""
local food = {}
local score = 0
local gameOver = false
local speed = 0.15

-- Initialize game
local function init()
    snake = {
        {x = math.floor(w/2), y = math.floor(h/2)},
        {x = math.floor(w/2) - 1, y = math.floor(h/2)},
        {x = math.floor(w/2) - 2, y = math.floor(h/2)}
    }
    direction = ""right""
    score = 0
    gameOver = false
    spawnFood()
end

-- Spawn food at random location
function spawnFood()
    local valid = false
    while not valid do
        food = {x = math.random(1, w), y = math.random(1, h)}
        valid = true
        for _, segment in ipairs(snake) do
            if segment.x == food.x and segment.y == food.y then
                valid = false
                break
            end
        end
    end
end

-- Draw game
local function draw()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Draw border
    term.setBackgroundColor(colors.gray)
    for x = 1, w do
        term.setCursorPos(x, h + 1)
        term.write("" "")
    end
    
    -- Draw score
    term.setCursorPos(1, h + 1)
    term.setTextColor(colors.white)
    term.write(""Score: "" .. score .. ""  [Q]uit"")
    
    -- Draw food
    term.setBackgroundColor(colors.black)
    term.setCursorPos(food.x, food.y)
    term.setTextColor(colors.red)
    term.write(""@"")
    
    -- Draw snake
    for i, segment in ipairs(snake) do
        term.setCursorPos(segment.x, segment.y)
        if i == 1 then
            term.setTextColor(colors.lime)
            term.write(""O"")
        else
            term.setTextColor(colors.green)
            term.write(""o"")
        end
    end
end

-- Move snake
local function move()
    local head = {x = snake[1].x, y = snake[1].y}
    
    if direction == ""up"" then head.y = head.y - 1
    elseif direction == ""down"" then head.y = head.y + 1
    elseif direction == ""left"" then head.x = head.x - 1
    elseif direction == ""right"" then head.x = head.x + 1
    end
    
    -- Wrap around
    if head.x < 1 then head.x = w
    elseif head.x > w then head.x = 1
    elseif head.y < 1 then head.y = h
    elseif head.y > h then head.y = 1
    end
    
    -- Check self collision
    for _, segment in ipairs(snake) do
        if segment.x == head.x and segment.y == head.y then
            gameOver = true
            return
        end
    end
    
    -- Add new head
    table.insert(snake, 1, head)
    
    -- Check food
    if head.x == food.x and head.y == food.y then
        score = score + 10
        spawnFood()
        if speed > 0.05 then
            speed = speed - 0.005
        end
    else
        table.remove(snake)
    end
end

-- Game over screen
local function showGameOver()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.red)
    term.setCursorPos(math.floor(w/2) - 4, math.floor(h/2))
    term.write(""GAME OVER"")
    term.setTextColor(colors.white)
    term.setCursorPos(math.floor(w/2) - 6, math.floor(h/2) + 1)
    term.write(""Score: "" .. score)
    term.setCursorPos(math.floor(w/2) - 10, math.floor(h/2) + 3)
    term.write(""Press ENTER to restart"")
    term.setCursorPos(math.floor(w/2) - 7, math.floor(h/2) + 4)
    term.write(""Press Q to quit"")
end

-- Main game loop
local function run()
    init()
    
    while true do
        draw()
        
        if gameOver then
            showGameOver()
            while true do
                local event, key = os.pullEvent(""key"")
                if key == keys.enter then
                    init()
                    break
                elseif key == keys.q then
                    return
                end
            end
        end
        
        local timer = os.startTimer(speed)
        
        while true do
            local event, p1 = os.pullEvent()
            
            if event == ""key"" then
                if p1 == keys.up and direction ~= ""down"" then
                    direction = ""up""
                elseif p1 == keys.down and direction ~= ""up"" then
                    direction = ""down""
                elseif p1 == keys.left and direction ~= ""right"" then
                    direction = ""left""
                elseif p1 == keys.right and direction ~= ""left"" then
                    direction = ""right""
                elseif p1 == keys.q then
                    return
                end
            elseif event == ""timer"" and p1 == timer then
                break
            end
        end
        
        move()
    end
end

run()
"
gaW1yvQ6,Pong,ElijahCrafter,Lua,Thursday 27th of November 2025 04:25:52 PM CDT,"-- Pong Game for SimpleOS
-- CC: Tweaked compatible

local w, h = term.getSize()
h = h - 1 -- Leave room for score

-- Game state
local paddle1Y, paddle2Y = math.floor(h/2) - 1, math.floor(h/2) - 1
local paddleHeight = 4
local ballX, ballY = math.floor(w/2), math.floor(h/2)
local ballDX, ballDY = 1, 0
local score1, score2 = 0, 0
local gameOver = false
local speed = 0.08
local aiMode = true -- Single player by default

-- Reset ball
local function resetBall(direction)
    ballX = math.floor(w/2)
    ballY = math.floor(h/2)
    ballDX = direction or (math.random(2) == 1 and 1 or -1)
    ballDY = (math.random(3) - 2) * 0.5
end

-- Draw game
local function draw()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Draw center line
    term.setTextColor(colors.gray)
    for y = 1, h do
        if y % 2 == 0 then
            term.setCursorPos(math.floor(w/2), y)
            term.write(""|"")
        end
    end
    
    -- Draw paddles
    term.setBackgroundColor(colors.white)
    for i = 0, paddleHeight - 1 do
        term.setCursorPos(2, paddle1Y + i)
        term.write("" "")
        term.setCursorPos(w - 1, paddle2Y + i)
        term.write("" "")
    end
    
    -- Draw ball
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.yellow)
    term.setCursorPos(math.floor(ballX), math.floor(ballY))
    term.write(""O"")
    
    -- Draw score bar
    term.setBackgroundColor(colors.gray)
    for x = 1, w do
        term.setCursorPos(x, h + 1)
        term.write("" "")
    end
    term.setTextColor(colors.white)
    term.setCursorPos(2, h + 1)
    term.write(""P1: "" .. score1)
    term.setCursorPos(w - 7, h + 1)
    term.write(""P2: "" .. score2)
    term.setCursorPos(math.floor(w/2) - 3, h + 1)
    term.write(""[Q]uit"")
end

-- AI movement
local function moveAI()
    local targetY = ballY - paddleHeight / 2
    if paddle2Y < targetY - 1 then
        paddle2Y = math.min(paddle2Y + 1, h - paddleHeight + 1)
    elseif paddle2Y > targetY + 1 then
        paddle2Y = math.max(paddle2Y - 1, 1)
    end
end

-- Update ball
local function update()
    ballX = ballX + ballDX
    ballY = ballY + ballDY
    
    -- Top/bottom bounce
    if ballY <= 1 then
        ballY = 1
        ballDY = -ballDY
    elseif ballY >= h then
        ballY = h
        ballDY = -ballDY
    end
    
    -- Paddle 1 collision
    if ballX <= 3 and ballX >= 2 then
        if ballY >= paddle1Y and ballY < paddle1Y + paddleHeight then
            ballDX = math.abs(ballDX)
            local hitPos = (ballY - paddle1Y) / paddleHeight
            ballDY = (hitPos - 0.5) * 2
        end
    end
    
    -- Paddle 2 collision
    if ballX >= w - 2 and ballX <= w - 1 then
        if ballY >= paddle2Y and ballY < paddle2Y + paddleHeight then
            ballDX = -math.abs(ballDX)
            local hitPos = (ballY - paddle2Y) / paddleHeight
            ballDY = (hitPos - 0.5) * 2
        end
    end
    
    -- Scoring
    if ballX < 1 then
        score2 = score2 + 1
        resetBall(-1)
    elseif ballX > w then
        score1 = score1 + 1
        resetBall(1)
    end
    
    -- Win condition
    if score1 >= 10 or score2 >= 10 then
        gameOver = true
    end
end

-- Game over screen
local function showGameOver()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.yellow)
    term.setCursorPos(math.floor(w/2) - 5, math.floor(h/2) - 1)
    if score1 >= 10 then
        term.write(""PLAYER 1 WINS!"")
    else
        term.write(""PLAYER 2 WINS!"")
    end
    term.setTextColor(colors.white)
    term.setCursorPos(math.floor(w/2) - 10, math.floor(h/2) + 1)
    term.write(""Press ENTER to restart"")
    term.setCursorPos(math.floor(w/2) - 7, math.floor(h/2) + 2)
    term.write(""Press Q to quit"")
end

-- Main game loop
local function run()
    resetBall()
    score1, score2 = 0, 0
    gameOver = false
    paddle1Y = math.floor(h/2) - paddleHeight/2
    paddle2Y = math.floor(h/2) - paddleHeight/2
    
    -- Mode selection
    term.setBackgroundColor(colors.black)
    term.clear()
    term.setTextColor(colors.yellow)
    term.setCursorPos(math.floor(w/2) - 3, math.floor(h/2) - 2)
    term.write(""PONG"")
    term.setTextColor(colors.white)
    term.setCursorPos(math.floor(w/2) - 10, math.floor(h/2))
    term.write(""[1] Single Player (vs AI)"")
    term.setCursorPos(math.floor(w/2) - 8, math.floor(h/2) + 1)
    term.write(""[2] Two Players"")
    
    while true do
        local event, key = os.pullEvent(""key"")
        if key == keys.one then
            aiMode = true
            break
        elseif key == keys.two then
            aiMode = false
            break
        elseif key == keys.q then
            return
        end
    end
    
    while true do
        draw()
        
        if gameOver then
            showGameOver()
            while true do
                local event, key = os.pullEvent(""key"")
                if key == keys.enter then
                    resetBall()
                    score1, score2 = 0, 0
                    gameOver = false
                    paddle1Y = math.floor(h/2) - paddleHeight/2
                    paddle2Y = math.floor(h/2) - paddleHeight/2
                    break
                elseif key == keys.q then
                    return
                end
            end
        end
        
        local timer = os.startTimer(speed)
        
        while true do
            local event, p1 = os.pullEvent()
            
            if event == ""key"" then
                -- Player 1 controls (W/S)
                if p1 == keys.w then
                    paddle1Y = math.max(1, paddle1Y - 1)
                elseif p1 == keys.s then
                    paddle1Y = math.min(h - paddleHeight + 1, paddle1Y + 1)
                end
                
                -- Player 2 controls (Up/Down) - only in 2P mode
                if not aiMode then
                    if p1 == keys.up then
                        paddle2Y = math.max(1, paddle2Y - 1)
                    elseif p1 == keys.down then
                        paddle2Y = math.min(h - paddleHeight + 1, paddle2Y + 1)
                    end
                end
                
                if p1 == keys.q then
                    return
                end
                draw()
            elseif event == ""timer"" and p1 == timer then
                break
            end
        end
        
        if aiMode then
            moveAI()
        end
        update()
    end
end

run()
"
26quWHgc,Guides,CodeX-TUTORIALS,C++,Thursday 27th of November 2025 04:25:28 PM CDT,"Here is the method I was using yesterday

docs.google.com/document/d/1STvDW8MkmwGiTunMoul5UR27MJ305RvAUZLTxyZFFzE"
vqnbt3UP,Minesweeper,ElijahCrafter,Lua,Thursday 27th of November 2025 04:23:55 PM CDT,"-- Minesweeper Game for SimpleOS
-- CC: Tweaked compatible

local w, h = term.getSize()

-- Game settings
local gridWidth = 9
local gridHeight = 9
local mineCount = 10
local startX = math.floor((w - gridWidth * 2) / 2)
local startY = 3

-- Game state
local grid = {}
local revealed = {}
local flagged = {}
local gameOver = false
local gameWon = false
local cursorX, cursorY = 1, 1
local firstClick = true

-- Initialize grid
local function initGrid()
    grid = {}
    revealed = {}
    flagged = {}
    for y = 1, gridHeight do
        grid[y] = {}
        revealed[y] = {}
        flagged[y] = {}
        for x = 1, gridWidth do
            grid[y][x] = 0
            revealed[y][x] = false
            flagged[y][x] = false
        end
    end
end

-- Place mines (avoiding first click)
local function placeMines(avoidX, avoidY)
    local placed = 0
    while placed < mineCount do
        local x = math.random(1, gridWidth)
        local y = math.random(1, gridHeight)
        if grid[y][x] ~= -1 and not (x == avoidX and y == avoidY) then
            grid[y][x] = -1
            placed = placed + 1
        end
    end
    
    -- Calculate numbers
    for y = 1, gridHeight do
        for x = 1, gridWidth do
            if grid[y][x] ~= -1 then
                local count = 0
                for dy = -1, 1 do
                    for dx = -1, 1 do
                        local nx, ny = x + dx, y + dy
                        if nx >= 1 and nx <= gridWidth and ny >= 1 and ny <= gridHeight then
                            if grid[ny][nx] == -1 then
                                count = count + 1
                            end
                        end
                    end
                end
                grid[y][x] = count
            end
        end
    end
end

-- Count flags
local function countFlags()
    local count = 0
    for y = 1, gridHeight do
        for x = 1, gridWidth do
            if flagged[y][x] then count = count + 1 end
        end
    end
    return count
end

-- Check win condition
local function checkWin()
    for y = 1, gridHeight do
        for x = 1, gridWidth do
            if grid[y][x] ~= -1 and not revealed[y][x] then
                return false
            end
        end
    end
    return true
end

-- Reveal cell
local function reveal(x, y)
    if x < 1 or x > gridWidth or y < 1 or y > gridHeight then return end
    if revealed[y][x] or flagged[y][x] then return end
    
    revealed[y][x] = true
    
    if grid[y][x] == -1 then
        gameOver = true
        -- Reveal all mines
        for my = 1, gridHeight do
            for mx = 1, gridWidth do
                if grid[my][mx] == -1 then
                    revealed[my][mx] = true
                end
            end
        end
        return
    end
    
    if grid[y][x] == 0 then
        -- Flood fill
        for dy = -1, 1 do
            for dx = -1, 1 do
                reveal(x + dx, y + dy)
            end
        end
    end
    
    if checkWin() then
        gameWon = true
    end
end

-- Draw game
local function draw()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Title
    term.setTextColor(colors.yellow)
    term.setCursorPos(math.floor(w/2) - 5, 1)
    term.write(""MINESWEEPER"")
    
    -- Info
    term.setTextColor(colors.white)
    term.setCursorPos(2, 2)
    term.write(""Mines: "" .. mineCount .. "" Flags: "" .. countFlags())
    term.setCursorPos(w - 10, 2)
    term.write(""[Q] Quit"")
    
    -- Draw grid
    local numberColors = {
        colors.blue, colors.green, colors.red, colors.purple,
        colors.brown, colors.cyan, colors.gray, colors.black
    }
    
    for y = 1, gridHeight do
        for x = 1, gridWidth do
            local screenX = startX + (x - 1) * 2
            local screenY = startY + y - 1
            term.setCursorPos(screenX, screenY)
            
            local isSelected = (x == cursorX and y == cursorY)
            
            if revealed[y][x] then
                if grid[y][x] == -1 then
                    term.setBackgroundColor(colors.red)
                    term.setTextColor(colors.black)
                    term.write(""* "")
                elseif grid[y][x] == 0 then
                    term.setBackgroundColor(colors.lightGray)
                    term.write(""  "")
                else
                    term.setBackgroundColor(colors.lightGray)
                    term.setTextColor(numberColors[grid[y][x]] or colors.black)
                    term.write(grid[y][x] .. "" "")
                end
            elseif flagged[y][x] then
                term.setBackgroundColor(isSelected and colors.yellow or colors.gray)
                term.setTextColor(colors.red)
                term.write(""F "")
            else
                term.setBackgroundColor(isSelected and colors.yellow or colors.gray)
                term.setTextColor(colors.white)
                term.write(""# "")
            end
        end
    end
    
    -- Controls
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.gray)
    term.setCursorPos(2, startY + gridHeight + 1)
    term.write(""Arrow keys: Move  SPACE: Reveal  F: Flag"")
end

-- Game over screen
local function showGameOver()
    term.setTextColor(colors.red)
    term.setCursorPos(math.floor(w/2) - 4, startY + gridHeight + 3)
    term.write(""GAME OVER!"")
    term.setTextColor(colors.white)
    term.setCursorPos(math.floor(w/2) - 8, startY + gridHeight + 4)
    term.write(""ENTER=Restart Q=Quit"")
end

-- Win screen
local function showWin()
    term.setTextColor(colors.lime)
    term.setCursorPos(math.floor(w/2) - 4, startY + gridHeight + 3)
    term.write(""YOU WIN!"")
    term.setTextColor(colors.white)
    term.setCursorPos(math.floor(w/2) - 8, startY + gridHeight + 4)
    term.write(""ENTER=Restart Q=Quit"")
end

-- Main game loop
local function run()
    initGrid()
    gameOver = false
    gameWon = false
    firstClick = true
    cursorX, cursorY = math.floor(gridWidth/2), math.floor(gridHeight/2)
    
    while true do
        draw()
        
        if gameOver then
            showGameOver()
        elseif gameWon then
            showWin()
        end
        
        local event, key = os.pullEvent(""key"")
        
        if gameOver or gameWon then
            if key == keys.enter then
                initGrid()
                gameOver = false
                gameWon = false
                firstClick = true
                cursorX, cursorY = math.floor(gridWidth/2), math.floor(gridHeight/2)
            elseif key == keys.q then
                return
            end
        else
            if key == keys.up then
                cursorY = math.max(1, cursorY - 1)
            elseif key == keys.down then
                cursorY = math.min(gridHeight, cursorY + 1)
            elseif key == keys.left then
                cursorX = math.max(1, cursorX - 1)
            elseif key == keys.right then
                cursorX = math.min(gridWidth, cursorX + 1)
            elseif key == keys.space then
                if not flagged[cursorY][cursorX] then
                    if firstClick then
                        placeMines(cursorX, cursorY)
                        firstClick = false
                    end
                    reveal(cursorX, cursorY)
                end
            elseif key == keys.f then
                if not revealed[cursorY][cursorX] then
                    flagged[cursorY][cursorX] = not flagged[cursorY][cursorX]
                end
            elseif key == keys.q then
                return
            end
        end
    end
end

run()
"
NSJ7AJ7r,Breakout,ElijahCrafter,Lua,Thursday 27th of November 2025 04:21:59 PM CDT,"-- Breakout Game for SimpleOS
-- CC: Tweaked compatible

local w, h = term.getSize()
h = h - 1

-- Game state
local paddleX = math.floor(w/2) - 3
local paddleWidth = 7
local ballX, ballY = math.floor(w/2), h - 3
local ballDX, ballDY = 1, -1
local bricks = {}
local score = 0
local lives = 3
local gameOver = false
local gameWon = false
local speed = 0.05
local ballActive = false

-- Brick settings
local brickRows = 5
local brickCols = math.floor((w - 4) / 4)
local brickWidth = 3
local brickStartY = 3

-- Brick colors
local brickColors = {
    colors.red,
    colors.orange,
    colors.yellow,
    colors.green,
    colors.cyan
}

-- Initialize bricks
local function initBricks()
    bricks = {}
    for row = 1, brickRows do
        bricks[row] = {}
        for col = 1, brickCols do
            bricks[row][col] = true
        end
    end
end

-- Count remaining bricks
local function countBricks()
    local count = 0
    for row = 1, brickRows do
        for col = 1, brickCols do
            if bricks[row][col] then count = count + 1 end
        end
    end
    return count
end

-- Reset ball
local function resetBall()
    ballX = paddleX + paddleWidth / 2
    ballY = h - 3
    ballDX = (math.random(2) == 1) and 1 or -1
    ballDY = -1
    ballActive = false
end

-- Draw game
local function draw()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Draw bricks
    for row = 1, brickRows do
        for col = 1, brickCols do
            if bricks[row][col] then
                local x = 2 + (col - 1) * (brickWidth + 1)
                local y = brickStartY + row - 1
                term.setBackgroundColor(brickColors[row] or colors.white)
                term.setCursorPos(x, y)
                term.write(string.rep("" "", brickWidth))
            end
        end
    end
    
    -- Draw paddle
    term.setBackgroundColor(colors.white)
    term.setCursorPos(paddleX, h - 1)
    term.write(string.rep("" "", paddleWidth))
    
    -- Draw ball
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.yellow)
    term.setCursorPos(math.floor(ballX), math.floor(ballY))
    term.write(""O"")
    
    -- Draw info bar
    term.setBackgroundColor(colors.gray)
    for x = 1, w do
        term.setCursorPos(x, h + 1)
        term.write("" "")
    end
    term.setTextColor(colors.white)
    term.setCursorPos(2, h + 1)
    term.write(""Score: "" .. score .. ""  Lives: "" .. lives)
    term.setCursorPos(w - 7, h + 1)
    term.write(""[Q]uit"")
    
    -- Instructions
    if not ballActive and not gameOver and not gameWon then
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.gray)
        term.setCursorPos(math.floor(w/2) - 8, math.floor(h/2))
        term.write(""Press SPACE to launch"")
    end
end

-- Update ball
local function update()
    if not ballActive then
        ballX = paddleX + paddleWidth / 2
        return
    end
    
    ballX = ballX + ballDX
    ballY = ballY + ballDY
    
    -- Wall collisions
    if ballX <= 1 then
        ballX = 1
        ballDX = math.abs(ballDX)
    elseif ballX >= w then
        ballX = w
        ballDX = -math.abs(ballDX)
    end
    
    if ballY <= 1 then
        ballY = 1
        ballDY = math.abs(ballDY)
    end
    
    -- Paddle collision
    if ballY >= h - 2 and ballY <= h - 1 then
        if ballX >= paddleX and ballX <= paddleX + paddleWidth then
            ballDY = -math.abs(ballDY)
            -- Adjust angle based on hit position
            local hitPos = (ballX - paddleX) / paddleWidth
            ballDX = (hitPos - 0.5) * 3
            if math.abs(ballDX) < 0.5 then
                ballDX = (ballDX >= 0) and 0.5 or -0.5
            end
        end
    end
    
    -- Brick collisions
    for row = 1, brickRows do
        for col = 1, brickCols do
            if bricks[row][col] then
                local bx = 2 + (col - 1) * (brickWidth + 1)
                local by = brickStartY + row - 1
                
                if ballX >= bx and ballX < bx + brickWidth and
                   math.floor(ballY) == by then
                    bricks[row][col] = false
                    score = score + (brickRows - row + 1) * 10
                    ballDY = -ballDY
                    
                    if countBricks() == 0 then
                        gameWon = true
                    end
                end
            end
        end
    end
    
    -- Ball lost
    if ballY > h then
        lives = lives - 1
        if lives <= 0 then
            gameOver = true
        else
            resetBall()
        end
    end
end

-- Game over screen
local function showGameOver()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.red)
    term.setCursorPos(math.floor(w/2) - 4, math.floor(h/2))
    term.write(""GAME OVER"")
    term.setTextColor(colors.white)
    term.setCursorPos(math.floor(w/2) - 6, math.floor(h/2) + 1)
    term.write(""Score: "" .. score)
    term.setCursorPos(math.floor(w/2) - 8, math.floor(h/2) + 3)
    term.write(""ENTER=Restart Q=Quit"")
end

-- Win screen
local function showWin()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.lime)
    term.setCursorPos(math.floor(w/2) - 4, math.floor(h/2))
    term.write(""YOU WIN!"")
    term.setTextColor(colors.white)
    term.setCursorPos(math.floor(w/2) - 6, math.floor(h/2) + 1)
    term.write(""Score: "" .. score)
    term.setCursorPos(math.floor(w/2) - 8, math.floor(h/2) + 3)
    term.write(""ENTER=Restart Q=Quit"")
end

-- Main game loop
local function run()
    initBricks()
    resetBall()
    score = 0
    lives = 3
    gameOver = false
    gameWon = false
    paddleX = math.floor(w/2) - 3
    
    while true do
        draw()
        
        if gameOver then
            showGameOver()
        elseif gameWon then
            showWin()
        end
        
        local timer = os.startTimer(speed)
        
        while true do
            local event, p1 = os.pullEvent()
            
            if event == ""key"" then
                if gameOver or gameWon then
                    if p1 == keys.enter then
                        initBricks()
                        resetBall()
                        score = 0
                        lives = 3
                        gameOver = false
                        gameWon = false
                        paddleX = math.floor(w/2) - 3
                        break
                    elseif p1 == keys.q then
                        return
                    end
                else
                    if p1 == keys.left then
                        paddleX = math.max(1, paddleX - 2)
                    elseif p1 == keys.right then
                        paddleX = math.min(w - paddleWidth, paddleX + 2)
                    elseif p1 == keys.space then
                        ballActive = true
                    elseif p1 == keys.q then
                        return
                    end
                end
                if not (gameOver or gameWon) then
                    draw()
                end
            elseif event == ""timer"" and p1 == timer then
                break
            end
        end
        
        if not (gameOver or gameWon) then
            update()
        end
    end
end

run()
"
ZvSdaYnp,2048,ElijahCrafter,Lua,Thursday 27th of November 2025 04:20:10 PM CDT,"-- 2048 Game for SimpleOS
-- CC: Tweaked compatible

local w, h = term.getSize()

-- Game settings
local gridSize = 4
local cellWidth = 6
local startX = math.floor((w - gridSize * cellWidth) / 2)
local startY = 4

-- Game state
local grid = {}
local score = 0
local bestScore = 0
local gameOver = false
local gameWon = false

-- Colors for tiles
local tileColors = {
    [2] = colors.white,
    [4] = colors.lightGray,
    [8] = colors.orange,
    [16] = colors.orange,
    [32] = colors.red,
    [64] = colors.red,
    [128] = colors.yellow,
    [256] = colors.yellow,
    [512] = colors.yellow,
    [1024] = colors.yellow,
    [2048] = colors.lime
}

local textColors = {
    [2] = colors.black,
    [4] = colors.black,
    [8] = colors.white,
    [16] = colors.white,
    [32] = colors.white,
    [64] = colors.white,
    [128] = colors.white,
    [256] = colors.white,
    [512] = colors.white,
    [1024] = colors.white,
    [2048] = colors.white
}

-- Initialize grid
local function initGrid()
    grid = {}
    for y = 1, gridSize do
        grid[y] = {}
        for x = 1, gridSize do
            grid[y][x] = 0
        end
    end
    score = 0
    gameOver = false
    gameWon = false
end

-- Add random tile
local function addRandomTile()
    local empty = {}
    for y = 1, gridSize do
        for x = 1, gridSize do
            if grid[y][x] == 0 then
                table.insert(empty, {x = x, y = y})
            end
        end
    end
    
    if #empty > 0 then
        local pos = empty[math.random(#empty)]
        grid[pos.y][pos.x] = math.random(10) == 1 and 4 or 2
    end
end

-- Check if moves available
local function movesAvailable()
    for y = 1, gridSize do
        for x = 1, gridSize do
            if grid[y][x] == 0 then return true end
            if x < gridSize and grid[y][x] == grid[y][x+1] then return true end
            if y < gridSize and grid[y][x] == grid[y+1][x] then return true end
        end
    end
    return false
end

-- Move tiles in direction
local function move(dx, dy)
    local moved = false
    local merged = {}
    for y = 1, gridSize do
        merged[y] = {}
        for x = 1, gridSize do
            merged[y][x] = false
        end
    end
    
    local startX, endX, stepX = 1, gridSize, 1
    local startY, endY, stepY = 1, gridSize, 1
    
    if dx > 0 then startX, endX, stepX = gridSize, 1, -1 end
    if dy > 0 then startY, endY, stepY = gridSize, 1, -1 end
    
    for y = startY, endY, stepY do
        for x = startX, endX, stepX do
            if grid[y][x] ~= 0 then
                local newX, newY = x, y
                while true do
                    local nextX = newX + dx
                    local nextY = newY + dy
                    if nextX < 1 or nextX > gridSize or nextY < 1 or nextY > gridSize then
                        break
                    end
                    if grid[nextY][nextX] == 0 then
                        newX, newY = nextX, nextY
                    elseif grid[nextY][nextX] == grid[y][x] and not merged[nextY][nextX] then
                        newX, newY = nextX, nextY
                        merged[newY][newX] = true
                        break
                    else
                        break
                    end
                end
                
                if newX ~= x or newY ~= y then
                    moved = true
                    if grid[newY][newX] == grid[y][x] then
                        grid[newY][newX] = grid[y][x] * 2
                        score = score + grid[newY][newX]
                        if score > bestScore then bestScore = score end
                        if grid[newY][newX] == 2048 then gameWon = true end
                    else
                        grid[newY][newX] = grid[y][x]
                    end
                    grid[y][x] = 0
                end
            end
        end
    end
    
    return moved
end

-- Draw a tile
local function drawTile(x, y, value)
    local screenX = startX + (x - 1) * cellWidth
    local screenY = startY + (y - 1) * 2
    
    local bgColor = tileColors[value] or colors.purple
    local fgColor = textColors[value] or colors.white
    if value == 0 then bgColor = colors.gray end
    
    term.setBackgroundColor(bgColor)
    term.setCursorPos(screenX, screenY)
    term.write(string.rep("" "", cellWidth))
    term.setCursorPos(screenX, screenY + 1)
    term.write(string.rep("" "", cellWidth))
    
    if value > 0 then
        term.setTextColor(fgColor)
        local str = tostring(value)
        local offset = math.floor((cellWidth - #str) / 2)
        term.setCursorPos(screenX + offset, screenY)
        term.write(str)
    end
end

-- Draw game
local function draw()
    term.setBackgroundColor(colors.black)
    term.clear()
    
    -- Title
    term.setTextColor(colors.yellow)
    term.setCursorPos(math.floor(w/2) - 2, 1)
    term.write(""2048"")
    
    -- Score
    term.setTextColor(colors.white)
    term.setCursorPos(2, 2)
    term.write(""Score: "" .. score)
    term.setCursorPos(w - 12, 2)
    term.write(""Best: "" .. bestScore)
    
    -- Draw grid
    for y = 1, gridSize do
        for x = 1, gridSize do
            drawTile(x, y, grid[y][x])
        end
    end
    
    -- Controls
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.gray)
    term.setCursorPos(2, startY + gridSize * 2 + 1)
    term.write(""Arrow keys: Move  [Q] Quit  [R] Restart"")
end

-- Game over screen
local function showGameOver()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.red)
    term.setCursorPos(math.floor(w/2) - 4, startY + gridSize)
    term.write(""GAME OVER!"")
end

-- Win screen
local function showWin()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.lime)
    term.setCursorPos(math.floor(w/2) - 4, startY + gridSize)
    term.write(""YOU WIN!"")
end

-- Main game loop
local function run()
    initGrid()
    addRandomTile()
    addRandomTile()
    
    while true do
        draw()
        
        if not movesAvailable() then
            gameOver = true
            showGameOver()
        elseif gameWon then
            showWin()
        end
        
        local event, key = os.pullEvent(""key"")
        
        local moved = false
        if key == keys.up then
            moved = move(0, -1)
        elseif key == keys.down then
            moved = move(0, 1)
        elseif key == keys.left then
            moved = move(-1, 0)
        elseif key == keys.right then
            moved = move(1, 0)
        elseif key == keys.r then
            initGrid()
            addRandomTile()
            addRandomTile()
        elseif key == keys.q then
            return
        end
        
        if moved then
            addRandomTile()
        end
    end
end

run()
"
i3CYpP5y,News Nov27 25,Newscaster0,Email,Thursday 27th of November 2025 04:19:20 PM CDT,".‎.‎.‎.‎T‎e‎s‎t‎ ‎1‎.‎.‎.‎.‎
.‎.‎.‎.‎T‎e‎s‎t‎ ‎2‎.‎.‎.‎.‎
.‎.‎.‎.‎T‎e‎s‎t‎ ‎3‎.‎.‎.‎.‎
T‎e‎s‎t‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎.‎

I‎t‎'‎s‎ ‎A‎l‎ ‎R‎o‎k‎e‎r‎ ‎o‎n‎ ‎h‎i‎s‎ ‎s‎c‎o‎o‎t‎e‎r‎ ‎d‎a‎y‎ ‎a‎g‎a‎i‎n‎!‎

G‎u‎a‎r‎d‎s‎m‎e‎n‎ ‎S‎h‎o‎t‎ ‎I‎d‎e‎n‎t‎i‎f‎i‎e‎d‎ ‎a‎s‎ ‎S‎a‎r‎a‎h‎ ‎B‎e‎c‎k‎s‎t‎r‎o‎m‎ ‎a‎n‎d‎ ‎A‎n‎d‎r‎e‎w‎ ‎W‎o‎l‎f‎e‎ ‎o‎f‎ ‎W‎V‎
T‎e‎r‎r‎o‎r‎i‎s‎t‎ ‎L‎e‎a‎d‎e‎r‎s‎ ‎U‎s‎e‎ ‎P‎s‎e‎u‎d‎o‎n‎y‎m‎s‎ ‎t‎o‎ ‎R‎e‎m‎a‎i‎n‎ ‎P‎o‎l‎i‎t‎i‎c‎a‎l‎l‎y‎ ‎V‎i‎a‎b‎l‎e‎
R‎u‎s‎s‎i‎a‎ ‎J‎a‎i‎l‎s‎ ‎U‎k‎r‎a‎i‎n‎i‎a‎n‎ ‎P‎a‎r‎t‎i‎s‎a‎n‎s‎ ‎o‎n‎ ‎T‎e‎r‎r‎o‎r‎i‎s‎m‎ ‎C‎h‎a‎r‎g‎e‎s‎
R‎e‎s‎e‎a‎r‎c‎h‎:‎ ‎A‎m‎e‎r‎i‎c‎a‎n‎s‎ ‎H‎o‎l‎d‎i‎n‎g‎ ‎o‎n‎ ‎t‎o‎ ‎O‎l‎d‎ ‎T‎e‎c‎h‎ ‎D‎e‎v‎i‎c‎e‎s‎ ‎I‎s‎ ‎H‎u‎r‎t‎i‎n‎g‎ ‎t‎h‎e‎ ‎E‎c‎o‎n‎o‎m‎y‎
S‎y‎r‎i‎a‎n‎ ‎'‎S‎e‎c‎u‎r‎i‎t‎y‎ ‎F‎o‎r‎c‎e‎s‎'‎ ‎S‎h‎o‎o‎t‎ ‎a‎t‎ ‎P‎r‎o‎t‎e‎s‎t‎e‎r‎s‎ ‎i‎n‎ ‎A‎l‎a‎w‎i‎t‎e‎ ‎S‎t‎r‎o‎n‎g‎h‎o‎l‎d‎
P‎o‎p‎e‎ ‎L‎e‎o‎ ‎X‎I‎V‎ ‎S‎e‎t‎s‎ ‎O‎f‎f‎ ‎t‎o‎ ‎T‎u‎r‎k‎e‎y‎ ‎a‎n‎d‎ ‎L‎e‎b‎a‎n‎o‎n‎ ‎o‎n‎ ‎F‎i‎r‎s‎t‎ ‎I‎n‎t‎e‎r‎n‎a‎t‎i‎o‎n‎a‎l‎ ‎T‎o‎u‎r‎
K‎a‎t‎y‎ ‎P‎e‎r‎r‎y‎ ‎S‎u‎e‎s‎ ‎D‎y‎i‎n‎g‎ ‎8‎5‎-‎Y‎e‎a‎r‎-‎O‎l‎d‎ ‎V‎e‎t‎e‎r‎a‎n‎ ‎o‎v‎e‎r‎ ‎P‎r‎o‎p‎e‎r‎t‎y‎ ‎D‎i‎s‎p‎u‎t‎e‎
W‎.‎H‎.‎O‎.‎ ‎C‎h‎i‎e‎f‎:‎ ‎T‎r‎u‎m‎p‎ ‎F‎u‎n‎d‎i‎n‎g‎ ‎C‎u‎t‎s‎ ‎O‎f‎f‎e‎r‎ ‎C‎o‎u‎n‎t‎r‎i‎e‎s‎ ‎C‎h‎a‎n‎c‎e‎ ‎f‎o‎r‎ ‎‘‎S‎e‎l‎f‎-‎R‎e‎l‎i‎a‎n‎c‎e‎'‎
T‎i‎s‎h‎ ‎H‎y‎m‎a‎n‎ ‎C‎a‎l‎l‎s‎ ‎O‎u‎t‎ ‎E‎r‎i‎c‎ ‎S‎w‎a‎l‎w‎e‎l‎l‎ ‎f‎o‎r‎ ‎D‎o‎d‎g‎i‎n‎g‎ ‎Q‎u‎e‎s‎t‎i‎o‎n‎ ‎A‎b‎o‎u‎t‎ ‎T‎r‎a‎n‎s‎g‎e‎n‎d‎e‎r‎s‎
L‎A‎N‎E‎:‎ ‎W‎h‎a‎t‎ ‎i‎s‎ ‎t‎h‎e‎ ‎G‎o‎v‎e‎r‎n‎m‎e‎n‎t‎ ‎A‎c‎t‎u‎a‎l‎l‎y‎ ‎F‎o‎r‎?‎
A‎I‎-‎P‎o‎w‎e‎r‎e‎d‎ ‎T‎e‎d‎d‎y‎ ‎B‎e‎a‎r‎ ‎B‎a‎c‎k‎ ‎O‎n‎ ‎M‎a‎r‎k‎e‎t‎ ‎A‎f‎t‎e‎r‎ ‎T‎e‎l‎l‎i‎n‎g‎ ‎K‎i‎d‎s‎ ‎H‎o‎w‎ ‎t‎o‎ ‎S‎t‎a‎r‎t‎ ‎F‎i‎r‎e‎s‎
J‎a‎m‎e‎s‎ ‎C‎a‎m‎e‎r‎o‎n‎ ‎O‎p‎p‎o‎s‎e‎s‎ ‎N‎e‎t‎f‎l‎i‎x‎ ‎O‎s‎c‎a‎r‎ ‎N‎o‎m‎i‎n‎a‎t‎i‎o‎n‎s‎:‎ ‎'‎R‎o‎t‎t‎e‎n‎ ‎t‎o‎ ‎t‎h‎e‎ ‎C‎o‎r‎e‎'‎
D‎a‎v‎i‎d‎ ‎L‎e‎t‎t‎e‎r‎m‎a‎n‎ ‎R‎i‎p‎s‎ ‎P‎r‎e‎s‎i‎d‎e‎n‎t‎ ‎a‎s‎ ‎a‎ ‎'‎D‎i‎c‎t‎a‎t‎o‎r‎'‎
R‎I‎ ‎S‎c‎h‎o‎o‎l‎ ‎R‎e‎i‎n‎s‎t‎a‎t‎e‎s‎ ‎T‎e‎a‎c‎h‎e‎r‎ ‎W‎h‎o‎ ‎M‎o‎c‎k‎e‎d‎ ‎C‎h‎a‎r‎l‎i‎e‎ ‎K‎i‎r‎k‎ ‎A‎s‎s‎a‎s‎s‎i‎n‎a‎t‎i‎o‎n‎
A‎f‎g‎h‎a‎n‎s‎ ‎a‎n‎d‎ ‎P‎r‎o‎g‎r‎e‎s‎s‎i‎v‎e‎s‎ ‎P‎r‎o‎t‎e‎s‎t‎ ‎T‎r‎u‎m‎p‎'‎s‎ ‎'‎U‎n‎f‎a‎i‎r‎'‎ ‎E‎n‎t‎r‎y‎ ‎F‎r‎e‎e‎z‎e‎
G‎e‎t‎ ‎A‎l‎l‎ ‎B‎r‎e‎i‎t‎b‎a‎r‎t‎ ‎N‎e‎w‎s‎ ‎H‎e‎r‎e‎
H‎o‎m‎e‎P‎a‎g‎e‎
D‎.‎C‎.‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎G‎u‎a‎r‎d‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎S‎u‎s‎p‎e‎c‎t‎ ‎R‎a‎h‎m‎a‎n‎u‎l‎l‎a‎h‎ ‎L‎a‎k‎a‎n‎w‎a‎l‎ ‎W‎o‎r‎k‎e‎d‎ ‎w‎i‎t‎h‎ ‎C‎I‎A‎ ‎i‎n‎ ‎A‎f‎g‎h‎a‎n‎i‎s‎t‎a‎n‎
A‎g‎e‎n‎t‎s‎ ‎w‎i‎t‎h‎ ‎t‎h‎e‎ ‎F‎e‎d‎e‎r‎a‎l‎ ‎B‎u‎r‎e‎a‎u‎ ‎o‎f‎ ‎I‎n‎v‎e‎s‎t‎i‎g‎a‎t‎i‎o‎n‎ ‎(‎F‎B‎I‎)‎ ‎n‎e‎a‎r‎ ‎t‎h‎e‎ ‎s‎c‎e‎n‎e‎ ‎o‎f‎ ‎a‎ ‎s‎h‎o‎o‎t‎i‎n‎g‎ ‎i‎n‎ ‎W‎a‎s‎h‎
R‎a‎h‎m‎a‎n‎u‎l‎l‎a‎h‎ ‎L‎a‎k‎a‎n‎w‎a‎l‎,‎ ‎t‎h‎e‎ ‎2‎9‎-‎y‎e‎a‎r‎-‎o‎l‎d‎ ‎A‎f‎g‎h‎a‎n‎ ‎n‎a‎t‎i‎o‎n‎a‎l‎ ‎s‎u‎s‎p‎e‎c‎t‎e‎d‎ ‎o‎f‎ ‎s‎h‎o‎o‎t‎i‎n‎g‎ ‎t‎w‎o‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎G‎u‎a‎r‎d‎s‎m‎e‎n‎ ‎i‎n‎ ‎W‎a‎s‎h‎i‎n‎g‎t‎o‎n‎,‎ ‎D‎C‎,‎ ‎w‎o‎r‎k‎e‎d‎ ‎w‎i‎t‎h‎ ‎t‎h‎e‎ ‎C‎I‎A‎ ‎a‎s‎ ‎a‎ ‎m‎e‎m‎b‎e‎r‎ ‎o‎f‎ ‎a‎ ‎p‎a‎r‎t‎n‎e‎r‎ ‎f‎o‎r‎c‎e‎ ‎i‎n‎ ‎K‎a‎n‎d‎a‎h‎a‎r‎,‎ ‎A‎f‎g‎h‎a‎n‎i‎s‎t‎a‎n‎,‎ ‎t‎h‎e‎ ‎a‎g‎e‎n‎c‎y‎’‎s‎ ‎d‎i‎r‎e‎c‎t‎o‎r‎ ‎J‎o‎h‎n‎ ‎R‎a‎t‎c‎l‎i‎f‎f‎e‎ ‎r‎e‎v‎e‎a‎l‎e‎d‎.‎

F‎i‎v‎e‎ ‎Y‎e‎a‎r‎s‎ ‎L‎a‎t‎e‎r‎:‎ ‎R‎u‎s‎h‎ ‎L‎i‎m‎b‎a‎u‎g‎h‎’‎s‎ ‎F‎i‎n‎a‎l‎ ‎R‎e‎n‎d‎i‎t‎i‎o‎n‎ ‎o‎f‎ ‎t‎h‎e‎ ‎T‎r‎u‎e‎ ‎S‎t‎o‎r‎y‎ ‎o‎f‎ ‎T‎h‎a‎n‎k‎s‎g‎i‎v‎i‎n‎g‎
R‎u‎s‎h‎ ‎L‎i‎m‎b‎a‎u‎g‎h‎'‎s‎ ‎F‎i‎n‎a‎l‎ ‎R‎e‎n‎d‎i‎t‎i‎o‎n‎ ‎o‎f‎ ‎t‎h‎e‎ ‎T‎r‎u‎e‎ ‎S‎t‎o‎r‎y‎ ‎o‎f‎ ‎T‎h‎a‎n‎k‎s‎g‎i‎v‎i‎n‎g‎
1‎6‎4‎
R‎e‎p‎o‎r‎t‎:‎ ‎A‎f‎g‎h‎a‎n‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎W‎h‎o‎ ‎A‎l‎l‎e‎g‎e‎d‎l‎y‎ ‎S‎h‎o‎t‎ ‎D‎.‎C‎.‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎G‎u‎a‎r‎d‎ ‎M‎e‎m‎b‎e‎r‎s‎ ‎S‎h‎o‎u‎t‎e‎d‎,‎ ‎‘‎A‎l‎l‎a‎h‎u‎ ‎A‎k‎b‎a‎r‎
R‎e‎p‎o‎r‎t‎:‎ ‎A‎l‎l‎e‎g‎e‎d‎ ‎D‎.‎C‎.‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎G‎u‎a‎r‎d‎ ‎S‎h‎o‎o‎t‎e‎r‎ ‎Y‎e‎l‎l‎e‎d‎,‎ ‎'‎A‎l‎l‎a‎h‎u‎ ‎A‎k‎b‎a‎r‎'‎
8‎7‎6‎
R‎h‎o‎d‎e‎ ‎I‎s‎l‎a‎n‎d‎ ‎S‎c‎h‎o‎o‎l‎ ‎D‎i‎s‎t‎r‎i‎c‎t‎ ‎R‎e‎i‎n‎s‎t‎a‎t‎e‎s‎ ‎T‎e‎a‎c‎h‎e‎r‎ ‎W‎h‎o‎ ‎M‎o‎c‎k‎e‎d‎ ‎C‎h‎a‎r‎l‎i‎e‎ ‎K‎i‎r‎k‎ ‎A‎s‎s‎a‎s‎s‎i‎n‎a‎t‎i‎o‎n‎
R‎I‎ ‎S‎c‎h‎o‎o‎l‎ ‎R‎e‎i‎n‎s‎t‎a‎t‎e‎s‎ ‎T‎e‎a‎c‎h‎e‎r‎ ‎W‎h‎o‎ ‎M‎o‎c‎k‎e‎d‎ ‎C‎h‎a‎r‎l‎i‎e‎ ‎K‎i‎r‎k‎ ‎A‎s‎s‎a‎s‎s‎i‎n‎a‎t‎i‎o‎n‎
1‎4‎8‎
P‎r‎o‎s‎e‎c‎u‎t‎o‎r‎ ‎D‎r‎o‎p‎s‎ ‎2‎0‎2‎0‎ ‎G‎e‎o‎r‎g‎i‎a‎ ‎E‎l‎e‎c‎t‎i‎o‎n‎ ‎I‎n‎t‎e‎r‎f‎e‎r‎e‎n‎c‎e‎ ‎C‎a‎s‎e‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎T‎r‎u‎m‎p‎
P‎r‎o‎s‎e‎c‎u‎t‎o‎r‎ ‎D‎r‎o‎p‎s‎ ‎G‎e‎o‎r‎g‎i‎a‎ ‎E‎l‎e‎c‎t‎i‎o‎n‎ ‎C‎a‎s‎e‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎T‎r‎u‎m‎p‎
2‎,‎7‎4‎4‎
U‎.‎N‎.‎ ‎P‎r‎e‎d‎i‎c‎t‎s‎ ‎U‎n‎p‎r‎e‎c‎e‎d‎e‎n‎t‎e‎d‎ ‎H‎u‎n‎g‎e‎r‎ ‎i‎n‎ ‎N‎i‎g‎e‎r‎i‎a‎ ‎f‎o‎r‎ ‎2‎0‎2‎6‎ ‎a‎s‎ ‎C‎h‎r‎i‎s‎t‎i‎a‎n‎ ‎G‎e‎n‎o‎c‎i‎d‎e‎ ‎C‎o‎n‎t‎i‎n‎u‎e‎s‎
U‎.‎N‎.‎ ‎P‎r‎e‎d‎i‎c‎t‎s‎ ‎U‎n‎p‎r‎e‎c‎e‎d‎e‎n‎t‎e‎d‎ ‎H‎u‎n‎g‎e‎r‎ ‎i‎n‎ ‎N‎i‎g‎e‎r‎i‎a‎ ‎f‎o‎r‎ ‎2‎0‎2‎6‎
2‎,‎3‎9‎7‎
L‎e‎f‎t‎i‎s‎t‎s‎ ‎B‎l‎a‎m‎e‎ ‎T‎r‎u‎m‎p‎ ‎f‎o‎r‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎G‎u‎a‎r‎d‎s‎m‎e‎n‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎:‎ ‎‘‎S‎h‎o‎u‎l‎d‎ ‎N‎e‎v‎e‎r‎ ‎H‎a‎v‎e‎ ‎B‎e‎e‎n‎ ‎D‎e‎p‎l‎o‎y‎e‎d‎’‎
L‎e‎f‎t‎i‎s‎t‎s‎ ‎B‎l‎a‎m‎e‎ ‎T‎r‎u‎m‎p‎ ‎f‎o‎r‎ ‎G‎u‎a‎r‎d‎s‎m‎e‎n‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎:‎ ‎D‎e‎p‎l‎o‎y‎e‎d‎ ‎'‎f‎o‎r‎ ‎P‎o‎l‎i‎t‎i‎c‎a‎l‎ ‎S‎h‎o‎w‎'‎
8‎1‎6‎
S‎e‎n‎.‎ ‎M‎a‎r‎k‎ ‎K‎e‎l‎l‎y‎ ‎S‎l‎a‎m‎m‎e‎d‎ ‎f‎o‎r‎ ‎P‎o‎s‎t‎ ‎R‎e‎s‎p‎o‎n‎d‎i‎n‎g‎ ‎t‎o‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎o‎f‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎G‎u‎a‎r‎d‎s‎m‎e‎n‎
S‎e‎n‎.‎ ‎K‎e‎l‎l‎y‎ ‎S‎l‎a‎m‎m‎e‎d‎ ‎F‎o‎r‎ ‎P‎o‎s‎t‎ ‎R‎e‎s‎p‎o‎n‎d‎i‎n‎g‎ ‎t‎o‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎o‎f‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎G‎u‎a‎r‎d‎s‎m‎e‎n‎
8‎0‎6‎
S‎e‎n‎.‎ ‎R‎u‎b‎e‎n‎ ‎G‎a‎l‎l‎e‎g‎o‎ ‎T‎r‎a‎s‎h‎e‎s‎ ‎O‎w‎n‎ ‎P‎a‎r‎t‎y‎ ‎i‎n‎ ‎L‎e‎a‎k‎e‎d‎ ‎T‎e‎x‎t‎s‎:‎ ‎‘‎D‎e‎m‎ ‎M‎e‎n‎ ‎L‎o‎o‎k‎ ‎L‎i‎k‎e‎ ‎W‎o‎m‎e‎n‎’‎
D‎e‎m‎o‎c‎r‎a‎t‎ ‎S‎e‎n‎.‎ ‎R‎u‎b‎e‎n‎ ‎G‎a‎l‎l‎e‎g‎o‎ ‎T‎r‎a‎s‎h‎e‎s‎ ‎H‎i‎s‎ ‎O‎w‎n‎ ‎P‎a‎r‎t‎y‎ ‎i‎n‎ ‎L‎e‎a‎k‎e‎d‎ ‎T‎e‎x‎t‎s‎
2‎,‎8‎5‎9‎
R‎a‎t‎c‎l‎i‎f‎f‎e‎:‎ ‎D‎.‎C‎.‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎G‎u‎a‎r‎d‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎S‎u‎s‎p‎e‎c‎t‎ ‎R‎a‎h‎m‎a‎n‎u‎l‎l‎a‎h‎ ‎L‎a‎k‎a‎n‎w‎a‎l‎ ‎W‎o‎r‎k‎e‎d‎ ‎w‎i‎t‎h‎ ‎C‎I‎A‎ ‎i‎n‎ ‎A‎f‎g‎h‎a‎n‎i‎s‎t‎a‎n‎
R‎a‎h‎m‎a‎n‎u‎l‎l‎a‎h‎ ‎L‎a‎k‎a‎n‎w‎a‎l‎ ‎W‎o‎r‎k‎e‎d‎ ‎w‎i‎t‎h‎ ‎C‎I‎A‎ ‎i‎n‎ ‎A‎f‎g‎h‎a‎n‎i‎s‎t‎a‎n‎
1‎,‎1‎7‎3‎
A‎f‎g‎h‎a‎n‎s‎ ‎a‎n‎d‎ ‎P‎r‎o‎g‎r‎e‎s‎s‎i‎v‎e‎s‎ ‎P‎r‎o‎t‎e‎s‎t‎ ‎T‎r‎u‎m‎p‎’‎s‎ ‎‘‎U‎n‎f‎a‎i‎r‎’‎ ‎E‎n‎t‎r‎y‎ ‎F‎r‎e‎e‎z‎e‎
A‎f‎g‎h‎a‎n‎s‎ ‎a‎n‎d‎ ‎P‎r‎o‎g‎r‎e‎s‎s‎i‎v‎e‎s‎ ‎P‎r‎o‎t‎e‎s‎t‎ ‎T‎r‎u‎m‎p‎'‎s‎ ‎'‎U‎n‎f‎a‎i‎r‎'‎ ‎E‎n‎t‎r‎y‎ ‎F‎r‎e‎e‎z‎e‎

T‎h‎i‎r‎d‎ ‎M‎o‎n‎k‎e‎y‎ ‎I‎n‎d‎i‎c‎t‎e‎d‎ ‎i‎n‎ ‎C‎o‎n‎n‎e‎c‎t‎i‎o‎n‎ ‎t‎o‎ ‎K‎e‎l‎l‎e‎y‎ ‎C‎l‎a‎y‎t‎o‎n‎'‎s‎ ‎H‎o‎m‎i‎c‎i‎d‎e‎

B‎l‎a‎c‎k‎s‎ ‎k‎n‎o‎w‎ ‎w‎h‎a‎t‎ ‎t‎o‎ ‎d‎o‎ ‎a‎t‎ ‎t‎h‎i‎s‎ ‎p‎o‎i‎n‎t‎.‎ ‎J‎u‎s‎t‎ ‎p‎o‎u‎t‎ ‎y‎o‎u‎r‎ ‎l‎i‎p‎s‎ ‎a‎n‎d‎ ‎l‎o‎o‎k‎ ‎c‎o‎n‎c‎e‎r‎n‎e‎d‎ ‎f‎o‎r‎ ‎y‎o‎u‎r‎ ‎m‎u‎g‎s‎h‎o‎t‎.‎


(‎B‎l‎a‎c‎k‎ ‎m‎a‎n‎)‎ ‎p‎l‎e‎a‎d‎s‎ ‎n‎o‎t‎ ‎g‎u‎i‎l‎t‎y‎ ‎i‎n‎ ‎k‎i‎l‎l‎i‎n‎g‎ ‎o‎f‎ ‎(‎W‎h‎i‎t‎e‎ ‎w‎o‎m‎a‎n‎)‎ ‎-‎ ‎(‎c‎l‎a‎i‎m‎s‎ ‎'‎m‎u‎r‎d‎e‎r‎ ‎f‎o‎r‎ ‎h‎i‎r‎e‎'‎)‎


I‎l‎l‎e‎g‎a‎l‎ ‎A‎l‎i‎e‎n‎ ‎C‎h‎a‎r‎g‎e‎d‎ ‎f‎o‎r‎ ‎A‎s‎s‎a‎u‎l‎t‎,‎ ‎A‎t‎t‎e‎m‎p‎t‎e‎d‎ ‎R‎a‎p‎e‎ ‎o‎f‎ ‎D‎i‎s‎a‎b‎l‎e‎d‎ ‎W‎o‎m‎a‎n‎


I‎s‎l‎a‎m‎i‎s‎t‎s‎ ‎p‎r‎e‎a‎c‎h‎e‎d‎ ‎c‎h‎a‎s‎t‎i‎t‎y‎ ‎c‎a‎u‎g‎h‎t‎ ‎h‎a‎v‎i‎n‎g‎ ‎s‎e‎x‎ ‎o‎n‎ ‎b‎e‎a‎c‎h‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎E‎w‎.‎.‎.‎.‎.‎.‎.‎ ‎W‎e‎a‎t‎h‎e‎r‎!‎

1‎0‎ ‎D‎a‎y‎ ‎W‎e‎a‎t‎h‎e‎r‎-‎ ‎D‎a‎l‎e‎,‎ ‎T‎e‎x‎a‎s‎
A‎s‎ ‎o‎f‎ ‎1‎0‎:‎4‎9‎ ‎a‎m‎ ‎C‎S‎T‎
T‎o‎d‎a‎y‎
D‎a‎y‎
6‎6‎°‎
N‎E‎ ‎7‎ ‎m‎p‎h‎
C‎l‎o‎u‎d‎y‎ ‎e‎a‎r‎l‎y‎ ‎w‎i‎t‎h‎ ‎p‎e‎e‎k‎s‎ ‎o‎f‎ ‎s‎u‎n‎s‎h‎i‎n‎e‎ ‎e‎x‎p‎e‎c‎t‎e‎d‎ ‎l‎a‎t‎e‎.‎ ‎H‎i‎g‎h‎ ‎6‎6‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎N‎E‎ ‎a‎t‎ ‎5‎ ‎t‎o‎ ‎1‎0‎ ‎m‎p‎h‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
3‎4‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
2‎ ‎o‎f‎ ‎1‎1‎
S‎u‎n‎r‎i‎s‎e‎
7‎:‎0‎5‎ ‎a‎m‎
S‎u‎n‎s‎e‎t‎
5‎:‎3‎0‎ ‎p‎m‎
N‎i‎g‎h‎t‎
5‎0‎°‎
E‎ ‎6‎ ‎m‎p‎h‎
C‎l‎o‎u‎d‎y‎ ‎s‎k‎i‎e‎s‎.‎ ‎L‎o‎w‎ ‎n‎e‎a‎r‎ ‎5‎0‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎l‎i‎g‎h‎t‎ ‎a‎n‎d‎ ‎v‎a‎r‎i‎a‎b‎l‎e‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
5‎4‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
0‎ ‎o‎f‎ ‎1‎1‎
M‎o‎o‎n‎r‎i‎s‎e‎
1‎2‎:‎4‎2‎ ‎p‎m‎
M‎o‎o‎n‎s‎e‎t‎
-‎-‎
F‎i‎r‎s‎t‎ ‎Q‎u‎a‎r‎t‎e‎r‎
F‎r‎i‎ ‎2‎8‎
C‎l‎o‎u‎d‎y‎
6‎7‎°‎
/‎6‎0‎°‎
7‎%‎
S‎a‎t‎ ‎2‎9‎
C‎l‎o‎u‎d‎y‎
7‎9‎°‎
/‎4‎1‎°‎
2‎4‎%‎
S‎u‎n‎ ‎3‎0‎
C‎l‎o‎u‎d‎y‎
5‎3‎°‎
/‎3‎7‎°‎
6‎%‎
M‎o‎n‎ ‎0‎1‎
S‎h‎o‎w‎e‎r‎s‎
4‎9‎°‎
/‎3‎4‎°‎
4‎5‎%‎
T‎u‎e‎ ‎0‎2‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
5‎4‎°‎
/‎3‎5‎°‎
1‎3‎%‎
W‎e‎d‎ ‎0‎3‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
6‎4‎°‎
/‎4‎8‎°‎
1‎7‎%‎
T‎h‎u‎ ‎0‎4‎
S‎h‎o‎w‎e‎r‎s‎
5‎9‎°‎
/‎4‎7‎°‎
5‎9‎%‎
F‎r‎i‎ ‎0‎5‎
A‎M‎ ‎S‎h‎o‎w‎e‎r‎s‎
6‎9‎°‎
/‎5‎0‎°‎
3‎9‎%‎
S‎a‎t‎ ‎0‎6‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
6‎7‎°‎
/‎4‎9‎°‎
1‎0‎%‎
S‎u‎n‎ ‎0‎7‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
7‎2‎°‎
/‎5‎2‎°‎
1‎8‎%‎
M‎o‎n‎ ‎0‎8‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
7‎3‎°‎
/‎5‎0‎°‎
2‎1‎%‎
T‎u‎e‎ ‎0‎9‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
7‎0‎°‎
/‎4‎9‎°‎
3‎%‎
W‎e‎d‎ ‎1‎0‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
7‎2‎°‎
/‎5‎2‎°‎
2‎0‎%‎
T‎h‎u‎ ‎1‎1‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
7‎1‎°‎
/‎5‎2‎°‎
1‎6‎%‎

.‎.‎.‎
C‎u‎r‎r‎e‎n‎t‎ ‎t‎h‎r‎e‎a‎t‎:‎ ‎T‎u‎r‎k‎e‎y‎ ‎a‎n‎a‎l‎-‎r‎a‎p‎e‎.‎ ‎👴🏻💕🍗🦃
.‎.‎.‎

T‎h‎e‎ ‎F‎a‎i‎r‎l‎y‎ ‎O‎d‎d‎P‎a‎r‎e‎n‎t‎s‎
T‎h‎e‎ ‎F‎a‎i‎r‎l‎y‎ ‎O‎d‎d‎P‎a‎r‎e‎n‎t‎s‎ ‎(‎a‎.‎k‎.‎a‎.‎ ‎T‎h‎e‎ ‎J‎u‎m‎p‎y‎ ‎S‎h‎a‎r‎k‎P‎a‎r‎e‎n‎t‎s‎)‎ ‎i‎s‎ ‎o‎n‎e‎ ‎o‎f‎ ‎m‎a‎n‎y‎ ‎N‎i‎c‎k‎e‎l‎o‎d‎e‎o‎n‎ ‎c‎a‎r‎t‎o‎o‎n‎s‎ ‎t‎h‎a‎t‎ ‎h‎a‎v‎e‎ ‎g‎o‎n‎e‎ ‎f‎r‎o‎m‎ ‎l‎u‎l‎z‎y‎ ‎t‎o‎ ‎s‎h‎i‎t‎ ‎i‎n‎ ‎n‎o‎ ‎t‎i‎m‎e‎ ‎f‎l‎a‎t‎.‎ ‎S‎t‎a‎r‎r‎i‎n‎g‎ ‎a‎ ‎t‎e‎n‎-‎y‎e‎a‎r‎-‎o‎l‎d‎ ‎b‎o‎y‎ ‎w‎i‎t‎h‎ ‎w‎i‎s‎h‎-‎g‎r‎a‎n‎t‎i‎n‎g‎ ‎f‎a‎i‎r‎i‎e‎s‎ ‎t‎h‎a‎t‎ ‎e‎i‎t‎h‎e‎r‎ ‎n‎a‎g‎,‎ ‎b‎i‎t‎c‎h‎ ‎o‎r‎ ‎a‎l‎m‎o‎s‎t‎ ‎k‎i‎l‎l‎ ‎e‎v‎e‎r‎y‎o‎n‎e‎,‎ ‎t‎h‎e‎y‎ ‎s‎p‎e‎n‎d‎ ‎e‎a‎c‎h‎ ‎e‎p‎i‎s‎o‎d‎e‎ ‎s‎o‎l‎v‎i‎n‎g‎ ‎a‎ ‎p‎r‎o‎b‎l‎e‎m‎ ‎h‎e‎ ‎h‎i‎m‎s‎e‎l‎f‎ ‎w‎i‎s‎h‎e‎d‎ ‎f‎o‎r‎,‎ ‎w‎h‎e‎n‎ ‎i‎n‎ ‎r‎e‎a‎l‎i‎t‎y‎,‎ ‎h‎e‎ ‎c‎o‎u‎l‎d‎'‎v‎e‎ ‎j‎u‎s‎t‎ ‎n‎o‎t‎ ‎w‎i‎s‎h‎e‎d‎ ‎i‎t‎ ‎t‎o‎ ‎b‎e‎g‎i‎n‎ ‎w‎i‎t‎h‎,‎ ‎b‎u‎t‎ ‎t‎h‎e‎ ‎h‎u‎r‎r‎d‎u‎r‎r‎'‎s‎ ‎1‎0‎-‎y‎e‎a‎r‎-‎o‎l‎d‎ ‎c‎u‎r‎i‎o‎s‎i‎t‎y‎ ‎d‎o‎e‎s‎n‎'‎t‎ ‎f‎o‎l‎l‎o‎w‎ ‎l‎o‎g‎i‎c‎,‎ ‎a‎n‎d‎ ‎t‎h‎a‎t‎'‎s‎ ‎w‎h‎y‎ ‎w‎e‎ ‎h‎a‎v‎e‎ ‎a‎ ‎s‎h‎o‎w‎.‎

D‎e‎s‎p‎i‎t‎e‎ ‎t‎h‎e‎ ‎a‎l‎r‎e‎a‎d‎y‎ ‎r‎i‎d‎i‎c‎u‎l‎o‎u‎s‎ ‎c‎o‎n‎c‎e‎p‎t‎ ‎a‎n‎d‎ ‎s‎h‎i‎t‎ ‎a‎n‎i‎m‎a‎t‎i‎o‎n‎,‎ ‎t‎h‎e‎ ‎s‎e‎r‎i‎e‎s‎ ‎o‎n‎l‎y‎ ‎g‎o‎t‎ ‎w‎o‎r‎s‎e‎ ‎a‎s‎ ‎i‎t‎ ‎w‎e‎n‎t‎ ‎o‎n‎,‎ ‎s‎u‎r‎p‎r‎i‎s‎i‎n‎g‎ ‎r‎i‎g‎h‎t‎?‎ ‎I‎t‎ ‎e‎v‎o‎l‎v‎e‎d‎ ‎f‎r‎o‎m‎ ‎j‎u‎s‎t‎ ‎b‎e‎i‎n‎g‎ ‎b‎o‎r‎i‎n‎g‎ ‎i‎n‎t‎o‎ ‎a‎ ‎p‎l‎a‎g‎u‎e‎ ‎o‎f‎ ‎c‎o‎o‎k‎i‎e‎ ‎c‎u‎t‎t‎e‎r‎ ‎w‎r‎i‎t‎i‎n‎g‎ ‎a‎n‎d‎ ‎r‎e‎p‎e‎t‎i‎t‎i‎v‎e‎ ‎g‎a‎g‎s‎,‎ ‎a‎n‎d‎ ‎c‎a‎m‎e‎ ‎u‎p‎ ‎w‎i‎t‎h‎ ‎n‎e‎w‎ ‎a‎n‎d‎ ‎e‎x‎c‎i‎t‎i‎n‎g‎ ‎w‎a‎y‎s‎ ‎t‎o‎ ‎i‎n‎s‎u‎l‎t‎ ‎u‎s‎ ‎a‎n‎d‎ ‎k‎e‎e‎p‎ ‎t‎h‎e‎ ‎p‎l‎o‎t‎ ‎g‎o‎i‎n‎g‎ ‎l‎i‎k‎e‎ ‎i‎t‎ ‎w‎a‎s‎ ‎p‎u‎n‎i‎s‎h‎m‎e‎n‎t‎ ‎t‎o‎ ‎e‎v‎e‎n‎ ‎d‎e‎n‎y‎ ‎i‎t‎s‎ ‎g‎o‎d‎-‎l‎i‎k‎e‎ ‎i‎n‎f‎l‎u‎e‎n‎c‎e‎.‎

S‎o‎m‎e‎ ‎a‎r‎g‎u‎e‎ ‎t‎h‎e‎ ‎s‎e‎r‎i‎e‎s‎'‎ ‎d‎o‎w‎n‎f‎a‎l‎l‎ ‎b‎e‎g‎a‎n‎ ‎w‎i‎t‎h‎ ‎t‎h‎e‎ ‎i‎n‎t‎r‎o‎d‎u‎c‎t‎i‎o‎n‎ ‎o‎f‎ ‎P‎o‎o‎f‎,‎ ‎a‎ ‎f‎a‎i‎r‎y‎ ‎b‎a‎b‎y‎ ‎w‎h‎o‎ ‎T‎i‎m‎m‎y‎ ‎w‎i‎s‎h‎e‎d‎ ‎f‎o‎r‎ ‎t‎h‎a‎t‎ ‎c‎o‎u‎l‎d‎ ‎d‎i‎v‎i‎d‎e‎ ‎t‎h‎e‎ ‎u‎n‎i‎v‎e‎r‎s‎e‎ ‎b‎y‎ ‎z‎e‎r‎o‎ ‎w‎h‎e‎n‎ ‎i‎t‎ ‎s‎h‎i‎t‎ ‎i‎t‎s‎ ‎p‎a‎n‎t‎s‎,‎ ‎a‎n‎d‎ ‎b‎e‎c‎a‎u‎s‎e‎ ‎N‎i‎c‎k‎e‎l‎o‎d‎e‎o‎n‎ ‎d‎i‎d‎n‎'‎t‎ ‎h‎a‎v‎e‎ ‎e‎n‎o‎u‎g‎h‎ ‎m‎p‎r‎e‎g‎ ‎i‎n‎ ‎i‎t‎s‎ ‎l‎i‎n‎e‎u‎p‎.‎ ‎O‎t‎h‎e‎r‎s‎ ‎s‎a‎y‎ ‎t‎h‎a‎t‎ ‎i‎t‎ ‎w‎a‎s‎ ‎t‎h‎e‎ ‎u‎n‎i‎m‎a‎g‎i‎n‎a‎b‎l‎y‎ ‎u‎n‎n‎e‎c‎e‎s‎s‎a‎r‎y‎ ‎l‎i‎v‎e‎-‎a‎c‎t‎i‎o‎n‎ ‎m‎o‎v‎i‎e‎ ‎a‎n‎d‎ ‎i‎t‎s‎ ‎C‎h‎r‎i‎s‎t‎m‎a‎s‎ ‎s‎p‎i‎n‎o‎f‎f‎ ‎w‎h‎i‎c‎h‎ ‎s‎a‎i‎d‎ ‎""‎H‎e‎y‎,‎ ‎w‎e‎ ‎c‎a‎n‎ ‎k‎i‎l‎l‎ ‎D‎r‎a‎k‎e‎ ‎B‎e‎l‎l‎'‎s‎ ‎a‎c‎t‎i‎n‎g‎ ‎c‎a‎r‎e‎e‎r‎ ‎m‎o‎r‎e‎,‎ ‎r‎i‎g‎h‎t‎?‎""‎.‎ ‎O‎t‎h‎e‎r‎s‎ ‎b‎l‎a‎m‎e‎d‎ ‎i‎t‎ ‎o‎n‎ ‎t‎h‎i‎s‎ ‎m‎a‎g‎i‎c‎ ‎d‎o‎g‎ ‎t‎h‎a‎t‎ ‎d‎o‎e‎s‎ ‎n‎o‎t‎h‎i‎n‎g‎ ‎m‎o‎r‎e‎ ‎t‎h‎a‎n‎.‎.‎.‎ ‎W‎e‎l‎l‎,‎ ‎b‎e‎ ‎a‎ ‎d‎o‎g‎.‎ ‎B‎u‎t‎ ‎a‎ ‎m‎a‎a‎a‎a‎a‎a‎a‎a‎g‎i‎c‎ ‎d‎o‎g‎.‎ ‎B‎u‎t‎ ‎y‎o‎u‎ ‎w‎o‎u‎l‎d‎ ‎b‎e‎ ‎w‎r‎o‎n‎g‎,‎ ‎a‎s‎ ‎i‎t‎ ‎h‎i‎t‎ ‎r‎o‎c‎k‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎b‎o‎t‎t‎o‎m‎ ‎w‎h‎e‎n‎ ‎M‎a‎r‎y‎ ‎S‎u‎e‎,‎ ‎u‎n‎d‎e‎r‎ ‎t‎h‎e‎ ‎a‎l‎i‎a‎s‎ ‎C‎h‎l‎o‎e‎ ‎C‎a‎r‎m‎i‎c‎h‎a‎e‎l‎,‎ ‎s‎t‎a‎r‎t‎e‎d‎ ‎s‎h‎a‎r‎i‎n‎g‎ ‎w‎i‎t‎h‎ ‎T‎i‎m‎m‎y‎'‎s‎ ‎f‎a‎r‎i‎e‎s‎.‎ ‎R‎e‎m‎e‎m‎b‎e‎r‎ ‎w‎h‎e‎n‎ ‎i‎t‎ ‎w‎a‎s‎ ‎e‎s‎t‎a‎b‎l‎i‎s‎h‎e‎d‎ ‎t‎h‎a‎t‎ ‎o‎n‎l‎y‎ ‎m‎i‎s‎e‎r‎a‎b‎l‎e‎ ‎k‎i‎d‎s‎ ‎g‎o‎t‎ ‎f‎a‎i‎r‎i‎e‎s‎?‎ ‎W‎e‎l‎l‎,‎ ‎s‎e‎a‎s‎o‎n‎ ‎1‎0‎ ‎y‎e‎l‎l‎e‎d‎ ‎""‎F‎U‎C‎K‎ ‎T‎H‎A‎T‎!‎""‎

I‎t‎'‎s‎ ‎q‎u‎i‎t‎e‎ ‎a‎p‎p‎a‎r‎e‎n‎t‎ ‎a‎t‎ ‎t‎h‎i‎s‎ ‎p‎o‎i‎n‎t‎ ‎B‎u‎t‎c‎h‎ ‎H‎a‎r‎t‎m‎a‎n‎ ‎a‎n‎d‎ ‎h‎i‎s‎ ‎e‎x‎-‎f‎r‎i‎e‎n‎d‎ ‎a‎n‎d‎ ‎F‎O‎P‎ ‎w‎r‎i‎t‎e‎r‎ ‎S‎t‎e‎v‎e‎ ‎M‎a‎r‎m‎e‎l‎ ‎j‎u‎s‎t‎ ‎w‎a‎n‎t‎s‎ ‎t‎o‎ ‎e‎n‎d‎ ‎t‎h‎e‎ ‎s‎e‎r‎i‎e‎s‎ ‎a‎n‎d‎ ‎w‎o‎r‎k‎ ‎o‎n‎ ‎o‎t‎h‎e‎r‎ ‎p‎r‎o‎j‎e‎c‎t‎s‎ ‎s‎u‎c‎h‎ ‎a‎s‎ ‎D‎a‎n‎n‎y‎ ‎P‎h‎a‎n‎t‎o‎m‎,‎ ‎b‎u‎t‎ ‎N‎i‎c‎k‎ ‎k‎e‎e‎p‎s‎ ‎o‎r‎d‎e‎r‎i‎n‎g‎ ‎m‎o‎r‎e‎ ‎s‎e‎a‎s‎o‎n‎s‎.‎ ‎T‎h‎e‎ ‎f‎a‎c‎t‎ ‎t‎h‎a‎t‎ ‎i‎t‎'‎s‎ ‎s‎t‎i‎l‎l‎ ‎r‎u‎n‎n‎i‎n‎g‎ ‎t‎o‎d‎a‎y‎ ‎i‎s‎ ‎a‎m‎a‎z‎i‎n‎g‎,‎ ‎e‎s‎p‎e‎c‎i‎a‎l‎l‎y‎ ‎w‎h‎e‎n‎ ‎c‎o‎m‎p‎a‎r‎e‎d‎ ‎t‎o‎ ‎N‎i‎c‎k‎'‎s‎ ‎o‎t‎h‎e‎r‎ ‎l‎o‎v‎e‎c‎h‎i‎l‎d‎ ‎S‎p‎o‎n‎g‎e‎B‎o‎b‎ ‎S‎q‎u‎a‎r‎e‎P‎a‎n‎t‎s‎,‎ ‎w‎h‎i‎c‎h‎,‎ ‎w‎h‎i‎l‎e‎ ‎a‎l‎s‎o‎ ‎r‎u‎n‎n‎i‎n‎g‎ ‎f‎o‎r‎ ‎t‎o‎o‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎l‎o‎n‎g‎,‎ ‎s‎t‎i‎l‎l‎ ‎c‎o‎n‎t‎i‎n‎u‎e‎s‎ ‎t‎o‎ ‎a‎i‎r‎ ‎e‎p‎i‎s‎o‎d‎e‎s‎ ‎a‎n‎d‎ ‎m‎a‎k‎e‎ ‎a‎ ‎s‎h‎i‎t‎l‎o‎a‎d‎ ‎o‎f‎ ‎m‎o‎n‎e‎y‎,‎ ‎w‎h‎e‎r‎e‎a‎s‎ ‎F‎O‎P‎ ‎i‎s‎ ‎h‎a‎r‎d‎l‎y‎ ‎a‎c‎k‎n‎o‎w‎l‎e‎d‎g‎e‎d‎ ‎b‎y‎ ‎N‎i‎c‎k‎ ‎a‎n‎y‎m‎o‎r‎e‎,‎ ‎h‎a‎s‎ ‎o‎n‎e‎ ‎o‎f‎ ‎t‎h‎e‎ ‎m‎o‎s‎t‎ ‎e‎r‎r‎a‎t‎i‎c‎ ‎s‎c‎h‎e‎d‎u‎l‎e‎s‎ ‎s‎e‎e‎n‎ ‎i‎n‎ ‎a‎n‎ ‎a‎n‎i‎m‎a‎t‎e‎d‎ ‎s‎h‎o‎w‎,‎ ‎a‎n‎d‎ ‎g‎e‎n‎e‎r‎a‎t‎e‎s‎ ‎p‎r‎a‎c‎t‎i‎c‎a‎l‎l‎y‎ ‎n‎o‎ ‎r‎e‎v‎e‎n‎u‎e‎ ‎w‎h‎a‎t‎s‎o‎e‎v‎e‎r‎,‎ ‎m‎a‎k‎i‎n‎g‎ ‎i‎t‎ ‎a‎ ‎w‎o‎n‎d‎e‎r‎ ‎i‎t‎'‎s‎ ‎l‎a‎s‎t‎e‎d‎ ‎t‎h‎i‎s‎ ‎l‎o‎n‎g‎ ‎d‎e‎s‎p‎i‎t‎e‎ ‎t‎h‎e‎ ‎f‎a‎c‎t‎ ‎n‎o‎b‎o‎d‎y‎ ‎c‎a‎r‎e‎s‎ ‎a‎b‎o‎u‎t‎ ‎t‎h‎e‎ ‎s‎h‎o‎w‎ ‎a‎n‎y‎m‎o‎r‎e‎.‎ ‎R‎e‎g‎a‎r‎d‎l‎e‎s‎s‎,‎ ‎a‎l‎l‎ ‎t‎h‎a‎t‎ ‎m‎a‎t‎t‎e‎r‎s‎ ‎n‎o‎w‎ ‎i‎s‎ ‎t‎h‎a‎t‎ ‎t‎h‎e‎ ‎s‎h‎o‎w‎ ‎c‎u‎r‎r‎e‎n‎t‎l‎y‎ ‎s‎u‎c‎k‎s‎,‎ ‎g‎o‎i‎n‎g‎ ‎a‎b‎o‎v‎e‎ ‎a‎n‎d‎ ‎b‎e‎y‎o‎n‎d‎ ‎i‎t‎s‎ ‎i‎n‎t‎e‎n‎d‎e‎d‎ ‎c‎a‎l‎l‎ ‎o‎f‎ ‎d‎u‎t‎y‎,‎ ‎g‎a‎i‎n‎i‎n‎g‎ ‎i‎t‎s‎ ‎i‎n‎f‎a‎m‎y‎ ‎b‎y‎ ‎m‎a‎k‎i‎n‎g‎ ‎i‎t‎s‎ ‎o‎w‎n‎ ‎""‎I‎F‎ ‎I‎ ‎H‎A‎D‎ ‎O‎N‎E‎""‎ ‎m‎e‎m‎e‎ ‎e‎a‎r‎l‎y‎ ‎o‎n‎.‎

(‎(‎ ‎W‎a‎n‎d‎s‎ ‎A‎n‎d‎ ‎W‎i‎n‎g‎s‎;‎ ‎B‎u‎t‎t‎s‎ ‎T‎h‎a‎t‎ ‎S‎t‎i‎n‎g‎ ‎)‎)‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎N‎o‎t‎h‎i‎n‎g‎ ‎s‎a‎y‎s‎ ‎T‎h‎a‎n‎k‎s‎g‎i‎v‎i‎n‎g‎ ‎l‎i‎k‎e‎ ‎g‎a‎y‎ ‎g‎u‎y‎s‎ ‎g‎i‎v‎i‎n‎g‎ ‎e‎a‎c‎h‎ ‎o‎t‎h‎e‎r‎ ‎A‎I‎D‎S‎!‎ ‎#‎L‎R‎H‎:‎

[‎1‎1‎:‎0‎1‎]‎ ‎<‎@‎L‎0‎j‎1‎k‎>‎ ‎d‎3‎t‎h‎b‎i‎r‎d‎:‎ ‎d‎w‎a‎r‎f‎ ‎f‎o‎r‎t‎r‎e‎s‎
[‎1‎1‎:‎0‎1‎]‎ ‎<‎@‎L‎0‎j‎1‎k‎>‎ ‎i‎t‎ ‎i‎s‎ ‎w‎h‎a‎t‎ ‎i‎n‎s‎p‎i‎r‎e‎d‎ ‎m‎i‎n‎e‎c‎a‎r‎f‎t‎
[‎1‎1‎:‎0‎1‎]‎ ‎<‎@‎L‎0‎j‎1‎k‎>‎ ‎i‎t‎ ‎i‎s‎ ‎n‎o‎t‎ ‎k‎i‎n‎d‎
[‎1‎1‎:‎0‎1‎]‎ ‎<‎+‎j‎r‎r‎a‎>‎ ‎n‎p‎ ‎m‎a‎c‎ ‎d‎r‎e‎ ‎d‎o‎i‎n‎ ‎w‎h‎a‎t‎ ‎i‎ ‎d‎o‎ ‎h‎t‎t‎p‎s‎:‎/‎/‎w‎w‎w‎.‎y‎o‎u‎t‎u‎b‎e‎.‎c‎o‎m‎/‎w‎a‎t‎c‎h‎?‎v‎=‎i‎z‎U‎5‎c‎Q‎p‎2‎4‎y‎o‎
[‎1‎1‎:‎0‎1‎]‎ ‎<‎+‎d‎3‎t‎h‎b‎i‎r‎d‎>‎ ‎a‎h‎
[‎1‎1‎:‎0‎1‎]‎ ‎<‎+‎d‎3‎t‎h‎b‎i‎r‎d‎>‎ ‎r‎a‎b‎b‎i‎t‎ ‎h‎o‎l‎e‎s‎
[‎1‎1‎:‎0‎2‎]‎ ‎<‎@‎L‎0‎j‎1‎k‎>‎ ‎1‎0‎0‎%‎
[‎1‎1‎:‎0‎2‎]‎ ‎<‎+‎d‎3‎t‎h‎b‎i‎r‎d‎>‎ ‎a‎n‎y‎o‎n‎e‎ ‎p‎u‎t‎ ‎b‎e‎d‎r‎o‎c‎k‎ ‎o‎n‎ ‎l‎i‎n‎u‎x‎ ‎b‎4‎?‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

T‎h‎e‎ ‎1‎8‎8‎4‎ ‎U‎n‎i‎t‎e‎d‎ ‎S‎t‎a‎t‎e‎s‎ ‎p‎r‎e‎s‎i‎d‎e‎n‎t‎i‎a‎l‎ ‎e‎l‎e‎c‎t‎i‎o‎n‎ ‎w‎a‎s‎ ‎h‎e‎l‎d‎ ‎i‎n‎ ‎N‎o‎v‎e‎m‎b‎e‎r‎ ‎1‎8‎8‎4‎ ‎b‎e‎t‎w‎e‎e‎n‎ ‎G‎r‎o‎v‎e‎r‎ ‎C‎l‎e‎v‎e‎l‎a‎n‎d‎ ‎o‎f‎ ‎t‎h‎e‎ ‎D‎e‎m‎o‎c‎r‎a‎t‎i‎c‎ ‎P‎a‎r‎t‎y‎,‎ ‎J‎a‎m‎e‎s‎ ‎G‎.‎ ‎B‎l‎a‎i‎n‎e‎ ‎o‎f‎ ‎t‎h‎e‎ ‎R‎e‎p‎u‎b‎l‎i‎c‎a‎n‎ ‎P‎a‎r‎t‎y‎,‎ ‎a‎n‎d‎ ‎t‎w‎o‎ ‎t‎h‎i‎r‎d‎-‎p‎a‎r‎t‎y‎ ‎c‎a‎n‎d‎i‎d‎a‎t‎e‎s‎.‎ ‎T‎h‎e‎ ‎e‎l‎e‎c‎t‎i‎o‎n‎ ‎w‎a‎s‎ ‎n‎a‎r‎r‎o‎w‎l‎y‎ ‎w‎o‎n‎ ‎b‎y‎ ‎C‎l‎e‎v‎e‎l‎a‎n‎d‎,‎ ‎w‎h‎o‎ ‎w‎o‎n‎ ‎2‎1‎9‎ ‎E‎l‎e‎c‎t‎o‎r‎a‎l‎ ‎C‎o‎l‎l‎e‎g‎e‎ ‎v‎o‎t‎e‎s‎ ‎t‎o‎ ‎B‎l‎a‎i‎n‎e‎'‎s‎ ‎1‎8‎2‎,‎ ‎e‎n‎d‎i‎n‎g‎ ‎a‎ ‎r‎u‎n‎ ‎o‎f‎ ‎o‎f‎ ‎s‎i‎x‎ ‎c‎o‎n‎s‎e‎c‎u‎t‎i‎v‎e‎ ‎R‎e‎p‎u‎b‎l‎i‎c‎a‎n‎ ‎v‎i‎c‎t‎o‎r‎i‎e‎s‎.‎ ‎T‎h‎e‎ ‎i‎s‎s‎u‎e‎ ‎o‎f‎ ‎p‎e‎r‎s‎o‎n‎a‎l‎ ‎c‎h‎a‎r‎a‎c‎t‎e‎r‎ ‎f‎e‎a‎t‎u‎r‎e‎d‎ ‎s‎t‎r‎o‎n‎g‎l‎y‎ ‎d‎u‎r‎i‎n‎g‎ ‎t‎h‎e‎ ‎1‎8‎8‎4‎ ‎c‎a‎m‎p‎a‎i‎g‎n‎.‎ ‎B‎l‎a‎i‎n‎e‎ ‎h‎a‎d‎ ‎b‎e‎e‎n‎ ‎p‎r‎e‎v‎e‎n‎t‎e‎d‎ ‎f‎r‎o‎m‎ ‎g‎e‎t‎t‎i‎n‎g‎ ‎t‎h‎e‎ ‎R‎e‎p‎u‎b‎l‎i‎c‎a‎n‎ ‎p‎r‎e‎s‎i‎d‎e‎n‎t‎i‎a‎l‎ ‎n‎o‎m‎i‎n‎a‎t‎i‎o‎n‎ ‎d‎u‎r‎i‎n‎g‎ ‎t‎h‎e‎ ‎p‎r‎e‎v‎i‎o‎u‎s‎ ‎t‎w‎o‎ ‎e‎l‎e‎c‎t‎i‎o‎n‎s‎ ‎b‎e‎c‎a‎u‎s‎e‎ ‎o‎f‎ ‎t‎h‎e‎ ‎s‎t‎i‎g‎m‎a‎ ‎o‎f‎ ‎a‎ ‎s‎e‎t‎ ‎o‎f‎ ‎l‎e‎t‎t‎e‎r‎s‎ ‎t‎h‎a‎t‎ ‎h‎e‎ ‎h‎a‎d‎ ‎w‎r‎i‎t‎t‎e‎n‎,‎ ‎w‎h‎i‎l‎e‎ ‎C‎l‎e‎v‎e‎l‎a‎n‎d‎ ‎w‎a‎s‎ ‎p‎e‎r‎c‎e‎i‎v‎e‎d‎ ‎a‎s‎ ‎h‎a‎v‎i‎n‎g‎ ‎h‎i‎g‎h‎ ‎p‎e‎r‎s‎o‎n‎a‎l‎ ‎i‎n‎t‎e‎g‎r‎i‎t‎y‎.‎ ‎T‎h‎i‎s‎ ‎c‎a‎m‎p‎a‎i‎g‎n‎ ‎a‎d‎v‎e‎r‎t‎i‎s‎e‎m‎e‎n‎t‎ ‎f‎o‎r‎ ‎B‎l‎a‎i‎n‎e‎,‎ ‎c‎a‎p‎t‎i‎o‎n‎e‎d‎ ‎""‎A‎n‎o‎t‎h‎e‎r‎ ‎v‎o‎i‎c‎e‎ ‎f‎o‎r‎ ‎C‎l‎e‎v‎e‎l‎a‎n‎d‎""‎,‎ ‎w‎a‎s‎ ‎p‎u‎b‎l‎i‎s‎h‎e‎d‎ ‎i‎n‎ ‎t‎h‎e‎ ‎N‎e‎w‎ ‎Y‎o‎r‎k‎ ‎m‎a‎g‎a‎z‎i‎n‎e‎ ‎T‎h‎e‎ ‎J‎u‎d‎g‎e‎ ‎o‎n‎ ‎S‎e‎p‎t‎e‎m‎b‎e‎r‎ ‎2‎7‎,‎ ‎1‎8‎8‎4‎,‎ ‎a‎n‎d‎ ‎a‎i‎m‎e‎d‎ ‎t‎o‎ ‎s‎h‎i‎f‎t‎ ‎t‎h‎i‎s‎ ‎b‎a‎l‎a‎n‎c‎e‎ ‎a‎n‎d‎ ‎a‎t‎t‎a‎c‎k‎ ‎C‎l‎e‎v‎e‎l‎a‎n‎d‎'‎s‎ ‎m‎o‎r‎a‎l‎s‎ ‎b‎y‎ ‎a‎l‎l‎e‎g‎i‎n‎g‎ ‎t‎h‎a‎t‎ ‎h‎e‎ ‎h‎a‎d‎ ‎f‎a‎t‎h‎e‎r‎e‎d‎ ‎a‎n‎ ‎i‎l‎l‎e‎g‎i‎t‎i‎m‎a‎t‎e‎ ‎c‎h‎i‎l‎d‎ ‎w‎h‎i‎l‎e‎ ‎h‎e‎ ‎w‎a‎s‎ ‎a‎ ‎l‎a‎w‎y‎e‎r‎ ‎i‎n‎ ‎B‎u‎f‎f‎a‎l‎o‎,‎ ‎N‎e‎w‎ ‎Y‎o‎r‎k‎.‎ ‎T‎h‎e‎ ‎c‎h‎r‎o‎m‎o‎l‎i‎t‎h‎o‎g‎r‎a‎p‎h‎ ‎i‎l‎l‎u‎s‎t‎r‎a‎t‎i‎o‎n‎ ‎d‎e‎p‎i‎c‎t‎s‎ ‎a‎ ‎w‎e‎e‎p‎i‎n‎g‎ ‎w‎o‎m‎a‎n‎ ‎h‎o‎l‎d‎i‎n‎g‎ ‎a‎ ‎b‎a‎b‎y‎ ‎w‎h‎o‎ ‎c‎r‎i‎e‎s‎ ‎o‎u‎t‎ ‎""‎I‎ ‎w‎a‎n‎t‎ ‎m‎y‎ ‎p‎a‎!‎""‎ ‎a‎s‎ ‎C‎l‎e‎v‎e‎l‎a‎n‎d‎ ‎w‎a‎l‎k‎s‎ ‎p‎a‎s‎t‎.‎ ‎C‎l‎e‎v‎e‎l‎a‎n‎d‎'‎s‎ ‎c‎a‎m‎p‎a‎i‎g‎n‎ ‎r‎e‎s‎p‎o‎n‎d‎e‎d‎ ‎t‎h‎a‎t‎ ‎h‎e‎ ‎h‎a‎d‎ ‎f‎o‎r‎m‎e‎d‎ ‎a‎ ‎c‎o‎n‎n‎e‎c‎t‎i‎o‎n‎ ‎w‎i‎t‎h‎ ‎t‎h‎e‎ ‎w‎o‎m‎a‎n‎ ‎i‎n‎ ‎q‎u‎e‎s‎t‎i‎o‎n‎ ‎a‎n‎d‎ ‎h‎a‎d‎ ‎a‎s‎s‎u‎m‎e‎d‎ ‎r‎e‎s‎p‎o‎n‎s‎i‎b‎i‎l‎i‎t‎y‎ ‎f‎o‎r‎ ‎t‎h‎e‎ ‎c‎h‎i‎l‎d‎,‎ ‎b‎u‎t‎ ‎t‎h‎a‎t‎ ‎h‎i‎s‎ ‎p‎a‎t‎e‎r‎n‎i‎t‎y‎ ‎w‎a‎s‎ ‎u‎n‎p‎r‎o‎v‎e‎n‎.‎

I‎l‎l‎u‎s‎t‎r‎a‎t‎i‎o‎n‎ ‎c‎r‎e‎d‎i‎t‎:‎ ‎F‎r‎a‎n‎k‎ ‎B‎e‎a‎r‎d‎;‎ ‎r‎e‎s‎t‎o‎r‎e‎d‎ ‎b‎y‎ ‎A‎d‎a‎m‎ ‎C‎u‎e‎r‎d‎e‎n‎

.‎.‎.‎.‎.‎.‎

H‎e‎l‎l‎o‎!‎ ‎🧔🏾‍♂️️ ‎I‎ ‎a‎m‎ ‎a‎ ‎J‎u‎l‎i‎o‎ ‎t‎h‎e‎h‎ ‎s‎p‎e‎e‎k‎!‎ ‎A‎n‎ ‎j‎o‎o‎ ‎t‎h‎o‎u‎g‎h‎t‎ ‎d‎a‎t‎ ‎I‎ ‎w‎a‎s‎s‎n‎'‎t‎ ‎g‎o‎e‎e‎n‎g‎ ‎t‎o‎ ‎m‎b‎e‎e‎ ‎h‎e‎e‎y‎e‎r‎ ‎a‎t‎ ‎T‎h‎a‎n‎k‎s‎g‎e‎e‎v‎e‎e‎n‎g‎?‎ ‎W‎e‎l‎l‎ ‎j‎o‎o‎ ‎a‎r‎e‎ ‎w‎r‎o‎n‎g‎,‎ ‎A‎m‎i‎g‎o‎!‎ ‎I‎ ‎a‎m‎ ‎h‎e‎e‎y‎e‎r‎ ‎a‎n‎ ‎I‎ ‎h‎a‎v‎e‎ ‎m‎y‎ ‎o‎w‎n‎ ‎f‎l‎o‎a‎t‎,‎ ‎E‎e‎t‎ ‎e‎e‎s‎s‎ ‎a‎ ‎g‎i‎a‎n‎t‎ ‎b‎a‎l‎l‎o‎o‎n‎ ‎m‎a‎d‎e‎ ‎o‎u‎t‎ ‎o‎f‎ ‎m‎e‎e‎,‎ ‎a‎n‎ ‎I‎ ‎w‎e‎e‎l‎ ‎m‎b‎e‎e‎ ‎s‎e‎e‎n‎g‎e‎e‎n‎g‎ ‎w‎e‎e‎t‎h‎ ‎d‎e‎h‎ ‎m‎a‎r‎c‎h‎e‎e‎n‎g‎ ‎m‎b‎a‎n‎d‎ ‎o‎a‎n‎ ‎d‎e‎h‎ ‎w‎e‎e‎t‎h‎ ‎a‎ ‎m‎b‎o‎a‎n‎c‎h‎ ‎o‎f‎ ‎p‎o‎o‎p‎i‎n‎g‎ ‎t‎a‎w‎d‎l‎e‎r‎s‎s‎!‎ ‎💩💩👧🏼💩💩‎ ‎I‎ ‎d‎o‎n‎'‎t‎ ‎m‎e‎a‎n‎ ‎t‎o‎ ‎m‎b‎e‎e‎ ‎a‎ ‎p‎a‎r‎t‎y‎ ‎p‎o‎o‎p‎e‎r‎ ‎s‎e‎e‎n‎c‎e‎ ‎I‎ ‎a‎l‎r‎e‎a‎d‎y‎ ‎h‎a‎v‎e‎ ‎t‎a‎w‎d‎l‎e‎r‎s‎s‎ ‎d‎o‎e‎e‎n‎g‎ ‎i‎t‎ ‎f‎o‎r‎ ‎m‎e‎e‎!‎ ‎W‎h‎a‎t‎ ‎c‎a‎n‎ ‎I‎ ‎s‎a‎y‎,‎ ‎I‎ ‎a‎m‎ ‎a‎ ‎J‎u‎l‎i‎o‎ ‎t‎h‎e‎h‎ ‎s‎p‎e‎e‎k‎,‎ ‎a‎n‎d‎ ‎I‎ ‎l‎o‎a‎v‎ ‎a‎ ‎t‎h‎a‎ ‎p‎o‎o‎p‎i‎n‎g‎ ‎t‎a‎w‎d‎l‎e‎r‎s‎s‎!‎
A‎n‎d‎ ‎h‎e‎l‎l‎o‎!‎ ‎🤵🏻‍♂️‎️‎ ‎I‎'‎m‎ ‎A‎g‎e‎n‎t‎ ‎J‎o‎n‎e‎s‎!‎ ‎I‎ ‎w‎a‎s‎ ‎r‎e‎s‎c‎u‎e‎d‎ ‎a‎t‎ ‎f‎r‎o‎m‎ ‎t‎h‎e‎ ‎i‎s‎l‎a‎n‎d‎ ‎a‎t‎ ‎t‎h‎e‎ ‎l‎a‎s‎t‎ ‎m‎i‎n‎u‎t‎e‎!‎ ‎A‎n‎d‎ ‎I‎'‎m‎ ‎h‎e‎r‎e‎ ‎f‎o‎r‎ ‎t‎h‎e‎ ‎p‎a‎r‎a‎d‎e‎ ‎t‎o‎o‎!‎ ‎A‎n‎d‎ ‎w‎h‎e‎n‎ ‎T‎h‎a‎n‎k‎s‎g‎i‎v‎i‎n‎g‎ ‎i‎s‎ ‎o‎v‎e‎r‎,‎ ‎I‎'‎m‎ ‎g‎o‎i‎n‎g‎ ‎t‎o‎ ‎k‎i‎l‎l‎ ‎J‎u‎l‎i‎o‎ ‎t‎h‎e‎ ‎s‎p‎i‎c‎!‎"
2ubWuFa3,Method,307noodles,C++,Thursday 27th of November 2025 04:17:18 PM CDT,"Shared here:

pastebin.com/cQGpsb0w

Enjoy! 

#209210923"
T3YAu2Lz,Profit Guide,307noodles,C++,Thursday 27th of November 2025 04:13:04 PM CDT,"Posted here:
 
pastebin.com/cQGpsb0w
 
Enjoy! #23"
mzVxuUM9,Run,ElijahCrafter,Lua,Thursday 27th of November 2025 03:56:38 PM CDT,"print(""Download OS?"")
print(""This will remove current startup files!"")
print(""Y/N"")
local answer = io.read()
if answer == ""Y"" or ""y"" then
	shell.run(""delete startup"")
    print(""Downloading UI"")
	shell.run(""pastebin get ZXQYB6uT os/ui"")
    print(""Downloading Apps"")
	shell.run(""pastebin get 1NRE1zdq os/apps"")
    print(""Downloading main OS"")
    shell.run(""pastebin get JngeJTk2 os/desktop"")
    print(""Downloading startup"")
	shell.run(""pastebin get Vi6GyLDm startup"")
    print(""Main OS finished installing games:"")
    sleep(1)
    print(""Installing 2048"")
    shell.run(""pastebin get ZvSdaYnp os/games/2048"")
    print(""Installing Breakout"")
    shell.run(""pastebin get NSJ7AJ7r os/games/breakout"")
    print(""Installing Minesweeper"")
    shell.run(""pastebin get vqnbt3UP os/games/minesweeper"")
    print(""Installing Pong"")
    shell.run(""pastebin get gaW1yvQ6 os/games/pong"")
    print(""Installing Snake"")
    shell.run(""pastebin get 8mwrRq3H os/games/snake"")
    print(""Installing Tetris"")
    shell.run(""pastebin get Vj6ERfup os/games/tetris"")
    print(""Finished installing games"")
	sleep(1)
    print(""Rebooting"")
    sleep(2)
    shell.run(""reboot"")
else
    print(""Stopping setup"")
end
    "
1NRE1zdq,Apps,ElijahCrafter,Lua,Thursday 27th of November 2025 03:47:19 PM CDT,"-- Apps Management Module for SimpleOS

local apps = {}

-- Default apps storage
local appList = {}
local appsFile = ""os/data/apps.dat""

-- Default apps
local defaultApps = {
    {
        name = ""Shell"",
        symbol = "">"",
        command = ""shell""
    },
    {
        name = ""Files"",
        symbol = ""F"",
        command = ""list""
    },
    {
        name = ""Edit"",
        symbol = ""E"",
        command = ""edit""
    },
    {
        name = ""Lua"",
        symbol = ""L"",
        command = ""lua""
    },
    {
        name = ""Snake"",
        symbol = ""S"",
        command = ""os/games/snake""
    },
    {
        name = ""Tetris"",
        symbol = ""T"",
        command = ""os/games/tetris""
    },
    {
        name = ""Pong"",
        symbol = ""P"",
        command = ""os/games/pong""
    },
    {
        name = ""Mines"",
        symbol = ""M"",
        command = ""os/games/minesweeper""
    },
    {
        name = ""2048"",
        symbol = ""2"",
        command = ""os/games/2048""
    },
    {
        name = ""Breakou"",
        symbol = ""B"",
        command = ""os/games/breakout""
    },
}

-- Ensure data directory exists
local function ensureDataDir()
    if not fs.exists(""os/data"") then
        fs.makeDir(""os/data"")
    end
end

-- Load apps from file
function apps.load()
    ensureDataDir()
    if fs.exists(appsFile) then
        local file = fs.open(appsFile, ""r"")
        if file then
            local content = file.readAll()
            file.close()
            local loaded = textutils.unserialize(content)
            if loaded then
                appList = loaded
                return
            end
        end
    end
    -- Use defaults if no saved apps
    appList = defaultApps
    apps.save()
end

-- Save apps to file
function apps.save()
    ensureDataDir()
    local file = fs.open(appsFile, ""w"")
    if file then
        file.write(textutils.serialize(appList))
        file.close()
    end
end

-- Get all apps
function apps.getAll()
    return appList
end

-- Add a new app
function apps.add(name, symbol, command)
    table.insert(appList, {
        name = name,
        symbol = symbol or ""#"",
        command = command
    })
    apps.save()
end

-- Remove an app by index
function apps.remove(index)
    if index > 0 and index <= #appList then
        table.remove(appList, index)
        apps.save()
        return true
    end
    return false
end

-- Edit an app
function apps.edit(index, name, symbol, command)
    if index > 0 and index <= #appList then
        appList[index].name = name or appList[index].name
        appList[index].symbol = symbol or appList[index].symbol
        appList[index].command = command or appList[index].command
        apps.save()
        return true
    end
    return false
end

-- Run an app
function apps.run(index)
    if index > 0 and index <= #appList then
        local app = appList[index]
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        term.setCursorPos(1, 1)
        
        -- Run the command
        shell.run(app.command)
        
        -- Wait for key press to return
        print()
        print(""Press any key to return to desktop..."")
        os.pullEvent(""key"")
        return true
    end
    return false
end

-- Get app count
function apps.count()
    return #appList
end

-- Get app by index
function apps.get(index)
    return appList[index]
end

return apps
"
