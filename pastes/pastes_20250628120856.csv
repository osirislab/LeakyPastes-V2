id,title,username,language,date,content
2Ca1uBr3,Nicee,prog3r,C++,Saturday 28th of June 2025 07:00:48 AM CDT,"//#include ""testlib.h""
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define int long long
#define YES(x) cout << (x?""YES\n"":""NO\n"")
#define NO(x) cout << (x?""NO\n"":""YES\n"")
#ifdef LO
#pragma GCC optimize(""trapv"")
#endif
#ifndef LO
#pragma GCC optimize(""Ofast,unroll-loops"")
#endif
//constexpr int MOD = (119<<23)+1;
//constexpr int MOD = 967276608647009887ll;
//constexpr int MOD = 1e9+7;
constexpr int INF = 1e18;
signed main() {
#ifndef LO
    clog << ""FIO\n"";
    ios::sync_with_stdio(0);
    cin.tie(0);
#endif
#ifdef LO
    cout << unitbuf;
#endif
    auto fenw_ops = [&] (const int x) -> int {
        if (x <= 1) {
            assert(false);
        }
        return __lg(x-1)+2;
    };
    int N = 1000;
    vector<int> dp(N+1);
    dp[0] = 0;
    dp[1] = 1;
    vector<pair<int,int>> ch(N+1);
    vector<int> palka(N+1);
    for (int i = 2; i <= N; i += 1) {
        for (int use = 1; use <= i; use += 1) {
            for (int one = 0; i-use-one >= one; one += 1) {
                int another = i-use-one;
                if (!one) {
                    int x = dp[another];
                    if (dp[i] < x) {
                        ch[i] = {one, another};
                        palka[i] = use;
                    }
                    dp[i] = max(dp[i], x);
                } else {
                    int x = min({max(dp[one]+1, dp[another]+1),
                                 max(dp[one]+min(use, fenw_ops(use+1)), dp[another]+0),
                                 max(dp[one]+0, dp[another]+min(use, fenw_ops(use+1)))});
                    if (dp[i] < x) {
                        ch[i] = {one, another};
                        palka[i] = use;
                    }
                    dp[i] = max(dp[i], x);
                }
            }
        }
        cout << ""("" << i << "", "" << dp[i] << "")\n"";
//        cout << ""("" << i << "", "" << dp[i] << "" "" << ch[i].first << ""|"" << dp[ch[i].first] << "" "" << ch[i].second << ""|"" << dp[ch[i].second] << ""), "" << palka[i] << ""\n"";
    }
    int curr = 1;
    auto print = [&] (auto f, const int x) -> int {
        if (!x) {
            return -1;
        }
        int U = curr++;
        int u = U;
        for (int i = 0; i < palka[x]-1; i += 1) {
            int v = curr++;
            cout << u << "" "" << v << ""\n"";
            u = v;
        }
        int v1 = f(f, ch[x].first), v2 = f(f, ch[x].second);
        if (v1 != -1) {
            cout << u << "" "" << v1 << ""\n"";
        }
        if (v2 != -1) {
            cout << u << "" "" << v2 << ""\n"";
        }
        return U;
    };
//    print(print, N);

}"
F0M6hVkM,?Make 1500$ in 1 day [Method]? 3S,Wakandaforever222425,Java,Saturday 28th of June 2025 06:59:30 AM CDT," 
>EBOOK<
LATEST(TESTED TODAY)>https://www.dropbox.com/scl/fi/0diu5qpna89bwhnhlowx1/updated.pdf?rlkey=sqpmxd0e3k9c9blkymmta9dnp&e=1&st=q8hj7c9a&dl=0

0UhcD"
BR0fQz1q,????Hadez Method Leaked???? TC,Wakandaforever222425,Java,Saturday 28th of June 2025 06:49:29 AM CDT," 
>EBOOK<
LATEST(TESTED TODAY)>https://www.dropbox.com/scl/fi/qulaxq261ytn9nv3c2v92/25.pdf?rlkey=3c55euf9y4xgau0cmm0jgarr3&e=1&st=w14aigmk

3ajSi"
TTLVa9pC,????Hadez Method Leaked???? TC,NoobyNoob_Ani,Java,Saturday 28th of June 2025 06:45:20 AM CDT," 
>EBOOK<
LATEST(TESTED TODAY)>https://www.dropbox.com/scl/fi/0diu5qpna89bwhnhlowx1/updated.pdf?rlkey=sqpmxd0e3k9c9blkymmta9dnp&e=1&st=q8hj7c9a&dl=0

I5P5d"
CMQjn9Ba,?FREE Method Leaked? 1Y,BrickSattle,Java,Saturday 28th of June 2025 06:36:49 AM CDT," 
>EBOOK<
LATEST(TESTED TODAY)>https://www.dropbox.com/scl/fi/xl44h93qc3pk3jg3bi2o3/newtut.pdf?rlkey=vz7t26ii3mbboa6tl02qfyu9e&e=1&st=dbi6jq6f

eYoRo"
LwJhjBDd,?FREE Method Leaked? 1Y,NoobyNoob_Ani,Java,Saturday 28th of June 2025 06:35:18 AM CDT," 
>EBOOK<
LATEST(TESTED TODAY)>https://www.dropbox.com/scl/fi/0diu5qpna89bwhnhlowx1/updated.pdf?rlkey=sqpmxd0e3k9c9blkymmta9dnp&e=1&st=q8hj7c9a&dl=0

C5oQN"
VDUbegTb,?Make $200 INSTANTLY [Works Worldwide]? ZA,NoobyNoob_Ani,Java,Saturday 28th of June 2025 06:25:17 AM CDT," 
>EBOOK<
LATEST(TESTED TODAY)>https://www.dropbox.com/scl/fi/qulaxq261ytn9nv3c2v92/25.pdf?rlkey=3c55euf9y4xgau0cmm0jgarr3&e=1&st=w14aigmk

TJ8dE"
FeaBpEeL,Untitled,gandalfbialy,Python,Saturday 28th of June 2025 06:18:46 AM CDT,"from pathlib import Path
from PIL import Image, ImageOps

#Pętla przechodzi przez wszystkie pliki z rozszerzeniem .png w pliku 'testowe'
#Obrazy są wczytywane w skali szarości .convert('L')
#A następnie tworzony jest negatyw - białe pismo na czarnym tle, tak jak w zbiorze uczącym, wbrew znaczeniom robi to różnicę i upewniamy się że dane maja odpowiedni wymiar i są znormalizowane
for path in Path(""testowe"").rglob(""*.png""):
  image = Image.open(path).convert('L')
  image = ImageOps.invert(image)
  image = image.resize((28, 28))
  image = np.array(image).reshape(1, 28, 28, 1) / 255.0

#Wyświetlamy obraz
  plt.imshow(image.reshape(28, 28), cmap='gray')
  plt.title('Przetworzony obraz')
  plt.show()

  prediction = model.predict(image)[0]
  top3_indices = np.argsort(prediction)[-3:][::-1]
  top3_probs = prediction[top3_indices]
  print(""Top 3 rozpoznane cyfry:"")
  for i, (label, prob) in enumerate(zip(top3_indices, top3_probs), 1):
	  print(f""{i}. Cyfra: {label}, Prawdopodobieństwo: {prob:.4f}"")

#Oraz dokoujemy prognozy i ją wyświetlamy
  prediction = model.predict(image)
  digit = np.argmax(prediction)
  print(f""Rozpoznana cyfra: {digit}"")"
84UqnGrH,?Make 1500$ in 1 day [Method]? MA,NoobyNoob_Ani,Java,Saturday 28th of June 2025 06:15:15 AM CDT," 
>EBOOK<
LATEST(TESTED TODAY)>https://www.dropbox.com/scl/fi/qulaxq261ytn9nv3c2v92/25.pdf?rlkey=3c55euf9y4xgau0cmm0jgarr3&e=1&st=w14aigmk&dl=0

e2oRB"
aZGBhkr6,dataNone,TestGuy1,JSON,Saturday 28th of June 2025 06:00:09 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'f81e24cf7794023a548b28c0eac2ce97b11e778c70639fb38e8dde187e9d0dd3f80a8f8fc3856975e95b3e276ebdfbeb381b882b601036a54a476090f2fc3db29e3eb2bf8babf2fdf98f1faf6ad03a5c9268e9ed3793aeb6e00621048408afac0550122d8664abf340e8c096fc4d0f8aac67b6120b1c2527ed2dc9ce49bf4705',
  otherdata: [
    'faa713340bbe2a345801261582c057ba',
    'd6753a0177f3cb6310e232008194c2ca',
    'c1b332f85eb2db917f9180590fe7460f',
    '0495eabc40e5ddc6bf66de4c48237333',
    '3745b3e5e79c9129e3b3dc7a3ae8a074',
    'ff26e5470e6c6af7f3d9e5a9d7a8062d',
    '336ececf414a8bc15dc1e0bd1ad9f0a8',
    'fda126256f40d24720054fc967991954'
  ]
}"
iAcVBeNv,Untitled,DarveL,PHP,Saturday 28th of June 2025 06:00:09 AM CDT,"""!ur$|gen|tal d|o al|non|f bur"""
Vn3kz51P,Serverme,ohoviewx99,C#,Saturday 28th of June 2025 05:39:14 AM CDT,S-1-5-21-1930596511-576219338-3601084200-1001   // my
yP03u4uX,2025-06-28T12:21:19.987,powerampache,PHP,Saturday 28th of June 2025 05:21:21 AM CDT,"1.01-76 (76) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
e9gDDyfj,rarreg.key,ney2x,Perl,Saturday 28th of June 2025 04:30:54 AM CDT,"RAR registration data
Arnellord Bondoc
drollenra@gmail.com
UID=363ac77bd1e69954dfda
6412212250dfdad49ba62f64ca14d167feffee79f0850921e68882
c43cf1ae8d997aec88e1600b17c841231986f96c243ddf4d851275
2626c40ea1149e02e66a1c90e0f5d797cff5f9e7dd701305d3a854
61ee5140fa80ab6ed6964f5d13bf2be3cb6054aa427f4dd3ce9fdb
b388d063e3d4b850371d4a823abe55947bd66f098fb5607c4d08dd
4776ee63054557896ee7627055049dd0946fd6406aace5c46096fe
615c2dbaab931c640690d5ca5f965455fe06723d2bf71387723369"
AbhPNHUv,ovoo-v3.4,s4m33r789,SQL,Saturday 28th of June 2025 03:45:59 AM CDT,"-- phpMyAdmin SQL Dump
-- version 5.1.0
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1
-- Generation Time: Oct 23, 2023 at 02:14 PM
-- Server version: 10.4.18-MariaDB
-- PHP Version: 8.0.3

SET SQL_MODE = ""NO_AUTO_VALUE_ON_ZERO"";
START TRANSACTION;
SET time_zone = ""+00:00"";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `ovoo_340`
--

-- --------------------------------------------------------

--
-- Table structure for table `ads`
--

CREATE TABLE `ads` (
  `ads_id` int(11) NOT NULL,
  `ads_name` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `unique_name` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `ads_size` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `ads_type` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `ads_url` mediumtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `ads_image_url` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `ads_code` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `enable` int(1) DEFAULT 0
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `ads`
--

INSERT INTO `ads` (`ads_id`, `ads_name`, `unique_name`, `ads_size`, `ads_type`, `ads_url`, `ads_image_url`, `ads_code`, `enable`) VALUES
(1, 'Home Page Header', 'home_header', '728x90', 'code', '#', '', '', 0),
(2, 'Movie Page Header', 'movie_header', '728x90', 'code', '#', '', '', 0),
(3, 'Genre Page Header', 'genre_header', '728x90', 'code', '#', '', '', 0),
(4, 'Country Page Header', 'country_header', '728x90', 'code', '#', '', '', 0),
(5, 'Release Page Header', 'release_header', '728x90', 'code', '#', '', '', 0),
(6, 'TV-series Page Header', 'tv_header', '728x90', 'code', '#', '', '', 0),
(7, 'Type Page Header', 'type_header', '728x90', 'code', '#', '', '', 0),
(8, 'Blog Page Header', 'blog_header', '728x90', 'code', '#', '', '', 0),
(9, 'Sidebar', 'sidebar', '300x600', 'code', '#', '', '', 0),
(12, 'Player Bottom', 'player_bottom', '728x90', 'code', '#', '', '', 0),
(10, 'Player Top', 'player_top', '728x90', 'code', '#', '', '', 0),
(11, 'Billboard(For movie,Landing page & watch page)', 'billboard', '970x250', 'code', '#', '', '', 0);

-- --------------------------------------------------------

--
-- Table structure for table `calendar`
--

CREATE TABLE `calendar` (
  `country_code` char(2) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `coordinates` char(15) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `timezone` char(32) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `comments` varchar(85) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `utc_offset` char(8) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `utc_dst_offset` char(8) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `notes` varchar(79) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `calendar`
--

INSERT INTO `calendar` (`country_code`, `coordinates`, `timezone`, `comments`, `utc_offset`, `utc_dst_offset`, `notes`) VALUES
('CI', '+0519-00402', 'Africa/Abidjan', '', '+00:00', '+00:00', ''),
('GH', '+0533-00013', 'Africa/Accra', '', '+00:00', '+00:00', ''),
('ET', '+0902+03842', 'Africa/Addis_Ababa', '', '+03:00', '+03:00', ''),
('DZ', '+3647+00303', 'Africa/Algiers', '', '+01:00', '+01:00', ''),
('ER', '+1520+03853', 'Africa/Asmara', '', '+03:00', '+03:00', ''),
('', '', 'Africa/Asmera', '', '+03:00', '+03:00', 'Link to Africa/Asmara'),
('ML', '+1239-00800', 'Africa/Bamako', '', '+00:00', '+00:00', ''),
('CF', '+0422+01835', 'Africa/Bangui', '', '+01:00', '+01:00', ''),
('GM', '+1328-01639', 'Africa/Banjul', '', '+00:00', '+00:00', ''),
('GW', '+1151-01535', 'Africa/Bissau', '', '+00:00', '+00:00', ''),
('MW', '-1547+03500', 'Africa/Blantyre', '', '+02:00', '+02:00', ''),
('CG', '-0416+01517', 'Africa/Brazzaville', '', '+01:00', '+01:00', ''),
('BI', '-0323+02922', 'Africa/Bujumbura', '', '+02:00', '+02:00', ''),
('EG', '+3003+03115', 'Africa/Cairo', '', '+02:00', '+02:00', 'DST has been canceled since 2011'),
('MA', '+3339-00735', 'Africa/Casablanca', '', '+00:00', '+01:00', ''),
('ES', '+3553-00519', 'Africa/Ceuta', 'Ceuta & Melilla', '+01:00', '+02:00', ''),
('GN', '+0931-01343', 'Africa/Conakry', '', '+00:00', '+00:00', ''),
('SN', '+1440-01726', 'Africa/Dakar', '', '+00:00', '+00:00', ''),
('TZ', '-0648+03917', 'Africa/Dar_es_Salaam', '', '+03:00', '+03:00', ''),
('DJ', '+1136+04309', 'Africa/Djibouti', '', '+03:00', '+03:00', ''),
('CM', '+0403+00942', 'Africa/Douala', '', '+01:00', '+01:00', ''),
('EH', '+2709-01312', 'Africa/El_Aaiun', '', '+00:00', '+00:00', ''),
('SL', '+0830-01315', 'Africa/Freetown', '', '+00:00', '+00:00', ''),
('BW', '-2439+02555', 'Africa/Gaborone', '', '+02:00', '+02:00', ''),
('ZW', '-1750+03103', 'Africa/Harare', '', '+02:00', '+02:00', ''),
('ZA', '-2615+02800', 'Africa/Johannesburg', '', '+02:00', '+02:00', ''),
('SS', '+0451+03136', 'Africa/Juba', '', '+03:00', '+03:00', ''),
('UG', '+0019+03225', 'Africa/Kampala', '', '+03:00', '+03:00', ''),
('SD', '+1536+03232', 'Africa/Khartoum', '', '+03:00', '+03:00', ''),
('RW', '-0157+03004', 'Africa/Kigali', '', '+02:00', '+02:00', ''),
('CD', '-0418+01518', 'Africa/Kinshasa', 'west Dem. Rep. of Congo', '+01:00', '+01:00', ''),
('NG', '+0627+00324', 'Africa/Lagos', '', '+01:00', '+01:00', ''),
('GA', '+0023+00927', 'Africa/Libreville', '', '+01:00', '+01:00', ''),
('TG', '+0608+00113', 'Africa/Lome', '', '+00:00', '+00:00', ''),
('AO', '-0848+01314', 'Africa/Luanda', '', '+01:00', '+01:00', ''),
('CD', '-1140+02728', 'Africa/Lubumbashi', 'east Dem. Rep. of Congo', '+02:00', '+02:00', ''),
('ZM', '-1525+02817', 'Africa/Lusaka', '', '+02:00', '+02:00', ''),
('GQ', '+0345+00847', 'Africa/Malabo', '', '+01:00', '+01:00', ''),
('MZ', '-2558+03235', 'Africa/Maputo', '', '+02:00', '+02:00', ''),
('LS', '-2928+02730', 'Africa/Maseru', '', '+02:00', '+02:00', ''),
('SZ', '-2618+03106', 'Africa/Mbabane', '', '+02:00', '+02:00', ''),
('SO', '+0204+04522', 'Africa/Mogadishu', '', '+03:00', '+03:00', ''),
('LR', '+0618-01047', 'Africa/Monrovia', '', '+00:00', '+00:00', ''),
('KE', '-0117+03649', 'Africa/Nairobi', '', '+03:00', '+03:00', ''),
('TD', '+1207+01503', 'Africa/Ndjamena', '', '+01:00', '+01:00', ''),
('NE', '+1331+00207', 'Africa/Niamey', '', '+01:00', '+01:00', ''),
('MR', '+1806-01557', 'Africa/Nouakchott', '', '+00:00', '+00:00', ''),
('BF', '+1222-00131', 'Africa/Ouagadougou', '', '+00:00', '+00:00', ''),
('BJ', '+0629+00237', 'Africa/Porto-Novo', '', '+01:00', '+01:00', ''),
('ST', '+0020+00644', 'Africa/Sao_Tome', '', '+00:00', '+00:00', ''),
('', '', 'Africa/Timbuktu', '', '+00:00', '+00:00', 'Link to Africa/Bamako'),
('LY', '+3254+01311', 'Africa/Tripoli', '', '+01:00', '+02:00', ''),
('TN', '+3648+01011', 'Africa/Tunis', '', '+01:00', '+01:00', ''),
('NA', '-2234+01706', 'Africa/Windhoek', '', '+01:00', '+02:00', ''),
('', '', 'AKST9AKDT', '', 'âˆ’09:00', 'âˆ’08:00', 'Link to America/Anchorage'),
('US', '+515248-1763929', 'America/Adak', 'Aleutian Islands', 'âˆ’10:00', 'âˆ’09:00', ''),
('US', '+611305-1495401', 'America/Anchorage', 'Alaska Time', 'âˆ’09:00', 'âˆ’08:00', ''),
('AI', '+1812-06304', 'America/Anguilla', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('AG', '+1703-06148', 'America/Antigua', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('BR', '-0712-04812', 'America/Araguaina', 'Tocantins', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-3436-05827', 'America/Argentina/Buenos_Aires', 'Buenos Aires (BA, CF)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-2828-06547', 'America/Argentina/Catamarca', 'Catamarca (CT), Chubut (CH)', 'âˆ’03:00', 'âˆ’03:00', ''),
('', '', 'America/Argentina/ComodRivadavia', '', 'âˆ’03:00', 'âˆ’03:00', 'Link to America/Argentina/Catamarca'),
('AR', '-3124-06411', 'America/Argentina/Cordoba', 'most locations (CB, CC, CN, ER, FM, MN, SE, SF)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-2411-06518', 'America/Argentina/Jujuy', 'Jujuy (JY)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-2926-06651', 'America/Argentina/La_Rioja', 'La Rioja (LR)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-3253-06849', 'America/Argentina/Mendoza', 'Mendoza (MZ)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-5138-06913', 'America/Argentina/Rio_Gallegos', 'Santa Cruz (SC)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-2447-06525', 'America/Argentina/Salta', '(SA, LP, NQ, RN)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-3132-06831', 'America/Argentina/San_Juan', 'San Juan (SJ)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-3319-06621', 'America/Argentina/San_Luis', 'San Luis (SL)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-2649-06513', 'America/Argentina/Tucuman', 'Tucuman (TM)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AR', '-5448-06818', 'America/Argentina/Ushuaia', 'Tierra del Fuego (TF)', 'âˆ’03:00', 'âˆ’03:00', ''),
('AW', '+1230-06958', 'America/Aruba', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('PY', '-2516-05740', 'America/Asuncion', '', 'âˆ’04:00', 'âˆ’03:00', ''),
('CA', '+484531-0913718', 'America/Atikokan', 'Eastern Standard Time - Atikokan, Ontario and Southampton I, Nunavut', 'âˆ’05:00', 'âˆ’05:00', ''),
('', '', 'America/Atka', '', 'âˆ’10:00', 'âˆ’09:00', 'Link to America/Adak'),
('BR', '-1259-03831', 'America/Bahia', 'Bahia', 'âˆ’03:00', 'âˆ’03:00', ''),
('MX', '+2048-10515', 'America/Bahia_Banderas', 'Mexican Central Time - Bahia de Banderas', 'âˆ’06:00', 'âˆ’05:00', ''),
('BB', '+1306-05937', 'America/Barbados', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('BR', '-0127-04829', 'America/Belem', 'Amapa, E Para', 'âˆ’03:00', 'âˆ’03:00', ''),
('BZ', '+1730-08812', 'America/Belize', '', 'âˆ’06:00', 'âˆ’06:00', ''),
('CA', '+5125-05707', 'America/Blanc-Sablon', 'Atlantic Standard Time - Quebec - Lower North Shore', 'âˆ’04:00', 'âˆ’04:00', ''),
('BR', '+0249-06040', 'America/Boa_Vista', 'Roraima', 'âˆ’04:00', 'âˆ’04:00', ''),
('CO', '+0436-07405', 'America/Bogota', '', 'âˆ’05:00', 'âˆ’05:00', ''),
('US', '+433649-1161209', 'America/Boise', 'Mountain Time - south Idaho & east Oregon', 'âˆ’07:00', 'âˆ’06:00', ''),
('', '', 'America/Buenos_Aires', '', 'âˆ’03:00', 'âˆ’03:00', 'Link to America/Argentina/Buenos_Aires'),
('CA', '+690650-1050310', 'America/Cambridge_Bay', 'Mountain Time - west Nunavut', 'âˆ’07:00', 'âˆ’06:00', ''),
('BR', '-2027-05437', 'America/Campo_Grande', 'Mato Grosso do Sul', 'âˆ’04:00', 'âˆ’03:00', ''),
('MX', '+2105-08646', 'America/Cancun', 'Central Time - Quintana Roo', 'âˆ’06:00', 'âˆ’05:00', ''),
('VE', '+1030-06656', 'America/Caracas', '', 'âˆ’04:30', 'âˆ’04:30', ''),
('', '', 'America/Catamarca', '', 'âˆ’03:00', 'âˆ’03:00', 'Link to America/Argentina/Catamarca'),
('GF', '+0456-05220', 'America/Cayenne', '', 'âˆ’03:00', 'âˆ’03:00', ''),
('KY', '+1918-08123', 'America/Cayman', '', 'âˆ’05:00', 'âˆ’05:00', ''),
('US', '+415100-0873900', 'America/Chicago', 'Central Time', 'âˆ’06:00', 'âˆ’05:00', ''),
('MX', '+2838-10605', 'America/Chihuahua', 'Mexican Mountain Time - Chihuahua away from US border', 'âˆ’07:00', 'âˆ’06:00', ''),
('', '', 'America/Coral_Harbour', '', 'âˆ’05:00', 'âˆ’05:00', 'Link to America/Atikokan'),
('', '', 'America/Cordoba', '', 'âˆ’03:00', 'âˆ’03:00', 'Link to America/Argentina/Cordoba'),
('CR', '+0956-08405', 'America/Costa_Rica', '', 'âˆ’06:00', 'âˆ’06:00', ''),
('CA', '+4906-11631', 'America/Creston', 'Mountain Standard Time - Creston, British Columbia', 'âˆ’07:00', 'âˆ’07:00', ''),
('BR', '-1535-05605', 'America/Cuiaba', 'Mato Grosso', 'âˆ’04:00', 'âˆ’03:00', ''),
('CW', '+1211-06900', 'America/Curacao', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('GL', '+7646-01840', 'America/Danmarkshavn', 'east coast, north of Scoresbysund', '+00:00', '+00:00', ''),
('CA', '+6404-13925', 'America/Dawson', 'Pacific Time - north Yukon', 'âˆ’08:00', 'âˆ’07:00', ''),
('CA', '+5946-12014', 'America/Dawson_Creek', 'Mountain Standard Time - Dawson Creek & Fort Saint John, British Columbia', 'âˆ’07:00', 'âˆ’07:00', ''),
('US', '+394421-1045903', 'America/Denver', 'Mountain Time', 'âˆ’07:00', 'âˆ’06:00', ''),
('US', '+421953-0830245', 'America/Detroit', 'Eastern Time - Michigan - most locations', 'âˆ’05:00', 'âˆ’04:00', ''),
('DM', '+1518-06124', 'America/Dominica', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('CA', '+5333-11328', 'America/Edmonton', 'Mountain Time - Alberta, east British Columbia & west Saskatchewan', 'âˆ’07:00', 'âˆ’06:00', ''),
('BR', '-0640-06952', 'America/Eirunepe', 'W Amazonas', 'âˆ’04:00', 'âˆ’04:00', ''),
('SV', '+1342-08912', 'America/El_Salvador', '', 'âˆ’06:00', 'âˆ’06:00', ''),
('', '', 'America/Ensenada', '', 'âˆ’08:00', 'âˆ’07:00', 'Link to America/Tijuana'),
('', '', 'America/Fort_Wayne', '', 'âˆ’05:00', 'âˆ’04:00', 'Link to America/Indiana/Indianapolis'),
('BR', '-0343-03830', 'America/Fortaleza', 'NE Brazil (MA, PI, CE, RN, PB)', 'âˆ’03:00', 'âˆ’03:00', ''),
('CA', '+4612-05957', 'America/Glace_Bay', 'Atlantic Time - Nova Scotia - places that did not observe DST 1966-1971', 'âˆ’04:00', 'âˆ’03:00', ''),
('GL', '+6411-05144', 'America/Godthab', 'most locations', 'âˆ’03:00', 'âˆ’02:00', ''),
('CA', '+5320-06025', 'America/Goose_Bay', 'Atlantic Time - Labrador - most locations', 'âˆ’04:00', 'âˆ’03:00', ''),
('TC', '+2128-07108', 'America/Grand_Turk', '', 'âˆ’05:00', 'âˆ’04:00', ''),
('GD', '+1203-06145', 'America/Grenada', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('GP', '+1614-06132', 'America/Guadeloupe', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('GT', '+1438-09031', 'America/Guatemala', '', 'âˆ’06:00', 'âˆ’06:00', ''),
('EC', '-0210-07950', 'America/Guayaquil', 'mainland', 'âˆ’05:00', 'âˆ’05:00', ''),
('GY', '+0648-05810', 'America/Guyana', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('CA', '+4439-06336', 'America/Halifax', 'Atlantic Time - Nova Scotia (most places), PEI', 'âˆ’04:00', 'âˆ’03:00', ''),
('CU', '+2308-08222', 'America/Havana', '', 'âˆ’05:00', 'âˆ’04:00', ''),
('MX', '+2904-11058', 'America/Hermosillo', 'Mountain Standard Time - Sonora', 'âˆ’07:00', 'âˆ’07:00', ''),
('US', '+394606-0860929', 'America/Indiana/Indianapolis', 'Eastern Time - Indiana - most locations', 'âˆ’05:00', 'âˆ’04:00', ''),
('US', '+411745-0863730', 'America/Indiana/Knox', 'Central Time - Indiana - Starke County', 'âˆ’06:00', 'âˆ’05:00', ''),
('US', '+382232-0862041', 'America/Indiana/Marengo', 'Eastern Time - Indiana - Crawford County', 'âˆ’05:00', 'âˆ’04:00', ''),
('US', '+382931-0871643', 'America/Indiana/Petersburg', 'Eastern Time - Indiana - Pike County', 'âˆ’05:00', 'âˆ’04:00', ''),
('US', '+375711-0864541', 'America/Indiana/Tell_City', 'Central Time - Indiana - Perry County', 'âˆ’06:00', 'âˆ’05:00', ''),
('US', '+384452-0850402', 'America/Indiana/Vevay', 'Eastern Time - Indiana - Switzerland County', 'âˆ’05:00', 'âˆ’04:00', ''),
('US', '+384038-0873143', 'America/Indiana/Vincennes', 'Eastern Time - Indiana - Daviess, Dubois, Knox & Martin Counties', 'âˆ’05:00', 'âˆ’04:00', ''),
('US', '+410305-0863611', 'America/Indiana/Winamac', 'Eastern Time - Indiana - Pulaski County', 'âˆ’05:00', 'âˆ’04:00', ''),
('', '', 'America/Indianapolis', '', 'âˆ’05:00', 'âˆ’04:00', 'Link to America/Indiana/Indianapolis'),
('CA', '+682059-1334300', 'America/Inuvik', 'Mountain Time - west Northwest Territories', 'âˆ’07:00', 'âˆ’06:00', ''),
('CA', '+6344-06828', 'America/Iqaluit', 'Eastern Time - east Nunavut - most locations', 'âˆ’05:00', 'âˆ’04:00', ''),
('JM', '+1800-07648', 'America/Jamaica', '', 'âˆ’05:00', 'âˆ’05:00', ''),
('', '', 'America/Jujuy', '', 'âˆ’03:00', 'âˆ’03:00', 'Link to America/Argentina/Jujuy'),
('US', '+581807-1342511', 'America/Juneau', 'Alaska Time - Alaska panhandle', 'âˆ’09:00', 'âˆ’08:00', ''),
('US', '+381515-0854534', 'America/Kentucky/Louisville', 'Eastern Time - Kentucky - Louisville area', 'âˆ’05:00', 'âˆ’04:00', ''),
('US', '+364947-0845057', 'America/Kentucky/Monticello', 'Eastern Time - Kentucky - Wayne County', 'âˆ’05:00', 'âˆ’04:00', ''),
('', '', 'America/Knox_IN', '', 'âˆ’06:00', 'âˆ’05:00', 'Link to America/Indiana/Knox'),
('BQ', '+120903-0681636', 'America/Kralendijk', '', 'âˆ’04:00', 'âˆ’04:00', 'Link to America/Curacao'),
('BO', '-1630-06809', 'America/La_Paz', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('PE', '-1203-07703', 'America/Lima', '', 'âˆ’05:00', 'âˆ’05:00', ''),
('US', '+340308-1181434', 'America/Los_Angeles', 'Pacific Time', 'âˆ’08:00', 'âˆ’07:00', ''),
('', '', 'America/Louisville', '', 'âˆ’05:00', 'âˆ’04:00', 'Link to America/Kentucky/Louisville'),
('SX', '+180305-0630250', 'America/Lower_Princes', '', 'âˆ’04:00', 'âˆ’04:00', 'Link to America/Curacao'),
('BR', '-0940-03543', 'America/Maceio', 'Alagoas, Sergipe', 'âˆ’03:00', 'âˆ’03:00', ''),
('NI', '+1209-08617', 'America/Managua', '', 'âˆ’06:00', 'âˆ’06:00', ''),
('BR', '-0308-06001', 'America/Manaus', 'E Amazonas', 'âˆ’04:00', 'âˆ’04:00', ''),
('MF', '+1804-06305', 'America/Marigot', '', 'âˆ’04:00', 'âˆ’04:00', 'Link to America/Guadeloupe'),
('MQ', '+1436-06105', 'America/Martinique', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('MX', '+2550-09730', 'America/Matamoros', 'US Central Time - Coahuila, Durango, Nuevo LeÃ³n, Tamaulipas near US border', 'âˆ’06:00', 'âˆ’05:00', ''),
('MX', '+2313-10625', 'America/Mazatlan', 'Mountain Time - S Baja, Nayarit, Sinaloa', 'âˆ’07:00', 'âˆ’06:00', ''),
('', '', 'America/Mendoza', '', 'âˆ’03:00', 'âˆ’03:00', 'Link to America/Argentina/Mendoza'),
('US', '+450628-0873651', 'America/Menominee', 'Central Time - Michigan - Dickinson, Gogebic, Iron & Menominee Counties', 'âˆ’06:00', 'âˆ’05:00', ''),
('MX', '+2058-08937', 'America/Merida', 'Central Time - Campeche, YucatÃ¡n', 'âˆ’06:00', 'âˆ’05:00', ''),
('US', '+550737-1313435', 'America/Metlakatla', 'Metlakatla Time - Annette Island', 'âˆ’08:00', 'âˆ’08:00', ''),
('MX', '+1924-09909', 'America/Mexico_City', 'Central Time - most locations', 'âˆ’06:00', 'âˆ’05:00', ''),
('PM', '+4703-05620', 'America/Miquelon', '', 'âˆ’03:00', 'âˆ’02:00', ''),
('CA', '+4606-06447', 'America/Moncton', 'Atlantic Time - New Brunswick', 'âˆ’04:00', 'âˆ’03:00', ''),
('MX', '+2540-10019', 'America/Monterrey', 'Mexican Central Time - Coahuila, Durango, Nuevo LeÃ³n, Tamaulipas away from US border', 'âˆ’06:00', 'âˆ’05:00', ''),
('UY', '-3453-05611', 'America/Montevideo', '', 'âˆ’03:00', 'âˆ’02:00', ''),
('CA', '+4531-07334', 'America/Montreal', 'Eastern Time - Quebec - most locations', 'âˆ’05:00', 'âˆ’04:00', ''),
('MS', '+1643-06213', 'America/Montserrat', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('BS', '+2505-07721', 'America/Nassau', '', 'âˆ’05:00', 'âˆ’04:00', ''),
('US', '+404251-0740023', 'America/New_York', 'Eastern Time', 'âˆ’05:00', 'âˆ’04:00', ''),
('CA', '+4901-08816', 'America/Nipigon', 'Eastern Time - Ontario & Quebec - places that did not observe DST 1967-1973', 'âˆ’05:00', 'âˆ’04:00', ''),
('US', '+643004-1652423', 'America/Nome', 'Alaska Time - west Alaska', 'âˆ’09:00', 'âˆ’08:00', ''),
('BR', '-0351-03225', 'America/Noronha', 'Atlantic islands', 'âˆ’02:00', 'âˆ’02:00', ''),
('US', '+471551-1014640', 'America/North_Dakota/Beulah', 'Central Time - North Dakota - Mercer County', 'âˆ’06:00', 'âˆ’05:00', ''),
('US', '+470659-1011757', 'America/North_Dakota/Center', 'Central Time - North Dakota - Oliver County', 'âˆ’06:00', 'âˆ’05:00', ''),
('US', '+465042-1012439', 'America/North_Dakota/New_Salem', 'Central Time - North Dakota - Morton County (except Mandan area)', 'âˆ’06:00', 'âˆ’05:00', ''),
('MX', '+2934-10425', 'America/Ojinaga', 'US Mountain Time - Chihuahua near US border', 'âˆ’07:00', 'âˆ’06:00', ''),
('PA', '+0858-07932', 'America/Panama', '', 'âˆ’05:00', 'âˆ’05:00', ''),
('CA', '+6608-06544', 'America/Pangnirtung', 'Eastern Time - Pangnirtung, Nunavut', 'âˆ’05:00', 'âˆ’04:00', ''),
('SR', '+0550-05510', 'America/Paramaribo', '', 'âˆ’03:00', 'âˆ’03:00', ''),
('US', '+332654-1120424', 'America/Phoenix', 'Mountain Standard Time - Arizona', 'âˆ’07:00', 'âˆ’07:00', ''),
('TT', '+1039-06131', 'America/Port_of_Spain', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('HT', '+1832-07220', 'America/Port-au-Prince', '', 'âˆ’05:00', 'âˆ’04:00', ''),
('', '', 'America/Porto_Acre', '', 'âˆ’04:00', 'âˆ’04:00', 'Link to America/Rio_Branco'),
('BR', '-0846-06354', 'America/Porto_Velho', 'Rondonia', 'âˆ’04:00', 'âˆ’04:00', ''),
('PR', '+182806-0660622', 'America/Puerto_Rico', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('CA', '+4843-09434', 'America/Rainy_River', 'Central Time - Rainy River & Fort Frances, Ontario', 'âˆ’06:00', 'âˆ’05:00', ''),
('CA', '+624900-0920459', 'America/Rankin_Inlet', 'Central Time - central Nunavut', 'âˆ’06:00', 'âˆ’05:00', ''),
('BR', '-0803-03454', 'America/Recife', 'Pernambuco', 'âˆ’03:00', 'âˆ’03:00', ''),
('CA', '+5024-10439', 'America/Regina', 'Central Standard Time - Saskatchewan - most locations', 'âˆ’06:00', 'âˆ’06:00', ''),
('CA', '+744144-0944945', 'America/Resolute', 'Central Standard Time - Resolute, Nunavut', 'âˆ’06:00', 'âˆ’05:00', ''),
('BR', '-0958-06748', 'America/Rio_Branco', 'Acre', 'âˆ’04:00', 'âˆ’04:00', ''),
('', '', 'America/Rosario', '', 'âˆ’03:00', 'âˆ’03:00', 'Link to America/Argentina/Cordoba'),
('MX', '+3018-11452', 'America/Santa_Isabel', 'Mexican Pacific Time - Baja California away from US border', 'âˆ’08:00', 'âˆ’07:00', ''),
('BR', '-0226-05452', 'America/Santarem', 'W Para', 'âˆ’03:00', 'âˆ’03:00', ''),
('CL', '-3327-07040', 'America/Santiago', 'most locations', 'âˆ’04:00', 'âˆ’03:00', ''),
('DO', '+1828-06954', 'America/Santo_Domingo', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('BR', '-2332-04637', 'America/Sao_Paulo', 'S & SE Brazil (GO, DF, MG, ES, RJ, SP, PR, SC, RS)', 'âˆ’03:00', 'âˆ’02:00', ''),
('GL', '+7029-02158', 'America/Scoresbysund', 'Scoresbysund / Ittoqqortoormiit', 'âˆ’01:00', '+00:00', ''),
('US', '+364708-1084111', 'America/Shiprock', 'Mountain Time - Navajo', 'âˆ’07:00', 'âˆ’06:00', 'Link to America/Denver'),
('US', '+571035-1351807', 'America/Sitka', 'Alaska Time - southeast Alaska panhandle', 'âˆ’09:00', 'âˆ’08:00', ''),
('BL', '+1753-06251', 'America/St_Barthelemy', '', 'âˆ’04:00', 'âˆ’04:00', 'Link to America/Guadeloupe'),
('CA', '+4734-05243', 'America/St_Johns', 'Newfoundland Time, including SE Labrador', 'âˆ’03:30', 'âˆ’02:30', ''),
('KN', '+1718-06243', 'America/St_Kitts', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('LC', '+1401-06100', 'America/St_Lucia', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('VI', '+1821-06456', 'America/St_Thomas', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('VC', '+1309-06114', 'America/St_Vincent', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('CA', '+5017-10750', 'America/Swift_Current', 'Central Standard Time - Saskatchewan - midwest', 'âˆ’06:00', 'âˆ’06:00', ''),
('HN', '+1406-08713', 'America/Tegucigalpa', '', 'âˆ’06:00', 'âˆ’06:00', ''),
('GL', '+7634-06847', 'America/Thule', 'Thule / Pituffik', 'âˆ’04:00', 'âˆ’03:00', ''),
('CA', '+4823-08915', 'America/Thunder_Bay', 'Eastern Time - Thunder Bay, Ontario', 'âˆ’05:00', 'âˆ’04:00', ''),
('MX', '+3232-11701', 'America/Tijuana', 'US Pacific Time - Baja California near US border', 'âˆ’08:00', 'âˆ’07:00', ''),
('CA', '+4339-07923', 'America/Toronto', 'Eastern Time - Ontario - most locations', 'âˆ’05:00', 'âˆ’04:00', ''),
('VG', '+1827-06437', 'America/Tortola', '', 'âˆ’04:00', 'âˆ’04:00', ''),
('CA', '+4916-12307', 'America/Vancouver', 'Pacific Time - west British Columbia', 'âˆ’08:00', 'âˆ’07:00', ''),
('', '', 'America/Virgin', '', 'âˆ’04:00', 'âˆ’04:00', 'Link to America/St_Thomas'),
('CA', '+6043-13503', 'America/Whitehorse', 'Pacific Time - south Yukon', 'âˆ’08:00', 'âˆ’07:00', ''),
('CA', '+4953-09709', 'America/Winnipeg', 'Central Time - Manitoba & west Ontario', 'âˆ’06:00', 'âˆ’05:00', ''),
('US', '+593249-1394338', 'America/Yakutat', 'Alaska Time - Alaska panhandle neck', 'âˆ’09:00', 'âˆ’08:00', ''),
('CA', '+6227-11421', 'America/Yellowknife', 'Mountain Time - central Northwest Territories', 'âˆ’07:00', 'âˆ’06:00', ''),
('AQ', '-6617+11031', 'Antarctica/Casey', 'Casey Station, Bailey Peninsula', '+11:00', '+08:00', ''),
('AQ', '-6835+07758', 'Antarctica/Davis', 'Davis Station, Vestfold Hills', '+05:00', '+07:00', ''),
('AQ', '-6640+14001', 'Antarctica/DumontDUrville', 'Dumont-d\'Urville Station, Terre Adelie', '+10:00', '+10:00', ''),
('AQ', '-5430+15857', 'Antarctica/Macquarie', 'Macquarie Island Station, Macquarie Island', '+11:00', '+11:00', ''),
('AQ', '-6736+06253', 'Antarctica/Mawson', 'Mawson Station, Holme Bay', '+05:00', '+05:00', ''),
('AQ', '-7750+16636', 'Antarctica/McMurdo', 'McMurdo Station, Ross Island', '+12:00', '+13:00', ''),
('AQ', '-6448-06406', 'Antarctica/Palmer', 'Palmer Station, Anvers Island', 'âˆ’04:00', 'âˆ’03:00', ''),
('AQ', '-6734-06808', 'Antarctica/Rothera', 'Rothera Station, Adelaide Island', 'âˆ’03:00', 'âˆ’03:00', ''),
('AQ', '-9000+00000', 'Antarctica/South_Pole', 'Amundsen-Scott Station, South Pole', '+12:00', '+13:00', 'Link to Antarctica/McMurdo'),
('AQ', '-690022+0393524', 'Antarctica/Syowa', 'Syowa Station, E Ongul I', '+03:00', '+03:00', ''),
('AQ', '-7824+10654', 'Antarctica/Vostok', 'Vostok Station, Lake Vostok', '+06:00', '+06:00', ''),
('SJ', '+7800+01600', 'Arctic/Longyearbyen', '', '+01:00', '+02:00', 'Link to Europe/Oslo'),
('YE', '+1245+04512', 'Asia/Aden', '', '+03:00', '+03:00', ''),
('KZ', '+4315+07657', 'Asia/Almaty', 'most locations', '+06:00', '+06:00', ''),
('JO', '+3157+03556', 'Asia/Amman', '', '+03:00', '+03:00', ''),
('RU', '+6445+17729', 'Asia/Anadyr', 'Moscow+08 - Bering Sea', '+12:00', '+12:00', ''),
('KZ', '+4431+05016', 'Asia/Aqtau', 'Atyrau (Atirau, Gur\'yev), Mangghystau (Mankistau)', '+05:00', '+05:00', ''),
('KZ', '+5017+05710', 'Asia/Aqtobe', 'Aqtobe (Aktobe)', '+05:00', '+05:00', ''),
('TM', '+3757+05823', 'Asia/Ashgabat', '', '+05:00', '+05:00', ''),
('', '', 'Asia/Ashkhabad', '', '+05:00', '+05:00', 'Link to Asia/Ashgabat'),
('IQ', '+3321+04425', 'Asia/Baghdad', '', '+03:00', '+03:00', ''),
('BH', '+2623+05035', 'Asia/Bahrain', '', '+03:00', '+03:00', ''),
('AZ', '+4023+04951', 'Asia/Baku', '', '+04:00', '+05:00', ''),
('TH', '+1345+10031', 'Asia/Bangkok', '', '+07:00', '+07:00', ''),
('LB', '+3353+03530', 'Asia/Beirut', '', '+02:00', '+03:00', ''),
('KG', '+4254+07436', 'Asia/Bishkek', '', '+06:00', '+06:00', ''),
('BN', '+0456+11455', 'Asia/Brunei', '', '+08:00', '+08:00', ''),
('', '', 'Asia/Calcutta', '', '+05:30', '+05:30', 'Link to Asia/Kolkata'),
('MN', '+4804+11430', 'Asia/Choibalsan', 'Dornod, Sukhbaatar', '+08:00', '+08:00', ''),
('CN', '+2934+10635', 'Asia/Chongqing', 'central China - Sichuan, Yunnan, Guangxi, Shaanxi, Guizhou, etc.', '+08:00', '+08:00', 'Covering historic Kansu-Szechuan time zone.'),
('', '', 'Asia/Chungking', '', '+08:00', '+08:00', 'Link to Asia/Chongqing'),
('LK', '+0656+07951', 'Asia/Colombo', '', '+05:30', '+05:30', ''),
('', '', 'Asia/Dacca', '', '+06:00', '+06:00', 'Link to Asia/Dhaka'),
('SY', '+3330+03618', 'Asia/Damascus', '', '+02:00', '+03:00', ''),
('BD', '+2343+09025', 'Asia/Dhaka', '', '+06:00', '+06:00', ''),
('TL', '-0833+12535', 'Asia/Dili', '', '+09:00', '+09:00', ''),
('AE', '+2518+05518', 'Asia/Dubai', '', '+04:00', '+04:00', ''),
('TJ', '+3835+06848', 'Asia/Dushanbe', '', '+05:00', '+05:00', ''),
('PS', '+3130+03428', 'Asia/Gaza', 'Gaza Strip', '+02:00', '+03:00', ''),
('CN', '+4545+12641', 'Asia/Harbin', 'Heilongjiang (except Mohe), Jilin', '+08:00', '+08:00', 'Covering historic Changpai time zone.'),
('PS', '+313200+0350542', 'Asia/Hebron', 'West Bank', '+02:00', '+03:00', ''),
('VN', '+1045+10640', 'Asia/Ho_Chi_Minh', '', '+07:00', '+07:00', ''),
('HK', '+2217+11409', 'Asia/Hong_Kong', '', '+08:00', '+08:00', ''),
('MN', '+4801+09139', 'Asia/Hovd', 'Bayan-Olgiy, Govi-Altai, Hovd, Uvs, Zavkhan', '+07:00', '+07:00', ''),
('RU', '+5216+10420', 'Asia/Irkutsk', 'Moscow+05 - Lake Baikal', '+09:00', '+09:00', ''),
('', '', 'Asia/Istanbul', '', '+02:00', '+03:00', 'Link to Europe/Istanbul'),
('ID', '-0610+10648', 'Asia/Jakarta', 'Java & Sumatra', '+07:00', '+07:00', ''),
('ID', '-0232+14042', 'Asia/Jayapura', 'west New Guinea (Irian Jaya) & Malukus (Moluccas)', '+09:00', '+09:00', ''),
('IL', '+3146+03514', 'Asia/Jerusalem', '', '+02:00', '+03:00', ''),
('AF', '+3431+06912', 'Asia/Kabul', '', '+04:30', '+04:30', ''),
('RU', '+5301+15839', 'Asia/Kamchatka', 'Moscow+08 - Kamchatka', '+12:00', '+12:00', ''),
('PK', '+2452+06703', 'Asia/Karachi', '', '+05:00', '+05:00', ''),
('CN', '+3929+07559', 'Asia/Kashgar', 'west Tibet & Xinjiang', '+08:00', '+08:00', 'Covering historic Kunlun time zone.'),
('NP', '+2743+08519', 'Asia/Kathmandu', '', '+05:45', '+05:45', ''),
('', '', 'Asia/Katmandu', '', '+05:45', '+05:45', 'Link to Asia/Kathmandu'),
('IN', '+2232+08822', 'Asia/Kolkata', '', '+05:30', '+05:30', 'Note: Different zones in history, see Time in India.'),
('RU', '+5601+09250', 'Asia/Krasnoyarsk', 'Moscow+04 - Yenisei River', '+08:00', '+08:00', ''),
('MY', '+0310+10142', 'Asia/Kuala_Lumpur', 'peninsular Malaysia', '+08:00', '+08:00', ''),
('MY', '+0133+11020', 'Asia/Kuching', 'Sabah & Sarawak', '+08:00', '+08:00', ''),
('KW', '+2920+04759', 'Asia/Kuwait', '', '+03:00', '+03:00', ''),
('', '', 'Asia/Macao', '', '+08:00', '+08:00', 'Link to Asia/Macau'),
('MO', '+2214+11335', 'Asia/Macau', '', '+08:00', '+08:00', ''),
('RU', '+5934+15048', 'Asia/Magadan', 'Moscow+08 - Magadan', '+12:00', '+12:00', ''),
('ID', '-0507+11924', 'Asia/Makassar', 'east & south Borneo, Sulawesi (Celebes), Bali, Nusa Tenggara, west Timor', '+08:00', '+08:00', ''),
('PH', '+1435+12100', 'Asia/Manila', '', '+08:00', '+08:00', ''),
('OM', '+2336+05835', 'Asia/Muscat', '', '+04:00', '+04:00', ''),
('CY', '+3510+03322', 'Asia/Nicosia', '', '+02:00', '+03:00', ''),
('RU', '+5345+08707', 'Asia/Novokuznetsk', 'Moscow+03 - Novokuznetsk', '+07:00', '+07:00', ''),
('RU', '+5502+08255', 'Asia/Novosibirsk', 'Moscow+03 - Novosibirsk', '+07:00', '+07:00', ''),
('RU', '+5500+07324', 'Asia/Omsk', 'Moscow+03 - west Siberia', '+07:00', '+07:00', ''),
('KZ', '+5113+05121', 'Asia/Oral', 'West Kazakhstan', '+05:00', '+05:00', ''),
('KH', '+1133+10455', 'Asia/Phnom_Penh', '', '+07:00', '+07:00', ''),
('ID', '-0002+10920', 'Asia/Pontianak', 'west & central Borneo', '+07:00', '+07:00', ''),
('KP', '+3901+12545', 'Asia/Pyongyang', '', '+09:00', '+09:00', ''),
('QA', '+2517+05132', 'Asia/Qatar', '', '+03:00', '+03:00', ''),
('KZ', '+4448+06528', 'Asia/Qyzylorda', 'Qyzylorda (Kyzylorda, Kzyl-Orda)', '+06:00', '+06:00', ''),
('MM', '+1647+09610', 'Asia/Rangoon', '', '+06:30', '+06:30', ''),
('SA', '+2438+04643', 'Asia/Riyadh', '', '+03:00', '+03:00', ''),
('', '', 'Asia/Saigon', '', '+07:00', '+07:00', 'Link to Asia/Ho_Chi_Minh'),
('RU', '+4658+14242', 'Asia/Sakhalin', 'Moscow+07 - Sakhalin Island', '+11:00', '+11:00', ''),
('UZ', '+3940+06648', 'Asia/Samarkand', 'west Uzbekistan', '+05:00', '+05:00', ''),
('KR', '+3733+12658', 'Asia/Seoul', '', '+09:00', '+09:00', ''),
('CN', '+3114+12128', 'Asia/Shanghai', 'east China - Beijing, Guangdong, Shanghai, etc.', '+08:00', '+08:00', 'Covering historic Chungyuan time zone.'),
('SG', '+0117+10351', 'Asia/Singapore', '', '+08:00', '+08:00', ''),
('TW', '+2503+12130', 'Asia/Taipei', '', '+08:00', '+08:00', ''),
('UZ', '+4120+06918', 'Asia/Tashkent', 'east Uzbekistan', '+05:00', '+05:00', ''),
('GE', '+4143+04449', 'Asia/Tbilisi', '', '+04:00', '+04:00', ''),
('IR', '+3540+05126', 'Asia/Tehran', '', '+03:30', '+04:30', ''),
('', '', 'Asia/Tel_Aviv', '', '+02:00', '+03:00', 'Link to Asia/Jerusalem'),
('', '', 'Asia/Thimbu', '', '+06:00', '+06:00', 'Link to Asia/Thimphu'),
('BT', '+2728+08939', 'Asia/Thimphu', '', '+06:00', '+06:00', ''),
('JP', '+353916+1394441', 'Asia/Tokyo', '', '+09:00', '+09:00', ''),
('', '', 'Asia/Ujung_Pandang', '', '+08:00', '+08:00', 'Link to Asia/Makassar'),
('MN', '+4755+10653', 'Asia/Ulaanbaatar', 'most locations', '+08:00', '+08:00', ''),
('', '', 'Asia/Ulan_Bator', '', '+08:00', '+08:00', 'Link to Asia/Ulaanbaatar'),
('CN', '+4348+08735', 'Asia/Urumqi', 'most of Tibet & Xinjiang', '+08:00', '+08:00', 'Covering historic Sinkiang-Tibet time zone.'),
('LA', '+1758+10236', 'Asia/Vientiane', '', '+07:00', '+07:00', ''),
('RU', '+4310+13156', 'Asia/Vladivostok', 'Moscow+07 - Amur River', '+11:00', '+11:00', ''),
('RU', '+6200+12940', 'Asia/Yakutsk', 'Moscow+06 - Lena River', '+10:00', '+10:00', ''),
('RU', '+5651+06036', 'Asia/Yekaterinburg', 'Moscow+02 - Urals', '+06:00', '+06:00', ''),
('AM', '+4011+04430', 'Asia/Yerevan', '', '+04:00', '+04:00', ''),
('PT', '+3744-02540', 'Atlantic/Azores', 'Azores', 'âˆ’01:00', '+00:00', ''),
('BM', '+3217-06446', 'Atlantic/Bermuda', '', 'âˆ’04:00', 'âˆ’03:00', ''),
('ES', '+2806-01524', 'Atlantic/Canary', 'Canary Islands', '+00:00', '+01:00', ''),
('CV', '+1455-02331', 'Atlantic/Cape_Verde', '', 'âˆ’01:00', 'âˆ’01:00', ''),
('', '', 'Atlantic/Faeroe', '', '+00:00', '+01:00', 'Link to Atlantic/Faroe'),
('FO', '+6201-00646', 'Atlantic/Faroe', '', '+00:00', '+01:00', ''),
('', '', 'Atlantic/Jan_Mayen', '', '+01:00', '+02:00', 'Link to Europe/Oslo'),
('PT', '+3238-01654', 'Atlantic/Madeira', 'Madeira Islands', '+00:00', '+01:00', ''),
('IS', '+6409-02151', 'Atlantic/Reykjavik', '', '+00:00', '+00:00', ''),
('GS', '-5416-03632', 'Atlantic/South_Georgia', '', 'âˆ’02:00', 'âˆ’02:00', ''),
('SH', '-1555-00542', 'Atlantic/St_Helena', '', '+00:00', '+00:00', ''),
('FK', '-5142-05751', 'Atlantic/Stanley', '', 'âˆ’03:00', 'âˆ’03:00', ''),
('', '', 'Australia/ACT', '', '+10:00', '+11:00', 'Link to Australia/Sydney'),
('AU', '-3455+13835', 'Australia/Adelaide', 'South Australia', '+09:30', '+10:30', ''),
('AU', '-2728+15302', 'Australia/Brisbane', 'Queensland - most locations', '+10:00', '+10:00', ''),
('AU', '-3157+14127', 'Australia/Broken_Hill', 'New South Wales - Yancowinna', '+09:30', '+10:30', ''),
('', '', 'Australia/Canberra', '', '+10:00', '+11:00', 'Link to Australia/Sydney'),
('AU', '-3956+14352', 'Australia/Currie', 'Tasmania - King Island', '+10:00', '+11:00', ''),
('AU', '-1228+13050', 'Australia/Darwin', 'Northern Territory', '+09:30', '+09:30', ''),
('AU', '-3143+12852', 'Australia/Eucla', 'Western Australia - Eucla area', '+08:45', '+08:45', ''),
('AU', '-4253+14719', 'Australia/Hobart', 'Tasmania - most locations', '+10:00', '+11:00', ''),
('', '', 'Australia/LHI', '', '+10:30', '+11:00', 'Link to Australia/Lord_Howe'),
('AU', '-2016+14900', 'Australia/Lindeman', 'Queensland - Holiday Islands', '+10:00', '+10:00', ''),
('AU', '-3133+15905', 'Australia/Lord_Howe', 'Lord Howe Island', '+10:30', '+11:00', ''),
('AU', '-3749+14458', 'Australia/Melbourne', 'Victoria', '+10:00', '+11:00', ''),
('', '', 'Australia/North', '', '+09:30', '+09:30', 'Link to Australia/Darwin'),
('', '', 'Australia/NSW', '', '+10:00', '+11:00', 'Link to Australia/Sydney'),
('AU', '-3157+11551', 'Australia/Perth', 'Western Australia - most locations', '+08:00', '+08:00', ''),
('', '', 'Australia/Queensland', '', '+10:00', '+10:00', 'Link to Australia/Brisbane'),
('', '', 'Australia/South', '', '+09:30', '+10:30', 'Link to Australia/Adelaide'),
('AU', '-3352+15113', 'Australia/Sydney', 'New South Wales - most locations', '+10:00', '+11:00', ''),
('', '', 'Australia/Tasmania', '', '+10:00', '+11:00', 'Link to Australia/Hobart'),
('', '', 'Australia/Victoria', '', '+10:00', '+11:00', 'Link to Australia/Melbourne'),
('', '', 'Australia/West', '', '+08:00', '+08:00', 'Link to Australia/Perth'),
('', '', 'Australia/Yancowinna', '', '+09:30', '+10:30', 'Link to Australia/Broken_Hill'),
('', '', 'Brazil/Acre', '', 'âˆ’04:00', 'âˆ’04:00', 'Link to America/Rio_Branco'),
('', '', 'Brazil/DeNoronha', '', 'âˆ’02:00', 'âˆ’02:00', 'Link to America/Noronha'),
('', '', 'Brazil/East', '', 'âˆ’03:00', 'âˆ’02:00', 'Link to America/Sao_Paulo'),
('', '', 'Brazil/West', '', 'âˆ’04:00', 'âˆ’04:00', 'Link to America/Manaus'),
('', '', 'Canada/Atlantic', '', 'âˆ’04:00', 'âˆ’03:00', 'Link to America/Halifax'),
('', '', 'Canada/Central', '', 'âˆ’06:00', 'âˆ’05:00', 'Link to America/Winnipeg'),
('', '', 'Canada/East-Saskatchewan', '', 'âˆ’06:00', 'âˆ’06:00', 'Link to America/Regina'),
('', '', 'Canada/Eastern', '', 'âˆ’05:00', 'âˆ’04:00', 'Link to America/Toronto'),
('', '', 'Canada/Mountain', '', 'âˆ’07:00', 'âˆ’06:00', 'Link to America/Edmonton'),
('', '', 'Canada/Newfoundland', '', 'âˆ’03:30', 'âˆ’02:30', 'Link to America/St_Johns'),
('', '', 'Canada/Pacific', '', 'âˆ’08:00', 'âˆ’07:00', 'Link to America/Vancouver'),
('', '', 'Canada/Saskatchewan', '', 'âˆ’06:00', 'âˆ’06:00', 'Link to America/Regina'),
('', '', 'Canada/Yukon', '', 'âˆ’08:00', 'âˆ’07:00', 'Link to America/Whitehorse'),
('', '', 'CET', '', '+01:00', '+02:00', ''),
('', '', 'Chile/Continental', '', 'âˆ’04:00', 'âˆ’03:00', 'Link to America/Santiago'),
('', '', 'Chile/EasterIsland', '', 'âˆ’06:00', 'âˆ’05:00', 'Link to Pacific/Easter'),
('', '', 'CST6CDT', '', 'âˆ’06:00', 'âˆ’05:00', ''),
('', '', 'Cuba', '', 'âˆ’05:00', 'âˆ’04:00', 'Link to America/Havana'),
('', '', 'EET', '', '+02:00', '+03:00', ''),
('', '', 'Egypt', '', '+02:00', '+02:00', 'Link to Africa/Cairo'),
('', '', 'Eire', '', '+00:00', '+01:00', 'Link to Europe/Dublin'),
('', '', 'EST', '', 'âˆ’05:00', 'âˆ’05:00', ''),
('', '', 'EST5EDT', '', 'âˆ’05:00', 'âˆ’04:00', ''),
('', '', 'Etc./GMT', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'Etc./GMT+0', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'Etc./UCT', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'Etc./Universal', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'Etc./UTC', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'Etc./Zulu', '', '+00:00', '+00:00', 'Link to UTC'),
('NL', '+5222+00454', 'Europe/Amsterdam', '', '+01:00', '+02:00', ''),
('AD', '+4230+00131', 'Europe/Andorra', '', '+01:00', '+02:00', ''),
('GR', '+3758+02343', 'Europe/Athens', '', '+02:00', '+03:00', ''),
('', '', 'Europe/Belfast', '', '+00:00', '+01:00', 'Link to Europe/London'),
('RS', '+4450+02030', 'Europe/Belgrade', '', '+01:00', '+02:00', ''),
('DE', '+5230+01322', 'Europe/Berlin', '', '+01:00', '+02:00', 'In 1945, the Trizone did not follow Berlin\'s switch to DST, see Time in Germany'),
('SK', '+4809+01707', 'Europe/Bratislava', '', '+01:00', '+02:00', 'Link to Europe/Prague'),
('BE', '+5050+00420', 'Europe/Brussels', '', '+01:00', '+02:00', ''),
('RO', '+4426+02606', 'Europe/Bucharest', '', '+02:00', '+03:00', ''),
('HU', '+4730+01905', 'Europe/Budapest', '', '+01:00', '+02:00', ''),
('MD', '+4700+02850', 'Europe/Chisinau', '', '+02:00', '+03:00', ''),
('DK', '+5540+01235', 'Europe/Copenhagen', '', '+01:00', '+02:00', ''),
('IE', '+5320-00615', 'Europe/Dublin', '', '+00:00', '+01:00', ''),
('GI', '+3608-00521', 'Europe/Gibraltar', '', '+01:00', '+02:00', ''),
('GG', '+4927-00232', 'Europe/Guernsey', '', '+00:00', '+01:00', 'Link to Europe/London'),
('FI', '+6010+02458', 'Europe/Helsinki', '', '+02:00', '+03:00', ''),
('IM', '+5409-00428', 'Europe/Isle_of_Man', '', '+00:00', '+01:00', 'Link to Europe/London'),
('TR', '+4101+02858', 'Europe/Istanbul', '', '+02:00', '+03:00', ''),
('JE', '+4912-00207', 'Europe/Jersey', '', '+00:00', '+01:00', 'Link to Europe/London'),
('RU', '+5443+02030', 'Europe/Kaliningrad', 'Moscow-01 - Kaliningrad', '+03:00', '+03:00', ''),
('UA', '+5026+03031', 'Europe/Kiev', 'most locations', '+02:00', '+03:00', ''),
('PT', '+3843-00908', 'Europe/Lisbon', 'mainland', '+00:00', '+01:00', ''),
('SI', '+4603+01431', 'Europe/Ljubljana', '', '+01:00', '+02:00', 'Link to Europe/Belgrade'),
('GB', '+513030-0000731', 'Europe/London', '', '+00:00', '+01:00', ''),
('LU', '+4936+00609', 'Europe/Luxembourg', '', '+01:00', '+02:00', ''),
('ES', '+4024-00341', 'Europe/Madrid', 'mainland', '+01:00', '+02:00', ''),
('MT', '+3554+01431', 'Europe/Malta', '', '+01:00', '+02:00', ''),
('AX', '+6006+01957', 'Europe/Mariehamn', '', '+02:00', '+03:00', 'Link to Europe/Helsinki'),
('BY', '+5354+02734', 'Europe/Minsk', '', '+03:00', '+03:00', ''),
('MC', '+4342+00723', 'Europe/Monaco', '', '+01:00', '+02:00', ''),
('RU', '+5545+03735', 'Europe/Moscow', 'Moscow+00 - west Russia', '+04:00', '+04:00', ''),
('', '', 'Europe/Nicosia', '', '+02:00', '+03:00', 'Link to Asia/Nicosia'),
('NO', '+5955+01045', 'Europe/Oslo', '', '+01:00', '+02:00', ''),
('FR', '+4852+00220', 'Europe/Paris', '', '+01:00', '+02:00', ''),
('ME', '+4226+01916', 'Europe/Podgorica', '', '+01:00', '+02:00', 'Link to Europe/Belgrade'),
('CZ', '+5005+01426', 'Europe/Prague', '', '+01:00', '+02:00', ''),
('LV', '+5657+02406', 'Europe/Riga', '', '+02:00', '+03:00', ''),
('IT', '+4154+01229', 'Europe/Rome', '', '+01:00', '+02:00', ''),
('RU', '+5312+05009', 'Europe/Samara', 'Moscow+00 - Samara, Udmurtia', '+04:00', '+04:00', ''),
('SM', '+4355+01228', 'Europe/San_Marino', '', '+01:00', '+02:00', 'Link to Europe/Rome'),
('BA', '+4352+01825', 'Europe/Sarajevo', '', '+01:00', '+02:00', 'Link to Europe/Belgrade'),
('UA', '+4457+03406', 'Europe/Simferopol', 'central Crimea', '+02:00', '+03:00', ''),
('MK', '+4159+02126', 'Europe/Skopje', '', '+01:00', '+02:00', 'Link to Europe/Belgrade'),
('BG', '+4241+02319', 'Europe/Sofia', '', '+02:00', '+03:00', ''),
('SE', '+5920+01803', 'Europe/Stockholm', '', '+01:00', '+02:00', ''),
('EE', '+5925+02445', 'Europe/Tallinn', '', '+02:00', '+03:00', ''),
('AL', '+4120+01950', 'Europe/Tirane', '', '+01:00', '+02:00', ''),
('', '', 'Europe/Tiraspol', '', '+02:00', '+03:00', 'Link to Europe/Chisinau'),
('UA', '+4837+02218', 'Europe/Uzhgorod', 'Ruthenia', '+02:00', '+03:00', ''),
('LI', '+4709+00931', 'Europe/Vaduz', '', '+01:00', '+02:00', ''),
('VA', '+415408+0122711', 'Europe/Vatican', '', '+01:00', '+02:00', 'Link to Europe/Rome'),
('AT', '+4813+01620', 'Europe/Vienna', '', '+01:00', '+02:00', ''),
('LT', '+5441+02519', 'Europe/Vilnius', '', '+02:00', '+03:00', ''),
('RU', '+4844+04425', 'Europe/Volgograd', 'Moscow+00 - Caspian Sea', '+04:00', '+04:00', ''),
('PL', '+5215+02100', 'Europe/Warsaw', '', '+01:00', '+02:00', ''),
('HR', '+4548+01558', 'Europe/Zagreb', '', '+01:00', '+02:00', 'Link to Europe/Belgrade'),
('UA', '+4750+03510', 'Europe/Zaporozhye', 'Zaporozh\'ye, E Lugansk / Zaporizhia, E Luhansk', '+02:00', '+03:00', ''),
('CH', '+4723+00832', 'Europe/Zurich', '', '+01:00', '+02:00', ''),
('', '', 'GB', '', '+00:00', '+01:00', 'Link to Europe/London'),
('', '', 'GB-Eire', '', '+00:00', '+01:00', 'Link to Europe/London'),
('', '', 'GMT', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'GMT-0', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'GMT+0', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'GMT0', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'Greenwich', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'Hong Kong', '', '+08:00', '+08:00', 'Link to Asia/Hong_Kong'),
('', '', 'HST', '', 'âˆ’10:00', 'âˆ’10:00', ''),
('', '', 'Iceland', '', '+00:00', '+00:00', 'Link to Atlantic/Reykjavik'),
('MG', '-1855+04731', 'Indian/Antananarivo', '', '+03:00', '+03:00', ''),
('IO', '-0720+07225', 'Indian/Chagos', '', '+06:00', '+06:00', ''),
('CX', '-1025+10543', 'Indian/Christmas', '', '+07:00', '+07:00', ''),
('CC', '-1210+09655', 'Indian/Cocos', '', '+06:30', '+06:30', ''),
('KM', '-1141+04316', 'Indian/Comoro', '', '+03:00', '+03:00', ''),
('TF', '-492110+0701303', 'Indian/Kerguelen', '', '+05:00', '+05:00', ''),
('SC', '-0440+05528', 'Indian/Mahe', '', '+04:00', '+04:00', ''),
('MV', '+0410+07330', 'Indian/Maldives', '', '+05:00', '+05:00', ''),
('MU', '-2010+05730', 'Indian/Mauritius', '', '+04:00', '+04:00', ''),
('YT', '-1247+04514', 'Indian/Mayotte', '', '+03:00', '+03:00', ''),
('RE', '-2052+05528', 'Indian/Reunion', '', '+04:00', '+04:00', ''),
('', '', 'Iran', '', '+03:30', '+04:30', 'Link to Asia/Tehran'),
('', '', 'Israel', '', '+02:00', '+03:00', 'Link to Asia/Jerusalem'),
('', '', 'Jamaica', '', 'âˆ’05:00', 'âˆ’05:00', 'Link to America/Jamaica'),
('', '', 'Japan', '', '+09:00', '+09:00', 'Link to Asia/Tokyo'),
('', '', 'JST-9', '', '+09:00', '+09:00', 'Link to Asia/Tokyo'),
('', '', 'Kwajalein', '', '+12:00', '+12:00', 'Link to Pacific/Kwajalein'),
('', '', 'Libya', '', '+02:00', '+02:00', 'Link to Africa/Tripoli'),
('', '', 'MET', '', '+01:00', '+02:00', ''),
('', '', 'Mexico/BajaNorte', '', 'âˆ’08:00', 'âˆ’07:00', 'Link to America/Tijuana'),
('', '', 'Mexico/BajaSur', '', 'âˆ’07:00', 'âˆ’06:00', 'Link to America/Mazatlan'),
('', '', 'Mexico/General', '', 'âˆ’06:00', 'âˆ’05:00', 'Link to America/Mexico_City'),
('', '', 'MST', '', 'âˆ’07:00', 'âˆ’07:00', ''),
('', '', 'MST7MDT', '', 'âˆ’07:00', 'âˆ’06:00', ''),
('', '', 'Navajo', '', 'âˆ’07:00', 'âˆ’06:00', 'Link to America/Denver'),
('', '', 'NZ', '', '+12:00', '+13:00', 'Link to Pacific/Auckland'),
('', '', 'NZ-CHAT', '', '+12:45', '+13:45', 'Link to Pacific/Chatham'),
('WS', '-1350-17144', 'Pacific/Apia', '', '+13:00', '+14:00', ''),
('NZ', '-3652+17446', 'Pacific/Auckland', 'most locations', '+12:00', '+13:00', ''),
('NZ', '-4357-17633', 'Pacific/Chatham', 'Chatham Islands', '+12:45', '+13:45', ''),
('FM', '+0725+15147', 'Pacific/Chuuk', 'Chuuk (Truk) and Yap', '+10:00', '+10:00', ''),
('CL', '-2709-10926', 'Pacific/Easter', 'Easter Island & Sala y Gomez', 'âˆ’06:00', 'âˆ’05:00', ''),
('VU', '-1740+16825', 'Pacific/Efate', '', '+11:00', '+11:00', ''),
('KI', '-0308-17105', 'Pacific/Enderbury', 'Phoenix Islands', '+13:00', '+13:00', ''),
('TK', '-0922-17114', 'Pacific/Fakaofo', '', '+13:00', '+13:00', ''),
('FJ', '-1808+17825', 'Pacific/Fiji', '', '+12:00', '+13:00', ''),
('TV', '-0831+17913', 'Pacific/Funafuti', '', '+12:00', '+12:00', ''),
('EC', '-0054-08936', 'Pacific/Galapagos', 'Galapagos Islands', 'âˆ’06:00', 'âˆ’06:00', ''),
('PF', '-2308-13457', 'Pacific/Gambier', 'Gambier Islands', 'âˆ’09:00', 'âˆ’09:00', ''),
('SB', '-0932+16012', 'Pacific/Guadalcanal', '', '+11:00', '+11:00', ''),
('GU', '+1328+14445', 'Pacific/Guam', '', '+10:00', '+10:00', ''),
('US', '+211825-1575130', 'Pacific/Honolulu', 'Hawaii', 'âˆ’10:00', 'âˆ’10:00', ''),
('UM', '+1645-16931', 'Pacific/Johnston', 'Johnston Atoll', 'âˆ’10:00', 'âˆ’10:00', ''),
('KI', '+0152-15720', 'Pacific/Kiritimati', 'Line Islands', '+14:00', '+14:00', ''),
('FM', '+0519+16259', 'Pacific/Kosrae', 'Kosrae', '+11:00', '+11:00', ''),
('MH', '+0905+16720', 'Pacific/Kwajalein', 'Kwajalein', '+12:00', '+12:00', ''),
('MH', '+0709+17112', 'Pacific/Majuro', 'most locations', '+12:00', '+12:00', ''),
('PF', '-0900-13930', 'Pacific/Marquesas', 'Marquesas Islands', 'âˆ’09:30', 'âˆ’09:30', ''),
('UM', '+2813-17722', 'Pacific/Midway', 'Midway Islands', 'âˆ’11:00', 'âˆ’11:00', ''),
('NR', '-0031+16655', 'Pacific/Nauru', '', '+12:00', '+12:00', ''),
('NU', '-1901-16955', 'Pacific/Niue', '', 'âˆ’11:00', 'âˆ’11:00', ''),
('NF', '-2903+16758', 'Pacific/Norfolk', '', '+11:30', '+11:30', ''),
('NC', '-2216+16627', 'Pacific/Noumea', '', '+11:00', '+11:00', ''),
('AS', '-1416-17042', 'Pacific/Pago_Pago', '', 'âˆ’11:00', 'âˆ’11:00', ''),
('PW', '+0720+13429', 'Pacific/Palau', '', '+09:00', '+09:00', ''),
('PN', '-2504-13005', 'Pacific/Pitcairn', '', 'âˆ’08:00', 'âˆ’08:00', ''),
('FM', '+0658+15813', 'Pacific/Pohnpei', 'Pohnpei (Ponape)', '+11:00', '+11:00', ''),
('', '', 'Pacific/Ponape', '', '+11:00', '+11:00', 'Link to Pacific/Pohnpei'),
('PG', '-0930+14710', 'Pacific/Port_Moresby', '', '+10:00', '+10:00', ''),
('CK', '-2114-15946', 'Pacific/Rarotonga', '', 'âˆ’10:00', 'âˆ’10:00', ''),
('MP', '+1512+14545', 'Pacific/Saipan', '', '+10:00', '+10:00', ''),
('', '', 'Pacific/Samoa', '', 'âˆ’11:00', 'âˆ’11:00', 'Link to Pacific/Pago_Pago'),
('PF', '-1732-14934', 'Pacific/Tahiti', 'Society Islands', 'âˆ’10:00', 'âˆ’10:00', ''),
('KI', '+0125+17300', 'Pacific/Tarawa', 'Gilbert Islands', '+12:00', '+12:00', ''),
('TO', '-2110-17510', 'Pacific/Tongatapu', '', '+13:00', '+13:00', ''),
('', '', 'Pacific/Truk', '', '+10:00', '+10:00', 'Link to Pacific/Chuuk'),
('UM', '+1917+16637', 'Pacific/Wake', 'Wake Island', '+12:00', '+12:00', ''),
('WF', '-1318-17610', 'Pacific/Wallis', '', '+12:00', '+12:00', ''),
('', '', 'Pacific/Yap', '', '+10:00', '+10:00', 'Link to Pacific/Chuuk'),
('', '', 'Poland', '', '+01:00', '+02:00', 'Link to Europe/Warsaw'),
('', '', 'Portugal', '', '+00:00', '+01:00', 'Link to Europe/Lisbon'),
('', '', 'PRC', '', '+08:00', '+08:00', 'Link to Asia/Shanghai'),
('', '', 'PST8PDT', '', 'âˆ’08:00', 'âˆ’07:00', ''),
('', '', 'ROC', '', '+08:00', '+08:00', 'Link to Asia/Taipei'),
('', '', 'ROK', '', '+09:00', '+09:00', 'Link to Asia/Seoul'),
('', '', 'Singapore', '', '+08:00', '+08:00', 'Link to Asia/Singapore'),
('', '', 'Turkey', '', '+02:00', '+03:00', 'Link to Europe/Istanbul'),
('', '', 'UCT', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'Universal', '', '+00:00', '+00:00', 'Link to UTC'),
('', '', 'US/Alaska', '', 'âˆ’09:00', 'âˆ’08:00', 'Link to America/Anchorage'),
('', '', 'US/Aleutian', '', 'âˆ’10:00', 'âˆ’09:00', 'Link to America/Adak'),
('', '', 'US/Arizona', '', 'âˆ’07:00', 'âˆ’07:00', 'Link to America/Phoenix'),
('', '', 'US/Central', '', 'âˆ’06:00', 'âˆ’05:00', 'Link to America/Chicago'),
('', '', 'US/East-Indiana', '', 'âˆ’05:00', 'âˆ’04:00', 'Link to America/Indiana/Indianapolis'),
('', '', 'US/Eastern', '', 'âˆ’05:00', 'âˆ’04:00', 'Link to America/New_York'),
('', '', 'US/Hawaii', '', 'âˆ’10:00', 'âˆ’10:00', 'Link to Pacific/Honolulu'),
('', '', 'US/Indiana-Starke', '', 'âˆ’06:00', 'âˆ’05:00', 'Link to America/Indiana/Knox'),
('', '', 'US/Michigan', '', 'âˆ’05:00', 'âˆ’04:00', 'Link to America/Detroit'),
('', '', 'US/Mountain', '', 'âˆ’07:00', 'âˆ’06:00', 'Link to America/Denver'),
('', '', 'US/Pacific', '', 'âˆ’08:00', 'âˆ’07:00', 'Link to America/Los_Angeles'),
('', '', 'US/Pacific-New', '', 'âˆ’08:00', 'âˆ’07:00', 'Link to America/Los_Angeles'),
('', '', 'US/Samoa', '', 'âˆ’11:00', 'âˆ’11:00', 'Link to Pacific/Pago_Pago'),
('', '', 'UTC', '', '+00:00', '+00:00', ''),
('', '', 'W-SU', '', '+04:00', '+04:00', 'Link to Europe/Moscow'),
('', '', 'WET', '', '+00:00', '+01:00', ''),
('', '', 'Zulu', '', '+00:00', '+00:00', 'Link to UTC');

-- --------------------------------------------------------

--
-- Table structure for table `ci_sessions`
--

CREATE TABLE `ci_sessions` (
  `id` varchar(40) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `ip_address` varchar(45) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `timestamp` int(10) UNSIGNED NOT NULL DEFAULT 0,
  `data` longblob DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `ci_sessions`
--

INSERT INTO `ci_sessions` (`id`, `ip_address`, `timestamp`, `data`) VALUES
('ahbao7ufqdv9j5cdadpislf7qg9hk7sr', '::1', 1698063105, 0x5f5f63695f6c6173745f726567656e65726174657c693a313639383036333130343b);

-- --------------------------------------------------------

--
-- Table structure for table `comments`
--

CREATE TABLE `comments` (
  `comments_id` int(20) NOT NULL,
  `user_id` int(10) NOT NULL,
  `video_id` int(20) NOT NULL,
  `comment_type` int(5) NOT NULL DEFAULT 1,
  `replay_for` int(10) DEFAULT 0,
  `comment` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `comment_at` datetime DEFAULT NULL,
  `publication` int(5) DEFAULT 0
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `config`
--

CREATE TABLE `config` (
  `config_id` int(11) NOT NULL,
  `title` longtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `value` longtext COLLATE utf8mb4_unicode_520_ci NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `config`
--

INSERT INTO `config` (`config_id`, `title`, `value`) VALUES
(1, 'system_name', 'OVOO - Live TV & Movie Portal CMS with Unlimited TV-Series'),
(2, 'site_name', 'My Movie Site'),
(3, 'author', 'Jone Doe'),
(4, 'business_address', 'My Address'),
(5, 'business_phone', '880170000000'),
(6, 'contact_email', 'contact@mydomain.com'),
(7, 'system_email', 'email@mydomain.com'),
(8, 'system_short_name', 'OVOO'),
(9, 'social_share_enable', '0'),
(10, 'default_color', '#00CC6A'),
(11, 'front_end_theme', 'red'),
(12, 'seo_title', ''),
(13, 'focus_keyword', ''),
(14, 'meta_description', ''),
(15, 'blog_enable', '0'),
(16, 'blog_title', ''),
(17, 'blog_keyword', ''),
(18, 'blog_meta_description', ''),
(19, 'home_page_seo_title', ''),
(20, 'language', 'english'),
(21, 'site_url', 'https://mydomain.com'),
(22, 'total_movie_in_slider', '5'),
(23, 'footer1_title', 'About'),
(24, 'footer1_content', '<p><br></p>'),
(25, 'footer2_title', 'Useful Link'),
(26, 'footer2_content', '<p><br></p>'),
(27, 'footer3_title', 'Useful Link'),
(28, 'footer3_content', '<p><br></p>'),
(29, 'copyright_text', 'Copyright 2023&nbsp;<a href=\""#\"">Business Name</a>'),
(30, 'slider_type', 'disable'),
(31, 'slide_per_page', '8'),
(32, 'protocol', 'sendmail'),
(33, 'mailpath', '/usr/bin/sendmail'),
(34, 'smtp_host', 'smtp.gmail.com'),
(35, 'smtp_user', 'example@gmail.com'),
(36, 'smtp_pass', 'xxxxxxxxxxxx'),
(37, 'smtp_port', '465'),
(38, 'smtp_crypto', 'ssl'),
(39, 'facebook_url', '#'),
(40, 'twitter_url', '#'),
(41, 'vimeo_url', '#'),
(42, 'linkedin_url', '#'),
(43, 'youtube_url', '#'),
(44, 'google_analytics_id', ''),
(45, 'about_us_enable', '1'),
(46, 'about_us_title', 'about'),
(47, 'about_us_text', 'about us'),
(48, 'about_us_to_primary_menu', '1'),
(49, 'about_us_to_footer_menu', '0'),
(50, 'facebook_comment_appid', '0000'),
(51, 'comments_method', '0'),
(52, 'comments_approval', '0'),
(53, 'ad_160x600_code', ''),
(54, 'ad_160x600_type', '1'),
(55, 'ad_160x600_image_url', ''),
(56, 'ad_250x300_type', '1'),
(57, 'ad_250x300_image_url', ''),
(58, 'ad_250x300_code', ''),
(59, 'ad_160x600_url', ''),
(60, 'ad_250x300_url', '#'),
(61, 'map_api', 'xxxxxxxxxxxxxxxxxxxxxxx'),
(62, 'map_lat', 'xxxxxxxxxxxxxxxx'),
(63, 'map_lng', 'xxxxxxxxxxxxxxxxxxxx'),
(64, 'movie_per_page', '18'),
(65, 'google_application_name', 'Connect With TRC4'),
(66, 'google_client_id', 'xxxxxxxxxxxxxxxxxxxx'),
(67, 'google_client_secret', 'xxxxxxxxxxxxxxxxxxxxxxx'),
(68, 'google_redirect_uri', 'https://google.com/'),
(69, 'google_api_key', ''),
(70, 'google_login_enable', '0'),
(71, 'facebook_app_id', 'xxxxxxxxxxxxxxxxxxxx'),
(72, 'facebook_app_secret', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxx'),
(73, 'facebook_graph_version', 'v2.10'),
(74, 'google_login_enable', '0'),
(75, 'facebook_login_enable', '0'),
(76, 'tv_series_publish', '1'),
(77, 'tv_series_title', 'Tv-Series Page SEO Title'),
(78, 'tv_series_keyword', ''),
(79, 'tv_series_meta_description', ''),
(80, 'tv_series_pin_primary_menu', '1'),
(81, 'tv_series_pin_footer_menu', '1'),
(82, 'purchase_code', '123456'),
(83, 'header_templete', 'header1'),
(84, 'footer_templete', 'footer1'),
(85, 'dark_theme', '1'),
(86, 'player_color_skin', 'green'),
(87, 'player_watermark', '1'),
(88, 'player_watermark_logo', 'uploads/watermark_logo.png'),
(89, 'player_watermark_url', '#'),
(90, 'player_share', ''),
(91, 'player_share_fb_id', '35345'),
(92, 'player_seek_button', '0'),
(95, 'player_volume_remember', '1'),
(93, 'player_seek_forward', '10'),
(94, 'player_seek_back', '5'),
(98, 'live_tv_publish', '1'),
(99, 'live_tv_title', 'Latest TV Page SEO Title'),
(100, 'live_tv_keyword', ''),
(101, 'live_tv_meta_description', ''),
(102, 'live_tv_pin_primary_menu', '1'),
(103, 'live_tv_pin_footer_menu', '1'),
(104, 'registration_enable', '1'),
(105, 'frontend_login_enable', '1'),
(106, 'push_notification_enable', ''),
(107, 'onesignal_appid', 'xxxxxxxxxxxxxxx'),
(108, 'onesignal_actionmessage', 'We\\\'d like to show you notifications for the latest news.'),
(109, 'onesignal_acceptbuttontext', 'ALLOW'),
(110, 'onesignal_cancelbuttontext', 'NO THANKS'),
(111, 'onesignal_api_keys', 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'),
(112, 'landing_page_enable', '0'),
(113, 'landing_page_image_url', 'landing_page/bg.jpg'),
(142, 'mobile_apps_api_secret_key', 'b8385215ee161ff'),
(115, 'country_to_primary_menu', '0'),
(116, 'genre_to_primary_menu', '1'),
(117, 'release_to_primary_menu', '1'),
(118, 'show_star_image', '0'),
(119, 'movie_page_seo_title', 'Movie Page SEO Title'),
(120, 'movie_page_focus_keyword', ''),
(121, 'movie_page_meta_description', ''),
(128, 'dmca_policy_content', 'privacy_policy_content'),
(122, 'privacy_policy_content', ''),
(123, 'privacy_policy_to_primary_menu', '0'),
(124, 'privacy_policy_to_footer_menu', '0'),
(125, 'disclaimer_text', '<b>Disclaimer:</b> This site does not store any files on its server. All contents are provided by non-affiliated third parties.'),
(126, 'disclaimer_text_enable', '0'),
(127, 'movie_report_enable', '1'),
(129, 'dmca_to_primary_menu', '0'),
(130, 'dmca_to_footer_menu', '0'),
(131, 'dmca_content', ''),
(132, 'contact_to_primary_menu', '0'),
(133, 'contact_to_footer_menu', '1'),
(134, 'movie_report_note', 'Please help us to describe the issue so we can fix it asap. \r\nNote: This feature used to report the issue for the current movie, not used for requesting new subtitle/audio in another language'),
(135, 'movie_report_email', 'contact@mydomain.com'),
(136, 'movie_request_enable', '1'),
(137, 'movie_request_email', 'contact@mydomain.com'),
(138, 'envato_support_untill', '2019-01-01'),
(139, 'cron_key', '51664c535ae94b3'),
(140, 'db_backup', '0'),
(141, 'backup_schedule', '1'),
(143, 'version', '3.4'),
(144, 'preroll_ads_enable', '0'),
(145, 'preroll_ads_video', 'https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_20mb.mp4'),
(146, 'admob_ads_enable', '0'),
(147, 'admob_app_id', 'ca-app-pub-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxe'),
(148, 'admob_banner_ads_id', 'ca-app-pub-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'),
(149, 'admob_interstitial_ads_id', 'ca-app-pub-xxxxxxxxxxxxxxxxxxx/xxxxxxxxxxxxxx'),
(150, 'admob_publisher_id', 'pub-xxxxxxxxxxxxxxxxxxe'),
(151, 'recaptcha_site_key', 'xxxxxxxxxxxxxxxxxxx'),
(152, 'recaptcha_secret_key', 'xxxxxxxxxxxxxxxxxxxx'),
(153, 'az_to_primary_menu', '1'),
(154, 'az_to_footer_menu', '1'),
(155, 'recaptcha_enable', '0'),
(156, 'active_theme', 'default'),
(157, 'active_language_id', '1'),
(158, 'disqus_short_name', 'ovoo'),
(159, 'trial_enable', '0'),
(160, 'trial_period', '0'),
(171, 'tmdb_language', 'en'),
(172, 'default_quality', 'HD'),
(173, 'app_menu', 'grid'),
(174, 'app_program_guide_enable', 'false'),
(175, 'app_mandatory_login', 'false'),
(176, 'genre_visible', 'true'),
(177, 'country_visible', 'true'),
(178, 'timezone', 'Europe/Tirane'),
(179, 'season_order', 'DESC'),
(180, 'episode_order', 'DESC'),
(181, 'video_source', 'mp4'),
(182, 'video_file_order', 'DESC'),
(183, 'tmbd_api_key', ''),
(193, 'slider_border_radius', '10'),
(192, 'slider_height', '420'),
(190, 'slider_arrow', '0'),
(191, 'slider_bullet', '1'),
(189, 'slider_fullwide', '0'),
(194, 'logo', 'logo.png'),
(196, 'favicon', 'favicon.ico'),
(197, 'landing_bg', 'landing_page/bg.jpg'),
(199, 'trial_enable', '0'),
(200, 'trial_period', '0'),
(201, 'paypal_email', 'paypal@domain.com'),
(202, 'currency_symbol', '$'),
(203, 'stripe_publishable_key', 'xxxxxxxxxxxxxxxxxxxxxxxxxxx'),
(204, 'stripe_secret_key', 'xxxxxxxxxxxxxxxxxxxxxxxxxxx'),
(205, 'currency', 'USD'),
(206, 'paypal_client_id', 'xxxxxxxxxxxxxxxxxxxx'),
(207, 'exchange_rate_update_by_cron', '0'),
(208, 'enable_ribbon', '1'),
(209, 'mobile_ads_enable', '0'),
(210, 'mobile_ads_network', 'admob'),
(211, 'fan_native_ads_placement_id', 'xxxxxxxxxxxxxxxxxxxx'),
(212, 'fan_banner_ads_placement_id', 'xxxxxxxxxxxxxxxxxxxxxxx'),
(213, 'fan_Interstitial_ads_placement_id', 'xxxxxxxxxxxxxxxxxxxxxx'),
(214, 'startapp_app_id', 'xxxxxxxxxxx'),
(218, 'apk_version_code', '15'),
(219, 'apk_version_name', 'v1.2.8'),
(220, 'apk_whats_new', 'New UI\r\nDownload option\r\nAdvanced Search\r\nSubscription'),
(221, 'latest_apk_url', 'http://oxoo.spagreen.net/demo/oxoo-v121.apk'),
(222, 'apk_update_is_skipable', '1'),
(223, 'razorpay_key_id', 'xxxxxxxxxxx'),
(224, 'razorpay_key_secret', 'xxxxxxxxxxxx'),
(225, 'paypal_enable', 'true'),
(226, 'stripe_enable', 'true'),
(227, 'razorpay_enable', 'true'),
(228, 'razorpay_inr_exchange_rate', '1'),
(229, 'admob_native_ads_id', 'xxxxxxxxxxx'),
(230, 'offline_payment_enable', 'false'),
(231, 'offline_payment_title', 'Offline Payment'),
(232, 'offline_payment_instruction', 'Offline payment instruction goes here.<div>Your Name, IBAN, ETC....</div>'),
(233, 'movie_page_slider', '1'),
(234, 'tv_series_page_slider', '1'),
(235, 'bg_img_disable', '0'),
(236, 'bg_image', 'bg.jpg'),
(237, 'preloader_disable', '0'),
(238, 'reward_ad', 'disable'),
(239, 'reward_ad_id', 'reward_ad_ide'),
(240, 'banner_ad', 'disable'),
(241, 'banner_ad_id', 'banner_ad_ide'),
(242, 'interstitial_ad', 'disable'),
(243, 'interstitial_ad_id', 'interstitial_ad_ide'),
(244, 'native_ad', 'disable'),
(245, 'native_ad_id', 'native_ad_ide'),
(246, 'unity_test_mode', '0'),
(247, 'unity_android_game_id', 'unity_android_game_ide'),
(248, 'unity_ios_game_id', 'unity_ios_game_ide'),
(249, 'native_ad_interval', 'native_ad_interval'),
(250, 'tmdb_image_import_by_cron', '0');

-- --------------------------------------------------------

--
-- Table structure for table `country`
--

CREATE TABLE `country` (
  `country_id` int(11) NOT NULL,
  `name` varchar(60) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `description` varchar(25) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `slug` varchar(128) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `publication` int(2) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `country`
--

INSERT INTO `country` (`country_id`, `name`, `description`, `slug`, `publication`) VALUES
(1, 'International', '', 'international', 1),
(2, 'Asia', '', 'asia', 1),
(3, 'USA', '', 'usa', 1),
(4, 'China', '', 'china', 1),
(5, 'Japan', '', 'japan', 1),
(6, 'Korean', '', 'korean', 1),
(7, 'Nepal', '', 'nepal', 1),
(8, 'Thailand', '', 'thailand', 1),
(9, 'Tamil', '', 'tamil', 1),
(10, 'India', '', 'india', 1),
(11, 'France', '', 'france', 1),
(12, 'Italy', '', 'italy', 1),
(13, 'German', '', 'german', 1),
(14, 'London', '', 'london', 1),
(15, 'Canada', '', 'canada', 1),
(16, 'Denmark', '', 'denmark', 1),
(17, 'UK', '', 'uk', 1),
(18, 'Hong kong', '', 'hong-kong', 1),
(19, 'UAE', '', 'uae', 1),
(20, 'Australia', '', 'australia', 1),
(21, 'South Korea', '', 'south-korea', 1),
(22, 'Russia', '', 'russia', 1),
(23, ' Sweden', '', 'sweden', 1),
(24, 'Spain', '', 'spain', 1),
(25, 'Brazil', '', 'brazil', 1),
(26, 'Iran', '', 'iran', 1),
(27, 'Israel', '', 'israel', 1),
(28, 'Indonesia', '', 'indonesia', 1),
(29, 'Philippines', '', 'philippines', 1),
(30, ' Peru', ' Peru', 'peru', 1),
(31, ' Canada', ' Canada', 'canada', 1),
(32, ' Japan', ' Japan', 'japan', 1),
(33, ' USA', ' USA', 'usa', 1),
(34, ' Hong Kong', ' Hong Kong', 'hong-kong', 1),
(35, ' Mexico', ' Mexico', 'mexico', 1),
(36, ' New Zealand', ' New Zealand', 'new-zealand', 1),
(37, ' UK', ' UK', 'uk', 1),
(38, ' Denmark', ' Denmark', 'denmark', 1),
(39, ' Australia', ' Australia', 'australia', 1),
(40, ' Germany', ' Germany', 'germany', 1),
(41, ' Hungary', ' Hungary', 'hungary', 1),
(42, ' India', ' India', 'india', 1),
(43, 'Hungary', 'Hungary', 'hungary', 1),
(44, ' France', ' France', 'france', 1),
(45, ' China', ' China', 'china', 1),
(46, 'Chile', 'Chile', 'chile', 1),
(47, ' Argentina', ' Argentina', 'argentina', 1),
(48, 'Egypt', 'Egypt', 'egypt', 1),
(49, 'New Zealand', 'New Zealand', 'new-zealand', 1),
(50, 'Croatia', 'Croatia', 'croatia', 1),
(51, ' Switzerland', ' Switzerland', 'switzerland', 1),
(52, ' Tunisia', ' Tunisia', 'tunisia', 1),
(53, 'Belgium', 'Belgium', 'belgium', 1),
(68, 'United States of America', 'United States of America', 'united-states-of-america', 1),
(69, 'Bangladesh', 'Bangladesh', 'bangladesh', 1),
(70, 'United Kingdom', 'United Kingdom', 'united-kingdom', 1),
(71, 'Malaysia', 'Malaysia', 'malaysia', 1),
(72, 'South Africa', 'South Africa', 'south-africa', 1),
(73, 'Switzerland', 'Switzerland', 'switzerland', 1),
(74, 'Germany', 'Germany', 'germany', 1),
(75, 'Sweden', 'Sweden', 'sweden', 1),
(76, 'Bulgaria', 'Bulgaria', 'bulgaria', 1),
(77, 'Soviet Union', 'Soviet Union', 'soviet-union', 1),
(78, 'Netherlands', 'Netherlands', 'netherlands', 1),
(80, 'Malta', 'Malta', 'malta', 1),
(81, 'Taiwan', 'Taiwan', 'taiwan', 1),
(82, 'Argentina', 'Argentina', 'argentina', 1),
(83, 'Iceland', 'Iceland', 'iceland', 1),
(84, 'CA', 'CA', 'ca', 1),
(85, 'JP', 'JP', 'jp', 1),
(86, 'US', 'US', 'us', 1),
(87, 'GB', 'GB', 'gb', 1),
(88, '', '', '', 1);

-- --------------------------------------------------------

--
-- Table structure for table `cron`
--

CREATE TABLE `cron` (
  `cron_id` int(11) NOT NULL,
  `type` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `action` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `image_url` longtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `save_to` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `videos_id` int(250) DEFAULT NULL,
  `admin_email_from` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `admin_email` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `email_to` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `email_sub` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `message` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `currency`
--

CREATE TABLE `currency` (
  `currency_id` int(11) NOT NULL,
  `country` varchar(100) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `currency` varchar(100) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `iso_code` varchar(100) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `symbol` varchar(100) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `exchange_rate` double NOT NULL DEFAULT 1,
  `default` int(11) NOT NULL DEFAULT 0,
  `status` int(11) NOT NULL DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `currency`
--

INSERT INTO `currency` (`currency_id`, `country`, `currency`, `iso_code`, `symbol`, `exchange_rate`, `default`, `status`) VALUES
(1, 'Albania', 'Leke', 'ALL', 'Lek', 1, 0, 1),
(2, 'America', 'Dollars', 'USD', '$', 1, 0, 1),
(3, 'Afghanistan', 'Afghanis', 'AFN', '؋', 1, 0, 1),
(4, 'Argentina', 'Pesos', 'ARS', '$', 61.399228, 0, 1),
(5, 'Aruba', 'Guilders', 'AWG', 'ƒ', 1, 0, 1),
(6, 'Australia', 'Dollars', 'AUD', '$', 1.4882, 0, 1),
(7, 'Azerbaijan', 'New Manats', 'AZN', 'ман', 1, 0, 1),
(8, 'Bahamas', 'Dollars', 'BSD', '$', 1, 0, 1),
(9, 'Barbados', 'Dollars', 'BBD', '$', 1, 0, 1),
(10, 'Belarus', 'Rubles', 'BYR', 'p.', 1, 0, 1),
(11, 'Belgium', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(12, 'Beliz', 'Dollars', 'BZD', 'BZ$', 1, 0, 1),
(13, 'Bermuda', 'Dollars', 'BMD', '$', 1, 0, 1),
(14, 'Bolivia', 'Bolivianos', 'BOB', '$b', 1, 0, 1),
(15, 'Bosnia and Herzegovina', 'Convertible Marka', 'BAM', 'KM', 1, 0, 1),
(16, 'Botswana', 'Pula', 'BWP', 'P', 1, 0, 1),
(17, 'Bulgaria', 'Leva', 'BGN', 'лв', 1.803753, 0, 1),
(18, 'Brazil', 'Reais', 'BRL', 'R$', 4.330496, 0, 1),
(19, 'Britain (United Kingdom)', 'Pounds', 'GBP', '£', 83, 0, 1),
(20, 'Brunei Darussalam', 'Dollars', 'BND', '$', 1, 0, 1),
(21, 'Cambodia', 'Riels', 'KHR', '៛', 1, 0, 1),
(22, 'Canada', 'Dollars', 'CAD', '$', 1.325097, 0, 1),
(23, 'Cayman Islands', 'Dollars', 'KYD', '$', 1, 0, 1),
(24, 'Chile', 'Pesos', 'CLP', '$', 794.622928, 0, 1),
(25, 'China', 'Yuan Renminbi', 'CNY', '¥', 6.984162, 0, 1),
(26, 'Colombia', 'Pesos', 'COP', '$', 3313, 0, 1),
(27, 'Costa Rica', 'Colón', 'CRC', '₡', 1, 0, 1),
(28, 'Croatia', 'Kuna', 'HRK', 'kn', 6.869981, 0, 1),
(29, 'Cuba', 'Pesos', 'CUP', '₱', 1, 0, 1),
(30, 'Cyprus', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(31, 'Czech Republic', 'Koruny', 'CZK', 'Kč', 22.911451, 0, 1),
(32, 'Denmark', 'Kroner', 'DKK', 'kr', 6.890187, 0, 1),
(33, 'Dominican Republic', 'Pesos', 'DOP ', 'RD$', 53.507402, 0, 1),
(34, 'East Caribbean', 'Dollars', 'XCD', '$', 1, 0, 1),
(35, 'Egypt', 'Pounds', 'EGP', '£', 15.61815, 0, 1),
(36, 'El Salvador', 'Colones', 'SVC', '$', 1, 0, 1),
(37, 'England (United Kingdom)', 'Pounds', 'GBP', '£', 83, 0, 1),
(38, 'Euro', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(39, 'Falkland Islands', 'Pounds', 'FKP', '£', 1, 0, 1),
(40, 'Fiji', 'Dollars', 'FJD', '$', 2.195918, 0, 1),
(41, 'France', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(42, 'Ghana', 'Cedis', 'GHC', '¢', 1, 0, 1),
(43, 'Gibraltar', 'Pounds', 'GIP', '£', 1, 0, 1),
(44, 'Greece', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(45, 'Guatemala', 'Quetzales', 'GTQ', 'Q', 7.63804, 0, 1),
(46, 'Guernsey', 'Pounds', 'GGP', '£', 1, 0, 1),
(47, 'Guyana', 'Dollars', 'GYD', '$', 1, 0, 1),
(48, 'Holland (Netherlands)', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(49, 'Honduras', 'Lempiras', 'HNL', 'L', 1, 0, 1),
(50, 'Hong Kong', 'Dollars', 'HKD', '$', 7.767071, 0, 1),
(51, 'Hungary', 'Forint', 'HUF', 'Ft', 310.231043, 0, 1),
(52, 'Iceland', 'Kronur', 'ISK', 'kr', 126.858376, 0, 1),
(53, 'India', 'Rupees', 'INR', 'Rp', 71.40112, 0, 1),
(54, 'Indonesia', 'Rupiahs', 'IDR', 'Rp', 13612.651679, 0, 1),
(55, 'Iran', 'Rials', 'IRR', '﷼', 1, 0, 1),
(56, 'Ireland', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(57, 'Isle of Man', 'Pounds', 'IMP', '£', 1, 0, 1),
(58, 'Israel', 'New Shekels', 'ILS', '₪', 3.427408, 0, 1),
(59, 'Italy', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(60, 'Jamaica', 'Dollars', 'JMD', 'J$', 1, 0, 1),
(61, 'Japan', 'Yen', 'JPY', '¥', 109.814254, 0, 1),
(62, 'Jersey', 'Pounds', 'JEP', '£', 1, 0, 1),
(63, 'Kazakhstan', 'Tenge', 'KZT', 'лв', 376.834123, 0, 1),
(64, 'Korea (North)', 'Won', 'KPW', '₩', 1, 0, 1),
(65, 'Korea (South)', 'Won', 'KRW', '₩', 1183.94149, 0, 1),
(66, 'Kyrgyzstan', 'Soms', 'KGS', 'лв', 1, 0, 1),
(67, 'Laos', 'Kips', 'LAK', '₭', 1, 0, 1),
(68, 'Latvia', 'Lati', 'LVL', 'Ls', 1, 0, 1),
(69, 'Lebanon', 'Pounds', 'LBP', '£', 1, 0, 1),
(70, 'Liberia', 'Dollars', 'LRD', '$', 1, 0, 1),
(71, 'Liechtenstein', 'Switzerland Francs', 'CHF', 'CHF', 0.980752, 0, 1),
(72, 'Lithuania', 'Litai', 'LTL', 'Lt', 1, 0, 1),
(73, 'Luxembourg', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(74, 'Macedonia', 'Denars', 'MKD', 'ден', 1, 0, 1),
(75, 'Malaysia', 'Ringgits', 'MYR', 'RM', 4.139749, 0, 1),
(76, 'Malta', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(77, 'Mauritius', 'Rupees', 'MUR', '₨', 1, 0, 1),
(78, 'Mexico', 'Pesos', 'MXN', '$', 18.585695, 0, 1),
(79, 'Mongolia', 'Tugriks', 'MNT', '₮', 1, 0, 1),
(80, 'Mozambique', 'Meticais', 'MZN', 'MT', 1, 0, 1),
(81, 'Namibia', 'Dollars', 'NAD', '$', 1, 0, 1),
(82, 'Nepal', 'Rupees', 'NPR', '₨', 1, 0, 1),
(83, 'Netherlands Antilles', 'Guilders', 'ANG', 'ƒ', 1, 0, 1),
(84, 'Netherlands', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(85, 'New Zealand', 'Dollars', 'NZD', '$', 1.553574, 0, 1),
(86, 'Nicaragua', 'Cordobas', 'NIO', 'C$', 1, 0, 1),
(87, 'Nigeria', 'Nairas', 'NGN', '₦', 1, 0, 1),
(88, 'North Korea', 'Won', 'KPW', '₩', 1, 0, 1),
(89, 'Norway', 'Krone', 'NOK', 'kr', 9.253793, 0, 1),
(90, 'Oman', 'Rials', 'OMR', '﷼', 1, 0, 1),
(91, 'Pakistan', 'Rupees', 'PKR', '₨', 154.392233, 0, 1),
(92, 'Panama', 'Balboa', 'PAB', 'B/.', 1, 0, 1),
(93, 'Paraguay', 'Guarani', 'PYG', 'Gs', 6626, 0, 1),
(94, 'Peru', 'Nuevos Soles', 'PEN', 'S/.', 3.383275, 0, 1),
(95, 'Philippines', 'Pesos', 'PHP', 'Php', 50.525693, 0, 1),
(96, 'Poland', 'Zlotych', 'PLN', 'zł', 3.917289, 0, 1),
(97, 'Qatar', 'Rials', 'QAR', '﷼', 1, 0, 1),
(98, 'Romania', 'New Lei', 'RON', 'lei', 4.396745, 0, 1),
(99, 'Russia', 'Rubles', 'RUB', 'руб', 63.537178, 0, 1),
(100, 'Saint Helena', 'Pounds', 'SHP', '£', 1, 0, 1),
(101, 'Saudi Arabia', 'Riyals', 'SAR', '﷼', 3.75061, 0, 1),
(102, 'Serbia', 'Dinars', 'RSD', 'Дин.', 1, 0, 1),
(103, 'Seychelles', 'Rupees', 'SCR', '₨', 1, 0, 1),
(104, 'Singapore', 'Dollars', 'SGD', '$', 1.390516, 0, 1),
(105, 'Slovenia', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(106, 'Solomon Islands', 'Dollars', 'SBD', '$', 1, 0, 1),
(107, 'Somalia', 'Shillings', 'SOS', 'S', 1, 0, 1),
(108, 'South Africa', 'Rand', 'ZAR', 'R', 14.88117, 0, 1),
(109, 'South Korea', 'Won', 'KRW', '₩', 1183.94149, 0, 1),
(110, 'Spain', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(111, 'Sri Lanka', 'Rupees', 'LKR', '₨', 1, 0, 1),
(112, 'Sweden', 'Kronor', 'SEK', 'kr', 9.694847, 0, 1),
(113, 'Switzerland', 'Francs', 'CHF', 'CHF', 0.980752, 0, 1),
(114, 'Suriname', 'Dollars', 'SRD', '$', 1, 0, 1),
(115, 'Syria', 'Pounds', 'SYP', '£', 1, 0, 1),
(116, 'Taiwan', 'New Dollars', 'TWD', 'NT$', 30.0056, 0, 1),
(117, 'Thailand', 'Baht', 'THB', '฿', 31.163295, 0, 1),
(118, 'Trinidad and Tobago', 'Dollars', 'TTD', 'TT$', 1, 0, 1),
(119, 'Turkey', 'Lira', 'TRY', 'TL', 6.053817, 0, 1),
(120, 'Turkey', 'Liras', 'TRL', '£', 1, 0, 1),
(121, 'Tuvalu', 'Dollars', 'TVD', '$', 1, 0, 1),
(122, 'Ukraine', 'Hryvnia', 'UAH', '₴', 24.336642, 0, 1),
(123, 'United Kingdom', 'Pounds', 'GBP', '£', 83, 0, 1),
(124, 'United States of America', 'Dollars', 'USD', '$', 1, 0, 1),
(125, 'Uruguay', 'Pesos', 'UYU', '$U', 37.880896, 0, 1),
(126, 'Uzbekistan', 'Sums', 'UZS', 'лв', 1, 0, 1),
(127, 'Vatican City', 'Euro', 'EUR', '€', 0.922379, 0, 1),
(128, 'Venezuela', 'Bolivares Fuertes', 'VEF', 'Bs', 1, 0, 1),
(129, 'Vietnam', 'Dong', 'VND', '₫', 1, 0, 1),
(130, 'Yemen', 'Rials', 'YER', '﷼', 1, 0, 1),
(131, 'Zimbabwe', 'Zimbabwe Dollars', 'ZWD', 'Z$', 1, 0, 1),
(132, 'Bangladesh', 'Taka', 'BDT', '৳', 83, 0, 1);

-- --------------------------------------------------------

--
-- Table structure for table `download_link`
--

CREATE TABLE `download_link` (
  `download_link_id` int(11) NOT NULL,
  `videos_id` int(11) DEFAULT NULL,
  `link_title` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `resolution` varchar(50) COLLATE utf8mb4_unicode_520_ci NOT NULL DEFAULT '720p',
  `file_size` varchar(50) COLLATE utf8mb4_unicode_520_ci NOT NULL DEFAULT '00MB',
  `download_url` varchar(500) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `in_app_download` tinyint(1) NOT NULL DEFAULT 0
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `episodes`
--

CREATE TABLE `episodes` (
  `episodes_id` int(11) NOT NULL,
  `stream_key` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `videos_id` int(11) DEFAULT NULL,
  `seasons_id` int(11) DEFAULT NULL,
  `episodes_name` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `file_source` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `source_type` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `file_url` varchar(500) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `order` int(50) NOT NULL DEFAULT 0,
  `date_added` datetime NOT NULL DEFAULT '2019-01-01 00:00:00',
  `last_ep_added` datetime NOT NULL DEFAULT '2019-01-01 00:00:00'
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `episode_download_link`
--

CREATE TABLE `episode_download_link` (
  `episode_download_link_id` int(11) NOT NULL,
  `videos_id` int(11) DEFAULT NULL,
  `season_id` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `link_title` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `resolution` varchar(50) COLLATE utf8mb4_unicode_520_ci NOT NULL DEFAULT '720p',
  `file_size` varchar(50) COLLATE utf8mb4_unicode_520_ci NOT NULL DEFAULT '00MB',
  `download_url` varchar(500) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `in_app_download` tinyint(1) NOT NULL DEFAULT 0
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `genre`
--

CREATE TABLE `genre` (
  `genre_id` int(11) NOT NULL,
  `name` varchar(20) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `description` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `slug` varchar(128) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `publication` int(1) NOT NULL,
  `featured` int(2) DEFAULT 0
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `genre`
--

INSERT INTO `genre` (`genre_id`, `name`, `description`, `slug`, `publication`, `featured`) VALUES
(62, 'Action', 'Action Movie', 'action', 1, 1),
(63, 'Comedy', 'Comedy Movies', 'comedy', 1, 1),
(64, 'Crime', 'Crime Movies', 'crime', 1, 0),
(65, 'Documentary', 'Documentary Movies', 'documentary', 1, 0),
(66, 'Drama', '', 'drama', 1, 0),
(67, 'Family', 'Family', 'family', 1, 0),
(68, 'Fantasy', 'Fantasy Movies', 'fantasy', 1, 0),
(69, 'History', '', 'history', 1, 0),
(70, 'Horror', 'Horror Movies', 'horror', 1, 1),
(71, 'Thriller', '', 'thriller', 1, 1),
(72, ' Romance', ' Romance', 'romance', 1, 0),
(73, ' Adventure', ' Adventure', 'adventure', 1, 0),
(74, '', '', '', 1, 0);

-- --------------------------------------------------------

--
-- Table structure for table `homepage_sections`
--

CREATE TABLE `homepage_sections` (
  `id` int(11) NOT NULL,
  `title` varchar(255) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `content_type` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `layout` tinyint(4) DEFAULT NULL,
  `order` tinyint(4) DEFAULT 0,
  `genre_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `homepage_sections`
--

INSERT INTO `homepage_sections` (`id`, `title`, `content_type`, `layout`, `order`, `genre_id`) VALUES
(1, 'Latest Episodes', 'latest_episodes', NULL, 10, NULL),
(2, 'Latest Movies', 'latest_movies', NULL, 4, NULL),
(3, 'Latest Series', 'latest_tvseries', NULL, 5, NULL),
(4, 'Popular Movies', 'popular_movies', NULL, 7, NULL),
(5, 'Popular Tv Series', 'popular_tv_series', NULL, 8, NULL),
(6, 'Live TV', 'live_tv_list', NULL, 1, NULL),
(7, 'Popular Actor', 'popular_actors', NULL, 2, NULL),
(8, 'Animation', 'genre', NULL, 3, 5);

-- --------------------------------------------------------

--
-- Table structure for table `keys`
--

CREATE TABLE `keys` (
  `id` int(11) NOT NULL,
  `label` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT 'System',
  `key` varchar(40) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `level` int(2) NOT NULL,
  `ignore_limits` tinyint(1) NOT NULL DEFAULT 0,
  `is_private_key` tinyint(1) NOT NULL DEFAULT 0,
  `ip_addresses` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `date_created` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `keys`
--

INSERT INTO `keys` (`id`, `label`, `key`, `level`, `ignore_limits`, `is_private_key`, `ip_addresses`, `date_created`) VALUES
(1, 'Default', '0334c0755f4d448', 1, 0, 0, NULL, 1582700749);

-- --------------------------------------------------------

--
-- Table structure for table `language`
--

CREATE TABLE `language` (
  `language_id` int(11) NOT NULL,
  `name` varchar(60) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `description` varchar(25) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `slug` varchar(128) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `publication` int(11) NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `language`
--

INSERT INTO `language` (`language_id`, `name`, `description`, `slug`, `publication`) VALUES
(1, 'English', 'English', 'english', 1);

-- --------------------------------------------------------

--
-- Table structure for table `languages_iso`
--

CREATE TABLE `languages_iso` (
  `id` int(10) UNSIGNED NOT NULL,
  `name` char(49) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `iso` char(2) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `languages_iso`
--

INSERT INTO `languages_iso` (`id`, `name`, `iso`) VALUES
(1, 'English', 'en'),
(2, 'Afar', 'aa'),
(3, 'Abkhazian', 'ab'),
(4, 'Afrikaans', 'af'),
(5, 'Amharic', 'am'),
(6, 'Arabic', 'ar'),
(7, 'Assamese', 'as'),
(8, 'Aymara', 'ay'),
(9, 'Azerbaijani', 'az'),
(10, 'Bashkir', 'ba'),
(11, 'Belarusian', 'be'),
(12, 'Bulgarian', 'bg'),
(13, 'Bihari', 'bh'),
(14, 'Bislama', 'bi'),
(15, 'Bangla', 'bn'),
(16, 'Tibetan', 'bo'),
(17, 'Breton', 'br'),
(18, 'Catalan', 'ca'),
(19, 'Corsican', 'co'),
(20, 'Czech', 'cs'),
(21, 'Welsh', 'cy'),
(22, 'Danish', 'da'),
(23, 'German', 'de'),
(24, 'Bhutani', 'dz'),
(25, 'Greek', 'el'),
(26, 'Esperanto', 'eo'),
(27, 'Spanish', 'es'),
(28, 'Estonian', 'et'),
(29, 'Basque', 'eu'),
(30, 'Persian', 'fa'),
(31, 'Finnish', 'fi'),
(32, 'Fiji', 'fj'),
(33, 'Faeroese', 'fo'),
(34, 'French', 'fr'),
(35, 'Frisian', 'fy'),
(36, 'Irish', 'ga'),
(37, 'Scots/Gaelic', 'gd'),
(38, 'Galician', 'gl'),
(39, 'Guarani', 'gn'),
(40, 'Gujarati', 'gu'),
(41, 'Hausa', 'ha'),
(42, 'Hindi', 'hi'),
(43, 'Croatian', 'hr'),
(44, 'Hungarian', 'hu'),
(45, 'Armenian', 'hy'),
(46, 'Interlingua', 'ia'),
(47, 'Interlingue', 'ie'),
(48, 'Inupiak', 'ik'),
(49, 'Indonesian', 'in'),
(50, 'Icelandic', 'is'),
(51, 'Italian', 'it'),
(52, 'Hebrew', 'iw'),
(53, 'Japanese', 'ja'),
(54, 'Yiddish', 'ji'),
(55, 'Javanese', 'jw'),
(56, 'Georgian', 'ka'),
(57, 'Kazakh', 'kk'),
(58, 'Greenlandic', 'kl'),
(59, 'Cambodian', 'km'),
(60, 'Kannada', 'kn'),
(61, 'Korean', 'ko'),
(62, 'Kashmiri', 'ks'),
(63, 'Kurdish', 'ku'),
(64, 'Kirghiz', 'ky'),
(65, 'Latin', 'la'),
(66, 'Lingala', 'ln'),
(67, 'Laothian', 'lo'),
(68, 'Lithuanian', 'lt'),
(69, 'Latvian/Lettish', 'lv'),
(70, 'Malagasy', 'mg'),
(71, 'Maori', 'mi'),
(72, 'Macedonian', 'mk'),
(73, 'Malayalam', 'ml'),
(74, 'Mongolian', 'mn'),
(75, 'Moldavian', 'mo'),
(76, 'Marathi', 'mr'),
(77, 'Malay', 'ms'),
(78, 'Maltese', 'mt'),
(79, 'Burmese', 'my'),
(80, 'Nauru', 'na'),
(81, 'Nepali', 'ne'),
(82, 'Dutch', 'nl'),
(83, 'Norwegian', 'no'),
(84, 'Occitan', 'oc'),
(85, '(Afan)/Oromoor/Oriya', 'om'),
(86, 'Punjabi', 'pa'),
(87, 'Polish', 'pl'),
(88, 'Pashto/Pushto', 'ps'),
(89, 'Portuguese', 'pt'),
(90, 'Quechua', 'qu'),
(91, 'Rhaeto-Romance', 'rm'),
(92, 'Kirundi', 'rn'),
(93, 'Romanian', 'ro'),
(94, 'Russian', 'ru'),
(95, 'Kinyarwanda', 'rw'),
(96, 'Sanskrit', 'sa'),
(97, 'Sindhi', 'sd'),
(98, 'Sangro', 'sg'),
(99, 'Serbo-Croatian', 'sh'),
(100, 'Singhalese', 'si'),
(101, 'Slovak', 'sk'),
(102, 'Slovenian', 'sl'),
(103, 'Samoan', 'sm'),
(104, 'Shona', 'sn'),
(105, 'Somali', 'so'),
(106, 'Albanian', 'sq'),
(107, 'Serbian', 'sr'),
(108, 'Siswati', 'ss'),
(109, 'Sesotho', 'st'),
(110, 'Sundanese', 'su'),
(111, 'Swedish', 'sv'),
(112, 'Swahili', 'sw'),
(113, 'Tamil', 'ta'),
(114, 'Telugu', 'te'),
(115, 'Tajik', 'tg'),
(116, 'Thai', 'th'),
(117, 'Tigrinya', 'ti'),
(118, 'Turkmen', 'tk'),
(119, 'Tagalog', 'tl'),
(120, 'Setswana', 'tn'),
(121, 'Tonga', 'to'),
(122, 'Turkish', 'tr'),
(123, 'Tsonga', 'ts'),
(124, 'Tatar', 'tt'),
(125, 'Twi', 'tw'),
(126, 'Ukrainian', 'uk'),
(127, 'Urdu', 'ur'),
(128, 'Uzbek', 'uz'),
(129, 'Vietnamese', 'vi'),
(130, 'Volapuk', 'vo'),
(131, 'Wolof', 'wo'),
(132, 'Xhosa', 'xh'),
(133, 'Yoruba', 'yo'),
(134, 'Chinese', 'zh'),
(135, 'Zulu', 'zu');

-- --------------------------------------------------------

--
-- Table structure for table `language_list`
--

CREATE TABLE `language_list` (
  `id` int(11) NOT NULL,
  `name` varchar(255) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `short_form` varchar(255) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `language_code` varchar(100) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `folder_name` varchar(255) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `text_direction` varchar(50) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `status` int(11) NOT NULL DEFAULT 1,
  `language_order` int(11) NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `language_list`
--

INSERT INTO `language_list` (`id`, `name`, `short_form`, `language_code`, `folder_name`, `text_direction`, `status`, `language_order`) VALUES
(1, 'English', 'en', 'en_us', 'english', 'ltr', 1, 1);

-- --------------------------------------------------------

--
-- Table structure for table `live_tv`
--

CREATE TABLE `live_tv` (
  `live_tv_id` int(11) NOT NULL,
  `tv_name` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `seo_title` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `live_tv_category_id` int(50) DEFAULT NULL,
  `slug` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `language` varchar(10) COLLATE utf8mb4_unicode_520_ci DEFAULT 'en',
  `stream_from` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `stream_label` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `stream_url` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `poster` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `thumbnail` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `focus_keyword` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `meta_description` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `featured` int(2) DEFAULT 1,
  `is_paid` int(5) NOT NULL DEFAULT 1,
  `tags` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `description` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `publish` int(10) UNSIGNED DEFAULT 0
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `live_tv_category`
--

CREATE TABLE `live_tv_category` (
  `live_tv_category_id` int(11) NOT NULL,
  `live_tv_category` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `slug` mediumtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `live_tv_category_desc` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `status` int(11) DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `live_tv_category`
--

INSERT INTO `live_tv_category` (`live_tv_category_id`, `live_tv_category`, `slug`, `live_tv_category_desc`, `status`) VALUES
(1, 'TEST', 'test', 'TEST', 1);

-- --------------------------------------------------------

--
-- Table structure for table `live_tv_url`
--

CREATE TABLE `live_tv_url` (
  `live_tv_url_id` int(11) NOT NULL,
  `stream_key` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `live_tv_id` int(11) DEFAULT NULL,
  `url_for` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `source` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `label` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `quality` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `url` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `live_tv_url`
--

-- --------------------------------------------------------

--
-- Table structure for table `logs`
--

CREATE TABLE `logs` (
  `id` int(11) NOT NULL,
  `uri` varchar(255) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `method` varchar(6) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `params` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `api_key` varchar(40) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `ip_address` varchar(45) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `time` int(11) NOT NULL,
  `rtime` float DEFAULT NULL,
  `authorized` varchar(1) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `response_code` smallint(3) DEFAULT 0
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `page`
--

CREATE TABLE `page` (
  `page_id` int(11) NOT NULL,
  `page_title` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `seo_title` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `slug` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `content` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `primary_menu` int(10) DEFAULT 0,
  `footer_menu` int(10) DEFAULT 0,
  `focus_keyword` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `meta_description` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `publication` int(11) DEFAULT 1,
  `publish_at` datetime DEFAULT NULL,
  `deletable` int(1) NOT NULL DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `plan`
--

CREATE TABLE `plan` (
  `plan_id` int(11) NOT NULL,
  `name` longtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `day` int(50) DEFAULT 0,
  `screens` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `price` longtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `status` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `plan`
--

INSERT INTO `plan` (`plan_id`, `name`, `day`, `screens`, `price`, `status`) VALUES
(1, 'Basic', 7, NULL, '5', 1),
(2, 'Professional ', 30, NULL, '10', 1),
(3, 'Ultra', 90, NULL, '20', 1);

-- --------------------------------------------------------

--
-- Table structure for table `posts`
--

CREATE TABLE `posts` (
  `posts_id` int(11) NOT NULL,
  `post_title` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `seo_title` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `slug` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `focus_keyword` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `meta_description` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `category_id` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `content` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `image_link` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `user_id` int(20) DEFAULT 1,
  `post_at` datetime DEFAULT NULL,
  `publication` int(11) DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `post_category`
--

CREATE TABLE `post_category` (
  `post_category_id` int(11) NOT NULL,
  `category` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `slug` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `category_desc` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `post_comments`
--

CREATE TABLE `post_comments` (
  `post_comments_id` int(20) NOT NULL,
  `user_id` int(10) NOT NULL,
  `post_id` int(20) NOT NULL,
  `comment_type` int(5) NOT NULL DEFAULT 1,
  `replay_for` int(10) DEFAULT 0,
  `comment` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `comment_at` datetime DEFAULT NULL,
  `publication` int(5) DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `quality`
--

CREATE TABLE `quality` (
  `quality_id` int(10) NOT NULL,
  `quality` varchar(100) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `description` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `status` int(5) DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `quality`
--

INSERT INTO `quality` (`quality_id`, `quality`, `description`, `status`) VALUES
(1, '4K', 'High Defination', 1),
(2, 'HD', 'Sandard Defination', 1),
(3, 'SD', 'Ultra High Defination', 1),
(4, 'CAM', 'Web Camera Video', 1),
(7, 'LQ', 'Low Quality', 1),
(8, 'DVD', 'Digital Video Device', 1);

-- --------------------------------------------------------

--
-- Table structure for table `rating`
--

CREATE TABLE `rating` (
  `rating_id` int(50) NOT NULL,
  `video_id` int(11) NOT NULL,
  `ip` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `rating` int(5) DEFAULT NULL,
  `datetime` datetime DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `report`
--

CREATE TABLE `report` (
  `report_id` int(11) NOT NULL,
  `type` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `id` int(50) DEFAULT NULL,
  `issue` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `report_datetime` datetime DEFAULT current_timestamp(),
  `message` text COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `status` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT 'pending'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `request`
--

CREATE TABLE `request` (
  `request_id` int(11) NOT NULL,
  `name` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `email` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `movie_name` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `message` text COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `request_datetime` datetime DEFAULT current_timestamp(),
  `status` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT 'pending'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `rest_logins`
--

CREATE TABLE `rest_logins` (
  `id` int(11) NOT NULL,
  `username` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `password` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `status` int(11) NOT NULL DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `rest_logins`
--

INSERT INTO `rest_logins` (`id`, `username`, `password`, `status`) VALUES
(1, 'admin', 'e9b40ee66261f01', 1);

-- --------------------------------------------------------

--
-- Table structure for table `seasons`
--

CREATE TABLE `seasons` (
  `seasons_id` int(11) NOT NULL,
  `videos_id` int(11) DEFAULT NULL,
  `seasons_name` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `order` int(50) NOT NULL DEFAULT 0,
  `publish` int(11) DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `slider`
--

CREATE TABLE `slider` (
  `slider_id` int(11) NOT NULL,
  `title` varchar(150) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `description` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `video_link` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `image_link` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `slug` varchar(150) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `action_type` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `action_btn_text` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `action_id` int(50) DEFAULT NULL,
  `action_url` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `order` int(50) NOT NULL DEFAULT 0,
  `publication` int(1) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `star`
--

CREATE TABLE `star` (
  `star_id` int(10) NOT NULL,
  `star_type` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `star_name` varchar(200) CHARACTER SET utf8 DEFAULT NULL,
  `slug` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `star_desc` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `view` int(11) NOT NULL DEFAULT 1,
  `status` int(11) NOT NULL DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `subscription`
--

CREATE TABLE `subscription` (
  `subscription_id` int(50) NOT NULL,
  `plan_id` int(50) NOT NULL,
  `user_id` int(50) NOT NULL,
  `price_amount` double NOT NULL,
  `paid_amount` float NOT NULL,
  `currency` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT 'USD',
  `timestamp_from` int(50) NOT NULL,
  `timestamp_to` int(50) NOT NULL,
  `payment_method` mediumtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `transaction_id` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `payment_info` longtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `payment_timestamp` int(50) NOT NULL,
  `recurring` int(10) NOT NULL DEFAULT 1,
  `status` int(5) NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `subtitle`
--

CREATE TABLE `subtitle` (
  `subtitle_id` int(11) NOT NULL,
  `videos_id` int(50) NOT NULL,
  `video_file_id` int(50) DEFAULT NULL,
  `language` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `kind` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `src` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `srclang` varchar(5) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `common` int(2) DEFAULT 0,
  `status` int(2) DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `tvseries_subtitle`
--

CREATE TABLE `tvseries_subtitle` (
  `tvseries_subtitle_id` int(11) NOT NULL,
  `videos_id` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `episodes_id` int(250) DEFAULT NULL,
  `language` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `kind` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `src` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `srclang` varchar(5) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `common` int(2) DEFAULT 0,
  `status` int(2) DEFAULT 1
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `user`
--

CREATE TABLE `user` (
  `user_id` int(11) NOT NULL,
  `name` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `slug` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `username` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `email` longtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `is_password_set` int(5) NOT NULL DEFAULT 0 COMMENT '0 = unknown, 1=set, 2 =unset',
  `password` longtext COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `gender` int(2) DEFAULT 1,
  `role` varchar(100) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `token` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `theme` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT 'default',
  `theme_color` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT '#16163F',
  `join_date` datetime DEFAULT NULL,
  `last_login` datetime DEFAULT NULL,
  `deactivate_reason` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `phone` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `dob` date DEFAULT '0000-00-00',
  `firebase_auth_uid` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `status` int(10) NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `user`
--

INSERT INTO `user` (`user_id`, `name`, `slug`, `username`, `email`, `is_password_set`, `password`, `gender`, `role`, `token`, `theme`, `theme_color`, `join_date`, `last_login`, `deactivate_reason`, `phone`, `dob`, `firebase_auth_uid`, `status`) VALUES
(1, 'TRC4 SXT', '', 'trc4@usa.com', 'trc4@usa.com', 0, 'e10adc3949ba59abbe56e057f20f883e', 1, 'admin', NULL, 'default', '#16163F', '2023-10-23 12:57:18', '2023-10-23 14:07:03', NULL, NULL, '0000-00-00', NULL, 1);

-- --------------------------------------------------------

--
-- Table structure for table `videos`
--

CREATE TABLE `videos` (
  `videos_id` int(11) NOT NULL,
  `imdbid` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `tmdbid` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `title` varchar(150) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `seo_title` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `slug` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `description` longtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `stars` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT '',
  `director` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `writer` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `rating` varchar(5) COLLATE utf8mb4_unicode_520_ci DEFAULT '0',
  `release` varchar(25) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `country` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `genre` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `language` varchar(255) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `video_type` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `runtime` varchar(10) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `video_quality` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT 'HD',
  `is_paid` int(5) NOT NULL DEFAULT 1,
  `publication` int(5) DEFAULT NULL,
  `trailer` int(5) DEFAULT 0,
  `trailler_youtube_source` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `enable_download` int(5) DEFAULT 1,
  `focus_keyword` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `meta_description` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `tags` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `imdb_rating` varchar(5) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `is_tvseries` int(11) NOT NULL DEFAULT 0,
  `total_rating` int(50) DEFAULT 1,
  `today_view` int(250) DEFAULT 0,
  `weekly_view` int(250) DEFAULT 0,
  `monthly_view` int(250) DEFAULT 0,
  `total_view` int(250) DEFAULT 1,
  `last_ep_added` datetime DEFAULT '2019-04-04 00:00:00'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;


-- --------------------------------------------------------

--
-- Table structure for table `video_file`
--

CREATE TABLE `video_file` (
  `video_file_id` int(11) NOT NULL,
  `stream_key` varchar(50) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `videos_id` int(11) DEFAULT NULL,
  `file_source` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `source_type` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `file_url` varchar(500) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `label` varchar(250) COLLATE utf8mb4_unicode_520_ci NOT NULL DEFAULT 'Server#1',
  `order` int(50) NOT NULL DEFAULT 0
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

-- --------------------------------------------------------

--
-- Table structure for table `video_type`
--

CREATE TABLE `video_type` (
  `video_type_id` int(11) NOT NULL,
  `video_type` varchar(200) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `video_type_desc` mediumtext COLLATE utf8mb4_unicode_520_ci DEFAULT NULL,
  `primary_menu` int(11) DEFAULT NULL,
  `footer_menu` int(11) DEFAULT NULL,
  `slug` varchar(250) COLLATE utf8mb4_unicode_520_ci DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Dumping data for table `video_type`
--

INSERT INTO `video_type` (`video_type_id`, `video_type`, `video_type_desc`, `primary_menu`, `footer_menu`, `slug`) VALUES
(1, 'Trending', '', NULL, NULL, 'trending'),
(2, 'Trending2', '', NULL, NULL, 'trending2');

-- --------------------------------------------------------

--
-- Table structure for table `wish_list`
--

CREATE TABLE `wish_list` (
  `wish_list_id` int(11) NOT NULL,
  `wish_list_type` varchar(200) COLLATE utf8mb4_unicode_520_ci NOT NULL,
  `user_id` int(11) DEFAULT NULL,
  `videos_id` int(11) DEFAULT NULL,
  `create_at` datetime DEFAULT NULL,
  `status` int(11) DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_520_ci;

--
-- Indexes for dumped tables
--

--
-- Indexes for table `ads`
--
ALTER TABLE `ads`
  ADD PRIMARY KEY (`ads_id`);

--
-- Indexes for table `calendar`
--
ALTER TABLE `calendar`
  ADD PRIMARY KEY (`timezone`);

--
-- Indexes for table `ci_sessions`
--
ALTER TABLE `ci_sessions`
  ADD KEY `ci_sessions_timestamp` (`timestamp`);

--
-- Indexes for table `comments`
--
ALTER TABLE `comments`
  ADD PRIMARY KEY (`comments_id`);

--
-- Indexes for table `config`
--
ALTER TABLE `config`
  ADD PRIMARY KEY (`config_id`);

--
-- Indexes for table `country`
--
ALTER TABLE `country`
  ADD PRIMARY KEY (`country_id`);

--
-- Indexes for table `cron`
--
ALTER TABLE `cron`
  ADD PRIMARY KEY (`cron_id`);

--
-- Indexes for table `currency`
--
ALTER TABLE `currency`
  ADD PRIMARY KEY (`currency_id`);

--
-- Indexes for table `download_link`
--
ALTER TABLE `download_link`
  ADD PRIMARY KEY (`download_link_id`);

--
-- Indexes for table `episodes`
--
ALTER TABLE `episodes`
  ADD PRIMARY KEY (`episodes_id`);

--
-- Indexes for table `episode_download_link`
--
ALTER TABLE `episode_download_link`
  ADD PRIMARY KEY (`episode_download_link_id`);

--
-- Indexes for table `genre`
--
ALTER TABLE `genre`
  ADD PRIMARY KEY (`genre_id`);

--
-- Indexes for table `homepage_sections`
--
ALTER TABLE `homepage_sections`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `keys`
--
ALTER TABLE `keys`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `languages_iso`
--
ALTER TABLE `languages_iso`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `language_list`
--
ALTER TABLE `language_list`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `live_tv`
--
ALTER TABLE `live_tv`
  ADD PRIMARY KEY (`live_tv_id`);

--
-- Indexes for table `live_tv_category`
--
ALTER TABLE `live_tv_category`
  ADD PRIMARY KEY (`live_tv_category_id`);

--
-- Indexes for table `live_tv_url`
--
ALTER TABLE `live_tv_url`
  ADD PRIMARY KEY (`live_tv_url_id`);

--
-- Indexes for table `page`
--
ALTER TABLE `page`
  ADD PRIMARY KEY (`page_id`);

--
-- Indexes for table `plan`
--
ALTER TABLE `plan`
  ADD PRIMARY KEY (`plan_id`);

--
-- Indexes for table `posts`
--
ALTER TABLE `posts`
  ADD PRIMARY KEY (`posts_id`);

--
-- Indexes for table `post_category`
--
ALTER TABLE `post_category`
  ADD PRIMARY KEY (`post_category_id`);

--
-- Indexes for table `post_comments`
--
ALTER TABLE `post_comments`
  ADD PRIMARY KEY (`post_comments_id`);

--
-- Indexes for table `quality`
--
ALTER TABLE `quality`
  ADD PRIMARY KEY (`quality_id`);

--
-- Indexes for table `rating`
--
ALTER TABLE `rating`
  ADD PRIMARY KEY (`rating_id`);

--
-- Indexes for table `report`
--
ALTER TABLE `report`
  ADD PRIMARY KEY (`report_id`);

--
-- Indexes for table `request`
--
ALTER TABLE `request`
  ADD PRIMARY KEY (`request_id`);

--
-- Indexes for table `rest_logins`
--
ALTER TABLE `rest_logins`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `seasons`
--
ALTER TABLE `seasons`
  ADD PRIMARY KEY (`seasons_id`);

--
-- Indexes for table `slider`
--
ALTER TABLE `slider`
  ADD PRIMARY KEY (`slider_id`);

--
-- Indexes for table `star`
--
ALTER TABLE `star`
  ADD PRIMARY KEY (`star_id`);

--
-- Indexes for table `subscription`
--
ALTER TABLE `subscription`
  ADD PRIMARY KEY (`subscription_id`);

--
-- Indexes for table `subtitle`
--
ALTER TABLE `subtitle`
  ADD PRIMARY KEY (`subtitle_id`);

--
-- Indexes for table `tvseries_subtitle`
--
ALTER TABLE `tvseries_subtitle`
  ADD PRIMARY KEY (`tvseries_subtitle_id`);

--
-- Indexes for table `user`
--
ALTER TABLE `user`
  ADD PRIMARY KEY (`user_id`);

--
-- Indexes for table `videos`
--
ALTER TABLE `videos`
  ADD PRIMARY KEY (`videos_id`);

--
-- Indexes for table `video_file`
--
ALTER TABLE `video_file`
  ADD PRIMARY KEY (`video_file_id`);

--
-- Indexes for table `video_type`
--
ALTER TABLE `video_type`
  ADD PRIMARY KEY (`video_type_id`);

--
-- Indexes for table `wish_list`
--
ALTER TABLE `wish_list`
  ADD PRIMARY KEY (`wish_list_id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `ads`
--
ALTER TABLE `ads`
  MODIFY `ads_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=13;

--
-- AUTO_INCREMENT for table `comments`
--
ALTER TABLE `comments`
  MODIFY `comments_id` int(20) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `config`
--
ALTER TABLE `config`
  MODIFY `config_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=251;

--
-- AUTO_INCREMENT for table `country`
--
ALTER TABLE `country`
  MODIFY `country_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=89;

--
-- AUTO_INCREMENT for table `cron`
--
ALTER TABLE `cron`
  MODIFY `cron_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `currency`
--
ALTER TABLE `currency`
  MODIFY `currency_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=133;

--
-- AUTO_INCREMENT for table `download_link`
--
ALTER TABLE `download_link`
  MODIFY `download_link_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `episodes`
--
ALTER TABLE `episodes`
  MODIFY `episodes_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `episode_download_link`
--
ALTER TABLE `episode_download_link`
  MODIFY `episode_download_link_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `genre`
--
ALTER TABLE `genre`
  MODIFY `genre_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=75;

--
-- AUTO_INCREMENT for table `homepage_sections`
--
ALTER TABLE `homepage_sections`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=9;

--
-- AUTO_INCREMENT for table `keys`
--
ALTER TABLE `keys`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT for table `languages_iso`
--
ALTER TABLE `languages_iso`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=136;

--
-- AUTO_INCREMENT for table `language_list`
--
ALTER TABLE `language_list`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT for table `live_tv`
--
ALTER TABLE `live_tv`
  MODIFY `live_tv_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT for table `live_tv_category`
--
ALTER TABLE `live_tv_category`
  MODIFY `live_tv_category_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT for table `live_tv_url`
--
ALTER TABLE `live_tv_url`
  MODIFY `live_tv_url_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- AUTO_INCREMENT for table `page`
--
ALTER TABLE `page`
  MODIFY `page_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `plan`
--
ALTER TABLE `plan`
  MODIFY `plan_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;

--
-- AUTO_INCREMENT for table `posts`
--
ALTER TABLE `posts`
  MODIFY `posts_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `post_category`
--
ALTER TABLE `post_category`
  MODIFY `post_category_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `post_comments`
--
ALTER TABLE `post_comments`
  MODIFY `post_comments_id` int(20) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `quality`
--
ALTER TABLE `quality`
  MODIFY `quality_id` int(10) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=9;

--
-- AUTO_INCREMENT for table `rating`
--
ALTER TABLE `rating`
  MODIFY `rating_id` int(50) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `report`
--
ALTER TABLE `report`
  MODIFY `report_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `request`
--
ALTER TABLE `request`
  MODIFY `request_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `rest_logins`
--
ALTER TABLE `rest_logins`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT for table `seasons`
--
ALTER TABLE `seasons`
  MODIFY `seasons_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `slider`
--
ALTER TABLE `slider`
  MODIFY `slider_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `star`
--
ALTER TABLE `star`
  MODIFY `star_id` int(10) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=11;

--
-- AUTO_INCREMENT for table `subscription`
--
ALTER TABLE `subscription`
  MODIFY `subscription_id` int(50) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `subtitle`
--
ALTER TABLE `subtitle`
  MODIFY `subtitle_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `tvseries_subtitle`
--
ALTER TABLE `tvseries_subtitle`
  MODIFY `tvseries_subtitle_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `user`
--
ALTER TABLE `user`
  MODIFY `user_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- AUTO_INCREMENT for table `videos`
--
ALTER TABLE `videos`
  MODIFY `videos_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT for table `video_file`
--
ALTER TABLE `video_file`
  MODIFY `video_file_id` int(11) NOT NULL AUTO_INCREMENT;

--
-- AUTO_INCREMENT for table `video_type`
--
ALTER TABLE `video_type`
  MODIFY `video_type_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- AUTO_INCREMENT for table `wish_list`
--
ALTER TABLE `wish_list`
  MODIFY `wish_list_id` int(11) NOT NULL AUTO_INCREMENT;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
"
mw9kaE2L,pyautogalaxy pytest,canorve,Bash,Friday 27th of June 2025 11:57:07 PM CDT,"❯ pytest
========================================================= test session starts =========================================================
platform linux -- Python 3.12.2, pytest-7.4.4, pluggy-1.5.0
rootdir: /home/canorve/MyPapers/Revisor/PyAutoGalaxy/PyAutoGalaxy-main
configfile: pyproject.toml
testpaths: test_autogalaxy
plugins: Faker-37.3.0, anyio-4.2.0
collected 417 items                                                                                                                   

test_autogalaxy/test_convert.py ......                                                                                          [  1%]
test_autogalaxy/test_regression.py ...                                                                                          [  2%]
test_autogalaxy/aggregator/test_aggregator_galaxies.py ..                                                                       [  2%]
test_autogalaxy/aggregator/ellipse/test_aggregator_ellipses.py ..                                                               [  3%]
test_autogalaxy/aggregator/ellipse/test_aggregator_fit_ellipse.py ..                                                            [  3%]
test_autogalaxy/aggregator/ellipse/test_aggregator_multipoles.py ..                                                             [  4%]
test_autogalaxy/aggregator/imaging/test_aggregator_fit_imaging.py ....                                                          [  5%]
test_autogalaxy/aggregator/imaging/test_aggregator_imaging.py .                                                                 [  5%]
test_autogalaxy/aggregator/interferometer/test_aggregator_fit_interferometer.py EEE                                             [  5%]
test_autogalaxy/aggregator/interferometer/test_aggregator_interferometer.py F                                                   [  6%]
test_autogalaxy/analysis/test_adapt_images.py .                                                                                 [  6%]
test_autogalaxy/analysis/test_plotter_interface.py ...                                                                          [  7%]
test_autogalaxy/analysis/test_preloads.py ..                                                                                    [  7%]
test_autogalaxy/analysis/test_result.py ...                                                                                     [  8%]
test_autogalaxy/analysis/analysis/test_analysis.py ..                                                                           [  8%]
test_autogalaxy/analysis/analysis/test_analysis_dataset.py .                                                                    [  9%]
test_autogalaxy/cosmology/test_lensing.py .....                                                                                 [ 10%]
test_autogalaxy/cosmology/test_model.py .                                                                                       [ 10%]
test_autogalaxy/ellipse/test_dataset_interp.py ...                                                                              [ 11%]
test_autogalaxy/ellipse/test_fit_ellipse.py ...........                                                                         [ 13%]
test_autogalaxy/ellipse/ellipse/test_ellipse.py ........                                                                        [ 15%]
test_autogalaxy/ellipse/ellipse/test_multipole.py .                                                                             [ 16%]
test_autogalaxy/ellipse/model/test_analysis_ellipse.py ..                                                                       [ 16%]
test_autogalaxy/galaxy/test_galaxies.py ...........                                                                             [ 19%]
test_autogalaxy/galaxy/test_galaxy.py .......................                                                                   [ 24%]
test_autogalaxy/galaxy/test_stellar_dark_decomp.py ....                                                                         [ 25%]
test_autogalaxy/galaxy/test_to_inversion.py ....E.                                                                              [ 27%]
test_autogalaxy/galaxy/plot/test_adapt_plotters.py .                                                                            [ 27%]
test_autogalaxy/galaxy/plot/test_galaxies_plotter.py ...                                                                        [ 28%]
test_autogalaxy/galaxy/plot/test_galaxy_plotters.py .....                                                                       [ 29%]
test_autogalaxy/imaging/test_fit_imaging.py ...........                                                                         [ 31%]
test_autogalaxy/imaging/test_simulate_and_fit_imaging.py ...                                                                    [ 32%]
test_autogalaxy/imaging/test_simulator.py ...                                                                                   [ 33%]
test_autogalaxy/imaging/model/test_analysis_imaging.py ...                                                                      [ 34%]
test_autogalaxy/imaging/model/test_plotter_interface_imaging.py ....                                                            [ 35%]
test_autogalaxy/imaging/model/test_result_imaging.py ...                                                                        [ 35%]
test_autogalaxy/imaging/plot/test_fit_imaging_plotters.py ...                                                                   [ 36%]
test_autogalaxy/interferometer/test_fit_interferometer.py EEEEEE                                                                [ 37%]
test_autogalaxy/interferometer/test_simulate_and_fit_interferometer.py FFF                                                      [ 38%]
test_autogalaxy/interferometer/test_simulator.py FF                                                                             [ 39%]
test_autogalaxy/interferometer/model/test_analysis_interferometer.py EEE                                                        [ 39%]
test_autogalaxy/interferometer/model/test_plotter_interface_interferometer.py EE                                                [ 40%]
test_autogalaxy/interferometer/plot/test_fit_interferometer_plotters.py E                                                       [ 40%]
test_autogalaxy/operate/test_deflections.py .........................                                                           [ 46%]
test_autogalaxy/operate/test_image.py ...E..E.E                                                                                 [ 48%]
test_autogalaxy/plot/mat_wrap/test_get_visuals.py ........                                                                      [ 50%]
test_autogalaxy/plot/mat_wrap/test_mat_obj.py .                                                                                 [ 50%]
test_autogalaxy/profiles/test_basis.py ......                                                                                   [ 52%]
test_autogalaxy/profiles/test_dict.py ..                                                                                        [ 52%]
test_autogalaxy/profiles/test_geometry_profiles.py ......                                                                       [ 54%]
test_autogalaxy/profiles/test_light_and_mass_profiles.py ........                                                               [ 56%]
test_autogalaxy/profiles/test_point_sources.py .                                                                                [ 56%]
test_autogalaxy/profiles/test_radial_minima.py ..                                                                               [ 56%]
test_autogalaxy/profiles/light/test_decorators.py .                                                                             [ 57%]
test_autogalaxy/profiles/light/test_snr.py .                                                                                    [ 57%]
test_autogalaxy/profiles/light/linear/test_abstract.py ..                                                                       [ 57%]
test_autogalaxy/profiles/light/shapelets/test_cartesian.py ..                                                                   [ 58%]
test_autogalaxy/profiles/light/shapelets/test_exponential.py ..                                                                 [ 58%]
test_autogalaxy/profiles/light/shapelets/test_polar.py ..                                                                       [ 59%]
test_autogalaxy/profiles/light/standard/test_abstract.py ....                                                                   [ 60%]
test_autogalaxy/profiles/light/standard/test_chameleon.py .                                                                     [ 60%]
test_autogalaxy/profiles/light/standard/test_dev_vaucouleurs.py .                                                               [ 60%]
test_autogalaxy/profiles/light/standard/test_eff.py ..                                                                          [ 61%]
test_autogalaxy/profiles/light/standard/test_exponential.py .                                                                   [ 61%]
test_autogalaxy/profiles/light/standard/test_gaussian.py .                                                                      [ 61%]
test_autogalaxy/profiles/light/standard/test_moffat.py .                                                                        [ 61%]
test_autogalaxy/profiles/light/standard/test_sersic.py .                                                                        [ 62%]
test_autogalaxy/profiles/light/standard/test_sersic_core.py .                                                                   [ 62%]
test_autogalaxy/profiles/mass/test_scaling_relations.py ..                                                                      [ 62%]
test_autogalaxy/profiles/mass/abstract/test_abstract.py ..........                                                              [ 65%]
test_autogalaxy/profiles/mass/dark/test_abstract.py ............                                                                [ 68%]
test_autogalaxy/profiles/mass/dark/test_gnfw.py .......                                                                         [ 69%]
test_autogalaxy/profiles/mass/dark/test_gnfw_virial_mass_conc.py .                                                              [ 70%]
test_autogalaxy/profiles/mass/dark/test_nfw.py .........                                                                        [ 72%]
test_autogalaxy/profiles/mass/dark/test_nfw_mcr.py ....                                                                         [ 73%]
test_autogalaxy/profiles/mass/dark/test_nfw_scatter.py .                                                                        [ 73%]
test_autogalaxy/profiles/mass/dark/test_nfw_truncated.py ....                                                                   [ 74%]
test_autogalaxy/profiles/mass/dark/test_nfw_truncated_mcr.py ..                                                                 [ 74%]
test_autogalaxy/profiles/mass/dark/test_nfw_truncated_mcr_scatter.py .                                                          [ 75%]
test_autogalaxy/profiles/mass/point/test_point.py .                                                                             [ 75%]
test_autogalaxy/profiles/mass/point/test_smbh.py .                                                                              [ 75%]
test_autogalaxy/profiles/mass/point/test_smbh_binary.py .......                                                                 [ 77%]
test_autogalaxy/profiles/mass/sheets/test_decorators.py .                                                                       [ 77%]
test_autogalaxy/profiles/mass/sheets/test_external_shear.py ...                                                                 [ 78%]
test_autogalaxy/profiles/mass/sheets/test_input_deflections.py .....                                                            [ 79%]
test_autogalaxy/profiles/mass/sheets/test_mass_sheet.py ...                                                                     [ 80%]
test_autogalaxy/profiles/mass/stellar/test_chameleon.py ....                                                                    [ 81%]
test_autogalaxy/profiles/mass/stellar/test_dev_vaucouleurs.py .....                                                             [ 82%]
test_autogalaxy/profiles/mass/stellar/test_exponential.py .....                                                                 [ 83%]
test_autogalaxy/profiles/mass/stellar/test_gaussian.py ......                                                                   [ 84%]
test_autogalaxy/profiles/mass/stellar/test_gaussian_gradient.py .                                                               [ 85%]
test_autogalaxy/profiles/mass/stellar/test_sersic.py .......                                                                    [ 86%]
test_autogalaxy/profiles/mass/stellar/test_sersic_core.py ....                                                                  [ 87%]
test_autogalaxy/profiles/mass/stellar/test_sersic_gradient.py ......                                                            [ 89%]
test_autogalaxy/profiles/mass/total/test_decorators.py .                                                                        [ 89%]
test_autogalaxy/profiles/mass/total/test_dual_pseudo_isothermal.py ..                                                           [ 89%]
test_autogalaxy/profiles/mass/total/test_isothermal.py .....                                                                    [ 91%]
test_autogalaxy/profiles/mass/total/test_isothermal_cored.py ....                                                               [ 92%]
test_autogalaxy/profiles/mass/total/test_power_law.py ....                                                                      [ 93%]
test_autogalaxy/profiles/mass/total/test_power_law_broken.py ...                                                                [ 93%]
test_autogalaxy/profiles/mass/total/test_power_law_cored.py ...                                                                 [ 94%]
test_autogalaxy/profiles/mass/total/test_power_law_multipole.py ...                                                             [ 95%]
test_autogalaxy/profiles/plot/test_basis_plotters.py .                                                                          [ 95%]
test_autogalaxy/profiles/plot/test_light_profile_plotters.py ..                                                                 [ 95%]
test_autogalaxy/profiles/plot/test_mass_profile_plotters.py ..                                                                  [ 96%]
test_autogalaxy/quantity/test_dataset_quantity.py .....                                                                         [ 97%]
test_autogalaxy/quantity/test_fit_quantity.py ..                                                                                [ 98%]
test_autogalaxy/quantity/model/test_analysis_quantity.py ..                                                                     [ 98%]
test_autogalaxy/quantity/model/test_plotter_interface_quantity.py ..                                                            [ 99%]
test_autogalaxy/quantity/plot/test_fit_quantity_plotters.py ..                                                                  [ 99%]
test_autogalaxy/util/test_error_util.py .                                                                                       [ 99%]
test_autogalaxy/util/test_shear_field.py .                                                                                      [100%]

=============================================================== ERRORS ================================================================
_____________________________ ERROR at setup of test__fit_interferometer_randomly_drawn_via_pdf_gen_from ______________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
___________________________________ ERROR at setup of test__fit_interferometer_all_above_weight_gen ___________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
______________________________________ ERROR at setup of test__fit_interferometer__adapt_images _______________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
________________________________________ ERROR at setup of test__inversion_interferometer_from ________________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_____________________________________________ ERROR at setup of test__model_visibilities ______________________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_____________________________________________ ERROR at setup of test__fit_figure_of_merit _____________________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
__________________________________ ERROR at setup of test___fit_figure_of_merit__different_settings ___________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
__________________________________________ ERROR at setup of test___galaxy_model_image_dict ___________________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_______________________________________ ERROR at setup of test___galaxy_model_visibilities_dict _______________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_____________________________________ ERROR at setup of test__model_visibilities_of_galaxies_list _____________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_______________________________ ERROR at setup of test__make_result__result_interferometer_is_returned ________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_______________________ ERROR at setup of test__fit_figure_of_merit__matches_correct_fit_given_galaxy_profiles ________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_______________________________________ ERROR at setup of test__profile_log_likelihood_function _______________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_______________________________________________ ERROR at setup of test__interferometer ________________________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_____________________________________________ ERROR at setup of test__fit_interferometer ______________________________________________

    @pytest.fixture(name=""interferometer_7"")
    def make_interferometer_7():
>       return fixtures.make_interferometer_7()

test_autogalaxy/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
___________________________________________ ERROR at setup of test__fit_sub_plot_real_space ___________________________________________

    @pytest.fixture(name=""fit_interferometer_7x7"")
    def make_fit_interferometer_7x7():
>       return fixtures.make_fit_interferometer_7x7()

test_autogalaxy/conftest.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
autogalaxy/fixtures.py:239: in make_fit_interferometer_7x7
    dataset=make_interferometer_7(),
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:234: in make_interferometer_7
    return aa.Interferometer(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
___________________________________ ERROR at setup of test__visibilities_from_grid_and_transformer ____________________________________

    @pytest.fixture(name=""transformer_7x7_7"")
    def make_transformer_7x7_7():
>       return fixtures.make_transformer_7x7_7()

test_autogalaxy/conftest.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:274: in make_transformer_7x7_7
    return aa.TransformerDFT(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
___________________________________________ ERROR at setup of test__visibilities_list_from ____________________________________________

    @pytest.fixture(name=""transformer_7x7_7"")
    def make_transformer_7x7_7():
>       return fixtures.make_transformer_7x7_7()

test_autogalaxy/conftest.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:274: in make_transformer_7x7_7
    return aa.TransformerDFT(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
________________________________________ ERROR at setup of test__galaxy_visibilities_dict_from ________________________________________

    @pytest.fixture(name=""transformer_7x7_7"")
    def make_transformer_7x7_7():
>       return fixtures.make_transformer_7x7_7()

test_autogalaxy/conftest.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/fixtures.py:274: in make_transformer_7x7_7
    return aa.TransformerDFT(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
============================================================== FAILURES ===============================================================
_____________________________ test__interferometer_generator_from_aggregator__analysis_has_single_dataset _____________________________

visibilities_7 = Visibilities([1.+1.j, 1.+1.j, 1.+1.j, 1.+1.j, 1.+1.j, 1.+1.j, 1.+1.j])
visibilities_noise_map_7 = VisibilitiesNoiseMap([2.+2.j, 2.+2.j, 2.+2.j, 2.+2.j, 2.+2.j, 2.+2.j, 2.+2.j])
uv_wavelengths_7x2 = array([[-55636.4609375 , 171376.90625   ],
       [ -6903.21923828,  51155.578125  ],
       [-63488.4140625 ,   4141....4160.75390625, -99354.1796875 ],
       [ -9327.66308594, -95212.90625   ],
       [     0.        ,      0.        ]])
mask_2d_7x7 = Mask2D([[ True,  True,  True,  True,  True,  True,  True],
       [ True,  True,  True,  True,  True,  True,  True],
 ...],
       [ True,  True,  True,  True,  True,  True,  True],
       [ True,  True,  True,  True,  True,  True,  True]])
samples = MockSamples(2)
model = <Collection dataset_model = DatasetModel (background_sky_level, UniformPrior [991], lower_limit = 0.5, upper_limit = 1...04], lower_limit = 0.0, upper_limit = 30.0), (sersic_index, UniformPrior [1005], lower_limit = 0.8, upper_limit = 5.0)>

    def test__interferometer_generator_from_aggregator__analysis_has_single_dataset(
        visibilities_7,
        visibilities_noise_map_7,
        uv_wavelengths_7x2,
        mask_2d_7x7,
        samples,
        model,
    ):
>       interferometer_7 = ag.Interferometer(
            data=visibilities_7,
            noise_map=visibilities_noise_map_7,
            uv_wavelengths=uv_wavelengths_7x2,
            real_space_mask=mask_2d_7x7,
            transformer_class=ag.TransformerDFT,
        )

test_autogalaxy/aggregator/interferometer/test_aggregator_interferometer.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/dataset.py:88: in __init__
    self.transformer = transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
__________________________________________________ test__perfect_fit__chi_squared_0 ___________________________________________________

    def test__perfect_fit__chi_squared_0():
        grid = ag.Grid2D.uniform(
            shape_native=(51, 51),
            pixel_scales=0.1,
            over_sample_size=1,
        )
    
        galaxy_0 = ag.Galaxy(
            redshift=0.5, light=ag.lp.Sersic(centre=(0.1, 0.1), intensity=0.1)
        )
    
        galaxy_1 = ag.Galaxy(
            redshift=0.5, light=ag.lp.Exponential(centre=(0.1, 0.1), intensity=0.5)
        )
    
        simulator = ag.SimulatorInterferometer(
            uv_wavelengths=np.ones(shape=(7, 2)),
            transformer_class=ag.TransformerDFT,
            exposure_time=300.0,
            noise_if_add_noise_false=1.0,
            noise_sigma=None,
        )
    
>       dataset = simulator.via_galaxies_from(galaxies=[galaxy_0, galaxy_1], grid=grid)

test_autogalaxy/interferometer/test_simulate_and_fit_interferometer.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
autogalaxy/interferometer/simulator.py:36: in via_galaxies_from
    return self.via_image_from(image=image)
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/simulator.py:66: in via_image_from
    transformer = self.transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
____________________________________ test__simulate_interferometer_data_and_fit__known_likelihood _____________________________________

    def test__simulate_interferometer_data_and_fit__known_likelihood():
        mask = ag.Mask2D.circular(
            radius=3.0,
            shape_native=(31, 31),
            pixel_scales=0.2,
        )
    
        grid = ag.Grid2D.from_mask(mask=mask)
    
        galaxy_0 = ag.Galaxy(
            redshift=0.5,
            light=ag.lp.Sersic(centre=(0.1, 0.1), intensity=0.1),
            mass=ag.mp.Isothermal(centre=(0.1, 0.1), einstein_radius=1.8),
        )
    
        pixelization = ag.Pixelization(
            mesh=ag.mesh.Rectangular(shape=(16, 16)),
            regularization=ag.reg.Constant(coefficient=(1.0)),
        )
    
        galaxy_1 = ag.Galaxy(redshift=1.0, pixelization=pixelization)
    
        simulator = ag.SimulatorInterferometer(
            uv_wavelengths=np.ones(shape=(7, 2)),
            transformer_class=ag.TransformerDFT,
            exposure_time=300.0,
            noise_seed=1,
        )
    
>       dataset = simulator.via_galaxies_from(galaxies=[galaxy_0, galaxy_1], grid=grid)

test_autogalaxy/interferometer/test_simulate_and_fit_interferometer.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
autogalaxy/interferometer/simulator.py:36: in via_galaxies_from
    return self.via_image_from(image=image)
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/simulator.py:66: in via_image_from
    transformer = self.transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
___________________________________ test__linear_light_profiles_agree_with_standard_light_profiles ____________________________________

    def test__linear_light_profiles_agree_with_standard_light_profiles():
        grid = ag.Grid2D.uniform(
            shape_native=(51, 51),
            pixel_scales=0.1,
            over_sample_size=1,
        )
    
        galaxy = ag.Galaxy(
            redshift=0.5,
            bulge=ag.lp.Sersic(intensity=0.1, sersic_index=1.0),
            disk=ag.lp.Sersic(intensity=0.2, sersic_index=4.0),
        )
    
        simulator = ag.SimulatorInterferometer(
            uv_wavelengths=np.array(
                [
                    [0.04, 200.0, 0.3, 400000.0, 60000000.0],
                    [0.00003, 500.0, 600000.0, 0.1, 75555555],
                ]
            ),
            transformer_class=ag.TransformerDFT,
            exposure_time=300.0,
            noise_if_add_noise_false=1.0,
            noise_sigma=None,
        )
    
>       dataset = simulator.via_galaxies_from(galaxies=[galaxy], grid=grid)

test_autogalaxy/interferometer/test_simulate_and_fit_interferometer.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
autogalaxy/interferometer/simulator.py:36: in via_galaxies_from
    return self.via_image_from(image=image)
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/simulator.py:66: in via_image_from
    transformer = self.transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
________________________________________________ test__from_plane__same_as_plane_input ________________________________________________

    def test__from_plane__same_as_plane_input():
        grid = ag.Grid2D.uniform(shape_native=(20, 20), pixel_scales=0.05)
    
        galaxy_0 = ag.Galaxy(
            redshift=0.5,
            light=ag.lp.Sersic(intensity=1.0),
            mass=ag.mp.Isothermal(einstein_radius=1.6),
        )
    
        galaxy_1 = ag.Galaxy(redshift=1.0, light=ag.lp.Sersic(intensity=0.3))
    
        galaxies = ag.Galaxies(galaxies=[galaxy_0, galaxy_1])
    
        simulator = ag.SimulatorInterferometer(
            uv_wavelengths=np.ones(shape=(7, 2)),
            exposure_time=10000.0,
            noise_sigma=0.1,
            noise_seed=1,
        )
    
>       dataset = simulator.via_galaxies_from(galaxies=[galaxy_0, galaxy_1], grid=grid)

test_autogalaxy/interferometer/test_simulator.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
autogalaxy/interferometer/simulator.py:36: in via_galaxies_from
    return self.via_image_from(image=image)
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/simulator.py:66: in via_image_from
    transformer = self.transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
_________________________ test__simulate_interferometer_from_galaxy__source_galaxy__compare_to_interferometer _________________________

    def test__simulate_interferometer_from_galaxy__source_galaxy__compare_to_interferometer():
        galaxy_0 = ag.Galaxy(
            redshift=0.5,
            mass=ag.mp.Isothermal(
                centre=(0.0, 0.0), einstein_radius=1.6, ell_comps=(0.17647, 0.0)
            ),
        )
    
        galaxy_1 = ag.Galaxy(
            redshift=0.5,
            light=ag.lp.Sersic(
                centre=(0.1, 0.1),
                ell_comps=(0.096225, -0.055555),
                intensity=0.3,
                effective_radius=1.0,
                sersic_index=2.5,
            ),
        )
    
        grid = ag.Grid2D.uniform(shape_native=(11, 11), pixel_scales=0.05)
    
        simulator = ag.SimulatorInterferometer(
            uv_wavelengths=np.ones(shape=(7, 2)),
            exposure_time=10000.0,
            noise_sigma=0.1,
            noise_seed=1,
        )
    
>       dataset = simulator.via_galaxies_from(galaxies=[galaxy_0, galaxy_1], grid=grid)

test_autogalaxy/interferometer/test_simulator.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
autogalaxy/interferometer/simulator.py:36: in via_galaxies_from
    return self.via_image_from(image=image)
../../../../anaconda3/lib/python3.12/site-packages/autoarray/dataset/interferometer/simulator.py:66: in via_image_from
    transformer = self.transformer_class(
../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:58: in __init__
    pylops_exception()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def pylops_exception():
>       raise ModuleNotFoundError(
            ""\n--------------------\n""
            ""You are attempting to perform interferometer analysis.\n\n""
            ""However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.\n\n""
            ""Install it via the command `pip install pylops==2.3.1`.\n\n""
            ""----------------------""
        )
E       ModuleNotFoundError: 
E       --------------------
E       You are attempting to perform interferometer analysis.
E       
E       However, the optional library PyLops (https://github.com/PyLops/pylops) is not installed.
E       
E       Install it via the command `pip install pylops==2.3.1`.
E       
E       ----------------------

../../../../anaconda3/lib/python3.12/site-packages/autoarray/operators/transformer.py:46: ModuleNotFoundError
========================================================== warnings summary ===========================================================
test_autogalaxy/galaxy/plot/test_galaxy_plotters.py: 36 warnings
test_autogalaxy/profiles/plot/test_light_profile_plotters.py: 3 warnings
test_autogalaxy/profiles/plot/test_mass_profile_plotters.py: 6 warnings
  /home/canorve/anaconda3/lib/python3.12/site-packages/matplotlib/cbook.py:1699: DeprecationWarning: Conversion of an array with ndim > 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)
    return math.isfinite(val)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================================================= short test summary info =======================================================
FAILED test_autogalaxy/aggregator/interferometer/test_aggregator_interferometer.py::test__interferometer_generator_from_aggregator__analysis_has_single_dataset - ModuleNotFoundError: 
FAILED test_autogalaxy/interferometer/test_simulate_and_fit_interferometer.py::test__perfect_fit__chi_squared_0 - ModuleNotFoundError: 
FAILED test_autogalaxy/interferometer/test_simulate_and_fit_interferometer.py::test__simulate_interferometer_data_and_fit__known_likelihood - ModuleNotFoundError: 
FAILED test_autogalaxy/interferometer/test_simulate_and_fit_interferometer.py::test__linear_light_profiles_agree_with_standard_light_profiles - ModuleNotFoundError: 
FAILED test_autogalaxy/interferometer/test_simulator.py::test__from_plane__same_as_plane_input - ModuleNotFoundError: 
FAILED test_autogalaxy/interferometer/test_simulator.py::test__simulate_interferometer_from_galaxy__source_galaxy__compare_to_interferometer - ModuleNotFoundError: 
ERROR test_autogalaxy/aggregator/interferometer/test_aggregator_fit_interferometer.py::test__fit_interferometer_randomly_drawn_via_pdf_gen_from - ModuleNotFoundError: 
ERROR test_autogalaxy/aggregator/interferometer/test_aggregator_fit_interferometer.py::test__fit_interferometer_all_above_weight_gen - ModuleNotFoundError: 
ERROR test_autogalaxy/aggregator/interferometer/test_aggregator_fit_interferometer.py::test__fit_interferometer__adapt_images - ModuleNotFoundError: 
ERROR test_autogalaxy/galaxy/test_to_inversion.py::test__inversion_interferometer_from - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/test_fit_interferometer.py::test__model_visibilities - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/test_fit_interferometer.py::test__fit_figure_of_merit - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/test_fit_interferometer.py::test___fit_figure_of_merit__different_settings - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/test_fit_interferometer.py::test___galaxy_model_image_dict - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/test_fit_interferometer.py::test___galaxy_model_visibilities_dict - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/test_fit_interferometer.py::test__model_visibilities_of_galaxies_list - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/model/test_analysis_interferometer.py::test__make_result__result_interferometer_is_returned - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/model/test_analysis_interferometer.py::test__fit_figure_of_merit__matches_correct_fit_given_galaxy_profiles - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/model/test_analysis_interferometer.py::test__profile_log_likelihood_function - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/model/test_plotter_interface_interferometer.py::test__interferometer - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/model/test_plotter_interface_interferometer.py::test__fit_interferometer - ModuleNotFoundError: 
ERROR test_autogalaxy/interferometer/plot/test_fit_interferometer_plotters.py::test__fit_sub_plot_real_space - ModuleNotFoundError: 
ERROR test_autogalaxy/operate/test_image.py::test__visibilities_from_grid_and_transformer - ModuleNotFoundError: 
ERROR test_autogalaxy/operate/test_image.py::test__visibilities_list_from - ModuleNotFoundError: 
ERROR test_autogalaxy/operate/test_image.py::test__galaxy_visibilities_dict_from - ModuleNotFoundError: 
================================== 6 failed, 392 passed, 45 warnings, 19 errors in 134.74s (0:02:14) ==================================


"
T4VtmJSQ,pyautogalaxy version submitted installation,canorve,Bash,Friday 27th of June 2025 11:46:42 PM CDT,"❯ pip install -e .
Obtaining file:///home/canorve/MyPapers/Revisor/PyAutoGalaxy/PyAutoGalaxy-2025.1.18.7
  Installing build dependencies ... done
  Checking if build backend supports build_editable ... done
  Getting requirements to build editable ... done
  Installing backend dependencies ... done
  Preparing editable metadata (pyproject.toml) ... done
Requirement already satisfied: colossus==1.3.1 in ./pyautogal_venv_submitted/lib/python3.12/site-packages (from autogalaxy==1.0.dev0) (1.3.1)
Requirement already satisfied: astropy<=6.1.2,>=5.0 in ./pyautogal_venv_submitted/lib/python3.12/site-packages (from autogalaxy==1.0.dev0) (6.1.2)
Requirement already satisfied: nautilus-sampler==1.0.4 in ./pyautogal_venv_submitted/lib/python3.12/site-packages (from autogalaxy==1.0.dev0) (1.0.4)
INFO: pip is looking at multiple versions of autogalaxy to determine which version is compatible with other requirements. This could take a while.
ERROR: Could not find a version that satisfies the requirement autoconf==1.0.dev0 (from autogalaxy) (from versions: 0.1.0, 0.1.1, 0.2.0, 0.2.1, 0.2.2, 0.3.0, 0.3.1, 0.4.0, 0.5.0, 0.6.0, 0.6.1, 0.6.2, 0.7.0, 0.7.1, 0.7.2, 0.7.3, 0.7.4, 0.7.5, 0.7.6, 0.7.7, 0.8.0, 0.9.0, 0.10.0, 2021.5.27.1, 2021.6.2.1, 2021.6.4.1, 2021.8.12.1, 2021.9.12.1, 2021.10.14.1, 2022.2.13.1, 2022.2.14.1, 2022.3.18.1, 2022.3.18.2, 2022.3.30.1, 2022.5.2.1, 2022.6.29.1, 2022.6.29.2, 2022.7.10.1, 2022.7.11.1, 2022.11.26.11, 2023.1.15.1, 2023.3.21.2, 2023.3.21.3, 2023.3.21.4, 2023.3.21.5, 2023.3.27.1, 2023.6.12.4, 2023.6.12.5, 2023.6.18.3, 2023.7.5.2, 2023.9.18.4, 2023.10.23.2, 2023.10.23.3, 2024.1.27.4, 2024.5.16.0, 2024.7.16.1, 2024.9.21.1, 2024.9.21.2, 2024.11.6.1, 2024.11.13.2, 2025.1.18.7, 2025.5.7.16, 2025.5.9.11, 2025.5.9.28, 2025.5.9.29, 2025.5.9.36, 2025.5.9.48, 2025.5.10.1)
ERROR: No matching distribution found for autoconf==1.0.dev0


"
j9M9yQrL,mon crtl,Grexxity,Lua,Friday 27th of June 2025 11:00:45 PM CDT,"local modem = peripheral.find(""modem"")
local channel = 42

while true do
    write(""> Command (open/close): "")
    local cmd = read()
    modem.transmit(channel, 0, cmd)
end
"
4mJt6ZNt,Untitled,Azzz_4565,Java,Friday 27th of June 2025 10:03:20 PM CDT,"-- HYBRID Ultra-Performance Instant Respawn System
-- Combining speed optimization with bulletproof reliability

local Players = game:GetService(""Players"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local RunService = game:GetService(""RunService"")
local LocalPlayer = Players.LocalPlayer

-- Performance optimizations
local taskSpawn = task.spawn
local taskWait = task.wait
local tick = tick

-- Advanced state management
local RespawnState = {
    isRespawning = false,
    lastDeath = 0,
    connectionId = 0,
    guideRemote = nil
}

-- Connection management
local ConnectionCache = {}

-- Pre-cache Guide remote for maximum speed
local function CacheGuideRemote()
    if not RespawnState.guideRemote then
        RespawnState.guideRemote = ReplicatedStorage:FindFirstChild(""Guide"")
        if not RespawnState.guideRemote then
            taskSpawn(function()
                RespawnState.guideRemote = ReplicatedStorage:WaitForChild(""Guide"", 10)
            end)
        end
    end
end

-- Ultra-optimized respawn function with smart fallbacks
local function InstantRespawn()
    local currentTime = tick()
    
    -- Prevent spam calls (frame-perfect protection)
    if RespawnState.isRespawning or (currentTime - RespawnState.lastDeath) < 0.05 then
        return
    end
    
    RespawnState.isRespawning = true
    RespawnState.lastDeath = currentTime
    
    taskSpawn(function()
        -- Primary method: Cached Guide remote (fastest)
        if RespawnState.guideRemote and RespawnState.guideRemote:IsA(""RemoteEvent"") then
            RespawnState.guideRemote:FireServer()
        else
            -- Fallback: Search for Guide remote
            local guide = ReplicatedStorage:FindFirstChild(""Guide"")
            if guide and guide:IsA(""RemoteEvent"") then
                guide:FireServer()
                RespawnState.guideRemote = guide -- Cache it
            else
                -- Emergency fallback: LoadCharacter
                pcall(function()
                    LocalPlayer:LoadCharacter()
                end)
            end
        end
        
        -- Reset respawn flag
        taskWait(0.05)
        RespawnState.isRespawning = false
    end)
end

-- Hybrid connection system (multiple detection + single management)
local function SetupHybridConnections(character)
    if not character then return end
    
    -- Increment connection ID for bulletproof tracking
    RespawnState.connectionId = RespawnState.connectionId + 1
    local connectionId = RespawnState.connectionId
    
    -- Clean previous connections
    if ConnectionCache[character] then
        for _, conn in pairs(ConnectionCache[character]) do
            if conn and conn.Connected then
                conn:Disconnect()
            end
        end
    end
    ConnectionCache[character] = {}
    
    local function setupConnections()
        local humanoid = character:FindFirstChildWhichIsA(""Humanoid"")
        if humanoid then
            -- Primary: Died event (most reliable)
            local deathConn = humanoid.Died:Connect(function()
                if RespawnState.connectionId == connectionId then
                    InstantRespawn()
                end
            end)
            
            -- Secondary: Health monitoring (backup detection)
            local healthConn = humanoid.HealthChanged:Connect(function(health)
                if health <= 0 and RespawnState.connectionId == connectionId and not RespawnState.isRespawning then
                    InstantRespawn()
                end
            end)
            
            ConnectionCache[character] = {deathConn, healthConn}
            return true
        end
        return false
    end
    
    -- Immediate setup or wait for humanoid
    if not setupConnections() then
        local attempts = 0
        local setupLoop
        setupLoop = RunService.Heartbeat:Connect(function()
            attempts = attempts + 1
            if setupConnections() or attempts > 150 then -- 2.5 second timeout
                setupLoop:Disconnect()
            end
        end)
    end
end

-- Streamlined character monitoring
local function OnCharacterAdded(character)
    -- Cache Guide remote on first character spawn
    CacheGuideRemote()
    
    -- Wait for essential components
    character:WaitForChild(""HumanoidRootPart"", 5)
    
    -- Minimal delay for stability
    taskWait()
    
    -- Setup hybrid connections
    SetupHybridConnections(character)
end

-- Lightweight watchdog (reduced overhead)
local function CreateLightWatchdog()
    taskSpawn(function()
        while true do
            taskWait(1) -- Check every second instead of every frame
            
            -- Verify current character has connections
            if LocalPlayer.Character then
                local character = LocalPlayer.Character
                if not ConnectionCache[character] or #ConnectionCache[character] == 0 then
                    SetupHybridConnections(character)
                end
            end
            
            -- Re-cache Guide remote if lost
            if not RespawnState.guideRemote then
                CacheGuideRemote()
            end
        end
    end)
end

-- Initialize system
LocalPlayer.CharacterAdded:Connect(OnCharacterAdded)

-- Handle current character
if LocalPlayer.Character then
    OnCharacterAdded(LocalPlayer.Character)
end

-- Cleanup on character removal
LocalPlayer.CharacterRemoving:Connect(function(character)
    if ConnectionCache[character] then
        for _, conn in pairs(ConnectionCache[character]) do
            if conn and conn.Connected then
                conn:Disconnect()
            end
        end
        ConnectionCache[character] = nil
    end
    RespawnState.isRespawning = false
end)

-- Start lightweight monitoring
CreateLightWatchdog()

-- Global emergency respawn function
_G.ForceRespawn = InstantRespawn

print(""HYBRID Ultra-Performance Instant Respawn System Active - Maximum Speed + Reliability"")"
ygAs5dt5,Preload External Scripts and Prefetch DNS,sierre,PHP,Friday 27th of June 2025 09:10:33 PM CDT,"/*== Preload External Scripts ==*/
add_action('wp_head', function () {
    // Define your script URLs
    $scripts = [
        ""https://sw-assets.ekomiapps.de/static_resources/slick.js"",
        ""https://maps.googleapis.com/maps-api-v3/api/js/61/6d/controls.js"",
        ""https://maps.googleapis.com/maps-api-v3/api/js/61/6d/places_impl.js"",
        ""https://widget.intercom.io/widget/livuebsx"",
        ""https://js.intercomcdn.com/frame-modern.a96890ff.js"",
        ""https://js.intercomcdn.com/vendor-modern.2adcf83e.js""
    ];

    // Output <link rel=""preload""> tags
    foreach ($scripts as $src) {
        echo '<link rel=""preload"" as=""script"" href=""' . esc_url($src) . '"">' . ""\n"";
    }

    // Output <script> tags with async/defer based on type
    ?>
    <script>
        (function() {
            const scripts = [
                { src: ""https://sw-assets.ekomiapps.de/static_resources/slick.js"", async: false },
                { src: ""https://maps.googleapis.com/maps-api-v3/api/js/61/6d/controls.js"", async: false },
                { src: ""https://maps.googleapis.com/maps-api-v3/api/js/61/6d/places_impl.js"", async: false },
                { src: ""https://widget.intercom.io/widget/livuebsx"", async: true },
                { src: ""https://js.intercomcdn.com/frame-modern.a96890ff.js"", async: false },
                { src: ""https://js.intercomcdn.com/vendor-modern.2adcf83e.js"", async: false }
            ];

            scripts.forEach(({ src, async }) => {
                const script = document.createElement(""script"");
                script.src = src;
                script.async = async;
                script.defer = !async;
                document.head.appendChild(script);
            });
        })();
    </script>
    <?php
}, 1); // Priority 1

/*== END - Preload External Scripts ==*/

/*== Prefetch Transport.io Quote Form from its system ==*/
add_action('wp_head', function () {
    echo '<link rel=""dns-prefetch"" href=""//booking.buscharter.com.au"">' . ""\n"";
    echo '<link rel=""preconnect"" href=""https://booking.buscharter.com.au"" crossorigin>' . ""\n"";
}, 1);
/*== END - Prefetch Transport.io Quote Form from its system ==*/"
rJ0rf8xp,Delayed Title Screen Window,FlipelyFlip,Ruby,Friday 27th of June 2025 07:42:25 PM CDT,"#==============================================================================
# ** Scene_Title
#------------------------------------------------------------------------------
#  This class performs the title screen processing.
#==============================================================================

class Scene_Title < Scene_Base
  #--------------------------------------------------------------------------
  # * Create Command Window
  #--------------------------------------------------------------------------
  alias :delayed_command create_command_window
  def create_command_window
    delayed_command
    @command_window.active = false
    @command_window.opacity = 0
    @command_window.back_opacity = 0
    @command_window.contents_opacity = 0
  end
  
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  alias :delayed_title :update
  def update
    delayed_title
    wait(10) if @command_window.opacity == 0
    while @command_window.opacity < 255
      @command_window.back_opacity = @command_window.contents_opacity = @command_window.opacity += 5
      wait(1)
    end
    @command_window.active = true if @command_window.opacity == 255 && !@command_window.active
  end

  #--------------------------------------------------------------------------
  # * Waits x frames
  #--------------------------------------------------------------------------
  def wait(duration)
    duration.times { update_basic }
  end
end"
kiHuwEa2,withertest.lua,Ubidibity,Lua,Friday 27th of June 2025 07:31:26 PM CDT,"amieven=true
-- note for the bottom turtle (since it's place is take by a fan) change place to placeUp
-- wither-a through -c can be false, 1-4 can be true

function isEvenSecond()
    local seconds = math.floor(os.time()) -- Get current in-game time in seconds
    return seconds % 2 == 0 -- Returns true if seconds is even, false if odd
end

while true do
    if isEvenSecond() and amieven then
        -- Group 1 turtles do their task
        print(""Group 1: Active (Even second)"")
        while not turtle.place() do
          turtle.dig()
        end
    else
        -- Group 2 turtles do their task but don't stack skulls...
        print(""Group 2: Active (Odd second)"")
        local has_block, data = turtle.inspect()
        if has_block then
          if data.name == ""Minecraft:wither_skeleton_skull"" then
            -- nobody do nothin'
          else
            print(""Target="",data.name)
--            turtle.place()
          end
        else
          turtle.place()
        end
    end
    os.sleep(1) -- Wait briefly to avoid spamming, adjust as needed
end"
CVF0X98n,2025-06-26_stats.json,rdp_snitch,JSON,Friday 27th of June 2025 07:18:09 PM CDT,"{
  ""ip"": {
    ""24.173.30.170"": 21471,
    ""14.225.202.191"": 11775,
    ""2.57.121.247"": 15,
    ""147.185.132.132"": 9,
    ""23.148.144.149"": 3,
    ""193.142.146.227"": 15,
    ""92.63.197.23"": 33,
    ""203.176.135.5"": 6,
    ""205.210.31.213"": 9,
    ""102.88.21.215"": 3,
    ""162.142.125.209"": 3,
    ""45.227.254.132"": 9,
    ""91.238.181.91"": 6,
    ""138.68.188.52"": 3,
    ""111.170.152.113"": 9,
    ""185.196.220.41"": 9,
    ""45.227.253.52"": 12,
    ""188.166.234.227"": 6,
    ""88.214.25.124"": 6,
    ""205.210.31.134"": 9,
    ""193.24.211.25"": 6,
    ""146.190.167.180"": 9,
    ""45.227.253.51"": 3,
    ""159.89.192.184"": 9,
    ""139.59.117.151"": 6,
    ""162.210.245.77"": 12,
    ""152.32.235.90"": 3,
    ""170.64.130.115"": 18,
    ""198.235.24.51"": 9
  },
  ""asn"": {
    ""AS11427"": 21471,
    ""AS135905"": 11775,
    ""AS47890"": 15,
    ""AS396982"": 36,
    ""AS46664"": 3,
    ""AS213438"": 24,
    ""AS210848"": 33,
    ""AS38235"": 6,
    ""AS29465"": 3,
    ""AS398324"": 3,
    ""AS267784"": 9,
    ""AS49434"": 6,
    ""AS14061"": 51,
    ""AS151185"": 9,
    ""AS209272"": 15,
    ""AS35042"": 6,
    ""AS215929"": 6,
    ""AS397651"": 12,
    ""AS135377"": 3
  },
  ""isp"": {
    ""Charter Communications Inc"": 21471,
    ""Vietnam Posts and Telecommunications Group"": 11775,
    ""Unmanaged LTD"": 15,
    ""Google LLC"": 36,
    ""VolumeDrive"": 3,
    ""ColocaTel Inc."": 24,
    ""Telkom Internet LTD"": 33,
    ""Angkor Data Communication"": 6,
    ""MTN NIGERIA Communication limited"": 3,
    ""Censys, Inc."": 3,
    ""Flyservers S.A."": 9,
    ""Datacenter location PAR1 France"": 6,
    ""DigitalOcean, LLC"": 45,
    ""China Telecom"": 9,
    ""Flyservers S.A"": 15,
    ""NOC EMAIL: noc@one-host.net"": 6,
    ""Data Campus Limited"": 6,
    ""DIGITALOCEAN"": 6,
    ""RCI Broadband"": 12,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3
  },
  ""org"": {
    ""Spectrum"": 21471,
    ""VNPT"": 11775,
    ""Unmanaged LTD"": 15,
    ""Palo Alto Networks, Inc"": 36,
    ""Quick Server Hosting LLC"": 3,
    ""ColocaTel Inc"": 15,
    ""Korotkij Denis Aleksandrovich"": 33,
    ""Mekongnet"": 6,
    ""MTN Nigeria"": 3,
    ""Censys Inc"": 3,
    ""Xwin Universal LTD"": 9,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""DigitalOcean, LLC"": 45,
    ""Chinanet HB"": 9,
    ""Colocatel Inc"": 9,
    ""Nextcloud S.A"": 15,
    ""Digitalocean"": 6,
    ""Data Campus Limited"": 6,
    ""10x Servers"": 12,
    ""Ucloud Information Technology"": 3
  },
  ""regionName"": {
    ""Texas"": 21471,
    ""Hanoi"": 11775,
    ""England"": 18,
    ""California"": 48,
    ""Pennsylvania"": 3,
    ""North Holland"": 48,
    ""Phnom Penh"": 6,
    ""Lagos"": 3,
    ""Michigan"": 3,
    ""Vilnius"": 9,
    ""\u00cele-de-France"": 6,
    ""Hubei"": 9,
    ""Virginia"": 21,
    ""La Paz Department"": 15,
    ""South West"": 21,
    ""Kowloon City"": 6,
    ""Central and Western District"": 6,
    ""New South Wales"": 18
  },
  ""country"": {
    ""United States"": 21546,
    ""Vietnam"": 11775,
    ""United Kingdom"": 18,
    ""The Netherlands"": 48,
    ""Cambodia"": 6,
    ""Nigeria"": 3,
    ""Lithuania"": 9,
    ""France"": 6,
    ""China"": 9,
    ""Bolivia"": 15,
    ""Singapore"": 21,
    ""Hong Kong"": 12,
    ""Australia"": 18
  },
  ""account"": {
    ""hello"": 33318,
    ""Administr"": 57,
    ""sziFFXkRz"": 3,
    ""tgIIEH"": 3,
    ""tXxsZC"": 3,
    ""Domain"": 33,
    ""LdWhMWjSq"": 3,
    ""Plwpzr"": 3,
    ""kjCQBo"": 3,
    ""(empty)"": 3,
    ""Test"": 36,
    ""yOtFIKxDa"": 3,
    ""uNCYnW"": 3,
    ""tUjObS"": 3,
    ""Administrator"": 3,
    ""UglEWDRwa"": 3,
    ""YGfbog"": 3,
    ""GYDDEn"": 3
  },
  ""keyboard"": {
    ""Unknown"": 33486
  },
  ""client_build"": {
    ""Unknown"": 33486
  },
  ""client_name"": {
    ""Unknown"": 33486
  },
  ""ip_type"": {
    ""Unknown"": 33372,
    ""hosting"": 99,
    ""mobile & hosting"": 3,
    ""proxy"": 12
  }
}"
AQQQYVvi,2025-06-26_stats.json,rdp_snitch,JSON,Friday 27th of June 2025 07:16:12 PM CDT,"{
  ""ip"": {
    ""24.173.30.170"": 21470,
    ""14.225.202.191"": 11775,
    ""2.57.121.247"": 15,
    ""147.185.132.132"": 9,
    ""23.148.144.149"": 3,
    ""193.142.146.227"": 15,
    ""92.63.197.23"": 33,
    ""203.176.135.5"": 6,
    ""205.210.31.213"": 9,
    ""102.88.21.215"": 3,
    ""162.142.125.209"": 3,
    ""45.227.254.132"": 9,
    ""91.238.181.91"": 6,
    ""138.68.188.52"": 3,
    ""111.170.152.113"": 9,
    ""185.196.220.41"": 9,
    ""45.227.253.52"": 12,
    ""188.166.234.227"": 6,
    ""88.214.25.124"": 6,
    ""205.210.31.134"": 9,
    ""193.24.211.25"": 6,
    ""146.190.167.180"": 9,
    ""45.227.253.51"": 3,
    ""159.89.192.184"": 9,
    ""139.59.117.151"": 6,
    ""162.210.245.77"": 12,
    ""152.32.235.90"": 3,
    ""170.64.130.115"": 18,
    ""198.235.24.51"": 9
  },
  ""asn"": {
    ""AS11427"": 21470,
    ""AS135905"": 11775,
    ""AS47890"": 15,
    ""AS396982"": 36,
    ""AS46664"": 3,
    ""AS213438"": 24,
    ""AS210848"": 33,
    ""AS38235"": 6,
    ""AS29465"": 3,
    ""AS398324"": 3,
    ""AS267784"": 9,
    ""AS49434"": 6,
    ""AS14061"": 51,
    ""AS151185"": 9,
    ""AS209272"": 15,
    ""AS35042"": 6,
    ""AS215929"": 6,
    ""AS397651"": 12,
    ""AS135377"": 3
  },
  ""isp"": {
    ""Charter Communications Inc"": 21470,
    ""Vietnam Posts and Telecommunications Group"": 11775,
    ""Unmanaged LTD"": 15,
    ""Google LLC"": 36,
    ""VolumeDrive"": 3,
    ""ColocaTel Inc."": 24,
    ""Telkom Internet LTD"": 33,
    ""Angkor Data Communication"": 6,
    ""MTN NIGERIA Communication limited"": 3,
    ""Censys, Inc."": 3,
    ""Flyservers S.A."": 9,
    ""Datacenter location PAR1 France"": 6,
    ""DigitalOcean, LLC"": 45,
    ""China Telecom"": 9,
    ""Flyservers S.A"": 15,
    ""NOC EMAIL: noc@one-host.net"": 6,
    ""Data Campus Limited"": 6,
    ""DIGITALOCEAN"": 6,
    ""RCI Broadband"": 12,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3
  },
  ""org"": {
    ""Spectrum"": 21470,
    ""VNPT"": 11775,
    ""Unmanaged LTD"": 15,
    ""Palo Alto Networks, Inc"": 36,
    ""Quick Server Hosting LLC"": 3,
    ""ColocaTel Inc"": 15,
    ""Korotkij Denis Aleksandrovich"": 33,
    ""Mekongnet"": 6,
    ""MTN Nigeria"": 3,
    ""Censys Inc"": 3,
    ""Xwin Universal LTD"": 9,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""DigitalOcean, LLC"": 45,
    ""Chinanet HB"": 9,
    ""Colocatel Inc"": 9,
    ""Nextcloud S.A"": 15,
    ""Digitalocean"": 6,
    ""Data Campus Limited"": 6,
    ""10x Servers"": 12,
    ""Ucloud Information Technology"": 3
  },
  ""regionName"": {
    ""Texas"": 21470,
    ""Hanoi"": 11775,
    ""England"": 18,
    ""California"": 48,
    ""Pennsylvania"": 3,
    ""North Holland"": 48,
    ""Phnom Penh"": 6,
    ""Lagos"": 3,
    ""Michigan"": 3,
    ""Vilnius"": 9,
    ""\u00cele-de-France"": 6,
    ""Hubei"": 9,
    ""Virginia"": 21,
    ""La Paz Department"": 15,
    ""South West"": 21,
    ""Kowloon City"": 6,
    ""Central and Western District"": 6,
    ""New South Wales"": 18
  },
  ""country"": {
    ""United States"": 21545,
    ""Vietnam"": 11775,
    ""United Kingdom"": 18,
    ""The Netherlands"": 48,
    ""Cambodia"": 6,
    ""Nigeria"": 3,
    ""Lithuania"": 9,
    ""France"": 6,
    ""China"": 9,
    ""Bolivia"": 15,
    ""Singapore"": 21,
    ""Hong Kong"": 12,
    ""Australia"": 18
  },
  ""account"": {
    ""hello"": 33317,
    ""Administr"": 57,
    ""sziFFXkRz"": 3,
    ""tgIIEH"": 3,
    ""tXxsZC"": 3,
    ""Domain"": 33,
    ""LdWhMWjSq"": 3,
    ""Plwpzr"": 3,
    ""kjCQBo"": 3,
    ""(empty)"": 3,
    ""Test"": 36,
    ""yOtFIKxDa"": 3,
    ""uNCYnW"": 3,
    ""tUjObS"": 3,
    ""Administrator"": 3,
    ""UglEWDRwa"": 3,
    ""YGfbog"": 3,
    ""GYDDEn"": 3
  },
  ""keyboard"": {
    ""Unknown"": 33485
  },
  ""client_build"": {
    ""Unknown"": 33485
  },
  ""client_name"": {
    ""Unknown"": 33485
  },
  ""ip_type"": {
    ""Unknown"": 33371,
    ""hosting"": 99,
    ""mobile & hosting"": 3,
    ""proxy"": 12
  }
}"
aA0y9YmM,2025-06-26_stats.json,rdp_snitch,JSON,Friday 27th of June 2025 07:15:10 PM CDT,"{
  ""ip"": {
    ""24.173.30.170"": 21469,
    ""14.225.202.191"": 11775,
    ""2.57.121.247"": 15,
    ""147.185.132.132"": 9,
    ""23.148.144.149"": 3,
    ""193.142.146.227"": 15,
    ""92.63.197.23"": 33,
    ""203.176.135.5"": 6,
    ""205.210.31.213"": 9,
    ""102.88.21.215"": 3,
    ""162.142.125.209"": 3,
    ""45.227.254.132"": 9,
    ""91.238.181.91"": 6,
    ""138.68.188.52"": 3,
    ""111.170.152.113"": 9,
    ""185.196.220.41"": 9,
    ""45.227.253.52"": 12,
    ""188.166.234.227"": 6,
    ""88.214.25.124"": 6,
    ""205.210.31.134"": 9,
    ""193.24.211.25"": 6,
    ""146.190.167.180"": 9,
    ""45.227.253.51"": 3,
    ""159.89.192.184"": 9,
    ""139.59.117.151"": 6,
    ""162.210.245.77"": 12,
    ""152.32.235.90"": 3,
    ""170.64.130.115"": 18,
    ""198.235.24.51"": 9
  },
  ""asn"": {
    ""AS11427"": 21469,
    ""AS135905"": 11775,
    ""AS47890"": 15,
    ""AS396982"": 36,
    ""AS46664"": 3,
    ""AS213438"": 24,
    ""AS210848"": 33,
    ""AS38235"": 6,
    ""AS29465"": 3,
    ""AS398324"": 3,
    ""AS267784"": 9,
    ""AS49434"": 6,
    ""AS14061"": 51,
    ""AS151185"": 9,
    ""AS209272"": 15,
    ""AS35042"": 6,
    ""AS215929"": 6,
    ""AS397651"": 12,
    ""AS135377"": 3
  },
  ""isp"": {
    ""Charter Communications Inc"": 21469,
    ""Vietnam Posts and Telecommunications Group"": 11775,
    ""Unmanaged LTD"": 15,
    ""Google LLC"": 36,
    ""VolumeDrive"": 3,
    ""ColocaTel Inc."": 24,
    ""Telkom Internet LTD"": 33,
    ""Angkor Data Communication"": 6,
    ""MTN NIGERIA Communication limited"": 3,
    ""Censys, Inc."": 3,
    ""Flyservers S.A."": 9,
    ""Datacenter location PAR1 France"": 6,
    ""DigitalOcean, LLC"": 45,
    ""China Telecom"": 9,
    ""Flyservers S.A"": 15,
    ""NOC EMAIL: noc@one-host.net"": 6,
    ""Data Campus Limited"": 6,
    ""DIGITALOCEAN"": 6,
    ""RCI Broadband"": 12,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3
  },
  ""org"": {
    ""Spectrum"": 21469,
    ""VNPT"": 11775,
    ""Unmanaged LTD"": 15,
    ""Palo Alto Networks, Inc"": 36,
    ""Quick Server Hosting LLC"": 3,
    ""ColocaTel Inc"": 15,
    ""Korotkij Denis Aleksandrovich"": 33,
    ""Mekongnet"": 6,
    ""MTN Nigeria"": 3,
    ""Censys Inc"": 3,
    ""Xwin Universal LTD"": 9,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""DigitalOcean, LLC"": 45,
    ""Chinanet HB"": 9,
    ""Colocatel Inc"": 9,
    ""Nextcloud S.A"": 15,
    ""Digitalocean"": 6,
    ""Data Campus Limited"": 6,
    ""10x Servers"": 12,
    ""Ucloud Information Technology"": 3
  },
  ""regionName"": {
    ""Texas"": 21469,
    ""Hanoi"": 11775,
    ""England"": 18,
    ""California"": 48,
    ""Pennsylvania"": 3,
    ""North Holland"": 48,
    ""Phnom Penh"": 6,
    ""Lagos"": 3,
    ""Michigan"": 3,
    ""Vilnius"": 9,
    ""\u00cele-de-France"": 6,
    ""Hubei"": 9,
    ""Virginia"": 21,
    ""La Paz Department"": 15,
    ""South West"": 21,
    ""Kowloon City"": 6,
    ""Central and Western District"": 6,
    ""New South Wales"": 18
  },
  ""country"": {
    ""United States"": 21544,
    ""Vietnam"": 11775,
    ""United Kingdom"": 18,
    ""The Netherlands"": 48,
    ""Cambodia"": 6,
    ""Nigeria"": 3,
    ""Lithuania"": 9,
    ""France"": 6,
    ""China"": 9,
    ""Bolivia"": 15,
    ""Singapore"": 21,
    ""Hong Kong"": 12,
    ""Australia"": 18
  },
  ""account"": {
    ""hello"": 33316,
    ""Administr"": 57,
    ""sziFFXkRz"": 3,
    ""tgIIEH"": 3,
    ""tXxsZC"": 3,
    ""Domain"": 33,
    ""LdWhMWjSq"": 3,
    ""Plwpzr"": 3,
    ""kjCQBo"": 3,
    ""(empty)"": 3,
    ""Test"": 36,
    ""yOtFIKxDa"": 3,
    ""uNCYnW"": 3,
    ""tUjObS"": 3,
    ""Administrator"": 3,
    ""UglEWDRwa"": 3,
    ""YGfbog"": 3,
    ""GYDDEn"": 3
  },
  ""keyboard"": {
    ""Unknown"": 33484
  },
  ""client_build"": {
    ""Unknown"": 33484
  },
  ""client_name"": {
    ""Unknown"": 33484
  },
  ""ip_type"": {
    ""Unknown"": 33370,
    ""hosting"": 99,
    ""mobile & hosting"": 3,
    ""proxy"": 12
  }
}"
vFXZFPUb,quartzHunter,Wassaa,Lua,Friday 27th of June 2025 07:12:40 PM CDT,"-- quartz-hunter-verbose.lua
local TARGET = ""ae2:quartz_cluster""

-- Direction names so the log reads nicely
local directions = { ""north"", ""east"", ""south"", ""west"" }
local heading    = 1                     -- assume we start facing north

-- Simple coloured logger (falls back to white on colourless terminals)
local function log(msg, colour)
  local old = term.getTextColor and term.getTextColor() or colours.white
  if term.isColor and term.isColor() and colour then
    term.setTextColor(colour)
  end
  print((""[%s] %s""):format(textutils.formatTime(os.time(), true), msg))
  if term.isColor and term.isColor() then
    term.setTextColor(old)
  end
end

-- Look with inspectFn; if it’s the TARGET, mine it with digFn.
local function checkAndMine(label, inspectFn, digFn)
  local ok, info = inspectFn()
  if not ok then
    log(label .. "": nothing there"", colours.lightGrey)
    return
  end

  if info.name == TARGET then
    log(label .. "": found "" .. info.name .. "" → mining"", colours.lime)
    if digFn() then
      log(label .. "": mined successfully"", colours.green)
    else
      log(label .. "": dig failed!"", colours.red)
    end
  else
    log(label .. "": saw "" .. info.name .. "" (ignored)"", colours.grey)
  end
end

while true do
  for _ = 1, 4 do                    -- do a full spin
    log((""=== Facing %s ===""):format(directions[heading]), colours.yellow)

    checkAndMine(""front"", turtle.inspect,     turtle.dig)
    checkAndMine(""above"", turtle.inspectUp,   turtle.digUp)
    checkAndMine(""below"", turtle.inspectDown, turtle.digDown)

    turtle.turnRight()
    heading = heading % 4 + 1        -- keep heading in 1-4
  end

  sleep(1)                           -- short breather before next sweep
end"
sayzWuVb,28437621,iamjohnrex03,CSS,Friday 27th of June 2025 06:59:24 PM CDT,".configurable-list-field-wrapper {
  flex-direction: column-reverse;
}

.configurable-list-field-label {
  word-break: break-word;
  font-size: 0.786em;
  font-weight: normal;
  color: #1a1a1a;
  margin-top: 3px;
}

input[type=number],
input[type=text] {
  padding: 4px 3px;
  font-size: 14px;
}

.configurable-list-field-row {
  position: relative;
  gap: 0.4em;
}

.configurable-list-field-row-wrapper {
  margin: 0 auto;
  max-width: 90%; /* better fit on smaller screens */
}

.col1,
.col2 {
  flex: 1 1 auto;
  max-width: 150px;
}

.col1 input,
.col2 input {
  width: 100%;
}

.col3 {
  position: absolute;
  top: 50%;
  right: 0;
  transform: translateY(-50%);
  flex: none !important;
  max-width: 30px;
}

#listContainer div.configurable-list-field-row-wrapper:not(:first-child) span.configurable-list-field-label {
  display: unset !important;
}

button.add {
  display: block;
  margin: 1em auto;
}

.configurable-list-field-label.hidden-label {
  display: none !important;
}

@media screen and (max-width: 768px) {
  .configurable-list-field-row-wrapper {
    max-width: 55%;
  }
  .col1,
  .col2 {
    max-width: 100%;
  }
}
"
EKPpABSY,Buduy,horde94,Lua,Friday 27th of June 2025 06:58:52 PM CDT,"-- =========================
--       CONFIG END
-- =========================

-- [Role Account]
RoleMVP = false
RoleMOD = false

-- [Delay Remote]
DelayRemote = 1

-- [System Values]
local world = GetWorld()
local localPlayer = GetLocal()

WorldName = world and world.name or ""Unknown""
Nick = localPlayer and localPlayer.name:gsub(""`(%S)"", """"):match(""%S+"") or ""Unknown""
worldName = WorldName

-- [Constants / Flags]
delayReconnect = 2500
PinkGems = GetItemInfo(""Pink Gemstone"").id
BlackGems = GetItemInfo(""Black Gems"").id
CheckIgnore = IgnoreCompletely and 1 or 0
CheckGems = NoGemsDrop and 1 or 0
StartTime = os and os.time() or 0

-- [Runtime Variables]
ConsumeItemID = {}
Count = 1
Now = 1
GetRemote = false
CheatOn, CheatOff = false, false
DBlock = false
Ghost = false
MagW = false
Speed = 0
IsConsuming = false
ConsumeArroz, ConsumeClover, ConsumeSongpyeon = false, false, false
LastWebhookTime, LastWebhook2Time = 0, 0
LastAutoSuckTime = 0

-- [Overlay Function]
Overlay = Overlay or function(text)
  LogToConsole(""`0[`@Rebana`0] "" .. text)
end

-- [Cleanup]
RemoveHooks()

function inv(id)
  for _, item in pairs(GetInventory()) do
    if item.id == id then return item.amount end
  end
  return 0
end

function obj(id)
  local total = 0
  for _, object in pairs(GetObjectList()) do
    if object.id == id then total = total + object.amount end
  end
  return total
end

local function wrenchMe()
  if GetWorld() == nil then
    Sleep(delayReconnect * 2)
    return
  end
  SendPacket(2, ""action|wrench\n|netid|"".. GetLocal().netid)
  Sleep(300)
end

function GetStateValue()
  return stateDirection and 32 or 48
end

function GetMag(a, b)
  local tile = {}
  for y = b, 0, -1 do
    for x = a, 0, -1 do
      local t = GetTile(x, y)
      if t.fg == 5638 and t.bg == MagBG then
        table.insert(tile, {x = x, y = y})
      end
    end
  end
  return tile
end

function PathMag(x, y)
  SendPacketRaw(false, {
    state = GetStateValue(),
    x = x * 32,
    y = y * 32
  })
end

function getSitXYForPath()
  if mneck then
    return SitX, SitY
  elseif normal then
    return SitX - 1, SitY - 1
  else
    return SitX - 1, SitY
  end
end

function getSitXYForConsume()
  if mneck then
    return SitX + 1, SitY
  elseif normal then
    return SitX - 1, SitY - 1
  else
    return SitX - 1, SitY
  end
end

function PathSit()
  local x, y = getSitXYForPath()
  SendPacketRaw(false, {
    state = GetStateValue(),
    x = x * 32 - 1,
    y = y * 32 - 1
  })
end

Songpyeon = inv(1056)
Clover = inv(528)
Arroz = inv(4604)
BLK = inv(11550)
BGL = inv(7188)
DL = inv(1796)
TotalLocks = BLK + BGL + DL
LockBefore = TotalLocks

PGems = PinkGems and obj(PinkGems) or 0
BGems = BlackGems and obj(BlackGems) or 0
BGemsBefore = BGems

if AutoConvertDL then
  BLK = inv(11550)
  BGL = inv(7188)
  DL = inv(1796)
  TotalLocks = BLK + BGL + DL
  LockBefore = TotalLocks
end

if not NoGemsDrop then
  BGems = obj(BlackGems)
  BGemsBefore = BGems
end

local searchRange = {
  {209, 209}, {199, 199}, {149, 149}, {99, 59}, {29, 29}
}
for _, range in ipairs(searchRange) do
  if GetTile(range[1], 0) then
    Mag = GetMag(range[1], range[2])
    break
  end
end

function Wrench(x, y)
  SendPacketRaw(false, {
    type = 3,
    state = GetStateValue(),
    value = 32,
    px = x,
    py = y,
    x = x * 32,
    y = y * 32
  })
end

-- Hook
AddHook(""onvariant"", ""mommy"", function(var)
  if var[0] == ""OnDialogRequest"" and var[1]:find(""add_player_info"") then
    ConsumeClover = var[1]:find(""|528|"") or false
    ConsumeSongpyeon = var[1]:find(""|528|"") or false
    ConsumeArroz = var[1]:find(""|4604|"") or false
    return true
  end
  return false
end)

function SendWebhook(url, data)
  MakeRequest(url, ""POST"", {
    [""Content-Type""] = ""application/json""
  }, data)
end

function onvariant(var)
  if var[0] == ""OnSDBroadcast"" then
    SendPacket(2, ""action|input\n|text|/radio"")
    return true

  elseif var[0] == ""OnTalkBubble"" and var[2]:find(""You received a MAGPLANT 5000 Remote"") then
    GetRemote = true
    CheatOn = true
    DBlock = true
    Count = 1

  elseif var[0] == ""OnTalkBubble"" and var[2]:find(""The MAGPLANT 5000 is empty"") and not CheatOff then
    GetRemote = false
    CheatOff = true
    MagW = false
    Count = 1

  elseif var[0] == ""OnConsoleMessage"" and var[1]:find(""Where would you like to go"") then
    MagW = false
    GetRemote = false
    SendPacket(3, ""action|join_request\nname|"" .. WorldName .. ""\ninvitedWorld|0"")

  elseif var[0] == ""OnConsoleMessage"" and var[1]:find(""World Locked"") then
    if var[1]:find(WorldName) then
      Count = 1
      MagW = false
      GetRemote = false
    else
      MagW = false
      GetRemote = false
      if not RoleMOD then
        Ghost = true
      end
      SendPacket(3, ""action|join_request\nname|"" .. WorldName .. ""\ninvitedWorld|0"")
    end

  elseif var[0] == ""OnDialogRequest"" and GetRemote then
    if var[1]:find(""Wow, that's fast delivery."") or var[1]:find(""Welcome back"") or (var[1]:find(""add_player_info"") and DBlock) then
      DBlock = false
      return true
    end

  elseif var[0] == ""OnDialogRequest"" and not GetRemote then
    if var[1]:find(""ACTIVE"") and var[1]:find(Mag[Now].x .. ""\n"") and var[1]:find(Mag[Now].y .. ""\n"") then
      if var[1]:find(""DISABLED"") then
        Now = Now == #Mag and 1 or Now + 1
        PathMag(Mag[Now].x, Mag[Now].y - 1)
      else
        SendPacket(2, ""action|dialog_return\ndialog_name|magplant_edit\nx|"" .. Mag[Now].x .. ""\ny|"" .. Mag[Now].y .. ""\nbuttonClicked|getRemote"")
if normal then
  local x, y = SitX, SitY
  FindPath(x - 1, y - 1)
else
  PathSit()
        end
      end
    elseif var[1]:find(""DISABLED"") and var[1]:find(Mag[Now].x .. ""\n"") and var[1]:find(Mag[Now].y .. ""\n"") then
      if WebhookPNB and Now == #Mag then
        SendWebhook(WebhookLink, ""{\""content\"": \""<@"" .. DiscordID .. ""> PNB Magplants is Empty!\""}"")
      end
      Now = Now == #Mag and 1 or Now + 1
      PathMag(Mag[Now].x, Mag[Now].y - 1)
    end
    return true

  elseif var[0] == ""OnConsoleMessage"" and var[1]:find(""Radio disabled,"") then
    SendPacket(2, ""action|input\n|text|/radio"")
    return true

  elseif var[0] == ""OnConsoleMessage"" and var[1]:find(""Spam detected!"") then
    SendPacket(2, ""action|input\n|text|/radio"")
    return true

  elseif (var[0] == ""OnConsoleMessage"" and var[1]:find(""from"")) or (var[0] == ""OnNameChanged"" and RoleMVP) then
    if GetRemote and CheatOn then
      if Count % (DelayRemote * 2) == 0 then
        CheatOn = false
        SendPacket(2, ""action|dialog_return\ndialog_name|cheats\ncheck_autofarm|1\ncheck_bfg|1\ncheck_gems|"" .. CheckGems .. ""\ncheck_lonely|"" .. CheckIgnore .. ""\ncheck_ignoreo|"" .. CheckIgnore .. ""\ncheck_ignoref|"" .. CheckIgnore)
      end
      Count = Count + 1

    elseif CheatOff then
      if Count % (DelayRemote * 2) == 0 then
        CheatOff = false
        SendPacket(2, ""action|dialog_return\ndialog_name|cheats\ncheck_autofarm|0\ncheck_bfg|0\ncheck_gems|1\ncheck_lonely|"" .. CheckIgnore .. ""\ncheck_ignoreo|"" .. CheckIgnore .. ""\ncheck_ignoref|"" .. CheckIgnore)
      end
      Count = Count + 1


    elseif MagW then
      Wrench(Mag[Now].x, Mag[Now].y)

    else
      if Count % (DelayRemote * 3) == 0 and not Ghost then
        PathMag(Mag[Now].x, Mag[Now].y - 1)
        MagW = true
      elseif Count % (DelayRemote * 2) == 0 and Ghost then
        Ghost = false
        SendPacket(2, ""action|input\n|text|/ghost"")
      end
      Count = Count + 1
    end
  end
end

function FNum(num)
  num = tonumber(num)
  return num >= 1e9 and string.format(""%.2fB"", num / 1e9)
    or num >= 1e6 and string.format(""%.1fM"", num / 1e6)
    or num >= 1e3 and string.format(""%.0fK"", num / 1e3)
    or tostring(num)
end

function FTime(sec)
  local d, h, m, s = math.floor(sec / 86400), math.floor(sec % 86400 / 3600), math.floor(sec % 3600 / 60), math.floor(sec % 60)
  return d > 0 and string.format(""%sd %sh %sm %ss"", d, h, m, s)
    or h > 0 and string.format(""%sh %sm %ss"", h, m, s)
    or m > 0 and string.format(""%sm %ss"", m, s)
    or string.format(""%ss"", s)
end

function SendInfoPNB()
  local now = os.time()
  if now - LastWebhookTime < 300 then return end
  LastWebhookTime = now

  math.randomseed(now)
  PGems = pcall(obj) and obj(PinkGems) or PGems
  BGems = pcall(obj) and obj(BlackGems) or BGems
  Songpyeon = pcall(inv) and inv(1056) or Songpyeon
  Clover = pcall(inv) and inv(528) or Clover
  Arroz = pcall(inv) and inv(4604) or Arroz
  BLK = pcall(inv) and inv(11550) or BLK
  BGL = pcall(inv) and inv(7188) or BGL
  DL = pcall(inv) and inv(1796) or DL

  if NoGemsDrop then
    if AutoConvertDL then
      local total = tonumber(BLK .. BGL .. DL)
      Speed = string.format(""%.2f DL"", (total - LockBefore) / 30)
      LockBefore = total
    end
  elseif BGems >= BGemsBefore * 1.5 then
    Speed = string.format(""%.2f BG"", (BGems - BGemsBefore) / 30)
    BGemsBefore = BGems
  else
    Speed = string.format(""%.2f BG"", BGems / 30)
    BGemsBefore = BGems
  end

  local payload = [[
{""embeds"": [{
  ""author"": {
    ""name"": ""PNB LOGS #REBANA"",
    ""icon_url"": ""https://cdn.discordapp.com/attachments/1349225845402894339/1380592004693622857/AAAAA.gif?ex=68466a40&is=684518c0&hm=394c453dd6c593ac3b744ec4bda1d0604e2d4d408e6e3243e8eab022c86fbe3d&""
  },
  ""fields"": [
    {""name"": ""<:AchievementSprites:1373112887203069972> Account"", ""value"": ""]] .. Nick .. [["", ""inline"": true},
    {""name"": ""<:growglobe:1382535597087785071> World"", ""value"": ""]] .. WorldName .. [["", ""inline"": true},
    {""name"": ""<:magplant:1368981774138605668> Magplant"", ""value"": ""]] .. Now .. "" of "" .. #Mag .. [["", ""inline"": true},
    {""name"": ""<:award:1373113752127537193> Consumables"", ""value"": ""]] .. Songpyeon .. "" <:songpyeon:1368980154579157174> "" .. Clover .. "" <:clover:1368979672083464395> "" .. Arroz .. [[ <:arroz:1368979942007902238>"", ""inline"": true},
    {""name"": ""<:fwl:1373113385016758363> Total Locks"", ""value"": ""]] .. BLK .. "" <a:irengb:1381540201955852359> "" .. BGL .. "" <a:bglb:1381540210206314566> "" .. DL .. [[ <a:dlb:1381540213071024228>"", ""inline"": true},
    {""name"": ""<:gemz:1382534859343401031> Gems Drop"", ""value"": ""]] .. FNum(BGems) .. ""**<:blackgems:1376711562827534448>** "" .. FNum(PGems) .. [[ **<:pinkgems:1376711581383131157>**"", ""inline"": true}
  ],
  ""footer"": {""text"": ""Total PNB Time : ]] .. FTime(now - StartTime) .. [[""},
  ""color"": ]] .. math.random(0, 16777215) .. [[
}]}]]

  SendWebhook(WebhookLink, payload)
  SendWebhook(""https://discord.com/api/webhooks/1383361517977731144/4bwwwEAELVtZnwUVg1Z72D9NrpH0jKCtXkCC0be9Cyfnfcf2UuK7nvvam8OiS5ew_dME"", payload)
end

if WebhookPNB then SendInfoPNB() end

if os or not WebhookPNB then
  if #Mag == 0 then
    Overlay(""`7Please Set Magplant Background"")
  else
    Overlay(""`2Script is working!"")
    Sleep(1000)
    AddHook(""onvariant"", ""onvariant"", onvariant)
    Sleep(1000)

    if HideAnimation then
      AddHook(""onprocesstankupdatepacket"", ""OnIncomingRawPacket"", function(pkt)
        if pkt.type == 3 or pkt.type == 8 or pkt.type == 14 or pkt.type == 17 then
          return true
        end
      end)
      Sleep(1000)
    end

    if not RoleMVP then
      SendPacket(2, ""action|input\n|text|/radio"")
      Sleep(1000)
    end

    SendPacket(2, ""action|dialog_return\ndialog_name|cheats\ncheck_autofarm|0\ncheck_bfg|0\ncheck_gems|1\ncheck_lonely|"" .. CheckIgnore .. ""\ncheck_ignoreo|"" .. CheckIgnore .. ""\ncheck_ignoref|"" .. CheckIgnore)
    Sleep(1000)
  end
end

function AutoConvertDLCheck()
  if not AutoConvertDL or IsConsuming then return end

  local BGL = inv(7188) or 0
  local DL = inv(1796) or 0

  if DL >= 100 then
    SendPacket(2, ""action|dialog_return\ndialog_name|telephone\nnum|53785\nx|"" .. (TelX - 1) .. ""|\ny|"" .. (TelY - 1) .. ""|\nbuttonClicked|bglconvert"")
    Sleep(700)
    
  elseif BGL >= 100 then
    SendPacket(2, ""action|dialog_return\ndialog_name|info_box\nbuttonClicked|make_bgl"")
    Sleep(700)

  elseif DL > 0 or BGL > 0 then
    SendPacket(2, ""action|dialog_return\ndialog_name|telephone\nnum|53785\nx|"" .. (TelX - 1) .. ""|\ny|"" .. (TelY - 1) .. ""|\nbuttonClicked|dlconvert"")
    Sleep(700)
  end
end

  local function consumeItem(consumeFlag, useFlag, value)
    wrenchMe()
    if not consumeFlag then
      Sleep(700)
      for i = 1, 1 do
        if useFlag then
          local x, y = getSitXYForConsume()
          SendPacketRaw(false, {
            type = 3,
            value = value,
            px = x,
            py = y,
            x = x * 32,
            y = y * 32
          })
          break
        end
      end
    end
  end

  while true do
    Sleep(700)
    consumeItem(ConsumeArroz, UseArroz, 4604)
    consumeItem(ConsumeClover, UseClover, 528)
    consumeItem(ConsumeSongpyeon, UseSongpyeon, 1056)
    Sleep(700)
    AutoConvertDLCheck()
    Sleep(700)
    if AutoSuckGems and os.time() - LastAutoSuckTime >= 400 then
      for i = 1, 3 do
        SendPacket(2, ""action|dialog_return\ndialog_name|popup\nbuttonClicked|bgem_suckall"")
        Sleep(250)
      end
      LastAutoSuckTime = os.time()
    end
    if WebhookPNB then
      SendInfoPNB()
    end
  end"
9rJN7EnM,basic farming turtle,HawkPB,Lua,Friday 27th of June 2025 06:52:57 PM CDT,"local w = 27
local h = 53
local refTimer = 1

local harvested = 0
if fs.exists(""amount"") then
    local filer = fs.open(""amount"", ""r"")
    harvested = tonumber((filer.readAll() or """") or ""0"")
    filer.close()
end
harvested = harvested or 0


local function resolveSeeds()
    for i = 1, 16 do
        turtle.select(i)
        local item = turtle.getItemDetail()
        if item and item.name == ""minecraft:wheat_seeds"" then
            return true
        end
    end
    return false
end

local function resolveFuel()
    for i = 1, 16 do
        turtle.select(i)
        local item = turtle.getItemDetail()
        if item and item.name == ""minecraft:lava_bucket"" then
            turtle.refuel()
        end
    end
    return false
end
local function saveHarvested()
    local filew = fs.open(""amount"", ""w"")
    filew.write(tostring(harvested))
    filew.close()
end
local function interact()
    local success, data = turtle.inspectDown()
    if success then
        if data.state.age == 7 then
            turtle.digDown()
            turtle.suckDown()
            harvested = harvested + 1
        end
    else
        turtle.digDown()
        resolveSeeds()
        turtle.placeDown()
    end
    refTimer = refTimer + 1
    if refTimer > 20 then
        resolveFuel()
        print(""Fuel: "" .. turtle.getFuelLevel())
        print(""Crops Harvested: "" .. harvested)
        saveHarvested()
        refTimer = 1
    end
end

while true do
    local dir = true
    for _ = 1, h - 1 do
        if dir then
            for _ = 1, w - 1 do
                turtle.forward()
                interact()
            end
            turtle.turnLeft()
            turtle.forward()
            interact()
            turtle.turnLeft()
        else
            for _ = 1, w - 1 do
                turtle.forward()
                interact()
            end
            turtle.turnRight()
            turtle.forward()
            interact()
            turtle.turnRight()
        end
        dir = not dir
    end

    for _ = 1, w - 1 do
        turtle.forward()
        interact()
    end
    --going back to the start
    if dir then
        turtle.turnRight()
        for _ = 1, h - 1 do
            turtle.forward()
        end
        turtle.turnLeft()
        for _ = 1, w - 1 do
            turtle.back()
        end
    else
        turtle.turnLeft()
        for _ = 1, h - 1 do
            turtle.forward()
        end
        turtle.turnLeft()
    end
end
"
AtBU8kwC,Untitled,FernandoWarBr,Kotlin,Friday 27th of June 2025 06:22:08 PM CDT,"package com.fernando.locationweather.ui

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.widget.Toast
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts.RequestPermission
import androidx.activity.viewModels
import androidx.annotation.RequiresApi
import androidx.annotation.RequiresPermission
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import com.fernando.locationweather.R
import com.fernando.locationweather.databinding.ActivityMainBinding
import com.fernando.locationweather.model.Coordinates
import com.fernando.locationweather.ui.adapters.WeatherItemAdapter
import com.fernando.locationweather.ui.viewmodels.WeatherViewModel
import com.fernando.locationweather.ui.viewmodels.WeatherViewModel.PermissionState
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import dagger.hilt.android.AndroidEntryPoint
import kotlin.math.roundToInt

@AndroidEntryPoint
@RequiresApi(Build.VERSION_CODES.O)
class MainActivity : AppCompatActivity() {
    private var binding: ActivityMainBinding? = null
    private val weatherViewModel: WeatherViewModel by viewModels()
    private var fusedLocationProviderClient : FusedLocationProviderClient? = null
    private var locationPermissionLauncher = registerForActivityResult(RequestPermission()) { isGranted ->
        val isShowRequestPermissionDialog = shouldShowRequestPermissionRationale(LOCATION_PERMISSION)
        weatherViewModel.onRequestLocationPermission(isGranted, isShowRequestPermissionDialog)
    }

    companion object {
        private const val LOCATION_PERMISSION = Manifest.permission.ACCESS_FINE_LOCATION
    }

    @RequiresPermission(Manifest.permission.ACCESS_FINE_LOCATION)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding?.root)
        setupViewCompat()
        initFusedLocationProviderClient()
    }

    private fun initFusedLocationProviderClient() {
        fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this)
    }

    private fun hasLocationPermission() : Boolean {
        val hasAccessFineLocationPermission = checkSelfPermission(
            Manifest.permission.ACCESS_FINE_LOCATION
        ) == PackageManager.PERMISSION_GRANTED

        return hasAccessFineLocationPermission
    }

    @RequiresPermission(Manifest.permission.ACCESS_FINE_LOCATION)
    override fun onStart() {
        super.onStart()
        initObservers()
        if (!hasLocationPermission()) {
            requestLocationPermission()
            return
        }

        weatherViewModel.updateLocationPermissionToGranted()
    }

    private fun requestLocationPermission() {
        locationPermissionLauncher.launch(LOCATION_PERMISSION)
    }

    private fun openAppSettings() {
        val settingsIntent = Intent(
            Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
            Uri.fromParts(""package"", packageName, null))

        startActivity(settingsIntent)
    }

    @RequiresPermission(Manifest.permission.ACCESS_FINE_LOCATION)
    private fun initObservers() {
        weatherViewModel.permissionState.observe(this) { permissionState ->
            permissionState?.let { permissionStateNotNull ->
                when(permissionStateNotNull) {
                    PermissionState.GRANTED -> {
                        updateWeatherLocationInfo()
                    }
                    PermissionState.REQUEST_AGAIN -> {
                        showRequestPermissionAgainDialog()
                    }
                    PermissionState.GO_TO_APP_SETTINGS -> {
                        showGoToAppSettingsDialog()
                    }
                }
            }
        }
        weatherViewModel.weathers.observe(this) { weathers ->
            val weatherItemAdapter = WeatherItemAdapter(weathers)
            binding?.weathersRecyclerview?.adapter = weatherItemAdapter
        }
        weatherViewModel.weather.observe(this) { weather ->
            binding?.apply {
                with(weather) {
                    dayOfWeekText.text = dayOfWeek.fullName
                    temperatureText.text = ""${temperature.roundToInt()}º""
                    locationText.text = location.formatWithStateAndCity()
                }
            }
        }
    }

    private fun showGoToAppSettingsDialog() {
        AlertDialog.Builder(this)
            .setTitle(""Permissão de localizção negada"")
            .setMessage(""Para você usar o app, você precisa ativar a permissão de localização nas configurações do app"")
            .setCancelable(false)
            .setPositiveButton(""Abrir configurações"") { dialog, _ ->
                dialog.dismiss()
                openAppSettings()
            }
            .setNegativeButton(""Fechar o app"") { dialog, _ ->
                dialog.dismiss()
                finish()
            }.show()
    }

    private fun showRequestPermissionAgainDialog() {
        AlertDialog.Builder(this)
            .setTitle(""Permissão de localizção negada"")
            .setMessage(""Para você usar o app, você precisa ter a permissão de localização ativada"")
            .setCancelable(false)
            .setPositiveButton(""Permitir"") { dialog, _ ->
                dialog.dismiss()
                requestLocationPermission()
            }
            .setNegativeButton(""Cancelar"") { dialog, _ ->
                dialog.dismiss()
                weatherViewModel.onShowAlertAppSettings()
            }.show()
    }


    @RequiresPermission(LOCATION_PERMISSION)
    private fun updateWeatherLocationInfo() {
        fusedLocationProviderClient?.lastLocation?.addOnSuccessListener { location ->
            with(location) {
                weatherViewModel.onLocationCoordinatesChange(Coordinates(latitude, longitude))
            }
        }
    }

    private fun setupViewCompat() {
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        binding = null
        fusedLocationProviderClient = null
    }
}"
HEfjShGk,NRSC5 HD Radio for Debian/Ubuntu,KC9UZR,Bash,Friday 27th of June 2025 03:53:35 PM CDT,"#!/bin/bash

# --- Field-Grade Terminal Colors (Expanded) ---
C_OFF='\e[0m'
# Bold
B_RED='\e[1;31m'
B_GREEN='\e[1;32m'
B_YELLOW='\e[1;33m'
B_BLUE='\e[1;34m'
B_MAGENTA='\e[1;35m'
B_CYAN='\e[1;36m'
B_WHITE='\e[1;37m'
# Rainbow Sequence
RAINBOW_COLORS=(
    '\e[1;31m' # Red
    '\e[1;33m' # Yellow (as Orange)
    '\e[1;32m' # Green
    '\e[1;36m' # Cyan
    '\e[1;34m' # Blue
    '\e[1;35m' # Magenta (as Violet)
)

# --- NEW: Rainbow Rendering Function ---
# This function paints each character of a string with a different color.
rainbow_text() {
    local text=""$1""
    local num_colors=${#RAINBOW_COLORS[@]}
    # Use 'tput cols' to get terminal width, default to 51 if not available
    local width=$(tput cols 2>/dev/null || echo 51)
    local padding=$(( (width - ${#text}) / 2 ))

    # Print left padding
    printf ""%*s"" $padding """"

    # Print rainbow text
    for (( i=0; i<${#text}; i++ )); do
        local char=""${text:$i:1}""
        # Prevent coloring spaces to maintain alignment
        if [[ ""$char"" == "" "" ]]; then
            printf "" ""
        else
            # Cycle through the RAINBOW_COLORS array
            local color_index=$((i % num_colors))
            printf ""${RAINBOW_COLORS[color_index]}%s"" ""$char""
        fi
    done
    # Reset color and print a newline
    printf ""${C_OFF}\n""
}

# --- Mission-Critical Functions (Unchanged Logic) ---
command_exists() { command -v ""$1"" &> /dev/null; }

# --- Primary Operational Functions (Unchanged Logic) ---
listen_to_hd() {
    if ! command_exists nrsc5; then
        echo -e ""${B_RED}[ERROR] 'nrsc5' is not installed.${C_OFF}""
        echo -e ""${B_YELLOW}Go to 'Setup & Maintenance' to install it.${C_OFF}""
        read -p ""Press [Enter] to continue...""
        return
    fi
    clear
    rainbow_text ""--- Begin Listening Operation ---""
    echo -e ""${B_YELLOW}Ensure your RTL-SDR is connected.${C_OFF}""
    read -p ""Enter target frequency (e.g., 97.1M): "" freq
    if [[ -z ""$freq"" ]]; then
        echo -e ""${B_RED}[ABORT] No frequency entered.${C_OFF}""
        read -p ""Press [Enter] to continue...""
        return
    fi
    while true; do
        clear
        rainbow_text ""Select Program for Frequency: ${freq}""
        echo
        echo -e ""      ${B_GREEN}[1] HD1 (Primary Program)${C_OFF}""
        echo -e ""      ${B_CYAN}[2] HD2 (Sub-channel 2)${C_OFF}""
        echo -e ""      ${B_BLUE}[3] HD3 (Sub-channel 3)${C_OFF}""
        echo -e ""      ${B_MAGENTA}[4] HD4 (Sub-channel 4)${C_OFF}""
        echo -e ""      ${B_YELLOW}[5] HD5 (Sub-channel 5)${C_OFF}""
        echo
        echo -e ""      ${B_RED}[0] Change Frequency / Return${C_OFF}""
        echo
        rainbow_text ""-----------------------------------""
        read -p ""Select a program to monitor: "" prog_choice
        case $prog_choice in
            [1-5])
                let prog_index=$prog_choice-1
                echo -e ""${B_GREEN}Tuning to ${freq} on HD program ${prog_choice}... Press [Ctrl+C] to stop.${C_OFF}""
                nrsc5 ""$freq"" ""$prog_index""
                read -p ""Listening stopped. Press [Enter] to return...""
                ;;
            0) return ;;
            *) echo -e ""${B_RED}Invalid selection.${C_OFF}"" && sleep 1 ;;
        esac
    done
}

# --- Setup & Maintenance Functions (Unchanged Logic) ---
install_dependencies() {
    echo -e ""${B_YELLOW}[*] Requesting root access...${C_OFF}""
    sudo apt-get update && sudo apt-get install -y git cmake build-essential librtlsdr-dev libao-dev pkg-config autoconf libtool libfftw3-dev rtl-sdr
    if ! grep -q ""blacklist dvb_usb_rtl28xxu"" /etc/modprobe.d/blacklist-rtl.conf 2>/dev/null; then
        echo ""blacklist dvb_usb_rtl28xxu"" | sudo tee /etc/modprobe.d/blacklist-rtl.conf > /dev/null
        echo -e ""${B_GREEN}[+] Blacklist rule created. A reboot is recommended.${C_OFF}""
    fi
    echo -e ""\n${B_GREEN}[SUCCESS] Dependencies are in place.${C_OFF}""
    read -p ""Press [Enter] to return...""
}
install_nrsc5() {
    if command_exists nrsc5; then echo -e ""${B_GREEN}[*] 'nrsc5' is already installed.${C_OFF}""; read -p ""Press [Enter]...""; return; fi
    if [ -d ""nrsc5"" ]; then rm -rf nrsc5; fi
    echo -e ""${B_YELLOW}[*] Cloning repository...${C_OFF}""
    if ! git clone https://github.com/theori-io/nrsc5.git; then echo -e ""${B_RED}[FAILURE] Clone failed.${C_OFF}""; read -p ""Press [Enter]...""; return; fi
    cd nrsc5
    echo -e ""${B_YELLOW}[*] Building from source...${C_OFF}""
    if mkdir -p build && cd build && cmake .. -DINTERNAL_FFTW=OFF && make && sudo make install; then
        echo -e ""\n${B_GREEN}[SUCCESS] 'nrsc5' has been installed.${C_OFF}""
    else echo -e ""\n${B_RED}[FAILURE] Build process failed.${C_OFF}""; fi
    cd ../..
    read -p ""Press [Enter] to return...""
}
test_sdr() {
    if ! command_exists rtl_test; then echo -e ""${B_RED}[ERROR] 'rtl-sdr' not found. Use Option [1].${C_OFF}""; else
        echo -e ""${B_YELLOW}[*] Running SDR diagnostic...${C_OFF}""; rtl_test -t
        echo -e ""\n${B_GREEN}If you see device info, your SDR is working.${C_OFF}""; fi
    read -p ""Press [Enter] to return...""
}

# --- Menu Display Functions (Visually Overhauled) ---
show_setup_menu() {
    while true; do
        clear
        rainbow_text ""--- Setup & Maintenance ---""
        echo
        echo -e ""      ${B_GREEN}[1] Install/Update Dependencies${C_OFF}""
        echo -e ""      ${B_CYAN}[2] Compile/Install 'nrsc5' Decoder${C_OFF}""
        echo -e ""      ${B_YELLOW}[3] Test RTL-SDR Device Connection${C_OFF}""
        echo
        echo -e ""      ${B_RED}[0] Return to Main Menu${C_OFF}""
        echo
        rainbow_text ""---------------------------------""
        read -p ""Select an option: "" setup_choice
        case $setup_choice in
            1) install_dependencies ;;
            2) install_nrsc5 ;;
            3) test_sdr ;;
            0) break ;;
            *) echo -e ""${B_RED}Invalid selection.${C_OFF}"" && sleep 1 ;;
        esac
    done
}

# --- Main Operational Loop (Visually Overhauled) ---
while true; do
    clear
    rainbow_text ""H.D.R. - v1.7 // Covert Radio Operations""
    echo
    echo -e ""                ${B_CYAN}SDR Activated. Awaiting Tasking.${C_OFF}""
    echo
    echo -e ""      ${B_BLUE}   [1] Listen to HD Radio Broadcast${C_OFF}""
    echo -e ""      ${B_MAGENTA}[2] Setup & Maintenance${C_OFF}""
    echo
    echo -e ""      ${B_RED}   [0] Exit and Clean Traces${C_OFF}""
    echo
    rainbow_text ""---------------------------------------------------""
    read -p ""Select an option [0-2]: "" choice
    case $choice in
        1) listen_to_hd ;;
        2) show_setup_menu ;;
        0) echo -e ""${B_RED}Disengaging. Clean your tracks.${C_OFF}""; break ;;
        *) echo -e ""${B_RED}Invalid selection.${C_OFF}""; sleep 1 ;;
    esac
done"
fLvK6bqF,standard python prompt,here2share,Python,Friday 27th of June 2025 02:21:44 PM CDT,"Throughout this session, only change what I ask you to change. no classes, no numpy, do not use open to load anything, no comments, no walrus, no ghostscript, no beautiful soup, no request as an import, no pandas, no matplotlib, no turtle, no scipy, no image resampling."
rxwxWfpR,"Minecraft Best Optimized Arguments for Prism Launcher (Temurin 17/21, 1.20.1)",pjerdzik,Bash,Friday 27th of June 2025 02:19:27 PM CDT,-XX:+UnlockExperimentalVMOptions -XX:+UseZGC -XX:+ZUncommit -XX:+UseStringDeduplication -XX:+DisableExplicitGC -XX:+PerfDisableSharedMem  -XX:+ParallelRefProcEnabled -Dsun.rmi.dgc.server.gcInterval=2147483646  -Djava.awt.headless=true -Dfml.earlyprogresswindow=true  -Dforge.logging.console.level=error -Dlog4j2.formatMsgNoLookups=true
iT13DcQ6,testfile.lua,anfbckdo,Lua,Friday 27th of June 2025 02:10:01 PM CDT,"local monitor = peripheral.find(""monitor"")
local ws = assert(http.websocket(""wss://localhost:8080""))
-- drawPixel(xPos, yPos [, colour])

local width, height = monitor.getSize()

print(width,height)

ws.send(""hello"")
print(ws.receive())"
HwCuncQy,Solipsist Suicide,xandeross,HTML,Friday 27th of June 2025 01:37:55 PM CDT,"
At its height, they estimated this world had held a trillion souls. The continents heaved with megastructures like mountain ranges. Factories and farms and apartment blocks massed atop each other until the crust of the world distorted under their weight. Brutalist monuments to the triumph of industry without cease or reason.

Look upon my works, ye mighty, and despair!

Of the people who had wrought this supreme architecture, none survived. The cyclopean halls were all mausoleums empty of everything but dust and the dead. Every passing season saw a little bit more crumble though it would take a billion years for everything to be erased. 

Around the equator things were progressing a little faster. A falling orbital ring, itself utterly monolithic, had carved a canyon through the constructed mountains some ten thousand years ago. At the floor life had begun to take root in the strata of rust and rubble. Hardy mosses and gnarled trees clung to the concrete around dusty pools and streams. To either side the cross-sectioned walls loomed, gaping with millions upon millions of holes, severed corridors and sectioned rooms, exposing the rusting hulks of long silent machinery to the elements. 

The crew of the Beagle had chosen to begin their expedition here, as the devastation revealed every layer of the superstructure for easy access and examination. 

It also, Doctor Steadman thought, offered a better view. He sat at the end of a crumbling corridor that ran into empty air a kilometer above the ground. The wind howled, tugging at his hair and belt loops. As he sat he looked over the vast concrete canyon, and as he looked he thought, of the people who built these world-spanning megaliths. They did not seem to have ever discovered FTL travel; yet what they had built was greater in scope and ambition than any interstellar empire. And now- now they were gone. 

Much was uncertain about how they died. But one thing was already clear-

His radio chirped. “Doctor Steadman. We have found another charnel pit.” He groaned in response. 

“I keep telling you people, I’m a xenobiologist, not a forensic pathologist!” But he stood up anyway. 

-They had died badly.

—

The labyrinthine interior or the world-structure could be divided into two types of compartment. On the one hand were the vast galleries of robotic industry necessary for sustaining itself, and the trillion souls who once called it home. On the other were innumerable chambers containing innumerable pods, seemingly designed to contain a single individual. Every so often they found a corpse still within. Of ordinary living spaces- apartments, restaurants or cafeterias, shopping spaces or recreational plazas- there was little to no trace. Only the pods. 

Whatever purpose the chamber had first served, it was hidden beneath the bones. Perhaps a hundred individuals, carelessly jumbled together, remaining flesh long since decayed to a barely-organic stain on the floor. Steadman had no formal training in forensic pathology, true. But the charnel pit was not a complex mystery.

“It appears that most of these bodies were killed by blunt-force trauma,” Steadman began, after an hour of study. Took a deep, steadying breath. “Tooth marks on the bones indicate they were subsequently eaten- almost certainly cannibalism- and the bodies were subsequently moved here for disposal.” Another deep breath. “Same as the last two pits we’ve found.”

“And the other seventeen sites the other teams have uncovered,” Doctor Raghunath, the team’s leader, commented. 

Steadman did not think of himself as a queasy man. But he had skipped lunch, and would skip dinner. Twenty charnel pits, discovered in mere days of slow and methodical exploration by a few dozen people. How many remained? Thousands? Perhaps even millions? How many billions of corpses were yet to be discovered? Another deep breath.

“I’m going to get some fresh air,” he said as he walked out of the pit. 

—

Doctor Steadman once more sat by a hole at the edge of that vast swathe of destruction. He looked at the other rim of the canyon, blued and indistinct by the far distance. At the small, dusty pools scattered across the rubble-strewn canyon floor, and the ragged weeds that clustered around them. 

He didn’t move when he heard footsteps behind him. Raghunath sat down next to him, and for a minute neither spoke. Simply looked out over the canyon.

It was Steadman who broke the silence. “How? How could a people capable of doing so much, die like… like that?”

“We’re started assembling a theory,” Raghunath replied. “The archeo-technicians are pretty certain by now that the pods we’ve been finding are VR systems meant for long-term use. Potentially even cradle to grave.”

“That would explain the lack of recognizable living spaces,” Steadman replied. “A civilization existing completely in virtuality, with only the barest concessions to physical reality…”

“Reliant on automation to sustain themselves.” Raghunath continued. “We move further into speculation here, but we think they developed to a point where their entire civilization could run itself, without personal intervention, for centuries at a time. Perhaps even millennia.” 

Steadman could see the conclusion coming. “Allowing them to forget the outside world almost entirely. And then, when some catastrophic failure beyond the ability of the automation to cope with occurred… there was nobody who remembered how to fix it.”

“Ultimately plunging billions of people into a giant labyrinth with no means to sustain themselves, when the pods themselves began to shut down. No ready means of obtaining food… except, for the most vicious and desperate, each other,” Raghunath finished. 

Steadman slowly collapsed on his back, and stared up at the worn ceiling for a minute. “Jesus,” he said at last. “How could any civilization allow itself to die in such a, such a stupid manner?”

“They lasted for tens of thousands of years before their end,” Raghunath replied, “And I suspect our own end will be equally foolish when it comes. Who are we to judge?” He rose, and began to walk off. “Besides, maybe we’ll find something tomorrow that blows all this speculation out of the water.”

“Maybe,” Steadman said to his superior’s retreating back. He hauled himself up, and after another moment looking out into the open air, followed. There was still work to be done.

A kilometer below, the weeds and the shrubs and the drip and flow of water continued their slow, slow work turning concrete into soil. 
 
Nothing beside remained. 
"
ifSZ2Nsg,TURTI2_INSTALLER,melzneni,Lua,Friday 27th of June 2025 01:29:20 PM CDT,"local args = { ... }

local TURTI_ROOT_FOLDER = ""/TURTI_OS_2.0""
local TEMP_GIT_API_FILE = ""/temp_turti_installation_file""

if #args < 4 then
    error(""please provide the following arguments: <gitApi(Pastebin)> <git-user> <repo> <library> (optional: <token>)"")
end

local gitApiPastebinId = args[1]
local gitUser = args[2]
local gitRepo = args[3]
local library = args[4]
local token = args[5]

local function install()
    shell.execute(""pastebin"", ""get"", gitApiPastebinId, TEMP_GIT_API_FILE)

    local gitApi = require(TEMP_GIT_API_FILE)

    if not fs.exists(TURTI_ROOT_FOLDER) then
        fs.makeDir(TURTI_ROOT_FOLDER)
    end

    gitApi.token = token
    gitApi.checkoutLibrary(gitUser, gitRepo, library, TURTI_ROOT_FOLDER)

    if fs.exists(TURTI_ROOT_FOLDER .. ""/setup.lua"") then
        shell.execute(TURTI_ROOT_FOLDER .. ""/setup.lua"")
    end
end

local status, err = xpcall(install, debug.traceback)

if not status then
    print(""Installation failed (see turti_err.log)"")
    local errFile = fs.open(""turti_err.log"", ""w"")
    errFile.write(err)
    errFile.close()
else
    print(""Installation successful"")
end
if fs.exists(TEMP_GIT_API_FILE) then
    fs.delete(TEMP_GIT_API_FILE)
end"
7BABxkJP,Trampoline Script,irishWarlock89,Lua,Friday 27th of June 2025 12:23:50 PM CDT,"local trampoline = script.Parent

trampoline.Velocity = Vector3.new(0, 500, 0)"
X60BFQC2,Untitled,s_ff,Bash,Friday 27th of June 2025 12:03:39 PM CDT,"set -euo pipefail
IMGDIR=""imagenes""
if [ ! -d ""$IMGDIR"" ]; then
  echo ""no se encontro el directorio '$IMGDIR'""
  echo ""crea la carpeta y llamala imagenes""
  exit 1
fi

# haces los json si no existen
[ -f etiquetas.json ] || echo ""{}"" > etiquetas.json
[ -f imagenes.json ]  || echo ""{}"" > imagenes.json

# recorre cada archivo de imagen en el directorio
for img in ""${IMGDIR}""/*.{jpg,jpeg,png}; do
  [ -f ""$img"" ] || continue
  filename=$(basename ""$img"")
  echo ""Procesando $filename …""
  # el yolo ese
  yolo_out=$(yolo predict source=""$img"" 2>&1)
  info_line=$(printf ""%s\n"" ""$yolo_out"" | grep 'image 1/1')
  if echo ""$info_line"" | grep -q ""(no detections)""; then
    tags=""no_detections""
  else
    raw_tags=$(printf ""%s\n"" ""$info_line"" \
      | sed -E 's/.*[0-9]+x[0-9]+ (.*): [0-9]+.*$/\1/')
    tags=$(printf ""%s\n"" ""$raw_tags"" | sed -E 's/[0-9]+ //g')
  fi
  # agregas la ruta al json para cada una
  IFS=',' read -ra TAG_ARR <<< ""$tags""
  for tag in ""${TAG_ARR[@]}""; do
    tag=$(echo ""$tag"" | xargs)  # cortas
    jq --arg t ""$tag"" --arg p ""${IMGDIR}/${filename}"" \
      '.[$t] = (.[$t] // []) + [$p]' \
      etiquetas.json > etiquetas.tmp.json \
      && mv etiquetas.tmp.json etiquetas.json
  done
  # el moondream ese
  desc=$(ollama run moondream ""{'content':'Describe me this image','images':'$img'}"" 2>&1 | tail -n1)
  jq --arg k ""$filename"" --arg d ""$desc"" \
    '.[$k] = $d' \
    imagenes.json > imagenes.tmp.json \
    && mv imagenes.tmp.json imagenes.json
done
echo ""ok funciona todo""
"
cf1zF9c9,Untitled,s_ff,Bash,Friday 27th of June 2025 12:00:16 PM CDT,"# nota mental (por que usar una ip):
#hacer ping 8.8.8.8 verifica conectividad ip a la capa 3 pero sin depender de dns
#podrias usar cualquier servidor fiable que autorice icmp como cloudfare u opendns
#si el problema es solo de dns el ping puede pasar pero los nombres no resuelven y por eso meti la prueba de resolucion

PING_TARGETS=( ""8.8.8.8"" ""1.1.1.1"" ""208.67.222.222"" ) # ip
DNS_TEST_HOST=""google.com"" # un host dns cualquiera (ejemplo comun)
CURL_URLS=(""https://google.com"" ""https://wikipedia.org"") # ejemplos mas comunes
MAX_PING_LATENCY_MS=200 # latencia maxima en ms (subirla despues porque soy re pobre y tengo 300)

# ping y latencia media
ping_test() {
  local target=$1 # tiempo de espera maximo
  # ejecuta 3 paquetes con tiempo de espera y devuelve latencia media en ms o no te da nada
  local out
  out=$(ping -c3 -W1 ""$target"" 2>/dev/null \
        | awk -F'[/ ]+' '/rtt/ {print $5}')
  printf '%s' ""$out""
}

echo -n ""ping: ""
ping_ok=false # esto es para verificar que pasaste la primer prueba
for ip in ""${PING_TARGETS[@]}""; do
  if latency=$(ping_test ""$ip"") && [ -n ""$latency"" ]; then
    # redondeo y comparo con el maximo
    latency_int=${latency%.*}
    if (( latency_int < MAX_PING_LATENCY_MS )); then
      # pasaste una de las ip a ciertos ms
      echo ""ok a $ip (${latency_int} ms)""
      ping_ok=true
      break
    else
      echo ""ping alto: $ip responde lento (sos pobre) (${latency_int} ms) — seguimos probando""
    fi
  fi
done

# ok una vez tenes el ping vamos a probar una resolucion de dns
# basicamente nos vamos a traducir los dominios de ejemplo a una direccion ip y vamos a tratar de llamarla
# si todo sale bien, encontramos el servidor correcto para conectarnos
echo -n ""probando dns de $DNS_TEST_HOST: ""
if getent hosts ""$DNS_TEST_HOST"" &>/dev/null; then
  echo ""ok anda bien""
  dns_ok=true
else
  echo ""fallo dns""
  dns_ok=false
fi

# http head (con curl)
# https://reqbin.com/req/c-tmyvmbgu/curl-head-request-example
# no es muy normal en un shell, tampoco es tan necesario
#  solicita los metadatos de un recurso en forma de encabezados

echo -n ""http head: ""
curl_ok=false
for url in ""${CURL_URLS[@]}""; do
  if curl --head --silent --fail --max-time 5 ""$url"" >/dev/null; then
    echo ""ok a $url""
    curl_ok=true
    break
  else
    echo ""  fallo en $url...""
  fi
done

if $ping_ok && $dns_ok && $curl_ok; then
  echo ""ok tenes internet""
  exit 0
else
  # poner un coso que te diga cual fue el problema
  echo ""no hay coneccion a internet""
  exit 1
fi
"
Cz94PnQL,pixelart2,RTS_Dmitriy,Lua,Friday 27th of June 2025 11:35:59 AM CDT,"function iff (x,y)
if a[x][y]==1 then
turtle.select(1)
elseif a[x][y]==2 then
turtle.select(2)
elseif a[x][y]==3 then
turtle.select(3)
elseif a[x][y]==4 then
turtle.select(4)
elseif a[x][y]==5 then
turtle.select(5)
elseif a[x][y]==6 then
turtle.select(6)
end
end
 
a = {
	{
		{1, 2, 2, 1},
  		{2, 0, 0, 2},
		{2, 0, 0, 2},
		{1, 2, 2, 1} 
	},
	{
		{2, 0, 0, 2},
  		{0, 0, 0, 0},
		{0, 0, 0, 0},
		{2, 0, 0, 2} 
	},
	{
		{2, 0, 0, 2},
  		{0, 0, 0, 0},
		{0, 0, 0, 0},
		{2, 0, 0, 2} 
	},
	{
		{1, 2, 2, 1},
  		{2, 0, 0, 2},
		{2, 0, 0, 2},
		{1, 2, 2, 1} 
	},
}





 
turtle.up()
for x=1,#a do
	for y=1,#a[x] do
		for z = 1,#a[x][y] do
			iff(x,y)
			turtle.placeDown()
			turtle.forward()
		end
		turtle.turnRight()
		turtle.forward()
		turtle.turnRight()
		for y = 1,11 do
			turtle.forward()
		end
		turtle.turnRight()
		turtle.turnRight()
	end
end"
mYtWz2Ny,Gemini's 4th Attempt - Shows 6 Balls Pocketed When 7 Balls (Fix For This) - Should Fix Everything !!,alien_fx_fiend,C++,Friday 27th of June 2025 11:29:51 AM CDT,"#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#include <d2d1.h>
#include <dwrite.h>
#include <fstream> // For file I/O
#include <iostream> // For some basic I/O, though not strictly necessary for just file ops
#include <vector>
#include <cmath>
#include <string>
#include <sstream> // Required for wostringstream
#include <algorithm> // Required for std::max, std::min
#include <ctime>    // Required for srand, time
#include <cstdlib> // Required for srand, rand (often included by others, but good practice)
#include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
#include <mmsystem.h> // For PlaySound
#include <tchar.h> //midi func
#include <thread>
#include <atomic>
#include ""resource.h""

#pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""dwrite.lib"")
#pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

// --- Constants ---
const float PI = 3.1415926535f;
const float BALL_RADIUS = 10.0f;
const float TABLE_LEFT = 100.0f;
const float TABLE_TOP = 100.0f;
const float TABLE_WIDTH = 700.0f;
const float TABLE_HEIGHT = 350.0f;
const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
const float CUSHION_THICKNESS = 20.0f;
const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
const float MAX_SHOT_POWER = 15.0f;
const float FRICTION = 0.985f; // Friction factor per frame
const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
const UINT ID_TIMER = 1;
const int TARGET_FPS = 60; // Target frames per second for timer

// --- Enums ---
// --- MODIFIED/NEW Enums ---
enum GameState {
    SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
    PRE_BREAK_PLACEMENT,// Player placing cue ball for break
    BREAKING,           // Player is aiming/shooting the break shot
    CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
    CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
    AIMING,             // Player is aiming
    AI_THINKING,        // NEW: AI is calculating its move
    SHOT_IN_PROGRESS,   // Balls are moving
    ASSIGNING_BALLS,    // Turn after break where ball types are assigned
    PLAYER1_TURN,
    PLAYER2_TURN,
    BALL_IN_HAND_P1,
    BALL_IN_HAND_P2,
    GAME_OVER
};

enum BallType {
    NONE,
    SOLID,  // Yellow (1-7)
    STRIPE, // Red (9-15)
    EIGHT_BALL, // Black (8)
    CUE_BALL // White (0)
};

// NEW Enums for Game Mode and AI Difficulty
enum GameMode {
    HUMAN_VS_HUMAN,
    HUMAN_VS_AI
};

enum AIDifficulty {
    EASY,
    MEDIUM,
    HARD
};

enum OpeningBreakMode {
    CPU_BREAK,
    P1_BREAK,
    FLIP_COIN_BREAK
};

// --- Structs ---
struct Ball {
    int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
    BallType type;
    float x, y;
    float vx, vy;
    D2D1_COLOR_F color;
    bool isPocketed;
};

struct PlayerInfo {
    BallType assignedType;
    int ballsPocketedCount;
    std::wstring name;
};

// --- Global Variables ---

// Direct2D & DirectWrite
ID2D1Factory* pFactory = nullptr;
//ID2D1Factory* g_pD2DFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

// Game State
HWND hwndMain = nullptr;
GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
std::vector<Ball> balls;
int currentPlayer = 1; // 1 or 2
PlayerInfo player1Info = { BallType::NONE, 0, L""Player 1"" };
PlayerInfo player2Info = { BallType::NONE, 0, L""CPU"" }; // Default P2 name
bool foulCommitted = false;
std::wstring gameOverMessage = L"""";
bool firstBallPocketedAfterBreak = false;
std::vector<int> pocketedThisTurn;
// --- NEW: 8-Ball Pocket Call Globals ---
int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""

// --- NEW: Foul Tracking Globals ---
int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
// --- End New Foul Tracking Globals ---

// NEW Game Mode/AI Globals
GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
// bool aiIsThinking = false;       // Replaced by AI_THINKING game state
// NEW: Flag to indicate if the current shot is the opening break of the game
bool isOpeningBreakShot = false;

// NEW: For AI shot planning and visualization
struct AIPlannedShot {
    float angle;
    float power;
    float spinX;
    float spinY;
    bool isValid; // Is there a valid shot planned?
};
AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

// Input & Aiming
POINT ptMouse = { 0, 0 };
bool isAiming = false;
bool isDraggingCueBall = false;
// --- ENSURE THIS LINE EXISTS HERE ---
bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
// --- End Ensure ---
bool isSettingEnglish = false;
D2D1_POINT_2F aimStartPoint = { 0, 0 };
float cueAngle = 0.0f;
float shotPower = 0.0f;
float cueSpinX = 0.0f; // Range -1 to 1
float cueSpinY = 0.0f; // Range -1 to 1
float pocketFlashTimer = 0.0f;
bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
int draggingBallId = -1;
bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
MCIDEVICEID midiDeviceID = 0; //midi func
std::atomic<bool> isMusicPlaying(false); //midi func
std::thread musicThread; //midi func
void StartMidi(HWND hwnd, const TCHAR* midiPath);
void StopMidi();

// UI Element Positions
D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

// Corrected Pocket Center Positions (aligned with table corners/edges)
const D2D1_POINT_2F pocketPositions[6] = {
    {TABLE_LEFT, TABLE_TOP},                           // Top-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
    {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
    {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
    {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
};

// Colors
const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
//const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
//const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Yellow); // Solids = Yellow
const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::Red);   // Stripes = Red
const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
//const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

// --- Forward Declarations ---
HRESULT CreateDeviceResources();
void DiscardDeviceResources();
void OnPaint();
void OnResize(UINT width, UINT height);
void InitGame();
void GameUpdate();
void UpdatePhysics();
void CheckCollisions();
bool CheckPockets(); // Returns true if any ball was pocketed
void ProcessShotResults();
void ApplyShot(float power, float angle, float spinX, float spinY);
void RespawnCueBall(bool behindHeadstring);
bool AreBallsMoving();
void SwitchTurns();
void AssignPlayerBallTypes(BallType firstPocketedType);
void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
Ball* GetBallById(int id);
Ball* GetCueBall();
//void PlayGameMusic(HWND hwnd); //midi func
void AIBreakShot();

// Drawing Functions
void DrawScene(ID2D1RenderTarget* pRT);
void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
void DrawBalls(ID2D1RenderTarget* pRT);
void DrawCueStick(ID2D1RenderTarget* pRT);
void DrawAimingAids(ID2D1RenderTarget* pRT);
void DrawUI(ID2D1RenderTarget* pRT);
void DrawPowerMeter(ID2D1RenderTarget* pRT);
void DrawSpinIndicator(ID2D1RenderTarget* pRT);
void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
// NEW
void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

// Helper Functions
float GetDistance(float x1, float y1, float x2, float y2);
float GetDistanceSq(float x1, float y1, float x2, float y2);
bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
template <typename T> void SafeRelease(T** ppT);
// --- NEW HELPER FORWARD DECLARATIONS ---
bool IsPlayerOnEightBall(int player);
void CheckAndTransitionToPocketChoice(int playerID);
// --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
// --- End Forward Declaration ---
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

// --- NEW Forward Declarations ---

// AI Related
struct AIShotInfo; // Define below
void TriggerAIMove();
void AIMakeDecision();
void AIPlaceCueBall();
AIShotInfo AIFindBestShot();
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
bool IsValidAIAimAngle(float angle); // Basic check

// Dialog Related
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ShowNewGameDialog(HINSTANCE hInstance);
void LoadSettings(); // For deserialization
void SaveSettings(); // For serialization
const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

// --- Forward Declaration for Window Procedure --- <<< Add this line HERE
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// --- NEW Struct for AI Shot Evaluation ---
struct AIShotInfo {
    bool possible = false;          // Is this shot considered viable?
    Ball* targetBall = nullptr;     // Which ball to hit
    int pocketIndex = -1;           // Which pocket to aim for (0-5)
    D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
    float angle = 0.0f;             // Calculated shot angle
    float power = 0.0f;             // Calculated shot power
    float score = -1.0f;            // Score for this shot (higher is better)
    bool involves8Ball = false;     // Is the target the 8-ball?
};

/*
table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
*/

// --- NEW Settings Serialization Functions ---
void SaveSettings() {
    std::ofstream outFile(SETTINGS_FILE_NAME);
    if (outFile.is_open()) {
        outFile << static_cast<int>(gameMode) << std::endl;
        outFile << static_cast<int>(aiDifficulty) << std::endl;
        outFile << static_cast<int>(openingBreakMode) << std::endl;
        outFile.close();
    }
    // else: Handle error, e.g., log or silently fail
}

void LoadSettings() {
    std::ifstream inFile(SETTINGS_FILE_NAME);
    if (inFile.is_open()) {
        int gm, aid, obm;
        if (inFile >> gm) {
            gameMode = static_cast<GameMode>(gm);
        }
        if (inFile >> aid) {
            aiDifficulty = static_cast<AIDifficulty>(aid);
        }
        if (inFile >> obm) {
            openingBreakMode = static_cast<OpeningBreakMode>(obm);
        }
        inFile.close();

        // Validate loaded settings (optional, but good practice)
        if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
        if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
        if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
    }
    // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
}
// --- End Settings Serialization Functions ---

// --- NEW Dialog Procedure ---
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_INITDIALOG:
    {
        // --- ACTION 4: Center Dialog Box ---
// Optional: Force centering if default isn't working
        RECT rcDlg, rcOwner, rcScreen;
        HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
        if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

        GetWindowRect(hwndOwner, &rcOwner);
        GetWindowRect(hDlg, &rcDlg);
        CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

        // Offset the owner rect relative to the screen if it's not the desktop
        if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
            OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
        }


        // Calculate centered position
        int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
        int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

        // Ensure it stays within screen bounds (optional safety)
        x = std::max(static_cast<int>(rcScreen.left), x);
        y = std::max(static_cast<int>(rcScreen.top), y);
        if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
            x = rcScreen.right - (rcDlg.right - rcDlg.left);
        if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
            y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


        // Set the dialog position
        SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

        // --- End Centering Code ---

        // Set initial state based on current global settings (or defaults)
        CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

        CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
            (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

        // Enable/Disable AI group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
        // Set initial state for Opening Break Mode
        CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
            (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
        // Enable/Disable Opening Break group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
    }
    return (INT_PTR)TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_RADIO_2P:
        case IDC_RADIO_CPU:
        {
            bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
            // Enable/Disable AI group controls based on selection
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
            // Also enable/disable Opening Break Mode group
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
        }
        return (INT_PTR)TRUE;

        case IDOK:
            // Retrieve selected options and store in global variables
            if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                gameMode = HUMAN_VS_AI;
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
            }
            else {
                gameMode = HUMAN_VS_HUMAN;
                // openingBreakMode doesn't apply to HvsH, can leave as is or reset
            }
            SaveSettings(); // Save settings when OK is pressed
            EndDialog(hDlg, IDOK); // Close dialog, return IDOK
            return (INT_PTR)TRUE;

        case IDCANCEL: // Handle Cancel or closing the dialog
            // Optionally, could reload settings here if you want cancel to revert to previously saved state
            EndDialog(hDlg, IDCANCEL);
            return (INT_PTR)TRUE;
        }
        break; // End WM_COMMAND
    }
    return (INT_PTR)FALSE; // Default processing
}

// --- NEW Helper to Show Dialog ---
void ShowNewGameDialog(HINSTANCE hInstance) {
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
        // User clicked Start, reset game with new settings
        isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""CPU (Easy)""; break;
            case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
            case HARD: player2Info.name = L""CPU (Hard)""; break;
            }
        }
        else {
            player2Info.name = L""Player 2"";
        }
        // Update window title
        std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
        SetWindowText(hwndMain, windowTitle.c_str());

        InitGame(); // Re-initialize game logic & board
        InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
    }
    else {
        // User cancelled dialog - maybe just resume game? Or exit?
        // For simplicity, we do nothing, game continues as it was.
        // To exit on cancel from F2, would need more complex state management.
    }
}

// --- NEW Reset Game Function ---
void ResetGame(HINSTANCE hInstance) {
    // Call the helper function to show the dialog and re-init if OK clicked
    ShowNewGameDialog(hInstance);
}

// --- WinMain ---
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    if (FAILED(CoInitialize(NULL))) {
        MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
        return -1;
    }

    // --- NEW: Load settings at startup ---
    LoadSettings();

    // --- NEW: Show configuration dialog FIRST ---
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
        // User cancelled the dialog
        CoUninitialize();
        return 0; // Exit gracefully if dialog cancelled
    }
    // Global gameMode and aiDifficulty are now set by the DialogProc

    // Set AI flag based on game mode
    isPlayer2AI = (gameMode == HUMAN_VS_AI);
    if (isPlayer2AI) {
        switch (aiDifficulty) {
        case EASY: player2Info.name = L""CPU (Easy)""; break;
        case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
        case HARD: player2Info.name = L""CPU (Hard)""; break;
        }
    }
    else {
        player2Info.name = L""Player 2"";
    }
    // --- End of Dialog Logic ---


    WNDCLASS wc = { };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L""Direct2D_8BallPool"";
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // --- ACTION 4: Calculate Centered Window Position ---
    const int WINDOW_WIDTH = 1000; // Define desired width
    const int WINDOW_HEIGHT = 700; // Define desired height
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WINDOW_WIDTH) / 2;
    int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

    // --- Change Window Title based on mode ---
    std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
    if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
    else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

    hwndMain = CreateWindowEx(
        0, L""Direct2D_8BallPool"", windowTitle.c_str(), dwStyle,
        windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL, NULL, hInstance, NULL
    );

    if (!hwndMain) {
        MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // Initialize Direct2D Resources AFTER window creation
    if (FAILED(CreateDeviceResources())) {
        MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    InitGame(); // Initialize game state AFTER resources are ready & mode is set
    Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
    StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
    //PlayGameMusic(hwndMain); //midi func

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
        MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    MSG msg = { };
    // --- Modified Main Loop ---
    // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
    // or gets reset to it via F2. The main loop runs normally once game starts.
    while (GetMessage(&msg, NULL, 0, 0)) {
        // We might need modeless dialog handling here if F2 shows dialog
        // while window is active, but DialogBoxParam is modal.
        // Let's assume F2 hides main window, shows dialog, then restarts game loop.
        // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    KillTimer(hwndMain, ID_TIMER);
    DiscardDeviceResources();
    SaveSettings(); // Save settings on exit
    CoUninitialize();

    return (int)msg.wParam;
}

// --- WndProc ---
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // Declare cueBall pointer once at the top, used in multiple cases
    // For clarity, often better to declare within each case where needed.
    Ball* cueBall = nullptr; // Initialize to nullptr
    switch (msg) {
    case WM_CREATE:
        // Resources are now created in WinMain after CreateWindowEx
        return 0;

    case WM_PAINT:
        OnPaint();
        // Validate the entire window region after painting
        ValidateRect(hwnd, NULL);
        return 0;

    case WM_SIZE: {
        UINT width = LOWORD(lParam);
        UINT height = HIWORD(lParam);
        OnResize(width, height);
        return 0;
    }

    case WM_TIMER:
        if (wParam == ID_TIMER) {
            GameUpdate(); // Update game logic and physics
            InvalidateRect(hwnd, NULL, FALSE); // Request redraw
        }
        return 0;

        // --- NEW: Handle F2 Key for Reset ---
        // --- MODIFIED: Handle More Keys ---
    case WM_KEYDOWN:
    { // Add scope for variable declarations

        // --- FIX: Get Cue Ball pointer for this scope ---
        cueBall = GetCueBall();
        // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
        // --- End Fix ---

        // Check which player can interact via keyboard (Humans only)
        bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

        // --- F1 / F2 Keys (Always available) ---
        if (wParam == VK_F2) {
            HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
            ResetGame(hInstance); // Call reset function
            return 0; // Indicate key was processed
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Direct2D-based StickPool game made in C++ from scratch (2764+ lines of code)\n"" // Update line count if needed
                L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                L""About This Game"", MB_OK | MB_ICONINFORMATION);
            return 0; // Indicate key was processed
        }

        // Check for 'M' key (uppercase or lowercase)
            // Toggle music with ""M""
        if (wParam == 'M' || wParam == 'm') {
            //static bool isMusicPlaying = false;
            if (isMusicPlaying) {
                // Stop the music
                StopMidi();
                isMusicPlaying = false;
            }
            else {
                // Build the MIDI file path
                TCHAR midiPath[MAX_PATH];
                GetModuleFileName(NULL, midiPath, MAX_PATH);
                // Keep only the directory part
                TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                if (lastBackslash != NULL) {
                    *(lastBackslash + 1) = '\0';
                }
                // Append the MIDI filename
                _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                // Start playing MIDI
                StartMidi(hwndMain, midiPath);
                isMusicPlaying = true;
            }
        }


        // --- Player Interaction Keys (Only if allowed) ---
        if (canPlayerControl) {
            // --- Get Shift Key State ---
            bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
            float powerStep = 0.2f; // Power step (Adjust as needed)

            switch (wParam) {
            case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle -= angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle < 0) cueAngle += 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_RIGHT: // Rotate Cue Stick Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle += angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_UP: // Decrease Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower -= powerStep;
                    if (shotPower < 0.0f) shotPower = 0.0f;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_DOWN: // Increase Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower += powerStep;
                    if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_SPACE: // Trigger Shot
                if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                    && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                {
                    if (shotPower > 0.15f) { // Use same threshold as mouse
                       // Reset foul flags BEFORE applying shot
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;

                        // Play sound & Apply Shot
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                        // Update State
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false;
                        pocketedThisTurn.clear();
                        shotPower = 0; // Reset power after shooting
                        isAiming = false; isDraggingStick = false; // Reset aiming flags
                        keyboardAimingActive = false;
                    }
                }
                break;

            case VK_ESCAPE: // Cancel Aim/Shot Setup
                if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                {
                    shotPower = 0.0f;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = false;
                    // Revert to basic turn state if not breaking
                    if (currentGameState != BREAKING) {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    }
                }
                break;

            case 'G': // Toggle Cheat Mode
                cheatModeEnabled = !cheatModeEnabled;
                if (cheatModeEnabled)
                    MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                else
                    MessageBeep(MB_OK); // Play a different beep when disabling
                break;

            default:
                // Allow default processing for other keys if needed
                // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                break;
            } // End switch(wParam) for player controls
            return 0; // Indicate player control key was processed
        } // End if(canPlayerControl)
    } // End scope for WM_KEYDOWN case
    // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
    // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
    return 0;

    case WM_MOUSEMOVE: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Hover ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
            int oldHover = currentlyHoveredPocket;
            currentlyHoveredPocket = -1; // Reset
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    currentlyHoveredPocket = i;
                    break;
                }
            }
            if (oldHover != currentlyHoveredPocket) {
                InvalidateRect(hwnd, NULL, FALSE);
            }
            // Do NOT return 0 here, allow normal mouse angle update to continue
        }
        // --- END NEW LOGIC ---


        cueBall = GetCueBall(); // Declare and get cueBall pointer

        if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
            Ball* ball = GetBallById(draggingBallId);
            if (ball) {
                ball->x = (float)ptMouse.x;
                ball->y = (float)ptMouse.y;
                ball->vx = ball->vy = 0.0f;
            }
            return 0;
        }

        if (!cueBall) return 0;

        // Update Aiming Logic (Check player turn)
        if (isDraggingCueBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                currentGameState == PRE_BREAK_PLACEMENT))
        {
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            // Tentative position update
            cueBall->x = (float)ptMouse.x;
            cueBall->y = (float)ptMouse.y;
            cueBall->vx = cueBall->vy = 0;
        }
        else if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            //NEW2 MOUSEBOUND CODE = START
                /*// Clamp mouse inside table bounds during aiming
                if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
            if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
            if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
            if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
            //NEW2 MOUSEBOUND CODE = END
            // Aiming drag updates angle and power
            float dx = (float)ptMouse.x - cueBall->x;
            float dy = (float)ptMouse.y - cueBall->y;
            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
            //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
            //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            }
        }
        else if (isSettingEnglish &&
            ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
        {
            // Setting English
            float dx = (float)ptMouse.x - spinIndicatorCenter.x;
            float dy = (float)ptMouse.y - spinIndicatorCenter.y;
            float dist = GetDistance(dx, dy, 0, 0);
            if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
            cueSpinX = dx / spinIndicatorRadius;
            cueSpinY = dy / spinIndicatorRadius;
        }
        else {
            //DISABLE PERM AIMING = START
            /*// Update visual angle even when not aiming/dragging (Check player turn)
            bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

            if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
            {
                // NEW MOUSEBOUND CODE = START
                    // Only update cue angle if mouse is inside the playable table area
                if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                    ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                {
                    // NEW MOUSEBOUND CODE = END
                    Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                    if (cb) {
                        float dx = (float)ptMouse.x - cb->x;
                        float dy = (float)ptMouse.y - cb->y;
                        if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    }
                } //NEW MOUSEBOUND CODE LINE = DISABLE
            }*/
            //DISABLE PERM AIMING = END
        }
        return 0;
    } // End WM_MOUSEMOVE

    case WM_LBUTTONDOWN: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Selection First ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

            int clickedPocketIndex = -1;
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    clickedPocketIndex = i;
                    break;
                }
            }

            if (clickedPocketIndex != -1) { // Player clicked on a pocket to select it
                if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                else calledPocketP2 = clickedPocketIndex;
                // After selecting, transition to the normal aiming turn state
                currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                pocketCallMessage = L""""; // Clear the message
                InvalidateRect(hwnd, NULL, FALSE);
                return 0; // Consume the click
            }
            // If they click anywhere else, do nothing and let them re-choose
            return 0;
        }
        // --- END NEW LOGIC ---


        if (cheatModeEnabled) {
            // Allow dragging any ball freely
            for (Ball& ball : balls) {
                float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                    isDraggingCueBall = true;
                    draggingBallId = ball.id;
                    if (ball.id == 0) {
                        // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                        if (currentPlayer == 1)
                            currentGameState = BALL_IN_HAND_P1;
                        else if (currentPlayer == 2 && !isPlayer2AI)
                            currentGameState = BALL_IN_HAND_P2;
                    }
                    return 0;
                }
            }
        }

        Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

        // Check which player is allowed to interact via mouse click
        bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
        // Define states where interaction is generally allowed
        bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == AIMING || currentGameState == BREAKING ||
            currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
            currentGameState == PRE_BREAK_PLACEMENT);

        // Check Spin Indicator first (Allow if player's turn/aim phase)
        if (canPlayerClickInteract && canInteractState) {
            float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
            if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                isSettingEnglish = true;
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
                isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                return 0;
            }
        }

        if (!cueBall) return 0;

        // Check Ball-in-Hand placement/drag
        bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
        bool isPlayerAllowedToPlace = (isPlacingBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

        if (isPlayerAllowedToPlace) {
            float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                isDraggingCueBall = true;
                isAiming = false; isDraggingStick = false;
            }
            else {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                    cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                    cueBall->vx = 0; cueBall->vy = 0;
                    isDraggingCueBall = false;
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
            }
            return 0;
        }

        // Check for starting Aim (Cue Ball OR Stick)
        bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

        if (canAim) {
            const float stickDrawLength = 150.0f * 1.4f;
            float currentStickAngle = cueAngle + PI;
            D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
            D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
            float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
            float stickClickThresholdSq = 36.0f;
            float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

            bool clickedStick = (distToStickSq < stickClickThresholdSq);
            bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

            if (clickedStick || clickedCueArea) {
                isDraggingStick = clickedStick && !clickedCueArea;
                isAiming = clickedCueArea;
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                shotPower = 0;
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                if (currentGameState != BREAKING) currentGameState = AIMING;
            }
        }
        return 0;
    } // End WM_LBUTTONDOWN


    case WM_LBUTTONUP: {
        if (cheatModeEnabled && isDraggingCueBall) {
            isDraggingCueBall = false;
            if (draggingBallId == 0) {
                // After dropping CueBall, stay Ball-In-Hand mode if needed
                if (currentPlayer == 1)
                    currentGameState = BALL_IN_HAND_P1;
                else if (currentPlayer == 2 && !isPlayer2AI)
                    currentGameState = BALL_IN_HAND_P2;
            }
            draggingBallId = -1;
            return 0;
        }

        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        Ball* cueBall = GetCueBall(); // Get cueBall pointer

        // Check for releasing aim drag (Stick OR Cue Ball)
        if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            bool wasAiming = isAiming;
            bool wasDraggingStick = isDraggingStick;
            isAiming = false; isDraggingStick = false;

            if (shotPower > 0.15f) { // Check power threshold
                if (currentGameState != AI_THINKING) {
                    firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false; pocketedThisTurn.clear();
                }
            }
            else if (currentGameState != AI_THINKING) { // Revert state if power too low
                if (currentGameState == BREAKING) { /* Still breaking */ }
                else {
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                }
            }
            shotPower = 0; // Reset power indicator regardless
        }

        // Handle releasing cue ball drag (placement)
        if (isDraggingCueBall) {
            isDraggingCueBall = false;
            // Check player allowed to place
            bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowed = (isPlacingState &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT)));

            if (isPlayerAllowed && cueBall) {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                    // Finalize position already set by mouse move
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
                else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
            }
        }

        // Handle releasing english setting
        if (isSettingEnglish) {
            isSettingEnglish = false;
        }
        return 0;
    } // End WM_LBUTTONUP

    case WM_DESTROY:
        isMusicPlaying = false;
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
            SaveSettings(); // Save settings on exit
        }
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// --- Direct2D Resource Management ---

HRESULT CreateDeviceResources() {
    HRESULT hr = S_OK;

    // Create Direct2D Factory
    if (!pFactory) {
        hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr)) return hr;
    }

    // Create DirectWrite Factory
    if (!pDWriteFactory) {
        hr = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (FAILED(hr)) return hr;
    }

    // Create Text Formats
    if (!pTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            16.0f, L""en-us"", &pTextFormat
        );
        if (FAILED(hr)) return hr;
        // Center align text
        pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }
    if (!pLargeTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            48.0f, L""en-us"", &pLargeTextFormat
        );
        if (FAILED(hr)) return hr;
        pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
        pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }


    // Create Render Target (needs valid hwnd)
    if (!pRenderTarget && hwndMain) {
        RECT rc;
        GetClientRect(hwndMain, &rc);
        D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

        hr = pFactory->CreateHwndRenderTarget(
            D2D1::RenderTargetProperties(),
            D2D1::HwndRenderTargetProperties(hwndMain, size),
            &pRenderTarget
        );
        if (FAILED(hr)) {
            // If failed, release factories if they were created in this call
            SafeRelease(&pTextFormat);
            SafeRelease(&pLargeTextFormat);
            SafeRelease(&pDWriteFactory);
            SafeRelease(&pFactory);
            pRenderTarget = nullptr; // Ensure it's null on failure
            return hr;
        }
    }

    return hr;
}

void DiscardDeviceResources() {
    SafeRelease(&pRenderTarget);
    SafeRelease(&pTextFormat);
    SafeRelease(&pLargeTextFormat);
    SafeRelease(&pDWriteFactory);
    // Keep pFactory until application exit? Or release here too? Let's release.
    SafeRelease(&pFactory);
}

void OnResize(UINT width, UINT height) {
    if (pRenderTarget) {
        D2D1_SIZE_U size = D2D1::SizeU(width, height);
        pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
    }
}

// --- Game Initialization ---
void InitGame() {
    srand((unsigned int)time(NULL)); // Seed random number generator
    isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
    aiPlannedShotDetails.isValid = false; // Reset AI planned shot
    aiIsDisplayingAim = false;
    aiAimDisplayFramesLeft = 0;
    // ... (rest of InitGame())

    // --- Ensure pocketed list is clear from the absolute start ---
    pocketedThisTurn.clear();

    balls.clear(); // Clear existing balls

    // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
    player1Info.assignedType = BallType::NONE;
    player1Info.ballsPocketedCount = 0;
    // Player 1 Name usually remains ""Player 1""
    player2Info.assignedType = BallType::NONE;
    player2Info.ballsPocketedCount = 0;
    // Player 2 Name is set based on gameMode in ShowNewGameDialog

    // Create Cue Ball (ID 0)
    // Initial position will be set during PRE_BREAK_PLACEMENT state
    balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

    // --- Create Object Balls (Temporary List) ---
    std::vector<Ball> objectBalls;
    // Solids (1-7, Yellow)
    for (int i = 1; i <= 7; ++i) {
        objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
    }
    // Stripes (9-15, Red)
    for (int i = 9; i <= 15; ++i) {
        objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
    }
    // 8-Ball (ID 8) - Add it to the list to be placed
    objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


    // --- Racking Logic (Improved) ---
    float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
    float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

    // Define rack positions (0-14 indices corresponding to triangle spots)
    D2D1_POINT_2F rackPositions[15];
    int rackIndex = 0;
    for (int row = 0; row < 5; ++row) {
        for (int col = 0; col <= row; ++col) {
            if (rackIndex >= 15) break;
            float x = RACK_POS_X + row * spacingX;
            float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
            rackPositions[rackIndex++] = D2D1::Point2F(x, y);
        }
    }

    // Separate 8-ball
    Ball eightBall;
    std::vector<Ball> otherBalls; // Solids and Stripes
    bool eightBallFound = false;
    for (const auto& ball : objectBalls) {
        if (ball.id == 8) {
            eightBall = ball;
            eightBallFound = true;
        }
        else {
            otherBalls.push_back(ball);
        }
    }
    // Ensure 8 ball was actually created (should always be true)
    if (!eightBallFound) {
        // Handle error - perhaps recreate it? For now, proceed.
        eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
    }


    // Shuffle the other 14 balls
    // Use std::shuffle if available (C++11 and later) for better randomness
    // std::random_device rd;
    // std::mt19937 g(rd());
    // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
    std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

    // --- Place balls into the main 'balls' vector in rack order ---
    // Important: Add the cue ball (already created) first.
    // (Cue ball added at the start of the function now)

    // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
    int eightBallRackIndex = 4;
    eightBall.x = rackPositions[eightBallRackIndex].x;
    eightBall.y = rackPositions[eightBallRackIndex].y;
    eightBall.vx = 0;
    eightBall.vy = 0;
    eightBall.isPocketed = false;
    balls.push_back(eightBall); // Add 8 ball to the main vector

    // 2. Place the shuffled Solids and Stripes in the remaining spots
    size_t otherBallIdx = 0;
    //int otherBallIdx = 0;
    for (int i = 0; i < 15; ++i) {
        if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

        if (otherBallIdx < otherBalls.size()) {
            Ball& ballToPlace = otherBalls[otherBallIdx++];
            ballToPlace.x = rackPositions[i].x;
            ballToPlace.y = rackPositions[i].y;
            ballToPlace.vx = 0;
            ballToPlace.vy = 0;
            ballToPlace.isPocketed = false;
            balls.push_back(ballToPlace); // Add to the main game vector
        }
    }
    // --- End Racking Logic ---


    // --- Determine Who Breaks and Initial State ---
    if (isPlayer2AI) {
        /*// AI Mode: Randomly decide who breaks
        if ((rand() % 2) == 0) {
            // AI (Player 2) breaks
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
            aiTurnPending = true; // Trigger AI logic
        }
        else {
            // Player 1 (Human) breaks
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
            aiTurnPending = false;*/
        switch (openingBreakMode) {
        case CPU_BREAK:
            currentPlayer = 2; // AI breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        case P1_BREAK:
            currentPlayer = 1; // Player 1 breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false;
            break;
        case FLIP_COIN_BREAK:
            if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
            }
            else {
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
            }
            break;
        default: // Fallback to CPU break
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        }
    }
    else {
        // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
        currentPlayer = 1;
        currentGameState = PRE_BREAK_PLACEMENT;
        aiTurnPending = false; // No AI involved
    }

    // Reset other relevant game state variables
    foulCommitted = false;
    gameOverMessage = L"""";
    firstBallPocketedAfterBreak = false;
    // pocketedThisTurn cleared at start
    // Reset shot parameters and input flags
    shotPower = 0.0f;
    cueSpinX = 0.0f;
    cueSpinY = 0.0f;
    isAiming = false;
    isDraggingCueBall = false;
    isSettingEnglish = false;
    cueAngle = 0.0f; // Reset aim angle
}


// --- Game Loop ---
void GameUpdate() {
    if (currentGameState == SHOT_IN_PROGRESS) {
        UpdatePhysics();
        CheckCollisions();

        if (AreBallsMoving()) {
            // When all balls stop, clear aiming flags
            isAiming = false;
            aiIsDisplayingAim = false;
            //ProcessShotResults();
        }

        bool pocketed = CheckPockets(); // Store if any ball was pocketed

        // --- Update pocket flash animation timer ---
        if (pocketFlashTimer > 0.0f) {
            pocketFlashTimer -= 0.02f;
            if (pocketFlashTimer < 0.0f) pocketFlashTimer = 0.0f;
        }

        if (!AreBallsMoving()) {
            ProcessShotResults(); // Determine next state based on what happened
        }
    }

    // --- Check if AI needs to act ---
    else if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
        if (aiIsDisplayingAim) { // AI has decided a shot and is displaying aim
            aiAimDisplayFramesLeft--;
            if (aiAimDisplayFramesLeft <= 0) {
                aiIsDisplayingAim = false; // Done displaying
                if (aiPlannedShotDetails.isValid) {
                    // Execute the planned shot
                    firstHitBallIdThisShot = -1;
                    cueHitObjectBallThisShot = false;
                    railHitAfterContact = false;
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
                    aiPlannedShotDetails.isValid = false; // Clear the planned shot
                }
                currentGameState = SHOT_IN_PROGRESS;
                foulCommitted = false;
                pocketedThisTurn.clear();
            }
            // Else, continue displaying aim
        }
        else if (aiTurnPending) { // AI needs to start its decision process
            // Valid states for AI to start thinking
            /*/if (currentGameState == PRE_BREAK_PLACEMENT && isOpeningBreakShot) {*/
            //newcode 1 commented out
            /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
                // Handle the break shot
                AIBreakShot();
            }*/ //new code 1 end  
            /*else if (currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING ||
                currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2) {*/

                // aiTurnPending might be consumed by AIBreakShot or remain for next cycle if needed
        /* } //new code 2 commented out
        else if (currentGameState == BALL_IN_HAND_P2 && currentPlayer == 2 && isPlayer2AI) {
            AIPlaceCueBall(); // AI places the ball first
            // After placement, AI needs to decide its shot.
            // Transition to a state where AIMakeDecision will be called for shot selection.
            currentGameState = PLAYER2_TURN; // Or a specific AI_AIMING_AFTER_PLACEMENT state
                                             // aiTurnPending remains true to trigger AIMakeDecision next.
        }
        else if (currentGameState == PLAYER2_TURN && currentPlayer == 2 && isPlayer2AI) {
            // This is for a normal turn (not break, not immediately after ball-in-hand placement)

                currentGameState = AI_THINKING; // Set state to indicate AI is processing
                aiTurnPending = false;         // Consume the pending turn flag
                AIMakeDecision();              // For normal shots (non-break)
            }
            else {
                // Not a state where AI should act
                aiTurnPending = false;
            }*/
            // 2b) AI is ready to think (pending flag)
            // **1) Ball-in-Hand** let AI place the cue ball first
            if (currentGameState == BALL_IN_HAND_P2) {
                // Step 1: AI places the cue ball.
                AIPlaceCueBall();
                // Step 2: Transition to thinking state for shot decision.
                currentGameState = AI_THINKING; //newcode5
                // Step 3: Consume the pending flag for the placement phase.
                //         AIMakeDecision will handle shot planning now.
                aiTurnPending = false; //newcode5
                // Step 4: AI immediately decides the shot from the new position.
                AIMakeDecision(); //newcode5
            }
            // **2) Opening break** special break shot logic
            else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                AIBreakShot();
            }
            else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) { //newcode5
                // General turn for AI to think (not ball-in-hand, not initial break placement)
                currentGameState = AI_THINKING; //newcode5
                aiTurnPending = false; // Consume the flag //newcode5
                AIMakeDecision(); //newcode5
            }
            // **3) Otherwise** normal shot planning
            /*else { //orig uncommented oldcode5
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
            }*/
        }

        //} //bracefix
        // If current state is AI_THINKING but not displaying aim, then AI decision has already been made
    }
}

// --- Physics and Collision ---
void UpdatePhysics() {
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) {
            b.x += b.vx;
            b.y += b.vy;

            // Apply friction
            b.vx *= FRICTION;
            b.vy *= FRICTION;

            // Stop balls if velocity is very low
            if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                b.vx = 0;
                b.vy = 0;
            }
        }
    }
}

void CheckCollisions() {
    float left = TABLE_LEFT;
    float right = TABLE_RIGHT;
    float top = TABLE_TOP;
    float bottom = TABLE_BOTTOM;
    const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

    // --- Reset Per-Frame Sound Flags ---
    bool playedWallSoundThisFrame = false;
    bool playedCollideSoundThisFrame = false;
    // ---

    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b1 = balls[i];
        if (b1.isPocketed) continue;

        bool nearPocket[6];
        for (int p = 0; p < 6; ++p) {
            nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
        }
        bool nearTopLeftPocket = nearPocket[0];
        bool nearTopMidPocket = nearPocket[1];
        bool nearTopRightPocket = nearPocket[2];
        bool nearBottomLeftPocket = nearPocket[3];
        bool nearBottomMidPocket = nearPocket[4];
        bool nearBottomRightPocket = nearPocket[5];

        bool collidedWallThisBall = false;

        // --- Ball-Wall Collisions ---
        // (Check logic unchanged, added sound calls and railHitAfterContact update)
        // Left Wall
        if (b1.x - BALL_RADIUS < left) {
            if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Right Wall
        if (b1.x + BALL_RADIUS > right) {
            if (!nearTopRightPocket && !nearBottomRightPocket) {
                b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Top Wall
        if (b1.y - BALL_RADIUS < top) {
            if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Bottom Wall
        if (b1.y + BALL_RADIUS > bottom) {
            if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }

        // Spin effect (Unchanged)
        if (collidedWallThisBall) {
            if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
            if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
            cueSpinX *= 0.7f; cueSpinY *= 0.7f;
        }


        // --- Ball-Ball Collisions ---
        for (size_t j = i + 1; j < balls.size(); ++j) {
            Ball& b2 = balls[j];
            if (b2.isPocketed) continue;

            float dx = b2.x - b1.x; float dy = b2.y - b1.y;
            float distSq = dx * dx + dy * dy;
            float minDist = BALL_RADIUS * 2.0f;

            if (distSq > 1e-6 && distSq < minDist * minDist) {
                float dist = sqrtf(distSq);
                float overlap = minDist - dist;
                float nx = dx / dist; float ny = dy / dist;

                // Separation (Unchanged)
                b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                float velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) { // Colliding
                    // --- Play Ball Collision Sound ---
                    if (!playedCollideSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                        playedCollideSoundThisFrame = true; // Set flag
                    }
                    // --- End Sound ---

                    // --- NEW: Track First Hit and Cue/Object Collision ---
                    if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                        if (b1.id == 0) { // Cue ball hit b2 first
                            firstHitBallIdThisShot = b2.id;
                            cueHitObjectBallThisShot = true;
                        }
                        else if (b2.id == 0) { // Cue ball hit b1 first
                            firstHitBallIdThisShot = b1.id;
                            cueHitObjectBallThisShot = true;
                        }
                        // If neither is cue ball, doesn't count as first hit for foul purposes
                    }
                    else if (b1.id == 0 || b2.id == 0) {
                        // Track subsequent cue ball collisions with object balls
                        cueHitObjectBallThisShot = true;
                    }
                    // --- End First Hit Tracking ---


                    // Impulse (Unchanged)
                    float impulse = velAlongNormal;
                    b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                    b2.vx += impulse * nx; b2.vy += impulse * ny;

                    // Spin Transfer (Unchanged)
                    if (b1.id == 0 || b2.id == 0) {
                        float spinEffectFactor = 0.08f;
                        b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                    }
                }
            }
        } // End ball-ball loop
    } // End ball loop
} // End CheckCollisions


bool CheckPockets() {
    bool ballPocketedThisCheck = false; // Local flag for this specific check run
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) { // Only check balls that aren't already flagged as pocketed
            for (int p = 0; p < 6; ++p) {
                float distSq = GetDistanceSq(b.x, b.y, pocketPositions[p].x, pocketPositions[p].y);
                // --- Use updated POCKET_RADIUS ---
                if (distSq < POCKET_RADIUS * POCKET_RADIUS) {
                    b.isPocketed = true;
                    b.vx = b.vy = 0;
                    pocketedThisTurn.push_back(b.id);

                    // --- Play Pocket Sound (Threaded) ---
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound ---

                    break; // Ball is pocketed
                }
            }
        }
    }
    return ballPocketedThisCheck;
}

bool AreBallsMoving() {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
            return true;
        }
    }
    return false;
}

void RespawnCueBall(bool behindHeadstring) { // 'behindHeadstring' only relevant for initial break placement
    Ball* cueBall = GetCueBall();
    if (cueBall) {
        // Reset position to a default
        //disabled for behind headstring (now move anywhere)
        /*cueBall->x = HEADSTRING_X * 0.5f;
        cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;*/
        // Reset position to a default:
        if (behindHeadstring) {
            // Opening break: kitchen center
            cueBall->x = HEADSTRING_X * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        else {
            // Ball-in-hand (foul): center of full table
            cueBall->x = TABLE_LEFT + TABLE_WIDTH / 2.0f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        cueBall->vx = 0;
        cueBall->vy = 0;
        cueBall->isPocketed = false;

        // Set state based on who gets ball-in-hand
        /*// 'currentPlayer' already reflects who's turn it is NOW (switched before calling this)*/
        // 'currentPlayer' has already been switched to the player whose turn it will be.
        // The 'behindHeadstring' parameter to RespawnCueBall is mostly for historical reasons / initial setup.
        if (currentPlayer == 1) { // Player 2 (AI/Human) fouled, Player 1 (Human) gets ball-in-hand
            currentGameState = BALL_IN_HAND_P1;
            aiTurnPending = false; // Ensure AI flag off
        }
        else { // Player 1 (Human) fouled, Player 2 gets ball-in-hand
            if (isPlayer2AI) {
                // --- CONFIRMED FIX: Set correct state for AI Ball-in-Hand ---
                currentGameState = BALL_IN_HAND_P2; // AI now needs to place the ball
                aiTurnPending = true; // Trigger AI logic (will call AIPlaceCueBall first)
            }
            else { // Human Player 2
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = false; // Ensure AI flag off
            }
        }
        // Handle initial placement state correctly if called from InitGame
        /*if (behindHeadstring && currentGameState != PRE_BREAK_PLACEMENT) {
            // This case might need review depending on exact initial setup flow,
            // but the foul logic above should now be correct.
            // Let's ensure initial state is PRE_BREAK_PLACEMENT if behindHeadstring is true.*/
            //currentGameState = PRE_BREAK_PLACEMENT;
    }
}
//}


// --- Game Logic ---

void ApplyShot(float power, float angle, float spinX, float spinY) {
    Ball* cueBall = GetCueBall();
    if (cueBall) {

        // --- Play Cue Strike Sound (Threaded) ---
        if (power > 0.1f) { // Only play if it's an audible shot
            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
        }
        // --- End Sound ---

        cueBall->vx = cosf(angle) * power;
        cueBall->vy = sinf(angle) * power;

        // Apply English (Spin) - Simplified effect (Unchanged)
        cueBall->vx += sinf(angle) * spinY * 0.5f;
        cueBall->vy -= cosf(angle) * spinY * 0.5f;
        cueBall->vx -= cosf(angle) * spinX * 0.5f;
        cueBall->vy -= sinf(angle) * spinX * 0.5f;

        // Store spin (Unchanged)
        cueSpinX = spinX;
        cueSpinY = spinY;

        // --- Reset Foul Tracking flags for the new shot ---
        // (Also reset in LBUTTONUP, but good to ensure here too)
        firstHitBallIdThisShot = -1;      // No ball hit yet
        cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
        railHitAfterContact = false;     // No rail hit after contact yet
        // --- End Reset ---

                // If this was the opening break shot, clear the flag
        if (isOpeningBreakShot) {
            isOpeningBreakShot = false; // Mark opening break as taken
        }
    }
}


void ProcessShotResults() {
    bool cueBallPocketed = false;
    bool eightBallPocketed = false;
    bool legalBallPocketed = false;

    // --- FIX: Update Ball Counts FIRST ---
    // This is the critical change. We must update the score before any other logic.
    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    for (int id : pocketedThisTurn) {
        Ball* b = GetBallById(id);
        if (!b) continue;

        if (b->id == 0) {
            cueBallPocketed = true;
        }
        else if (b->id == 8) {
            eightBallPocketed = true;
        }
        else {
            // This is a numbered ball. Update the pocketed count for the correct player.
            if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) {
                player1Info.ballsPocketedCount++;
            }
            else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) {
                player2Info.ballsPocketedCount++;
            }

            // Check if the current shooter pocketed one of their own balls
            if (b->type == shootingPlayer.assignedType) {
                legalBallPocketed = true;
            }
        }
    }
    // --- END FIX ---

    // Now that counts are updated, check for a game-ending 8-ball shot.
    if (eightBallPocketed) {
        CheckGameOverConditions(true, cueBallPocketed);
        if (currentGameState == GAME_OVER) {
            pocketedThisTurn.clear();
            return;
        }
    }

    // Determine if a foul occurred on the shot.
    bool turnFoul = false;
    if (cueBallPocketed) {
        turnFoul = true;
    }
    else {
        Ball* firstHit = GetBallById(firstHitBallIdThisShot);
        if (!firstHit) { // Rule: Hitting nothing is a foul.
            turnFoul = true;
        }
        else { // Rule: Hitting the wrong ball type is a foul.
            if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                if (IsPlayerOnEightBall(currentPlayer)) {
                    if (firstHit->id != 8) turnFoul = true; // Must hit 8-ball first.
                }
                else {
                    if (firstHit->type != shootingPlayer.assignedType) turnFoul = true; // Must hit own ball type.
                }
            }
        }
    }

    // Rule: No rail after contact is a foul.
    if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
        turnFoul = true;
    }

    foulCommitted = turnFoul;

    // --- State Transitions ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false); // Ball in hand for the opponent.
    }
    else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed && !eightBallPocketed) {
        // Table is open, and a legal ball was pocketed. Assign types.
        Ball* firstBall = GetBallById(pocketedThisTurn[0]);
        if (firstBall) AssignPlayerBallTypes(firstBall->type);
        // The player's turn continues. NOW, check if they are on the 8-ball.
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else if (legalBallPocketed) {
        // Player legally pocketed one of their own balls. Their turn continues.
        // The ball count is now correct, so this check will work perfectly.
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        // Player missed, or pocketed an opponent's ball without a foul. Turn switches.
        SwitchTurns();
    }

    pocketedThisTurn.clear(); // Clean up for the next shot.
}

void AssignPlayerBallTypes(BallType firstPocketedType) {
    if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
        if (currentPlayer == 1) {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        else {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
    }
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.
}

void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
    if (!eightBallPocketed) return;

    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;
    bool shooterWasOn8Ball = IsPlayerOnEightBall(currentPlayer);
    int pocketThe8BallEntered = -1;

    // Find which pocket the 8-ball actually went into
    Ball* b = GetBallById(8);
    if (b) {
        for (int p_idx = 0; p_idx < 6; ++p_idx) {
            if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                pocketThe8BallEntered = p_idx;
                break;
            }
        }
    }

    // Case 1: 8-ball pocketed on the break (or before colors assigned)
    if (player1Info.assignedType == BallType::NONE) {
        if (b) { // Re-spot the 8-ball
            b->isPocketed = false;
            b->x = RACK_POS_X;
            b->y = RACK_POS_Y;
            b->vx = b->vy = 0;
        }
        if (cueBallPocketed) {
            foulCommitted = true; // Let ProcessShotResults handle the foul, game doesn't end.
        }
        return; // Game continues
    }

    // Case 2: Normal gameplay win/loss conditions
    int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;

    if (!shooterWasOn8Ball) {
        // Loss: Pocketed 8-ball before clearing own group.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" pocketed 8-ball early)"";
    }
    else if (cueBallPocketed) {
        // Loss: Scratched while shooting for the 8-ball.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" scratched on 8-ball)"";
    }
    else if (calledPocket == -1) {
        // Loss: Pocketed 8-ball without calling a pocket. THIS IS THE KEY FIX FOR YOUR REPORTED PROBLEM.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" did not call a pocket)"";
    }
    else if (pocketThe8BallEntered != calledPocket) {
        // Loss: Pocketed 8-ball in the wrong pocket.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" 8-ball in wrong pocket)"";
    }
    else {
        // WIN! Pocketed 8-ball in the called pocket without a foul.
        gameOverMessage = shootingPlayer.name + L"" Wins!"";
    }

    currentGameState = GAME_OVER;
}


void SwitchTurns() {
    currentPlayer = (currentPlayer == 1) ? 2 : 1;
    isAiming = false;
    shotPower = 0;
    CheckAndTransitionToPocketChoice(currentPlayer); // Use the new helper
}

void AIBreakShot() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
    // AI will place the cue ball and then plan the shot.
    if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
        // Place cue ball in the kitchen randomly
        /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
        float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

        // --- AI Places Cue Ball for Break ---
// Decide if placing center or side. For simplicity, let's try placing slightly off-center
// towards one side for a more angled break, or center for direct apex hit.
// A common strategy is to hit the second ball of the rack.

        float placementY = RACK_POS_Y; // Align vertically with the rack center
        float placementX;

        // Randomly choose a side or center-ish placement for variation.
        int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

        if (placementChoice == 0) { // Left-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
        }
        else if (placementChoice == 2) { // Right-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
        }
        else { // Center-ish
            placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
        }
        placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

        bool validPos = false;
        int attempts = 0;
        while (!validPos && attempts < 100) {
            /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
            cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                validPos = true; // [cite: 1591]*/
                // Try the chosen X, but vary Y slightly to find a clear spot
            cueBall->x = placementX;
            cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
            cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                validPos = true;
            }
            attempts++; // [cite: 1592]
        }
        if (!validPos) {
            // Fallback position
            /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
            cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
            }
        }
        cueBall->vx = 0; // [cite: 1595]
        cueBall->vy = 0; // [cite: 1596]

        // Plan a break shot: aim at the center of the rack (apex ball)
        float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
        float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

        float dx = targetX - cueBall->x; // [cite: 1599]
        float dy = targetY - cueBall->y; // [cite: 1600]
        float shotAngle = atan2f(dy, dx); // [cite: 1600]
        float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
            cueBall->y = RACK_POS_Y;
        }
        cueBall->vx = 0; cueBall->vy = 0;

        // --- AI Plans the Break Shot ---
        float targetX, targetY;
        // If cue ball is near center of kitchen width, aim for apex.
        // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
        float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
        if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
            // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
            targetX = RACK_POS_X; // Apex ball X
            targetY = RACK_POS_Y; // Apex ball Y
        }
        else {
            // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
            // This is a simplification. A more robust way is to find the actual second ball.
            // For now, aim slightly off the apex towards the side the cue ball is on.
            targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
            targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
        }

        float dx = targetX - cueBall->x;
        float dy = targetY - cueBall->y;
        float shotAngle = atan2f(dy, dx);
        float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

        // Store planned shot details for the AI
        /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
        aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
        aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
        aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
        aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

        aiPlannedShotDetails.angle = shotAngle;
        aiPlannedShotDetails.power = shotPowerValue;
        aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
        /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
        ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
        ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
        ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

        ::cueAngle = aiPlannedShotDetails.angle;
        ::shotPower = aiPlannedShotDetails.power;
        ::cueSpinX = aiPlannedShotDetails.spinX;
        ::cueSpinY = aiPlannedShotDetails.spinY;

        // Set up for AI display via GameUpdate
        /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

        currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                        // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                        // and then execute the shot using aiPlannedShotDetails.
                                        // isOpeningBreakShot will be set to false within ApplyShot.

        // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display

        return; // The break shot is now planned and will be executed by GameUpdate
    }

    // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
    //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
    //    This part can be extended if AIBreakShot needs to handle other scenarios.
    //    For now, the primary logic is above.
}

// --- Helper Functions ---

Ball* GetBallById(int id) {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id == id) {
            return &balls[i];
        }
    }
    return nullptr;
}

Ball* GetCueBall() {
    return GetBallById(0);
}

float GetDistance(float x1, float y1, float x2, float y2) {
    return sqrtf(GetDistanceSq(x1, y1, x2, y2));
}

float GetDistanceSq(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return dx * dx + dy * dy;
}

bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
    // Basic bounds check (inside cushions)
    float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
    float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
    float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
    float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

    if (x < left || x > right || y < top || y > bottom) {
        return false;
    }

    // Check headstring restriction if needed
    if (checkHeadstring && x >= HEADSTRING_X) {
        return false;
    }

    // Check overlap with other balls
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
            if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                return false; // Overlapping another ball
            }
        }
    }

    return true;
}

// --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

// Checks if a player has pocketed all their balls and is now on the 8-ball.
bool IsPlayerOnEightBall(int player) {
    PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
    if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
        Ball* eightBall = GetBallById(8);
        return (eightBall && !eightBall->isPocketed);
    }
    return false;
}

// Centralized logic to enter the ""choosing pocket"" state. This fixes the indicator bugs.
void CheckAndTransitionToPocketChoice(int playerID) {
    bool needsToCall = IsPlayerOnEightBall(playerID);
    int* calledPocketForPlayer = (playerID == 1) ? &calledPocketP1 : &calledPocketP2;

    if (needsToCall && *calledPocketForPlayer == -1) { // Only transition if a pocket hasn't been called yet
        pocketCallMessage = ((playerID == 1) ? player1Info.name : player2Info.name) + L"": Choose a pocket..."";
        if (playerID == 1) {
            currentGameState = CHOOSING_POCKET_P1;
        }
        else { // Player 2
            if (isPlayer2AI) {
                currentGameState = AI_THINKING;
                aiTurnPending = true;
            }
            else {
                currentGameState = CHOOSING_POCKET_P2;
            }
        }
        if (!(playerID == 2 && isPlayer2AI)) {
            *calledPocketForPlayer = 5; // Default to top-right if none chosen
        }
    }
    else {
        // Player does not need to call a pocket (or already has), proceed to normal turn.
        pocketCallMessage = L""""; // Clear any message
        currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
        if (playerID == 2 && isPlayer2AI) {
            aiTurnPending = true;
        }
    }
}

template <typename T>
void SafeRelease(T** ppT) {
    if (*ppT) {
        (*ppT)->Release();
        *ppT = nullptr;
    }
}

// --- Helper Function for Line Segment Intersection ---
// Finds intersection point of line segment P1->P2 and line segment P3->P4
// Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
{
    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

    // Check if lines are parallel or collinear
    if (fabs(denominator) < 1e-6) {
        return false;
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    // Check if intersection point lies on both segments
    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
        intersection.x = p1.x + ua * (p2.x - p1.x);
        intersection.y = p1.y + ua * (p2.y - p1.y);
        return true;
    }

    return false;
}

// --- INSERT NEW HELPER FUNCTION HERE ---
// Calculates the squared distance from point P to the line segment AB.
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
    float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
    if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
    // Consider P projecting onto the line AB infinite line
    // t = [(P-A) . (B-A)] / |B-A|^2
    float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
    t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
    // Projection falls on the segment
    D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
    return GetDistanceSq(p.x, p.y, projection.x, projection.y);
}
// --- End New Helper ---

// --- NEW AI Implementation Functions ---

// Main entry point for AI turn
void AIMakeDecision() {
    //AIShotInfo bestShot = { false }; // Declare here
    // This function is called when currentGameState is AI_THINKING (for a normal shot decision)
    Ball* cueBall = GetCueBall();
    if (!cueBall || !isPlayer2AI || currentPlayer != 2) {
        aiPlannedShotDetails.isValid = false; // Ensure no shot if conditions not met
        return;
    }

    // Phase 1: Placement if needed (Ball-in-Hand or Initial Break)
    /*if ((isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) || currentGameState == BALL_IN_HAND_P2) {
        AIPlaceCueBall(); // Handles kitchen placement for break or regular ball-in-hand
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            currentGameState = BREAKING; // Now AI needs to decide the break shot parameters
        }
        // For regular BALL_IN_HAND_P2, after placement, it will proceed to find a shot.
    }*/

    aiPlannedShotDetails.isValid = false; // Default to no valid shot found yet for this decision cycle
    // Note: isOpeningBreakShot is false here because AIBreakShot handles the break.

     // Phase 2: Decide shot parameters (Break or Normal play)
    /*if (isOpeningBreakShot && currentGameState == BREAKING) {
        // Force cue ball into center of kitchen
        cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
        cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f;
        cueBall->vx = cueBall->vy = 0.0f;

        float rackCenterX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f * 2.0f;
        float rackCenterY = RACK_POS_Y;
        float dx = rackCenterX - cueBall->x;
        float dy = rackCenterY - cueBall->y;

        aiPlannedShotDetails.angle = atan2f(dy, dx);
        aiPlannedShotDetails.power = MAX_SHOT_POWER;
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Apply shot immediately
        cueAngle = aiPlannedShotDetails.angle;
        shotPower = aiPlannedShotDetails.power;
        cueSpinX = aiPlannedShotDetails.spinX;
        cueSpinY = aiPlannedShotDetails.spinY;

        firstHitBallIdThisShot = -1;
        cueHitObjectBallThisShot = false;
        railHitAfterContact = false;
        isAiming = false;
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        //bool aiIsDisplayingAim = true;

        std::thread([](const TCHAR* soundName) {
            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
            }, TEXT(""cue.wav"")).detach();

            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
            currentGameState = SHOT_IN_PROGRESS;
            isOpeningBreakShot = false;
            aiTurnPending = false;
            pocketedThisTurn.clear();
            return;
    }
    else {*/
    // --- Normal AI Shot Decision (using AIFindBestShot) ---
    AIShotInfo bestShot = AIFindBestShot(); // bugtraq
    //bestShot = AIFindBestShot(); // bugtraq
    if (bestShot.possible) {
        aiPlannedShotDetails.angle = bestShot.angle;
        aiPlannedShotDetails.power = bestShot.power;
        aiPlannedShotDetails.spinX = 0.0f; // AI doesn't use spin yet
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;
    }
    else {
        // Safety tap if no better shot found
        // Try to hit the closest 'own' ball gently or any ball if types not assigned
        Ball* ballToNudge = nullptr;
        float minDistSq = -1.0f;
        BallType aiTargetType = player2Info.assignedType;
        bool mustHit8Ball = (aiTargetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);

        for (auto& b : balls) {
            if (b.isPocketed || b.id == 0) continue;
            bool canHitThis = false;
            if (mustHit8Ball) canHitThis = (b.id == 8);
            else if (aiTargetType != BallType::NONE) canHitThis = (b.type == aiTargetType);
            else canHitThis = (b.id != 8); // Can hit any non-8-ball if types not assigned

            if (canHitThis) {
                float dSq = GetDistanceSq(cueBall->x, cueBall->y, b.x, b.y);
                if (ballToNudge == nullptr || dSq < minDistSq) {
                    ballToNudge = &b;
                    minDistSq = dSq;
                }
            }
        }
        if (ballToNudge) { // Found a ball to nudge
            aiPlannedShotDetails.angle = atan2f(ballToNudge->y - cueBall->y, ballToNudge->x - cueBall->x);
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.15f; // Gentle tap
        }
        else { // Absolute fallback: small tap forward
            aiPlannedShotDetails.angle = cueAngle; // Keep last angle or default
            //aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
        }
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true; // Safety shot is a ""valid"" plan
    }
    //} //bracefix

    // Phase 3: Setup for Aim Display (if a valid shot was decided)
    if (aiPlannedShotDetails.isValid) {
        cueAngle = aiPlannedShotDetails.angle;   // Update global for drawing
        shotPower = aiPlannedShotDetails.power;  // Update global for drawing
        // cueSpinX and cueSpinY could also be set here if AI used them
        cueSpinX = aiPlannedShotDetails.spinX; // Also set these for drawing consistency
        cueSpinY = aiPlannedShotDetails.spinY; //

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        // currentGameState remains AI_THINKING, GameUpdate will handle the display countdown and shot execution.
            // FIRE THE BREAK SHOT NOW
            // Immediately execute the break shot after setting parameters
        /*ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
        currentGameState = SHOT_IN_PROGRESS;
        aiTurnPending = false;
        isOpeningBreakShot = false;*/
    }
    else {
        // Should not happen if safety shot is always planned, but as a fallback:
        aiIsDisplayingAim = false;
        // If AI truly can't decide anything, maybe switch turn or log error. For now, it will do nothing this frame.
        // Or force a minimal safety tap without display.
        // To ensure game progresses, let's plan a minimal tap if nothing else.
        if (!aiPlannedShotDetails.isValid) { // Double check
            aiPlannedShotDetails.angle = 0.0f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.05f; // Very small tap
            aiPlannedShotDetails.spinX = 0.0f; aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;
            //cueAngle = aiPlannedShotDetails.angle; shotPower = aiPlannedShotDetails.power;
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;
            cueSpinX = aiPlannedShotDetails.spinX;
            cueSpinY = aiPlannedShotDetails.spinY;
            aiIsDisplayingAim = true; // Allow display for this minimal tap too
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES / 2; // Shorter display for fallback
        }
    }
    // aiTurnPending was set to false by GameUpdate before calling AIMakeDecision.
    // AIMakeDecision's job is to populate aiPlannedShotDetails and trigger display.
}

// AI logic for placing cue ball during ball-in-hand
void AIPlaceCueBall() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // --- CPU AI Opening Break: Kitchen Placement ---
    /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
        float kitchenMinX = TABLE_LEFT + BALL_RADIUS;
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS;
        float kitchenMinY = TABLE_TOP + BALL_RADIUS;
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS;
        bool validPositionFound = false;
        int attempts = 0;
        while (!validPositionFound && attempts < 100) {
            cueBall->x = kitchenMinX + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxX - kitchenMinX)));
            cueBall->y = kitchenMinY + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxY - kitchenMinY)));
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                validPositionFound = true;
            }
            attempts++;
        }
        if (!validPositionFound) {
            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2.0f;
                cueBall->y = RACK_POS_Y;
            }
        }
        cueBall->vx = 0; cueBall->vy = 0;
        return;
    }*/
    // --- End CPU AI Opening Break Placement ---

    // This function is now SOLELY for Ball-In-Hand placement for the AI (anywhere on the table).
    // Break placement is handled by AIBreakShot().

    // Simple Strategy: Find the easiest possible shot for the AI's ball type
    // Place the cue ball directly behind that target ball, aiming straight at a pocket.
    // (More advanced: find spot offering multiple options or safety)

    AIShotInfo bestPlacementShot = { false };
    D2D1_POINT_2F bestPlacePos = D2D1::Point2F(HEADSTRING_X * 0.5f, RACK_POS_Y); // Default placement

    // A better default for ball-in-hand (anywhere) might be center table if no shot found.
    bestPlacePos = D2D1::Point2F(TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP + TABLE_HEIGHT / 2.0f);
    float bestPlacementScore = -1.0f; // Keep track of the score for the best placement found

    BallType targetType = player2Info.assignedType;
    bool canTargetAnyPlacement = false; // Local scope variable for placement logic
    if (targetType == BallType::NONE) {
        canTargetAnyPlacement = true;
    }
    bool target8Ball = (!canTargetAnyPlacement && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    if (target8Ball) targetType = BallType::EIGHT_BALL;


    for (auto& targetBall : balls) {
        if (targetBall.isPocketed || targetBall.id == 0) continue;

        // Determine if current ball is a valid target for placement consideration
        bool currentBallIsValidTarget = false;
        if (target8Ball && targetBall.id == 8) currentBallIsValidTarget = true;
        else if (canTargetAnyPlacement && targetBall.id != 8) currentBallIsValidTarget = true;
        else if (!canTargetAnyPlacement && !target8Ball && targetBall.type == targetType) currentBallIsValidTarget = true;

        if (!currentBallIsValidTarget) continue; // Skip if not a valid target

        for (int p = 0; p < 6; ++p) {
            // Calculate ideal cue ball position: straight line behind target ball aiming at pocket p
            float targetToPocketX = pocketPositions[p].x - targetBall.x;
            float targetToPocketY = pocketPositions[p].y - targetBall.y;
            float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);
            if (dist < 1.0f) continue; // Avoid division by zero

            float idealAngle = atan2f(targetToPocketY, targetToPocketX);
            // Place cue ball slightly behind target ball along this line
            float placeDist = BALL_RADIUS * 3.0f; // Place a bit behind
            D2D1_POINT_2F potentialPlacePos = D2D1::Point2F( // Use factory function
                targetBall.x - cosf(idealAngle) * placeDist,
                targetBall.y - sinf(idealAngle) * placeDist
            );

            // Check if this placement is valid (on table, behind headstring if break, not overlapping)
            /*bool behindHeadstringRule = (currentGameState == PRE_BREAK_PLACEMENT);*/
            // For ball-in-hand (NOT break), behindHeadstringRule is false.
            // The currentGameState should be BALL_IN_HAND_P2 when this is called for a foul.
            bool behindHeadstringRule = false; // Player can place anywhere after a foul
            if (IsValidCueBallPosition(potentialPlacePos.x, potentialPlacePos.y, behindHeadstringRule)) {
                // Is path from potentialPlacePos to targetBall clear?
                // Use D2D1::Point2F() factory function here
                if (IsPathClear(potentialPlacePos, D2D1::Point2F(targetBall.x, targetBall.y), 0, targetBall.id)) {
                    // Is path from targetBall to pocket clear?
                    // Use D2D1::Point2F() factory function here
                    if (IsPathClear(D2D1::Point2F(targetBall.x, targetBall.y), pocketPositions[p], targetBall.id, -1)) {
                        // This seems like a good potential placement. Score it?
                        // Easy AI: Just take the first valid one found.
                        /*bestPlacePos = potentialPlacePos;
                        goto placement_found;*/ // Use goto for simplicity in non-OOP structure
                        // This is a possible shot. Score this placement.
// A simple score: distance to target ball (shorter is better for placement).
// More advanced: consider angle to pocket, difficulty of the shot from this placement.
                        AIShotInfo tempShotInfo;
                        tempShotInfo.possible = true;
                        tempShotInfo.targetBall = &targetBall;
                        tempShotInfo.pocketIndex = p;
                        tempShotInfo.ghostBallPos = CalculateGhostBallPos(&targetBall, p); // Not strictly needed for placement score but good for consistency
                        tempShotInfo.angle = idealAngle; // The angle from the placed ball to target
                        // Use EvaluateShot's scoring mechanism if possible, or a simpler one here.
                        float currentScore = 1000.0f / (1.0f + GetDistance(potentialPlacePos.x, potentialPlacePos.y, targetBall.x, targetBall.y)); // Inverse distance

                        if (currentScore > bestPlacementScore) {
                            bestPlacementScore = currentScore;
                            bestPlacePos = potentialPlacePos;
                        }
                    }
                }
            }
        }
    }

placement_found:
    // Place the cue ball at the best found position (or default if no good spot found)
    cueBall->x = bestPlacePos.x;
    cueBall->y = bestPlacePos.y;
    cueBall->vx = 0;
    cueBall->vy = 0;
}


// AI finds the best shot available on the table
AIShotInfo AIFindBestShot() {
    AIShotInfo bestShotOverall = { false };
    Ball* cueBall = GetCueBall();
    if (!cueBall) return bestShotOverall;
    // Ensure cue ball position is up-to-date if AI just placed it
    // (AIPlaceCueBall should have already set cueBall->x, cueBall->y)

    // Determine target ball type for AI (Player 2)
    BallType targetType = player2Info.assignedType;
    bool canTargetAny = false; // Can AI hit any ball (e.g., after break, before assignment)?
    if (targetType == BallType::NONE) {
        // If colors not assigned, AI aims to pocket *something* (usually lowest numbered ball legally)
        // Or, more simply, treat any ball as a potential target to make *a* pocket
        canTargetAny = true; // Simplification: allow targeting any non-8 ball.
        // A better rule is hit lowest numbered ball first on break follow-up.
    }

    // Check if AI needs to shoot the 8-ball
    bool target8Ball = (!canTargetAny && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);


    // Iterate through all potential target balls
    for (auto& potentialTarget : balls) {
        if (potentialTarget.isPocketed || potentialTarget.id == 0) continue; // Skip pocketed and cue ball

        // Check if this ball is a valid target
        bool isValidTarget = false;
        if (target8Ball) {
            isValidTarget = (potentialTarget.id == 8);
        }
        else if (canTargetAny) {
            isValidTarget = (potentialTarget.id != 8); // Can hit any non-8 ball
        }
        else { // Colors assigned, not yet shooting 8-ball
            isValidTarget = (potentialTarget.type == targetType);
        }

        if (!isValidTarget) continue; // Skip if not a valid target for this turn

        // Now, check all pockets for this target ball
        for (int p = 0; p < 6; ++p) {
            AIShotInfo currentShot = EvaluateShot(&potentialTarget, p);
            currentShot.involves8Ball = (potentialTarget.id == 8);

            if (currentShot.possible) {
                // Compare scores to find the best shot
                if (!bestShotOverall.possible || currentShot.score > bestShotOverall.score) {
                    bestShotOverall = currentShot;
                }
            }
        }
    } // End loop through potential target balls

    // If targeting 8-ball and no shot found, or targeting own balls and no shot found,
    // need a safety strategy. Current simple AI just takes best found or taps cue ball.

    return bestShotOverall;
}


// Evaluate a potential shot at a specific target ball towards a specific pocket
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
    AIShotInfo shotInfo;
    shotInfo.possible = false; // Assume not possible initially
    shotInfo.targetBall = targetBall;
    shotInfo.pocketIndex = pocketIndex;

    Ball* cueBall = GetCueBall();
    if (!cueBall || !targetBall) return shotInfo;

    // --- Define local state variables needed for legality checks ---
    BallType aiAssignedType = player2Info.assignedType;
    bool canTargetAny = (aiAssignedType == BallType::NONE); // Can AI hit any ball?
    bool mustTarget8Ball = (!canTargetAny && aiAssignedType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    // ---

    // 1. Calculate Ghost Ball position
    shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

    // 2. Calculate Angle from Cue Ball to Ghost Ball
    float dx = shotInfo.ghostBallPos.x - cueBall->x;
    float dy = shotInfo.ghostBallPos.y - cueBall->y;
    if (fabs(dx) < 0.01f && fabs(dy) < 0.01f) return shotInfo; // Avoid aiming at same spot
    shotInfo.angle = atan2f(dy, dx);

    // Basic angle validity check (optional)
    if (!IsValidAIAimAngle(shotInfo.angle)) {
        // Maybe log this or handle edge cases
    }

    // 3. Check Path: Cue Ball -> Ghost Ball Position
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
        return shotInfo; // Path blocked
    }

    // 4. Check Path: Target Ball -> Pocket
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(targetBall->x, targetBall->y), pocketPositions[pocketIndex], targetBall->id, -1)) {
        return shotInfo; // Path blocked
    }

    // 5. Check First Ball Hit Legality
    float firstHitDistSq = -1.0f;
    // Use D2D1::Point2F() factory function here
    Ball* firstHit = FindFirstHitBall(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.angle, firstHitDistSq);

    if (!firstHit) {
        return shotInfo; // AI aims but doesn't hit anything? Impossible shot.
    }

    // Check if the first ball hit is the intended target ball
    if (firstHit->id != targetBall->id) {
        // Allow hitting slightly off target if it's very close to ghost ball pos
        float ghostDistSq = GetDistanceSq(shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y, firstHit->x, firstHit->y);
        // Allow a tolerance roughly half the ball radius squared
        if (ghostDistSq > (BALL_RADIUS * 0.7f) * (BALL_RADIUS * 0.7f)) {
            // First hit is significantly different from the target point.
            // This shot path leads to hitting the wrong ball first.
            return shotInfo; // Foul or unintended shot
        }
        // If first hit is not target, but very close, allow it for now (might still be foul based on type).
    }

    // Check legality of the *first ball actually hit* based on game rules
    if (!canTargetAny) { // Colors are assigned (or should be)
        if (mustTarget8Ball) { // Must hit 8-ball first
            if (firstHit->id != 8) {
                // return shotInfo; // FOUL - Hitting wrong ball when aiming for 8-ball
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
        }
        else { // Must hit own ball type first
            if (firstHit->type != aiAssignedType && firstHit->id != 8) { // Allow hitting 8-ball if own type blocked? No, standard rules usually require hitting own first.
                // return shotInfo; // FOUL - Hitting opponent ball or 8-ball when shouldn't
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
            else if (firstHit->id == 8) {
                // return shotInfo; // FOUL - Hitting 8-ball when shouldn't
                // Keep shot possible for now
            }
        }
    }
    // (If canTargetAny is true, hitting any ball except 8 first is legal - assuming not scratching)


    // 6. Calculate Score & Power (Difficulty affects this)
    shotInfo.possible = true; // If we got here, the shot is geometrically possible and likely legal enough for AI to consider

    float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
    float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);

    // Simple Score: Shorter shots are better, straighter shots are slightly better.
    float distanceScore = 1000.0f / (1.0f + cueToGhostDist + targetToPocketDist);

    // Angle Score: Calculate cut angle
    // Vector Cue -> Ghost
    float v1x = shotInfo.ghostBallPos.x - cueBall->x;
    float v1y = shotInfo.ghostBallPos.y - cueBall->y;
    // Vector Target -> Pocket
    float v2x = pocketPositions[pocketIndex].x - targetBall->x;
    float v2y = pocketPositions[pocketIndex].y - targetBall->y;
    // Normalize vectors
    float mag1 = sqrtf(v1x * v1x + v1y * v1y);
    float mag2 = sqrtf(v2x * v2x + v2y * v2y);
    float angleScoreFactor = 0.5f; // Default if vectors are zero len
    if (mag1 > 0.1f && mag2 > 0.1f) {
        v1x /= mag1; v1y /= mag1;
        v2x /= mag2; v2y /= mag2;
        // Dot product gives cosine of angle between cue ball path and target ball path
        float dotProduct = v1x * v2x + v1y * v2y;
        // Straighter shot (dot product closer to 1) gets higher score
        angleScoreFactor = (1.0f + dotProduct) / 2.0f; // Map [-1, 1] to [0, 1]
    }
    angleScoreFactor = std::max(0.1f, angleScoreFactor); // Ensure some minimum score factor

    shotInfo.score = distanceScore * angleScoreFactor;

    // Bonus for pocketing 8-ball legally
    if (mustTarget8Ball && targetBall->id == 8) {
        shotInfo.score *= 10.0; // Strongly prefer the winning shot
    }

    // Penalty for difficult cuts? Already partially handled by angleScoreFactor.

    // 7. Calculate Power
    shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

    // 8. Add Inaccuracy based on Difficulty (same as before)
    float angleError = 0.0f;
    float powerErrorFactor = 1.0f;

    switch (aiDifficulty) {
    case EASY:
        angleError = (float)(rand() % 100 - 50) / 1000.0f; // +/- ~3 deg
        powerErrorFactor = 0.8f + (float)(rand() % 40) / 100.0f; // 80-120%
        shotInfo.power *= 0.8f;
        break;
    case MEDIUM:
        angleError = (float)(rand() % 60 - 30) / 1000.0f; // +/- ~1.7 deg
        powerErrorFactor = 0.9f + (float)(rand() % 20) / 100.0f; // 90-110%
        break;
    case HARD:
        angleError = (float)(rand() % 10 - 5) / 1000.0f; // +/- ~0.3 deg
        powerErrorFactor = 0.98f + (float)(rand() % 4) / 100.0f; // 98-102%
        break;
    }
    shotInfo.angle += angleError;
    shotInfo.power *= powerErrorFactor;
    shotInfo.power = std::max(1.0f, std::min(shotInfo.power, MAX_SHOT_POWER)); // Clamp power

    return shotInfo;
}


// Calculates required power (simplified)
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist) {
    // Basic model: Power needed increases with total distance the balls need to travel.
    // Need enough power for cue ball to reach target AND target to reach pocket.
    float totalDist = cueToGhostDist + targetToPocketDist;

    // Map distance to power (needs tuning)
    // Let's say max power is needed for longest possible shot (e.g., corner to corner ~ 1000 units)
    float powerRatio = std::min(1.0f, totalDist / 800.0f); // Normalize based on estimated max distance

    float basePower = MAX_SHOT_POWER * 0.2f; // Minimum power to move balls reliably
    float variablePower = (MAX_SHOT_POWER * 0.8f) * powerRatio; // Scale remaining power range

    // Harder AI could adjust based on desired cue ball travel (more power for draw/follow)
    return std::min(MAX_SHOT_POWER, basePower + variablePower);
}

// Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex) {
    float targetToPocketX = pocketPositions[pocketIndex].x - targetBall->x;
    float targetToPocketY = pocketPositions[pocketIndex].y - targetBall->y;
    float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);

    if (dist < 1.0f) { // Target is basically in the pocket
        // Aim slightly off-center to avoid weird physics? Or directly at center?
        // For simplicity, return a point slightly behind center along the reverse line.
        return D2D1::Point2F(targetBall->x - targetToPocketX * 0.1f, targetBall->y - targetToPocketY * 0.1f);
    }

    // Normalize direction vector from target to pocket
    float nx = targetToPocketX / dist;
    float ny = targetToPocketY / dist;

    // Ghost ball position is diameter distance *behind* the target ball along this line
    float ghostX = targetBall->x - nx * (BALL_RADIUS * 2.0f);
    float ghostY = targetBall->y - ny * (BALL_RADIUS * 2.0f);

    return D2D1::Point2F(ghostX, ghostY);
}

// Checks if line segment is clear of obstructing balls
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2) {
    float dx = end.x - start.x;
    float dy = end.y - start.y;
    float segmentLenSq = dx * dx + dy * dy;

    if (segmentLenSq < 0.01f) return true; // Start and end are same point

    for (const auto& ball : balls) {
        if (ball.isPocketed) continue;
        if (ball.id == ignoredBallId1) continue;
        if (ball.id == ignoredBallId2) continue;

        // Check distance from ball center to the line segment
        float ballToStartX = ball.x - start.x;
        float ballToStartY = ball.y - start.y;

        // Project ball center onto the line defined by the segment
        float dot = (ballToStartX * dx + ballToStartY * dy) / segmentLenSq;

        D2D1_POINT_2F closestPointOnLine;
        if (dot < 0) { // Closest point is start point
            closestPointOnLine = start;
        }
        else if (dot > 1) { // Closest point is end point
            closestPointOnLine = end;
        }
        else { // Closest point is along the segment
            closestPointOnLine = D2D1::Point2F(start.x + dot * dx, start.y + dot * dy);
        }

        // Check if the closest point is within collision distance (ball radius + path radius)
        if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * BALL_RADIUS)) {
            // Consider slightly wider path check? Maybe BALL_RADIUS * 1.1f?
            // if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * 1.1f)*(BALL_RADIUS*1.1f)) {
            return false; // Path is blocked
        }
    }
    return true; // No obstructions found
}

// Finds the first ball hit along a path (simplified)
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq) {
    Ball* hitBall = nullptr;
    hitDistSq = -1.0f; // Initialize hit distance squared
    float minCollisionDistSq = -1.0f;

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    for (auto& ball : balls) {
        if (ball.isPocketed || ball.id == 0) continue; // Skip cue ball and pocketed

        float dx = ball.x - start.x;
        float dy = ball.y - start.y;

        // Project vector from start->ball onto the aim direction vector
        float dot = dx * cosA + dy * sinA;

        if (dot > 0) { // Ball is generally in front
            // Find closest point on aim line to the ball's center
            float closestPointX = start.x + dot * cosA;
            float closestPointY = start.y + dot * sinA;
            float distSq = GetDistanceSq(ball.x, ball.y, closestPointX, closestPointY);

            // Check if the aim line passes within the ball's radius
            if (distSq < (BALL_RADIUS * BALL_RADIUS)) {
                // Calculate distance from start to the collision point on the ball's circumference
                float backDist = sqrtf(std::max(0.f, BALL_RADIUS * BALL_RADIUS - distSq));
                float collisionDist = dot - backDist; // Distance along aim line to collision

                if (collisionDist > 0) { // Ensure collision is in front
                    float collisionDistSq = collisionDist * collisionDist;
                    if (hitBall == nullptr || collisionDistSq < minCollisionDistSq) {
                        minCollisionDistSq = collisionDistSq;
                        hitBall = &ball; // Found a closer hit ball
                    }
                }
            }
        }
    }
    hitDistSq = minCollisionDistSq; // Return distance squared to the first hit
    return hitBall;
}

// Basic check for reasonable AI aim angles (optional)
bool IsValidAIAimAngle(float angle) {
    // Placeholder - could check for NaN or infinity if calculations go wrong
    return isfinite(angle);
}

//midi func = start
void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
    while (isMusicPlaying) {
        MCI_OPEN_PARMS mciOpen = { 0 };
        mciOpen.lpstrDeviceType = TEXT(""sequencer"");
        mciOpen.lpstrElementName = midiPath;

        if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
            midiDeviceID = mciOpen.wDeviceID;

            MCI_PLAY_PARMS mciPlay = { 0 };
            mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

            // Wait for playback to complete
            MCI_STATUS_PARMS mciStatus = { 0 };
            mciStatus.dwItem = MCI_STATUS_MODE;

            do {
                mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                Sleep(100); // adjust as needed
            } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

void StartMidi(HWND hwnd, const TCHAR* midiPath) {
    if (isMusicPlaying) {
        StopMidi();
    }
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}

void StopMidi() {
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) musicThread.join();
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

/*void PlayGameMusic(HWND hwnd) {
    // Stop any existing playback
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) {
            musicThread.join();
        }
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }

    // Get the path of the executable
    TCHAR exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

    // Extract the directory path
    TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
    if (lastBackslash != NULL) {
        *(lastBackslash + 1) = '\0';
    }

    // Construct the full path to the MIDI file
    static TCHAR midiPath[MAX_PATH];
    _tcscpy_s(midiPath, MAX_PATH, exePath);
    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

    // Start the background playback
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}*/
//midi func = end

// --- Drawing Functions ---

void OnPaint() {
    HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

    if (SUCCEEDED(hr)) {
        pRenderTarget->BeginDraw();
        DrawScene(pRenderTarget); // Pass render target
        hr = pRenderTarget->EndDraw();

        if (hr == D2DERR_RECREATE_TARGET) {
            DiscardDeviceResources();
            // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
            // But the timer loop will trigger redraw anyway.
        }
    }
    // If CreateDeviceResources failed, EndDraw might not be called.
    // Consider handling this more robustly if needed.
}

void DrawScene(ID2D1RenderTarget* pRT) {
    if (!pRT) return;

    //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
    // Set background color to #ffffcd (RGB: 255, 255, 205)
    pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
    //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

    DrawTable(pRT, pFactory);
    DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
    DrawBalls(pRT);
    DrawAimingAids(pRT); // Includes cue stick if aiming
    DrawUI(pRT);
    DrawPowerMeter(pRT);
    DrawSpinIndicator(pRT);
    DrawPocketedBallsIndicator(pRT);
    DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

     // Draw Game Over Message
    if (currentGameState == GAME_OVER && pTextFormat) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
        if (pBrush) {
            D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
            pRT->DrawText(
                gameOverMessage.c_str(),
                (UINT32)gameOverMessage.length(),
                pTextFormat, // Use large format maybe?
                &layoutRect,
                pBrush
            );
            SafeRelease(&pBrush);
        }
    }

}

void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
    ID2D1SolidColorBrush* pBrush = nullptr;

    // === Draw Full Orange Frame (Table Border) ===
    ID2D1SolidColorBrush* pFrameBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    if (pFrameBrush) {
        D2D1_RECT_F outerRect = D2D1::RectF(
            TABLE_LEFT - CUSHION_THICKNESS,
            TABLE_TOP - CUSHION_THICKNESS,
            TABLE_RIGHT + CUSHION_THICKNESS,
            TABLE_BOTTOM + CUSHION_THICKNESS
        );
        pRT->FillRectangle(&outerRect, pFrameBrush);
        SafeRelease(&pFrameBrush);
    }

    // Draw Table Bed (Green Felt)
    pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
    if (!pBrush) return;
    D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
    pRT->FillRectangle(&tableRect, pBrush);
    SafeRelease(&pBrush);

    // Draw Cushions (Red Border)
    pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
    if (!pBrush) return;
    // Top Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    // Bottom Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    // Left Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    // Right Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    SafeRelease(&pBrush);


    // Draw Pockets (Black Circles)
    pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
    if (!pBrush) return;
    for (int i = 0; i < 6; ++i) {
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
        pRT->FillEllipse(&ellipse, pBrush);
    }
    SafeRelease(&pBrush);

    // Draw Headstring Line (White)
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    if (!pBrush) return;
    pRT->DrawLine(
        D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
        D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
        pBrush,
        1.0f // Line thickness
    );
    SafeRelease(&pBrush);

    // Draw Semicircle facing West (flat side East)
    // Draw Semicircle facing East (curved side on the East, flat side on the West)
    ID2D1PathGeometry* pGeometry = nullptr;
    HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
    if (SUCCEEDED(hr) && pGeometry)
    {
        ID2D1GeometrySink* pSink = nullptr;
        hr = pGeometry->Open(&pSink);
        if (SUCCEEDED(hr) && pSink)
        {
            float radius = 60.0f; // Radius for the semicircle
            D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

            // For a semicircle facing East (curved side on the East), use the top and bottom points.
            D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

            pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

            D2D1_ARC_SEGMENT arc = {};
            arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
            arc.size = D2D1::SizeF(radius, radius);
            arc.rotationAngle = 0.0f;
            // Use the correct identifier with the extra underscore:
            arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
            arc.arcSize = D2D1_ARC_SIZE_SMALL;

            pSink->AddArc(&arc);
            pSink->EndFigure(D2D1_FIGURE_END_OPEN);
            pSink->Close();
            SafeRelease(&pSink);

            ID2D1SolidColorBrush* pArcBrush = nullptr;
            //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
            pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
            if (pArcBrush)
            {
                pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                SafeRelease(&pArcBrush);
            }
        }
        SafeRelease(&pGeometry);
    }




}


void DrawBalls(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

    pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

    if (!pBrush || !pStripeBrush) {
        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
        return;
    }


    for (size_t i = 0; i < balls.size(); ++i) {
        const Ball& b = balls[i];
        if (!b.isPocketed) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            // Set main ball color
            pBrush->SetColor(b.color);
            pRT->FillEllipse(&ellipse, pBrush);

            // Draw Stripe if applicable
            if (b.type == BallType::STRIPE) {
                // Draw a white band across the middle (simplified stripe)
                D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                // Need to clip this rectangle to the ellipse bounds - complex!
                // Alternative: Draw two colored arcs leaving a white band.
                // Simplest: Draw a white circle inside, slightly smaller.
                D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                pBrush->SetColor(b.color); // Set back to stripe color
                pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                // Let's try drawing a thick white line across
                // This doesn't look great. Just drawing solid red for stripes for now.
            }

            // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
            // if (b.id != 0 && pTextFormat) {
            //     std::wstring numStr = std::to_wstring(b.id);
            //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
            //     ID2D1SolidColorBrush* pNumBrush = nullptr;
            //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
            //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
            //     // Create a smaller text format...
            //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
            //     SafeRelease(&pNumBrush);
            // }
        }
    }

    SafeRelease(&pBrush);
    SafeRelease(&pStripeBrush);
}


void DrawAimingAids(ID2D1RenderTarget* pRT) {
    // Condition check at start (Unchanged)
    //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
        //currentGameState != BREAKING && currentGameState != AIMING)
    //{
        //return;
    //}
        // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
    // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
    bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
        (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == BREAKING || currentGameState == AIMING);
    // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
    // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
        // NEW Condition: AI is displaying its aim
    bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
        return;
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    ID2D1StrokeStyle* pDashedStyle = nullptr;
    ID2D1SolidColorBrush* pCueBrush = nullptr;
    ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

    // Ensure render target is valid
    if (!pRT) return;

    // Create Brushes and Styles (check for failures)
    HRESULT hr;
    hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
    if FAILED(hr) { SafeRelease(&pBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
    // Create reflection brush (e.g., lighter shade or different color)
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
    // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
    D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
    ID2D1SolidColorBrush* pCyanBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
    if (FAILED(hr)) {
        SafeRelease(&pCyanBrush);
        // handle error if needed
    }
    // Create a Purple brush for primary and secondary lines
    D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
    ID2D1SolidColorBrush* pPurpleBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
    if (FAILED(hr)) {
        SafeRelease(&pPurpleBrush);
        // handle error if needed
    }

    if (pFactory) {
        D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
        strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
        hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        if FAILED(hr) { pDashedStyle = nullptr; }
    }


    // --- Cue Stick Drawing (Unchanged from previous fix) ---
    const float baseStickLength = 150.0f;
    const float baseStickThickness = 4.0f;
    float stickLength = baseStickLength * 1.4f;
    float stickThickness = baseStickThickness * 1.5f;
    float stickAngle = cueAngle + PI;
    float powerOffset = 0.0f;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
    if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
        powerOffset = shotPower * 5.0f;
    }
    D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
    D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
    pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


    // --- Projection Line Calculation ---
    float cosA = cosf(cueAngle);
    float sinA = sinf(cueAngle);
    float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
    D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
    D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

    // Find the first ball hit by the aiming ray
    Ball* hitBall = nullptr;
    float firstHitDistSq = -1.0f;
    D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
    D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

    hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
    if (hitBall) {
        // Calculate the point on the target ball's circumference
        float collisionDist = sqrtf(firstHitDistSq);
        ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
        // Calculate ghost ball position for this specific hit (used for projection consistency)
        ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
    }

    // Find the first rail hit by the aiming ray
    D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
    float minRailDistSq = rayLength * rayLength;
    int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

    // Define table edge segments for intersection checks
    D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
    D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
    D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
    D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

    D2D1_POINT_2F currentIntersection;

    // Check Left Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
    }
    // Check Right Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
    }
    // Check Top Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
    }
    // Check Bottom Rail
    if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
    }


    // --- Determine final aim line end point ---
    D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
    bool aimingAtRail = true;

    if (hitBall && firstHitDistSq < minRailDistSq) {
        // Ball collision is closer than rail collision
        finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
        aimingAtRail = false;
    }

    // --- Draw Primary Aiming Line ---
    pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

    // --- Draw Target Circle/Indicator ---
    D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
    pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

    // --- Draw Projection/Reflection Lines ---
    if (!aimingAtRail && hitBall) {
        // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
        D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
        pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // Calculate target ball projection based on impact line (cue collision point -> target center)
        float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
        // Clamp angle calculation if distance is tiny
        if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
            targetProjectionAngle = cueAngle; // Fallback if overlapping
        }

        D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
        D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
            hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
            hitBall->y + sinf(targetProjectionAngle) * 50.0f
        );
        // Draw solid line for target projection
        //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

    //new code start

                // Dual trajectory with edge-aware contact simulation
        D2D1_POINT_2F dir = {
            targetProjectionEnd.x - targetStartPoint.x,
            targetProjectionEnd.y - targetStartPoint.y
        };
        float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
        dir.x /= dirLen;
        dir.y /= dirLen;

        D2D1_POINT_2F perp = { -dir.y, dir.x };

        // Approximate cue ball center by reversing from tip
        D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
            targetStartPoint.x - dir.x * BALL_RADIUS,
            targetStartPoint.y - dir.y * BALL_RADIUS
        };

        // REAL contact-ball center - use your physics object's center:
        // (replace 'objectBallPos' with whatever you actually call it)
        // (targetStartPoint is already hitBall->x, hitBall->y)
        D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
        //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

       // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
       // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
       // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
       // and 'perp' is perpendicular to 'dir'.
       // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
        /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
            (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
            /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                (targetStartPoint.y - cueBallCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);*/

            // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
        D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

        // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
        float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
            (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
        float absOffset = fabsf(offset);
        float side = (offset >= 0 ? 1.0f : -1.0f);


        // Actual contact point on target ball edge
        D2D1_POINT_2F contactPoint = {
        contactBallCenter.x + perp.x * BALL_RADIUS * side,
        contactBallCenter.y + perp.y * BALL_RADIUS * side
        };

        // Tangent (cut shot) path from contact point
            // Tangent (cut shot) path: from contact point to contact ball center
        D2D1_POINT_2F objectBallDir = {
            contactBallCenter.x - contactPoint.x,
            contactBallCenter.y - contactPoint.y
        };
        float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
        if (oLen != 0.0f) {
            objectBallDir.x /= oLen;
            objectBallDir.y /= oLen;
        }

        const float PRIMARY_LEN = 150.0f; //default=150.0f
        const float SECONDARY_LEN = 150.0f; //default=150.0f
        const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

        D2D1_POINT_2F primaryEnd = {
            targetStartPoint.x + dir.x * PRIMARY_LEN,
            targetStartPoint.y + dir.y * PRIMARY_LEN
        };

        // Secondary line starts from the contact ball's center
        D2D1_POINT_2F secondaryStart = contactBallCenter;
        D2D1_POINT_2F secondaryEnd = {
            secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
            secondaryStart.y + objectBallDir.y * SECONDARY_LEN
        };

        if (absOffset < STRAIGHT_EPSILON)  // straight shot?
        {
            // Straight: secondary behind primary
                    // secondary behind primary {pDashedStyle param at end}
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        else
        {
            // Cut shot: both visible
                    // both visible for cut shot
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        // End improved trajectory logic

    //new code end

        // -- Cue Ball Path after collision (Optional, requires physics) --
        // Very simplified: Assume cue deflects, angle depends on cut angle.
        // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
        // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
        // D2D1_POINT_2F cueProjectionEnd = ...
        // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Accuracy Comment ---
        // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
        // or shots with spin, is limited by the simplified physics model. Real pool physics involves
        // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
        // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

    }
    else if (aimingAtRail && hitRailIndex != -1) {
        // Aiming at a rail: Draw reflection line
        float reflectAngle = cueAngle;
        // Reflect angle based on which rail was hit
        if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
            reflectAngle = PI - cueAngle; // Reflect horizontal component
        }
        else { // Top or Bottom rail
            reflectAngle = -cueAngle; // Reflect vertical component
        }
        // Normalize angle if needed (atan2 usually handles this)
        while (reflectAngle > PI) reflectAngle -= 2 * PI;
        while (reflectAngle <= -PI) reflectAngle += 2 * PI;


        float reflectionLength = 60.0f; // Length of the reflection line
        D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
            finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
            finalLineEnd.y + sinf(reflectAngle) * reflectionLength
        );

        // Draw the reflection line (e.g., using a different color/style)
        pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
    }

    // Release resources
    SafeRelease(&pBrush);
    SafeRelease(&pGhostBrush);
    SafeRelease(&pCueBrush);
    SafeRelease(&pReflectBrush); // Release new brush
    SafeRelease(&pCyanBrush);
    SafeRelease(&pPurpleBrush);
    SafeRelease(&pDashedStyle);
}


void DrawUI(ID2D1RenderTarget* pRT) {
    if (!pTextFormat || !pLargeTextFormat) return;

    ID2D1SolidColorBrush* pBrush = nullptr;
    pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
    if (!pBrush) return;

    // --- Player Info Area (Top Left/Right) --- (Unchanged)
    float uiTop = TABLE_TOP - 80;
    float uiHeight = 60;
    float p1Left = TABLE_LEFT;
    float p1Width = 150;
    float p2Left = TABLE_RIGHT - p1Width;
    D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
    D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

    // Player 1 Info Text (Unchanged)
    std::wostringstream oss1;
    oss1 << player1Info.name.c_str() << L""\n"";
    if (player1Info.assignedType != BallType::NONE) {
        oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss1 << L""(Undecided)"";
    }
    pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
    // Draw Player 1 Side Ball
    if (player1Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player1Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // Player 2 Info Text (Unchanged)
    std::wostringstream oss2;
    oss2 << player2Info.name.c_str() << L""\n"";
    if (player2Info.assignedType != BallType::NONE) {
        oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss2 << L""(Undecided)"";
    }
    pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
    // Draw Player 2 Side Ball
    if (player2Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player2Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
        arrowBackX = playerBox.left - 25.0f;
        arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

        float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
        float notchWidth = 10.0f;

        float cx = arrowBackX;
        float cy = arrowCenterY;

        // Define triangle + rectangle tail shape
        D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
        D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
        D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

        // Rectangle coordinates for the tail portion:
        D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
        D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
        D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
        D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseTop);
                pSink->AddLine(r2); // transition from triangle into rectangle
                pSink->AddLine(r1);
                pSink->AddLine(r4);
                pSink->AddLine(r3);
                pSink->AddLine(baseBot);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }


        SafeRelease(&pArrowBrush);
    }

    //original
/*
    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        if (currentPlayer == 1) {
arrowBackX = p1Rect.left - 25.0f; // Position left of the box
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
            // Define points for right-pointing arrow
            //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
            //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
            //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
            // Enhanced arrow with base rectangle intersection
    float notchDepth = 6.0f; // Depth of square base ""stem""
    float notchWidth = 4.0f; // Thickness of square part

    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
    D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
    D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
        }


        //==================else player 2
        else { // Player 2
         // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
         // Let's keep it consistent: Arrow left of the active player's box, pointing right.
// Let's keep it consistent: Arrow left of the active player's box, pointing right.
arrowBackX = p2Rect.left - 25.0f; // Position left of the box
arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
// Define points for right-pointing arrow
D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

ID2D1PathGeometry* pPath = nullptr;
if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
    ID2D1GeometrySink* pSink = nullptr;
    if (SUCCEEDED(pPath->Open(&pSink))) {
        pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
        pSink->AddLine(pt2);
        pSink->AddLine(pt3);
        pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
        pSink->Close();
        SafeRelease(&pSink);
        pRT->FillGeometry(pPath, pArrowBrush);
    }
    SafeRelease(&pPath);
}
        }
        */

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
    if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
        ID2D1SolidColorBrush* pFoulBrush = nullptr;
        pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
        if (pFoulBrush && pLargeTextFormat) {
            // Calculate Rect for bottom-middle area
            float foulWidth = 200.0f; // Adjust width as needed
            float foulHeight = 60.0f;
            float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
            // Position below the pocketed balls bar
            float foulTop = pocketedBallsBarRect.bottom + 10.0f;
            D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

            // --- Set text alignment to center for foul text ---
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

            // --- Restore default alignment for large text if needed elsewhere ---
            // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            SafeRelease(&pFoulBrush);
        }
    }

    // --- Draw ""Choose Pocket"" Message ---
    if (!pocketCallMessage.empty() && (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2)) {
        ID2D1SolidColorBrush* pMsgBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pMsgBrush);
        if (pMsgBrush && pTextFormat) {
            float msgWidth = 450.0f;
            float msgHeight = 30.0f;
            float msgLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (msgWidth / 2.0f);
            float msgTop = pocketedBallsBarRect.bottom + 10.0f;
            if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) msgTop += 30.0f;

            D2D1_RECT_F msgRect = D2D1::RectF(msgLeft, msgTop, msgLeft + msgWidth, msgTop + msgHeight);

            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(pocketCallMessage.c_str(), (UINT32)pocketCallMessage.length(), pTextFormat, &msgRect, pMsgBrush);
            SafeRelease(&pMsgBrush);
        }
    }


    // Show AI Thinking State (Unchanged from previous step)
    if (currentGameState == AI_THINKING && pTextFormat) {
        ID2D1SolidColorBrush* pThinkingBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
        if (pThinkingBrush) {
            D2D1_RECT_F thinkingRect = p2Rect;
            thinkingRect.top += 20; // Offset within P2 box
            // Ensure default text alignment for this
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
            SafeRelease(&pThinkingBrush);
        }
    }

    SafeRelease(&pBrush);

    // --- Draw CHEAT MODE label if active ---
    if (cheatModeEnabled) {
        ID2D1SolidColorBrush* pCheatBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
        if (pCheatBrush && pTextFormat) {
            D2D1_RECT_F cheatTextRect = D2D1::RectF(
                TABLE_LEFT + 10.0f,
                TABLE_TOP + 10.0f,
                TABLE_LEFT + 200.0f,
                TABLE_TOP + 40.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
        }
        SafeRelease(&pCheatBrush);
    }
}

void DrawPowerMeter(ID2D1RenderTarget* pRT) {
    // Draw Border
    ID2D1SolidColorBrush* pBorderBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
    if (!pBorderBrush) return;
    pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
    SafeRelease(&pBorderBrush);

    // Create Gradient Fill
    ID2D1GradientStopCollection* pGradientStops = nullptr;
    ID2D1LinearGradientBrush* pGradientBrush = nullptr;
    D2D1_GRADIENT_STOP gradientStops[4];
    gradientStops[0].position = 0.0f;
    gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
    gradientStops[1].position = 0.45f;
    gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
    gradientStops[2].position = 0.7f;
    gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
    gradientStops[3].position = 1.0f;
    gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

    pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
    if (pGradientStops) {
        D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
        props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
        props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
        pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
        SafeRelease(&pGradientStops);
    }

    // Calculate Fill Height
    float fillRatio = 0;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Determine if power meter should reflect shot power (human aiming or AI preparing)
    bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
    // NEW Condition: AI is displaying its aim, so show its chosen power
    bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
        fillRatio = shotPower / MAX_SHOT_POWER;
    }
    float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
    D2D1_RECT_F fillRect = D2D1::RectF(
        powerMeterRect.left,
        powerMeterRect.bottom - fillHeight,
        powerMeterRect.right,
        powerMeterRect.bottom
    );

    if (pGradientBrush) {
        pRT->FillRectangle(&fillRect, pGradientBrush);
        SafeRelease(&pGradientBrush);
    }

    // Draw scale notches
    ID2D1SolidColorBrush* pNotchBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
    if (pNotchBrush) {
        for (int i = 0; i <= 8; ++i) {
            float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
            pRT->DrawLine(
                D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                pNotchBrush,
                1.5f
            );
        }
        SafeRelease(&pNotchBrush);
    }

    // Draw ""Power"" Label Below Meter
    if (pTextFormat) {
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
        if (pTextBrush) {
            D2D1_RECT_F textRect = D2D1::RectF(
                powerMeterRect.left - 20.0f,
                powerMeterRect.bottom + 8.0f,
                powerMeterRect.right + 20.0f,
                powerMeterRect.bottom + 38.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
            SafeRelease(&pTextBrush);
        }
    }

    // Draw Glow Effect if fully charged or fading out
    static float glowPulse = 0.0f;
    static bool glowIncreasing = true;
    static float glowFadeOut = 0.0f; // NEW: tracks fading out

    if (shotPower >= MAX_SHOT_POWER * 0.99f) {
        // While fully charged, keep pulsing normally
        if (glowIncreasing) {
            glowPulse += 0.02f;
            if (glowPulse >= 1.0f) glowIncreasing = false;
        }
        else {
            glowPulse -= 0.02f;
            if (glowPulse <= 0.0f) glowIncreasing = true;
        }
        glowFadeOut = 1.0f; // Reset fade out to full
    }
    else if (glowFadeOut > 0.0f) {
        // If shot fired, gradually fade out
        glowFadeOut -= 0.02f;
        if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
    }

    if (glowFadeOut > 0.0f) {
        ID2D1SolidColorBrush* pGlowBrush = nullptr;
        float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
        pRT->CreateSolidColorBrush(
            D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
            &pGlowBrush
        );
        if (pGlowBrush) {
            float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
            float glowCenterY = powerMeterRect.top;
            D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                12.0f + 3.0f * glowPulse,
                6.0f + 2.0f * glowPulse
            );
            pRT->FillEllipse(&glowEllipse, pGlowBrush);
            SafeRelease(&pGlowBrush);
        }
    }
}

void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pWhiteBrush = nullptr;
    ID2D1SolidColorBrush* pRedBrush = nullptr;

    pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
    pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

    if (!pWhiteBrush || !pRedBrush) {
        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
        return;
    }

    // Draw White Ball Background
    D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
    pRT->FillEllipse(&bgEllipse, pWhiteBrush);
    pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


    // Draw Red Dot for Spin Position
    float dotRadius = 4.0f;
    float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
    float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
    D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
    pRT->FillEllipse(&dotEllipse, pRedBrush);

    SafeRelease(&pWhiteBrush);
    SafeRelease(&pRedBrush);
}


void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBgBrush = nullptr;
    ID2D1SolidColorBrush* pBallBrush = nullptr;

    // Ensure render target is valid before proceeding
    if (!pRT) return;

    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
    if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
    if (FAILED(hr)) {
        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
        return; // Exit if brush creation fails
    }

    // Draw the background bar (rounded rect)
    D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
    float baseAlpha = 0.8f;
    float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
    float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
    pBgBrush->SetOpacity(finalAlpha);
    pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
    pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

    // --- Draw small circles for pocketed balls inside the bar ---

    // Calculate dimensions based on the bar's height for better scaling
    float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
    float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
    float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
    float padding = spacing * 0.75f; // Add padding from the edges
    float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

    // Starting X positions with padding
    float currentX_P1 = pocketedBallsBarRect.left + padding;
    float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

    int p1DrawnCount = 0;
    int p2DrawnCount = 0;
    const int maxBallsToShow = 7; // Max balls per player in the bar

    for (const auto& b : balls) {
        if (b.isPocketed) {
            // Skip cue ball and 8-ball in this indicator
            if (b.id == 0 || b.id == 8) continue;

            bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
            bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

            if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P1 balls from left to right
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p1DrawnCount++;
            }
            else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P2 balls from right to left
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p2DrawnCount++;
            }
            // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
            // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
        }
    }

    SafeRelease(&pBgBrush);
    SafeRelease(&pBallBrush);
}

void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
    if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
        return; // Only show when placing/dragging
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

    if (pGhostBrush) {
        D2D1_POINT_2F drawPos;
        if (isDraggingCueBall) {
            drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
        }
        else {
            // If not dragging but in placement state, show at current ball pos
            drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
        }

        // Check if the placement is valid before drawing differently?
        bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
        bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

        if (!isValid) {
            // Maybe draw red outline if invalid placement?
            pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
        }


        D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
        pRT->FillEllipse(&ghostEllipse, pGhostBrush);
        pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

        SafeRelease(&pGhostBrush);
    }
}

void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
    int pocketToIndicate = -1;
    // A human player is actively choosing if they are in the CHOOSING_POCKET state.
    bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

    if (isHumanChoosing) {
        // When choosing, show the currently selected pocket (which has a default).
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }
    else if (IsPlayerOnEightBall(currentPlayer)) {
        // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }

    if (pocketToIndicate < 0 || pocketToIndicate > 5) {
        return; // Don't draw if no pocket is selected or relevant.
    }

    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
    if (!pArrowBrush) return;

    // ... The rest of your arrow drawing geometry logic remains exactly the same ...
    // (No changes needed to the points/path drawing, only the logic above)
    D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
    float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
    float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
    float arrowShaftWidth = arrowHeadSize * 0.4f;
    float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
    D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

    if (targetPocketCenter.y == TABLE_TOP) {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
    }
    else {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
    }

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
            pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
    SafeRelease(&pArrowBrush);
}"
RFEwr0Nc,Gemini's 3rd Attempt - Should Fix (Make Or Break!!),alien_fx_fiend,C++,Friday 27th of June 2025 11:09:00 AM CDT,"#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#include <d2d1.h>
#include <dwrite.h>
#include <fstream> // For file I/O
#include <iostream> // For some basic I/O, though not strictly necessary for just file ops
#include <vector>
#include <cmath>
#include <string>
#include <sstream> // Required for wostringstream
#include <algorithm> // Required for std::max, std::min
#include <ctime>    // Required for srand, time
#include <cstdlib> // Required for srand, rand (often included by others, but good practice)
#include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
#include <mmsystem.h> // For PlaySound
#include <tchar.h> //midi func
#include <thread>
#include <atomic>
#include ""resource.h""

#pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""dwrite.lib"")
#pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

// --- Constants ---
const float PI = 3.1415926535f;
const float BALL_RADIUS = 10.0f;
const float TABLE_LEFT = 100.0f;
const float TABLE_TOP = 100.0f;
const float TABLE_WIDTH = 700.0f;
const float TABLE_HEIGHT = 350.0f;
const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
const float CUSHION_THICKNESS = 20.0f;
const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
const float MAX_SHOT_POWER = 15.0f;
const float FRICTION = 0.985f; // Friction factor per frame
const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
const UINT ID_TIMER = 1;
const int TARGET_FPS = 60; // Target frames per second for timer

// --- Enums ---
// --- MODIFIED/NEW Enums ---
enum GameState {
    SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
    PRE_BREAK_PLACEMENT,// Player placing cue ball for break
    BREAKING,           // Player is aiming/shooting the break shot
    CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
    CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
    AIMING,             // Player is aiming
    AI_THINKING,        // NEW: AI is calculating its move
    SHOT_IN_PROGRESS,   // Balls are moving
    ASSIGNING_BALLS,    // Turn after break where ball types are assigned
    PLAYER1_TURN,
    PLAYER2_TURN,
    BALL_IN_HAND_P1,
    BALL_IN_HAND_P2,
    GAME_OVER
};

enum BallType {
    NONE,
    SOLID,  // Yellow (1-7)
    STRIPE, // Red (9-15)
    EIGHT_BALL, // Black (8)
    CUE_BALL // White (0)
};

// NEW Enums for Game Mode and AI Difficulty
enum GameMode {
    HUMAN_VS_HUMAN,
    HUMAN_VS_AI
};

enum AIDifficulty {
    EASY,
    MEDIUM,
    HARD
};

enum OpeningBreakMode {
    CPU_BREAK,
    P1_BREAK,
    FLIP_COIN_BREAK
};

// --- Structs ---
struct Ball {
    int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
    BallType type;
    float x, y;
    float vx, vy;
    D2D1_COLOR_F color;
    bool isPocketed;
};

struct PlayerInfo {
    BallType assignedType;
    int ballsPocketedCount;
    std::wstring name;
};

// --- Global Variables ---

// Direct2D & DirectWrite
ID2D1Factory* pFactory = nullptr;
//ID2D1Factory* g_pD2DFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

// Game State
HWND hwndMain = nullptr;
GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
std::vector<Ball> balls;
int currentPlayer = 1; // 1 or 2
PlayerInfo player1Info = { BallType::NONE, 0, L""Player 1"" };
PlayerInfo player2Info = { BallType::NONE, 0, L""CPU"" }; // Default P2 name
bool foulCommitted = false;
std::wstring gameOverMessage = L"""";
bool firstBallPocketedAfterBreak = false;
std::vector<int> pocketedThisTurn;
// --- NEW: 8-Ball Pocket Call Globals ---
int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""

// --- NEW: Foul Tracking Globals ---
int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
// --- End New Foul Tracking Globals ---

// NEW Game Mode/AI Globals
GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
// bool aiIsThinking = false;       // Replaced by AI_THINKING game state
// NEW: Flag to indicate if the current shot is the opening break of the game
bool isOpeningBreakShot = false;

// NEW: For AI shot planning and visualization
struct AIPlannedShot {
    float angle;
    float power;
    float spinX;
    float spinY;
    bool isValid; // Is there a valid shot planned?
};
AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

// Input & Aiming
POINT ptMouse = { 0, 0 };
bool isAiming = false;
bool isDraggingCueBall = false;
// --- ENSURE THIS LINE EXISTS HERE ---
bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
// --- End Ensure ---
bool isSettingEnglish = false;
D2D1_POINT_2F aimStartPoint = { 0, 0 };
float cueAngle = 0.0f;
float shotPower = 0.0f;
float cueSpinX = 0.0f; // Range -1 to 1
float cueSpinY = 0.0f; // Range -1 to 1
float pocketFlashTimer = 0.0f;
bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
int draggingBallId = -1;
bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
MCIDEVICEID midiDeviceID = 0; //midi func
std::atomic<bool> isMusicPlaying(false); //midi func
std::thread musicThread; //midi func
void StartMidi(HWND hwnd, const TCHAR* midiPath);
void StopMidi();

// UI Element Positions
D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

// Corrected Pocket Center Positions (aligned with table corners/edges)
const D2D1_POINT_2F pocketPositions[6] = {
    {TABLE_LEFT, TABLE_TOP},                           // Top-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
    {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
    {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
    {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
};

// Colors
const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
//const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
//const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Yellow); // Solids = Yellow
const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::Red);   // Stripes = Red
const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
//const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

// --- Forward Declarations ---
HRESULT CreateDeviceResources();
void DiscardDeviceResources();
void OnPaint();
void OnResize(UINT width, UINT height);
void InitGame();
void GameUpdate();
void UpdatePhysics();
void CheckCollisions();
bool CheckPockets(); // Returns true if any ball was pocketed
void ProcessShotResults();
void ApplyShot(float power, float angle, float spinX, float spinY);
void RespawnCueBall(bool behindHeadstring);
bool AreBallsMoving();
void SwitchTurns();
void AssignPlayerBallTypes(BallType firstPocketedType);
void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
Ball* GetBallById(int id);
Ball* GetCueBall();
//void PlayGameMusic(HWND hwnd); //midi func
void AIBreakShot();

// Drawing Functions
void DrawScene(ID2D1RenderTarget* pRT);
void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
void DrawBalls(ID2D1RenderTarget* pRT);
void DrawCueStick(ID2D1RenderTarget* pRT);
void DrawAimingAids(ID2D1RenderTarget* pRT);
void DrawUI(ID2D1RenderTarget* pRT);
void DrawPowerMeter(ID2D1RenderTarget* pRT);
void DrawSpinIndicator(ID2D1RenderTarget* pRT);
void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
// NEW
void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

// Helper Functions
float GetDistance(float x1, float y1, float x2, float y2);
float GetDistanceSq(float x1, float y1, float x2, float y2);
bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
template <typename T> void SafeRelease(T** ppT);
// --- NEW HELPER FORWARD DECLARATIONS ---
bool IsPlayerOnEightBall(int player);
void CheckAndTransitionToPocketChoice(int playerID);
// --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
// --- End Forward Declaration ---
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

// --- NEW Forward Declarations ---

// AI Related
struct AIShotInfo; // Define below
void TriggerAIMove();
void AIMakeDecision();
void AIPlaceCueBall();
AIShotInfo AIFindBestShot();
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
bool IsValidAIAimAngle(float angle); // Basic check

// Dialog Related
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ShowNewGameDialog(HINSTANCE hInstance);
void LoadSettings(); // For deserialization
void SaveSettings(); // For serialization
const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

// --- Forward Declaration for Window Procedure --- <<< Add this line HERE
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// --- NEW Struct for AI Shot Evaluation ---
struct AIShotInfo {
    bool possible = false;          // Is this shot considered viable?
    Ball* targetBall = nullptr;     // Which ball to hit
    int pocketIndex = -1;           // Which pocket to aim for (0-5)
    D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
    float angle = 0.0f;             // Calculated shot angle
    float power = 0.0f;             // Calculated shot power
    float score = -1.0f;            // Score for this shot (higher is better)
    bool involves8Ball = false;     // Is the target the 8-ball?
};

/*
table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
*/

// --- NEW Settings Serialization Functions ---
void SaveSettings() {
    std::ofstream outFile(SETTINGS_FILE_NAME);
    if (outFile.is_open()) {
        outFile << static_cast<int>(gameMode) << std::endl;
        outFile << static_cast<int>(aiDifficulty) << std::endl;
        outFile << static_cast<int>(openingBreakMode) << std::endl;
        outFile.close();
    }
    // else: Handle error, e.g., log or silently fail
}

void LoadSettings() {
    std::ifstream inFile(SETTINGS_FILE_NAME);
    if (inFile.is_open()) {
        int gm, aid, obm;
        if (inFile >> gm) {
            gameMode = static_cast<GameMode>(gm);
        }
        if (inFile >> aid) {
            aiDifficulty = static_cast<AIDifficulty>(aid);
        }
        if (inFile >> obm) {
            openingBreakMode = static_cast<OpeningBreakMode>(obm);
        }
        inFile.close();

        // Validate loaded settings (optional, but good practice)
        if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
        if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
        if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
    }
    // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
}
// --- End Settings Serialization Functions ---

// --- NEW Dialog Procedure ---
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_INITDIALOG:
    {
        // --- ACTION 4: Center Dialog Box ---
// Optional: Force centering if default isn't working
        RECT rcDlg, rcOwner, rcScreen;
        HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
        if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

        GetWindowRect(hwndOwner, &rcOwner);
        GetWindowRect(hDlg, &rcDlg);
        CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

        // Offset the owner rect relative to the screen if it's not the desktop
        if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
            OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
        }


        // Calculate centered position
        int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
        int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

        // Ensure it stays within screen bounds (optional safety)
        x = std::max(static_cast<int>(rcScreen.left), x);
        y = std::max(static_cast<int>(rcScreen.top), y);
        if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
            x = rcScreen.right - (rcDlg.right - rcDlg.left);
        if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
            y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


        // Set the dialog position
        SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

        // --- End Centering Code ---

        // Set initial state based on current global settings (or defaults)
        CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

        CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
            (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

        // Enable/Disable AI group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
        // Set initial state for Opening Break Mode
        CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
            (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
        // Enable/Disable Opening Break group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
    }
    return (INT_PTR)TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_RADIO_2P:
        case IDC_RADIO_CPU:
        {
            bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
            // Enable/Disable AI group controls based on selection
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
            // Also enable/disable Opening Break Mode group
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
        }
        return (INT_PTR)TRUE;

        case IDOK:
            // Retrieve selected options and store in global variables
            if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                gameMode = HUMAN_VS_AI;
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
            }
            else {
                gameMode = HUMAN_VS_HUMAN;
                // openingBreakMode doesn't apply to HvsH, can leave as is or reset
            }
            SaveSettings(); // Save settings when OK is pressed
            EndDialog(hDlg, IDOK); // Close dialog, return IDOK
            return (INT_PTR)TRUE;

        case IDCANCEL: // Handle Cancel or closing the dialog
            // Optionally, could reload settings here if you want cancel to revert to previously saved state
            EndDialog(hDlg, IDCANCEL);
            return (INT_PTR)TRUE;
        }
        break; // End WM_COMMAND
    }
    return (INT_PTR)FALSE; // Default processing
}

// --- NEW Helper to Show Dialog ---
void ShowNewGameDialog(HINSTANCE hInstance) {
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
        // User clicked Start, reset game with new settings
        isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""CPU (Easy)""; break;
            case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
            case HARD: player2Info.name = L""CPU (Hard)""; break;
            }
        }
        else {
            player2Info.name = L""Player 2"";
        }
        // Update window title
        std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
        SetWindowText(hwndMain, windowTitle.c_str());

        InitGame(); // Re-initialize game logic & board
        InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
    }
    else {
        // User cancelled dialog - maybe just resume game? Or exit?
        // For simplicity, we do nothing, game continues as it was.
        // To exit on cancel from F2, would need more complex state management.
    }
}

// --- NEW Reset Game Function ---
void ResetGame(HINSTANCE hInstance) {
    // Call the helper function to show the dialog and re-init if OK clicked
    ShowNewGameDialog(hInstance);
}

// --- WinMain ---
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    if (FAILED(CoInitialize(NULL))) {
        MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
        return -1;
    }

    // --- NEW: Load settings at startup ---
    LoadSettings();

    // --- NEW: Show configuration dialog FIRST ---
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
        // User cancelled the dialog
        CoUninitialize();
        return 0; // Exit gracefully if dialog cancelled
    }
    // Global gameMode and aiDifficulty are now set by the DialogProc

    // Set AI flag based on game mode
    isPlayer2AI = (gameMode == HUMAN_VS_AI);
    if (isPlayer2AI) {
        switch (aiDifficulty) {
        case EASY: player2Info.name = L""CPU (Easy)""; break;
        case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
        case HARD: player2Info.name = L""CPU (Hard)""; break;
        }
    }
    else {
        player2Info.name = L""Player 2"";
    }
    // --- End of Dialog Logic ---


    WNDCLASS wc = { };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L""Direct2D_8BallPool"";
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // --- ACTION 4: Calculate Centered Window Position ---
    const int WINDOW_WIDTH = 1000; // Define desired width
    const int WINDOW_HEIGHT = 700; // Define desired height
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WINDOW_WIDTH) / 2;
    int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

    // --- Change Window Title based on mode ---
    std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
    if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
    else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

    hwndMain = CreateWindowEx(
        0, L""Direct2D_8BallPool"", windowTitle.c_str(), dwStyle,
        windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL, NULL, hInstance, NULL
    );

    if (!hwndMain) {
        MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // Initialize Direct2D Resources AFTER window creation
    if (FAILED(CreateDeviceResources())) {
        MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    InitGame(); // Initialize game state AFTER resources are ready & mode is set
    Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
    StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
    //PlayGameMusic(hwndMain); //midi func

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
        MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    MSG msg = { };
    // --- Modified Main Loop ---
    // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
    // or gets reset to it via F2. The main loop runs normally once game starts.
    while (GetMessage(&msg, NULL, 0, 0)) {
        // We might need modeless dialog handling here if F2 shows dialog
        // while window is active, but DialogBoxParam is modal.
        // Let's assume F2 hides main window, shows dialog, then restarts game loop.
        // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    KillTimer(hwndMain, ID_TIMER);
    DiscardDeviceResources();
    SaveSettings(); // Save settings on exit
    CoUninitialize();

    return (int)msg.wParam;
}

// --- WndProc ---
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // Declare cueBall pointer once at the top, used in multiple cases
    // For clarity, often better to declare within each case where needed.
    Ball* cueBall = nullptr; // Initialize to nullptr
    switch (msg) {
    case WM_CREATE:
        // Resources are now created in WinMain after CreateWindowEx
        return 0;

    case WM_PAINT:
        OnPaint();
        // Validate the entire window region after painting
        ValidateRect(hwnd, NULL);
        return 0;

    case WM_SIZE: {
        UINT width = LOWORD(lParam);
        UINT height = HIWORD(lParam);
        OnResize(width, height);
        return 0;
    }

    case WM_TIMER:
        if (wParam == ID_TIMER) {
            GameUpdate(); // Update game logic and physics
            InvalidateRect(hwnd, NULL, FALSE); // Request redraw
        }
        return 0;

        // --- NEW: Handle F2 Key for Reset ---
        // --- MODIFIED: Handle More Keys ---
    case WM_KEYDOWN:
    { // Add scope for variable declarations

        // --- FIX: Get Cue Ball pointer for this scope ---
        cueBall = GetCueBall();
        // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
        // --- End Fix ---

        // Check which player can interact via keyboard (Humans only)
        bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

        // --- F1 / F2 Keys (Always available) ---
        if (wParam == VK_F2) {
            HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
            ResetGame(hInstance); // Call reset function
            return 0; // Indicate key was processed
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Direct2D-based StickPool game made in C++ from scratch (2764+ lines of code)\n"" // Update line count if needed
                L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                L""About This Game"", MB_OK | MB_ICONINFORMATION);
            return 0; // Indicate key was processed
        }

        // Check for 'M' key (uppercase or lowercase)
            // Toggle music with ""M""
        if (wParam == 'M' || wParam == 'm') {
            //static bool isMusicPlaying = false;
            if (isMusicPlaying) {
                // Stop the music
                StopMidi();
                isMusicPlaying = false;
            }
            else {
                // Build the MIDI file path
                TCHAR midiPath[MAX_PATH];
                GetModuleFileName(NULL, midiPath, MAX_PATH);
                // Keep only the directory part
                TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                if (lastBackslash != NULL) {
                    *(lastBackslash + 1) = '\0';
                }
                // Append the MIDI filename
                _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                // Start playing MIDI
                StartMidi(hwndMain, midiPath);
                isMusicPlaying = true;
            }
        }


        // --- Player Interaction Keys (Only if allowed) ---
        if (canPlayerControl) {
            // --- Get Shift Key State ---
            bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
            float powerStep = 0.2f; // Power step (Adjust as needed)

            switch (wParam) {
            case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle -= angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle < 0) cueAngle += 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_RIGHT: // Rotate Cue Stick Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle += angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_UP: // Decrease Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower -= powerStep;
                    if (shotPower < 0.0f) shotPower = 0.0f;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_DOWN: // Increase Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower += powerStep;
                    if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_SPACE: // Trigger Shot
                if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                    && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                {
                    if (shotPower > 0.15f) { // Use same threshold as mouse
                       // Reset foul flags BEFORE applying shot
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;

                        // Play sound & Apply Shot
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                        // Update State
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false;
                        pocketedThisTurn.clear();
                        shotPower = 0; // Reset power after shooting
                        isAiming = false; isDraggingStick = false; // Reset aiming flags
                        keyboardAimingActive = false;
                    }
                }
                break;

            case VK_ESCAPE: // Cancel Aim/Shot Setup
                if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                {
                    shotPower = 0.0f;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = false;
                    // Revert to basic turn state if not breaking
                    if (currentGameState != BREAKING) {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    }
                }
                break;

            case 'G': // Toggle Cheat Mode
                cheatModeEnabled = !cheatModeEnabled;
                if (cheatModeEnabled)
                    MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                else
                    MessageBeep(MB_OK); // Play a different beep when disabling
                break;

            default:
                // Allow default processing for other keys if needed
                // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                break;
            } // End switch(wParam) for player controls
            return 0; // Indicate player control key was processed
        } // End if(canPlayerControl)
    } // End scope for WM_KEYDOWN case
    // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
    // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
    return 0;

    case WM_MOUSEMOVE: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Hover ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
            int oldHover = currentlyHoveredPocket;
            currentlyHoveredPocket = -1; // Reset
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    currentlyHoveredPocket = i;
                    break;
                }
            }
            if (oldHover != currentlyHoveredPocket) {
                InvalidateRect(hwnd, NULL, FALSE);
            }
            // Do NOT return 0 here, allow normal mouse angle update to continue
        }
        // --- END NEW LOGIC ---


        cueBall = GetCueBall(); // Declare and get cueBall pointer

        if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
            Ball* ball = GetBallById(draggingBallId);
            if (ball) {
                ball->x = (float)ptMouse.x;
                ball->y = (float)ptMouse.y;
                ball->vx = ball->vy = 0.0f;
            }
            return 0;
        }

        if (!cueBall) return 0;

        // Update Aiming Logic (Check player turn)
        if (isDraggingCueBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                currentGameState == PRE_BREAK_PLACEMENT))
        {
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            // Tentative position update
            cueBall->x = (float)ptMouse.x;
            cueBall->y = (float)ptMouse.y;
            cueBall->vx = cueBall->vy = 0;
        }
        else if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            //NEW2 MOUSEBOUND CODE = START
                /*// Clamp mouse inside table bounds during aiming
                if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
            if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
            if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
            if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
            //NEW2 MOUSEBOUND CODE = END
            // Aiming drag updates angle and power
            float dx = (float)ptMouse.x - cueBall->x;
            float dy = (float)ptMouse.y - cueBall->y;
            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
            //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
            //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            }
        }
        else if (isSettingEnglish &&
            ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
        {
            // Setting English
            float dx = (float)ptMouse.x - spinIndicatorCenter.x;
            float dy = (float)ptMouse.y - spinIndicatorCenter.y;
            float dist = GetDistance(dx, dy, 0, 0);
            if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
            cueSpinX = dx / spinIndicatorRadius;
            cueSpinY = dy / spinIndicatorRadius;
        }
        else {
            //DISABLE PERM AIMING = START
            /*// Update visual angle even when not aiming/dragging (Check player turn)
            bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

            if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
            {
                // NEW MOUSEBOUND CODE = START
                    // Only update cue angle if mouse is inside the playable table area
                if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                    ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                {
                    // NEW MOUSEBOUND CODE = END
                    Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                    if (cb) {
                        float dx = (float)ptMouse.x - cb->x;
                        float dy = (float)ptMouse.y - cb->y;
                        if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    }
                } //NEW MOUSEBOUND CODE LINE = DISABLE
            }*/
            //DISABLE PERM AIMING = END
        }
        return 0;
    } // End WM_MOUSEMOVE

    case WM_LBUTTONDOWN: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Selection First ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

            int clickedPocketIndex = -1;
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    clickedPocketIndex = i;
                    break;
                }
            }

            if (clickedPocketIndex != -1) { // Player clicked on a pocket to select it
                if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                else calledPocketP2 = clickedPocketIndex;
                // After selecting, transition to the normal aiming turn state
                currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                pocketCallMessage = L""""; // Clear the message
                InvalidateRect(hwnd, NULL, FALSE);
                return 0; // Consume the click
            }
            // If they click anywhere else, do nothing and let them re-choose
            return 0;
        }
        // --- END NEW LOGIC ---


        if (cheatModeEnabled) {
            // Allow dragging any ball freely
            for (Ball& ball : balls) {
                float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                    isDraggingCueBall = true;
                    draggingBallId = ball.id;
                    if (ball.id == 0) {
                        // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                        if (currentPlayer == 1)
                            currentGameState = BALL_IN_HAND_P1;
                        else if (currentPlayer == 2 && !isPlayer2AI)
                            currentGameState = BALL_IN_HAND_P2;
                    }
                    return 0;
                }
            }
        }

        Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

        // Check which player is allowed to interact via mouse click
        bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
        // Define states where interaction is generally allowed
        bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == AIMING || currentGameState == BREAKING ||
            currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
            currentGameState == PRE_BREAK_PLACEMENT);

        // Check Spin Indicator first (Allow if player's turn/aim phase)
        if (canPlayerClickInteract && canInteractState) {
            float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
            if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                isSettingEnglish = true;
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
                isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                return 0;
            }
        }

        if (!cueBall) return 0;

        // Check Ball-in-Hand placement/drag
        bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
        bool isPlayerAllowedToPlace = (isPlacingBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

        if (isPlayerAllowedToPlace) {
            float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                isDraggingCueBall = true;
                isAiming = false; isDraggingStick = false;
            }
            else {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                    cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                    cueBall->vx = 0; cueBall->vy = 0;
                    isDraggingCueBall = false;
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
            }
            return 0;
        }

        // Check for starting Aim (Cue Ball OR Stick)
        bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

        if (canAim) {
            const float stickDrawLength = 150.0f * 1.4f;
            float currentStickAngle = cueAngle + PI;
            D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
            D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
            float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
            float stickClickThresholdSq = 36.0f;
            float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

            bool clickedStick = (distToStickSq < stickClickThresholdSq);
            bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

            if (clickedStick || clickedCueArea) {
                isDraggingStick = clickedStick && !clickedCueArea;
                isAiming = clickedCueArea;
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                shotPower = 0;
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                if (currentGameState != BREAKING) currentGameState = AIMING;
            }
        }
        return 0;
    } // End WM_LBUTTONDOWN


    case WM_LBUTTONUP: {
        if (cheatModeEnabled && isDraggingCueBall) {
            isDraggingCueBall = false;
            if (draggingBallId == 0) {
                // After dropping CueBall, stay Ball-In-Hand mode if needed
                if (currentPlayer == 1)
                    currentGameState = BALL_IN_HAND_P1;
                else if (currentPlayer == 2 && !isPlayer2AI)
                    currentGameState = BALL_IN_HAND_P2;
            }
            draggingBallId = -1;
            return 0;
        }

        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        Ball* cueBall = GetCueBall(); // Get cueBall pointer

        // Check for releasing aim drag (Stick OR Cue Ball)
        if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            bool wasAiming = isAiming;
            bool wasDraggingStick = isDraggingStick;
            isAiming = false; isDraggingStick = false;

            if (shotPower > 0.15f) { // Check power threshold
                if (currentGameState != AI_THINKING) {
                    firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false; pocketedThisTurn.clear();
                }
            }
            else if (currentGameState != AI_THINKING) { // Revert state if power too low
                if (currentGameState == BREAKING) { /* Still breaking */ }
                else {
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                }
            }
            shotPower = 0; // Reset power indicator regardless
        }

        // Handle releasing cue ball drag (placement)
        if (isDraggingCueBall) {
            isDraggingCueBall = false;
            // Check player allowed to place
            bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowed = (isPlacingState &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT)));

            if (isPlayerAllowed && cueBall) {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                    // Finalize position already set by mouse move
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
                else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
            }
        }

        // Handle releasing english setting
        if (isSettingEnglish) {
            isSettingEnglish = false;
        }
        return 0;
    } // End WM_LBUTTONUP

    case WM_DESTROY:
        isMusicPlaying = false;
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
            SaveSettings(); // Save settings on exit
        }
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// --- Direct2D Resource Management ---

HRESULT CreateDeviceResources() {
    HRESULT hr = S_OK;

    // Create Direct2D Factory
    if (!pFactory) {
        hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr)) return hr;
    }

    // Create DirectWrite Factory
    if (!pDWriteFactory) {
        hr = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (FAILED(hr)) return hr;
    }

    // Create Text Formats
    if (!pTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            16.0f, L""en-us"", &pTextFormat
        );
        if (FAILED(hr)) return hr;
        // Center align text
        pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }
    if (!pLargeTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            48.0f, L""en-us"", &pLargeTextFormat
        );
        if (FAILED(hr)) return hr;
        pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
        pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }


    // Create Render Target (needs valid hwnd)
    if (!pRenderTarget && hwndMain) {
        RECT rc;
        GetClientRect(hwndMain, &rc);
        D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

        hr = pFactory->CreateHwndRenderTarget(
            D2D1::RenderTargetProperties(),
            D2D1::HwndRenderTargetProperties(hwndMain, size),
            &pRenderTarget
        );
        if (FAILED(hr)) {
            // If failed, release factories if they were created in this call
            SafeRelease(&pTextFormat);
            SafeRelease(&pLargeTextFormat);
            SafeRelease(&pDWriteFactory);
            SafeRelease(&pFactory);
            pRenderTarget = nullptr; // Ensure it's null on failure
            return hr;
        }
    }

    return hr;
}

void DiscardDeviceResources() {
    SafeRelease(&pRenderTarget);
    SafeRelease(&pTextFormat);
    SafeRelease(&pLargeTextFormat);
    SafeRelease(&pDWriteFactory);
    // Keep pFactory until application exit? Or release here too? Let's release.
    SafeRelease(&pFactory);
}

void OnResize(UINT width, UINT height) {
    if (pRenderTarget) {
        D2D1_SIZE_U size = D2D1::SizeU(width, height);
        pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
    }
}

// --- Game Initialization ---
void InitGame() {
    srand((unsigned int)time(NULL)); // Seed random number generator
    isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
    aiPlannedShotDetails.isValid = false; // Reset AI planned shot
    aiIsDisplayingAim = false;
    aiAimDisplayFramesLeft = 0;
    // ... (rest of InitGame())

    // --- Ensure pocketed list is clear from the absolute start ---
    pocketedThisTurn.clear();

    balls.clear(); // Clear existing balls

    // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
    player1Info.assignedType = BallType::NONE;
    player1Info.ballsPocketedCount = 0;
    // Player 1 Name usually remains ""Player 1""
    player2Info.assignedType = BallType::NONE;
    player2Info.ballsPocketedCount = 0;
    // Player 2 Name is set based on gameMode in ShowNewGameDialog

    // Create Cue Ball (ID 0)
    // Initial position will be set during PRE_BREAK_PLACEMENT state
    balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

    // --- Create Object Balls (Temporary List) ---
    std::vector<Ball> objectBalls;
    // Solids (1-7, Yellow)
    for (int i = 1; i <= 7; ++i) {
        objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
    }
    // Stripes (9-15, Red)
    for (int i = 9; i <= 15; ++i) {
        objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
    }
    // 8-Ball (ID 8) - Add it to the list to be placed
    objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


    // --- Racking Logic (Improved) ---
    float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
    float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

    // Define rack positions (0-14 indices corresponding to triangle spots)
    D2D1_POINT_2F rackPositions[15];
    int rackIndex = 0;
    for (int row = 0; row < 5; ++row) {
        for (int col = 0; col <= row; ++col) {
            if (rackIndex >= 15) break;
            float x = RACK_POS_X + row * spacingX;
            float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
            rackPositions[rackIndex++] = D2D1::Point2F(x, y);
        }
    }

    // Separate 8-ball
    Ball eightBall;
    std::vector<Ball> otherBalls; // Solids and Stripes
    bool eightBallFound = false;
    for (const auto& ball : objectBalls) {
        if (ball.id == 8) {
            eightBall = ball;
            eightBallFound = true;
        }
        else {
            otherBalls.push_back(ball);
        }
    }
    // Ensure 8 ball was actually created (should always be true)
    if (!eightBallFound) {
        // Handle error - perhaps recreate it? For now, proceed.
        eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
    }


    // Shuffle the other 14 balls
    // Use std::shuffle if available (C++11 and later) for better randomness
    // std::random_device rd;
    // std::mt19937 g(rd());
    // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
    std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

    // --- Place balls into the main 'balls' vector in rack order ---
    // Important: Add the cue ball (already created) first.
    // (Cue ball added at the start of the function now)

    // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
    int eightBallRackIndex = 4;
    eightBall.x = rackPositions[eightBallRackIndex].x;
    eightBall.y = rackPositions[eightBallRackIndex].y;
    eightBall.vx = 0;
    eightBall.vy = 0;
    eightBall.isPocketed = false;
    balls.push_back(eightBall); // Add 8 ball to the main vector

    // 2. Place the shuffled Solids and Stripes in the remaining spots
    size_t otherBallIdx = 0;
    //int otherBallIdx = 0;
    for (int i = 0; i < 15; ++i) {
        if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

        if (otherBallIdx < otherBalls.size()) {
            Ball& ballToPlace = otherBalls[otherBallIdx++];
            ballToPlace.x = rackPositions[i].x;
            ballToPlace.y = rackPositions[i].y;
            ballToPlace.vx = 0;
            ballToPlace.vy = 0;
            ballToPlace.isPocketed = false;
            balls.push_back(ballToPlace); // Add to the main game vector
        }
    }
    // --- End Racking Logic ---


    // --- Determine Who Breaks and Initial State ---
    if (isPlayer2AI) {
        /*// AI Mode: Randomly decide who breaks
        if ((rand() % 2) == 0) {
            // AI (Player 2) breaks
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
            aiTurnPending = true; // Trigger AI logic
        }
        else {
            // Player 1 (Human) breaks
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
            aiTurnPending = false;*/
        switch (openingBreakMode) {
        case CPU_BREAK:
            currentPlayer = 2; // AI breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        case P1_BREAK:
            currentPlayer = 1; // Player 1 breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false;
            break;
        case FLIP_COIN_BREAK:
            if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
            }
            else {
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
            }
            break;
        default: // Fallback to CPU break
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        }
    }
    else {
        // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
        currentPlayer = 1;
        currentGameState = PRE_BREAK_PLACEMENT;
        aiTurnPending = false; // No AI involved
    }

    // Reset other relevant game state variables
    foulCommitted = false;
    gameOverMessage = L"""";
    firstBallPocketedAfterBreak = false;
    // pocketedThisTurn cleared at start
    // Reset shot parameters and input flags
    shotPower = 0.0f;
    cueSpinX = 0.0f;
    cueSpinY = 0.0f;
    isAiming = false;
    isDraggingCueBall = false;
    isSettingEnglish = false;
    cueAngle = 0.0f; // Reset aim angle
}


// --- Game Loop ---
void GameUpdate() {
    if (currentGameState == SHOT_IN_PROGRESS) {
        UpdatePhysics();
        CheckCollisions();

        if (AreBallsMoving()) {
            // When all balls stop, clear aiming flags
            isAiming = false;
            aiIsDisplayingAim = false;
            //ProcessShotResults();
        }

        bool pocketed = CheckPockets(); // Store if any ball was pocketed

        // --- Update pocket flash animation timer ---
        if (pocketFlashTimer > 0.0f) {
            pocketFlashTimer -= 0.02f;
            if (pocketFlashTimer < 0.0f) pocketFlashTimer = 0.0f;
        }

        if (!AreBallsMoving()) {
            ProcessShotResults(); // Determine next state based on what happened
        }
    }

    // --- Check if AI needs to act ---
    else if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
        if (aiIsDisplayingAim) { // AI has decided a shot and is displaying aim
            aiAimDisplayFramesLeft--;
            if (aiAimDisplayFramesLeft <= 0) {
                aiIsDisplayingAim = false; // Done displaying
                if (aiPlannedShotDetails.isValid) {
                    // Execute the planned shot
                    firstHitBallIdThisShot = -1;
                    cueHitObjectBallThisShot = false;
                    railHitAfterContact = false;
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
                    aiPlannedShotDetails.isValid = false; // Clear the planned shot
                }
                currentGameState = SHOT_IN_PROGRESS;
                foulCommitted = false;
                pocketedThisTurn.clear();
            }
            // Else, continue displaying aim
        }
        else if (aiTurnPending) { // AI needs to start its decision process
            // Valid states for AI to start thinking
            /*/if (currentGameState == PRE_BREAK_PLACEMENT && isOpeningBreakShot) {*/
            //newcode 1 commented out
            /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
                // Handle the break shot
                AIBreakShot();
            }*/ //new code 1 end  
            /*else if (currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING ||
                currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2) {*/

                // aiTurnPending might be consumed by AIBreakShot or remain for next cycle if needed
        /* } //new code 2 commented out
        else if (currentGameState == BALL_IN_HAND_P2 && currentPlayer == 2 && isPlayer2AI) {
            AIPlaceCueBall(); // AI places the ball first
            // After placement, AI needs to decide its shot.
            // Transition to a state where AIMakeDecision will be called for shot selection.
            currentGameState = PLAYER2_TURN; // Or a specific AI_AIMING_AFTER_PLACEMENT state
                                             // aiTurnPending remains true to trigger AIMakeDecision next.
        }
        else if (currentGameState == PLAYER2_TURN && currentPlayer == 2 && isPlayer2AI) {
            // This is for a normal turn (not break, not immediately after ball-in-hand placement)

                currentGameState = AI_THINKING; // Set state to indicate AI is processing
                aiTurnPending = false;         // Consume the pending turn flag
                AIMakeDecision();              // For normal shots (non-break)
            }
            else {
                // Not a state where AI should act
                aiTurnPending = false;
            }*/
            // 2b) AI is ready to think (pending flag)
            // **1) Ball-in-Hand** let AI place the cue ball first
            if (currentGameState == BALL_IN_HAND_P2) {
                // Step 1: AI places the cue ball.
                AIPlaceCueBall();
                // Step 2: Transition to thinking state for shot decision.
                currentGameState = AI_THINKING; //newcode5
                // Step 3: Consume the pending flag for the placement phase.
                //         AIMakeDecision will handle shot planning now.
                aiTurnPending = false; //newcode5
                // Step 4: AI immediately decides the shot from the new position.
                AIMakeDecision(); //newcode5
            }
            // **2) Opening break** special break shot logic
            else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                AIBreakShot();
            }
            else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) { //newcode5
                // General turn for AI to think (not ball-in-hand, not initial break placement)
                currentGameState = AI_THINKING; //newcode5
                aiTurnPending = false; // Consume the flag //newcode5
                AIMakeDecision(); //newcode5
            }
            // **3) Otherwise** normal shot planning
            /*else { //orig uncommented oldcode5
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
            }*/
        }

        //} //bracefix
        // If current state is AI_THINKING but not displaying aim, then AI decision has already been made
    }
}

// --- Physics and Collision ---
void UpdatePhysics() {
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) {
            b.x += b.vx;
            b.y += b.vy;

            // Apply friction
            b.vx *= FRICTION;
            b.vy *= FRICTION;

            // Stop balls if velocity is very low
            if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                b.vx = 0;
                b.vy = 0;
            }
        }
    }
}

void CheckCollisions() {
    float left = TABLE_LEFT;
    float right = TABLE_RIGHT;
    float top = TABLE_TOP;
    float bottom = TABLE_BOTTOM;
    const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

    // --- Reset Per-Frame Sound Flags ---
    bool playedWallSoundThisFrame = false;
    bool playedCollideSoundThisFrame = false;
    // ---

    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b1 = balls[i];
        if (b1.isPocketed) continue;

        bool nearPocket[6];
        for (int p = 0; p < 6; ++p) {
            nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
        }
        bool nearTopLeftPocket = nearPocket[0];
        bool nearTopMidPocket = nearPocket[1];
        bool nearTopRightPocket = nearPocket[2];
        bool nearBottomLeftPocket = nearPocket[3];
        bool nearBottomMidPocket = nearPocket[4];
        bool nearBottomRightPocket = nearPocket[5];

        bool collidedWallThisBall = false;

        // --- Ball-Wall Collisions ---
        // (Check logic unchanged, added sound calls and railHitAfterContact update)
        // Left Wall
        if (b1.x - BALL_RADIUS < left) {
            if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Right Wall
        if (b1.x + BALL_RADIUS > right) {
            if (!nearTopRightPocket && !nearBottomRightPocket) {
                b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Top Wall
        if (b1.y - BALL_RADIUS < top) {
            if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Bottom Wall
        if (b1.y + BALL_RADIUS > bottom) {
            if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }

        // Spin effect (Unchanged)
        if (collidedWallThisBall) {
            if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
            if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
            cueSpinX *= 0.7f; cueSpinY *= 0.7f;
        }


        // --- Ball-Ball Collisions ---
        for (size_t j = i + 1; j < balls.size(); ++j) {
            Ball& b2 = balls[j];
            if (b2.isPocketed) continue;

            float dx = b2.x - b1.x; float dy = b2.y - b1.y;
            float distSq = dx * dx + dy * dy;
            float minDist = BALL_RADIUS * 2.0f;

            if (distSq > 1e-6 && distSq < minDist * minDist) {
                float dist = sqrtf(distSq);
                float overlap = minDist - dist;
                float nx = dx / dist; float ny = dy / dist;

                // Separation (Unchanged)
                b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                float velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) { // Colliding
                    // --- Play Ball Collision Sound ---
                    if (!playedCollideSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                        playedCollideSoundThisFrame = true; // Set flag
                    }
                    // --- End Sound ---

                    // --- NEW: Track First Hit and Cue/Object Collision ---
                    if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                        if (b1.id == 0) { // Cue ball hit b2 first
                            firstHitBallIdThisShot = b2.id;
                            cueHitObjectBallThisShot = true;
                        }
                        else if (b2.id == 0) { // Cue ball hit b1 first
                            firstHitBallIdThisShot = b1.id;
                            cueHitObjectBallThisShot = true;
                        }
                        // If neither is cue ball, doesn't count as first hit for foul purposes
                    }
                    else if (b1.id == 0 || b2.id == 0) {
                        // Track subsequent cue ball collisions with object balls
                        cueHitObjectBallThisShot = true;
                    }
                    // --- End First Hit Tracking ---


                    // Impulse (Unchanged)
                    float impulse = velAlongNormal;
                    b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                    b2.vx += impulse * nx; b2.vy += impulse * ny;

                    // Spin Transfer (Unchanged)
                    if (b1.id == 0 || b2.id == 0) {
                        float spinEffectFactor = 0.08f;
                        b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                    }
                }
            }
        } // End ball-ball loop
    } // End ball loop
} // End CheckCollisions


bool CheckPockets() {
    bool ballPocketedThisCheck = false; // Local flag for this specific check run
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) { // Only check balls that aren't already flagged as pocketed
            for (int p = 0; p < 6; ++p) {
                float distSq = GetDistanceSq(b.x, b.y, pocketPositions[p].x, pocketPositions[p].y);
                // --- Use updated POCKET_RADIUS ---
                if (distSq < POCKET_RADIUS * POCKET_RADIUS) {
                    b.isPocketed = true;
                    b.vx = b.vy = 0;
                    pocketedThisTurn.push_back(b.id);

                    // --- Play Pocket Sound (Threaded) ---
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound ---

                    break; // Ball is pocketed
                }
            }
        }
    }
    return ballPocketedThisCheck;
}

bool AreBallsMoving() {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
            return true;
        }
    }
    return false;
}

void RespawnCueBall(bool behindHeadstring) { // 'behindHeadstring' only relevant for initial break placement
    Ball* cueBall = GetCueBall();
    if (cueBall) {
        // Reset position to a default
        //disabled for behind headstring (now move anywhere)
        /*cueBall->x = HEADSTRING_X * 0.5f;
        cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;*/
        // Reset position to a default:
        if (behindHeadstring) {
            // Opening break: kitchen center
            cueBall->x = HEADSTRING_X * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        else {
            // Ball-in-hand (foul): center of full table
            cueBall->x = TABLE_LEFT + TABLE_WIDTH / 2.0f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        cueBall->vx = 0;
        cueBall->vy = 0;
        cueBall->isPocketed = false;

        // Set state based on who gets ball-in-hand
        /*// 'currentPlayer' already reflects who's turn it is NOW (switched before calling this)*/
        // 'currentPlayer' has already been switched to the player whose turn it will be.
        // The 'behindHeadstring' parameter to RespawnCueBall is mostly for historical reasons / initial setup.
        if (currentPlayer == 1) { // Player 2 (AI/Human) fouled, Player 1 (Human) gets ball-in-hand
            currentGameState = BALL_IN_HAND_P1;
            aiTurnPending = false; // Ensure AI flag off
        }
        else { // Player 1 (Human) fouled, Player 2 gets ball-in-hand
            if (isPlayer2AI) {
                // --- CONFIRMED FIX: Set correct state for AI Ball-in-Hand ---
                currentGameState = BALL_IN_HAND_P2; // AI now needs to place the ball
                aiTurnPending = true; // Trigger AI logic (will call AIPlaceCueBall first)
            }
            else { // Human Player 2
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = false; // Ensure AI flag off
            }
        }
        // Handle initial placement state correctly if called from InitGame
        /*if (behindHeadstring && currentGameState != PRE_BREAK_PLACEMENT) {
            // This case might need review depending on exact initial setup flow,
            // but the foul logic above should now be correct.
            // Let's ensure initial state is PRE_BREAK_PLACEMENT if behindHeadstring is true.*/
            //currentGameState = PRE_BREAK_PLACEMENT;
    }
}
//}


// --- Game Logic ---

void ApplyShot(float power, float angle, float spinX, float spinY) {
    Ball* cueBall = GetCueBall();
    if (cueBall) {

        // --- Play Cue Strike Sound (Threaded) ---
        if (power > 0.1f) { // Only play if it's an audible shot
            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
        }
        // --- End Sound ---

        cueBall->vx = cosf(angle) * power;
        cueBall->vy = sinf(angle) * power;

        // Apply English (Spin) - Simplified effect (Unchanged)
        cueBall->vx += sinf(angle) * spinY * 0.5f;
        cueBall->vy -= cosf(angle) * spinY * 0.5f;
        cueBall->vx -= cosf(angle) * spinX * 0.5f;
        cueBall->vy -= sinf(angle) * spinX * 0.5f;

        // Store spin (Unchanged)
        cueSpinX = spinX;
        cueSpinY = spinY;

        // --- Reset Foul Tracking flags for the new shot ---
        // (Also reset in LBUTTONUP, but good to ensure here too)
        firstHitBallIdThisShot = -1;      // No ball hit yet
        cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
        railHitAfterContact = false;     // No rail hit after contact yet
        // --- End Reset ---

                // If this was the opening break shot, clear the flag
        if (isOpeningBreakShot) {
            isOpeningBreakShot = false; // Mark opening break as taken
        }
    }
}


void ProcessShotResults() {
    bool cueBallPocketed = false;
    bool eightBallPocketed = false;

    // Update pocketed counts first
    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    int ownBallsPocketedThisTurn = 0;

    for (int id : pocketedThisTurn) {
        Ball* b = GetBallById(id);
        if (!b) continue;

        if (b->id == 0) cueBallPocketed = true;
        else if (b->id == 8) eightBallPocketed = true;
        else {
            if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) player1Info.ballsPocketedCount++;
            else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) player2Info.ballsPocketedCount++;

            if (b->type == shootingPlayer.assignedType) {
                ownBallsPocketedThisTurn++;
            }
        }
    }

    // Check for game over BEFORE fouls, as sinking the 8-ball is a game-ending event.
    if (eightBallPocketed) {
        CheckGameOverConditions(true, cueBallPocketed);
        if (currentGameState == GAME_OVER) {
            pocketedThisTurn.clear();
            return;
        }
    }

    // Now, determine if a foul occurred on the shot.
    bool turnFoul = false;
    if (cueBallPocketed) {
        turnFoul = true;
    }
    else {
        Ball* firstHit = GetBallById(firstHitBallIdThisShot);
        if (!firstHit) { // Rule: Hitting nothing is a foul.
            turnFoul = true;
        }
        else { // Rule: Hitting the wrong ball type is a foul.
            if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                if (IsPlayerOnEightBall(currentPlayer)) {
                    if (firstHit->id != 8) turnFoul = true; // Must hit 8-ball first.
                }
                else {
                    if (firstHit->type != shootingPlayer.assignedType) turnFoul = true; // Must hit own ball type.
                }
            }
            // If table is open, hitting any non-8-ball is legal, so no foul here.
        }
    }

    // Rule: No rail after contact is a foul.
    if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
        turnFoul = true;
    }

    foulCommitted = turnFoul;

    // --- State Transitions (The most critical part of the fix) ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false); // Ball in hand for the opponent.
    }
    else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed && !eightBallPocketed) {
        // Table is open, and a legal ball was pocketed. Assign types.
        Ball* firstBall = GetBallById(pocketedThisTurn[0]);
        if (firstBall) AssignPlayerBallTypes(firstBall->type);
        // The player's turn continues. NOW, check if they are on the 8-ball.
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else if (ownBallsPocketedThisTurn > 0) {
        // Player legally pocketed one of their own balls. Their turn continues.
        // THIS IS THE FIX: We must check if that was their last ball.
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        // Player missed, or pocketed an opponent's ball without a foul. Turn switches.
        SwitchTurns();
    }

    pocketedThisTurn.clear(); // Clean up for the next shot.
}

void AssignPlayerBallTypes(BallType firstPocketedType) {
    if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
        if (currentPlayer == 1) {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        else {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
    }
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.
}

void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
    if (!eightBallPocketed) return;

    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;
    bool shooterWasOn8Ball = IsPlayerOnEightBall(currentPlayer);
    int pocketThe8BallEntered = -1;

    // Find which pocket the 8-ball actually went into
    Ball* b = GetBallById(8);
    if (b) {
        for (int p_idx = 0; p_idx < 6; ++p_idx) {
            if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                pocketThe8BallEntered = p_idx;
                break;
            }
        }
    }

    // Case 1: 8-ball pocketed on the break (or before colors assigned)
    if (player1Info.assignedType == BallType::NONE) {
        if (b) { // Re-spot the 8-ball
            b->isPocketed = false;
            b->x = RACK_POS_X;
            b->y = RACK_POS_Y;
            b->vx = b->vy = 0;
        }
        if (cueBallPocketed) {
            foulCommitted = true; // Let ProcessShotResults handle the foul, game doesn't end.
        }
        return; // Game continues
    }

    // Case 2: Normal gameplay win/loss conditions
    int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;

    if (!shooterWasOn8Ball) {
        // Loss: Pocketed 8-ball before clearing own group.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" pocketed 8-ball early)"";
    }
    else if (cueBallPocketed) {
        // Loss: Scratched while shooting for the 8-ball.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" scratched on 8-ball)"";
    }
    else if (calledPocket == -1) {
        // Loss: Pocketed 8-ball without calling a pocket. THIS IS THE KEY FIX FOR YOUR REPORTED PROBLEM.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" did not call a pocket)"";
    }
    else if (pocketThe8BallEntered != calledPocket) {
        // Loss: Pocketed 8-ball in the wrong pocket.
        gameOverMessage = opponentPlayer.name + L"" Wins! ("" + shootingPlayer.name + L"" 8-ball in wrong pocket)"";
    }
    else {
        // WIN! Pocketed 8-ball in the called pocket without a foul.
        gameOverMessage = shootingPlayer.name + L"" Wins!"";
    }

    currentGameState = GAME_OVER;
}


void SwitchTurns() {
    currentPlayer = (currentPlayer == 1) ? 2 : 1;
    isAiming = false;
    shotPower = 0;
    CheckAndTransitionToPocketChoice(currentPlayer); // Use the new helper
}

void AIBreakShot() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
    // AI will place the cue ball and then plan the shot.
    if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
        // Place cue ball in the kitchen randomly
        /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
        float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

        // --- AI Places Cue Ball for Break ---
// Decide if placing center or side. For simplicity, let's try placing slightly off-center
// towards one side for a more angled break, or center for direct apex hit.
// A common strategy is to hit the second ball of the rack.

        float placementY = RACK_POS_Y; // Align vertically with the rack center
        float placementX;

        // Randomly choose a side or center-ish placement for variation.
        int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

        if (placementChoice == 0) { // Left-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
        }
        else if (placementChoice == 2) { // Right-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
        }
        else { // Center-ish
            placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
        }
        placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

        bool validPos = false;
        int attempts = 0;
        while (!validPos && attempts < 100) {
            /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
            cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                validPos = true; // [cite: 1591]*/
                // Try the chosen X, but vary Y slightly to find a clear spot
            cueBall->x = placementX;
            cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
            cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                validPos = true;
            }
            attempts++; // [cite: 1592]
        }
        if (!validPos) {
            // Fallback position
            /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
            cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
            }
        }
        cueBall->vx = 0; // [cite: 1595]
        cueBall->vy = 0; // [cite: 1596]

        // Plan a break shot: aim at the center of the rack (apex ball)
        float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
        float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

        float dx = targetX - cueBall->x; // [cite: 1599]
        float dy = targetY - cueBall->y; // [cite: 1600]
        float shotAngle = atan2f(dy, dx); // [cite: 1600]
        float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
            cueBall->y = RACK_POS_Y;
        }
        cueBall->vx = 0; cueBall->vy = 0;

        // --- AI Plans the Break Shot ---
        float targetX, targetY;
        // If cue ball is near center of kitchen width, aim for apex.
        // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
        float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
        if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
            // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
            targetX = RACK_POS_X; // Apex ball X
            targetY = RACK_POS_Y; // Apex ball Y
        }
        else {
            // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
            // This is a simplification. A more robust way is to find the actual second ball.
            // For now, aim slightly off the apex towards the side the cue ball is on.
            targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
            targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
        }

        float dx = targetX - cueBall->x;
        float dy = targetY - cueBall->y;
        float shotAngle = atan2f(dy, dx);
        float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

        // Store planned shot details for the AI
        /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
        aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
        aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
        aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
        aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

        aiPlannedShotDetails.angle = shotAngle;
        aiPlannedShotDetails.power = shotPowerValue;
        aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
        /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
        ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
        ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
        ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

        ::cueAngle = aiPlannedShotDetails.angle;
        ::shotPower = aiPlannedShotDetails.power;
        ::cueSpinX = aiPlannedShotDetails.spinX;
        ::cueSpinY = aiPlannedShotDetails.spinY;

        // Set up for AI display via GameUpdate
        /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

        currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                        // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                        // and then execute the shot using aiPlannedShotDetails.
                                        // isOpeningBreakShot will be set to false within ApplyShot.

        // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display

        return; // The break shot is now planned and will be executed by GameUpdate
    }

    // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
    //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
    //    This part can be extended if AIBreakShot needs to handle other scenarios.
    //    For now, the primary logic is above.
}

// --- Helper Functions ---

Ball* GetBallById(int id) {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id == id) {
            return &balls[i];
        }
    }
    return nullptr;
}

Ball* GetCueBall() {
    return GetBallById(0);
}

float GetDistance(float x1, float y1, float x2, float y2) {
    return sqrtf(GetDistanceSq(x1, y1, x2, y2));
}

float GetDistanceSq(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return dx * dx + dy * dy;
}

bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
    // Basic bounds check (inside cushions)
    float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
    float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
    float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
    float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

    if (x < left || x > right || y < top || y > bottom) {
        return false;
    }

    // Check headstring restriction if needed
    if (checkHeadstring && x >= HEADSTRING_X) {
        return false;
    }

    // Check overlap with other balls
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
            if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                return false; // Overlapping another ball
            }
        }
    }

    return true;
}

// --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

// Checks if a player has pocketed all their balls and is now on the 8-ball.
bool IsPlayerOnEightBall(int player) {
    PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
    if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
        Ball* eightBall = GetBallById(8);
        return (eightBall && !eightBall->isPocketed);
    }
    return false;
}

// Centralized logic to enter the ""choosing pocket"" state. This fixes the indicator bugs.
void CheckAndTransitionToPocketChoice(int playerID) {
    bool needsToCall = IsPlayerOnEightBall(playerID);
    int* calledPocketForPlayer = (playerID == 1) ? &calledPocketP1 : &calledPocketP2;

    if (needsToCall && *calledPocketForPlayer == -1) { // Only transition if a pocket hasn't been called yet
        pocketCallMessage = ((playerID == 1) ? player1Info.name : player2Info.name) + L"": Choose a pocket..."";
        if (playerID == 1) {
            currentGameState = CHOOSING_POCKET_P1;
        }
        else { // Player 2
            if (isPlayer2AI) {
                currentGameState = AI_THINKING;
                aiTurnPending = true;
            }
            else {
                currentGameState = CHOOSING_POCKET_P2;
            }
        }
        if (!(playerID == 2 && isPlayer2AI)) {
            *calledPocketForPlayer = 5; // Default to top-right if none chosen
        }
    }
    else {
        // Player does not need to call a pocket (or already has), proceed to normal turn.
        pocketCallMessage = L""""; // Clear any message
        currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
        if (playerID == 2 && isPlayer2AI) {
            aiTurnPending = true;
        }
    }
}

template <typename T>
void SafeRelease(T** ppT) {
    if (*ppT) {
        (*ppT)->Release();
        *ppT = nullptr;
    }
}

// --- Helper Function for Line Segment Intersection ---
// Finds intersection point of line segment P1->P2 and line segment P3->P4
// Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
{
    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

    // Check if lines are parallel or collinear
    if (fabs(denominator) < 1e-6) {
        return false;
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    // Check if intersection point lies on both segments
    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
        intersection.x = p1.x + ua * (p2.x - p1.x);
        intersection.y = p1.y + ua * (p2.y - p1.y);
        return true;
    }

    return false;
}

// --- INSERT NEW HELPER FUNCTION HERE ---
// Calculates the squared distance from point P to the line segment AB.
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
    float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
    if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
    // Consider P projecting onto the line AB infinite line
    // t = [(P-A) . (B-A)] / |B-A|^2
    float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
    t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
    // Projection falls on the segment
    D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
    return GetDistanceSq(p.x, p.y, projection.x, projection.y);
}
// --- End New Helper ---

// --- NEW AI Implementation Functions ---

// Main entry point for AI turn
void AIMakeDecision() {
    //AIShotInfo bestShot = { false }; // Declare here
    // This function is called when currentGameState is AI_THINKING (for a normal shot decision)
    Ball* cueBall = GetCueBall();
    if (!cueBall || !isPlayer2AI || currentPlayer != 2) {
        aiPlannedShotDetails.isValid = false; // Ensure no shot if conditions not met
        return;
    }

    // Phase 1: Placement if needed (Ball-in-Hand or Initial Break)
    /*if ((isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) || currentGameState == BALL_IN_HAND_P2) {
        AIPlaceCueBall(); // Handles kitchen placement for break or regular ball-in-hand
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            currentGameState = BREAKING; // Now AI needs to decide the break shot parameters
        }
        // For regular BALL_IN_HAND_P2, after placement, it will proceed to find a shot.
    }*/

    aiPlannedShotDetails.isValid = false; // Default to no valid shot found yet for this decision cycle
    // Note: isOpeningBreakShot is false here because AIBreakShot handles the break.

     // Phase 2: Decide shot parameters (Break or Normal play)
    /*if (isOpeningBreakShot && currentGameState == BREAKING) {
        // Force cue ball into center of kitchen
        cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
        cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f;
        cueBall->vx = cueBall->vy = 0.0f;

        float rackCenterX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f * 2.0f;
        float rackCenterY = RACK_POS_Y;
        float dx = rackCenterX - cueBall->x;
        float dy = rackCenterY - cueBall->y;

        aiPlannedShotDetails.angle = atan2f(dy, dx);
        aiPlannedShotDetails.power = MAX_SHOT_POWER;
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Apply shot immediately
        cueAngle = aiPlannedShotDetails.angle;
        shotPower = aiPlannedShotDetails.power;
        cueSpinX = aiPlannedShotDetails.spinX;
        cueSpinY = aiPlannedShotDetails.spinY;

        firstHitBallIdThisShot = -1;
        cueHitObjectBallThisShot = false;
        railHitAfterContact = false;
        isAiming = false;
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        //bool aiIsDisplayingAim = true;

        std::thread([](const TCHAR* soundName) {
            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
            }, TEXT(""cue.wav"")).detach();

            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
            currentGameState = SHOT_IN_PROGRESS;
            isOpeningBreakShot = false;
            aiTurnPending = false;
            pocketedThisTurn.clear();
            return;
    }
    else {*/
    // --- Normal AI Shot Decision (using AIFindBestShot) ---
    AIShotInfo bestShot = AIFindBestShot(); // bugtraq
    //bestShot = AIFindBestShot(); // bugtraq
    if (bestShot.possible) {
        aiPlannedShotDetails.angle = bestShot.angle;
        aiPlannedShotDetails.power = bestShot.power;
        aiPlannedShotDetails.spinX = 0.0f; // AI doesn't use spin yet
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;
    }
    else {
        // Safety tap if no better shot found
        // Try to hit the closest 'own' ball gently or any ball if types not assigned
        Ball* ballToNudge = nullptr;
        float minDistSq = -1.0f;
        BallType aiTargetType = player2Info.assignedType;
        bool mustHit8Ball = (aiTargetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);

        for (auto& b : balls) {
            if (b.isPocketed || b.id == 0) continue;
            bool canHitThis = false;
            if (mustHit8Ball) canHitThis = (b.id == 8);
            else if (aiTargetType != BallType::NONE) canHitThis = (b.type == aiTargetType);
            else canHitThis = (b.id != 8); // Can hit any non-8-ball if types not assigned

            if (canHitThis) {
                float dSq = GetDistanceSq(cueBall->x, cueBall->y, b.x, b.y);
                if (ballToNudge == nullptr || dSq < minDistSq) {
                    ballToNudge = &b;
                    minDistSq = dSq;
                }
            }
        }
        if (ballToNudge) { // Found a ball to nudge
            aiPlannedShotDetails.angle = atan2f(ballToNudge->y - cueBall->y, ballToNudge->x - cueBall->x);
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.15f; // Gentle tap
        }
        else { // Absolute fallback: small tap forward
            aiPlannedShotDetails.angle = cueAngle; // Keep last angle or default
            //aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
        }
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true; // Safety shot is a ""valid"" plan
    }
    //} //bracefix

    // Phase 3: Setup for Aim Display (if a valid shot was decided)
    if (aiPlannedShotDetails.isValid) {
        cueAngle = aiPlannedShotDetails.angle;   // Update global for drawing
        shotPower = aiPlannedShotDetails.power;  // Update global for drawing
        // cueSpinX and cueSpinY could also be set here if AI used them
        cueSpinX = aiPlannedShotDetails.spinX; // Also set these for drawing consistency
        cueSpinY = aiPlannedShotDetails.spinY; //

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        // currentGameState remains AI_THINKING, GameUpdate will handle the display countdown and shot execution.
            // FIRE THE BREAK SHOT NOW
            // Immediately execute the break shot after setting parameters
        /*ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
        currentGameState = SHOT_IN_PROGRESS;
        aiTurnPending = false;
        isOpeningBreakShot = false;*/
    }
    else {
        // Should not happen if safety shot is always planned, but as a fallback:
        aiIsDisplayingAim = false;
        // If AI truly can't decide anything, maybe switch turn or log error. For now, it will do nothing this frame.
        // Or force a minimal safety tap without display.
        // To ensure game progresses, let's plan a minimal tap if nothing else.
        if (!aiPlannedShotDetails.isValid) { // Double check
            aiPlannedShotDetails.angle = 0.0f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.05f; // Very small tap
            aiPlannedShotDetails.spinX = 0.0f; aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;
            //cueAngle = aiPlannedShotDetails.angle; shotPower = aiPlannedShotDetails.power;
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;
            cueSpinX = aiPlannedShotDetails.spinX;
            cueSpinY = aiPlannedShotDetails.spinY;
            aiIsDisplayingAim = true; // Allow display for this minimal tap too
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES / 2; // Shorter display for fallback
        }
    }
    // aiTurnPending was set to false by GameUpdate before calling AIMakeDecision.
    // AIMakeDecision's job is to populate aiPlannedShotDetails and trigger display.
}

// AI logic for placing cue ball during ball-in-hand
void AIPlaceCueBall() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // --- CPU AI Opening Break: Kitchen Placement ---
    /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
        float kitchenMinX = TABLE_LEFT + BALL_RADIUS;
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS;
        float kitchenMinY = TABLE_TOP + BALL_RADIUS;
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS;
        bool validPositionFound = false;
        int attempts = 0;
        while (!validPositionFound && attempts < 100) {
            cueBall->x = kitchenMinX + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxX - kitchenMinX)));
            cueBall->y = kitchenMinY + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxY - kitchenMinY)));
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                validPositionFound = true;
            }
            attempts++;
        }
        if (!validPositionFound) {
            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2.0f;
                cueBall->y = RACK_POS_Y;
            }
        }
        cueBall->vx = 0; cueBall->vy = 0;
        return;
    }*/
    // --- End CPU AI Opening Break Placement ---

    // This function is now SOLELY for Ball-In-Hand placement for the AI (anywhere on the table).
    // Break placement is handled by AIBreakShot().

    // Simple Strategy: Find the easiest possible shot for the AI's ball type
    // Place the cue ball directly behind that target ball, aiming straight at a pocket.
    // (More advanced: find spot offering multiple options or safety)

    AIShotInfo bestPlacementShot = { false };
    D2D1_POINT_2F bestPlacePos = D2D1::Point2F(HEADSTRING_X * 0.5f, RACK_POS_Y); // Default placement

    // A better default for ball-in-hand (anywhere) might be center table if no shot found.
    bestPlacePos = D2D1::Point2F(TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP + TABLE_HEIGHT / 2.0f);
    float bestPlacementScore = -1.0f; // Keep track of the score for the best placement found

    BallType targetType = player2Info.assignedType;
    bool canTargetAnyPlacement = false; // Local scope variable for placement logic
    if (targetType == BallType::NONE) {
        canTargetAnyPlacement = true;
    }
    bool target8Ball = (!canTargetAnyPlacement && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    if (target8Ball) targetType = BallType::EIGHT_BALL;


    for (auto& targetBall : balls) {
        if (targetBall.isPocketed || targetBall.id == 0) continue;

        // Determine if current ball is a valid target for placement consideration
        bool currentBallIsValidTarget = false;
        if (target8Ball && targetBall.id == 8) currentBallIsValidTarget = true;
        else if (canTargetAnyPlacement && targetBall.id != 8) currentBallIsValidTarget = true;
        else if (!canTargetAnyPlacement && !target8Ball && targetBall.type == targetType) currentBallIsValidTarget = true;

        if (!currentBallIsValidTarget) continue; // Skip if not a valid target

        for (int p = 0; p < 6; ++p) {
            // Calculate ideal cue ball position: straight line behind target ball aiming at pocket p
            float targetToPocketX = pocketPositions[p].x - targetBall.x;
            float targetToPocketY = pocketPositions[p].y - targetBall.y;
            float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);
            if (dist < 1.0f) continue; // Avoid division by zero

            float idealAngle = atan2f(targetToPocketY, targetToPocketX);
            // Place cue ball slightly behind target ball along this line
            float placeDist = BALL_RADIUS * 3.0f; // Place a bit behind
            D2D1_POINT_2F potentialPlacePos = D2D1::Point2F( // Use factory function
                targetBall.x - cosf(idealAngle) * placeDist,
                targetBall.y - sinf(idealAngle) * placeDist
            );

            // Check if this placement is valid (on table, behind headstring if break, not overlapping)
            /*bool behindHeadstringRule = (currentGameState == PRE_BREAK_PLACEMENT);*/
            // For ball-in-hand (NOT break), behindHeadstringRule is false.
            // The currentGameState should be BALL_IN_HAND_P2 when this is called for a foul.
            bool behindHeadstringRule = false; // Player can place anywhere after a foul
            if (IsValidCueBallPosition(potentialPlacePos.x, potentialPlacePos.y, behindHeadstringRule)) {
                // Is path from potentialPlacePos to targetBall clear?
                // Use D2D1::Point2F() factory function here
                if (IsPathClear(potentialPlacePos, D2D1::Point2F(targetBall.x, targetBall.y), 0, targetBall.id)) {
                    // Is path from targetBall to pocket clear?
                    // Use D2D1::Point2F() factory function here
                    if (IsPathClear(D2D1::Point2F(targetBall.x, targetBall.y), pocketPositions[p], targetBall.id, -1)) {
                        // This seems like a good potential placement. Score it?
                        // Easy AI: Just take the first valid one found.
                        /*bestPlacePos = potentialPlacePos;
                        goto placement_found;*/ // Use goto for simplicity in non-OOP structure
                        // This is a possible shot. Score this placement.
// A simple score: distance to target ball (shorter is better for placement).
// More advanced: consider angle to pocket, difficulty of the shot from this placement.
                        AIShotInfo tempShotInfo;
                        tempShotInfo.possible = true;
                        tempShotInfo.targetBall = &targetBall;
                        tempShotInfo.pocketIndex = p;
                        tempShotInfo.ghostBallPos = CalculateGhostBallPos(&targetBall, p); // Not strictly needed for placement score but good for consistency
                        tempShotInfo.angle = idealAngle; // The angle from the placed ball to target
                        // Use EvaluateShot's scoring mechanism if possible, or a simpler one here.
                        float currentScore = 1000.0f / (1.0f + GetDistance(potentialPlacePos.x, potentialPlacePos.y, targetBall.x, targetBall.y)); // Inverse distance

                        if (currentScore > bestPlacementScore) {
                            bestPlacementScore = currentScore;
                            bestPlacePos = potentialPlacePos;
                        }
                    }
                }
            }
        }
    }

placement_found:
    // Place the cue ball at the best found position (or default if no good spot found)
    cueBall->x = bestPlacePos.x;
    cueBall->y = bestPlacePos.y;
    cueBall->vx = 0;
    cueBall->vy = 0;
}


// AI finds the best shot available on the table
AIShotInfo AIFindBestShot() {
    AIShotInfo bestShotOverall = { false };
    Ball* cueBall = GetCueBall();
    if (!cueBall) return bestShotOverall;
    // Ensure cue ball position is up-to-date if AI just placed it
    // (AIPlaceCueBall should have already set cueBall->x, cueBall->y)

    // Determine target ball type for AI (Player 2)
    BallType targetType = player2Info.assignedType;
    bool canTargetAny = false; // Can AI hit any ball (e.g., after break, before assignment)?
    if (targetType == BallType::NONE) {
        // If colors not assigned, AI aims to pocket *something* (usually lowest numbered ball legally)
        // Or, more simply, treat any ball as a potential target to make *a* pocket
        canTargetAny = true; // Simplification: allow targeting any non-8 ball.
        // A better rule is hit lowest numbered ball first on break follow-up.
    }

    // Check if AI needs to shoot the 8-ball
    bool target8Ball = (!canTargetAny && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);


    // Iterate through all potential target balls
    for (auto& potentialTarget : balls) {
        if (potentialTarget.isPocketed || potentialTarget.id == 0) continue; // Skip pocketed and cue ball

        // Check if this ball is a valid target
        bool isValidTarget = false;
        if (target8Ball) {
            isValidTarget = (potentialTarget.id == 8);
        }
        else if (canTargetAny) {
            isValidTarget = (potentialTarget.id != 8); // Can hit any non-8 ball
        }
        else { // Colors assigned, not yet shooting 8-ball
            isValidTarget = (potentialTarget.type == targetType);
        }

        if (!isValidTarget) continue; // Skip if not a valid target for this turn

        // Now, check all pockets for this target ball
        for (int p = 0; p < 6; ++p) {
            AIShotInfo currentShot = EvaluateShot(&potentialTarget, p);
            currentShot.involves8Ball = (potentialTarget.id == 8);

            if (currentShot.possible) {
                // Compare scores to find the best shot
                if (!bestShotOverall.possible || currentShot.score > bestShotOverall.score) {
                    bestShotOverall = currentShot;
                }
            }
        }
    } // End loop through potential target balls

    // If targeting 8-ball and no shot found, or targeting own balls and no shot found,
    // need a safety strategy. Current simple AI just takes best found or taps cue ball.

    return bestShotOverall;
}


// Evaluate a potential shot at a specific target ball towards a specific pocket
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
    AIShotInfo shotInfo;
    shotInfo.possible = false; // Assume not possible initially
    shotInfo.targetBall = targetBall;
    shotInfo.pocketIndex = pocketIndex;

    Ball* cueBall = GetCueBall();
    if (!cueBall || !targetBall) return shotInfo;

    // --- Define local state variables needed for legality checks ---
    BallType aiAssignedType = player2Info.assignedType;
    bool canTargetAny = (aiAssignedType == BallType::NONE); // Can AI hit any ball?
    bool mustTarget8Ball = (!canTargetAny && aiAssignedType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    // ---

    // 1. Calculate Ghost Ball position
    shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

    // 2. Calculate Angle from Cue Ball to Ghost Ball
    float dx = shotInfo.ghostBallPos.x - cueBall->x;
    float dy = shotInfo.ghostBallPos.y - cueBall->y;
    if (fabs(dx) < 0.01f && fabs(dy) < 0.01f) return shotInfo; // Avoid aiming at same spot
    shotInfo.angle = atan2f(dy, dx);

    // Basic angle validity check (optional)
    if (!IsValidAIAimAngle(shotInfo.angle)) {
        // Maybe log this or handle edge cases
    }

    // 3. Check Path: Cue Ball -> Ghost Ball Position
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
        return shotInfo; // Path blocked
    }

    // 4. Check Path: Target Ball -> Pocket
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(targetBall->x, targetBall->y), pocketPositions[pocketIndex], targetBall->id, -1)) {
        return shotInfo; // Path blocked
    }

    // 5. Check First Ball Hit Legality
    float firstHitDistSq = -1.0f;
    // Use D2D1::Point2F() factory function here
    Ball* firstHit = FindFirstHitBall(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.angle, firstHitDistSq);

    if (!firstHit) {
        return shotInfo; // AI aims but doesn't hit anything? Impossible shot.
    }

    // Check if the first ball hit is the intended target ball
    if (firstHit->id != targetBall->id) {
        // Allow hitting slightly off target if it's very close to ghost ball pos
        float ghostDistSq = GetDistanceSq(shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y, firstHit->x, firstHit->y);
        // Allow a tolerance roughly half the ball radius squared
        if (ghostDistSq > (BALL_RADIUS * 0.7f) * (BALL_RADIUS * 0.7f)) {
            // First hit is significantly different from the target point.
            // This shot path leads to hitting the wrong ball first.
            return shotInfo; // Foul or unintended shot
        }
        // If first hit is not target, but very close, allow it for now (might still be foul based on type).
    }

    // Check legality of the *first ball actually hit* based on game rules
    if (!canTargetAny) { // Colors are assigned (or should be)
        if (mustTarget8Ball) { // Must hit 8-ball first
            if (firstHit->id != 8) {
                // return shotInfo; // FOUL - Hitting wrong ball when aiming for 8-ball
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
        }
        else { // Must hit own ball type first
            if (firstHit->type != aiAssignedType && firstHit->id != 8) { // Allow hitting 8-ball if own type blocked? No, standard rules usually require hitting own first.
                // return shotInfo; // FOUL - Hitting opponent ball or 8-ball when shouldn't
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
            else if (firstHit->id == 8) {
                // return shotInfo; // FOUL - Hitting 8-ball when shouldn't
                // Keep shot possible for now
            }
        }
    }
    // (If canTargetAny is true, hitting any ball except 8 first is legal - assuming not scratching)


    // 6. Calculate Score & Power (Difficulty affects this)
    shotInfo.possible = true; // If we got here, the shot is geometrically possible and likely legal enough for AI to consider

    float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
    float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);

    // Simple Score: Shorter shots are better, straighter shots are slightly better.
    float distanceScore = 1000.0f / (1.0f + cueToGhostDist + targetToPocketDist);

    // Angle Score: Calculate cut angle
    // Vector Cue -> Ghost
    float v1x = shotInfo.ghostBallPos.x - cueBall->x;
    float v1y = shotInfo.ghostBallPos.y - cueBall->y;
    // Vector Target -> Pocket
    float v2x = pocketPositions[pocketIndex].x - targetBall->x;
    float v2y = pocketPositions[pocketIndex].y - targetBall->y;
    // Normalize vectors
    float mag1 = sqrtf(v1x * v1x + v1y * v1y);
    float mag2 = sqrtf(v2x * v2x + v2y * v2y);
    float angleScoreFactor = 0.5f; // Default if vectors are zero len
    if (mag1 > 0.1f && mag2 > 0.1f) {
        v1x /= mag1; v1y /= mag1;
        v2x /= mag2; v2y /= mag2;
        // Dot product gives cosine of angle between cue ball path and target ball path
        float dotProduct = v1x * v2x + v1y * v2y;
        // Straighter shot (dot product closer to 1) gets higher score
        angleScoreFactor = (1.0f + dotProduct) / 2.0f; // Map [-1, 1] to [0, 1]
    }
    angleScoreFactor = std::max(0.1f, angleScoreFactor); // Ensure some minimum score factor

    shotInfo.score = distanceScore * angleScoreFactor;

    // Bonus for pocketing 8-ball legally
    if (mustTarget8Ball && targetBall->id == 8) {
        shotInfo.score *= 10.0; // Strongly prefer the winning shot
    }

    // Penalty for difficult cuts? Already partially handled by angleScoreFactor.

    // 7. Calculate Power
    shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

    // 8. Add Inaccuracy based on Difficulty (same as before)
    float angleError = 0.0f;
    float powerErrorFactor = 1.0f;

    switch (aiDifficulty) {
    case EASY:
        angleError = (float)(rand() % 100 - 50) / 1000.0f; // +/- ~3 deg
        powerErrorFactor = 0.8f + (float)(rand() % 40) / 100.0f; // 80-120%
        shotInfo.power *= 0.8f;
        break;
    case MEDIUM:
        angleError = (float)(rand() % 60 - 30) / 1000.0f; // +/- ~1.7 deg
        powerErrorFactor = 0.9f + (float)(rand() % 20) / 100.0f; // 90-110%
        break;
    case HARD:
        angleError = (float)(rand() % 10 - 5) / 1000.0f; // +/- ~0.3 deg
        powerErrorFactor = 0.98f + (float)(rand() % 4) / 100.0f; // 98-102%
        break;
    }
    shotInfo.angle += angleError;
    shotInfo.power *= powerErrorFactor;
    shotInfo.power = std::max(1.0f, std::min(shotInfo.power, MAX_SHOT_POWER)); // Clamp power

    return shotInfo;
}


// Calculates required power (simplified)
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist) {
    // Basic model: Power needed increases with total distance the balls need to travel.
    // Need enough power for cue ball to reach target AND target to reach pocket.
    float totalDist = cueToGhostDist + targetToPocketDist;

    // Map distance to power (needs tuning)
    // Let's say max power is needed for longest possible shot (e.g., corner to corner ~ 1000 units)
    float powerRatio = std::min(1.0f, totalDist / 800.0f); // Normalize based on estimated max distance

    float basePower = MAX_SHOT_POWER * 0.2f; // Minimum power to move balls reliably
    float variablePower = (MAX_SHOT_POWER * 0.8f) * powerRatio; // Scale remaining power range

    // Harder AI could adjust based on desired cue ball travel (more power for draw/follow)
    return std::min(MAX_SHOT_POWER, basePower + variablePower);
}

// Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex) {
    float targetToPocketX = pocketPositions[pocketIndex].x - targetBall->x;
    float targetToPocketY = pocketPositions[pocketIndex].y - targetBall->y;
    float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);

    if (dist < 1.0f) { // Target is basically in the pocket
        // Aim slightly off-center to avoid weird physics? Or directly at center?
        // For simplicity, return a point slightly behind center along the reverse line.
        return D2D1::Point2F(targetBall->x - targetToPocketX * 0.1f, targetBall->y - targetToPocketY * 0.1f);
    }

    // Normalize direction vector from target to pocket
    float nx = targetToPocketX / dist;
    float ny = targetToPocketY / dist;

    // Ghost ball position is diameter distance *behind* the target ball along this line
    float ghostX = targetBall->x - nx * (BALL_RADIUS * 2.0f);
    float ghostY = targetBall->y - ny * (BALL_RADIUS * 2.0f);

    return D2D1::Point2F(ghostX, ghostY);
}

// Checks if line segment is clear of obstructing balls
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2) {
    float dx = end.x - start.x;
    float dy = end.y - start.y;
    float segmentLenSq = dx * dx + dy * dy;

    if (segmentLenSq < 0.01f) return true; // Start and end are same point

    for (const auto& ball : balls) {
        if (ball.isPocketed) continue;
        if (ball.id == ignoredBallId1) continue;
        if (ball.id == ignoredBallId2) continue;

        // Check distance from ball center to the line segment
        float ballToStartX = ball.x - start.x;
        float ballToStartY = ball.y - start.y;

        // Project ball center onto the line defined by the segment
        float dot = (ballToStartX * dx + ballToStartY * dy) / segmentLenSq;

        D2D1_POINT_2F closestPointOnLine;
        if (dot < 0) { // Closest point is start point
            closestPointOnLine = start;
        }
        else if (dot > 1) { // Closest point is end point
            closestPointOnLine = end;
        }
        else { // Closest point is along the segment
            closestPointOnLine = D2D1::Point2F(start.x + dot * dx, start.y + dot * dy);
        }

        // Check if the closest point is within collision distance (ball radius + path radius)
        if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * BALL_RADIUS)) {
            // Consider slightly wider path check? Maybe BALL_RADIUS * 1.1f?
            // if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * 1.1f)*(BALL_RADIUS*1.1f)) {
            return false; // Path is blocked
        }
    }
    return true; // No obstructions found
}

// Finds the first ball hit along a path (simplified)
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq) {
    Ball* hitBall = nullptr;
    hitDistSq = -1.0f; // Initialize hit distance squared
    float minCollisionDistSq = -1.0f;

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    for (auto& ball : balls) {
        if (ball.isPocketed || ball.id == 0) continue; // Skip cue ball and pocketed

        float dx = ball.x - start.x;
        float dy = ball.y - start.y;

        // Project vector from start->ball onto the aim direction vector
        float dot = dx * cosA + dy * sinA;

        if (dot > 0) { // Ball is generally in front
            // Find closest point on aim line to the ball's center
            float closestPointX = start.x + dot * cosA;
            float closestPointY = start.y + dot * sinA;
            float distSq = GetDistanceSq(ball.x, ball.y, closestPointX, closestPointY);

            // Check if the aim line passes within the ball's radius
            if (distSq < (BALL_RADIUS * BALL_RADIUS)) {
                // Calculate distance from start to the collision point on the ball's circumference
                float backDist = sqrtf(std::max(0.f, BALL_RADIUS * BALL_RADIUS - distSq));
                float collisionDist = dot - backDist; // Distance along aim line to collision

                if (collisionDist > 0) { // Ensure collision is in front
                    float collisionDistSq = collisionDist * collisionDist;
                    if (hitBall == nullptr || collisionDistSq < minCollisionDistSq) {
                        minCollisionDistSq = collisionDistSq;
                        hitBall = &ball; // Found a closer hit ball
                    }
                }
            }
        }
    }
    hitDistSq = minCollisionDistSq; // Return distance squared to the first hit
    return hitBall;
}

// Basic check for reasonable AI aim angles (optional)
bool IsValidAIAimAngle(float angle) {
    // Placeholder - could check for NaN or infinity if calculations go wrong
    return isfinite(angle);
}

//midi func = start
void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
    while (isMusicPlaying) {
        MCI_OPEN_PARMS mciOpen = { 0 };
        mciOpen.lpstrDeviceType = TEXT(""sequencer"");
        mciOpen.lpstrElementName = midiPath;

        if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
            midiDeviceID = mciOpen.wDeviceID;

            MCI_PLAY_PARMS mciPlay = { 0 };
            mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

            // Wait for playback to complete
            MCI_STATUS_PARMS mciStatus = { 0 };
            mciStatus.dwItem = MCI_STATUS_MODE;

            do {
                mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                Sleep(100); // adjust as needed
            } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

void StartMidi(HWND hwnd, const TCHAR* midiPath) {
    if (isMusicPlaying) {
        StopMidi();
    }
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}

void StopMidi() {
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) musicThread.join();
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

/*void PlayGameMusic(HWND hwnd) {
    // Stop any existing playback
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) {
            musicThread.join();
        }
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }

    // Get the path of the executable
    TCHAR exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

    // Extract the directory path
    TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
    if (lastBackslash != NULL) {
        *(lastBackslash + 1) = '\0';
    }

    // Construct the full path to the MIDI file
    static TCHAR midiPath[MAX_PATH];
    _tcscpy_s(midiPath, MAX_PATH, exePath);
    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

    // Start the background playback
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}*/
//midi func = end

// --- Drawing Functions ---

void OnPaint() {
    HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

    if (SUCCEEDED(hr)) {
        pRenderTarget->BeginDraw();
        DrawScene(pRenderTarget); // Pass render target
        hr = pRenderTarget->EndDraw();

        if (hr == D2DERR_RECREATE_TARGET) {
            DiscardDeviceResources();
            // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
            // But the timer loop will trigger redraw anyway.
        }
    }
    // If CreateDeviceResources failed, EndDraw might not be called.
    // Consider handling this more robustly if needed.
}

void DrawScene(ID2D1RenderTarget* pRT) {
    if (!pRT) return;

    //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
    // Set background color to #ffffcd (RGB: 255, 255, 205)
    pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
    //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

    DrawTable(pRT, pFactory);
    DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
    DrawBalls(pRT);
    DrawAimingAids(pRT); // Includes cue stick if aiming
    DrawUI(pRT);
    DrawPowerMeter(pRT);
    DrawSpinIndicator(pRT);
    DrawPocketedBallsIndicator(pRT);
    DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

     // Draw Game Over Message
    if (currentGameState == GAME_OVER && pTextFormat) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
        if (pBrush) {
            D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
            pRT->DrawText(
                gameOverMessage.c_str(),
                (UINT32)gameOverMessage.length(),
                pTextFormat, // Use large format maybe?
                &layoutRect,
                pBrush
            );
            SafeRelease(&pBrush);
        }
    }

}

void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
    ID2D1SolidColorBrush* pBrush = nullptr;

    // === Draw Full Orange Frame (Table Border) ===
    ID2D1SolidColorBrush* pFrameBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    if (pFrameBrush) {
        D2D1_RECT_F outerRect = D2D1::RectF(
            TABLE_LEFT - CUSHION_THICKNESS,
            TABLE_TOP - CUSHION_THICKNESS,
            TABLE_RIGHT + CUSHION_THICKNESS,
            TABLE_BOTTOM + CUSHION_THICKNESS
        );
        pRT->FillRectangle(&outerRect, pFrameBrush);
        SafeRelease(&pFrameBrush);
    }

    // Draw Table Bed (Green Felt)
    pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
    if (!pBrush) return;
    D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
    pRT->FillRectangle(&tableRect, pBrush);
    SafeRelease(&pBrush);

    // Draw Cushions (Red Border)
    pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
    if (!pBrush) return;
    // Top Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    // Bottom Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    // Left Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    // Right Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    SafeRelease(&pBrush);


    // Draw Pockets (Black Circles)
    pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
    if (!pBrush) return;
    for (int i = 0; i < 6; ++i) {
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
        pRT->FillEllipse(&ellipse, pBrush);
    }
    SafeRelease(&pBrush);

    // Draw Headstring Line (White)
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    if (!pBrush) return;
    pRT->DrawLine(
        D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
        D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
        pBrush,
        1.0f // Line thickness
    );
    SafeRelease(&pBrush);

    // Draw Semicircle facing West (flat side East)
    // Draw Semicircle facing East (curved side on the East, flat side on the West)
    ID2D1PathGeometry* pGeometry = nullptr;
    HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
    if (SUCCEEDED(hr) && pGeometry)
    {
        ID2D1GeometrySink* pSink = nullptr;
        hr = pGeometry->Open(&pSink);
        if (SUCCEEDED(hr) && pSink)
        {
            float radius = 60.0f; // Radius for the semicircle
            D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

            // For a semicircle facing East (curved side on the East), use the top and bottom points.
            D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

            pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

            D2D1_ARC_SEGMENT arc = {};
            arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
            arc.size = D2D1::SizeF(radius, radius);
            arc.rotationAngle = 0.0f;
            // Use the correct identifier with the extra underscore:
            arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
            arc.arcSize = D2D1_ARC_SIZE_SMALL;

            pSink->AddArc(&arc);
            pSink->EndFigure(D2D1_FIGURE_END_OPEN);
            pSink->Close();
            SafeRelease(&pSink);

            ID2D1SolidColorBrush* pArcBrush = nullptr;
            //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
            pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
            if (pArcBrush)
            {
                pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                SafeRelease(&pArcBrush);
            }
        }
        SafeRelease(&pGeometry);
    }




}


void DrawBalls(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

    pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

    if (!pBrush || !pStripeBrush) {
        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
        return;
    }


    for (size_t i = 0; i < balls.size(); ++i) {
        const Ball& b = balls[i];
        if (!b.isPocketed) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            // Set main ball color
            pBrush->SetColor(b.color);
            pRT->FillEllipse(&ellipse, pBrush);

            // Draw Stripe if applicable
            if (b.type == BallType::STRIPE) {
                // Draw a white band across the middle (simplified stripe)
                D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                // Need to clip this rectangle to the ellipse bounds - complex!
                // Alternative: Draw two colored arcs leaving a white band.
                // Simplest: Draw a white circle inside, slightly smaller.
                D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                pBrush->SetColor(b.color); // Set back to stripe color
                pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                // Let's try drawing a thick white line across
                // This doesn't look great. Just drawing solid red for stripes for now.
            }

            // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
            // if (b.id != 0 && pTextFormat) {
            //     std::wstring numStr = std::to_wstring(b.id);
            //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
            //     ID2D1SolidColorBrush* pNumBrush = nullptr;
            //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
            //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
            //     // Create a smaller text format...
            //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
            //     SafeRelease(&pNumBrush);
            // }
        }
    }

    SafeRelease(&pBrush);
    SafeRelease(&pStripeBrush);
}


void DrawAimingAids(ID2D1RenderTarget* pRT) {
    // Condition check at start (Unchanged)
    //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
        //currentGameState != BREAKING && currentGameState != AIMING)
    //{
        //return;
    //}
        // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
    // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
    bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
        (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == BREAKING || currentGameState == AIMING);
    // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
    // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
        // NEW Condition: AI is displaying its aim
    bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
        return;
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    ID2D1StrokeStyle* pDashedStyle = nullptr;
    ID2D1SolidColorBrush* pCueBrush = nullptr;
    ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

    // Ensure render target is valid
    if (!pRT) return;

    // Create Brushes and Styles (check for failures)
    HRESULT hr;
    hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
    if FAILED(hr) { SafeRelease(&pBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
    // Create reflection brush (e.g., lighter shade or different color)
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
    // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
    D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
    ID2D1SolidColorBrush* pCyanBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
    if (FAILED(hr)) {
        SafeRelease(&pCyanBrush);
        // handle error if needed
    }
    // Create a Purple brush for primary and secondary lines
    D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
    ID2D1SolidColorBrush* pPurpleBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
    if (FAILED(hr)) {
        SafeRelease(&pPurpleBrush);
        // handle error if needed
    }

    if (pFactory) {
        D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
        strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
        hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        if FAILED(hr) { pDashedStyle = nullptr; }
    }


    // --- Cue Stick Drawing (Unchanged from previous fix) ---
    const float baseStickLength = 150.0f;
    const float baseStickThickness = 4.0f;
    float stickLength = baseStickLength * 1.4f;
    float stickThickness = baseStickThickness * 1.5f;
    float stickAngle = cueAngle + PI;
    float powerOffset = 0.0f;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
    if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
        powerOffset = shotPower * 5.0f;
    }
    D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
    D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
    pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


    // --- Projection Line Calculation ---
    float cosA = cosf(cueAngle);
    float sinA = sinf(cueAngle);
    float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
    D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
    D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

    // Find the first ball hit by the aiming ray
    Ball* hitBall = nullptr;
    float firstHitDistSq = -1.0f;
    D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
    D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

    hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
    if (hitBall) {
        // Calculate the point on the target ball's circumference
        float collisionDist = sqrtf(firstHitDistSq);
        ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
        // Calculate ghost ball position for this specific hit (used for projection consistency)
        ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
    }

    // Find the first rail hit by the aiming ray
    D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
    float minRailDistSq = rayLength * rayLength;
    int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

    // Define table edge segments for intersection checks
    D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
    D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
    D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
    D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

    D2D1_POINT_2F currentIntersection;

    // Check Left Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
    }
    // Check Right Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
    }
    // Check Top Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
    }
    // Check Bottom Rail
    if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
    }


    // --- Determine final aim line end point ---
    D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
    bool aimingAtRail = true;

    if (hitBall && firstHitDistSq < minRailDistSq) {
        // Ball collision is closer than rail collision
        finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
        aimingAtRail = false;
    }

    // --- Draw Primary Aiming Line ---
    pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

    // --- Draw Target Circle/Indicator ---
    D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
    pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

    // --- Draw Projection/Reflection Lines ---
    if (!aimingAtRail && hitBall) {
        // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
        D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
        pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // Calculate target ball projection based on impact line (cue collision point -> target center)
        float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
        // Clamp angle calculation if distance is tiny
        if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
            targetProjectionAngle = cueAngle; // Fallback if overlapping
        }

        D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
        D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
            hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
            hitBall->y + sinf(targetProjectionAngle) * 50.0f
        );
        // Draw solid line for target projection
        //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

    //new code start

                // Dual trajectory with edge-aware contact simulation
        D2D1_POINT_2F dir = {
            targetProjectionEnd.x - targetStartPoint.x,
            targetProjectionEnd.y - targetStartPoint.y
        };
        float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
        dir.x /= dirLen;
        dir.y /= dirLen;

        D2D1_POINT_2F perp = { -dir.y, dir.x };

        // Approximate cue ball center by reversing from tip
        D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
            targetStartPoint.x - dir.x * BALL_RADIUS,
            targetStartPoint.y - dir.y * BALL_RADIUS
        };

        // REAL contact-ball center - use your physics object's center:
        // (replace 'objectBallPos' with whatever you actually call it)
        // (targetStartPoint is already hitBall->x, hitBall->y)
        D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
        //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

       // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
       // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
       // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
       // and 'perp' is perpendicular to 'dir'.
       // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
        /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
            (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
            /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                (targetStartPoint.y - cueBallCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);*/

            // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
        D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

        // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
        float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
            (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
        float absOffset = fabsf(offset);
        float side = (offset >= 0 ? 1.0f : -1.0f);


        // Actual contact point on target ball edge
        D2D1_POINT_2F contactPoint = {
        contactBallCenter.x + perp.x * BALL_RADIUS * side,
        contactBallCenter.y + perp.y * BALL_RADIUS * side
        };

        // Tangent (cut shot) path from contact point
            // Tangent (cut shot) path: from contact point to contact ball center
        D2D1_POINT_2F objectBallDir = {
            contactBallCenter.x - contactPoint.x,
            contactBallCenter.y - contactPoint.y
        };
        float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
        if (oLen != 0.0f) {
            objectBallDir.x /= oLen;
            objectBallDir.y /= oLen;
        }

        const float PRIMARY_LEN = 150.0f; //default=150.0f
        const float SECONDARY_LEN = 150.0f; //default=150.0f
        const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

        D2D1_POINT_2F primaryEnd = {
            targetStartPoint.x + dir.x * PRIMARY_LEN,
            targetStartPoint.y + dir.y * PRIMARY_LEN
        };

        // Secondary line starts from the contact ball's center
        D2D1_POINT_2F secondaryStart = contactBallCenter;
        D2D1_POINT_2F secondaryEnd = {
            secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
            secondaryStart.y + objectBallDir.y * SECONDARY_LEN
        };

        if (absOffset < STRAIGHT_EPSILON)  // straight shot?
        {
            // Straight: secondary behind primary
                    // secondary behind primary {pDashedStyle param at end}
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        else
        {
            // Cut shot: both visible
                    // both visible for cut shot
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        // End improved trajectory logic

    //new code end

        // -- Cue Ball Path after collision (Optional, requires physics) --
        // Very simplified: Assume cue deflects, angle depends on cut angle.
        // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
        // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
        // D2D1_POINT_2F cueProjectionEnd = ...
        // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Accuracy Comment ---
        // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
        // or shots with spin, is limited by the simplified physics model. Real pool physics involves
        // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
        // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

    }
    else if (aimingAtRail && hitRailIndex != -1) {
        // Aiming at a rail: Draw reflection line
        float reflectAngle = cueAngle;
        // Reflect angle based on which rail was hit
        if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
            reflectAngle = PI - cueAngle; // Reflect horizontal component
        }
        else { // Top or Bottom rail
            reflectAngle = -cueAngle; // Reflect vertical component
        }
        // Normalize angle if needed (atan2 usually handles this)
        while (reflectAngle > PI) reflectAngle -= 2 * PI;
        while (reflectAngle <= -PI) reflectAngle += 2 * PI;


        float reflectionLength = 60.0f; // Length of the reflection line
        D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
            finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
            finalLineEnd.y + sinf(reflectAngle) * reflectionLength
        );

        // Draw the reflection line (e.g., using a different color/style)
        pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
    }

    // Release resources
    SafeRelease(&pBrush);
    SafeRelease(&pGhostBrush);
    SafeRelease(&pCueBrush);
    SafeRelease(&pReflectBrush); // Release new brush
    SafeRelease(&pCyanBrush);
    SafeRelease(&pPurpleBrush);
    SafeRelease(&pDashedStyle);
}


void DrawUI(ID2D1RenderTarget* pRT) {
    if (!pTextFormat || !pLargeTextFormat) return;

    ID2D1SolidColorBrush* pBrush = nullptr;
    pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
    if (!pBrush) return;

    // --- Player Info Area (Top Left/Right) --- (Unchanged)
    float uiTop = TABLE_TOP - 80;
    float uiHeight = 60;
    float p1Left = TABLE_LEFT;
    float p1Width = 150;
    float p2Left = TABLE_RIGHT - p1Width;
    D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
    D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

    // Player 1 Info Text (Unchanged)
    std::wostringstream oss1;
    oss1 << player1Info.name.c_str() << L""\n"";
    if (player1Info.assignedType != BallType::NONE) {
        oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss1 << L""(Undecided)"";
    }
    pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
    // Draw Player 1 Side Ball
    if (player1Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player1Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // Player 2 Info Text (Unchanged)
    std::wostringstream oss2;
    oss2 << player2Info.name.c_str() << L""\n"";
    if (player2Info.assignedType != BallType::NONE) {
        oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss2 << L""(Undecided)"";
    }
    pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
    // Draw Player 2 Side Ball
    if (player2Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player2Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
        arrowBackX = playerBox.left - 25.0f;
        arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

        float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
        float notchWidth = 10.0f;

        float cx = arrowBackX;
        float cy = arrowCenterY;

        // Define triangle + rectangle tail shape
        D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
        D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
        D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

        // Rectangle coordinates for the tail portion:
        D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
        D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
        D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
        D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseTop);
                pSink->AddLine(r2); // transition from triangle into rectangle
                pSink->AddLine(r1);
                pSink->AddLine(r4);
                pSink->AddLine(r3);
                pSink->AddLine(baseBot);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }


        SafeRelease(&pArrowBrush);
    }

    //original
/*
    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        if (currentPlayer == 1) {
arrowBackX = p1Rect.left - 25.0f; // Position left of the box
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
            // Define points for right-pointing arrow
            //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
            //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
            //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
            // Enhanced arrow with base rectangle intersection
    float notchDepth = 6.0f; // Depth of square base ""stem""
    float notchWidth = 4.0f; // Thickness of square part

    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
    D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
    D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
        }


        //==================else player 2
        else { // Player 2
         // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
         // Let's keep it consistent: Arrow left of the active player's box, pointing right.
// Let's keep it consistent: Arrow left of the active player's box, pointing right.
arrowBackX = p2Rect.left - 25.0f; // Position left of the box
arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
// Define points for right-pointing arrow
D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

ID2D1PathGeometry* pPath = nullptr;
if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
    ID2D1GeometrySink* pSink = nullptr;
    if (SUCCEEDED(pPath->Open(&pSink))) {
        pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
        pSink->AddLine(pt2);
        pSink->AddLine(pt3);
        pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
        pSink->Close();
        SafeRelease(&pSink);
        pRT->FillGeometry(pPath, pArrowBrush);
    }
    SafeRelease(&pPath);
}
        }
        */

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
    if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
        ID2D1SolidColorBrush* pFoulBrush = nullptr;
        pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
        if (pFoulBrush && pLargeTextFormat) {
            // Calculate Rect for bottom-middle area
            float foulWidth = 200.0f; // Adjust width as needed
            float foulHeight = 60.0f;
            float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
            // Position below the pocketed balls bar
            float foulTop = pocketedBallsBarRect.bottom + 10.0f;
            D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

            // --- Set text alignment to center for foul text ---
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

            // --- Restore default alignment for large text if needed elsewhere ---
            // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            SafeRelease(&pFoulBrush);
        }
    }

    // --- Draw ""Choose Pocket"" Message ---
    if (!pocketCallMessage.empty() && (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2)) {
        ID2D1SolidColorBrush* pMsgBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pMsgBrush);
        if (pMsgBrush && pTextFormat) {
            float msgWidth = 450.0f;
            float msgHeight = 30.0f;
            float msgLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (msgWidth / 2.0f);
            float msgTop = pocketedBallsBarRect.bottom + 10.0f;
            if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) msgTop += 30.0f;

            D2D1_RECT_F msgRect = D2D1::RectF(msgLeft, msgTop, msgLeft + msgWidth, msgTop + msgHeight);

            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(pocketCallMessage.c_str(), (UINT32)pocketCallMessage.length(), pTextFormat, &msgRect, pMsgBrush);
            SafeRelease(&pMsgBrush);
        }
    }


    // Show AI Thinking State (Unchanged from previous step)
    if (currentGameState == AI_THINKING && pTextFormat) {
        ID2D1SolidColorBrush* pThinkingBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
        if (pThinkingBrush) {
            D2D1_RECT_F thinkingRect = p2Rect;
            thinkingRect.top += 20; // Offset within P2 box
            // Ensure default text alignment for this
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
            SafeRelease(&pThinkingBrush);
        }
    }

    SafeRelease(&pBrush);

    // --- Draw CHEAT MODE label if active ---
    if (cheatModeEnabled) {
        ID2D1SolidColorBrush* pCheatBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
        if (pCheatBrush && pTextFormat) {
            D2D1_RECT_F cheatTextRect = D2D1::RectF(
                TABLE_LEFT + 10.0f,
                TABLE_TOP + 10.0f,
                TABLE_LEFT + 200.0f,
                TABLE_TOP + 40.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
        }
        SafeRelease(&pCheatBrush);
    }
}

void DrawPowerMeter(ID2D1RenderTarget* pRT) {
    // Draw Border
    ID2D1SolidColorBrush* pBorderBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
    if (!pBorderBrush) return;
    pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
    SafeRelease(&pBorderBrush);

    // Create Gradient Fill
    ID2D1GradientStopCollection* pGradientStops = nullptr;
    ID2D1LinearGradientBrush* pGradientBrush = nullptr;
    D2D1_GRADIENT_STOP gradientStops[4];
    gradientStops[0].position = 0.0f;
    gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
    gradientStops[1].position = 0.45f;
    gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
    gradientStops[2].position = 0.7f;
    gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
    gradientStops[3].position = 1.0f;
    gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

    pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
    if (pGradientStops) {
        D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
        props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
        props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
        pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
        SafeRelease(&pGradientStops);
    }

    // Calculate Fill Height
    float fillRatio = 0;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Determine if power meter should reflect shot power (human aiming or AI preparing)
    bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
    // NEW Condition: AI is displaying its aim, so show its chosen power
    bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
        fillRatio = shotPower / MAX_SHOT_POWER;
    }
    float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
    D2D1_RECT_F fillRect = D2D1::RectF(
        powerMeterRect.left,
        powerMeterRect.bottom - fillHeight,
        powerMeterRect.right,
        powerMeterRect.bottom
    );

    if (pGradientBrush) {
        pRT->FillRectangle(&fillRect, pGradientBrush);
        SafeRelease(&pGradientBrush);
    }

    // Draw scale notches
    ID2D1SolidColorBrush* pNotchBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
    if (pNotchBrush) {
        for (int i = 0; i <= 8; ++i) {
            float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
            pRT->DrawLine(
                D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                pNotchBrush,
                1.5f
            );
        }
        SafeRelease(&pNotchBrush);
    }

    // Draw ""Power"" Label Below Meter
    if (pTextFormat) {
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
        if (pTextBrush) {
            D2D1_RECT_F textRect = D2D1::RectF(
                powerMeterRect.left - 20.0f,
                powerMeterRect.bottom + 8.0f,
                powerMeterRect.right + 20.0f,
                powerMeterRect.bottom + 38.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
            SafeRelease(&pTextBrush);
        }
    }

    // Draw Glow Effect if fully charged or fading out
    static float glowPulse = 0.0f;
    static bool glowIncreasing = true;
    static float glowFadeOut = 0.0f; // NEW: tracks fading out

    if (shotPower >= MAX_SHOT_POWER * 0.99f) {
        // While fully charged, keep pulsing normally
        if (glowIncreasing) {
            glowPulse += 0.02f;
            if (glowPulse >= 1.0f) glowIncreasing = false;
        }
        else {
            glowPulse -= 0.02f;
            if (glowPulse <= 0.0f) glowIncreasing = true;
        }
        glowFadeOut = 1.0f; // Reset fade out to full
    }
    else if (glowFadeOut > 0.0f) {
        // If shot fired, gradually fade out
        glowFadeOut -= 0.02f;
        if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
    }

    if (glowFadeOut > 0.0f) {
        ID2D1SolidColorBrush* pGlowBrush = nullptr;
        float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
        pRT->CreateSolidColorBrush(
            D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
            &pGlowBrush
        );
        if (pGlowBrush) {
            float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
            float glowCenterY = powerMeterRect.top;
            D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                12.0f + 3.0f * glowPulse,
                6.0f + 2.0f * glowPulse
            );
            pRT->FillEllipse(&glowEllipse, pGlowBrush);
            SafeRelease(&pGlowBrush);
        }
    }
}

void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pWhiteBrush = nullptr;
    ID2D1SolidColorBrush* pRedBrush = nullptr;

    pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
    pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

    if (!pWhiteBrush || !pRedBrush) {
        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
        return;
    }

    // Draw White Ball Background
    D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
    pRT->FillEllipse(&bgEllipse, pWhiteBrush);
    pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


    // Draw Red Dot for Spin Position
    float dotRadius = 4.0f;
    float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
    float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
    D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
    pRT->FillEllipse(&dotEllipse, pRedBrush);

    SafeRelease(&pWhiteBrush);
    SafeRelease(&pRedBrush);
}


void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBgBrush = nullptr;
    ID2D1SolidColorBrush* pBallBrush = nullptr;

    // Ensure render target is valid before proceeding
    if (!pRT) return;

    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
    if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
    if (FAILED(hr)) {
        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
        return; // Exit if brush creation fails
    }

    // Draw the background bar (rounded rect)
    D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
    float baseAlpha = 0.8f;
    float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
    float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
    pBgBrush->SetOpacity(finalAlpha);
    pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
    pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

    // --- Draw small circles for pocketed balls inside the bar ---

    // Calculate dimensions based on the bar's height for better scaling
    float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
    float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
    float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
    float padding = spacing * 0.75f; // Add padding from the edges
    float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

    // Starting X positions with padding
    float currentX_P1 = pocketedBallsBarRect.left + padding;
    float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

    int p1DrawnCount = 0;
    int p2DrawnCount = 0;
    const int maxBallsToShow = 7; // Max balls per player in the bar

    for (const auto& b : balls) {
        if (b.isPocketed) {
            // Skip cue ball and 8-ball in this indicator
            if (b.id == 0 || b.id == 8) continue;

            bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
            bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

            if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P1 balls from left to right
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p1DrawnCount++;
            }
            else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P2 balls from right to left
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p2DrawnCount++;
            }
            // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
            // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
        }
    }

    SafeRelease(&pBgBrush);
    SafeRelease(&pBallBrush);
}

void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
    if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
        return; // Only show when placing/dragging
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

    if (pGhostBrush) {
        D2D1_POINT_2F drawPos;
        if (isDraggingCueBall) {
            drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
        }
        else {
            // If not dragging but in placement state, show at current ball pos
            drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
        }

        // Check if the placement is valid before drawing differently?
        bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
        bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

        if (!isValid) {
            // Maybe draw red outline if invalid placement?
            pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
        }


        D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
        pRT->FillEllipse(&ghostEllipse, pGhostBrush);
        pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

        SafeRelease(&pGhostBrush);
    }
}

void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
    int pocketToIndicate = -1;
    // A human player is actively choosing if they are in the CHOOSING_POCKET state.
    bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

    if (isHumanChoosing) {
        // When choosing, show the currently selected pocket (which has a default).
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }
    else if (IsPlayerOnEightBall(currentPlayer)) {
        // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }

    if (pocketToIndicate < 0 || pocketToIndicate > 5) {
        return; // Don't draw if no pocket is selected or relevant.
    }

    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
    if (!pArrowBrush) return;

    // ... The rest of your arrow drawing geometry logic remains exactly the same ...
    // (No changes needed to the points/path drawing, only the logic above)
    D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
    float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
    float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
    float arrowShaftWidth = arrowHeadSize * 0.4f;
    float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
    D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

    if (targetPocketCenter.y == TABLE_TOP) {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
    }
    else {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
    }

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
            pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
    SafeRelease(&pArrowBrush);
}"
7JrtywSP,Gemini's 2nd Attempt Out Of 3 - Still Not There Yet !,alien_fx_fiend,C++,Friday 27th of June 2025 11:04:06 AM CDT,"#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#include <d2d1.h>
#include <dwrite.h>
#include <fstream> // For file I/O
#include <iostream> // For some basic I/O, though not strictly necessary for just file ops
#include <vector>
#include <cmath>
#include <string>
#include <sstream> // Required for wostringstream
#include <algorithm> // Required for std::max, std::min
#include <ctime>    // Required for srand, time
#include <cstdlib> // Required for srand, rand (often included by others, but good practice)
#include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
#include <mmsystem.h> // For PlaySound
#include <tchar.h> //midi func
#include <thread>
#include <atomic>
#include ""resource.h""

#pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""dwrite.lib"")
#pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

// --- Constants ---
const float PI = 3.1415926535f;
const float BALL_RADIUS = 10.0f;
const float TABLE_LEFT = 100.0f;
const float TABLE_TOP = 100.0f;
const float TABLE_WIDTH = 700.0f;
const float TABLE_HEIGHT = 350.0f;
const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
const float CUSHION_THICKNESS = 20.0f;
const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
const float MAX_SHOT_POWER = 15.0f;
const float FRICTION = 0.985f; // Friction factor per frame
const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
const UINT ID_TIMER = 1;
const int TARGET_FPS = 60; // Target frames per second for timer

// --- Enums ---
// --- MODIFIED/NEW Enums ---
enum GameState {
    SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
    PRE_BREAK_PLACEMENT,// Player placing cue ball for break
    BREAKING,           // Player is aiming/shooting the break shot
    CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
    CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
    AIMING,             // Player is aiming
    AI_THINKING,        // NEW: AI is calculating its move
    SHOT_IN_PROGRESS,   // Balls are moving
    ASSIGNING_BALLS,    // Turn after break where ball types are assigned
    PLAYER1_TURN,
    PLAYER2_TURN,
    BALL_IN_HAND_P1,
    BALL_IN_HAND_P2,
    GAME_OVER
};

enum BallType {
    NONE,
    SOLID,  // Yellow (1-7)
    STRIPE, // Red (9-15)
    EIGHT_BALL, // Black (8)
    CUE_BALL // White (0)
};

// NEW Enums for Game Mode and AI Difficulty
enum GameMode {
    HUMAN_VS_HUMAN,
    HUMAN_VS_AI
};

enum AIDifficulty {
    EASY,
    MEDIUM,
    HARD
};

enum OpeningBreakMode {
    CPU_BREAK,
    P1_BREAK,
    FLIP_COIN_BREAK
};

// --- Structs ---
struct Ball {
    int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
    BallType type;
    float x, y;
    float vx, vy;
    D2D1_COLOR_F color;
    bool isPocketed;
};

struct PlayerInfo {
    BallType assignedType;
    int ballsPocketedCount;
    std::wstring name;
};

// --- Global Variables ---

// Direct2D & DirectWrite
ID2D1Factory* pFactory = nullptr;
//ID2D1Factory* g_pD2DFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

// Game State
HWND hwndMain = nullptr;
GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
std::vector<Ball> balls;
int currentPlayer = 1; // 1 or 2
PlayerInfo player1Info = { BallType::NONE, 0, L""Player 1"" };
PlayerInfo player2Info = { BallType::NONE, 0, L""CPU"" }; // Default P2 name
bool foulCommitted = false;
std::wstring gameOverMessage = L"""";
bool firstBallPocketedAfterBreak = false;
std::vector<int> pocketedThisTurn;
// --- NEW: 8-Ball Pocket Call Globals ---
int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""

// --- NEW: Foul Tracking Globals ---
int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
// --- End New Foul Tracking Globals ---

// NEW Game Mode/AI Globals
GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
// bool aiIsThinking = false;       // Replaced by AI_THINKING game state
// NEW: Flag to indicate if the current shot is the opening break of the game
bool isOpeningBreakShot = false;

// NEW: For AI shot planning and visualization
struct AIPlannedShot {
    float angle;
    float power;
    float spinX;
    float spinY;
    bool isValid; // Is there a valid shot planned?
};
AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

// Input & Aiming
POINT ptMouse = { 0, 0 };
bool isAiming = false;
bool isDraggingCueBall = false;
// --- ENSURE THIS LINE EXISTS HERE ---
bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
// --- End Ensure ---
bool isSettingEnglish = false;
D2D1_POINT_2F aimStartPoint = { 0, 0 };
float cueAngle = 0.0f;
float shotPower = 0.0f;
float cueSpinX = 0.0f; // Range -1 to 1
float cueSpinY = 0.0f; // Range -1 to 1
float pocketFlashTimer = 0.0f;
bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
int draggingBallId = -1;
bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
MCIDEVICEID midiDeviceID = 0; //midi func
std::atomic<bool> isMusicPlaying(false); //midi func
std::thread musicThread; //midi func
void StartMidi(HWND hwnd, const TCHAR* midiPath);
void StopMidi();

// UI Element Positions
D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

// Corrected Pocket Center Positions (aligned with table corners/edges)
const D2D1_POINT_2F pocketPositions[6] = {
    {TABLE_LEFT, TABLE_TOP},                           // Top-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
    {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
    {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
    {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
};

// Colors
const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
//const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
//const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Yellow); // Solids = Yellow
const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::Red);   // Stripes = Red
const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
//const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

// --- Forward Declarations ---
HRESULT CreateDeviceResources();
void DiscardDeviceResources();
void OnPaint();
void OnResize(UINT width, UINT height);
void InitGame();
void GameUpdate();
void UpdatePhysics();
void CheckCollisions();
bool CheckPockets(); // Returns true if any ball was pocketed
void ProcessShotResults();
void ApplyShot(float power, float angle, float spinX, float spinY);
void RespawnCueBall(bool behindHeadstring);
bool AreBallsMoving();
void SwitchTurns();
void AssignPlayerBallTypes(BallType firstPocketedType);
void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
Ball* GetBallById(int id);
Ball* GetCueBall();
//void PlayGameMusic(HWND hwnd); //midi func
void AIBreakShot();

// Drawing Functions
void DrawScene(ID2D1RenderTarget* pRT);
void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
void DrawBalls(ID2D1RenderTarget* pRT);
void DrawCueStick(ID2D1RenderTarget* pRT);
void DrawAimingAids(ID2D1RenderTarget* pRT);
void DrawUI(ID2D1RenderTarget* pRT);
void DrawPowerMeter(ID2D1RenderTarget* pRT);
void DrawSpinIndicator(ID2D1RenderTarget* pRT);
void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
// NEW
void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

// Helper Functions
float GetDistance(float x1, float y1, float x2, float y2);
float GetDistanceSq(float x1, float y1, float x2, float y2);
bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
template <typename T> void SafeRelease(T** ppT);
// --- NEW HELPER FORWARD DECLARATIONS ---
bool IsPlayerOnEightBall(int player);
void CheckAndTransitionToPocketChoice(int playerID);
// --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
// --- End Forward Declaration ---
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

// --- NEW Forward Declarations ---

// AI Related
struct AIShotInfo; // Define below
void TriggerAIMove();
void AIMakeDecision();
void AIPlaceCueBall();
AIShotInfo AIFindBestShot();
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
bool IsValidAIAimAngle(float angle); // Basic check

// Dialog Related
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ShowNewGameDialog(HINSTANCE hInstance);
void LoadSettings(); // For deserialization
void SaveSettings(); // For serialization
const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

// --- Forward Declaration for Window Procedure --- <<< Add this line HERE
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// --- NEW Struct for AI Shot Evaluation ---
struct AIShotInfo {
    bool possible = false;          // Is this shot considered viable?
    Ball* targetBall = nullptr;     // Which ball to hit
    int pocketIndex = -1;           // Which pocket to aim for (0-5)
    D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
    float angle = 0.0f;             // Calculated shot angle
    float power = 0.0f;             // Calculated shot power
    float score = -1.0f;            // Score for this shot (higher is better)
    bool involves8Ball = false;     // Is the target the 8-ball?
};

/*
table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
*/

// --- NEW Settings Serialization Functions ---
void SaveSettings() {
    std::ofstream outFile(SETTINGS_FILE_NAME);
    if (outFile.is_open()) {
        outFile << static_cast<int>(gameMode) << std::endl;
        outFile << static_cast<int>(aiDifficulty) << std::endl;
        outFile << static_cast<int>(openingBreakMode) << std::endl;
        outFile.close();
    }
    // else: Handle error, e.g., log or silently fail
}

void LoadSettings() {
    std::ifstream inFile(SETTINGS_FILE_NAME);
    if (inFile.is_open()) {
        int gm, aid, obm;
        if (inFile >> gm) {
            gameMode = static_cast<GameMode>(gm);
        }
        if (inFile >> aid) {
            aiDifficulty = static_cast<AIDifficulty>(aid);
        }
        if (inFile >> obm) {
            openingBreakMode = static_cast<OpeningBreakMode>(obm);
        }
        inFile.close();

        // Validate loaded settings (optional, but good practice)
        if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
        if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
        if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
    }
    // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
}
// --- End Settings Serialization Functions ---

// --- NEW Dialog Procedure ---
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_INITDIALOG:
    {
        // --- ACTION 4: Center Dialog Box ---
// Optional: Force centering if default isn't working
        RECT rcDlg, rcOwner, rcScreen;
        HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
        if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

        GetWindowRect(hwndOwner, &rcOwner);
        GetWindowRect(hDlg, &rcDlg);
        CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

        // Offset the owner rect relative to the screen if it's not the desktop
        if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
            OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
        }


        // Calculate centered position
        int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
        int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

        // Ensure it stays within screen bounds (optional safety)
        x = std::max(static_cast<int>(rcScreen.left), x);
        y = std::max(static_cast<int>(rcScreen.top), y);
        if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
            x = rcScreen.right - (rcDlg.right - rcDlg.left);
        if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
            y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


        // Set the dialog position
        SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

        // --- End Centering Code ---

        // Set initial state based on current global settings (or defaults)
        CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

        CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
            (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

        // Enable/Disable AI group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
        // Set initial state for Opening Break Mode
        CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
            (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
        // Enable/Disable Opening Break group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
    }
    return (INT_PTR)TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_RADIO_2P:
        case IDC_RADIO_CPU:
        {
            bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
            // Enable/Disable AI group controls based on selection
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
            // Also enable/disable Opening Break Mode group
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
        }
        return (INT_PTR)TRUE;

        case IDOK:
            // Retrieve selected options and store in global variables
            if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                gameMode = HUMAN_VS_AI;
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
            }
            else {
                gameMode = HUMAN_VS_HUMAN;
                // openingBreakMode doesn't apply to HvsH, can leave as is or reset
            }
            SaveSettings(); // Save settings when OK is pressed
            EndDialog(hDlg, IDOK); // Close dialog, return IDOK
            return (INT_PTR)TRUE;

        case IDCANCEL: // Handle Cancel or closing the dialog
            // Optionally, could reload settings here if you want cancel to revert to previously saved state
            EndDialog(hDlg, IDCANCEL);
            return (INT_PTR)TRUE;
        }
        break; // End WM_COMMAND
    }
    return (INT_PTR)FALSE; // Default processing
}

// --- NEW Helper to Show Dialog ---
void ShowNewGameDialog(HINSTANCE hInstance) {
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
        // User clicked Start, reset game with new settings
        isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""CPU (Easy)""; break;
            case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
            case HARD: player2Info.name = L""CPU (Hard)""; break;
            }
        }
        else {
            player2Info.name = L""Player 2"";
        }
        // Update window title
        std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
        SetWindowText(hwndMain, windowTitle.c_str());

        InitGame(); // Re-initialize game logic & board
        InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
    }
    else {
        // User cancelled dialog - maybe just resume game? Or exit?
        // For simplicity, we do nothing, game continues as it was.
        // To exit on cancel from F2, would need more complex state management.
    }
}

// --- NEW Reset Game Function ---
void ResetGame(HINSTANCE hInstance) {
    // Call the helper function to show the dialog and re-init if OK clicked
    ShowNewGameDialog(hInstance);
}

// --- WinMain ---
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    if (FAILED(CoInitialize(NULL))) {
        MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
        return -1;
    }

    // --- NEW: Load settings at startup ---
    LoadSettings();

    // --- NEW: Show configuration dialog FIRST ---
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
        // User cancelled the dialog
        CoUninitialize();
        return 0; // Exit gracefully if dialog cancelled
    }
    // Global gameMode and aiDifficulty are now set by the DialogProc

    // Set AI flag based on game mode
    isPlayer2AI = (gameMode == HUMAN_VS_AI);
    if (isPlayer2AI) {
        switch (aiDifficulty) {
        case EASY: player2Info.name = L""CPU (Easy)""; break;
        case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
        case HARD: player2Info.name = L""CPU (Hard)""; break;
        }
    }
    else {
        player2Info.name = L""Player 2"";
    }
    // --- End of Dialog Logic ---


    WNDCLASS wc = { };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L""Direct2D_8BallPool"";
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // --- ACTION 4: Calculate Centered Window Position ---
    const int WINDOW_WIDTH = 1000; // Define desired width
    const int WINDOW_HEIGHT = 700; // Define desired height
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WINDOW_WIDTH) / 2;
    int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

    // --- Change Window Title based on mode ---
    std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
    if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
    else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

    hwndMain = CreateWindowEx(
        0, L""Direct2D_8BallPool"", windowTitle.c_str(), dwStyle,
        windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL, NULL, hInstance, NULL
    );

    if (!hwndMain) {
        MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // Initialize Direct2D Resources AFTER window creation
    if (FAILED(CreateDeviceResources())) {
        MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    InitGame(); // Initialize game state AFTER resources are ready & mode is set
    Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
    StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
    //PlayGameMusic(hwndMain); //midi func

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
        MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    MSG msg = { };
    // --- Modified Main Loop ---
    // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
    // or gets reset to it via F2. The main loop runs normally once game starts.
    while (GetMessage(&msg, NULL, 0, 0)) {
        // We might need modeless dialog handling here if F2 shows dialog
        // while window is active, but DialogBoxParam is modal.
        // Let's assume F2 hides main window, shows dialog, then restarts game loop.
        // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    KillTimer(hwndMain, ID_TIMER);
    DiscardDeviceResources();
    SaveSettings(); // Save settings on exit
    CoUninitialize();

    return (int)msg.wParam;
}

// --- WndProc ---
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // Declare cueBall pointer once at the top, used in multiple cases
    // For clarity, often better to declare within each case where needed.
    Ball* cueBall = nullptr; // Initialize to nullptr
    switch (msg) {
    case WM_CREATE:
        // Resources are now created in WinMain after CreateWindowEx
        return 0;

    case WM_PAINT:
        OnPaint();
        // Validate the entire window region after painting
        ValidateRect(hwnd, NULL);
        return 0;

    case WM_SIZE: {
        UINT width = LOWORD(lParam);
        UINT height = HIWORD(lParam);
        OnResize(width, height);
        return 0;
    }

    case WM_TIMER:
        if (wParam == ID_TIMER) {
            GameUpdate(); // Update game logic and physics
            InvalidateRect(hwnd, NULL, FALSE); // Request redraw
        }
        return 0;

        // --- NEW: Handle F2 Key for Reset ---
        // --- MODIFIED: Handle More Keys ---
    case WM_KEYDOWN:
    { // Add scope for variable declarations

        // --- FIX: Get Cue Ball pointer for this scope ---
        cueBall = GetCueBall();
        // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
        // --- End Fix ---

        // Check which player can interact via keyboard (Humans only)
        bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

        // --- F1 / F2 Keys (Always available) ---
        if (wParam == VK_F2) {
            HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
            ResetGame(hInstance); // Call reset function
            return 0; // Indicate key was processed
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Direct2D-based StickPool game made in C++ from scratch (2764+ lines of code)\n"" // Update line count if needed
                L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                L""About This Game"", MB_OK | MB_ICONINFORMATION);
            return 0; // Indicate key was processed
        }

        // Check for 'M' key (uppercase or lowercase)
            // Toggle music with ""M""
        if (wParam == 'M' || wParam == 'm') {
            //static bool isMusicPlaying = false;
            if (isMusicPlaying) {
                // Stop the music
                StopMidi();
                isMusicPlaying = false;
            }
            else {
                // Build the MIDI file path
                TCHAR midiPath[MAX_PATH];
                GetModuleFileName(NULL, midiPath, MAX_PATH);
                // Keep only the directory part
                TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                if (lastBackslash != NULL) {
                    *(lastBackslash + 1) = '\0';
                }
                // Append the MIDI filename
                _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                // Start playing MIDI
                StartMidi(hwndMain, midiPath);
                isMusicPlaying = true;
            }
        }


        // --- Player Interaction Keys (Only if allowed) ---
        if (canPlayerControl) {
            // --- Get Shift Key State ---
            bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
            float powerStep = 0.2f; // Power step (Adjust as needed)

            switch (wParam) {
            case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle -= angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle < 0) cueAngle += 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_RIGHT: // Rotate Cue Stick Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle += angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_UP: // Decrease Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower -= powerStep;
                    if (shotPower < 0.0f) shotPower = 0.0f;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_DOWN: // Increase Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower += powerStep;
                    if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_SPACE: // Trigger Shot
                if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                    && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                {
                    if (shotPower > 0.15f) { // Use same threshold as mouse
                       // Reset foul flags BEFORE applying shot
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;

                        // Play sound & Apply Shot
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                        // Update State
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false;
                        pocketedThisTurn.clear();
                        shotPower = 0; // Reset power after shooting
                        isAiming = false; isDraggingStick = false; // Reset aiming flags
                        keyboardAimingActive = false;
                    }
                }
                break;

            case VK_ESCAPE: // Cancel Aim/Shot Setup
                if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                {
                    shotPower = 0.0f;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = false;
                    // Revert to basic turn state if not breaking
                    if (currentGameState != BREAKING) {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    }
                }
                break;

            case 'G': // Toggle Cheat Mode
                cheatModeEnabled = !cheatModeEnabled;
                if (cheatModeEnabled)
                    MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                else
                    MessageBeep(MB_OK); // Play a different beep when disabling
                break;

            default:
                // Allow default processing for other keys if needed
                // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                break;
            } // End switch(wParam) for player controls
            return 0; // Indicate player control key was processed
        } // End if(canPlayerControl)
    } // End scope for WM_KEYDOWN case
    // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
    // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
    return 0;

    case WM_MOUSEMOVE: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Hover ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
            int oldHover = currentlyHoveredPocket;
            currentlyHoveredPocket = -1; // Reset
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    currentlyHoveredPocket = i;
                    break;
                }
            }
            if (oldHover != currentlyHoveredPocket) {
                InvalidateRect(hwnd, NULL, FALSE);
            }
            // Do NOT return 0 here, allow normal mouse angle update to continue
        }
        // --- END NEW LOGIC ---


        cueBall = GetCueBall(); // Declare and get cueBall pointer

        if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
            Ball* ball = GetBallById(draggingBallId);
            if (ball) {
                ball->x = (float)ptMouse.x;
                ball->y = (float)ptMouse.y;
                ball->vx = ball->vy = 0.0f;
            }
            return 0;
        }

        if (!cueBall) return 0;

        // Update Aiming Logic (Check player turn)
        if (isDraggingCueBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                currentGameState == PRE_BREAK_PLACEMENT))
        {
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            // Tentative position update
            cueBall->x = (float)ptMouse.x;
            cueBall->y = (float)ptMouse.y;
            cueBall->vx = cueBall->vy = 0;
        }
        else if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            //NEW2 MOUSEBOUND CODE = START
                /*// Clamp mouse inside table bounds during aiming
                if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
            if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
            if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
            if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
            //NEW2 MOUSEBOUND CODE = END
            // Aiming drag updates angle and power
            float dx = (float)ptMouse.x - cueBall->x;
            float dy = (float)ptMouse.y - cueBall->y;
            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
            //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
            //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            }
        }
        else if (isSettingEnglish &&
            ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
        {
            // Setting English
            float dx = (float)ptMouse.x - spinIndicatorCenter.x;
            float dy = (float)ptMouse.y - spinIndicatorCenter.y;
            float dist = GetDistance(dx, dy, 0, 0);
            if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
            cueSpinX = dx / spinIndicatorRadius;
            cueSpinY = dy / spinIndicatorRadius;
        }
        else {
            //DISABLE PERM AIMING = START
            /*// Update visual angle even when not aiming/dragging (Check player turn)
            bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

            if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
            {
                // NEW MOUSEBOUND CODE = START
                    // Only update cue angle if mouse is inside the playable table area
                if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                    ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                {
                    // NEW MOUSEBOUND CODE = END
                    Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                    if (cb) {
                        float dx = (float)ptMouse.x - cb->x;
                        float dy = (float)ptMouse.y - cb->y;
                        if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    }
                } //NEW MOUSEBOUND CODE LINE = DISABLE
            }*/
            //DISABLE PERM AIMING = END
        }
        return 0;
    } // End WM_MOUSEMOVE

    case WM_LBUTTONDOWN: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        // --- NEW LOGIC: Handle Pocket Selection First ---
        if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
            (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

            int clickedPocketIndex = -1;
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                    clickedPocketIndex = i;
                    break;
                }
            }

            if (clickedPocketIndex != -1) { // Player clicked on a pocket to select it
                if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                else calledPocketP2 = clickedPocketIndex;
                // After selecting, transition to the normal aiming turn state
                currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                pocketCallMessage = L""""; // Clear the message
                InvalidateRect(hwnd, NULL, FALSE);
                return 0; // Consume the click
            }
            // If they click anywhere else, do nothing and let them re-choose
            return 0;
        }
        // --- END NEW LOGIC ---


        if (cheatModeEnabled) {
            // Allow dragging any ball freely
            for (Ball& ball : balls) {
                float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                    isDraggingCueBall = true;
                    draggingBallId = ball.id;
                    if (ball.id == 0) {
                        // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                        if (currentPlayer == 1)
                            currentGameState = BALL_IN_HAND_P1;
                        else if (currentPlayer == 2 && !isPlayer2AI)
                            currentGameState = BALL_IN_HAND_P2;
                    }
                    return 0;
                }
            }
        }

        Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

        // Check which player is allowed to interact via mouse click
        bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
        // Define states where interaction is generally allowed
        bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == AIMING || currentGameState == BREAKING ||
            currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
            currentGameState == PRE_BREAK_PLACEMENT);

        // Check Spin Indicator first (Allow if player's turn/aim phase)
        if (canPlayerClickInteract && canInteractState) {
            float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
            if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                isSettingEnglish = true;
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
                isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                return 0;
            }
        }

        if (!cueBall) return 0;

        // Check Ball-in-Hand placement/drag
        bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
        bool isPlayerAllowedToPlace = (isPlacingBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

        if (isPlayerAllowedToPlace) {
            float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                isDraggingCueBall = true;
                isAiming = false; isDraggingStick = false;
            }
            else {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                    cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                    cueBall->vx = 0; cueBall->vy = 0;
                    isDraggingCueBall = false;
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
            }
            return 0;
        }

        // Check for starting Aim (Cue Ball OR Stick)
        bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

        if (canAim) {
            const float stickDrawLength = 150.0f * 1.4f;
            float currentStickAngle = cueAngle + PI;
            D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
            D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
            float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
            float stickClickThresholdSq = 36.0f;
            float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

            bool clickedStick = (distToStickSq < stickClickThresholdSq);
            bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

            if (clickedStick || clickedCueArea) {
                isDraggingStick = clickedStick && !clickedCueArea;
                isAiming = clickedCueArea;
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                shotPower = 0;
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                if (currentGameState != BREAKING) currentGameState = AIMING;
            }
        }
        return 0;
    } // End WM_LBUTTONDOWN


    case WM_LBUTTONUP: {
        if (cheatModeEnabled && isDraggingCueBall) {
            isDraggingCueBall = false;
            if (draggingBallId == 0) {
                // After dropping CueBall, stay Ball-In-Hand mode if needed
                if (currentPlayer == 1)
                    currentGameState = BALL_IN_HAND_P1;
                else if (currentPlayer == 2 && !isPlayer2AI)
                    currentGameState = BALL_IN_HAND_P2;
            }
            draggingBallId = -1;
            return 0;
        }

        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        Ball* cueBall = GetCueBall(); // Get cueBall pointer

        // Check for releasing aim drag (Stick OR Cue Ball)
        if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            bool wasAiming = isAiming;
            bool wasDraggingStick = isDraggingStick;
            isAiming = false; isDraggingStick = false;

            if (shotPower > 0.15f) { // Check power threshold
                if (currentGameState != AI_THINKING) {
                    firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false; pocketedThisTurn.clear();
                }
            }
            else if (currentGameState != AI_THINKING) { // Revert state if power too low
                if (currentGameState == BREAKING) { /* Still breaking */ }
                else {
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                }
            }
            shotPower = 0; // Reset power indicator regardless
        }

        // Handle releasing cue ball drag (placement)
        if (isDraggingCueBall) {
            isDraggingCueBall = false;
            // Check player allowed to place
            bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowed = (isPlacingState &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT)));

            if (isPlayerAllowed && cueBall) {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                    // Finalize position already set by mouse move
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
                else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
            }
        }

        // Handle releasing english setting
        if (isSettingEnglish) {
            isSettingEnglish = false;
        }
        return 0;
    } // End WM_LBUTTONUP

    case WM_DESTROY:
        isMusicPlaying = false;
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
            SaveSettings(); // Save settings on exit
        }
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// --- Direct2D Resource Management ---

HRESULT CreateDeviceResources() {
    HRESULT hr = S_OK;

    // Create Direct2D Factory
    if (!pFactory) {
        hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr)) return hr;
    }

    // Create DirectWrite Factory
    if (!pDWriteFactory) {
        hr = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (FAILED(hr)) return hr;
    }

    // Create Text Formats
    if (!pTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            16.0f, L""en-us"", &pTextFormat
        );
        if (FAILED(hr)) return hr;
        // Center align text
        pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }
    if (!pLargeTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            48.0f, L""en-us"", &pLargeTextFormat
        );
        if (FAILED(hr)) return hr;
        pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
        pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }


    // Create Render Target (needs valid hwnd)
    if (!pRenderTarget && hwndMain) {
        RECT rc;
        GetClientRect(hwndMain, &rc);
        D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

        hr = pFactory->CreateHwndRenderTarget(
            D2D1::RenderTargetProperties(),
            D2D1::HwndRenderTargetProperties(hwndMain, size),
            &pRenderTarget
        );
        if (FAILED(hr)) {
            // If failed, release factories if they were created in this call
            SafeRelease(&pTextFormat);
            SafeRelease(&pLargeTextFormat);
            SafeRelease(&pDWriteFactory);
            SafeRelease(&pFactory);
            pRenderTarget = nullptr; // Ensure it's null on failure
            return hr;
        }
    }

    return hr;
}

void DiscardDeviceResources() {
    SafeRelease(&pRenderTarget);
    SafeRelease(&pTextFormat);
    SafeRelease(&pLargeTextFormat);
    SafeRelease(&pDWriteFactory);
    // Keep pFactory until application exit? Or release here too? Let's release.
    SafeRelease(&pFactory);
}

void OnResize(UINT width, UINT height) {
    if (pRenderTarget) {
        D2D1_SIZE_U size = D2D1::SizeU(width, height);
        pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
    }
}

// --- Game Initialization ---
void InitGame() {
    srand((unsigned int)time(NULL)); // Seed random number generator
    isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
    aiPlannedShotDetails.isValid = false; // Reset AI planned shot
    aiIsDisplayingAim = false;
    aiAimDisplayFramesLeft = 0;
    // ... (rest of InitGame())

    // --- Ensure pocketed list is clear from the absolute start ---
    pocketedThisTurn.clear();

    balls.clear(); // Clear existing balls

    // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
    player1Info.assignedType = BallType::NONE;
    player1Info.ballsPocketedCount = 0;
    // Player 1 Name usually remains ""Player 1""
    player2Info.assignedType = BallType::NONE;
    player2Info.ballsPocketedCount = 0;
    // Player 2 Name is set based on gameMode in ShowNewGameDialog

    // Create Cue Ball (ID 0)
    // Initial position will be set during PRE_BREAK_PLACEMENT state
    balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

    // --- Create Object Balls (Temporary List) ---
    std::vector<Ball> objectBalls;
    // Solids (1-7, Yellow)
    for (int i = 1; i <= 7; ++i) {
        objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
    }
    // Stripes (9-15, Red)
    for (int i = 9; i <= 15; ++i) {
        objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
    }
    // 8-Ball (ID 8) - Add it to the list to be placed
    objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


    // --- Racking Logic (Improved) ---
    float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
    float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

    // Define rack positions (0-14 indices corresponding to triangle spots)
    D2D1_POINT_2F rackPositions[15];
    int rackIndex = 0;
    for (int row = 0; row < 5; ++row) {
        for (int col = 0; col <= row; ++col) {
            if (rackIndex >= 15) break;
            float x = RACK_POS_X + row * spacingX;
            float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
            rackPositions[rackIndex++] = D2D1::Point2F(x, y);
        }
    }

    // Separate 8-ball
    Ball eightBall;
    std::vector<Ball> otherBalls; // Solids and Stripes
    bool eightBallFound = false;
    for (const auto& ball : objectBalls) {
        if (ball.id == 8) {
            eightBall = ball;
            eightBallFound = true;
        }
        else {
            otherBalls.push_back(ball);
        }
    }
    // Ensure 8 ball was actually created (should always be true)
    if (!eightBallFound) {
        // Handle error - perhaps recreate it? For now, proceed.
        eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
    }


    // Shuffle the other 14 balls
    // Use std::shuffle if available (C++11 and later) for better randomness
    // std::random_device rd;
    // std::mt19937 g(rd());
    // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
    std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

    // --- Place balls into the main 'balls' vector in rack order ---
    // Important: Add the cue ball (already created) first.
    // (Cue ball added at the start of the function now)

    // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
    int eightBallRackIndex = 4;
    eightBall.x = rackPositions[eightBallRackIndex].x;
    eightBall.y = rackPositions[eightBallRackIndex].y;
    eightBall.vx = 0;
    eightBall.vy = 0;
    eightBall.isPocketed = false;
    balls.push_back(eightBall); // Add 8 ball to the main vector

    // 2. Place the shuffled Solids and Stripes in the remaining spots
    size_t otherBallIdx = 0;
    //int otherBallIdx = 0;
    for (int i = 0; i < 15; ++i) {
        if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

        if (otherBallIdx < otherBalls.size()) {
            Ball& ballToPlace = otherBalls[otherBallIdx++];
            ballToPlace.x = rackPositions[i].x;
            ballToPlace.y = rackPositions[i].y;
            ballToPlace.vx = 0;
            ballToPlace.vy = 0;
            ballToPlace.isPocketed = false;
            balls.push_back(ballToPlace); // Add to the main game vector
        }
    }
    // --- End Racking Logic ---


    // --- Determine Who Breaks and Initial State ---
    if (isPlayer2AI) {
        /*// AI Mode: Randomly decide who breaks
        if ((rand() % 2) == 0) {
            // AI (Player 2) breaks
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
            aiTurnPending = true; // Trigger AI logic
        }
        else {
            // Player 1 (Human) breaks
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
            aiTurnPending = false;*/
        switch (openingBreakMode) {
        case CPU_BREAK:
            currentPlayer = 2; // AI breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        case P1_BREAK:
            currentPlayer = 1; // Player 1 breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false;
            break;
        case FLIP_COIN_BREAK:
            if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
            }
            else {
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
            }
            break;
        default: // Fallback to CPU break
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        }
    }
    else {
        // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
        currentPlayer = 1;
        currentGameState = PRE_BREAK_PLACEMENT;
        aiTurnPending = false; // No AI involved
    }

    // Reset other relevant game state variables
    foulCommitted = false;
    gameOverMessage = L"""";
    firstBallPocketedAfterBreak = false;
    // pocketedThisTurn cleared at start
    // Reset shot parameters and input flags
    shotPower = 0.0f;
    cueSpinX = 0.0f;
    cueSpinY = 0.0f;
    isAiming = false;
    isDraggingCueBall = false;
    isSettingEnglish = false;
    cueAngle = 0.0f; // Reset aim angle
}


// --- Game Loop ---
void GameUpdate() {
    if (currentGameState == SHOT_IN_PROGRESS) {
        UpdatePhysics();
        CheckCollisions();

        if (AreBallsMoving()) {
            // When all balls stop, clear aiming flags
            isAiming = false;
            aiIsDisplayingAim = false;
            //ProcessShotResults();
        }

        bool pocketed = CheckPockets(); // Store if any ball was pocketed

        // --- Update pocket flash animation timer ---
        if (pocketFlashTimer > 0.0f) {
            pocketFlashTimer -= 0.02f;
            if (pocketFlashTimer < 0.0f) pocketFlashTimer = 0.0f;
        }

        if (!AreBallsMoving()) {
            ProcessShotResults(); // Determine next state based on what happened
        }
    }

    // --- Check if AI needs to act ---
    else if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
        if (aiIsDisplayingAim) { // AI has decided a shot and is displaying aim
            aiAimDisplayFramesLeft--;
            if (aiAimDisplayFramesLeft <= 0) {
                aiIsDisplayingAim = false; // Done displaying
                if (aiPlannedShotDetails.isValid) {
                    // Execute the planned shot
                    firstHitBallIdThisShot = -1;
                    cueHitObjectBallThisShot = false;
                    railHitAfterContact = false;
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
                    aiPlannedShotDetails.isValid = false; // Clear the planned shot
                }
                currentGameState = SHOT_IN_PROGRESS;
                foulCommitted = false;
                pocketedThisTurn.clear();
            }
            // Else, continue displaying aim
        }
        else if (aiTurnPending) { // AI needs to start its decision process
            // Valid states for AI to start thinking
            /*/if (currentGameState == PRE_BREAK_PLACEMENT && isOpeningBreakShot) {*/
            //newcode 1 commented out
            /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
                // Handle the break shot
                AIBreakShot();
            }*/ //new code 1 end  
            /*else if (currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING ||
                currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2) {*/

                // aiTurnPending might be consumed by AIBreakShot or remain for next cycle if needed
        /* } //new code 2 commented out
        else if (currentGameState == BALL_IN_HAND_P2 && currentPlayer == 2 && isPlayer2AI) {
            AIPlaceCueBall(); // AI places the ball first
            // After placement, AI needs to decide its shot.
            // Transition to a state where AIMakeDecision will be called for shot selection.
            currentGameState = PLAYER2_TURN; // Or a specific AI_AIMING_AFTER_PLACEMENT state
                                             // aiTurnPending remains true to trigger AIMakeDecision next.
        }
        else if (currentGameState == PLAYER2_TURN && currentPlayer == 2 && isPlayer2AI) {
            // This is for a normal turn (not break, not immediately after ball-in-hand placement)

                currentGameState = AI_THINKING; // Set state to indicate AI is processing
                aiTurnPending = false;         // Consume the pending turn flag
                AIMakeDecision();              // For normal shots (non-break)
            }
            else {
                // Not a state where AI should act
                aiTurnPending = false;
            }*/
            // 2b) AI is ready to think (pending flag)
            // **1) Ball-in-Hand** let AI place the cue ball first
            if (currentGameState == BALL_IN_HAND_P2) {
                // Step 1: AI places the cue ball.
                AIPlaceCueBall();
                // Step 2: Transition to thinking state for shot decision.
                currentGameState = AI_THINKING; //newcode5
                // Step 3: Consume the pending flag for the placement phase.
                //         AIMakeDecision will handle shot planning now.
                aiTurnPending = false; //newcode5
                // Step 4: AI immediately decides the shot from the new position.
                AIMakeDecision(); //newcode5
            }
            // **2) Opening break** special break shot logic
            else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                AIBreakShot();
            }
            else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) { //newcode5
                // General turn for AI to think (not ball-in-hand, not initial break placement)
                currentGameState = AI_THINKING; //newcode5
                aiTurnPending = false; // Consume the flag //newcode5
                AIMakeDecision(); //newcode5
            }
            // **3) Otherwise** normal shot planning
            /*else { //orig uncommented oldcode5
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
            }*/
        }

        //} //bracefix
        // If current state is AI_THINKING but not displaying aim, then AI decision has already been made
    }
}

// --- Physics and Collision ---
void UpdatePhysics() {
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) {
            b.x += b.vx;
            b.y += b.vy;

            // Apply friction
            b.vx *= FRICTION;
            b.vy *= FRICTION;

            // Stop balls if velocity is very low
            if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                b.vx = 0;
                b.vy = 0;
            }
        }
    }
}

void CheckCollisions() {
    float left = TABLE_LEFT;
    float right = TABLE_RIGHT;
    float top = TABLE_TOP;
    float bottom = TABLE_BOTTOM;
    const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

    // --- Reset Per-Frame Sound Flags ---
    bool playedWallSoundThisFrame = false;
    bool playedCollideSoundThisFrame = false;
    // ---

    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b1 = balls[i];
        if (b1.isPocketed) continue;

        bool nearPocket[6];
        for (int p = 0; p < 6; ++p) {
            nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
        }
        bool nearTopLeftPocket = nearPocket[0];
        bool nearTopMidPocket = nearPocket[1];
        bool nearTopRightPocket = nearPocket[2];
        bool nearBottomLeftPocket = nearPocket[3];
        bool nearBottomMidPocket = nearPocket[4];
        bool nearBottomRightPocket = nearPocket[5];

        bool collidedWallThisBall = false;

        // --- Ball-Wall Collisions ---
        // (Check logic unchanged, added sound calls and railHitAfterContact update)
        // Left Wall
        if (b1.x - BALL_RADIUS < left) {
            if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Right Wall
        if (b1.x + BALL_RADIUS > right) {
            if (!nearTopRightPocket && !nearBottomRightPocket) {
                b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Top Wall
        if (b1.y - BALL_RADIUS < top) {
            if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Bottom Wall
        if (b1.y + BALL_RADIUS > bottom) {
            if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }

        // Spin effect (Unchanged)
        if (collidedWallThisBall) {
            if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
            if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
            cueSpinX *= 0.7f; cueSpinY *= 0.7f;
        }


        // --- Ball-Ball Collisions ---
        for (size_t j = i + 1; j < balls.size(); ++j) {
            Ball& b2 = balls[j];
            if (b2.isPocketed) continue;

            float dx = b2.x - b1.x; float dy = b2.y - b1.y;
            float distSq = dx * dx + dy * dy;
            float minDist = BALL_RADIUS * 2.0f;

            if (distSq > 1e-6 && distSq < minDist * minDist) {
                float dist = sqrtf(distSq);
                float overlap = minDist - dist;
                float nx = dx / dist; float ny = dy / dist;

                // Separation (Unchanged)
                b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                float velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) { // Colliding
                    // --- Play Ball Collision Sound ---
                    if (!playedCollideSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                        playedCollideSoundThisFrame = true; // Set flag
                    }
                    // --- End Sound ---

                    // --- NEW: Track First Hit and Cue/Object Collision ---
                    if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                        if (b1.id == 0) { // Cue ball hit b2 first
                            firstHitBallIdThisShot = b2.id;
                            cueHitObjectBallThisShot = true;
                        }
                        else if (b2.id == 0) { // Cue ball hit b1 first
                            firstHitBallIdThisShot = b1.id;
                            cueHitObjectBallThisShot = true;
                        }
                        // If neither is cue ball, doesn't count as first hit for foul purposes
                    }
                    else if (b1.id == 0 || b2.id == 0) {
                        // Track subsequent cue ball collisions with object balls
                        cueHitObjectBallThisShot = true;
                    }
                    // --- End First Hit Tracking ---


                    // Impulse (Unchanged)
                    float impulse = velAlongNormal;
                    b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                    b2.vx += impulse * nx; b2.vy += impulse * ny;

                    // Spin Transfer (Unchanged)
                    if (b1.id == 0 || b2.id == 0) {
                        float spinEffectFactor = 0.08f;
                        b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                    }
                }
            }
        } // End ball-ball loop
    } // End ball loop
} // End CheckCollisions


bool CheckPockets() {
    bool ballPocketedThisCheck = false; // Local flag for this specific check run
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) { // Only check balls that aren't already flagged as pocketed
            for (int p = 0; p < 6; ++p) {
                float distSq = GetDistanceSq(b.x, b.y, pocketPositions[p].x, pocketPositions[p].y);
                // --- Use updated POCKET_RADIUS ---
                if (distSq < POCKET_RADIUS * POCKET_RADIUS) {
                    b.isPocketed = true;
                    b.vx = b.vy = 0;
                    pocketedThisTurn.push_back(b.id);

                    // --- Play Pocket Sound (Threaded) ---
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound ---

                    break; // Ball is pocketed
                }
            }
        }
    }
    return ballPocketedThisCheck;
}

bool AreBallsMoving() {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
            return true;
        }
    }
    return false;
}

void RespawnCueBall(bool behindHeadstring) { // 'behindHeadstring' only relevant for initial break placement
    Ball* cueBall = GetCueBall();
    if (cueBall) {
        // Reset position to a default
        //disabled for behind headstring (now move anywhere)
        /*cueBall->x = HEADSTRING_X * 0.5f;
        cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;*/
        // Reset position to a default:
        if (behindHeadstring) {
            // Opening break: kitchen center
            cueBall->x = HEADSTRING_X * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        else {
            // Ball-in-hand (foul): center of full table
            cueBall->x = TABLE_LEFT + TABLE_WIDTH / 2.0f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        cueBall->vx = 0;
        cueBall->vy = 0;
        cueBall->isPocketed = false;

        // Set state based on who gets ball-in-hand
        /*// 'currentPlayer' already reflects who's turn it is NOW (switched before calling this)*/
        // 'currentPlayer' has already been switched to the player whose turn it will be.
        // The 'behindHeadstring' parameter to RespawnCueBall is mostly for historical reasons / initial setup.
        if (currentPlayer == 1) { // Player 2 (AI/Human) fouled, Player 1 (Human) gets ball-in-hand
            currentGameState = BALL_IN_HAND_P1;
            aiTurnPending = false; // Ensure AI flag off
        }
        else { // Player 1 (Human) fouled, Player 2 gets ball-in-hand
            if (isPlayer2AI) {
                // --- CONFIRMED FIX: Set correct state for AI Ball-in-Hand ---
                currentGameState = BALL_IN_HAND_P2; // AI now needs to place the ball
                aiTurnPending = true; // Trigger AI logic (will call AIPlaceCueBall first)
            }
            else { // Human Player 2
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = false; // Ensure AI flag off
            }
        }
        // Handle initial placement state correctly if called from InitGame
        /*if (behindHeadstring && currentGameState != PRE_BREAK_PLACEMENT) {
            // This case might need review depending on exact initial setup flow,
            // but the foul logic above should now be correct.
            // Let's ensure initial state is PRE_BREAK_PLACEMENT if behindHeadstring is true.*/
            //currentGameState = PRE_BREAK_PLACEMENT;
    }
}
//}


// --- Game Logic ---

void ApplyShot(float power, float angle, float spinX, float spinY) {
    Ball* cueBall = GetCueBall();
    if (cueBall) {

        // --- Play Cue Strike Sound (Threaded) ---
        if (power > 0.1f) { // Only play if it's an audible shot
            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
        }
        // --- End Sound ---

        cueBall->vx = cosf(angle) * power;
        cueBall->vy = sinf(angle) * power;

        // Apply English (Spin) - Simplified effect (Unchanged)
        cueBall->vx += sinf(angle) * spinY * 0.5f;
        cueBall->vy -= cosf(angle) * spinY * 0.5f;
        cueBall->vx -= cosf(angle) * spinX * 0.5f;
        cueBall->vy -= sinf(angle) * spinX * 0.5f;

        // Store spin (Unchanged)
        cueSpinX = spinX;
        cueSpinY = spinY;

        // --- Reset Foul Tracking flags for the new shot ---
        // (Also reset in LBUTTONUP, but good to ensure here too)
        firstHitBallIdThisShot = -1;      // No ball hit yet
        cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
        railHitAfterContact = false;     // No rail hit after contact yet
        // --- End Reset ---

                // If this was the opening break shot, clear the flag
        if (isOpeningBreakShot) {
            isOpeningBreakShot = false; // Mark opening break as taken
        }
    }
}


void ProcessShotResults() {
    bool cueBallPocketed = false;
    bool eightBallPocketed = false;

    PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
    int ownBallsPocketedThisTurn = 0;

    for (int id : pocketedThisTurn) {
        Ball* b = GetBallById(id);
        if (!b) continue;

        if (b->id == 0) cueBallPocketed = true;
        else if (b->id == 8) eightBallPocketed = true;
        else {
            if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) player1Info.ballsPocketedCount++;
            else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) player2Info.ballsPocketedCount++;
            if (b->type == shootingPlayer.assignedType) {
                ownBallsPocketedThisTurn++;
            }
        }
    }

    if (eightBallPocketed) {
        CheckGameOverConditions(true, cueBallPocketed);
        if (currentGameState == GAME_OVER) {
            pocketedThisTurn.clear();
            return;
        }
    }

    bool turnFoul = false;
    if (cueBallPocketed) {
        turnFoul = true;
    }
    else {
        Ball* firstHit = GetBallById(firstHitBallIdThisShot);
        if (!firstHit) {
            turnFoul = true;
        }
        else {
            if (player1Info.assignedType != BallType::NONE) {
                if (IsPlayerOnEightBall(currentPlayer)) {
                    if (firstHit->id != 8) turnFoul = true;
                }
                else {
                    if (firstHit->type != shootingPlayer.assignedType) turnFoul = true;
                }
            }
        }
    }

    if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
        turnFoul = true;
    }

    foulCommitted = turnFoul;

    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed && !eightBallPocketed) {
        Ball* firstBall = GetBallById(pocketedThisTurn[0]);
        if (firstBall) AssignPlayerBallTypes(firstBall->type);
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else if (ownBallsPocketedThisTurn > 0) {
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        SwitchTurns();
    }

    pocketedThisTurn.clear();
}

void AssignPlayerBallTypes(BallType firstPocketedType) {
    if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
        if (currentPlayer == 1) {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        else {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
    }
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.
}

void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
    if (!eightBallPocketed) return; // Only proceed if 8-ball was pocketed

    PlayerInfo& currentPlayerInfo = (currentPlayer == 1) ? player1Info : player2Info;
    bool playerClearedBalls = (currentPlayerInfo.assignedType != BallType::NONE && currentPlayerInfo.ballsPocketedCount >= 7);

    // Loss Conditions:
    // 1. Pocket 8-ball AND scratch (pocket cue ball)
    // 2. Pocket 8-ball before clearing own color group
    if (cueBallPocketed || (!playerClearedBalls && currentPlayerInfo.assignedType != BallType::NONE)) {
        gameOverMessage = (currentPlayer == 1) ? L""Player 2 Wins! (Player 1 fouled on 8-ball)"" : L""Player 1 Wins! (Player 2 fouled on 8-ball)"";
        currentGameState = GAME_OVER;
    }
    // Win Condition:
    // 1. Pocket 8-ball legally after clearing own color group
    else if (playerClearedBalls) {
        gameOverMessage = (currentPlayer == 1) ? L""Player 1 Wins!"" : L""Player 2 Wins!"";
        currentGameState = GAME_OVER;
    }
    // Special case: 8 ball pocketed on break. Usually re-spot or re-rack.
    // Simple: If it happens during assignment phase, treat as foul, respawn 8ball.
    else if (player1Info.assignedType == BallType::NONE) {
        Ball* eightBall = GetBallById(8);
        if (eightBall) {
            eightBall->isPocketed = false;
            // Place 8-ball on foot spot (approx RACK_POS_X) or center if occupied
            eightBall->x = RACK_POS_X;
            eightBall->y = RACK_POS_Y;
            eightBall->vx = eightBall->vy = 0;
            // Check overlap and nudge if necessary (simplified)
        }
        // Apply foul rules if cue ball was also pocketed
        if (cueBallPocketed) {
            foulCommitted = true;
            // Don't switch turns on break scratch + 8ball pocket? Rules vary.
            // Let's make it a foul, switch turns, ball in hand.
            SwitchTurns();
            RespawnCueBall(false); // Ball in hand for opponent
        }
        else {
            // Just respawned 8ball, continue turn or switch based on other balls pocketed.
            // Let ProcessShotResults handle turn logic based on other pocketed balls.
        }
        // Prevent immediate game over message by returning here
        return;
    }


}


void SwitchTurns() {
    currentPlayer = (currentPlayer == 1) ? 2 : 1;
    isAiming = false;
    shotPower = 0;
    CheckAndTransitionToPocketChoice(currentPlayer); // Use the new helper
}

void AIBreakShot() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
    // AI will place the cue ball and then plan the shot.
    if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
        // Place cue ball in the kitchen randomly
        /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
        float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

        // --- AI Places Cue Ball for Break ---
// Decide if placing center or side. For simplicity, let's try placing slightly off-center
// towards one side for a more angled break, or center for direct apex hit.
// A common strategy is to hit the second ball of the rack.

        float placementY = RACK_POS_Y; // Align vertically with the rack center
        float placementX;

        // Randomly choose a side or center-ish placement for variation.
        int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

        if (placementChoice == 0) { // Left-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
        }
        else if (placementChoice == 2) { // Right-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
        }
        else { // Center-ish
            placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
        }
        placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

        bool validPos = false;
        int attempts = 0;
        while (!validPos && attempts < 100) {
            /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
            cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                validPos = true; // [cite: 1591]*/
                // Try the chosen X, but vary Y slightly to find a clear spot
            cueBall->x = placementX;
            cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
            cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                validPos = true;
            }
            attempts++; // [cite: 1592]
        }
        if (!validPos) {
            // Fallback position
            /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
            cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
            }
        }
        cueBall->vx = 0; // [cite: 1595]
        cueBall->vy = 0; // [cite: 1596]

        // Plan a break shot: aim at the center of the rack (apex ball)
        float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
        float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

        float dx = targetX - cueBall->x; // [cite: 1599]
        float dy = targetY - cueBall->y; // [cite: 1600]
        float shotAngle = atan2f(dy, dx); // [cite: 1600]
        float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
            cueBall->y = RACK_POS_Y;
        }
        cueBall->vx = 0; cueBall->vy = 0;

        // --- AI Plans the Break Shot ---
        float targetX, targetY;
        // If cue ball is near center of kitchen width, aim for apex.
        // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
        float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
        if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
            // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
            targetX = RACK_POS_X; // Apex ball X
            targetY = RACK_POS_Y; // Apex ball Y
        }
        else {
            // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
            // This is a simplification. A more robust way is to find the actual second ball.
            // For now, aim slightly off the apex towards the side the cue ball is on.
            targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
            targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
        }

        float dx = targetX - cueBall->x;
        float dy = targetY - cueBall->y;
        float shotAngle = atan2f(dy, dx);
        float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

        // Store planned shot details for the AI
        /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
        aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
        aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
        aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
        aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

        aiPlannedShotDetails.angle = shotAngle;
        aiPlannedShotDetails.power = shotPowerValue;
        aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
        /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
        ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
        ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
        ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

        ::cueAngle = aiPlannedShotDetails.angle;
        ::shotPower = aiPlannedShotDetails.power;
        ::cueSpinX = aiPlannedShotDetails.spinX;
        ::cueSpinY = aiPlannedShotDetails.spinY;

        // Set up for AI display via GameUpdate
        /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

        currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                        // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                        // and then execute the shot using aiPlannedShotDetails.
                                        // isOpeningBreakShot will be set to false within ApplyShot.

        // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display

        return; // The break shot is now planned and will be executed by GameUpdate
    }

    // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
    //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
    //    This part can be extended if AIBreakShot needs to handle other scenarios.
    //    For now, the primary logic is above.
}

// --- Helper Functions ---

Ball* GetBallById(int id) {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id == id) {
            return &balls[i];
        }
    }
    return nullptr;
}

Ball* GetCueBall() {
    return GetBallById(0);
}

float GetDistance(float x1, float y1, float x2, float y2) {
    return sqrtf(GetDistanceSq(x1, y1, x2, y2));
}

float GetDistanceSq(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return dx * dx + dy * dy;
}

bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
    // Basic bounds check (inside cushions)
    float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
    float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
    float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
    float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

    if (x < left || x > right || y < top || y > bottom) {
        return false;
    }

    // Check headstring restriction if needed
    if (checkHeadstring && x >= HEADSTRING_X) {
        return false;
    }

    // Check overlap with other balls
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
            if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                return false; // Overlapping another ball
            }
        }
    }

    return true;
}

// --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

// Checks if a player has pocketed all their balls and is now on the 8-ball.
bool IsPlayerOnEightBall(int player) {
    PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
    if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
        Ball* eightBall = GetBallById(8);
        return (eightBall && !eightBall->isPocketed);
    }
    return false;
}

// Centralized logic to enter the ""choosing pocket"" state. This fixes the indicator bugs.
void CheckAndTransitionToPocketChoice(int playerID) {
    bool needsToCall = IsPlayerOnEightBall(playerID);
    int* calledPocketForPlayer = (playerID == 1) ? &calledPocketP1 : &calledPocketP2;

    if (needsToCall && *calledPocketForPlayer == -1) { // Only transition if a pocket hasn't been called yet
        pocketCallMessage = ((playerID == 1) ? player1Info.name : player2Info.name) + L"": Choose a pocket..."";
        if (playerID == 1) {
            currentGameState = CHOOSING_POCKET_P1;
        }
        else { // Player 2
            if (isPlayer2AI) {
                currentGameState = AI_THINKING;
                aiTurnPending = true;
            }
            else {
                currentGameState = CHOOSING_POCKET_P2;
            }
        }
        if (!(playerID == 2 && isPlayer2AI)) {
            *calledPocketForPlayer = 5; // Default to top-right if none chosen
        }
    }
    else {
        // Player does not need to call a pocket (or already has), proceed to normal turn.
        pocketCallMessage = L""""; // Clear any message
        currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
        if (playerID == 2 && isPlayer2AI) {
            aiTurnPending = true;
        }
    }
}

template <typename T>
void SafeRelease(T** ppT) {
    if (*ppT) {
        (*ppT)->Release();
        *ppT = nullptr;
    }
}

// --- Helper Function for Line Segment Intersection ---
// Finds intersection point of line segment P1->P2 and line segment P3->P4
// Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
{
    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

    // Check if lines are parallel or collinear
    if (fabs(denominator) < 1e-6) {
        return false;
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    // Check if intersection point lies on both segments
    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
        intersection.x = p1.x + ua * (p2.x - p1.x);
        intersection.y = p1.y + ua * (p2.y - p1.y);
        return true;
    }

    return false;
}

// --- INSERT NEW HELPER FUNCTION HERE ---
// Calculates the squared distance from point P to the line segment AB.
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
    float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
    if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
    // Consider P projecting onto the line AB infinite line
    // t = [(P-A) . (B-A)] / |B-A|^2
    float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
    t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
    // Projection falls on the segment
    D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
    return GetDistanceSq(p.x, p.y, projection.x, projection.y);
}
// --- End New Helper ---

// --- NEW AI Implementation Functions ---

// Main entry point for AI turn
void AIMakeDecision() {
    //AIShotInfo bestShot = { false }; // Declare here
    // This function is called when currentGameState is AI_THINKING (for a normal shot decision)
    Ball* cueBall = GetCueBall();
    if (!cueBall || !isPlayer2AI || currentPlayer != 2) {
        aiPlannedShotDetails.isValid = false; // Ensure no shot if conditions not met
        return;
    }

    // Phase 1: Placement if needed (Ball-in-Hand or Initial Break)
    /*if ((isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) || currentGameState == BALL_IN_HAND_P2) {
        AIPlaceCueBall(); // Handles kitchen placement for break or regular ball-in-hand
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            currentGameState = BREAKING; // Now AI needs to decide the break shot parameters
        }
        // For regular BALL_IN_HAND_P2, after placement, it will proceed to find a shot.
    }*/

    aiPlannedShotDetails.isValid = false; // Default to no valid shot found yet for this decision cycle
    // Note: isOpeningBreakShot is false here because AIBreakShot handles the break.

     // Phase 2: Decide shot parameters (Break or Normal play)
    /*if (isOpeningBreakShot && currentGameState == BREAKING) {
        // Force cue ball into center of kitchen
        cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
        cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f;
        cueBall->vx = cueBall->vy = 0.0f;

        float rackCenterX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f * 2.0f;
        float rackCenterY = RACK_POS_Y;
        float dx = rackCenterX - cueBall->x;
        float dy = rackCenterY - cueBall->y;

        aiPlannedShotDetails.angle = atan2f(dy, dx);
        aiPlannedShotDetails.power = MAX_SHOT_POWER;
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Apply shot immediately
        cueAngle = aiPlannedShotDetails.angle;
        shotPower = aiPlannedShotDetails.power;
        cueSpinX = aiPlannedShotDetails.spinX;
        cueSpinY = aiPlannedShotDetails.spinY;

        firstHitBallIdThisShot = -1;
        cueHitObjectBallThisShot = false;
        railHitAfterContact = false;
        isAiming = false;
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        //bool aiIsDisplayingAim = true;

        std::thread([](const TCHAR* soundName) {
            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
            }, TEXT(""cue.wav"")).detach();

            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
            currentGameState = SHOT_IN_PROGRESS;
            isOpeningBreakShot = false;
            aiTurnPending = false;
            pocketedThisTurn.clear();
            return;
    }
    else {*/
    // --- Normal AI Shot Decision (using AIFindBestShot) ---
    AIShotInfo bestShot = AIFindBestShot(); // bugtraq
    //bestShot = AIFindBestShot(); // bugtraq
    if (bestShot.possible) {
        aiPlannedShotDetails.angle = bestShot.angle;
        aiPlannedShotDetails.power = bestShot.power;
        aiPlannedShotDetails.spinX = 0.0f; // AI doesn't use spin yet
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;
    }
    else {
        // Safety tap if no better shot found
        // Try to hit the closest 'own' ball gently or any ball if types not assigned
        Ball* ballToNudge = nullptr;
        float minDistSq = -1.0f;
        BallType aiTargetType = player2Info.assignedType;
        bool mustHit8Ball = (aiTargetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);

        for (auto& b : balls) {
            if (b.isPocketed || b.id == 0) continue;
            bool canHitThis = false;
            if (mustHit8Ball) canHitThis = (b.id == 8);
            else if (aiTargetType != BallType::NONE) canHitThis = (b.type == aiTargetType);
            else canHitThis = (b.id != 8); // Can hit any non-8-ball if types not assigned

            if (canHitThis) {
                float dSq = GetDistanceSq(cueBall->x, cueBall->y, b.x, b.y);
                if (ballToNudge == nullptr || dSq < minDistSq) {
                    ballToNudge = &b;
                    minDistSq = dSq;
                }
            }
        }
        if (ballToNudge) { // Found a ball to nudge
            aiPlannedShotDetails.angle = atan2f(ballToNudge->y - cueBall->y, ballToNudge->x - cueBall->x);
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.15f; // Gentle tap
        }
        else { // Absolute fallback: small tap forward
            aiPlannedShotDetails.angle = cueAngle; // Keep last angle or default
            //aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
        }
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true; // Safety shot is a ""valid"" plan
    }
    //} //bracefix

    // Phase 3: Setup for Aim Display (if a valid shot was decided)
    if (aiPlannedShotDetails.isValid) {
        cueAngle = aiPlannedShotDetails.angle;   // Update global for drawing
        shotPower = aiPlannedShotDetails.power;  // Update global for drawing
        // cueSpinX and cueSpinY could also be set here if AI used them
        cueSpinX = aiPlannedShotDetails.spinX; // Also set these for drawing consistency
        cueSpinY = aiPlannedShotDetails.spinY; //

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        // currentGameState remains AI_THINKING, GameUpdate will handle the display countdown and shot execution.
            // FIRE THE BREAK SHOT NOW
            // Immediately execute the break shot after setting parameters
        /*ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
        currentGameState = SHOT_IN_PROGRESS;
        aiTurnPending = false;
        isOpeningBreakShot = false;*/
    }
    else {
        // Should not happen if safety shot is always planned, but as a fallback:
        aiIsDisplayingAim = false;
        // If AI truly can't decide anything, maybe switch turn or log error. For now, it will do nothing this frame.
        // Or force a minimal safety tap without display.
        // To ensure game progresses, let's plan a minimal tap if nothing else.
        if (!aiPlannedShotDetails.isValid) { // Double check
            aiPlannedShotDetails.angle = 0.0f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.05f; // Very small tap
            aiPlannedShotDetails.spinX = 0.0f; aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;
            //cueAngle = aiPlannedShotDetails.angle; shotPower = aiPlannedShotDetails.power;
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;
            cueSpinX = aiPlannedShotDetails.spinX;
            cueSpinY = aiPlannedShotDetails.spinY;
            aiIsDisplayingAim = true; // Allow display for this minimal tap too
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES / 2; // Shorter display for fallback
        }
    }
    // aiTurnPending was set to false by GameUpdate before calling AIMakeDecision.
    // AIMakeDecision's job is to populate aiPlannedShotDetails and trigger display.
}

// AI logic for placing cue ball during ball-in-hand
void AIPlaceCueBall() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // --- CPU AI Opening Break: Kitchen Placement ---
    /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
        float kitchenMinX = TABLE_LEFT + BALL_RADIUS;
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS;
        float kitchenMinY = TABLE_TOP + BALL_RADIUS;
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS;
        bool validPositionFound = false;
        int attempts = 0;
        while (!validPositionFound && attempts < 100) {
            cueBall->x = kitchenMinX + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxX - kitchenMinX)));
            cueBall->y = kitchenMinY + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxY - kitchenMinY)));
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                validPositionFound = true;
            }
            attempts++;
        }
        if (!validPositionFound) {
            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2.0f;
                cueBall->y = RACK_POS_Y;
            }
        }
        cueBall->vx = 0; cueBall->vy = 0;
        return;
    }*/
    // --- End CPU AI Opening Break Placement ---

    // This function is now SOLELY for Ball-In-Hand placement for the AI (anywhere on the table).
    // Break placement is handled by AIBreakShot().

    // Simple Strategy: Find the easiest possible shot for the AI's ball type
    // Place the cue ball directly behind that target ball, aiming straight at a pocket.
    // (More advanced: find spot offering multiple options or safety)

    AIShotInfo bestPlacementShot = { false };
    D2D1_POINT_2F bestPlacePos = D2D1::Point2F(HEADSTRING_X * 0.5f, RACK_POS_Y); // Default placement

    // A better default for ball-in-hand (anywhere) might be center table if no shot found.
    bestPlacePos = D2D1::Point2F(TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP + TABLE_HEIGHT / 2.0f);
    float bestPlacementScore = -1.0f; // Keep track of the score for the best placement found

    BallType targetType = player2Info.assignedType;
    bool canTargetAnyPlacement = false; // Local scope variable for placement logic
    if (targetType == BallType::NONE) {
        canTargetAnyPlacement = true;
    }
    bool target8Ball = (!canTargetAnyPlacement && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    if (target8Ball) targetType = BallType::EIGHT_BALL;


    for (auto& targetBall : balls) {
        if (targetBall.isPocketed || targetBall.id == 0) continue;

        // Determine if current ball is a valid target for placement consideration
        bool currentBallIsValidTarget = false;
        if (target8Ball && targetBall.id == 8) currentBallIsValidTarget = true;
        else if (canTargetAnyPlacement && targetBall.id != 8) currentBallIsValidTarget = true;
        else if (!canTargetAnyPlacement && !target8Ball && targetBall.type == targetType) currentBallIsValidTarget = true;

        if (!currentBallIsValidTarget) continue; // Skip if not a valid target

        for (int p = 0; p < 6; ++p) {
            // Calculate ideal cue ball position: straight line behind target ball aiming at pocket p
            float targetToPocketX = pocketPositions[p].x - targetBall.x;
            float targetToPocketY = pocketPositions[p].y - targetBall.y;
            float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);
            if (dist < 1.0f) continue; // Avoid division by zero

            float idealAngle = atan2f(targetToPocketY, targetToPocketX);
            // Place cue ball slightly behind target ball along this line
            float placeDist = BALL_RADIUS * 3.0f; // Place a bit behind
            D2D1_POINT_2F potentialPlacePos = D2D1::Point2F( // Use factory function
                targetBall.x - cosf(idealAngle) * placeDist,
                targetBall.y - sinf(idealAngle) * placeDist
            );

            // Check if this placement is valid (on table, behind headstring if break, not overlapping)
            /*bool behindHeadstringRule = (currentGameState == PRE_BREAK_PLACEMENT);*/
            // For ball-in-hand (NOT break), behindHeadstringRule is false.
            // The currentGameState should be BALL_IN_HAND_P2 when this is called for a foul.
            bool behindHeadstringRule = false; // Player can place anywhere after a foul
            if (IsValidCueBallPosition(potentialPlacePos.x, potentialPlacePos.y, behindHeadstringRule)) {
                // Is path from potentialPlacePos to targetBall clear?
                // Use D2D1::Point2F() factory function here
                if (IsPathClear(potentialPlacePos, D2D1::Point2F(targetBall.x, targetBall.y), 0, targetBall.id)) {
                    // Is path from targetBall to pocket clear?
                    // Use D2D1::Point2F() factory function here
                    if (IsPathClear(D2D1::Point2F(targetBall.x, targetBall.y), pocketPositions[p], targetBall.id, -1)) {
                        // This seems like a good potential placement. Score it?
                        // Easy AI: Just take the first valid one found.
                        /*bestPlacePos = potentialPlacePos;
                        goto placement_found;*/ // Use goto for simplicity in non-OOP structure
                        // This is a possible shot. Score this placement.
// A simple score: distance to target ball (shorter is better for placement).
// More advanced: consider angle to pocket, difficulty of the shot from this placement.
                        AIShotInfo tempShotInfo;
                        tempShotInfo.possible = true;
                        tempShotInfo.targetBall = &targetBall;
                        tempShotInfo.pocketIndex = p;
                        tempShotInfo.ghostBallPos = CalculateGhostBallPos(&targetBall, p); // Not strictly needed for placement score but good for consistency
                        tempShotInfo.angle = idealAngle; // The angle from the placed ball to target
                        // Use EvaluateShot's scoring mechanism if possible, or a simpler one here.
                        float currentScore = 1000.0f / (1.0f + GetDistance(potentialPlacePos.x, potentialPlacePos.y, targetBall.x, targetBall.y)); // Inverse distance

                        if (currentScore > bestPlacementScore) {
                            bestPlacementScore = currentScore;
                            bestPlacePos = potentialPlacePos;
                        }
                    }
                }
            }
        }
    }

placement_found:
    // Place the cue ball at the best found position (or default if no good spot found)
    cueBall->x = bestPlacePos.x;
    cueBall->y = bestPlacePos.y;
    cueBall->vx = 0;
    cueBall->vy = 0;
}


// AI finds the best shot available on the table
AIShotInfo AIFindBestShot() {
    AIShotInfo bestShotOverall = { false };
    Ball* cueBall = GetCueBall();
    if (!cueBall) return bestShotOverall;
    // Ensure cue ball position is up-to-date if AI just placed it
    // (AIPlaceCueBall should have already set cueBall->x, cueBall->y)

    // Determine target ball type for AI (Player 2)
    BallType targetType = player2Info.assignedType;
    bool canTargetAny = false; // Can AI hit any ball (e.g., after break, before assignment)?
    if (targetType == BallType::NONE) {
        // If colors not assigned, AI aims to pocket *something* (usually lowest numbered ball legally)
        // Or, more simply, treat any ball as a potential target to make *a* pocket
        canTargetAny = true; // Simplification: allow targeting any non-8 ball.
        // A better rule is hit lowest numbered ball first on break follow-up.
    }

    // Check if AI needs to shoot the 8-ball
    bool target8Ball = (!canTargetAny && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);


    // Iterate through all potential target balls
    for (auto& potentialTarget : balls) {
        if (potentialTarget.isPocketed || potentialTarget.id == 0) continue; // Skip pocketed and cue ball

        // Check if this ball is a valid target
        bool isValidTarget = false;
        if (target8Ball) {
            isValidTarget = (potentialTarget.id == 8);
        }
        else if (canTargetAny) {
            isValidTarget = (potentialTarget.id != 8); // Can hit any non-8 ball
        }
        else { // Colors assigned, not yet shooting 8-ball
            isValidTarget = (potentialTarget.type == targetType);
        }

        if (!isValidTarget) continue; // Skip if not a valid target for this turn

        // Now, check all pockets for this target ball
        for (int p = 0; p < 6; ++p) {
            AIShotInfo currentShot = EvaluateShot(&potentialTarget, p);
            currentShot.involves8Ball = (potentialTarget.id == 8);

            if (currentShot.possible) {
                // Compare scores to find the best shot
                if (!bestShotOverall.possible || currentShot.score > bestShotOverall.score) {
                    bestShotOverall = currentShot;
                }
            }
        }
    } // End loop through potential target balls

    // If targeting 8-ball and no shot found, or targeting own balls and no shot found,
    // need a safety strategy. Current simple AI just takes best found or taps cue ball.

    return bestShotOverall;
}


// Evaluate a potential shot at a specific target ball towards a specific pocket
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
    AIShotInfo shotInfo;
    shotInfo.possible = false; // Assume not possible initially
    shotInfo.targetBall = targetBall;
    shotInfo.pocketIndex = pocketIndex;

    Ball* cueBall = GetCueBall();
    if (!cueBall || !targetBall) return shotInfo;

    // --- Define local state variables needed for legality checks ---
    BallType aiAssignedType = player2Info.assignedType;
    bool canTargetAny = (aiAssignedType == BallType::NONE); // Can AI hit any ball?
    bool mustTarget8Ball = (!canTargetAny && aiAssignedType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    // ---

    // 1. Calculate Ghost Ball position
    shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

    // 2. Calculate Angle from Cue Ball to Ghost Ball
    float dx = shotInfo.ghostBallPos.x - cueBall->x;
    float dy = shotInfo.ghostBallPos.y - cueBall->y;
    if (fabs(dx) < 0.01f && fabs(dy) < 0.01f) return shotInfo; // Avoid aiming at same spot
    shotInfo.angle = atan2f(dy, dx);

    // Basic angle validity check (optional)
    if (!IsValidAIAimAngle(shotInfo.angle)) {
        // Maybe log this or handle edge cases
    }

    // 3. Check Path: Cue Ball -> Ghost Ball Position
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
        return shotInfo; // Path blocked
    }

    // 4. Check Path: Target Ball -> Pocket
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(targetBall->x, targetBall->y), pocketPositions[pocketIndex], targetBall->id, -1)) {
        return shotInfo; // Path blocked
    }

    // 5. Check First Ball Hit Legality
    float firstHitDistSq = -1.0f;
    // Use D2D1::Point2F() factory function here
    Ball* firstHit = FindFirstHitBall(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.angle, firstHitDistSq);

    if (!firstHit) {
        return shotInfo; // AI aims but doesn't hit anything? Impossible shot.
    }

    // Check if the first ball hit is the intended target ball
    if (firstHit->id != targetBall->id) {
        // Allow hitting slightly off target if it's very close to ghost ball pos
        float ghostDistSq = GetDistanceSq(shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y, firstHit->x, firstHit->y);
        // Allow a tolerance roughly half the ball radius squared
        if (ghostDistSq > (BALL_RADIUS * 0.7f) * (BALL_RADIUS * 0.7f)) {
            // First hit is significantly different from the target point.
            // This shot path leads to hitting the wrong ball first.
            return shotInfo; // Foul or unintended shot
        }
        // If first hit is not target, but very close, allow it for now (might still be foul based on type).
    }

    // Check legality of the *first ball actually hit* based on game rules
    if (!canTargetAny) { // Colors are assigned (or should be)
        if (mustTarget8Ball) { // Must hit 8-ball first
            if (firstHit->id != 8) {
                // return shotInfo; // FOUL - Hitting wrong ball when aiming for 8-ball
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
        }
        else { // Must hit own ball type first
            if (firstHit->type != aiAssignedType && firstHit->id != 8) { // Allow hitting 8-ball if own type blocked? No, standard rules usually require hitting own first.
                // return shotInfo; // FOUL - Hitting opponent ball or 8-ball when shouldn't
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
            else if (firstHit->id == 8) {
                // return shotInfo; // FOUL - Hitting 8-ball when shouldn't
                // Keep shot possible for now
            }
        }
    }
    // (If canTargetAny is true, hitting any ball except 8 first is legal - assuming not scratching)


    // 6. Calculate Score & Power (Difficulty affects this)
    shotInfo.possible = true; // If we got here, the shot is geometrically possible and likely legal enough for AI to consider

    float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
    float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);

    // Simple Score: Shorter shots are better, straighter shots are slightly better.
    float distanceScore = 1000.0f / (1.0f + cueToGhostDist + targetToPocketDist);

    // Angle Score: Calculate cut angle
    // Vector Cue -> Ghost
    float v1x = shotInfo.ghostBallPos.x - cueBall->x;
    float v1y = shotInfo.ghostBallPos.y - cueBall->y;
    // Vector Target -> Pocket
    float v2x = pocketPositions[pocketIndex].x - targetBall->x;
    float v2y = pocketPositions[pocketIndex].y - targetBall->y;
    // Normalize vectors
    float mag1 = sqrtf(v1x * v1x + v1y * v1y);
    float mag2 = sqrtf(v2x * v2x + v2y * v2y);
    float angleScoreFactor = 0.5f; // Default if vectors are zero len
    if (mag1 > 0.1f && mag2 > 0.1f) {
        v1x /= mag1; v1y /= mag1;
        v2x /= mag2; v2y /= mag2;
        // Dot product gives cosine of angle between cue ball path and target ball path
        float dotProduct = v1x * v2x + v1y * v2y;
        // Straighter shot (dot product closer to 1) gets higher score
        angleScoreFactor = (1.0f + dotProduct) / 2.0f; // Map [-1, 1] to [0, 1]
    }
    angleScoreFactor = std::max(0.1f, angleScoreFactor); // Ensure some minimum score factor

    shotInfo.score = distanceScore * angleScoreFactor;

    // Bonus for pocketing 8-ball legally
    if (mustTarget8Ball && targetBall->id == 8) {
        shotInfo.score *= 10.0; // Strongly prefer the winning shot
    }

    // Penalty for difficult cuts? Already partially handled by angleScoreFactor.

    // 7. Calculate Power
    shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

    // 8. Add Inaccuracy based on Difficulty (same as before)
    float angleError = 0.0f;
    float powerErrorFactor = 1.0f;

    switch (aiDifficulty) {
    case EASY:
        angleError = (float)(rand() % 100 - 50) / 1000.0f; // +/- ~3 deg
        powerErrorFactor = 0.8f + (float)(rand() % 40) / 100.0f; // 80-120%
        shotInfo.power *= 0.8f;
        break;
    case MEDIUM:
        angleError = (float)(rand() % 60 - 30) / 1000.0f; // +/- ~1.7 deg
        powerErrorFactor = 0.9f + (float)(rand() % 20) / 100.0f; // 90-110%
        break;
    case HARD:
        angleError = (float)(rand() % 10 - 5) / 1000.0f; // +/- ~0.3 deg
        powerErrorFactor = 0.98f + (float)(rand() % 4) / 100.0f; // 98-102%
        break;
    }
    shotInfo.angle += angleError;
    shotInfo.power *= powerErrorFactor;
    shotInfo.power = std::max(1.0f, std::min(shotInfo.power, MAX_SHOT_POWER)); // Clamp power

    return shotInfo;
}


// Calculates required power (simplified)
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist) {
    // Basic model: Power needed increases with total distance the balls need to travel.
    // Need enough power for cue ball to reach target AND target to reach pocket.
    float totalDist = cueToGhostDist + targetToPocketDist;

    // Map distance to power (needs tuning)
    // Let's say max power is needed for longest possible shot (e.g., corner to corner ~ 1000 units)
    float powerRatio = std::min(1.0f, totalDist / 800.0f); // Normalize based on estimated max distance

    float basePower = MAX_SHOT_POWER * 0.2f; // Minimum power to move balls reliably
    float variablePower = (MAX_SHOT_POWER * 0.8f) * powerRatio; // Scale remaining power range

    // Harder AI could adjust based on desired cue ball travel (more power for draw/follow)
    return std::min(MAX_SHOT_POWER, basePower + variablePower);
}

// Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex) {
    float targetToPocketX = pocketPositions[pocketIndex].x - targetBall->x;
    float targetToPocketY = pocketPositions[pocketIndex].y - targetBall->y;
    float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);

    if (dist < 1.0f) { // Target is basically in the pocket
        // Aim slightly off-center to avoid weird physics? Or directly at center?
        // For simplicity, return a point slightly behind center along the reverse line.
        return D2D1::Point2F(targetBall->x - targetToPocketX * 0.1f, targetBall->y - targetToPocketY * 0.1f);
    }

    // Normalize direction vector from target to pocket
    float nx = targetToPocketX / dist;
    float ny = targetToPocketY / dist;

    // Ghost ball position is diameter distance *behind* the target ball along this line
    float ghostX = targetBall->x - nx * (BALL_RADIUS * 2.0f);
    float ghostY = targetBall->y - ny * (BALL_RADIUS * 2.0f);

    return D2D1::Point2F(ghostX, ghostY);
}

// Checks if line segment is clear of obstructing balls
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2) {
    float dx = end.x - start.x;
    float dy = end.y - start.y;
    float segmentLenSq = dx * dx + dy * dy;

    if (segmentLenSq < 0.01f) return true; // Start and end are same point

    for (const auto& ball : balls) {
        if (ball.isPocketed) continue;
        if (ball.id == ignoredBallId1) continue;
        if (ball.id == ignoredBallId2) continue;

        // Check distance from ball center to the line segment
        float ballToStartX = ball.x - start.x;
        float ballToStartY = ball.y - start.y;

        // Project ball center onto the line defined by the segment
        float dot = (ballToStartX * dx + ballToStartY * dy) / segmentLenSq;

        D2D1_POINT_2F closestPointOnLine;
        if (dot < 0) { // Closest point is start point
            closestPointOnLine = start;
        }
        else if (dot > 1) { // Closest point is end point
            closestPointOnLine = end;
        }
        else { // Closest point is along the segment
            closestPointOnLine = D2D1::Point2F(start.x + dot * dx, start.y + dot * dy);
        }

        // Check if the closest point is within collision distance (ball radius + path radius)
        if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * BALL_RADIUS)) {
            // Consider slightly wider path check? Maybe BALL_RADIUS * 1.1f?
            // if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * 1.1f)*(BALL_RADIUS*1.1f)) {
            return false; // Path is blocked
        }
    }
    return true; // No obstructions found
}

// Finds the first ball hit along a path (simplified)
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq) {
    Ball* hitBall = nullptr;
    hitDistSq = -1.0f; // Initialize hit distance squared
    float minCollisionDistSq = -1.0f;

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    for (auto& ball : balls) {
        if (ball.isPocketed || ball.id == 0) continue; // Skip cue ball and pocketed

        float dx = ball.x - start.x;
        float dy = ball.y - start.y;

        // Project vector from start->ball onto the aim direction vector
        float dot = dx * cosA + dy * sinA;

        if (dot > 0) { // Ball is generally in front
            // Find closest point on aim line to the ball's center
            float closestPointX = start.x + dot * cosA;
            float closestPointY = start.y + dot * sinA;
            float distSq = GetDistanceSq(ball.x, ball.y, closestPointX, closestPointY);

            // Check if the aim line passes within the ball's radius
            if (distSq < (BALL_RADIUS * BALL_RADIUS)) {
                // Calculate distance from start to the collision point on the ball's circumference
                float backDist = sqrtf(std::max(0.f, BALL_RADIUS * BALL_RADIUS - distSq));
                float collisionDist = dot - backDist; // Distance along aim line to collision

                if (collisionDist > 0) { // Ensure collision is in front
                    float collisionDistSq = collisionDist * collisionDist;
                    if (hitBall == nullptr || collisionDistSq < minCollisionDistSq) {
                        minCollisionDistSq = collisionDistSq;
                        hitBall = &ball; // Found a closer hit ball
                    }
                }
            }
        }
    }
    hitDistSq = minCollisionDistSq; // Return distance squared to the first hit
    return hitBall;
}

// Basic check for reasonable AI aim angles (optional)
bool IsValidAIAimAngle(float angle) {
    // Placeholder - could check for NaN or infinity if calculations go wrong
    return isfinite(angle);
}

//midi func = start
void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
    while (isMusicPlaying) {
        MCI_OPEN_PARMS mciOpen = { 0 };
        mciOpen.lpstrDeviceType = TEXT(""sequencer"");
        mciOpen.lpstrElementName = midiPath;

        if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
            midiDeviceID = mciOpen.wDeviceID;

            MCI_PLAY_PARMS mciPlay = { 0 };
            mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

            // Wait for playback to complete
            MCI_STATUS_PARMS mciStatus = { 0 };
            mciStatus.dwItem = MCI_STATUS_MODE;

            do {
                mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                Sleep(100); // adjust as needed
            } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

void StartMidi(HWND hwnd, const TCHAR* midiPath) {
    if (isMusicPlaying) {
        StopMidi();
    }
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}

void StopMidi() {
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) musicThread.join();
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

/*void PlayGameMusic(HWND hwnd) {
    // Stop any existing playback
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) {
            musicThread.join();
        }
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }

    // Get the path of the executable
    TCHAR exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

    // Extract the directory path
    TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
    if (lastBackslash != NULL) {
        *(lastBackslash + 1) = '\0';
    }

    // Construct the full path to the MIDI file
    static TCHAR midiPath[MAX_PATH];
    _tcscpy_s(midiPath, MAX_PATH, exePath);
    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

    // Start the background playback
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}*/
//midi func = end

// --- Drawing Functions ---

void OnPaint() {
    HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

    if (SUCCEEDED(hr)) {
        pRenderTarget->BeginDraw();
        DrawScene(pRenderTarget); // Pass render target
        hr = pRenderTarget->EndDraw();

        if (hr == D2DERR_RECREATE_TARGET) {
            DiscardDeviceResources();
            // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
            // But the timer loop will trigger redraw anyway.
        }
    }
    // If CreateDeviceResources failed, EndDraw might not be called.
    // Consider handling this more robustly if needed.
}

void DrawScene(ID2D1RenderTarget* pRT) {
    if (!pRT) return;

    //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
    // Set background color to #ffffcd (RGB: 255, 255, 205)
    pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
    //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

    DrawTable(pRT, pFactory);
    DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
    DrawBalls(pRT);
    DrawAimingAids(pRT); // Includes cue stick if aiming
    DrawUI(pRT);
    DrawPowerMeter(pRT);
    DrawSpinIndicator(pRT);
    DrawPocketedBallsIndicator(pRT);
    DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

     // Draw Game Over Message
    if (currentGameState == GAME_OVER && pTextFormat) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
        if (pBrush) {
            D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
            pRT->DrawText(
                gameOverMessage.c_str(),
                (UINT32)gameOverMessage.length(),
                pTextFormat, // Use large format maybe?
                &layoutRect,
                pBrush
            );
            SafeRelease(&pBrush);
        }
    }

}

void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
    ID2D1SolidColorBrush* pBrush = nullptr;

    // === Draw Full Orange Frame (Table Border) ===
    ID2D1SolidColorBrush* pFrameBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    if (pFrameBrush) {
        D2D1_RECT_F outerRect = D2D1::RectF(
            TABLE_LEFT - CUSHION_THICKNESS,
            TABLE_TOP - CUSHION_THICKNESS,
            TABLE_RIGHT + CUSHION_THICKNESS,
            TABLE_BOTTOM + CUSHION_THICKNESS
        );
        pRT->FillRectangle(&outerRect, pFrameBrush);
        SafeRelease(&pFrameBrush);
    }

    // Draw Table Bed (Green Felt)
    pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
    if (!pBrush) return;
    D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
    pRT->FillRectangle(&tableRect, pBrush);
    SafeRelease(&pBrush);

    // Draw Cushions (Red Border)
    pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
    if (!pBrush) return;
    // Top Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    // Bottom Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    // Left Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    // Right Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    SafeRelease(&pBrush);


    // Draw Pockets (Black Circles)
    pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
    if (!pBrush) return;
    for (int i = 0; i < 6; ++i) {
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
        pRT->FillEllipse(&ellipse, pBrush);
    }
    SafeRelease(&pBrush);

    // Draw Headstring Line (White)
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    if (!pBrush) return;
    pRT->DrawLine(
        D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
        D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
        pBrush,
        1.0f // Line thickness
    );
    SafeRelease(&pBrush);

    // Draw Semicircle facing West (flat side East)
    // Draw Semicircle facing East (curved side on the East, flat side on the West)
    ID2D1PathGeometry* pGeometry = nullptr;
    HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
    if (SUCCEEDED(hr) && pGeometry)
    {
        ID2D1GeometrySink* pSink = nullptr;
        hr = pGeometry->Open(&pSink);
        if (SUCCEEDED(hr) && pSink)
        {
            float radius = 60.0f; // Radius for the semicircle
            D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

            // For a semicircle facing East (curved side on the East), use the top and bottom points.
            D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

            pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

            D2D1_ARC_SEGMENT arc = {};
            arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
            arc.size = D2D1::SizeF(radius, radius);
            arc.rotationAngle = 0.0f;
            // Use the correct identifier with the extra underscore:
            arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
            arc.arcSize = D2D1_ARC_SIZE_SMALL;

            pSink->AddArc(&arc);
            pSink->EndFigure(D2D1_FIGURE_END_OPEN);
            pSink->Close();
            SafeRelease(&pSink);

            ID2D1SolidColorBrush* pArcBrush = nullptr;
            //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
            pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
            if (pArcBrush)
            {
                pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                SafeRelease(&pArcBrush);
            }
        }
        SafeRelease(&pGeometry);
    }




}


void DrawBalls(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

    pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

    if (!pBrush || !pStripeBrush) {
        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
        return;
    }


    for (size_t i = 0; i < balls.size(); ++i) {
        const Ball& b = balls[i];
        if (!b.isPocketed) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            // Set main ball color
            pBrush->SetColor(b.color);
            pRT->FillEllipse(&ellipse, pBrush);

            // Draw Stripe if applicable
            if (b.type == BallType::STRIPE) {
                // Draw a white band across the middle (simplified stripe)
                D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                // Need to clip this rectangle to the ellipse bounds - complex!
                // Alternative: Draw two colored arcs leaving a white band.
                // Simplest: Draw a white circle inside, slightly smaller.
                D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                pBrush->SetColor(b.color); // Set back to stripe color
                pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                // Let's try drawing a thick white line across
                // This doesn't look great. Just drawing solid red for stripes for now.
            }

            // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
            // if (b.id != 0 && pTextFormat) {
            //     std::wstring numStr = std::to_wstring(b.id);
            //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
            //     ID2D1SolidColorBrush* pNumBrush = nullptr;
            //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
            //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
            //     // Create a smaller text format...
            //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
            //     SafeRelease(&pNumBrush);
            // }
        }
    }

    SafeRelease(&pBrush);
    SafeRelease(&pStripeBrush);
}


void DrawAimingAids(ID2D1RenderTarget* pRT) {
    // Condition check at start (Unchanged)
    //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
        //currentGameState != BREAKING && currentGameState != AIMING)
    //{
        //return;
    //}
        // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
    // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
    bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
        (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == BREAKING || currentGameState == AIMING);
    // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
    // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
        // NEW Condition: AI is displaying its aim
    bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
        return;
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    ID2D1StrokeStyle* pDashedStyle = nullptr;
    ID2D1SolidColorBrush* pCueBrush = nullptr;
    ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

    // Ensure render target is valid
    if (!pRT) return;

    // Create Brushes and Styles (check for failures)
    HRESULT hr;
    hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
    if FAILED(hr) { SafeRelease(&pBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
    // Create reflection brush (e.g., lighter shade or different color)
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
    // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
    D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
    ID2D1SolidColorBrush* pCyanBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
    if (FAILED(hr)) {
        SafeRelease(&pCyanBrush);
        // handle error if needed
    }
    // Create a Purple brush for primary and secondary lines
    D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
    ID2D1SolidColorBrush* pPurpleBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
    if (FAILED(hr)) {
        SafeRelease(&pPurpleBrush);
        // handle error if needed
    }

    if (pFactory) {
        D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
        strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
        hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        if FAILED(hr) { pDashedStyle = nullptr; }
    }


    // --- Cue Stick Drawing (Unchanged from previous fix) ---
    const float baseStickLength = 150.0f;
    const float baseStickThickness = 4.0f;
    float stickLength = baseStickLength * 1.4f;
    float stickThickness = baseStickThickness * 1.5f;
    float stickAngle = cueAngle + PI;
    float powerOffset = 0.0f;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
    if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
        powerOffset = shotPower * 5.0f;
    }
    D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
    D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
    pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


    // --- Projection Line Calculation ---
    float cosA = cosf(cueAngle);
    float sinA = sinf(cueAngle);
    float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
    D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
    D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

    // Find the first ball hit by the aiming ray
    Ball* hitBall = nullptr;
    float firstHitDistSq = -1.0f;
    D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
    D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

    hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
    if (hitBall) {
        // Calculate the point on the target ball's circumference
        float collisionDist = sqrtf(firstHitDistSq);
        ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
        // Calculate ghost ball position for this specific hit (used for projection consistency)
        ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
    }

    // Find the first rail hit by the aiming ray
    D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
    float minRailDistSq = rayLength * rayLength;
    int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

    // Define table edge segments for intersection checks
    D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
    D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
    D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
    D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

    D2D1_POINT_2F currentIntersection;

    // Check Left Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
    }
    // Check Right Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
    }
    // Check Top Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
    }
    // Check Bottom Rail
    if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
    }


    // --- Determine final aim line end point ---
    D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
    bool aimingAtRail = true;

    if (hitBall && firstHitDistSq < minRailDistSq) {
        // Ball collision is closer than rail collision
        finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
        aimingAtRail = false;
    }

    // --- Draw Primary Aiming Line ---
    pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

    // --- Draw Target Circle/Indicator ---
    D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
    pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

    // --- Draw Projection/Reflection Lines ---
    if (!aimingAtRail && hitBall) {
        // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
        D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
        pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // Calculate target ball projection based on impact line (cue collision point -> target center)
        float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
        // Clamp angle calculation if distance is tiny
        if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
            targetProjectionAngle = cueAngle; // Fallback if overlapping
        }

        D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
        D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
            hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
            hitBall->y + sinf(targetProjectionAngle) * 50.0f
        );
        // Draw solid line for target projection
        //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

    //new code start

                // Dual trajectory with edge-aware contact simulation
        D2D1_POINT_2F dir = {
            targetProjectionEnd.x - targetStartPoint.x,
            targetProjectionEnd.y - targetStartPoint.y
        };
        float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
        dir.x /= dirLen;
        dir.y /= dirLen;

        D2D1_POINT_2F perp = { -dir.y, dir.x };

        // Approximate cue ball center by reversing from tip
        D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
            targetStartPoint.x - dir.x * BALL_RADIUS,
            targetStartPoint.y - dir.y * BALL_RADIUS
        };

        // REAL contact-ball center - use your physics object's center:
        // (replace 'objectBallPos' with whatever you actually call it)
        // (targetStartPoint is already hitBall->x, hitBall->y)
        D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
        //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

       // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
       // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
       // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
       // and 'perp' is perpendicular to 'dir'.
       // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
        /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
            (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
            /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                (targetStartPoint.y - cueBallCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);*/

            // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
        D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

        // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
        float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
            (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
        float absOffset = fabsf(offset);
        float side = (offset >= 0 ? 1.0f : -1.0f);


        // Actual contact point on target ball edge
        D2D1_POINT_2F contactPoint = {
        contactBallCenter.x + perp.x * BALL_RADIUS * side,
        contactBallCenter.y + perp.y * BALL_RADIUS * side
        };

        // Tangent (cut shot) path from contact point
            // Tangent (cut shot) path: from contact point to contact ball center
        D2D1_POINT_2F objectBallDir = {
            contactBallCenter.x - contactPoint.x,
            contactBallCenter.y - contactPoint.y
        };
        float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
        if (oLen != 0.0f) {
            objectBallDir.x /= oLen;
            objectBallDir.y /= oLen;
        }

        const float PRIMARY_LEN = 150.0f; //default=150.0f
        const float SECONDARY_LEN = 150.0f; //default=150.0f
        const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

        D2D1_POINT_2F primaryEnd = {
            targetStartPoint.x + dir.x * PRIMARY_LEN,
            targetStartPoint.y + dir.y * PRIMARY_LEN
        };

        // Secondary line starts from the contact ball's center
        D2D1_POINT_2F secondaryStart = contactBallCenter;
        D2D1_POINT_2F secondaryEnd = {
            secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
            secondaryStart.y + objectBallDir.y * SECONDARY_LEN
        };

        if (absOffset < STRAIGHT_EPSILON)  // straight shot?
        {
            // Straight: secondary behind primary
                    // secondary behind primary {pDashedStyle param at end}
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        else
        {
            // Cut shot: both visible
                    // both visible for cut shot
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        // End improved trajectory logic

    //new code end

        // -- Cue Ball Path after collision (Optional, requires physics) --
        // Very simplified: Assume cue deflects, angle depends on cut angle.
        // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
        // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
        // D2D1_POINT_2F cueProjectionEnd = ...
        // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Accuracy Comment ---
        // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
        // or shots with spin, is limited by the simplified physics model. Real pool physics involves
        // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
        // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

    }
    else if (aimingAtRail && hitRailIndex != -1) {
        // Aiming at a rail: Draw reflection line
        float reflectAngle = cueAngle;
        // Reflect angle based on which rail was hit
        if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
            reflectAngle = PI - cueAngle; // Reflect horizontal component
        }
        else { // Top or Bottom rail
            reflectAngle = -cueAngle; // Reflect vertical component
        }
        // Normalize angle if needed (atan2 usually handles this)
        while (reflectAngle > PI) reflectAngle -= 2 * PI;
        while (reflectAngle <= -PI) reflectAngle += 2 * PI;


        float reflectionLength = 60.0f; // Length of the reflection line
        D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
            finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
            finalLineEnd.y + sinf(reflectAngle) * reflectionLength
        );

        // Draw the reflection line (e.g., using a different color/style)
        pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
    }

    // Release resources
    SafeRelease(&pBrush);
    SafeRelease(&pGhostBrush);
    SafeRelease(&pCueBrush);
    SafeRelease(&pReflectBrush); // Release new brush
    SafeRelease(&pCyanBrush);
    SafeRelease(&pPurpleBrush);
    SafeRelease(&pDashedStyle);
}


void DrawUI(ID2D1RenderTarget* pRT) {
    if (!pTextFormat || !pLargeTextFormat) return;

    ID2D1SolidColorBrush* pBrush = nullptr;
    pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
    if (!pBrush) return;

    // --- Player Info Area (Top Left/Right) --- (Unchanged)
    float uiTop = TABLE_TOP - 80;
    float uiHeight = 60;
    float p1Left = TABLE_LEFT;
    float p1Width = 150;
    float p2Left = TABLE_RIGHT - p1Width;
    D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
    D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

    // Player 1 Info Text (Unchanged)
    std::wostringstream oss1;
    oss1 << player1Info.name.c_str() << L""\n"";
    if (player1Info.assignedType != BallType::NONE) {
        oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss1 << L""(Undecided)"";
    }
    pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
    // Draw Player 1 Side Ball
    if (player1Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player1Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // Player 2 Info Text (Unchanged)
    std::wostringstream oss2;
    oss2 << player2Info.name.c_str() << L""\n"";
    if (player2Info.assignedType != BallType::NONE) {
        oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss2 << L""(Undecided)"";
    }
    pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
    // Draw Player 2 Side Ball
    if (player2Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player2Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
        arrowBackX = playerBox.left - 25.0f;
        arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

        float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
        float notchWidth = 10.0f;

        float cx = arrowBackX;
        float cy = arrowCenterY;

        // Define triangle + rectangle tail shape
        D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
        D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
        D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

        // Rectangle coordinates for the tail portion:
        D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
        D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
        D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
        D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseTop);
                pSink->AddLine(r2); // transition from triangle into rectangle
                pSink->AddLine(r1);
                pSink->AddLine(r4);
                pSink->AddLine(r3);
                pSink->AddLine(baseBot);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }


        SafeRelease(&pArrowBrush);
    }

    //original
/*
    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        if (currentPlayer == 1) {
arrowBackX = p1Rect.left - 25.0f; // Position left of the box
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
            // Define points for right-pointing arrow
            //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
            //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
            //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
            // Enhanced arrow with base rectangle intersection
    float notchDepth = 6.0f; // Depth of square base ""stem""
    float notchWidth = 4.0f; // Thickness of square part

    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
    D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
    D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
        }


        //==================else player 2
        else { // Player 2
         // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
         // Let's keep it consistent: Arrow left of the active player's box, pointing right.
// Let's keep it consistent: Arrow left of the active player's box, pointing right.
arrowBackX = p2Rect.left - 25.0f; // Position left of the box
arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
// Define points for right-pointing arrow
D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

ID2D1PathGeometry* pPath = nullptr;
if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
    ID2D1GeometrySink* pSink = nullptr;
    if (SUCCEEDED(pPath->Open(&pSink))) {
        pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
        pSink->AddLine(pt2);
        pSink->AddLine(pt3);
        pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
        pSink->Close();
        SafeRelease(&pSink);
        pRT->FillGeometry(pPath, pArrowBrush);
    }
    SafeRelease(&pPath);
}
        }
        */

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
    if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
        ID2D1SolidColorBrush* pFoulBrush = nullptr;
        pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
        if (pFoulBrush && pLargeTextFormat) {
            // Calculate Rect for bottom-middle area
            float foulWidth = 200.0f; // Adjust width as needed
            float foulHeight = 60.0f;
            float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
            // Position below the pocketed balls bar
            float foulTop = pocketedBallsBarRect.bottom + 10.0f;
            D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

            // --- Set text alignment to center for foul text ---
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

            // --- Restore default alignment for large text if needed elsewhere ---
            // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            SafeRelease(&pFoulBrush);
        }
    }

    // --- Draw ""Choose Pocket"" Message ---
    if (!pocketCallMessage.empty() && (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2)) {
        ID2D1SolidColorBrush* pMsgBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pMsgBrush);
        if (pMsgBrush && pTextFormat) {
            float msgWidth = 450.0f;
            float msgHeight = 30.0f;
            float msgLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (msgWidth / 2.0f);
            float msgTop = pocketedBallsBarRect.bottom + 10.0f;
            if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) msgTop += 30.0f;

            D2D1_RECT_F msgRect = D2D1::RectF(msgLeft, msgTop, msgLeft + msgWidth, msgTop + msgHeight);

            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(pocketCallMessage.c_str(), (UINT32)pocketCallMessage.length(), pTextFormat, &msgRect, pMsgBrush);
            SafeRelease(&pMsgBrush);
        }
    }


    // Show AI Thinking State (Unchanged from previous step)
    if (currentGameState == AI_THINKING && pTextFormat) {
        ID2D1SolidColorBrush* pThinkingBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
        if (pThinkingBrush) {
            D2D1_RECT_F thinkingRect = p2Rect;
            thinkingRect.top += 20; // Offset within P2 box
            // Ensure default text alignment for this
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
            SafeRelease(&pThinkingBrush);
        }
    }

    SafeRelease(&pBrush);

    // --- Draw CHEAT MODE label if active ---
    if (cheatModeEnabled) {
        ID2D1SolidColorBrush* pCheatBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
        if (pCheatBrush && pTextFormat) {
            D2D1_RECT_F cheatTextRect = D2D1::RectF(
                TABLE_LEFT + 10.0f,
                TABLE_TOP + 10.0f,
                TABLE_LEFT + 200.0f,
                TABLE_TOP + 40.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
        }
        SafeRelease(&pCheatBrush);
    }
}

void DrawPowerMeter(ID2D1RenderTarget* pRT) {
    // Draw Border
    ID2D1SolidColorBrush* pBorderBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
    if (!pBorderBrush) return;
    pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
    SafeRelease(&pBorderBrush);

    // Create Gradient Fill
    ID2D1GradientStopCollection* pGradientStops = nullptr;
    ID2D1LinearGradientBrush* pGradientBrush = nullptr;
    D2D1_GRADIENT_STOP gradientStops[4];
    gradientStops[0].position = 0.0f;
    gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
    gradientStops[1].position = 0.45f;
    gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
    gradientStops[2].position = 0.7f;
    gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
    gradientStops[3].position = 1.0f;
    gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

    pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
    if (pGradientStops) {
        D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
        props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
        props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
        pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
        SafeRelease(&pGradientStops);
    }

    // Calculate Fill Height
    float fillRatio = 0;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Determine if power meter should reflect shot power (human aiming or AI preparing)
    bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
    // NEW Condition: AI is displaying its aim, so show its chosen power
    bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
        fillRatio = shotPower / MAX_SHOT_POWER;
    }
    float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
    D2D1_RECT_F fillRect = D2D1::RectF(
        powerMeterRect.left,
        powerMeterRect.bottom - fillHeight,
        powerMeterRect.right,
        powerMeterRect.bottom
    );

    if (pGradientBrush) {
        pRT->FillRectangle(&fillRect, pGradientBrush);
        SafeRelease(&pGradientBrush);
    }

    // Draw scale notches
    ID2D1SolidColorBrush* pNotchBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
    if (pNotchBrush) {
        for (int i = 0; i <= 8; ++i) {
            float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
            pRT->DrawLine(
                D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                pNotchBrush,
                1.5f
            );
        }
        SafeRelease(&pNotchBrush);
    }

    // Draw ""Power"" Label Below Meter
    if (pTextFormat) {
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
        if (pTextBrush) {
            D2D1_RECT_F textRect = D2D1::RectF(
                powerMeterRect.left - 20.0f,
                powerMeterRect.bottom + 8.0f,
                powerMeterRect.right + 20.0f,
                powerMeterRect.bottom + 38.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
            SafeRelease(&pTextBrush);
        }
    }

    // Draw Glow Effect if fully charged or fading out
    static float glowPulse = 0.0f;
    static bool glowIncreasing = true;
    static float glowFadeOut = 0.0f; // NEW: tracks fading out

    if (shotPower >= MAX_SHOT_POWER * 0.99f) {
        // While fully charged, keep pulsing normally
        if (glowIncreasing) {
            glowPulse += 0.02f;
            if (glowPulse >= 1.0f) glowIncreasing = false;
        }
        else {
            glowPulse -= 0.02f;
            if (glowPulse <= 0.0f) glowIncreasing = true;
        }
        glowFadeOut = 1.0f; // Reset fade out to full
    }
    else if (glowFadeOut > 0.0f) {
        // If shot fired, gradually fade out
        glowFadeOut -= 0.02f;
        if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
    }

    if (glowFadeOut > 0.0f) {
        ID2D1SolidColorBrush* pGlowBrush = nullptr;
        float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
        pRT->CreateSolidColorBrush(
            D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
            &pGlowBrush
        );
        if (pGlowBrush) {
            float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
            float glowCenterY = powerMeterRect.top;
            D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                12.0f + 3.0f * glowPulse,
                6.0f + 2.0f * glowPulse
            );
            pRT->FillEllipse(&glowEllipse, pGlowBrush);
            SafeRelease(&pGlowBrush);
        }
    }
}

void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pWhiteBrush = nullptr;
    ID2D1SolidColorBrush* pRedBrush = nullptr;

    pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
    pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

    if (!pWhiteBrush || !pRedBrush) {
        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
        return;
    }

    // Draw White Ball Background
    D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
    pRT->FillEllipse(&bgEllipse, pWhiteBrush);
    pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


    // Draw Red Dot for Spin Position
    float dotRadius = 4.0f;
    float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
    float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
    D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
    pRT->FillEllipse(&dotEllipse, pRedBrush);

    SafeRelease(&pWhiteBrush);
    SafeRelease(&pRedBrush);
}


void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBgBrush = nullptr;
    ID2D1SolidColorBrush* pBallBrush = nullptr;

    // Ensure render target is valid before proceeding
    if (!pRT) return;

    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
    if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
    if (FAILED(hr)) {
        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
        return; // Exit if brush creation fails
    }

    // Draw the background bar (rounded rect)
    D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
    float baseAlpha = 0.8f;
    float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
    float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
    pBgBrush->SetOpacity(finalAlpha);
    pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
    pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

    // --- Draw small circles for pocketed balls inside the bar ---

    // Calculate dimensions based on the bar's height for better scaling
    float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
    float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
    float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
    float padding = spacing * 0.75f; // Add padding from the edges
    float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

    // Starting X positions with padding
    float currentX_P1 = pocketedBallsBarRect.left + padding;
    float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

    int p1DrawnCount = 0;
    int p2DrawnCount = 0;
    const int maxBallsToShow = 7; // Max balls per player in the bar

    for (const auto& b : balls) {
        if (b.isPocketed) {
            // Skip cue ball and 8-ball in this indicator
            if (b.id == 0 || b.id == 8) continue;

            bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
            bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

            if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P1 balls from left to right
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p1DrawnCount++;
            }
            else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P2 balls from right to left
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p2DrawnCount++;
            }
            // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
            // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
        }
    }

    SafeRelease(&pBgBrush);
    SafeRelease(&pBallBrush);
}

void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
    if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
        return; // Only show when placing/dragging
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

    if (pGhostBrush) {
        D2D1_POINT_2F drawPos;
        if (isDraggingCueBall) {
            drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
        }
        else {
            // If not dragging but in placement state, show at current ball pos
            drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
        }

        // Check if the placement is valid before drawing differently?
        bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
        bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

        if (!isValid) {
            // Maybe draw red outline if invalid placement?
            pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
        }


        D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
        pRT->FillEllipse(&ghostEllipse, pGhostBrush);
        pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

        SafeRelease(&pGhostBrush);
    }
}

void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
    int pocketToIndicate = -1;
    bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

    if (isHumanChoosing) {
        // While actively choosing, the indicator follows the hover.
        pocketToIndicate = currentlyHoveredPocket;
        // If not hovering anything, show the currently selected pocket (which defaults to 5).
        if (pocketToIndicate == -1) {
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
    }
    else if (IsPlayerOnEightBall(currentPlayer)) {
        // Once choice is made, lock the indicator on the called pocket.
        pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
    }

    if (pocketToIndicate < 0 || pocketToIndicate > 5) {
        return;
    }

    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
    if (!pArrowBrush) return;

    D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
    float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
    float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
    float arrowShaftWidth = arrowHeadSize * 0.4f;
    float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
    D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

    if (targetPocketCenter.y == TABLE_TOP) {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
    }
    else {
        tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
        baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
        shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
        shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
        shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
        shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
    }

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
            pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
    SafeRelease(&pArrowBrush);
}"
FbsqMKzJ,8 bit ring rotation,pintcat,Bash,Friday 27th of June 2025 10:36:04 AM CDT,"#!/bin/sh
# 8-Bit ring rotation to the left

VAL=$(($1 & 0xFF))                         # limit mask to 8 bit
while [ $((LOOP=$LOOP+1)) -le $2 ]; do
	HBIT=$((($VAL & 0x80) >> 7))           # extract highest bit (bit 7)
	VAL=$(((($VAL << 1) | HBIT) & 0xFF))   # rotate left, mask to 8 bit
done
echo $VAL
"
as5sazRr,addition - arithmetic function which uses only logic functions,pintcat,Bash,Friday 27th of June 2025 10:34:38 AM CDT,"#!/bin/sh

A=$1
B=$2
while [ $B -gt 0 ]; do
    CARRY=$((A & B))
    A=$((A ^ B))
    B=$((CARRY << 1))
done
echo $1""+""$2""=""$A
"
8pKjNVaU,transcript code,Ayan143,JavaScript,Friday 27th of June 2025 10:21:14 AM CDT,"require('dotenv').config();
const { Client, GatewayIntentBits } = require('discord.js');
const { DateTime } = require('luxon');
const escapeHtml = require('escape-html');
const crypto = require('crypto');
const mongoose = require('mongoose');

// Database Models
const GuildSchema = new mongoose.Schema({
  id: { type: String, required: true, unique: true },
  name: String,
  icon: String,
  updatedAt: { type: Date, default: Date.now }
});

const ChannelSchema = new mongoose.Schema({
  id: { type: String, required: true, unique: true },
  guildId: { type: String, required: true },
  name: String,
  topic: String,
  updatedAt: { type: Date, default: Date.now }
});

const MessageSchema = new mongoose.Schema({
  id: { type: String, required: true, unique: true },
  channelId: { type: String, required: true },
  author: {
    id: String,
    username: String,
    avatar: String,
    bot: Boolean,
    color: String
  },
  content: String,
  attachments: [{
    url: String,
    proxyURL: String,
    name: String,
    size: Number,
    contentType: String,
    width: Number,
    height: Number
  }],
  embeds: [Object],
  stickers: [Object],
  timestamp: Number,
  editedTimestamp: Number,
  updatedAt: { type: Date, default: Date.now }
});

const Guild = mongoose.model('Guild', GuildSchema);
const Channel = mongoose.model('Channel', ChannelSchema);
const Message = mongoose.model('Message', MessageSchema);

// Security Configuration
const ALLOWED_ORIGINS = [
  'https://zia-bot-trans-api.netlify.app',
  'https://discord.com'
];
const BDFD_AGENT_PREFIX = 'BDFD-';
const MAX_REQUESTS_PER_MINUTE = 10;
const requestCounts = new Map();

// Initialize Discord client outside handler
const discordClient = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

// Connect to Discord when Lambda starts
let discordReady = false;
discordClient.login(process.env.DISCORD_BOT_TOKEN)
  .then(() => discordReady = true)
  .catch(err => console.error('Discord login failed:', err));

// Database Connection Handler
let dbConnection = null;

async function getDatabaseConnection() {
  if (dbConnection) return dbConnection;
  
  try {
    dbConnection = await mongoose.connect(process.env.MONGODB_URI, {
      serverSelectionTimeoutMS: 3000,
      maxPoolSize: 1,
      socketTimeoutMS: 30000
    });
    
    mongoose.connection.on('error', err => {
      console.error('MongoDB connection error:', err);
      dbConnection = null;
    });
    
    return dbConnection;
  } catch (err) {
    console.error('MongoDB connection failed:', err);
    dbConnection = null;
    throw err;
  }
}

// Rate limiting middleware
function checkRateLimit(ip) {
  const now = Date.now();
  const windowStart = now - 60000;
  
  if (!requestCounts.has(ip)) {
    requestCounts.set(ip, { count: 1, lastRequest: now });
    return true;
  }

  const record = requestCounts.get(ip);
  if (record.lastRequest < windowStart) {
    record.count = 1;
    record.lastRequest = now;
    return true;
  }

  if (record.count >= MAX_REQUESTS_PER_MINUTE) {
    return false;
  }

  record.count++;
  record.lastRequest = now;
  return true;
}

// Token generation
function generateSignedToken(guildId, channelId, limit) {
  const secret = process.env.URL_SIGNING_SECRET;
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(`${guildId}:${channelId}:${limit}`);
  return hmac.digest('hex');
}

function verifySignedToken(token, guildId, channelId, limit) {
  const expectedToken = generateSignedToken(guildId, channelId, limit);
  return crypto.timingSafeEqual(
    Buffer.from(token),
    Buffer.from(expectedToken)
  );
}

// Cache updater functions
async function updateGuildCache(guild) {
  await getDatabaseConnection();
  await Guild.findOneAndUpdate(
    { id: guild.id },
    {
      name: guild.name,
      icon: guild.iconURL({ size: 256 }),
      updatedAt: new Date()
    },
    { upsert: true, new: true }
  );
}

async function updateChannelCache(channel) {
  await getDatabaseConnection();
  await Channel.findOneAndUpdate(
    { id: channel.id },
    {
      guildId: channel.guild.id,
      name: channel.name,
      topic: channel.topic,
      updatedAt: new Date()
    },
    { upsert: true, new: true }
  );
}

async function updateMessageCache(message) {
  await getDatabaseConnection();
  await Message.findOneAndUpdate(
    { id: message.id },
    {
      channelId: message.channel.id,
      author: {
        id: message.author.id,
        username: message.author.username,
        avatar: message.author.displayAvatarURL({ size: 256 }),
        bot: message.author.bot,
        color: message.member?.displayHexColor || '#7289da'
      },
      content: message.content,
      attachments: Array.from(message.attachments.values()).map(attach => ({
        url: attach.url,
        proxyURL: attach.proxyURL,
        name: attach.name,
        size: attach.size,
        contentType: attach.contentType,
        width: attach.width,
        height: attach.height
      })),
      embeds: message.embeds,
      stickers: Array.from(message.stickers.values()),
      timestamp: message.createdTimestamp,
      editedTimestamp: message.editedTimestamp,
      updatedAt: new Date()
    },
    { upsert: true, new: true }
  );
}

// Secure origin check
function isRequestAllowed(event) {
  if (event.path.includes('/download')) {
    const { token, guildId, channelId, limit } = event.queryStringParameters;
    if (token && guildId && channelId && limit) {
      return verifySignedToken(token, guildId, channelId, limit);
    }
  }

  const isBDFD = event.headers['user-agent']?.startsWith(BDFD_AGENT_PREFIX);
  if (isBDFD) return true;

  const origin = event.headers.origin || event.headers.referer;
  return ALLOWED_ORIGINS.some(o => origin?.includes(o));
}

// Main handler
exports.handler = async (event) => {
  try {
    // Get the real IP
    const ips = (event.headers['x-forwarded-for'] || '').split(',').map(ip => ip.trim());
    const ip = ips.length > 0 ? ips[0] : 'unknown';

    // Rate limiting
    if (!checkRateLimit(ip)) {
      return {
        statusCode: 429,
        body: JSON.stringify({ error: 'Too many requests' })
      };
    }

    // Security check
    if (!isRequestAllowed(event)) {
      return {
        statusCode: 403,
        body: JSON.stringify({ 
          error: 'Unauthorized',
          solution: 'Use the official download link provided by the bot'
        })
      };
    }

    const prettyBytes = (await import('pretty-bytes')).default;
    const { guildId, channelId, json, preview } = event.queryStringParameters;
    const limit = Math.min(parseInt(event.queryStringParameters.limit) || 100, 500);

    if (!guildId || !channelId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Missing guildId or channelId' })
      };
    }

    // Wait for Discord client to be ready with timeout
    const discordReadyPromise = new Promise((resolve) => {
      const check = () => {
        if (discordReady) return resolve(true);
        setTimeout(check, 100);
      };
      check();
    });

    await Promise.race([
      discordReadyPromise,
      new Promise((_, reject) => setTimeout(() => reject(new Error('Discord client connection timeout')), 3000))
    ]);

    // Try to get fresh data first
    let guildInfo, channelInfo, messages = [];
    try {
      const guild = await discordClient.guilds.fetch(guildId);
      guildInfo = {
        id: guild.id,
        name: guild.name,
        icon: guild.iconURL({ size: 256 })
      };
      
      const channel = await guild.channels.fetch(channelId);
      channelInfo = {
        id: channel.id,
        name: channel.name,
        topic: channel.topic
      };

      // Update cache with fresh data
      await Promise.all([
        updateGuildCache(guild),
        updateChannelCache(channel)
      ]);

      // Fetch and cache messages with timeout
      const freshMessages = await Promise.race([
        channel.messages.fetch({ limit }),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Message fetch timeout')), 5000))
      ]);
      
      messages = Array.from(freshMessages.values());
      await Promise.all(messages.map(msg => updateMessageCache(msg)));
    } catch (error) {
      console.log('Using cached data due to error:', error.message);
      
      // Fallback to cached data
      await getDatabaseConnection();
      guildInfo = await Guild.findOne({ id: guildId }) || { 
        id: guildId, 
        name: 'Deleted Server', 
        icon: null 
      };
      
      channelInfo = await Channel.findOne({ id: channelId }) || { 
        id: channelId, 
        name: 'deleted-channel', 
        topic: null 
      };
      
      messages = await Message.find({ channelId })
        .sort({ timestamp: -1 })
        .limit(limit)
        .lean();
    }

    // Build transcript data
    const transcriptData = {
      guild: guildInfo,
      channel: channelInfo,
      messages: messages.map(msg => ({
        id: msg.id,
        author: msg.author,
        content: msg.content,
        attachments: msg.attachments,
        embeds: msg.embeds,
        stickers: msg.stickers,
        timestamp: msg.timestamp,
        editedTimestamp: msg.editedTimestamp
      })),
      generatedAt: Date.now(),
      limit: limit
    };

    const transcriptHTML = generateTranscriptHTML(transcriptData, prettyBytes);
    const filename = `transcript-${channelInfo.name}-${DateTime.now().toFormat('yyyy-LL-dd')}.html`;
    const downloadToken = generateSignedToken(guildId, channelId, limit);

    // Special response handling for BDFD
    const isBDFD = event.headers['user-agent']?.startsWith(BDFD_AGENT_PREFIX);
    if (isBDFD) {
      return {
        statusCode: 200,
        headers: { 
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache'
        },
        body: JSON.stringify({
          success: true,
          downloadUrl: `https://${event.headers.host}/download?guildId=${guildId}&channelId=${channelId}&limit=${limit}&token=${downloadToken}`,
          filename,
          messageCount: transcriptData.messages.length,
          channelName: channelInfo.name,
          guildName: guildInfo.name,
          generationDate: DateTime.now().toLocaleString(DateTime.DATETIME_FULL),
          isBDFD: true,
          cacheStatus: messages.length > 0 ? 'CACHED' : 'NO_CACHE'
        })
      };
    }

    // JSON response for API requests
    if (json || event.headers['user-agent']?.includes('DiscordBot')) {
      return {
        statusCode: 200,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          success: true,
          downloadUrl: `https://${event.headers.host}/download?guildId=${guildId}&channelId=${channelId}&limit=${limit}&token=${downloadToken}`,
          filename,
          messageCount: transcriptData.messages.length,
          channelName: channelInfo.name,
          guildName: guildInfo.name,
          generationDate: DateTime.now().toLocaleString(DateTime.DATETIME_FULL),
          mobileInstructions: 'Long-press link and ""Open in new tab"" for best results',
          cacheStatus: messages.length > 0 ? 'CACHED' : 'NO_CACHE'
        })
      };
    }

    // Default HTML response
    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'text/html',
        'Content-Disposition': preview ? '' : `attachment; filename=""${filename}""`
      },
      body: transcriptHTML
    };

  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ 
        error: error.message,
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
      })
    };
  }
};

function generateTranscriptHTML(data, prettyBytes) {
  const messagesHTML = data.messages.map(msg => {
    let attachmentsHTML = '';
    if (msg.attachments && msg.attachments.length > 0) {
      attachmentsHTML = `<div class=""attachments"">${
        msg.attachments.map(attach => {
          const imageUrl = attach.proxyURL || attach.url;
          
          if (attach.contentType?.startsWith('image/')) {
            return `
              <div class=""attachment image"">
                <img src=""${imageUrl}"" 
                     alt=""${attach.name}"" 
                     loading=""lazy""
                     width=""${attach.width || ''}""
                     height=""${attach.height || ''}"">
              </div>`;
          }
          return `
            <div class=""attachment file"">
              <a href=""${attach.url}"" target=""_blank"">📄 ${attach.name} (${prettyBytes(attach.size)})</a>
            </div>`;
        }).join('')
      }</div>`;
    }

    let embedsHTML = '';
    if (msg.embeds && msg.embeds.length > 0) {
      embedsHTML = `<div class=""embeds"">${
        msg.embeds.map(embed => `
          <div class=""embed"">
            ${embed.title ? `<div class=""embed-title""><a href=""${embed.url || '#'}"" target=""_blank"">${escapeHtml(embed.title)}</a></div>` : ''}
            ${embed.description ? `<div class=""embed-description"">${escapeHtml(embed.description)}</div>` : ''}
            ${embed.image ? `<img src=""${embed.image.proxyURL || embed.image.url}"" class=""embed-image"" loading=""lazy"">` : ''}
          </div>
        `).join('')
      }</div>`;
    }

    let stickersHTML = '';
    if (msg.stickers && msg.stickers.length > 0) {
      stickersHTML = `<div class=""stickers"">${
        msg.stickers.map(sticker => `
          <div class=""sticker"">
            <img src=""${sticker.url}"" alt=""${sticker.name}"" loading=""lazy"">
          </div>
        `).join('')
      }</div>`;
    }

    return `
      <div class=""message"" data-message-id=""${msg.id}"">
        <div class=""message-header"">
          <img src=""${msg.author.avatar}"" 
               alt=""${msg.author.username}"" 
               class=""avatar"">
          <span class=""username"" style=""color: ${msg.author.color || '#7289da'}"">
            ${escapeHtml(msg.author.username)}
            ${msg.author.bot ? '<span class=""bot-tag"">BOT</span>' : ''}
          </span>
          <span class=""timestamp"" data-timestamp=""${msg.timestamp}"">
            ${DateTime.fromMillis(msg.timestamp).toLocaleString(DateTime.DATETIME_MED)}
          </span>
        </div>
        <div class=""message-content"">
          ${escapeHtml(msg.content || '').replace(/\n/g, '<br>')}
          ${attachmentsHTML}
          ${embedsHTML}
          ${stickersHTML}
        </div>
      </div>
    `;
  }).join('');

  return `<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
  <title>Transcript: #${escapeHtml(data.channel.name)} | ${escapeHtml(data.guild.name)}</title>
  <style>
    :root {
      --background-primary: #36393f;
      --background-secondary: #2f3136;
      --background-tertiary: #202225;
      --text-normal: #dcddde;
      --text-muted: #72767d;
      --text-link: #00b0f4;
      --brand-color: #5865f2;
      --online-color: #3ba55c;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Whitney', 'Helvetica Neue', Helvetica, Arial, sans-serif;
      background-color: var(--background-primary);
      color: var(--text-normal);
      line-height: 1.5;
      padding: 20px;
      max-width: 1000px;
      margin: 0 auto;
    }

    .header {
      background-color: var(--background-secondary);
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      position: relative;
    }

    .channel-name {
      font-size: 1.5em;
      font-weight: bold;
      color: white;
      margin-bottom: 5px;
    }

    .guild-name {
      color: var(--text-muted);
      font-size: 1.1em;
      margin-bottom: 10px;
    }

    .transcript-info {
      color: var(--text-muted);
      font-size: 0.9em;
      line-height: 1.4;
    }

    .message {
      background-color: var(--background-secondary);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      position: relative;
    }

    .message:hover {
      background-color: var(--background-tertiary);
    }

    .message-header {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      flex-wrap: wrap;
      gap: 6px;
    }

    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      flex-shrink: 0;
    }

    .username {
      font-weight: 600;
      margin-right: 6px;
    }

    .bot-tag {
      background-color: var(--brand-color);
      color: white;
      font-size: 0.7em;
      padding: 2px 4px;
      border-radius: 3px;
      margin-left: 4px;
      vertical-align: middle;
    }

    .timestamp {
      color: var(--text-muted);
      font-size: 0.8em;
      cursor: pointer;
    }

    .timestamp:hover {
      text-decoration: underline;
    }

    .message-content {
      margin-left: 52px;
      word-break: break-word;
    }

    .message-content > br {
      content: """";
      display: block;
      margin-top: 0.5em;
    }

    .attachments {
      margin-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .attachment.image img {
      max-width: 500px;
      max-height: 400px;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .attachment.image img:hover {
      transform: scale(1.02);
    }

    .attachment.file a {
      color: var(--text-link);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background-color: var(--background-tertiary);
      border-radius: 4px;
    }

    .attachment.file a:hover {
      text-decoration: underline;
    }

    .embeds {
      margin-top: 8px;
      max-width: 520px;
    }

    .embed {
      border-left: 4px solid var(--brand-color);
      padding: 8px 12px 12px;
      background-color: var(--background-tertiary);
      border-radius: 0 4px 4px 0;
      margin-top: 8px;
    }

    .embed-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-link);
    }

    .embed-title a {
      color: inherit;
      text-decoration: none;
    }

    .embed-title a:hover {
      text-decoration: underline;
    }

    .embed-description {
      margin-bottom: 8px;
      line-height: 1.4;
    }

    .embed-image {
      max-width: 100%;
      border-radius: 4px;
      margin-top: 8px;
    }

    .stickers {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 8px;
    }

    .sticker img {
      max-width: 160px;
      max-height: 160px;
      border-radius: 4px;
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .message-content {
        margin-left: 0;
        padding-top: 10px;
      }

      .attachment.image img,
      .embed-image,
      .sticker img {
        max-width: 100%;
      }

      .embeds {
        max-width: 100%;
      }
    }

    @media print {
      body {
        background-color: white !important;
        color: black !important;
        padding: 0;
        font-size: 12pt;
      }

      .header {
        background-color: white !important;
        border-bottom: 1px solid #eee;
        padding: 10px;
      }

      .channel-name {
        color: black !important;
      }

      .message {
        page-break-inside: avoid;
        background-color: white !important;
        border: 1px solid #eee;
        padding: 10px;
        margin-bottom: 10px;
      }

      .timestamp {
        color: #666 !important;
      }

      .embed {
        background-color: #f9f9f9 !important;
      }

      .attachment.file a {
        color: #0066cc;
      }
    }

    @keyframes highlight {
      0% { background-color: rgba(114, 137, 218, 0.3); }
      100% { background-color: transparent; }
    }

    .message.highlight {
      animation: highlight 2s ease-out;
    }
  </style>
</head>
<body>
  <div class=""header"">
    ${data.guild.icon ? `<img src=""${data.guild.icon}"" alt=""Guild icon"" style=""width:50px;height:50px;border-radius:50%;position:absolute;right:20px;top:20px;"">` : ''}
    <div class=""channel-name"">#${escapeHtml(data.channel.name)}</div>
    <div class=""guild-name"">${escapeHtml(data.guild.name)}</div>
    <div class=""transcript-info"">
      Transcript generated on ${DateTime.fromMillis(data.generatedAt).toLocaleString(DateTime.DATETIME_FULL)}<br>
      ${data.messages.length} messages | Channel ID: ${data.channel.id}<br>
      ${data.channel.topic ? `Channel topic: ${escapeHtml(data.channel.topic)}` : ''}
      ${data.messages.length > 0 && data.messages[0].timestamp < Date.now() - 86400000 ? 
       '<br><strong>Note:</strong> This transcript contains cached historical data' : ''}
    </div>
  </div>
  
  ${messagesHTML}

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      if (!window.location.search.includes('preview=true')) {
        const blob = new Blob([document.documentElement.outerHTML], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = document.title + '.html';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        }, 100);
      }

      document.querySelectorAll('.timestamp').forEach(el => {
        el.addEventListener('click', () => {
          const timestamp = el.getAttribute('data-timestamp');
          navigator.clipboard.writeText(new Date(parseInt(timestamp)).toISOString());
          const originalText = el.textContent;
          el.textContent = 'Copied!';
          setTimeout(() => el.textContent = originalText, 2000);
        });
      });

      if (window.location.hash) {
        const message = document.querySelector(\`[data-message-id=""\${window.location.hash.substring(1)}""]\`);
        if (message) {
          message.classList.add('highlight');
          message.scrollIntoView({ behavior: 'smooth' });
        }
      }
    });
  </script>
</body>
</html>`;
      }"
9xYEU8W1,AeroDal Python Disnake,hamster69,Python,Friday 27th of June 2025 09:57:33 AM CDT,"import disnake
from disnake.ext import commands

intents = disnake.Intents.default()
intents.message_content = True
bot = commands.Bot(
    command_prefix=disnake.ext.commands.when_mentioned, intents=intents)


@bot.command()
async def aero(ctx):
    await ctx.send(""# <:Untitleddesign10:1388159576217616487> AERODAL CODE WORKING "")


@bot.command()
async def aero2(ctx, *, message: str):
    await ctx.send(f""<:Untitleddesign10:1388159576217616487> | Your message is {message}"")

bot.run(""bottoken"")
"
GM8KTmjZ,Untitled,Azzz_4565,Java,Friday 27th of June 2025 09:38:46 AM CDT,"-- Ultra-Fast Instant Respawn System
-- Optimized for maximum speed and reliability

local Players = game:GetService(""Players"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local RunService = game:GetService(""RunService"")
local LocalPlayer = Players.LocalPlayer

-- Performance optimizations
local taskwait = task.wait
local taskspawn = task.spawn
local findFirstChild = game.FindFirstChild

-- State management for bulletproof operation
local ConnectionCache = {}
local RespawnState = {
    Active = false,
    LastDeath = 0,
    ConnectionId = 0
}

-- Ultra-optimized respawn function with multiple fallbacks
local function InstantRespawn()
    local currentTime = tick()
    
    -- Prevent spam calls within same frame
    if currentTime - RespawnState.LastDeath < 0. then
        return
    end
    
    RespawnState.LastDeath = currentTime
    
    -- Multiple respawn methods for maximum reliability
    taskspawn(function()
        -- Primary method: Guide remote
        local guide = findFirstChild(ReplicatedStorage, ""Guide"")
        if guide and guide:IsA(""RemoteEvent"") then
            guide:FireServer()
        end
        
        -- Fallback method: LoadCharacter
        pcall(function()
            LocalPlayer:LoadCharacter()
        end)
        
        -- Emergency fallback: Teleport to spawn
        taskwait(0.1)
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChildWhichIsA(""Humanoid"")
            if humanoid then
                humanoid.Health = 0
                taskwait(0.1)
                if findFirstChild(ReplicatedStorage, ""Guide"") then
                    ReplicatedStorage.Guide:FireServer()
                end
            end
        end
    end)
end

-- Bulletproof connection system
local function SetupRespawnConnection(character)
    if not character then return end
    
    RespawnState.ConnectionId = RespawnState.ConnectionId + 1
    local connectionId = RespawnState.ConnectionId
    
    -- Clear any existing connections for this character
    if ConnectionCache[character] then
        for _, conn in pairs(ConnectionCache[character]) do
            if conn and conn.Connected then
                conn:Disconnect()
            end
        end
    end
    ConnectionCache[character] = {}
    
    -- Multi-layered death detection
    local function setupHumanoidConnection()
        local humanoid = character:FindFirstChildWhichIsA(""Humanoid"")
        if humanoid then
            -- Primary death detection
            local deathConn = humanoid.Died:Connect(function()
                if RespawnState.ConnectionId == connectionId then
                    InstantRespawn()
                end
            end)
            
            -- Secondary health-based detection
            local healthConn = humanoid.HealthChanged:Connect(function(health)
                if health <= 0 and RespawnState.ConnectionId == connectionId then
                    InstantRespawn()
                end
            end)
            
            -- Tertiary state-based detection
            local stateConn = humanoid.StateChanged:Connect(function(oldState, newState)
                if newState == Enum.HumanoidStateType.Dead and RespawnState.ConnectionId == connectionId then
                    InstantRespawn()
                end
            end)
            
            ConnectionCache[character] = {deathConn, healthConn, stateConn}
            return true
        end
        return false
    end
    
    -- Immediate setup
    if not setupHumanoidConnection() then
        -- Wait for humanoid if not immediately available
        local attempts = 0
        local setupLoop
        setupLoop = RunService.Heartbeat:Connect(function()
            attempts = attempts + 1
            if setupHumanoidConnection() or attempts > 300 then -- 5 second timeout
                setupLoop:Disconnect()
            end
        end)
    end
end

-- Unbreakable character monitoring
local function MonitorCharacter()
    RespawnState.Active = true
    
    -- Handle current character
    if LocalPlayer.Character then
        SetupRespawnConnection(LocalPlayer.Character)
    end
    
    -- Handle future characters
    local charAddedConn = LocalPlayer.CharacterAdded:Connect(function(character)
        if RespawnState.Active then
            -- Immediate setup
            SetupRespawnConnection(character)
            
            -- Backup setup after short delay
            taskspawn(function()
                taskwait(0)
                if character.Parent and RespawnState.Active then
                    SetupRespawnConnection(character)
                end
            end)
        end
    end)
    
    -- Cleanup on character removal
    local charRemovingConn = LocalPlayer.CharacterRemoving:Connect(function(character)
        if ConnectionCache[character] then
            for _, conn in pairs(ConnectionCache[character]) do
                if conn and conn.Connected then
                    conn:Disconnect()
                end
            end
            ConnectionCache[character] = nil
        end
    end)
    
    -- Store main connections for potential cleanup
    ConnectionCache.Main = {charAddedConn, charRemovingConn}
end

-- Continuous monitoring system (unkillable)
local function CreateWatchdog()
    taskspawn(function()
        while true do
            if not RespawnState.Active then
                MonitorCharacter()
            end
            
            -- Verify connections are still active
            if LocalPlayer.Character then
                local character = LocalPlayer.Character
                if not ConnectionCache[character] or #ConnectionCache[character] == 0 then
                    SetupRespawnConnection(character)
                end
            end
            
            -- Ultra-fast monitoring loop
            taskwait(0) -- 1ms intervals for instant response
        end
    end)
end

-- Initialize the system
CreateWatchdog()

-- Additional protection against script interference
local function ProtectScript()
    -- Prevent other scripts from interfering
    taskspawn(function()
        while true do
            if not RespawnState.Active then
                CreateWatchdog()
            end
            taskwait(0)
        end
    end)
end

ProtectScript()

-- Emergency manual trigger (call this if needed)
_G.ForceRespawn = InstantRespawn

print(""Ultra-Fast Instant Respawn System Active - Maximum Performance Mode"")"
ryHNrVuL,Alt# Pool Modfiication By ChatGPT4o (MAY BE BROKEN),alien_fx_fiend,C++,Friday 27th of June 2025 08:49:57 AM CDT,"#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#include <d2d1.h>
#include <dwrite.h>
#include <fstream> // For file I/O
#include <iostream> // For some basic I/O, though not strictly necessary for just file ops
#include <vector>
#include <cmath>
#include <string>
#include <sstream> // Required for wostringstream
#include <algorithm> // Required for std::max, std::min
#include <ctime>    // Required for srand, time
#include <cstdlib> // Required for srand, rand (often included by others, but good practice)
#include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
#include <mmsystem.h> // For PlaySound
#include <tchar.h> //midi func
#include <thread>
#include <atomic>
#include ""resource.h""

#pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""dwrite.lib"")
#pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

// --- Constants ---
const float PI = 3.1415926535f;
const float BALL_RADIUS = 10.0f;
const float TABLE_LEFT = 100.0f;
const float TABLE_TOP = 100.0f;
const float TABLE_WIDTH = 700.0f;
const float TABLE_HEIGHT = 350.0f;
const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
const float CUSHION_THICKNESS = 20.0f;
const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
const float MAX_SHOT_POWER = 15.0f;
const float FRICTION = 0.985f; // Friction factor per frame
const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
const UINT ID_TIMER = 1;
const int TARGET_FPS = 60; // Target frames per second for timer

// --- Enums ---
// --- MODIFIED/NEW Enums ---
enum GameState {
    SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
    PRE_BREAK_PLACEMENT,// Player placing cue ball for break
    BREAKING,           // Player is aiming/shooting the break shot
    AIMING,             // Player is aiming
    AI_THINKING,        // NEW: AI is calculating its move
    SHOT_IN_PROGRESS,   // Balls are moving
    ASSIGNING_BALLS,    // Turn after break where ball types are assigned
    PLAYER1_TURN,
    PLAYER2_TURN,
    BALL_IN_HAND_P1,
    BALL_IN_HAND_P2,
    SELECT_EIGHT_POCKET_P1,  // NEW: human must choose pocket for 8-Ball
    SELECT_EIGHT_POCKET_P2,  // NEW: CPU must choose pocket for 8-Ball
    GAME_OVER
};

enum BallType {
    NONE,
    SOLID,  // Yellow (1-7)
    STRIPE, // Red (9-15)
    EIGHT_BALL, // Black (8)
    CUE_BALL // White (0)
};

// NEW Enums for Game Mode and AI Difficulty
enum GameMode {
    HUMAN_VS_HUMAN,
    HUMAN_VS_AI
};

enum AIDifficulty {
    EASY,
    MEDIUM,
    HARD
};

enum OpeningBreakMode {
    CPU_BREAK,
    P1_BREAK,
    FLIP_COIN_BREAK
};

// --- Structs ---
struct Ball {
    int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
    BallType type;
    float x, y;
    float vx, vy;
    D2D1_COLOR_F color;
    bool isPocketed;
};

struct PlayerInfo {
    BallType assignedType;
    int ballsPocketedCount;
    std::wstring name;
};

// --- Global Variables ---

// Direct2D & DirectWrite
ID2D1Factory* pFactory = nullptr;
//ID2D1Factory* g_pD2DFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

// Game State
HWND hwndMain = nullptr;
GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
std::vector<Ball> balls;
int currentPlayer = 1; // 1 or 2
PlayerInfo player1Info = { BallType::NONE, 0, L""Player 1"" };
PlayerInfo player2Info = { BallType::NONE, 0, L""CPU"" }; // Default P2 name
bool foulCommitted = false;
std::wstring gameOverMessage = L"""";
int selectedPocketIndex = 2;      // Default Top-Right pocket
bool eightPocketSelected = false; // Has the pocket been chosen this turn?
bool eightBallPocketed = false;
bool firstBallPocketedAfterBreak = false;
std::vector<int> pocketedThisTurn;
// --- NEW: Foul Tracking Globals ---
int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
// --- End New Foul Tracking Globals ---

// NEW Game Mode/AI Globals
GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
// bool aiIsThinking = false;       // Replaced by AI_THINKING game state
// NEW: Flag to indicate if the current shot is the opening break of the game
bool isOpeningBreakShot = false;

// NEW: For AI shot planning and visualization
struct AIPlannedShot {
    float angle;
    float power;
    float spinX;
    float spinY;
    bool isValid; // Is there a valid shot planned?
};
AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

// Input & Aiming
POINT ptMouse = { 0, 0 };
bool isAiming = false;
bool isDraggingCueBall = false;
// --- ENSURE THIS LINE EXISTS HERE ---
bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
// --- End Ensure ---
bool isSettingEnglish = false;
D2D1_POINT_2F aimStartPoint = { 0, 0 };
float cueAngle = 0.0f;
float shotPower = 0.0f;
float cueSpinX = 0.0f; // Range -1 to 1
float cueSpinY = 0.0f; // Range -1 to 1
float pocketFlashTimer = 0.0f;
bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
int draggingBallId = -1;
bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
MCIDEVICEID midiDeviceID = 0; //midi func
std::atomic<bool> isMusicPlaying(false); //midi func
std::thread musicThread; //midi func
void StartMidi(HWND hwnd, const TCHAR* midiPath);
void StopMidi();

// UI Element Positions
D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

// Corrected Pocket Center Positions (aligned with table corners/edges)
const D2D1_POINT_2F pocketPositions[6] = {
    {TABLE_LEFT, TABLE_TOP},                           // Top-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
    {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
    {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
    {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
};

// Colors
const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
//const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
//const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Yellow); // Solids = Yellow
const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::Red);   // Stripes = Red
const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
//const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

// --- Forward Declarations ---
HRESULT CreateDeviceResources();
void DiscardDeviceResources();
void OnPaint();
void OnResize(UINT width, UINT height);
void InitGame();
void GameUpdate();
void UpdatePhysics();
void CheckCollisions();
bool CheckPockets(); // Returns true if any ball was pocketed
void ProcessShotResults();
void ApplyShot(float power, float angle, float spinX, float spinY);
void RespawnCueBall(bool behindHeadstring);
bool AreBallsMoving();
void SwitchTurns();
void AssignPlayerBallTypes(BallType firstPocketedType);
void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
Ball* GetBallById(int id);
Ball* GetCueBall();
//void PlayGameMusic(HWND hwnd); //midi func
void AIBreakShot();

// Drawing Functions
void DrawScene(ID2D1RenderTarget* pRT);
void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
void DrawBalls(ID2D1RenderTarget* pRT);
void DrawCueStick(ID2D1RenderTarget* pRT);
void DrawAimingAids(ID2D1RenderTarget* pRT);
void DrawUI(ID2D1RenderTarget* pRT);
void DrawPowerMeter(ID2D1RenderTarget* pRT);
void DrawSpinIndicator(ID2D1RenderTarget* pRT);
void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);

// Helper Functions
float GetDistance(float x1, float y1, float x2, float y2);
float GetDistanceSq(float x1, float y1, float x2, float y2);
bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
template <typename T> void SafeRelease(T** ppT);
// --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
// --- End Forward Declaration ---
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

// --- NEW Forward Declarations ---

// AI Related
struct AIShotInfo; // Define below
void TriggerAIMove();
void AIMakeDecision();
void AIPlaceCueBall();
AIShotInfo AIFindBestShot();
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
bool IsValidAIAimAngle(float angle); // Basic check

// Dialog Related
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ShowNewGameDialog(HINSTANCE hInstance);
void LoadSettings(); // For deserialization
void SaveSettings(); // For serialization
const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

// --- Forward Declaration for Window Procedure --- <<< Add this line HERE
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// --- NEW Struct for AI Shot Evaluation ---
struct AIShotInfo {
    bool possible = false;          // Is this shot considered viable?
    Ball* targetBall = nullptr;     // Which ball to hit
    int pocketIndex = -1;           // Which pocket to aim for (0-5)
    D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
    float angle = 0.0f;             // Calculated shot angle
    float power = 0.0f;             // Calculated shot power
    float score = -1.0f;            // Score for this shot (higher is better)
    bool involves8Ball = false;     // Is the target the 8-ball?
};

/*
table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
*/

// --- NEW Settings Serialization Functions ---
void SaveSettings() {
    std::ofstream outFile(SETTINGS_FILE_NAME);
    if (outFile.is_open()) {
        outFile << static_cast<int>(gameMode) << std::endl;
        outFile << static_cast<int>(aiDifficulty) << std::endl;
        outFile << static_cast<int>(openingBreakMode) << std::endl;
        outFile.close();
    }
    // else: Handle error, e.g., log or silently fail
}

void LoadSettings() {
    std::ifstream inFile(SETTINGS_FILE_NAME);
    if (inFile.is_open()) {
        int gm, aid, obm;
        if (inFile >> gm) {
            gameMode = static_cast<GameMode>(gm);
        }
        if (inFile >> aid) {
            aiDifficulty = static_cast<AIDifficulty>(aid);
        }
        if (inFile >> obm) {
            openingBreakMode = static_cast<OpeningBreakMode>(obm);
        }
        inFile.close();

        // Validate loaded settings (optional, but good practice)
        if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
        if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
        if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
    }
    // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
}
// --- End Settings Serialization Functions ---

// --- NEW Dialog Procedure ---
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_INITDIALOG:
    {
        // --- ACTION 4: Center Dialog Box ---
// Optional: Force centering if default isn't working
        RECT rcDlg, rcOwner, rcScreen;
        HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
        if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

        GetWindowRect(hwndOwner, &rcOwner);
        GetWindowRect(hDlg, &rcDlg);
        CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

        // Offset the owner rect relative to the screen if it's not the desktop
        if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
            OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
        }


        // Calculate centered position
        int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
        int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

        // Ensure it stays within screen bounds (optional safety)
        x = std::max(static_cast<int>(rcScreen.left), x);
        y = std::max(static_cast<int>(rcScreen.top), y);
        if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
            x = rcScreen.right - (rcDlg.right - rcDlg.left);
        if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
            y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


        // Set the dialog position
        SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

        // --- End Centering Code ---

        // Set initial state based on current global settings (or defaults)
        CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

        CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
            (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

        // Enable/Disable AI group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
        // Set initial state for Opening Break Mode
        CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
            (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
        // Enable/Disable Opening Break group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
    }
    return (INT_PTR)TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_RADIO_2P:
        case IDC_RADIO_CPU:
        {
            bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
            // Enable/Disable AI group controls based on selection
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
            // Also enable/disable Opening Break Mode group
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
        }
        return (INT_PTR)TRUE;

        case IDOK:
            // Retrieve selected options and store in global variables
            if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                gameMode = HUMAN_VS_AI;
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
            }
            else {
                gameMode = HUMAN_VS_HUMAN;
                // openingBreakMode doesn't apply to HvsH, can leave as is or reset
            }
            SaveSettings(); // Save settings when OK is pressed
            EndDialog(hDlg, IDOK); // Close dialog, return IDOK
            return (INT_PTR)TRUE;

        case IDCANCEL: // Handle Cancel or closing the dialog
            // Optionally, could reload settings here if you want cancel to revert to previously saved state
            EndDialog(hDlg, IDCANCEL);
            return (INT_PTR)TRUE;
        }
        break; // End WM_COMMAND
    }
    return (INT_PTR)FALSE; // Default processing
}

// --- NEW Helper to Show Dialog ---
void ShowNewGameDialog(HINSTANCE hInstance) {
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
        // User clicked Start, reset game with new settings
        isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""CPU (Easy)""; break;
            case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
            case HARD: player2Info.name = L""CPU (Hard)""; break;
            }
        }
        else {
            player2Info.name = L""Player 2"";
        }
        // Update window title
        std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
        SetWindowText(hwndMain, windowTitle.c_str());

        InitGame(); // Re-initialize game logic & board
        InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
    }
    else {
        // User cancelled dialog - maybe just resume game? Or exit?
        // For simplicity, we do nothing, game continues as it was.
        // To exit on cancel from F2, would need more complex state management.
    }
}

// --- NEW Reset Game Function ---
void ResetGame(HINSTANCE hInstance) {
    // Call the helper function to show the dialog and re-init if OK clicked
    ShowNewGameDialog(hInstance);
}

// --- WinMain ---
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    if (FAILED(CoInitialize(NULL))) {
        MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
        return -1;
    }

    // --- NEW: Load settings at startup ---
    LoadSettings();

    // --- NEW: Show configuration dialog FIRST ---
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
        // User cancelled the dialog
        CoUninitialize();
        return 0; // Exit gracefully if dialog cancelled
    }
    // Global gameMode and aiDifficulty are now set by the DialogProc

    // Set AI flag based on game mode
    isPlayer2AI = (gameMode == HUMAN_VS_AI);
    if (isPlayer2AI) {
        switch (aiDifficulty) {
        case EASY: player2Info.name = L""CPU (Easy)""; break;
        case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
        case HARD: player2Info.name = L""CPU (Hard)""; break;
        }
    }
    else {
        player2Info.name = L""Player 2"";
    }
    // --- End of Dialog Logic ---


    WNDCLASS wc = { };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L""Direct2D_8BallPool"";
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // --- ACTION 4: Calculate Centered Window Position ---
    const int WINDOW_WIDTH = 1000; // Define desired width
    const int WINDOW_HEIGHT = 700; // Define desired height
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WINDOW_WIDTH) / 2;
    int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

    // --- Change Window Title based on mode ---
    std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
    if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
    else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

    hwndMain = CreateWindowEx(
        0, L""Direct2D_8BallPool"", windowTitle.c_str(), dwStyle,
        windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL, NULL, hInstance, NULL
    );

    if (!hwndMain) {
        MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // Initialize Direct2D Resources AFTER window creation
    if (FAILED(CreateDeviceResources())) {
        MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    InitGame(); // Initialize game state AFTER resources are ready & mode is set
    Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
    StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
    //PlayGameMusic(hwndMain); //midi func

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
        MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    MSG msg = { };
    // --- Modified Main Loop ---
    // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
    // or gets reset to it via F2. The main loop runs normally once game starts.
    while (GetMessage(&msg, NULL, 0, 0)) {
        // We might need modeless dialog handling here if F2 shows dialog
        // while window is active, but DialogBoxParam is modal.
        // Let's assume F2 hides main window, shows dialog, then restarts game loop.
        // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    KillTimer(hwndMain, ID_TIMER);
    DiscardDeviceResources();
    SaveSettings(); // Save settings on exit
    CoUninitialize();

    return (int)msg.wParam;
}

// --- WndProc ---
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // Declare cueBall pointer once at the top, used in multiple cases
    // For clarity, often better to declare within each case where needed.
    Ball* cueBall = nullptr; // Initialize to nullptr
    switch (msg) {
    case WM_CREATE:
        // Resources are now created in WinMain after CreateWindowEx
        return 0;

    case WM_PAINT:
        OnPaint();
        // Validate the entire window region after painting
        ValidateRect(hwnd, NULL);
        return 0;

    case WM_SIZE: {
        UINT width = LOWORD(lParam);
        UINT height = HIWORD(lParam);
        OnResize(width, height);
        return 0;
    }

    case WM_TIMER:
        if (wParam == ID_TIMER) {
            GameUpdate(); // Update game logic and physics
            InvalidateRect(hwnd, NULL, FALSE); // Request redraw
        }
        return 0;

        // --- NEW: Handle F2 Key for Reset ---
        // --- MODIFIED: Handle More Keys ---
    case WM_KEYDOWN:
    { // Add scope for variable declarations

        // --- FIX: Get Cue Ball pointer for this scope ---
        cueBall = GetCueBall();
        // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
        // --- End Fix ---

        // Check which player can interact via keyboard (Humans only)
        bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

        // --- F1 / F2 Keys (Always available) ---
        if (wParam == VK_F2) {
            HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
            ResetGame(hInstance); // Call reset function
            return 0; // Indicate key was processed
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Direct2D-based StickPool game made in C++ from scratch (2764+ lines of code)\n"" // Update line count if needed
                L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                L""About This Game"", MB_OK | MB_ICONINFORMATION);
            return 0; // Indicate key was processed
        }

        // Check for 'M' key (uppercase or lowercase)
            // Toggle music with ""M""
        if (wParam == 'M' || wParam == 'm') {
            //static bool isMusicPlaying = false;
            if (isMusicPlaying) {
                // Stop the music
                StopMidi();
                isMusicPlaying = false;
            }
            else {
                // Build the MIDI file path
                TCHAR midiPath[MAX_PATH];
                GetModuleFileName(NULL, midiPath, MAX_PATH);
                // Keep only the directory part
                TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                if (lastBackslash != NULL) {
                    *(lastBackslash + 1) = '\0';
                }
                // Append the MIDI filename
                _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                // Start playing MIDI
                StartMidi(hwndMain, midiPath);
                isMusicPlaying = true;
            }
        }


        // --- Player Interaction Keys (Only if allowed) ---
        if (canPlayerControl) {
            // --- Get Shift Key State ---
            bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
            float powerStep = 0.2f; // Power step (Adjust as needed)

            switch (wParam) {
            case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle -= angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle < 0) cueAngle += 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_RIGHT: // Rotate Cue Stick Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle += angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_UP: // Decrease Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower -= powerStep;
                    if (shotPower < 0.0f) shotPower = 0.0f;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_DOWN: // Increase Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower += powerStep;
                    if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_SPACE: // Trigger Shot
                if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                    && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                {
                    if (shotPower > 0.15f) { // Use same threshold as mouse
                       // Reset foul flags BEFORE applying shot
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;

                        // Play sound & Apply Shot
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                        // Update State
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false;
                        pocketedThisTurn.clear();
                        shotPower = 0; // Reset power after shooting
                        isAiming = false; isDraggingStick = false; // Reset aiming flags
                        keyboardAimingActive = false;
                    }
                }
                break;

            case VK_ESCAPE: // Cancel Aim/Shot Setup
                if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                {
                    shotPower = 0.0f;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = false;
                    // Revert to basic turn state if not breaking
                    if (currentGameState != BREAKING) {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    }
                }
                break;

            case 'G': // Toggle Cheat Mode
                cheatModeEnabled = !cheatModeEnabled;
                if (cheatModeEnabled)
                    MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                else
                    MessageBeep(MB_OK); // Play a different beep when disabling
                break;

            default:
                // Allow default processing for other keys if needed
                // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                break;
            } // End switch(wParam) for player controls
            return 0; // Indicate player control key was processed
        } // End if(canPlayerControl)
    } // End scope for WM_KEYDOWN case
    // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
    // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
    return 0;

    case WM_MOUSEMOVE: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        cueBall = GetCueBall(); // Declare and get cueBall pointer

        if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
            Ball* ball = GetBallById(draggingBallId);
            if (ball) {
                ball->x = (float)ptMouse.x;
                ball->y = (float)ptMouse.y;
                ball->vx = ball->vy = 0.0f;
            }
            return 0;
        }

        if (!cueBall) return 0;

        // Update Aiming Logic (Check player turn)
        if (isDraggingCueBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                currentGameState == PRE_BREAK_PLACEMENT))
        {
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            // Tentative position update
            cueBall->x = (float)ptMouse.x;
            cueBall->y = (float)ptMouse.y;
            cueBall->vx = cueBall->vy = 0;
        }
        else if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            //NEW2 MOUSEBOUND CODE = START
                /*// Clamp mouse inside table bounds during aiming
                if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
            if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
            if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
            if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
            //NEW2 MOUSEBOUND CODE = END
            // Aiming drag updates angle and power
            float dx = (float)ptMouse.x - cueBall->x;
            float dy = (float)ptMouse.y - cueBall->y;
            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
            //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
            //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            }
        }
        else if (isSettingEnglish &&
            ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
        {
            // Setting English
            float dx = (float)ptMouse.x - spinIndicatorCenter.x;
            float dy = (float)ptMouse.y - spinIndicatorCenter.y;
            float dist = GetDistance(dx, dy, 0, 0);
            if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
            cueSpinX = dx / spinIndicatorRadius;
            cueSpinY = dy / spinIndicatorRadius;
        }
        else {
            //DISABLE PERM AIMING = START
            /*// Update visual angle even when not aiming/dragging (Check player turn)
            bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

            if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
            {
                // NEW MOUSEBOUND CODE = START
                    // Only update cue angle if mouse is inside the playable table area
                if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                    ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                {
                    // NEW MOUSEBOUND CODE = END
                    Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                    if (cb) {
                        float dx = (float)ptMouse.x - cb->x;
                        float dy = (float)ptMouse.y - cb->y;
                        if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    }
                } //NEW MOUSEBOUND CODE LINE = DISABLE
            }*/
            //DISABLE PERM AIMING = END
        }
        return 0;
    } // End WM_MOUSEMOVE

    case WM_LBUTTONDOWN: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);


        // --- Handle pocket selection clicks ---
        if (currentGameState == SELECT_EIGHT_POCKET_P1 || currentGameState == SELECT_EIGHT_POCKET_P2) {
            for (int i = 0; i < 6; i++) {
                float dx = ptMouse.x - pocketPositions[i].x, dy = ptMouse.y - pocketPositions[i].y;
                if (dx * dx + dy * dy <= HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS) {
                    selectedPocketIndex = i;
                    eightPocketSelected = true;
                    // return to normal turn: human aims or CPU thinks
                    currentGameState = (currentGameState == SELECT_EIGHT_POCKET_P1) ? PLAYER1_TURN : PLAYER2_TURN;
                    return 0;
                }
            }
            return 0;
        }

        if (cheatModeEnabled) {
            // Allow dragging any ball freely
            for (Ball& ball : balls) {
                float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                    isDraggingCueBall = true;
                    draggingBallId = ball.id;
                    if (ball.id == 0) {
                        // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                        if (currentPlayer == 1)
                            currentGameState = BALL_IN_HAND_P1;
                        else if (currentPlayer == 2 && !isPlayer2AI)
                            currentGameState = BALL_IN_HAND_P2;
                    }
                    return 0;
                }
            }
        }

        Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

        // Check which player is allowed to interact via mouse click
        bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
        // Define states where interaction is generally allowed
        bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == AIMING || currentGameState == BREAKING ||
            currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
            currentGameState == PRE_BREAK_PLACEMENT);

        // Check Spin Indicator first (Allow if player's turn/aim phase)
        if (canPlayerClickInteract && canInteractState) {
            float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
            if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                isSettingEnglish = true;
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
                isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                return 0;
            }
        }

        if (!cueBall) return 0;

        // Check Ball-in-Hand placement/drag
        bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
        bool isPlayerAllowedToPlace = (isPlacingBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

        if (isPlayerAllowedToPlace) {
            float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                isDraggingCueBall = true;
                isAiming = false; isDraggingStick = false;
            }
            else {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                    cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                    cueBall->vx = 0; cueBall->vy = 0;
                    isDraggingCueBall = false;
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
            }
            return 0;
        }

        // Check for starting Aim (Cue Ball OR Stick)
        bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

        if (canAim) {
            const float stickDrawLength = 150.0f * 1.4f;
            float currentStickAngle = cueAngle + PI;
            D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
            D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
            float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
            float stickClickThresholdSq = 36.0f;
            float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

            bool clickedStick = (distToStickSq < stickClickThresholdSq);
            bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

            if (clickedStick || clickedCueArea) {
                isDraggingStick = clickedStick && !clickedCueArea;
                isAiming = clickedCueArea;
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                shotPower = 0;
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                if (currentGameState != BREAKING) currentGameState = AIMING;
            }
        }
        return 0;
    } // End WM_LBUTTONDOWN


    case WM_LBUTTONUP: {
        if (cheatModeEnabled && isDraggingCueBall) {
            isDraggingCueBall = false;
            if (draggingBallId == 0) {
                // After dropping CueBall, stay Ball-In-Hand mode if needed
                if (currentPlayer == 1)
                    currentGameState = BALL_IN_HAND_P1;
                else if (currentPlayer == 2 && !isPlayer2AI)
                    currentGameState = BALL_IN_HAND_P2;
            }
            draggingBallId = -1;
            return 0;
        }

        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        Ball* cueBall = GetCueBall(); // Get cueBall pointer

        // Check for releasing aim drag (Stick OR Cue Ball)
        if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            bool wasAiming = isAiming;
            bool wasDraggingStick = isDraggingStick;
            isAiming = false; isDraggingStick = false;

            if (shotPower > 0.15f) { // Check power threshold
                if (currentGameState != AI_THINKING) {
                    firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false; pocketedThisTurn.clear();
                }
            }
            else if (currentGameState != AI_THINKING) { // Revert state if power too low
                if (currentGameState == BREAKING) { /* Still breaking */ }
                else {
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                }
            }
            shotPower = 0; // Reset power indicator regardless
        }

        // Handle releasing cue ball drag (placement)
        if (isDraggingCueBall) {
            isDraggingCueBall = false;
            // Check player allowed to place
            bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowed = (isPlacingState &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT)));

            if (isPlayerAllowed && cueBall) {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                    // Finalize position already set by mouse move
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
                else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
            }
        }

        // Handle releasing english setting
        if (isSettingEnglish) {
            isSettingEnglish = false;
        }
        return 0;
    } // End WM_LBUTTONUP

    case WM_DESTROY:
        isMusicPlaying = false;
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
            SaveSettings(); // Save settings on exit
        }
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// --- Direct2D Resource Management ---

HRESULT CreateDeviceResources() {
    HRESULT hr = S_OK;

    // Create Direct2D Factory
    if (!pFactory) {
        hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr)) return hr;
    }

    // Create DirectWrite Factory
    if (!pDWriteFactory) {
        hr = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (FAILED(hr)) return hr;
    }

    // Create Text Formats
    if (!pTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            16.0f, L""en-us"", &pTextFormat
        );
        if (FAILED(hr)) return hr;
        // Center align text
        pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }
    if (!pLargeTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            48.0f, L""en-us"", &pLargeTextFormat
        );
        if (FAILED(hr)) return hr;
        pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
        pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }


    // Create Render Target (needs valid hwnd)
    if (!pRenderTarget && hwndMain) {
        RECT rc;
        GetClientRect(hwndMain, &rc);
        D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

        hr = pFactory->CreateHwndRenderTarget(
            D2D1::RenderTargetProperties(),
            D2D1::HwndRenderTargetProperties(hwndMain, size),
            &pRenderTarget
        );
        if (FAILED(hr)) {
            // If failed, release factories if they were created in this call
            SafeRelease(&pTextFormat);
            SafeRelease(&pLargeTextFormat);
            SafeRelease(&pDWriteFactory);
            SafeRelease(&pFactory);
            pRenderTarget = nullptr; // Ensure it's null on failure
            return hr;
        }
    }

    return hr;
}

void DiscardDeviceResources() {
    SafeRelease(&pRenderTarget);
    SafeRelease(&pTextFormat);
    SafeRelease(&pLargeTextFormat);
    SafeRelease(&pDWriteFactory);
    // Keep pFactory until application exit? Or release here too? Let's release.
    SafeRelease(&pFactory);
}

void OnResize(UINT width, UINT height) {
    if (pRenderTarget) {
        D2D1_SIZE_U size = D2D1::SizeU(width, height);
        pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
    }
}

// --- Game Initialization ---
void InitGame() {
    srand((unsigned int)time(NULL)); // Seed random number generator
    isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
    aiPlannedShotDetails.isValid = false; // Reset AI planned shot
    aiIsDisplayingAim = false;
    aiAimDisplayFramesLeft = 0;
    // ... (rest of InitGame())

    // --- Ensure pocketed list is clear from the absolute start ---
    pocketedThisTurn.clear();

    balls.clear(); // Clear existing balls

    // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
    player1Info.assignedType = BallType::NONE;
    player1Info.ballsPocketedCount = 0;
    // Player 1 Name usually remains ""Player 1""
    player2Info.assignedType = BallType::NONE;
    player2Info.ballsPocketedCount = 0;
    // Player 2 Name is set based on gameMode in ShowNewGameDialog

    // If player just sank their 7th object (next is 8-Ball), force pocket selection
    PlayerInfo& cp = (currentPlayer == 1 ? player1Info : player2Info);
    if (!eightPocketSelected && !eightBallPocketed && cp.ballsPocketedCount >= 7) {
        // go into pocket-selection mode
        currentGameState = (currentPlayer == 1) ? SELECT_EIGHT_POCKET_P1 : SELECT_EIGHT_POCKET_P2;
        // display “Choose a pocket…” instead of normal UI
        return;
    }

    // Create Cue Ball (ID 0)
    // Initial position will be set during PRE_BREAK_PLACEMENT state
    balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

    // --- Create Object Balls (Temporary List) ---
    std::vector<Ball> objectBalls;
    // Solids (1-7, Yellow)
    for (int i = 1; i <= 7; ++i) {
        objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
    }
    // Stripes (9-15, Red)
    for (int i = 9; i <= 15; ++i) {
        objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
    }
    // 8-Ball (ID 8) - Add it to the list to be placed
    objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


    // --- Racking Logic (Improved) ---
    float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
    float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

    // Define rack positions (0-14 indices corresponding to triangle spots)
    D2D1_POINT_2F rackPositions[15];
    int rackIndex = 0;
    for (int row = 0; row < 5; ++row) {
        for (int col = 0; col <= row; ++col) {
            if (rackIndex >= 15) break;
            float x = RACK_POS_X + row * spacingX;
            float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
            rackPositions[rackIndex++] = D2D1::Point2F(x, y);
        }
    }

    // Separate 8-ball
    Ball eightBall;
    std::vector<Ball> otherBalls; // Solids and Stripes
    bool eightBallFound = false;
    for (const auto& ball : objectBalls) {
        if (ball.id == 8) {
            eightBall = ball;
            eightBallFound = true;
        }
        else {
            otherBalls.push_back(ball);
        }
    }
    // Ensure 8 ball was actually created (should always be true)
    if (!eightBallFound) {
        // Handle error - perhaps recreate it? For now, proceed.
        eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
    }


    // Shuffle the other 14 balls
    // Use std::shuffle if available (C++11 and later) for better randomness
    // std::random_device rd;
    // std::mt19937 g(rd());
    // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
    std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

    // --- Place balls into the main 'balls' vector in rack order ---
    // Important: Add the cue ball (already created) first.
    // (Cue ball added at the start of the function now)

    // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
    int eightBallRackIndex = 4;
    eightBall.x = rackPositions[eightBallRackIndex].x;
    eightBall.y = rackPositions[eightBallRackIndex].y;
    eightBall.vx = 0;
    eightBall.vy = 0;
    eightBall.isPocketed = false;
    balls.push_back(eightBall); // Add 8 ball to the main vector

    // 2. Place the shuffled Solids and Stripes in the remaining spots
    size_t otherBallIdx = 0;
    //int otherBallIdx = 0;
    for (int i = 0; i < 15; ++i) {
        if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

        if (otherBallIdx < otherBalls.size()) {
            Ball& ballToPlace = otherBalls[otherBallIdx++];
            ballToPlace.x = rackPositions[i].x;
            ballToPlace.y = rackPositions[i].y;
            ballToPlace.vx = 0;
            ballToPlace.vy = 0;
            ballToPlace.isPocketed = false;
            balls.push_back(ballToPlace); // Add to the main game vector
        }
    }
    // --- End Racking Logic ---


    // --- Determine Who Breaks and Initial State ---
    if (isPlayer2AI) {
        /*// AI Mode: Randomly decide who breaks
        if ((rand() % 2) == 0) {
            // AI (Player 2) breaks
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
            aiTurnPending = true; // Trigger AI logic
        }
        else {
            // Player 1 (Human) breaks
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
            aiTurnPending = false;*/
        switch (openingBreakMode) {
        case CPU_BREAK:
            currentPlayer = 2; // AI breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        case P1_BREAK:
            currentPlayer = 1; // Player 1 breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false;
            break;
        case FLIP_COIN_BREAK:
            if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
            }
            else {
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
            }
            break;
        default: // Fallback to CPU break
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        }
    }
    else {
        // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
        currentPlayer = 1;
        currentGameState = PRE_BREAK_PLACEMENT;
        aiTurnPending = false; // No AI involved
    }

    // Reset other relevant game state variables
    foulCommitted = false;
    gameOverMessage = L"""";
    firstBallPocketedAfterBreak = false;
    // pocketedThisTurn cleared at start
    // Reset shot parameters and input flags
    shotPower = 0.0f;
    cueSpinX = 0.0f;
    cueSpinY = 0.0f;
    isAiming = false;
    isDraggingCueBall = false;
    isSettingEnglish = false;
    cueAngle = 0.0f; // Reset aim angle
}


// --- Game Loop ---
void GameUpdate() {
    if (currentGameState == SHOT_IN_PROGRESS) {
        UpdatePhysics();
        CheckCollisions();

        if (AreBallsMoving()) {
            // When all balls stop, clear aiming flags
            isAiming = false;
            aiIsDisplayingAim = false;
            //ProcessShotResults();
        }

        bool pocketed = CheckPockets(); // Store if any ball was pocketed

        // --- Update pocket flash animation timer ---
        if (pocketFlashTimer > 0.0f) {
            pocketFlashTimer -= 0.02f;
            if (pocketFlashTimer < 0.0f) pocketFlashTimer = 0.0f;
        }

        if (!AreBallsMoving()) {
            ProcessShotResults(); // Determine next state based on what happened
        }
    }

    // --- Check if AI needs to act ---
    else if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
        // For CPU, force pocket selection first if needed
        if (!eightPocketSelected && player2Info.ballsPocketedCount >= 7) {
            currentGameState = SELECT_EIGHT_POCKET_P2;
            return;
        }
        if (aiIsDisplayingAim) { // AI has decided a shot and is displaying aim
            aiAimDisplayFramesLeft--;
            if (aiAimDisplayFramesLeft <= 0) {
                aiIsDisplayingAim = false; // Done displaying
                if (aiPlannedShotDetails.isValid) {
                    // Execute the planned shot
                    firstHitBallIdThisShot = -1;
                    cueHitObjectBallThisShot = false;
                    railHitAfterContact = false;
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
                    aiPlannedShotDetails.isValid = false; // Clear the planned shot
                }
                currentGameState = SHOT_IN_PROGRESS;
                foulCommitted = false;
                pocketedThisTurn.clear();
            }
            // Else, continue displaying aim
        }
        else if (aiTurnPending) { // AI needs to start its decision process
            // Valid states for AI to start thinking
            /*/if (currentGameState == PRE_BREAK_PLACEMENT && isOpeningBreakShot) {*/
            //newcode 1 commented out
            /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
                // Handle the break shot
                AIBreakShot();
            }*/ //new code 1 end  
            /*else if (currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING ||
                currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2) {*/

                // aiTurnPending might be consumed by AIBreakShot or remain for next cycle if needed
        /* } //new code 2 commented out
        else if (currentGameState == BALL_IN_HAND_P2 && currentPlayer == 2 && isPlayer2AI) {
            AIPlaceCueBall(); // AI places the ball first
            // After placement, AI needs to decide its shot.
            // Transition to a state where AIMakeDecision will be called for shot selection.
            currentGameState = PLAYER2_TURN; // Or a specific AI_AIMING_AFTER_PLACEMENT state
                                             // aiTurnPending remains true to trigger AIMakeDecision next.
        }
        else if (currentGameState == PLAYER2_TURN && currentPlayer == 2 && isPlayer2AI) {
            // This is for a normal turn (not break, not immediately after ball-in-hand placement)

                currentGameState = AI_THINKING; // Set state to indicate AI is processing
                aiTurnPending = false;         // Consume the pending turn flag
                AIMakeDecision();              // For normal shots (non-break)
            }
            else {
                // Not a state where AI should act
                aiTurnPending = false;
            }*/
            // 2b) AI is ready to think (pending flag)
            // **1) Ball-in-Hand** let AI place the cue ball first
            if (currentGameState == BALL_IN_HAND_P2) {
                // Step 1: AI places the cue ball.
                AIPlaceCueBall();
                // Step 2: Transition to thinking state for shot decision.
                currentGameState = AI_THINKING; //newcode5
                // Step 3: Consume the pending flag for the placement phase.
                //         AIMakeDecision will handle shot planning now.
                aiTurnPending = false; //newcode5
                // Step 4: AI immediately decides the shot from the new position.
                AIMakeDecision(); //newcode5
            }
            // **2) Opening break** special break shot logic
            else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                AIBreakShot();
            }
            else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) { //newcode5
                // General turn for AI to think (not ball-in-hand, not initial break placement)
                currentGameState = AI_THINKING; //newcode5
                aiTurnPending = false; // Consume the flag //newcode5
                AIMakeDecision(); //newcode5
            }
            // **3) Otherwise** normal shot planning
            /*else { //orig uncommented oldcode5
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
            }*/
        }

        //} //bracefix
        // If current state is AI_THINKING but not displaying aim, then AI decision has already been made
    }
}

// --- Physics and Collision ---
void UpdatePhysics() {
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) {
            b.x += b.vx;
            b.y += b.vy;

            // Apply friction
            b.vx *= FRICTION;
            b.vy *= FRICTION;

            // Stop balls if velocity is very low
            if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                b.vx = 0;
                b.vy = 0;
            }
        }
    }
}

void CheckCollisions() {
    float left = TABLE_LEFT;
    float right = TABLE_RIGHT;
    float top = TABLE_TOP;
    float bottom = TABLE_BOTTOM;
    const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

    // --- Reset Per-Frame Sound Flags ---
    bool playedWallSoundThisFrame = false;
    bool playedCollideSoundThisFrame = false;
    // ---

    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b1 = balls[i];
        if (b1.isPocketed) continue;

        bool nearPocket[6];
        for (int p = 0; p < 6; ++p) {
            nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
        }
        bool nearTopLeftPocket = nearPocket[0];
        bool nearTopMidPocket = nearPocket[1];
        bool nearTopRightPocket = nearPocket[2];
        bool nearBottomLeftPocket = nearPocket[3];
        bool nearBottomMidPocket = nearPocket[4];
        bool nearBottomRightPocket = nearPocket[5];

        bool collidedWallThisBall = false;

        // --- Ball-Wall Collisions ---
        // (Check logic unchanged, added sound calls and railHitAfterContact update)
        // Left Wall
        if (b1.x - BALL_RADIUS < left) {
            if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Right Wall
        if (b1.x + BALL_RADIUS > right) {
            if (!nearTopRightPocket && !nearBottomRightPocket) {
                b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Top Wall
        if (b1.y - BALL_RADIUS < top) {
            if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Bottom Wall
        if (b1.y + BALL_RADIUS > bottom) {
            if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }

        // Spin effect (Unchanged)
        if (collidedWallThisBall) {
            if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
            if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
            cueSpinX *= 0.7f; cueSpinY *= 0.7f;
        }


        // --- Ball-Ball Collisions ---
        for (size_t j = i + 1; j < balls.size(); ++j) {
            Ball& b2 = balls[j];
            if (b2.isPocketed) continue;

            float dx = b2.x - b1.x; float dy = b2.y - b1.y;
            float distSq = dx * dx + dy * dy;
            float minDist = BALL_RADIUS * 2.0f;

            if (distSq > 1e-6 && distSq < minDist * minDist) {
                float dist = sqrtf(distSq);
                float overlap = minDist - dist;
                float nx = dx / dist; float ny = dy / dist;

                // Separation (Unchanged)
                b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                float velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) { // Colliding
                    // --- Play Ball Collision Sound ---
                    if (!playedCollideSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                        playedCollideSoundThisFrame = true; // Set flag
                    }
                    // --- End Sound ---

                    // --- NEW: Track First Hit and Cue/Object Collision ---
                    if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                        if (b1.id == 0) { // Cue ball hit b2 first
                            firstHitBallIdThisShot = b2.id;
                            cueHitObjectBallThisShot = true;
                        }
                        else if (b2.id == 0) { // Cue ball hit b1 first
                            firstHitBallIdThisShot = b1.id;
                            cueHitObjectBallThisShot = true;
                        }
                        // If neither is cue ball, doesn't count as first hit for foul purposes
                    }
                    else if (b1.id == 0 || b2.id == 0) {
                        // Track subsequent cue ball collisions with object balls
                        cueHitObjectBallThisShot = true;
                    }
                    // --- End First Hit Tracking ---


                    // Impulse (Unchanged)
                    float impulse = velAlongNormal;
                    b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                    b2.vx += impulse * nx; b2.vy += impulse * ny;

                    // Spin Transfer (Unchanged)
                    if (b1.id == 0 || b2.id == 0) {
                        float spinEffectFactor = 0.08f;
                        b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                    }
                }
            }
        } // End ball-ball loop
    } // End ball loop
} // End CheckCollisions


bool CheckPockets() {
    bool ballPocketedThisCheck = false; // Local flag for this specific check run
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) { // Only check balls that aren't already flagged as pocketed
            for (int p = 0; p < 6; ++p) {
                float distSq = GetDistanceSq(b.x, b.y, pocketPositions[p].x, pocketPositions[p].y);
                // --- Use updated POCKET_RADIUS ---
                if (distSq < POCKET_RADIUS * POCKET_RADIUS) {
                    b.isPocketed = true;
                    b.vx = b.vy = 0;
                    pocketedThisTurn.push_back(b.id);

                    // --- Play Pocket Sound (Threaded) ---
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound ---

                    break; // Ball is pocketed
                }
            }
        }
    }
    return ballPocketedThisCheck;
}

bool AreBallsMoving() {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
            return true;
        }
    }
    return false;
}

void RespawnCueBall(bool behindHeadstring) { // 'behindHeadstring' only relevant for initial break placement
    Ball* cueBall = GetCueBall();
    if (cueBall) {
        // Reset position to a default
        //disabled for behind headstring (now move anywhere)
        /*cueBall->x = HEADSTRING_X * 0.5f;
        cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;*/
        // Reset position to a default:
        if (behindHeadstring) {
            // Opening break: kitchen center
            cueBall->x = HEADSTRING_X * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        else {
            // Ball-in-hand (foul): center of full table
            cueBall->x = TABLE_LEFT + TABLE_WIDTH / 2.0f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        cueBall->vx = 0;
        cueBall->vy = 0;
        cueBall->isPocketed = false;

        // Set state based on who gets ball-in-hand
        /*// 'currentPlayer' already reflects who's turn it is NOW (switched before calling this)*/
        // 'currentPlayer' has already been switched to the player whose turn it will be.
        // The 'behindHeadstring' parameter to RespawnCueBall is mostly for historical reasons / initial setup.
        if (currentPlayer == 1) { // Player 2 (AI/Human) fouled, Player 1 (Human) gets ball-in-hand
            currentGameState = BALL_IN_HAND_P1;
            aiTurnPending = false; // Ensure AI flag off
        }
        else { // Player 1 (Human) fouled, Player 2 gets ball-in-hand
            if (isPlayer2AI) {
                // --- CONFIRMED FIX: Set correct state for AI Ball-in-Hand ---
                currentGameState = BALL_IN_HAND_P2; // AI now needs to place the ball
                aiTurnPending = true; // Trigger AI logic (will call AIPlaceCueBall first)
            }
            else { // Human Player 2
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = false; // Ensure AI flag off
            }
        }
        // Handle initial placement state correctly if called from InitGame
        /*if (behindHeadstring && currentGameState != PRE_BREAK_PLACEMENT) {
            // This case might need review depending on exact initial setup flow,
            // but the foul logic above should now be correct.
            // Let's ensure initial state is PRE_BREAK_PLACEMENT if behindHeadstring is true.*/
            //currentGameState = PRE_BREAK_PLACEMENT;
    }
}
//}


// --- Game Logic ---

void ApplyShot(float power, float angle, float spinX, float spinY) {
    Ball* cueBall = GetCueBall();
    if (cueBall) {

        // --- Play Cue Strike Sound (Threaded) ---
        if (power > 0.1f) { // Only play if it's an audible shot
            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
        }
        // --- End Sound ---

        cueBall->vx = cosf(angle) * power;
        cueBall->vy = sinf(angle) * power;

        // Apply English (Spin) - Simplified effect (Unchanged)
        cueBall->vx += sinf(angle) * spinY * 0.5f;
        cueBall->vy -= cosf(angle) * spinY * 0.5f;
        cueBall->vx -= cosf(angle) * spinX * 0.5f;
        cueBall->vy -= sinf(angle) * spinX * 0.5f;

        // Store spin (Unchanged)
        cueSpinX = spinX;
        cueSpinY = spinY;

        // --- Reset Foul Tracking flags for the new shot ---
        // (Also reset in LBUTTONUP, but good to ensure here too)
        firstHitBallIdThisShot = -1;      // No ball hit yet
        cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
        railHitAfterContact = false;     // No rail hit after contact yet
        // --- End Reset ---

                // If this was the opening break shot, clear the flag
        if (isOpeningBreakShot) {
            isOpeningBreakShot = false; // Mark opening break as taken
        }
    }
}


void ProcessShotResults() {
    bool cueBallPocketed = false;
    bool eightBallPocketed = false;
    bool legalBallPocketed = false;
    bool opponentBallPocketed = false;
    bool anyNonCueBallPocketed = false; // Includes opponent balls
    BallType firstPocketedType = BallType::NONE;
    int firstPocketedId = -1;

    PlayerInfo& currentPlayerInfo = (currentPlayer == 1) ? player1Info : player2Info;
    PlayerInfo& opponentPlayerInfo = (currentPlayer == 1) ? player2Info : player1Info;

    // Analyze pocketed balls (Unchanged logic)
    for (int pocketedId : pocketedThisTurn) {
        Ball* b = GetBallById(pocketedId);
        if (!b) continue;
        if (!pocketedThisTurn.empty()) {
            pocketFlashTimer = 1.0f; // Flash boost when any ball is pocketed
        }
        if (b->id == 0) { cueBallPocketed = true; }
        else if (b->id == 8) { eightBallPocketed = true; }
        else {
            anyNonCueBallPocketed = true;
            if (firstPocketedId == -1) { firstPocketedId = b->id; firstPocketedType = b->type; }
            if (currentPlayerInfo.assignedType != BallType::NONE) {
                if (b->type == currentPlayerInfo.assignedType) legalBallPocketed = true;
                else if (b->type == opponentPlayerInfo.assignedType) opponentBallPocketed = true;
            }
        }
    }

    // --- Game Over Checks --- (Unchanged logic)
    if (eightBallPocketed) {
        CheckGameOverConditions(eightBallPocketed, cueBallPocketed);
        if (currentGameState == GAME_OVER) return;
    }

    // --- MODIFIED: Enhanced Foul Checks ---
    bool turnFoul = false;

    // Foul 1: Scratch (Cue ball pocketed)
    if (cueBallPocketed) {
        foulCommitted = true; turnFoul = true;
    }

    // Foul 2: Hit Nothing (Only if not already a scratch)
    // Condition: Cue ball didn't hit *any* object ball during the shot.
    if (!turnFoul && !cueHitObjectBallThisShot) {
        // Check if the cue ball actually moved significantly to constitute a shot attempt
        Ball* cue = GetCueBall();
        // Use a small threshold to avoid foul on accidental tiny nudge if needed
        // For now, any shot attempt that doesn't hit an object ball is a foul.
        // (Could add velocity check from ApplyShot if needed)
        if (cue) { // Ensure cue ball exists
            foulCommitted = true; turnFoul = true;
        }
    }

    // Foul 3: Wrong Ball First (Check only if not already foul and *something* was hit)
    if (!turnFoul && firstHitBallIdThisShot != -1) {
        Ball* firstHitBall = GetBallById(firstHitBallIdThisShot);
        if (firstHitBall) {
            bool isBreakShot = (player1Info.assignedType == BallType::NONE && player2Info.assignedType == BallType::NONE);
            bool mustTarget8Ball = (!isBreakShot && currentPlayerInfo.assignedType != BallType::NONE && currentPlayerInfo.ballsPocketedCount >= 7);

            if (!isBreakShot) { // Standard play rules
                if (mustTarget8Ball) {
                    if (firstHitBall->id != 8) { foulCommitted = true; turnFoul = true; }
                }
                else if (currentPlayerInfo.assignedType != BallType::NONE) { // Colors assigned
                  // Illegal to hit opponent ball OR 8-ball first
                    if (firstHitBall->type == opponentPlayerInfo.assignedType || firstHitBall->id == 8) {
                        foulCommitted = true; turnFoul = true;
                    }
                }
                // If colors NOT assigned yet (e.g. shot immediately after break), hitting any ball is legal first.
            }
            // No specific first-hit foul rules applied for the break itself here.
        }
    }

    // Foul 4: No Rail After Contact (Check only if not already foul)
    // Condition: Cue hit an object ball, BUT after that first contact,
    //            NO ball hit a rail AND NO object ball was pocketed (excluding cue/8-ball).
    if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && !anyNonCueBallPocketed) {
        foulCommitted = true;
        turnFoul = true;
    }

    // Foul 5: Pocketing Opponent's Ball (Optional stricter rule - can uncomment if desired)
    // if (!turnFoul && opponentBallPocketed) {
    //     foulCommitted = true; turnFoul = true;
    // }
    // --- End Enhanced Foul Checks ---


    // --- State Transitions ---
    if (turnFoul) {
        SwitchTurns();
        RespawnCueBall(false); // Ball in hand for opponent (state set in Respawn)
    }
    // --- Assign Ball Types only AFTER checking for fouls on the break/first shot ---
    else if (player1Info.assignedType == BallType::NONE && anyNonCueBallPocketed) {
        // (Assign types logic - unchanged)
        bool firstTypeVerified = false;
        for (int id : pocketedThisTurn) { if (id == firstPocketedId) { firstTypeVerified = true; break; } }

        if (firstTypeVerified && (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE)) {
            AssignPlayerBallTypes(firstPocketedType);
            legalBallPocketed = true;
        }
        // After assignment (or if types already assigned), check if turn continues
        if (legalBallPocketed) { // Player legally pocketed their assigned type (newly or existing)
            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = true;
        }
        else { // Pocketed wrong ball, or only opponent ball, or missed (but no foul committed)
            SwitchTurns();
        }
    }
    // --- Normal Play Results (Types Assigned) ---
    else if (player1Info.assignedType != BallType::NONE) { // Ensure types assigned before this block
        if (legalBallPocketed) { // Legally pocketed own ball
            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = true; // AI continues turn
        }
        else { // No legal ball pocketed (or no ball pocketed at all) and no foul
            SwitchTurns();
        }
    }
    // --- Handle case where shot occurred but no balls pocketed and no foul ---
    else if (!anyNonCueBallPocketed && !turnFoul) {
        SwitchTurns();
    }


    // Update pocketed counts AFTER handling turns/fouls/assignment
    int p1NewlyPocketed = 0;
    int p2NewlyPocketed = 0;
    for (int id : pocketedThisTurn) {
        if (id == 0 || id == 8) continue; // Skip cue ball and 8-ball
        Ball* b = GetBallById(id);
        if (!b) continue; // extra safety
        if (b->type == player1Info.assignedType) p1NewlyPocketed++;
        else if (b->type == player2Info.assignedType) p2NewlyPocketed++;
    }
    if (currentGameState != GAME_OVER) {
        player1Info.ballsPocketedCount += p1NewlyPocketed;
        player2Info.ballsPocketedCount += p2NewlyPocketed;
    }


    // --- Cleanup for next actual shot attempt ---
    pocketedThisTurn.clear();
    // Reset foul tracking flags (done before next shot applied)
    // firstHitBallIdThisShot = -1; // Reset these before next shot call
    // cueHitObjectBallThisShot = false;
    // railHitAfterContact = false;
}

void AssignPlayerBallTypes(BallType firstPocketedType) {
    if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
        if (currentPlayer == 1) {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        else {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
    }
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.
}

void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
    if (!eightBallPocketed) return; // Only proceed if 8-ball was pocketed

    PlayerInfo& currentPlayerInfo = (currentPlayer == 1) ? player1Info : player2Info;
    bool playerClearedBalls = (currentPlayerInfo.assignedType != BallType::NONE && currentPlayerInfo.ballsPocketedCount >= 7);

    // Loss Conditions:
    // 1. Pocket 8-ball AND scratch (pocket cue ball)
    // 2. Pocket 8-ball before clearing own color group
    if (cueBallPocketed || (!playerClearedBalls && currentPlayerInfo.assignedType != BallType::NONE)) {
        gameOverMessage = (currentPlayer == 1) ? L""Player 2 Wins! (Player 1 fouled on 8-ball)"" : L""Player 1 Wins! (Player 2 fouled on 8-ball)"";
        currentGameState = GAME_OVER;
    }
    // Win Condition:
    // 1. Pocket 8-ball legally after clearing own color group
    else if (playerClearedBalls) {
        gameOverMessage = (currentPlayer == 1) ? L""Player 1 Wins!"" : L""Player 2 Wins!"";
        currentGameState = GAME_OVER;
    }
    // Special case: 8 ball pocketed on break. Usually re-spot or re-rack.
    // Simple: If it happens during assignment phase, treat as foul, respawn 8ball.
    else if (player1Info.assignedType == BallType::NONE) {
        Ball* eightBall = GetBallById(8);
        if (eightBall) {
            eightBall->isPocketed = false;
            // Place 8-ball on foot spot (approx RACK_POS_X) or center if occupied
            eightBall->x = RACK_POS_X;
            eightBall->y = RACK_POS_Y;
            eightBall->vx = eightBall->vy = 0;
            // Check overlap and nudge if necessary (simplified)
        }
        // Apply foul rules if cue ball was also pocketed
        if (cueBallPocketed) {
            foulCommitted = true;
            // Don't switch turns on break scratch + 8ball pocket? Rules vary.
            // Let's make it a foul, switch turns, ball in hand.
            SwitchTurns();
            RespawnCueBall(false); // Ball in hand for opponent
        }
        else {
            // Just respawned 8ball, continue turn or switch based on other balls pocketed.
            // Let ProcessShotResults handle turn logic based on other pocketed balls.
        }
        // Prevent immediate game over message by returning here
        return;
    }


}


void SwitchTurns() {
    currentPlayer = (currentPlayer == 1) ? 2 : 1;
    // Reset aiming state for the new player
    isAiming = false;
    shotPower = 0;
    // Reset foul flag before new turn *really* starts (AI might take over)
    // Foul flag is mainly for display, gets cleared before human/AI shot
    // foulCommitted = false; // Probably better to clear before ApplyShot

    // Set the correct state based on who's turn it is
    if (currentPlayer == 1) {
        currentGameState = PLAYER1_TURN;
        aiTurnPending = false; // Ensure AI flag is off for P1
    }
    else { // Player 2's turn
        if (isPlayer2AI) {
            currentGameState = PLAYER2_TURN; // State indicates it's P2's turn
            aiTurnPending = true;           // Set flag for GameUpdate to trigger AI
            // AI will handle Ball-in-Hand logic if necessary within its decision making
        }
        else {
            currentGameState = PLAYER2_TURN; // Human P2
            aiTurnPending = false;
        }
    }
}

void AIBreakShot() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
    // AI will place the cue ball and then plan the shot.
    if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
        // Place cue ball in the kitchen randomly
        /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
        float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

        // --- AI Places Cue Ball for Break ---
// Decide if placing center or side. For simplicity, let's try placing slightly off-center
// towards one side for a more angled break, or center for direct apex hit.
// A common strategy is to hit the second ball of the rack.

        float placementY = RACK_POS_Y; // Align vertically with the rack center
        float placementX;

        // Randomly choose a side or center-ish placement for variation.
        int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

        if (placementChoice == 0) { // Left-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
        }
        else if (placementChoice == 2) { // Right-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
        }
        else { // Center-ish
            placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
        }
        placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

        bool validPos = false;
        int attempts = 0;
        while (!validPos && attempts < 100) {
            /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
            cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                validPos = true; // [cite: 1591]*/
                // Try the chosen X, but vary Y slightly to find a clear spot
            cueBall->x = placementX;
            cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
            cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                validPos = true;
            }
            attempts++; // [cite: 1592]
        }
        if (!validPos) {
            // Fallback position
            /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
            cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
            }
        }
        cueBall->vx = 0; // [cite: 1595]
        cueBall->vy = 0; // [cite: 1596]

        // Plan a break shot: aim at the center of the rack (apex ball)
        float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
        float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

        float dx = targetX - cueBall->x; // [cite: 1599]
        float dy = targetY - cueBall->y; // [cite: 1600]
        float shotAngle = atan2f(dy, dx); // [cite: 1600]
        float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
            cueBall->y = RACK_POS_Y;
        }
        cueBall->vx = 0; cueBall->vy = 0;

        // --- AI Plans the Break Shot ---
        float targetX, targetY;
        // If cue ball is near center of kitchen width, aim for apex.
        // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
        float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
        if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
            // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
            targetX = RACK_POS_X; // Apex ball X
            targetY = RACK_POS_Y; // Apex ball Y
        }
        else {
            // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
            // This is a simplification. A more robust way is to find the actual second ball.
            // For now, aim slightly off the apex towards the side the cue ball is on.
            targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
            targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
        }

        float dx = targetX - cueBall->x;
        float dy = targetY - cueBall->y;
        float shotAngle = atan2f(dy, dx);
        float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

        // Store planned shot details for the AI
        /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
        aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
        aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
        aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
        aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

        aiPlannedShotDetails.angle = shotAngle;
        aiPlannedShotDetails.power = shotPowerValue;
        aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
        /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
        ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
        ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
        ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

        ::cueAngle = aiPlannedShotDetails.angle;
        ::shotPower = aiPlannedShotDetails.power;
        ::cueSpinX = aiPlannedShotDetails.spinX;
        ::cueSpinY = aiPlannedShotDetails.spinY;

        // Set up for AI display via GameUpdate
        /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

        currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                        // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                        // and then execute the shot using aiPlannedShotDetails.
                                        // isOpeningBreakShot will be set to false within ApplyShot.

        // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display

        return; // The break shot is now planned and will be executed by GameUpdate
    }

    // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
    //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
    //    This part can be extended if AIBreakShot needs to handle other scenarios.
    //    For now, the primary logic is above.
}

// --- Helper Functions ---

Ball* GetBallById(int id) {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id == id) {
            return &balls[i];
        }
    }
    return nullptr;
}

Ball* GetCueBall() {
    return GetBallById(0);
}

float GetDistance(float x1, float y1, float x2, float y2) {
    return sqrtf(GetDistanceSq(x1, y1, x2, y2));
}

float GetDistanceSq(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return dx * dx + dy * dy;
}

bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
    // Basic bounds check (inside cushions)
    float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
    float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
    float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
    float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

    if (x < left || x > right || y < top || y > bottom) {
        return false;
    }

    // Check headstring restriction if needed
    if (checkHeadstring && x >= HEADSTRING_X) {
        return false;
    }

    // Check overlap with other balls
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
            if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                return false; // Overlapping another ball
            }
        }
    }

    return true;
}


template <typename T>
void SafeRelease(T** ppT) {
    if (*ppT) {
        (*ppT)->Release();
        *ppT = nullptr;
    }
}

// --- Helper Function for Line Segment Intersection ---
// Finds intersection point of line segment P1->P2 and line segment P3->P4
// Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
{
    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

    // Check if lines are parallel or collinear
    if (fabs(denominator) < 1e-6) {
        return false;
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    // Check if intersection point lies on both segments
    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
        intersection.x = p1.x + ua * (p2.x - p1.x);
        intersection.y = p1.y + ua * (p2.y - p1.y);
        return true;
    }

    return false;
}

// --- INSERT NEW HELPER FUNCTION HERE ---
// Calculates the squared distance from point P to the line segment AB.
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
    float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
    if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
    // Consider P projecting onto the line AB infinite line
    // t = [(P-A) . (B-A)] / |B-A|^2
    float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
    t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
    // Projection falls on the segment
    D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
    return GetDistanceSq(p.x, p.y, projection.x, projection.y);
}
// --- End New Helper ---

// --- NEW AI Implementation Functions ---

// Main entry point for AI turn
void AIMakeDecision() {
    //AIShotInfo bestShot = { false }; // Declare here
    // This function is called when currentGameState is AI_THINKING (for a normal shot decision)
    Ball* cueBall = GetCueBall();
    if (!cueBall || !isPlayer2AI || currentPlayer != 2) {
        aiPlannedShotDetails.isValid = false; // Ensure no shot if conditions not met
        return;
    }

    // Phase 1: Placement if needed (Ball-in-Hand or Initial Break)
    /*if ((isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) || currentGameState == BALL_IN_HAND_P2) {
        AIPlaceCueBall(); // Handles kitchen placement for break or regular ball-in-hand
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            currentGameState = BREAKING; // Now AI needs to decide the break shot parameters
        }
        // For regular BALL_IN_HAND_P2, after placement, it will proceed to find a shot.
    }*/

    aiPlannedShotDetails.isValid = false; // Default to no valid shot found yet for this decision cycle
    // Note: isOpeningBreakShot is false here because AIBreakShot handles the break.

     // Phase 2: Decide shot parameters (Break or Normal play)
    /*if (isOpeningBreakShot && currentGameState == BREAKING) {
        // Force cue ball into center of kitchen
        cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
        cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f;
        cueBall->vx = cueBall->vy = 0.0f;

        float rackCenterX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f * 2.0f;
        float rackCenterY = RACK_POS_Y;
        float dx = rackCenterX - cueBall->x;
        float dy = rackCenterY - cueBall->y;

        aiPlannedShotDetails.angle = atan2f(dy, dx);
        aiPlannedShotDetails.power = MAX_SHOT_POWER;
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Apply shot immediately
        cueAngle = aiPlannedShotDetails.angle;
        shotPower = aiPlannedShotDetails.power;
        cueSpinX = aiPlannedShotDetails.spinX;
        cueSpinY = aiPlannedShotDetails.spinY;

        firstHitBallIdThisShot = -1;
        cueHitObjectBallThisShot = false;
        railHitAfterContact = false;
        isAiming = false;
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        //bool aiIsDisplayingAim = true;

        std::thread([](const TCHAR* soundName) {
            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
            }, TEXT(""cue.wav"")).detach();

            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
            currentGameState = SHOT_IN_PROGRESS;
            isOpeningBreakShot = false;
            aiTurnPending = false;
            pocketedThisTurn.clear();
            return;
    }
    else {*/
    // --- Normal AI Shot Decision (using AIFindBestShot) ---
    AIShotInfo bestShot = AIFindBestShot(); // bugtraq
    //bestShot = AIFindBestShot(); // bugtraq
    if (bestShot.possible) {
        aiPlannedShotDetails.angle = bestShot.angle;
        aiPlannedShotDetails.power = bestShot.power;
        aiPlannedShotDetails.spinX = 0.0f; // AI doesn't use spin yet
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;
    }
    else {
        // Safety tap if no better shot found
        // Try to hit the closest 'own' ball gently or any ball if types not assigned
        Ball* ballToNudge = nullptr;
        float minDistSq = -1.0f;
        BallType aiTargetType = player2Info.assignedType;
        bool mustHit8Ball = (aiTargetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);

        for (auto& b : balls) {
            if (b.isPocketed || b.id == 0) continue;
            bool canHitThis = false;
            if (mustHit8Ball) canHitThis = (b.id == 8);
            else if (aiTargetType != BallType::NONE) canHitThis = (b.type == aiTargetType);
            else canHitThis = (b.id != 8); // Can hit any non-8-ball if types not assigned

            if (canHitThis) {
                float dSq = GetDistanceSq(cueBall->x, cueBall->y, b.x, b.y);
                if (ballToNudge == nullptr || dSq < minDistSq) {
                    ballToNudge = &b;
                    minDistSq = dSq;
                }
            }
        }
        if (ballToNudge) { // Found a ball to nudge
            aiPlannedShotDetails.angle = atan2f(ballToNudge->y - cueBall->y, ballToNudge->x - cueBall->x);
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.15f; // Gentle tap
        }
        else { // Absolute fallback: small tap forward
            aiPlannedShotDetails.angle = cueAngle; // Keep last angle or default
            //aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
        }
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true; // Safety shot is a ""valid"" plan
    }
    //} //bracefix

    // Phase 3: Setup for Aim Display (if a valid shot was decided)
    if (aiPlannedShotDetails.isValid) {
        cueAngle = aiPlannedShotDetails.angle;   // Update global for drawing
        shotPower = aiPlannedShotDetails.power;  // Update global for drawing
        // cueSpinX and cueSpinY could also be set here if AI used them
        cueSpinX = aiPlannedShotDetails.spinX; // Also set these for drawing consistency
        cueSpinY = aiPlannedShotDetails.spinY; //

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        // currentGameState remains AI_THINKING, GameUpdate will handle the display countdown and shot execution.
            // FIRE THE BREAK SHOT NOW
            // Immediately execute the break shot after setting parameters
        /*ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
        currentGameState = SHOT_IN_PROGRESS;
        aiTurnPending = false;
        isOpeningBreakShot = false;*/
    }
    else {
        // Should not happen if safety shot is always planned, but as a fallback:
        aiIsDisplayingAim = false;
        // If AI truly can't decide anything, maybe switch turn or log error. For now, it will do nothing this frame.
        // Or force a minimal safety tap without display.
        // To ensure game progresses, let's plan a minimal tap if nothing else.
        if (!aiPlannedShotDetails.isValid) { // Double check
            aiPlannedShotDetails.angle = 0.0f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.05f; // Very small tap
            aiPlannedShotDetails.spinX = 0.0f; aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;
            //cueAngle = aiPlannedShotDetails.angle; shotPower = aiPlannedShotDetails.power;
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;
            cueSpinX = aiPlannedShotDetails.spinX;
            cueSpinY = aiPlannedShotDetails.spinY;
            aiIsDisplayingAim = true; // Allow display for this minimal tap too
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES / 2; // Shorter display for fallback
        }
    }
    // aiTurnPending was set to false by GameUpdate before calling AIMakeDecision.
    // AIMakeDecision's job is to populate aiPlannedShotDetails and trigger display.
}

// AI logic for placing cue ball during ball-in-hand
void AIPlaceCueBall() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // --- CPU AI Opening Break: Kitchen Placement ---
    /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
        float kitchenMinX = TABLE_LEFT + BALL_RADIUS;
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS;
        float kitchenMinY = TABLE_TOP + BALL_RADIUS;
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS;
        bool validPositionFound = false;
        int attempts = 0;
        while (!validPositionFound && attempts < 100) {
            cueBall->x = kitchenMinX + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxX - kitchenMinX)));
            cueBall->y = kitchenMinY + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxY - kitchenMinY)));
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                validPositionFound = true;
            }
            attempts++;
        }
        if (!validPositionFound) {
            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2.0f;
                cueBall->y = RACK_POS_Y;
            }
        }
        cueBall->vx = 0; cueBall->vy = 0;
        return;
    }*/
    // --- End CPU AI Opening Break Placement ---

    // This function is now SOLELY for Ball-In-Hand placement for the AI (anywhere on the table).
    // Break placement is handled by AIBreakShot().

    // Simple Strategy: Find the easiest possible shot for the AI's ball type
    // Place the cue ball directly behind that target ball, aiming straight at a pocket.
    // (More advanced: find spot offering multiple options or safety)

    AIShotInfo bestPlacementShot = { false };
    D2D1_POINT_2F bestPlacePos = D2D1::Point2F(HEADSTRING_X * 0.5f, RACK_POS_Y); // Default placement

    // A better default for ball-in-hand (anywhere) might be center table if no shot found.
    bestPlacePos = D2D1::Point2F(TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP + TABLE_HEIGHT / 2.0f);
    float bestPlacementScore = -1.0f; // Keep track of the score for the best placement found

    BallType targetType = player2Info.assignedType;
    bool canTargetAnyPlacement = false; // Local scope variable for placement logic
    if (targetType == BallType::NONE) {
        canTargetAnyPlacement = true;
    }
    bool target8Ball = (!canTargetAnyPlacement && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    if (target8Ball) targetType = BallType::EIGHT_BALL;


    for (auto& targetBall : balls) {
        if (targetBall.isPocketed || targetBall.id == 0) continue;

        // Determine if current ball is a valid target for placement consideration
        bool currentBallIsValidTarget = false;
        if (target8Ball && targetBall.id == 8) currentBallIsValidTarget = true;
        else if (canTargetAnyPlacement && targetBall.id != 8) currentBallIsValidTarget = true;
        else if (!canTargetAnyPlacement && !target8Ball && targetBall.type == targetType) currentBallIsValidTarget = true;

        if (!currentBallIsValidTarget) continue; // Skip if not a valid target

        for (int p = 0; p < 6; ++p) {
            // Calculate ideal cue ball position: straight line behind target ball aiming at pocket p
            float targetToPocketX = pocketPositions[p].x - targetBall.x;
            float targetToPocketY = pocketPositions[p].y - targetBall.y;
            float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);
            if (dist < 1.0f) continue; // Avoid division by zero

            float idealAngle = atan2f(targetToPocketY, targetToPocketX);
            // Place cue ball slightly behind target ball along this line
            float placeDist = BALL_RADIUS * 3.0f; // Place a bit behind
            D2D1_POINT_2F potentialPlacePos = D2D1::Point2F( // Use factory function
                targetBall.x - cosf(idealAngle) * placeDist,
                targetBall.y - sinf(idealAngle) * placeDist
            );

            // Check if this placement is valid (on table, behind headstring if break, not overlapping)
            /*bool behindHeadstringRule = (currentGameState == PRE_BREAK_PLACEMENT);*/
            // For ball-in-hand (NOT break), behindHeadstringRule is false.
            // The currentGameState should be BALL_IN_HAND_P2 when this is called for a foul.
            bool behindHeadstringRule = false; // Player can place anywhere after a foul
            if (IsValidCueBallPosition(potentialPlacePos.x, potentialPlacePos.y, behindHeadstringRule)) {
                // Is path from potentialPlacePos to targetBall clear?
                // Use D2D1::Point2F() factory function here
                if (IsPathClear(potentialPlacePos, D2D1::Point2F(targetBall.x, targetBall.y), 0, targetBall.id)) {
                    // Is path from targetBall to pocket clear?
                    // Use D2D1::Point2F() factory function here
                    if (IsPathClear(D2D1::Point2F(targetBall.x, targetBall.y), pocketPositions[p], targetBall.id, -1)) {
                        // This seems like a good potential placement. Score it?
                        // Easy AI: Just take the first valid one found.
                        /*bestPlacePos = potentialPlacePos;
                        goto placement_found;*/ // Use goto for simplicity in non-OOP structure
                        // This is a possible shot. Score this placement.
// A simple score: distance to target ball (shorter is better for placement).
// More advanced: consider angle to pocket, difficulty of the shot from this placement.
                        AIShotInfo tempShotInfo;
                        tempShotInfo.possible = true;
                        tempShotInfo.targetBall = &targetBall;
                        tempShotInfo.pocketIndex = p;
                        tempShotInfo.ghostBallPos = CalculateGhostBallPos(&targetBall, p); // Not strictly needed for placement score but good for consistency
                        tempShotInfo.angle = idealAngle; // The angle from the placed ball to target
                        // Use EvaluateShot's scoring mechanism if possible, or a simpler one here.
                        float currentScore = 1000.0f / (1.0f + GetDistance(potentialPlacePos.x, potentialPlacePos.y, targetBall.x, targetBall.y)); // Inverse distance

                        if (currentScore > bestPlacementScore) {
                            bestPlacementScore = currentScore;
                            bestPlacePos = potentialPlacePos;
                        }
                    }
                }
            }
        }
    }

placement_found:
    // Place the cue ball at the best found position (or default if no good spot found)
    cueBall->x = bestPlacePos.x;
    cueBall->y = bestPlacePos.y;
    cueBall->vx = 0;
    cueBall->vy = 0;
}


// AI finds the best shot available on the table
AIShotInfo AIFindBestShot() {
    AIShotInfo bestShotOverall = { false };
    Ball* cueBall = GetCueBall();
    if (!cueBall) return bestShotOverall;
    // Ensure cue ball position is up-to-date if AI just placed it
    // (AIPlaceCueBall should have already set cueBall->x, cueBall->y)

    // Determine target ball type for AI (Player 2)
    BallType targetType = player2Info.assignedType;
    bool canTargetAny = false; // Can AI hit any ball (e.g., after break, before assignment)?
    if (targetType == BallType::NONE) {
        // If colors not assigned, AI aims to pocket *something* (usually lowest numbered ball legally)
        // Or, more simply, treat any ball as a potential target to make *a* pocket
        canTargetAny = true; // Simplification: allow targeting any non-8 ball.
        // A better rule is hit lowest numbered ball first on break follow-up.
    }

    // Check if AI needs to shoot the 8-ball
    bool target8Ball = (!canTargetAny && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);


    // Iterate through all potential target balls
    for (auto& potentialTarget : balls) {
        if (potentialTarget.isPocketed || potentialTarget.id == 0) continue; // Skip pocketed and cue ball

        // Check if this ball is a valid target
        bool isValidTarget = false;
        if (target8Ball) {
            isValidTarget = (potentialTarget.id == 8);
        }
        else if (canTargetAny) {
            isValidTarget = (potentialTarget.id != 8); // Can hit any non-8 ball
        }
        else { // Colors assigned, not yet shooting 8-ball
            isValidTarget = (potentialTarget.type == targetType);
        }

        if (!isValidTarget) continue; // Skip if not a valid target for this turn

        // Now, check all pockets for this target ball
        for (int p = 0; p < 6; ++p) {
            AIShotInfo currentShot = EvaluateShot(&potentialTarget, p);
            currentShot.involves8Ball = (potentialTarget.id == 8);

            if (currentShot.possible) {
                // Compare scores to find the best shot
                if (!bestShotOverall.possible || currentShot.score > bestShotOverall.score) {
                    bestShotOverall = currentShot;
                }
            }
        }
    } // End loop through potential target balls

    // If targeting 8-ball and no shot found, or targeting own balls and no shot found,
    // need a safety strategy. Current simple AI just takes best found or taps cue ball.

    return bestShotOverall;
}


// Evaluate a potential shot at a specific target ball towards a specific pocket
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
    AIShotInfo shotInfo;
    shotInfo.possible = false; // Assume not possible initially
    shotInfo.targetBall = targetBall;
    shotInfo.pocketIndex = pocketIndex;

    Ball* cueBall = GetCueBall();
    if (!cueBall || !targetBall) return shotInfo;

    // --- Define local state variables needed for legality checks ---
    BallType aiAssignedType = player2Info.assignedType;
    bool canTargetAny = (aiAssignedType == BallType::NONE); // Can AI hit any ball?
    bool mustTarget8Ball = (!canTargetAny && aiAssignedType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    // ---

    // 1. Calculate Ghost Ball position
    shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

    // 2. Calculate Angle from Cue Ball to Ghost Ball
    float dx = shotInfo.ghostBallPos.x - cueBall->x;
    float dy = shotInfo.ghostBallPos.y - cueBall->y;
    if (fabs(dx) < 0.01f && fabs(dy) < 0.01f) return shotInfo; // Avoid aiming at same spot
    shotInfo.angle = atan2f(dy, dx);

    // Basic angle validity check (optional)
    if (!IsValidAIAimAngle(shotInfo.angle)) {
        // Maybe log this or handle edge cases
    }

    // 3. Check Path: Cue Ball -> Ghost Ball Position
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
        return shotInfo; // Path blocked
    }

    // 4. Check Path: Target Ball -> Pocket
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(targetBall->x, targetBall->y), pocketPositions[pocketIndex], targetBall->id, -1)) {
        return shotInfo; // Path blocked
    }

    // 5. Check First Ball Hit Legality
    float firstHitDistSq = -1.0f;
    // Use D2D1::Point2F() factory function here
    Ball* firstHit = FindFirstHitBall(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.angle, firstHitDistSq);

    if (!firstHit) {
        return shotInfo; // AI aims but doesn't hit anything? Impossible shot.
    }

    // Check if the first ball hit is the intended target ball
    if (firstHit->id != targetBall->id) {
        // Allow hitting slightly off target if it's very close to ghost ball pos
        float ghostDistSq = GetDistanceSq(shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y, firstHit->x, firstHit->y);
        // Allow a tolerance roughly half the ball radius squared
        if (ghostDistSq > (BALL_RADIUS * 0.7f) * (BALL_RADIUS * 0.7f)) {
            // First hit is significantly different from the target point.
            // This shot path leads to hitting the wrong ball first.
            return shotInfo; // Foul or unintended shot
        }
        // If first hit is not target, but very close, allow it for now (might still be foul based on type).
    }

    // Check legality of the *first ball actually hit* based on game rules
    if (!canTargetAny) { // Colors are assigned (or should be)
        if (mustTarget8Ball) { // Must hit 8-ball first
            if (firstHit->id != 8) {
                // return shotInfo; // FOUL - Hitting wrong ball when aiming for 8-ball
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
        }
        else { // Must hit own ball type first
            if (firstHit->type != aiAssignedType && firstHit->id != 8) { // Allow hitting 8-ball if own type blocked? No, standard rules usually require hitting own first.
                // return shotInfo; // FOUL - Hitting opponent ball or 8-ball when shouldn't
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
            else if (firstHit->id == 8) {
                // return shotInfo; // FOUL - Hitting 8-ball when shouldn't
                // Keep shot possible for now
            }
        }
    }
    // (If canTargetAny is true, hitting any ball except 8 first is legal - assuming not scratching)


    // 6. Calculate Score & Power (Difficulty affects this)
    shotInfo.possible = true; // If we got here, the shot is geometrically possible and likely legal enough for AI to consider

    float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
    float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);

    // Simple Score: Shorter shots are better, straighter shots are slightly better.
    float distanceScore = 1000.0f / (1.0f + cueToGhostDist + targetToPocketDist);

    // Angle Score: Calculate cut angle
    // Vector Cue -> Ghost
    float v1x = shotInfo.ghostBallPos.x - cueBall->x;
    float v1y = shotInfo.ghostBallPos.y - cueBall->y;
    // Vector Target -> Pocket
    float v2x = pocketPositions[pocketIndex].x - targetBall->x;
    float v2y = pocketPositions[pocketIndex].y - targetBall->y;
    // Normalize vectors
    float mag1 = sqrtf(v1x * v1x + v1y * v1y);
    float mag2 = sqrtf(v2x * v2x + v2y * v2y);
    float angleScoreFactor = 0.5f; // Default if vectors are zero len
    if (mag1 > 0.1f && mag2 > 0.1f) {
        v1x /= mag1; v1y /= mag1;
        v2x /= mag2; v2y /= mag2;
        // Dot product gives cosine of angle between cue ball path and target ball path
        float dotProduct = v1x * v2x + v1y * v2y;
        // Straighter shot (dot product closer to 1) gets higher score
        angleScoreFactor = (1.0f + dotProduct) / 2.0f; // Map [-1, 1] to [0, 1]
    }
    angleScoreFactor = std::max(0.1f, angleScoreFactor); // Ensure some minimum score factor

    shotInfo.score = distanceScore * angleScoreFactor;

    // Bonus for pocketing 8-ball legally
    if (mustTarget8Ball && targetBall->id == 8) {
        shotInfo.score *= 10.0; // Strongly prefer the winning shot
    }

    // Penalty for difficult cuts? Already partially handled by angleScoreFactor.

    // 7. Calculate Power
    shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

    // 8. Add Inaccuracy based on Difficulty (same as before)
    float angleError = 0.0f;
    float powerErrorFactor = 1.0f;

    switch (aiDifficulty) {
    case EASY:
        angleError = (float)(rand() % 100 - 50) / 1000.0f; // +/- ~3 deg
        powerErrorFactor = 0.8f + (float)(rand() % 40) / 100.0f; // 80-120%
        shotInfo.power *= 0.8f;
        break;
    case MEDIUM:
        angleError = (float)(rand() % 60 - 30) / 1000.0f; // +/- ~1.7 deg
        powerErrorFactor = 0.9f + (float)(rand() % 20) / 100.0f; // 90-110%
        break;
    case HARD:
        angleError = (float)(rand() % 10 - 5) / 1000.0f; // +/- ~0.3 deg
        powerErrorFactor = 0.98f + (float)(rand() % 4) / 100.0f; // 98-102%
        break;
    }
    shotInfo.angle += angleError;
    shotInfo.power *= powerErrorFactor;
    shotInfo.power = std::max(1.0f, std::min(shotInfo.power, MAX_SHOT_POWER)); // Clamp power

    return shotInfo;
}


// Calculates required power (simplified)
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist) {
    // Basic model: Power needed increases with total distance the balls need to travel.
    // Need enough power for cue ball to reach target AND target to reach pocket.
    float totalDist = cueToGhostDist + targetToPocketDist;

    // Map distance to power (needs tuning)
    // Let's say max power is needed for longest possible shot (e.g., corner to corner ~ 1000 units)
    float powerRatio = std::min(1.0f, totalDist / 800.0f); // Normalize based on estimated max distance

    float basePower = MAX_SHOT_POWER * 0.2f; // Minimum power to move balls reliably
    float variablePower = (MAX_SHOT_POWER * 0.8f) * powerRatio; // Scale remaining power range

    // Harder AI could adjust based on desired cue ball travel (more power for draw/follow)
    return std::min(MAX_SHOT_POWER, basePower + variablePower);
}

// Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex) {
    float targetToPocketX = pocketPositions[pocketIndex].x - targetBall->x;
    float targetToPocketY = pocketPositions[pocketIndex].y - targetBall->y;
    float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);

    if (dist < 1.0f) { // Target is basically in the pocket
        // Aim slightly off-center to avoid weird physics? Or directly at center?
        // For simplicity, return a point slightly behind center along the reverse line.
        return D2D1::Point2F(targetBall->x - targetToPocketX * 0.1f, targetBall->y - targetToPocketY * 0.1f);
    }

    // Normalize direction vector from target to pocket
    float nx = targetToPocketX / dist;
    float ny = targetToPocketY / dist;

    // Ghost ball position is diameter distance *behind* the target ball along this line
    float ghostX = targetBall->x - nx * (BALL_RADIUS * 2.0f);
    float ghostY = targetBall->y - ny * (BALL_RADIUS * 2.0f);

    return D2D1::Point2F(ghostX, ghostY);
}

// Checks if line segment is clear of obstructing balls
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2) {
    float dx = end.x - start.x;
    float dy = end.y - start.y;
    float segmentLenSq = dx * dx + dy * dy;

    if (segmentLenSq < 0.01f) return true; // Start and end are same point

    for (const auto& ball : balls) {
        if (ball.isPocketed) continue;
        if (ball.id == ignoredBallId1) continue;
        if (ball.id == ignoredBallId2) continue;

        // Check distance from ball center to the line segment
        float ballToStartX = ball.x - start.x;
        float ballToStartY = ball.y - start.y;

        // Project ball center onto the line defined by the segment
        float dot = (ballToStartX * dx + ballToStartY * dy) / segmentLenSq;

        D2D1_POINT_2F closestPointOnLine;
        if (dot < 0) { // Closest point is start point
            closestPointOnLine = start;
        }
        else if (dot > 1) { // Closest point is end point
            closestPointOnLine = end;
        }
        else { // Closest point is along the segment
            closestPointOnLine = D2D1::Point2F(start.x + dot * dx, start.y + dot * dy);
        }

        // Check if the closest point is within collision distance (ball radius + path radius)
        if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * BALL_RADIUS)) {
            // Consider slightly wider path check? Maybe BALL_RADIUS * 1.1f?
            // if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * 1.1f)*(BALL_RADIUS*1.1f)) {
            return false; // Path is blocked
        }
    }
    return true; // No obstructions found
}

// Finds the first ball hit along a path (simplified)
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq) {
    Ball* hitBall = nullptr;
    hitDistSq = -1.0f; // Initialize hit distance squared
    float minCollisionDistSq = -1.0f;

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    for (auto& ball : balls) {
        if (ball.isPocketed || ball.id == 0) continue; // Skip cue ball and pocketed

        float dx = ball.x - start.x;
        float dy = ball.y - start.y;

        // Project vector from start->ball onto the aim direction vector
        float dot = dx * cosA + dy * sinA;

        if (dot > 0) { // Ball is generally in front
            // Find closest point on aim line to the ball's center
            float closestPointX = start.x + dot * cosA;
            float closestPointY = start.y + dot * sinA;
            float distSq = GetDistanceSq(ball.x, ball.y, closestPointX, closestPointY);

            // Check if the aim line passes within the ball's radius
            if (distSq < (BALL_RADIUS * BALL_RADIUS)) {
                // Calculate distance from start to the collision point on the ball's circumference
                float backDist = sqrtf(std::max(0.f, BALL_RADIUS * BALL_RADIUS - distSq));
                float collisionDist = dot - backDist; // Distance along aim line to collision

                if (collisionDist > 0) { // Ensure collision is in front
                    float collisionDistSq = collisionDist * collisionDist;
                    if (hitBall == nullptr || collisionDistSq < minCollisionDistSq) {
                        minCollisionDistSq = collisionDistSq;
                        hitBall = &ball; // Found a closer hit ball
                    }
                }
            }
        }
    }
    hitDistSq = minCollisionDistSq; // Return distance squared to the first hit
    return hitBall;
}

// Basic check for reasonable AI aim angles (optional)
bool IsValidAIAimAngle(float angle) {
    // Placeholder - could check for NaN or infinity if calculations go wrong
    return isfinite(angle);
}

//midi func = start
void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
    while (isMusicPlaying) {
        MCI_OPEN_PARMS mciOpen = { 0 };
        mciOpen.lpstrDeviceType = TEXT(""sequencer"");
        mciOpen.lpstrElementName = midiPath;

        if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
            midiDeviceID = mciOpen.wDeviceID;

            MCI_PLAY_PARMS mciPlay = { 0 };
            mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

            // Wait for playback to complete
            MCI_STATUS_PARMS mciStatus = { 0 };
            mciStatus.dwItem = MCI_STATUS_MODE;

            do {
                mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                Sleep(100); // adjust as needed
            } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

void StartMidi(HWND hwnd, const TCHAR* midiPath) {
    if (isMusicPlaying) {
        StopMidi();
    }
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}

void StopMidi() {
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) musicThread.join();
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

/*void PlayGameMusic(HWND hwnd) {
    // Stop any existing playback
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) {
            musicThread.join();
        }
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }

    // Get the path of the executable
    TCHAR exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

    // Extract the directory path
    TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
    if (lastBackslash != NULL) {
        *(lastBackslash + 1) = '\0';
    }

    // Construct the full path to the MIDI file
    static TCHAR midiPath[MAX_PATH];
    _tcscpy_s(midiPath, MAX_PATH, exePath);
    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

    // Start the background playback
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}*/
//midi func = end

// --- Drawing Functions ---

void OnPaint() {
    HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

    if (SUCCEEDED(hr)) {
        pRenderTarget->BeginDraw();
        DrawScene(pRenderTarget); // Pass render target
        hr = pRenderTarget->EndDraw();

        if (hr == D2DERR_RECREATE_TARGET) {
            DiscardDeviceResources();
            // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
            // But the timer loop will trigger redraw anyway.
        }
    }
    // If CreateDeviceResources failed, EndDraw might not be called.
    // Consider handling this more robustly if needed.
}

void DrawScene(ID2D1RenderTarget* pRT) {
    if (!pRT) return;

    //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
    // Set background color to #ffffcd (RGB: 255, 255, 205)
    pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
    //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

    DrawTable(pRT, pFactory);
    DrawBalls(pRT);
    DrawAimingAids(pRT); // Includes cue stick if aiming
    DrawUI(pRT);
    DrawPowerMeter(pRT);
    DrawSpinIndicator(pRT);
    DrawPocketedBallsIndicator(pRT);
    DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

     // Draw Game Over Message
    if (currentGameState == GAME_OVER && pTextFormat) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
        if (pBrush) {
            D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
            pRT->DrawText(
                gameOverMessage.c_str(),
                (UINT32)gameOverMessage.length(),
                pTextFormat, // Use large format maybe?
                &layoutRect,
                pBrush
            );
            SafeRelease(&pBrush);
        }
    }

}

void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
    ID2D1SolidColorBrush* pBrush = nullptr;

    // === Draw Full Orange Frame (Table Border) ===
    ID2D1SolidColorBrush* pFrameBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    if (pFrameBrush) {
        D2D1_RECT_F outerRect = D2D1::RectF(
            TABLE_LEFT - CUSHION_THICKNESS,
            TABLE_TOP - CUSHION_THICKNESS,
            TABLE_RIGHT + CUSHION_THICKNESS,
            TABLE_BOTTOM + CUSHION_THICKNESS
        );
        pRT->FillRectangle(&outerRect, pFrameBrush);
        SafeRelease(&pFrameBrush);
    }

    // Draw Table Bed (Green Felt)
    pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
    if (!pBrush) return;
    D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
    pRT->FillRectangle(&tableRect, pBrush);
    SafeRelease(&pBrush);

    // Draw Cushions (Red Border)
    pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
    if (!pBrush) return;
    // Top Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    // Bottom Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    // Left Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    // Right Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    SafeRelease(&pBrush);


    // Draw Pockets (Black Circles)
    pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
    if (!pBrush) return;
    for (int i = 0; i < 6; ++i) {
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
        pRT->FillEllipse(&ellipse, pBrush);
    }
    SafeRelease(&pBrush);

    // Draw Headstring Line (White)
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    if (!pBrush) return;
    pRT->DrawLine(
        D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
        D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
        pBrush,
        1.0f // Line thickness
    );
    SafeRelease(&pBrush);

    // Draw Semicircle facing West (flat side East)
    // Draw Semicircle facing East (curved side on the East, flat side on the West)
    ID2D1PathGeometry* pGeometry = nullptr;
    HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
    if (SUCCEEDED(hr) && pGeometry)
    {
        ID2D1GeometrySink* pSink = nullptr;
        hr = pGeometry->Open(&pSink);
        if (SUCCEEDED(hr) && pSink)
        {
            float radius = 60.0f; // Radius for the semicircle
            D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

            // For a semicircle facing East (curved side on the East), use the top and bottom points.
            D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

            pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

            D2D1_ARC_SEGMENT arc = {};
            arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
            arc.size = D2D1::SizeF(radius, radius);
            arc.rotationAngle = 0.0f;
            // Use the correct identifier with the extra underscore:
            arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
            arc.arcSize = D2D1_ARC_SIZE_SMALL;

            pSink->AddArc(&arc);
            pSink->EndFigure(D2D1_FIGURE_END_OPEN);
            pSink->Close();
            SafeRelease(&pSink);

            ID2D1SolidColorBrush* pArcBrush = nullptr;
            //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
            pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
            if (pArcBrush)
            {
                pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                SafeRelease(&pArcBrush);
            }
        }
        SafeRelease(&pGeometry);
    }




}


void DrawBalls(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

    pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

    if (!pBrush || !pStripeBrush) {
        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
        return;
    }


    for (size_t i = 0; i < balls.size(); ++i) {
        const Ball& b = balls[i];
        if (!b.isPocketed) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            // Set main ball color
            pBrush->SetColor(b.color);
            pRT->FillEllipse(&ellipse, pBrush);

            // Draw Stripe if applicable
            if (b.type == BallType::STRIPE) {
                // Draw a white band across the middle (simplified stripe)
                D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                // Need to clip this rectangle to the ellipse bounds - complex!
                // Alternative: Draw two colored arcs leaving a white band.
                // Simplest: Draw a white circle inside, slightly smaller.
                D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                pBrush->SetColor(b.color); // Set back to stripe color
                pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                // Let's try drawing a thick white line across
                // This doesn't look great. Just drawing solid red for stripes for now.
            }

            // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
            // if (b.id != 0 && pTextFormat) {
            //     std::wstring numStr = std::to_wstring(b.id);
            //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
            //     ID2D1SolidColorBrush* pNumBrush = nullptr;
            //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
            //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
            //     // Create a smaller text format...
            //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
            //     SafeRelease(&pNumBrush);
            // }
        }
    }

    SafeRelease(&pBrush);
    SafeRelease(&pStripeBrush);
}


void DrawAimingAids(ID2D1RenderTarget* pRT) {
    // Condition check at start (Unchanged)
    //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
        //currentGameState != BREAKING && currentGameState != AIMING)
    //{
        //return;
    //}
        // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
    // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
    bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
        (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == BREAKING || currentGameState == AIMING);
    // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
    // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
        // NEW Condition: AI is displaying its aim
    bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
        return;
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    ID2D1StrokeStyle* pDashedStyle = nullptr;
    ID2D1SolidColorBrush* pCueBrush = nullptr;
    ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

    // Ensure render target is valid
    if (!pRT) return;

    // Create Brushes and Styles (check for failures)
    HRESULT hr;
    hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
    if FAILED(hr) { SafeRelease(&pBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
    // Create reflection brush (e.g., lighter shade or different color)
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
    // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
    D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
    ID2D1SolidColorBrush* pCyanBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
    if (FAILED(hr)) {
        SafeRelease(&pCyanBrush);
        // handle error if needed
    }
    // Create a Purple brush for primary and secondary lines
    D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
    ID2D1SolidColorBrush* pPurpleBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
    if (FAILED(hr)) {
        SafeRelease(&pPurpleBrush);
        // handle error if needed
    }

    if (pFactory) {
        D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
        strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
        hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        if FAILED(hr) { pDashedStyle = nullptr; }
    }


    // --- Cue Stick Drawing (Unchanged from previous fix) ---
    const float baseStickLength = 150.0f;
    const float baseStickThickness = 4.0f;
    float stickLength = baseStickLength * 1.4f;
    float stickThickness = baseStickThickness * 1.5f;
    float stickAngle = cueAngle + PI;
    float powerOffset = 0.0f;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
    if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
        powerOffset = shotPower * 5.0f;
    }
    D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
    D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
    pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


    // --- Projection Line Calculation ---
    float cosA = cosf(cueAngle);
    float sinA = sinf(cueAngle);
    float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
    D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
    D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

    // Find the first ball hit by the aiming ray
    Ball* hitBall = nullptr;
    float firstHitDistSq = -1.0f;
    D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
    D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

    hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
    if (hitBall) {
        // Calculate the point on the target ball's circumference
        float collisionDist = sqrtf(firstHitDistSq);
        ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
        // Calculate ghost ball position for this specific hit (used for projection consistency)
        ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
    }

    // Find the first rail hit by the aiming ray
    D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
    float minRailDistSq = rayLength * rayLength;
    int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

    // Define table edge segments for intersection checks
    D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
    D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
    D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
    D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

    D2D1_POINT_2F currentIntersection;

    // Check Left Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
    }
    // Check Right Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
    }
    // Check Top Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
    }
    // Check Bottom Rail
    if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
    }


    // --- Determine final aim line end point ---
    D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
    bool aimingAtRail = true;

    if (hitBall && firstHitDistSq < minRailDistSq) {
        // Ball collision is closer than rail collision
        finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
        aimingAtRail = false;
    }

    // --- Draw Primary Aiming Line ---
    pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

    // --- Draw Target Circle/Indicator ---
    D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
    pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

    // --- Draw Projection/Reflection Lines ---
    if (!aimingAtRail && hitBall) {
        // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
        D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
        pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // Calculate target ball projection based on impact line (cue collision point -> target center)
        float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
        // Clamp angle calculation if distance is tiny
        if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
            targetProjectionAngle = cueAngle; // Fallback if overlapping
        }

        D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
        D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
            hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
            hitBall->y + sinf(targetProjectionAngle) * 50.0f
        );
        // Draw solid line for target projection
        //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

    //new code start

                // Dual trajectory with edge-aware contact simulation
        D2D1_POINT_2F dir = {
            targetProjectionEnd.x - targetStartPoint.x,
            targetProjectionEnd.y - targetStartPoint.y
        };
        float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
        dir.x /= dirLen;
        dir.y /= dirLen;

        D2D1_POINT_2F perp = { -dir.y, dir.x };

        // Approximate cue ball center by reversing from tip
        D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
            targetStartPoint.x - dir.x * BALL_RADIUS,
            targetStartPoint.y - dir.y * BALL_RADIUS
        };

        // REAL contact-ball center - use your physics object's center:
        // (replace 'objectBallPos' with whatever you actually call it)
        // (targetStartPoint is already hitBall->x, hitBall->y)
        D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
        //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

       // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
       // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
       // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
       // and 'perp' is perpendicular to 'dir'.
       // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
        /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
            (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
            /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                (targetStartPoint.y - cueBallCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);*/

            // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
        D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

        // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
        float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
            (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
        float absOffset = fabsf(offset);
        float side = (offset >= 0 ? 1.0f : -1.0f);


        // Actual contact point on target ball edge
        D2D1_POINT_2F contactPoint = {
        contactBallCenter.x + perp.x * BALL_RADIUS * side,
        contactBallCenter.y + perp.y * BALL_RADIUS * side
        };

        // Tangent (cut shot) path from contact point
            // Tangent (cut shot) path: from contact point to contact ball center
        D2D1_POINT_2F objectBallDir = {
            contactBallCenter.x - contactPoint.x,
            contactBallCenter.y - contactPoint.y
        };
        float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
        if (oLen != 0.0f) {
            objectBallDir.x /= oLen;
            objectBallDir.y /= oLen;
        }

        const float PRIMARY_LEN = 150.0f; //default=150.0f
        const float SECONDARY_LEN = 150.0f; //default=150.0f
        const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

        D2D1_POINT_2F primaryEnd = {
            targetStartPoint.x + dir.x * PRIMARY_LEN,
            targetStartPoint.y + dir.y * PRIMARY_LEN
        };

        // Secondary line starts from the contact ball's center
        D2D1_POINT_2F secondaryStart = contactBallCenter;
        D2D1_POINT_2F secondaryEnd = {
            secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
            secondaryStart.y + objectBallDir.y * SECONDARY_LEN
        };

        if (absOffset < STRAIGHT_EPSILON)  // straight shot?
        {
            // Straight: secondary behind primary
                    // secondary behind primary {pDashedStyle param at end}
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        else
        {
            // Cut shot: both visible
                    // both visible for cut shot
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        // End improved trajectory logic

    //new code end

        // -- Cue Ball Path after collision (Optional, requires physics) --
        // Very simplified: Assume cue deflects, angle depends on cut angle.
        // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
        // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
        // D2D1_POINT_2F cueProjectionEnd = ...
        // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Accuracy Comment ---
        // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
        // or shots with spin, is limited by the simplified physics model. Real pool physics involves
        // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
        // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

    }
    else if (aimingAtRail && hitRailIndex != -1) {
        // Aiming at a rail: Draw reflection line
        float reflectAngle = cueAngle;
        // Reflect angle based on which rail was hit
        if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
            reflectAngle = PI - cueAngle; // Reflect horizontal component
        }
        else { // Top or Bottom rail
            reflectAngle = -cueAngle; // Reflect vertical component
        }
        // Normalize angle if needed (atan2 usually handles this)
        while (reflectAngle > PI) reflectAngle -= 2 * PI;
        while (reflectAngle <= -PI) reflectAngle += 2 * PI;


        float reflectionLength = 60.0f; // Length of the reflection line
        D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
            finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
            finalLineEnd.y + sinf(reflectAngle) * reflectionLength
        );

        // Draw the reflection line (e.g., using a different color/style)
        pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
    }

    // Release resources
    SafeRelease(&pBrush);
    SafeRelease(&pGhostBrush);
    SafeRelease(&pCueBrush);
    SafeRelease(&pReflectBrush); // Release new brush
    SafeRelease(&pCyanBrush);
    SafeRelease(&pPurpleBrush);
    SafeRelease(&pDashedStyle);
}


void DrawUI(ID2D1RenderTarget* pRT) {
    if (!pTextFormat || !pLargeTextFormat) return;

    ID2D1SolidColorBrush* pBrush = nullptr;
    pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
    if (!pBrush) return;

    // --- Player Info Area (Top Left/Right) --- (Unchanged)
    float uiTop = TABLE_TOP - 80;
    float uiHeight = 60;
    float p1Left = TABLE_LEFT;
    float p1Width = 150;
    float p2Left = TABLE_RIGHT - p1Width;
    D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
    D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

    // Player 1 Info Text (Unchanged)
    std::wostringstream oss1;
    oss1 << player1Info.name.c_str() << L""\n"";
    if (player1Info.assignedType != BallType::NONE) {
        oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss1 << L""(Undecided)"";
    }
    pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
    // Draw Player 1 Side Ball
    if (player1Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player1Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // Player 2 Info Text (Unchanged)
    std::wostringstream oss2;
    oss2 << player2Info.name.c_str() << L""\n"";
    if (player2Info.assignedType != BallType::NONE) {
        oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss2 << L""(Undecided)"";
    }
    pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
    // Draw Player 2 Side Ball
    if (player2Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player2Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
        arrowBackX = playerBox.left - 25.0f;
        arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

        float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
        float notchWidth = 10.0f;

        float cx = arrowBackX;
        float cy = arrowCenterY;

        // Define triangle + rectangle tail shape
        D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
        D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
        D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

        // Rectangle coordinates for the tail portion:
        D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
        D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
        D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
        D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseTop);
                pSink->AddLine(r2); // transition from triangle into rectangle
                pSink->AddLine(r1);
                pSink->AddLine(r4);
                pSink->AddLine(r3);
                pSink->AddLine(baseBot);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }


        SafeRelease(&pArrowBrush);
    }

    //original
/*
    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        if (currentPlayer == 1) {
arrowBackX = p1Rect.left - 25.0f; // Position left of the box
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
            // Define points for right-pointing arrow
            //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
            //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
            //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
            // Enhanced arrow with base rectangle intersection
    float notchDepth = 6.0f; // Depth of square base ""stem""
    float notchWidth = 4.0f; // Thickness of square part

    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
    D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
    D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
        }


        //==================else player 2
        else { // Player 2
         // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
         // Let's keep it consistent: Arrow left of the active player's box, pointing right.
// Let's keep it consistent: Arrow left of the active player's box, pointing right.
arrowBackX = p2Rect.left - 25.0f; // Position left of the box
arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
// Define points for right-pointing arrow
D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

ID2D1PathGeometry* pPath = nullptr;
if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
    ID2D1GeometrySink* pSink = nullptr;
    if (SUCCEEDED(pPath->Open(&pSink))) {
        pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
        pSink->AddLine(pt2);
        pSink->AddLine(pt3);
        pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
        pSink->Close();
        SafeRelease(&pSink);
        pRT->FillGeometry(pPath, pArrowBrush);
    }
    SafeRelease(&pPath);
}
        }
        */

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
    // --- 8-Ball Pocket Selection Indicator ---
    if (currentGameState == SELECT_EIGHT_POCKET_P1
        || currentGameState == SELECT_EIGHT_POCKET_P2) {
        // Draw down-pointing arrow at chosen pocket
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush) {
            auto P = pocketPositions[selectedPocketIndex];
            // Triangle points
            D2D1_POINT_2F tri[3] = {
                {P.x - 10, P.y - 30},
                {P.x + 10, P.y - 30},
                {P.x,     P.y - 10}
            };
            // Build and fill geometry
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrowBrush);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrowBrush);
        }
        // Prompt text below table
        D2D1_RECT_F promptRect = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &promptRect,
            pBrush
        );
        // Stop here so turn/foul text does not draw underneath
        SafeRelease(&pBrush);
        return;
    }

    // --- Foul / Turn Indicator ---
    if (foulCommitted) {
        ID2D1SolidColorBrush* pFoulBrush = nullptr;
        pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
        if (pFoulBrush) {
            D2D1_RECT_F foulRect = D2D1::RectF(p1Rect.left, p1Rect.bottom + 10,
                p2Rect.right, p1Rect.bottom + 50);
            pRT->DrawText(gameOverMessage.c_str(),
                (UINT32)gameOverMessage.length(),
                pLargeTextFormat,
                &foulRect,
                pFoulBrush);
            SafeRelease(&pFoulBrush);
        }
    }

    // Show AI Thinking State (Unchanged from previous step)
    if (currentGameState == AI_THINKING && pTextFormat) {
        ID2D1SolidColorBrush* pThinkingBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
        if (pThinkingBrush) {
            D2D1_RECT_F thinkingRect = p2Rect;
            thinkingRect.top += 20; // Offset within P2 box
            // Ensure default text alignment for this
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
            SafeRelease(&pThinkingBrush);
        }
    }

    SafeRelease(&pBrush);

    // --- Draw CHEAT MODE label if active ---
    if (cheatModeEnabled) {
        ID2D1SolidColorBrush* pCheatBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
        if (pCheatBrush && pTextFormat) {
            D2D1_RECT_F cheatTextRect = D2D1::RectF(
                TABLE_LEFT + 10.0f,
                TABLE_TOP + 10.0f,
                TABLE_LEFT + 200.0f,
                TABLE_TOP + 40.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
        }
        SafeRelease(&pCheatBrush);
    }
}

void DrawPowerMeter(ID2D1RenderTarget* pRT) {
    // Draw Border
    ID2D1SolidColorBrush* pBorderBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
    if (!pBorderBrush) return;
    pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
    SafeRelease(&pBorderBrush);

    // Create Gradient Fill
    ID2D1GradientStopCollection* pGradientStops = nullptr;
    ID2D1LinearGradientBrush* pGradientBrush = nullptr;
    D2D1_GRADIENT_STOP gradientStops[4];
    gradientStops[0].position = 0.0f;
    gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
    gradientStops[1].position = 0.45f;
    gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
    gradientStops[2].position = 0.7f;
    gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
    gradientStops[3].position = 1.0f;
    gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

    pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
    if (pGradientStops) {
        D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
        props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
        props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
        pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
        SafeRelease(&pGradientStops);
    }

    // Calculate Fill Height
    float fillRatio = 0;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Determine if power meter should reflect shot power (human aiming or AI preparing)
    bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
    // NEW Condition: AI is displaying its aim, so show its chosen power
    bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
        fillRatio = shotPower / MAX_SHOT_POWER;
    }
    float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
    D2D1_RECT_F fillRect = D2D1::RectF(
        powerMeterRect.left,
        powerMeterRect.bottom - fillHeight,
        powerMeterRect.right,
        powerMeterRect.bottom
    );

    if (pGradientBrush) {
        pRT->FillRectangle(&fillRect, pGradientBrush);
        SafeRelease(&pGradientBrush);
    }

    // Draw scale notches
    ID2D1SolidColorBrush* pNotchBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
    if (pNotchBrush) {
        for (int i = 0; i <= 8; ++i) {
            float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
            pRT->DrawLine(
                D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                pNotchBrush,
                1.5f
            );
        }
        SafeRelease(&pNotchBrush);
    }

    // Draw ""Power"" Label Below Meter
    if (pTextFormat) {
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
        if (pTextBrush) {
            D2D1_RECT_F textRect = D2D1::RectF(
                powerMeterRect.left - 20.0f,
                powerMeterRect.bottom + 8.0f,
                powerMeterRect.right + 20.0f,
                powerMeterRect.bottom + 38.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
            SafeRelease(&pTextBrush);
        }
    }

    // Draw Glow Effect if fully charged or fading out
    static float glowPulse = 0.0f;
    static bool glowIncreasing = true;
    static float glowFadeOut = 0.0f; // NEW: tracks fading out

    if (shotPower >= MAX_SHOT_POWER * 0.99f) {
        // While fully charged, keep pulsing normally
        if (glowIncreasing) {
            glowPulse += 0.02f;
            if (glowPulse >= 1.0f) glowIncreasing = false;
        }
        else {
            glowPulse -= 0.02f;
            if (glowPulse <= 0.0f) glowIncreasing = true;
        }
        glowFadeOut = 1.0f; // Reset fade out to full
    }
    else if (glowFadeOut > 0.0f) {
        // If shot fired, gradually fade out
        glowFadeOut -= 0.02f;
        if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
    }

    if (glowFadeOut > 0.0f) {
        ID2D1SolidColorBrush* pGlowBrush = nullptr;
        float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
        pRT->CreateSolidColorBrush(
            D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
            &pGlowBrush
        );
        if (pGlowBrush) {
            float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
            float glowCenterY = powerMeterRect.top;
            D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                12.0f + 3.0f * glowPulse,
                6.0f + 2.0f * glowPulse
            );
            pRT->FillEllipse(&glowEllipse, pGlowBrush);
            SafeRelease(&pGlowBrush);
        }
    }
}

void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pWhiteBrush = nullptr;
    ID2D1SolidColorBrush* pRedBrush = nullptr;

    pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
    pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

    if (!pWhiteBrush || !pRedBrush) {
        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
        return;
    }

    // Draw White Ball Background
    D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
    pRT->FillEllipse(&bgEllipse, pWhiteBrush);
    pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


    // Draw Red Dot for Spin Position
    float dotRadius = 4.0f;
    float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
    float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
    D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
    pRT->FillEllipse(&dotEllipse, pRedBrush);

    SafeRelease(&pWhiteBrush);
    SafeRelease(&pRedBrush);
}


void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBgBrush = nullptr;
    ID2D1SolidColorBrush* pBallBrush = nullptr;

    // Ensure render target is valid before proceeding
    if (!pRT) return;

    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
    if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
    if (FAILED(hr)) {
        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
        return; // Exit if brush creation fails
    }

    // Draw the background bar (rounded rect)
    D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
    float baseAlpha = 0.8f;
    float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
    float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
    pBgBrush->SetOpacity(finalAlpha);
    pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
    pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

    // --- Draw small circles for pocketed balls inside the bar ---

    // Calculate dimensions based on the bar's height for better scaling
    float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
    float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
    float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
    float padding = spacing * 0.75f; // Add padding from the edges
    float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

    // Starting X positions with padding
    float currentX_P1 = pocketedBallsBarRect.left + padding;
    float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

    int p1DrawnCount = 0;
    int p2DrawnCount = 0;
    const int maxBallsToShow = 7; // Max balls per player in the bar

    for (const auto& b : balls) {
        if (b.isPocketed) {
            // Skip cue ball and 8-ball in this indicator
            if (b.id == 0 || b.id == 8) continue;

            bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
            bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

            if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P1 balls from left to right
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p1DrawnCount++;
            }
            else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P2 balls from right to left
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p2DrawnCount++;
            }
            // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
            // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
        }
    }

    SafeRelease(&pBgBrush);
    SafeRelease(&pBallBrush);
}

void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
    if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
        return; // Only show when placing/dragging
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

    if (pGhostBrush) {
        D2D1_POINT_2F drawPos;
        if (isDraggingCueBall) {
            drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
        }
        else {
            // If not dragging but in placement state, show at current ball pos
            drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
        }

        // Check if the placement is valid before drawing differently?
        bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
        bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

        if (!isValid) {
            // Maybe draw red outline if invalid placement?
            pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
        }


        D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
        pRT->FillEllipse(&ghostEllipse, pGhostBrush);
        pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

        SafeRelease(&pGhostBrush);
    }
}"
XejPB3RH,Pool Original Stable w/o Experimental Features (JUSTINCASE),alien_fx_fiend,C++,Friday 27th of June 2025 08:26:58 AM CDT,"#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#include <d2d1.h>
#include <dwrite.h>
#include <fstream> // For file I/O
#include <iostream> // For some basic I/O, though not strictly necessary for just file ops
#include <vector>
#include <cmath>
#include <string>
#include <sstream> // Required for wostringstream
#include <algorithm> // Required for std::max, std::min
#include <ctime>    // Required for srand, time
#include <cstdlib> // Required for srand, rand (often included by others, but good practice)
#include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
#include <mmsystem.h> // For PlaySound
#include <tchar.h> //midi func
#include <thread>
#include <atomic>
#include ""resource.h""

#pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""dwrite.lib"")
#pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

// --- Constants ---
const float PI = 3.1415926535f;
const float BALL_RADIUS = 10.0f;
const float TABLE_LEFT = 100.0f;
const float TABLE_TOP = 100.0f;
const float TABLE_WIDTH = 700.0f;
const float TABLE_HEIGHT = 350.0f;
const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
const float CUSHION_THICKNESS = 20.0f;
const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
const float MAX_SHOT_POWER = 15.0f;
const float FRICTION = 0.985f; // Friction factor per frame
const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
const UINT ID_TIMER = 1;
const int TARGET_FPS = 60; // Target frames per second for timer

// --- Enums ---
// --- MODIFIED/NEW Enums ---
enum GameState {
    SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
    PRE_BREAK_PLACEMENT,// Player placing cue ball for break
    BREAKING,           // Player is aiming/shooting the break shot
    AIMING,             // Player is aiming
    AI_THINKING,        // NEW: AI is calculating its move
    SHOT_IN_PROGRESS,   // Balls are moving
    ASSIGNING_BALLS,    // Turn after break where ball types are assigned
    PLAYER1_TURN,
    PLAYER2_TURN,
    BALL_IN_HAND_P1,
    BALL_IN_HAND_P2,
    GAME_OVER
};

enum BallType {
    NONE,
    SOLID,  // Yellow (1-7)
    STRIPE, // Red (9-15)
    EIGHT_BALL, // Black (8)
    CUE_BALL // White (0)
};

// NEW Enums for Game Mode and AI Difficulty
enum GameMode {
    HUMAN_VS_HUMAN,
    HUMAN_VS_AI
};

enum AIDifficulty {
    EASY,
    MEDIUM,
    HARD
};

enum OpeningBreakMode {
    CPU_BREAK,
    P1_BREAK,
    FLIP_COIN_BREAK
};

// --- Structs ---
struct Ball {
    int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
    BallType type;
    float x, y;
    float vx, vy;
    D2D1_COLOR_F color;
    bool isPocketed;
};

struct PlayerInfo {
    BallType assignedType;
    int ballsPocketedCount;
    std::wstring name;
};

// --- Global Variables ---

// Direct2D & DirectWrite
ID2D1Factory* pFactory = nullptr;
//ID2D1Factory* g_pD2DFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""

// Game State
HWND hwndMain = nullptr;
GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
std::vector<Ball> balls;
int currentPlayer = 1; // 1 or 2
PlayerInfo player1Info = { BallType::NONE, 0, L""Player 1"" };
PlayerInfo player2Info = { BallType::NONE, 0, L""CPU"" }; // Default P2 name
bool foulCommitted = false;
std::wstring gameOverMessage = L"""";
bool firstBallPocketedAfterBreak = false;
std::vector<int> pocketedThisTurn;
// --- NEW: Foul Tracking Globals ---
int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
// --- End New Foul Tracking Globals ---

// NEW Game Mode/AI Globals
GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
// bool aiIsThinking = false;       // Replaced by AI_THINKING game state
// NEW: Flag to indicate if the current shot is the opening break of the game
bool isOpeningBreakShot = false;

// NEW: For AI shot planning and visualization
struct AIPlannedShot {
    float angle;
    float power;
    float spinX;
    float spinY;
    bool isValid; // Is there a valid shot planned?
};
AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

// Input & Aiming
POINT ptMouse = { 0, 0 };
bool isAiming = false;
bool isDraggingCueBall = false;
// --- ENSURE THIS LINE EXISTS HERE ---
bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
// --- End Ensure ---
bool isSettingEnglish = false;
D2D1_POINT_2F aimStartPoint = { 0, 0 };
float cueAngle = 0.0f;
float shotPower = 0.0f;
float cueSpinX = 0.0f; // Range -1 to 1
float cueSpinY = 0.0f; // Range -1 to 1
float pocketFlashTimer = 0.0f;
bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
int draggingBallId = -1;
bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
MCIDEVICEID midiDeviceID = 0; //midi func
std::atomic<bool> isMusicPlaying(false); //midi func
std::thread musicThread; //midi func
void StartMidi(HWND hwnd, const TCHAR* midiPath);
void StopMidi();

// UI Element Positions
D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

// Corrected Pocket Center Positions (aligned with table corners/edges)
const D2D1_POINT_2F pocketPositions[6] = {
    {TABLE_LEFT, TABLE_TOP},                           // Top-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
    {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
    {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
    {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
    {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
};

// Colors
const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.1608f, 0.4000f, 0.1765f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
//const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
//const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Yellow); // Solids = Yellow
const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::Red);   // Stripes = Red
const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
//const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

// --- Forward Declarations ---
HRESULT CreateDeviceResources();
void DiscardDeviceResources();
void OnPaint();
void OnResize(UINT width, UINT height);
void InitGame();
void GameUpdate();
void UpdatePhysics();
void CheckCollisions();
bool CheckPockets(); // Returns true if any ball was pocketed
void ProcessShotResults();
void ApplyShot(float power, float angle, float spinX, float spinY);
void RespawnCueBall(bool behindHeadstring);
bool AreBallsMoving();
void SwitchTurns();
void AssignPlayerBallTypes(BallType firstPocketedType);
void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
Ball* GetBallById(int id);
Ball* GetCueBall();
//void PlayGameMusic(HWND hwnd); //midi func
void AIBreakShot();

// Drawing Functions
void DrawScene(ID2D1RenderTarget* pRT);
void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
void DrawBalls(ID2D1RenderTarget* pRT);
void DrawCueStick(ID2D1RenderTarget* pRT);
void DrawAimingAids(ID2D1RenderTarget* pRT);
void DrawUI(ID2D1RenderTarget* pRT);
void DrawPowerMeter(ID2D1RenderTarget* pRT);
void DrawSpinIndicator(ID2D1RenderTarget* pRT);
void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);

// Helper Functions
float GetDistance(float x1, float y1, float x2, float y2);
float GetDistanceSq(float x1, float y1, float x2, float y2);
bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
template <typename T> void SafeRelease(T** ppT);
// --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
// --- End Forward Declaration ---
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

// --- NEW Forward Declarations ---

// AI Related
struct AIShotInfo; // Define below
void TriggerAIMove();
void AIMakeDecision();
void AIPlaceCueBall();
AIShotInfo AIFindBestShot();
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
bool IsValidAIAimAngle(float angle); // Basic check

// Dialog Related
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void ShowNewGameDialog(HINSTANCE hInstance);
void LoadSettings(); // For deserialization
void SaveSettings(); // For serialization
const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

// --- Forward Declaration for Window Procedure --- <<< Add this line HERE
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// --- NEW Struct for AI Shot Evaluation ---
struct AIShotInfo {
    bool possible = false;          // Is this shot considered viable?
    Ball* targetBall = nullptr;     // Which ball to hit
    int pocketIndex = -1;           // Which pocket to aim for (0-5)
    D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
    float angle = 0.0f;             // Calculated shot angle
    float power = 0.0f;             // Calculated shot power
    float score = -1.0f;            // Score for this shot (higher is better)
    bool involves8Ball = false;     // Is the target the 8-ball?
};

/*
table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
*/

// --- NEW Settings Serialization Functions ---
void SaveSettings() {
    std::ofstream outFile(SETTINGS_FILE_NAME);
    if (outFile.is_open()) {
        outFile << static_cast<int>(gameMode) << std::endl;
        outFile << static_cast<int>(aiDifficulty) << std::endl;
        outFile << static_cast<int>(openingBreakMode) << std::endl;
        outFile.close();
    }
    // else: Handle error, e.g., log or silently fail
}

void LoadSettings() {
    std::ifstream inFile(SETTINGS_FILE_NAME);
    if (inFile.is_open()) {
        int gm, aid, obm;
        if (inFile >> gm) {
            gameMode = static_cast<GameMode>(gm);
        }
        if (inFile >> aid) {
            aiDifficulty = static_cast<AIDifficulty>(aid);
        }
        if (inFile >> obm) {
            openingBreakMode = static_cast<OpeningBreakMode>(obm);
        }
        inFile.close();

        // Validate loaded settings (optional, but good practice)
        if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
        if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
        if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
    }
    // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
}
// --- End Settings Serialization Functions ---

// --- NEW Dialog Procedure ---
INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_INITDIALOG:
    {
        // --- ACTION 4: Center Dialog Box ---
// Optional: Force centering if default isn't working
        RECT rcDlg, rcOwner, rcScreen;
        HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
        if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

        GetWindowRect(hwndOwner, &rcOwner);
        GetWindowRect(hDlg, &rcDlg);
        CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

        // Offset the owner rect relative to the screen if it's not the desktop
        if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
            OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
            OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
        }


        // Calculate centered position
        int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
        int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

        // Ensure it stays within screen bounds (optional safety)
        x = std::max(static_cast<int>(rcScreen.left), x);
        y = std::max(static_cast<int>(rcScreen.top), y);
        if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
            x = rcScreen.right - (rcDlg.right - rcDlg.left);
        if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
            y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


        // Set the dialog position
        SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

        // --- End Centering Code ---

        // Set initial state based on current global settings (or defaults)
        CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

        CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
            (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

        // Enable/Disable AI group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
        // Set initial state for Opening Break Mode
        CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
            (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
        // Enable/Disable Opening Break group based on initial mode
        EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
    }
    return (INT_PTR)TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_RADIO_2P:
        case IDC_RADIO_CPU:
        {
            bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
            // Enable/Disable AI group controls based on selection
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
            // Also enable/disable Opening Break Mode group
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
        }
        return (INT_PTR)TRUE;

        case IDOK:
            // Retrieve selected options and store in global variables
            if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                gameMode = HUMAN_VS_AI;
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
            }
            else {
                gameMode = HUMAN_VS_HUMAN;
                // openingBreakMode doesn't apply to HvsH, can leave as is or reset
            }
            SaveSettings(); // Save settings when OK is pressed
            EndDialog(hDlg, IDOK); // Close dialog, return IDOK
            return (INT_PTR)TRUE;

        case IDCANCEL: // Handle Cancel or closing the dialog
            // Optionally, could reload settings here if you want cancel to revert to previously saved state
            EndDialog(hDlg, IDCANCEL);
            return (INT_PTR)TRUE;
        }
        break; // End WM_COMMAND
    }
    return (INT_PTR)FALSE; // Default processing
}

// --- NEW Helper to Show Dialog ---
void ShowNewGameDialog(HINSTANCE hInstance) {
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
        // User clicked Start, reset game with new settings
        isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""CPU (Easy)""; break;
            case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
            case HARD: player2Info.name = L""CPU (Hard)""; break;
            }
        }
        else {
            player2Info.name = L""Player 2"";
        }
        // Update window title
        std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
        SetWindowText(hwndMain, windowTitle.c_str());

        InitGame(); // Re-initialize game logic & board
        InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
    }
    else {
        // User cancelled dialog - maybe just resume game? Or exit?
        // For simplicity, we do nothing, game continues as it was.
        // To exit on cancel from F2, would need more complex state management.
    }
}

// --- NEW Reset Game Function ---
void ResetGame(HINSTANCE hInstance) {
    // Call the helper function to show the dialog and re-init if OK clicked
    ShowNewGameDialog(hInstance);
}

// --- WinMain ---
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
    if (FAILED(CoInitialize(NULL))) {
        MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
        return -1;
    }

    // --- NEW: Load settings at startup ---
    LoadSettings();

    // --- NEW: Show configuration dialog FIRST ---
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
        // User cancelled the dialog
        CoUninitialize();
        return 0; // Exit gracefully if dialog cancelled
    }
    // Global gameMode and aiDifficulty are now set by the DialogProc

    // Set AI flag based on game mode
    isPlayer2AI = (gameMode == HUMAN_VS_AI);
    if (isPlayer2AI) {
        switch (aiDifficulty) {
        case EASY: player2Info.name = L""CPU (Easy)""; break;
        case MEDIUM: player2Info.name = L""CPU (Medium)""; break;
        case HARD: player2Info.name = L""CPU (Hard)""; break;
        }
    }
    else {
        player2Info.name = L""Player 2"";
    }
    // --- End of Dialog Logic ---


    WNDCLASS wc = { };
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L""Direct2D_8BallPool"";
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

    if (!RegisterClass(&wc)) {
        MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // --- ACTION 4: Calculate Centered Window Position ---
    const int WINDOW_WIDTH = 1000; // Define desired width
    const int WINDOW_HEIGHT = 700; // Define desired height
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowX = (screenWidth - WINDOW_WIDTH) / 2;
    int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

    // --- Change Window Title based on mode ---
    std::wstring windowTitle = L""Direct2D 8-Ball Pool"";
    if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
    else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

    DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

    hwndMain = CreateWindowEx(
        0, L""Direct2D_8BallPool"", windowTitle.c_str(), dwStyle,
        windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
        NULL, NULL, hInstance, NULL
    );

    if (!hwndMain) {
        MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
        CoUninitialize();
        return -1;
    }

    // Initialize Direct2D Resources AFTER window creation
    if (FAILED(CreateDeviceResources())) {
        MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    InitGame(); // Initialize game state AFTER resources are ready & mode is set
    Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
    StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
    //PlayGameMusic(hwndMain); //midi func

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
        MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
        DestroyWindow(hwndMain);
        CoUninitialize();
        return -1;
    }

    MSG msg = { };
    // --- Modified Main Loop ---
    // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
    // or gets reset to it via F2. The main loop runs normally once game starts.
    while (GetMessage(&msg, NULL, 0, 0)) {
        // We might need modeless dialog handling here if F2 shows dialog
        // while window is active, but DialogBoxParam is modal.
        // Let's assume F2 hides main window, shows dialog, then restarts game loop.
        // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    KillTimer(hwndMain, ID_TIMER);
    DiscardDeviceResources();
    SaveSettings(); // Save settings on exit
    CoUninitialize();

    return (int)msg.wParam;
}

// --- WndProc ---
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // Declare cueBall pointer once at the top, used in multiple cases
    // For clarity, often better to declare within each case where needed.
    Ball* cueBall = nullptr; // Initialize to nullptr
    switch (msg) {
    case WM_CREATE:
        // Resources are now created in WinMain after CreateWindowEx
        return 0;

    case WM_PAINT:
        OnPaint();
        // Validate the entire window region after painting
        ValidateRect(hwnd, NULL);
        return 0;

    case WM_SIZE: {
        UINT width = LOWORD(lParam);
        UINT height = HIWORD(lParam);
        OnResize(width, height);
        return 0;
    }

    case WM_TIMER:
        if (wParam == ID_TIMER) {
            GameUpdate(); // Update game logic and physics
            InvalidateRect(hwnd, NULL, FALSE); // Request redraw
        }
        return 0;

        // --- NEW: Handle F2 Key for Reset ---
        // --- MODIFIED: Handle More Keys ---
    case WM_KEYDOWN:
    { // Add scope for variable declarations

        // --- FIX: Get Cue Ball pointer for this scope ---
        cueBall = GetCueBall();
        // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
        // --- End Fix ---

        // Check which player can interact via keyboard (Humans only)
        bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

        // --- F1 / F2 Keys (Always available) ---
        if (wParam == VK_F2) {
            HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
            ResetGame(hInstance); // Call reset function
            return 0; // Indicate key was processed
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Direct2D-based StickPool game made in C++ from scratch (2764+ lines of code)\n"" // Update line count if needed
                L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions.\n""
                L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                L""About This Game"", MB_OK | MB_ICONINFORMATION);
            return 0; // Indicate key was processed
        }

        // Check for 'M' key (uppercase or lowercase)
            // Toggle music with ""M""
        if (wParam == 'M' || wParam == 'm') {
            //static bool isMusicPlaying = false;
            if (isMusicPlaying) {
                // Stop the music
                StopMidi();
                isMusicPlaying = false;
            }
            else {
                // Build the MIDI file path
                TCHAR midiPath[MAX_PATH];
                GetModuleFileName(NULL, midiPath, MAX_PATH);
                // Keep only the directory part
                TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                if (lastBackslash != NULL) {
                    *(lastBackslash + 1) = '\0';
                }
                // Append the MIDI filename
                _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                // Start playing MIDI
                StartMidi(hwndMain, midiPath);
                isMusicPlaying = true;
            }
        }


        // --- Player Interaction Keys (Only if allowed) ---
        if (canPlayerControl) {
            // --- Get Shift Key State ---
            bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
            float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
            float powerStep = 0.2f; // Power step (Adjust as needed)

            switch (wParam) {
            case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle -= angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle < 0) cueAngle += 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_RIGHT: // Rotate Cue Stick Clockwise
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    cueAngle += angleStep;
                    // Normalize angle (keep between 0 and 2*PI)
                    if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_UP: // Decrease Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower -= powerStep;
                    if (shotPower < 0.0f) shotPower = 0.0f;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_DOWN: // Increase Shot Power
                if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                    shotPower += powerStep;
                    if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                    // Ensure state shows aiming visuals if turn just started
                    if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                    isAiming = true;
                    isDraggingStick = false;
                    keyboardAimingActive = true;
                }
                break;

            case VK_SPACE: // Trigger Shot
                if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                    && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                {
                    if (shotPower > 0.15f) { // Use same threshold as mouse
                       // Reset foul flags BEFORE applying shot
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;

                        // Play sound & Apply Shot
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                        // Update State
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false;
                        pocketedThisTurn.clear();
                        shotPower = 0; // Reset power after shooting
                        isAiming = false; isDraggingStick = false; // Reset aiming flags
                        keyboardAimingActive = false;
                    }
                }
                break;

            case VK_ESCAPE: // Cancel Aim/Shot Setup
                if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                {
                    shotPower = 0.0f;
                    isAiming = false;
                    isDraggingStick = false;
                    keyboardAimingActive = false;
                    // Revert to basic turn state if not breaking
                    if (currentGameState != BREAKING) {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    }
                }
                break;

            case 'G': // Toggle Cheat Mode
                cheatModeEnabled = !cheatModeEnabled;
                if (cheatModeEnabled)
                    MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                else
                    MessageBeep(MB_OK); // Play a different beep when disabling
                break;

            default:
                // Allow default processing for other keys if needed
                // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                break;
            } // End switch(wParam) for player controls
            return 0; // Indicate player control key was processed
        } // End if(canPlayerControl)
    } // End scope for WM_KEYDOWN case
    // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
    // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
    return 0;

    case WM_MOUSEMOVE: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        cueBall = GetCueBall(); // Declare and get cueBall pointer

        if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
            Ball* ball = GetBallById(draggingBallId);
            if (ball) {
                ball->x = (float)ptMouse.x;
                ball->y = (float)ptMouse.y;
                ball->vx = ball->vy = 0.0f;
            }
            return 0;
        }

        if (!cueBall) return 0;

        // Update Aiming Logic (Check player turn)
        if (isDraggingCueBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                currentGameState == PRE_BREAK_PLACEMENT))
        {
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            // Tentative position update
            cueBall->x = (float)ptMouse.x;
            cueBall->y = (float)ptMouse.y;
            cueBall->vx = cueBall->vy = 0;
        }
        else if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            //NEW2 MOUSEBOUND CODE = START
                /*// Clamp mouse inside table bounds during aiming
                if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
            if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
            if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
            if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
            //NEW2 MOUSEBOUND CODE = END
            // Aiming drag updates angle and power
            float dx = (float)ptMouse.x - cueBall->x;
            float dy = (float)ptMouse.y - cueBall->y;
            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
            //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
            //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
            }
        }
        else if (isSettingEnglish &&
            ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
        {
            // Setting English
            float dx = (float)ptMouse.x - spinIndicatorCenter.x;
            float dy = (float)ptMouse.y - spinIndicatorCenter.y;
            float dist = GetDistance(dx, dy, 0, 0);
            if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
            cueSpinX = dx / spinIndicatorRadius;
            cueSpinY = dy / spinIndicatorRadius;
        }
        else {
            //DISABLE PERM AIMING = START
            /*// Update visual angle even when not aiming/dragging (Check player turn)
            bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

            if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
            {
                // NEW MOUSEBOUND CODE = START
                    // Only update cue angle if mouse is inside the playable table area
                if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                    ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                {
                    // NEW MOUSEBOUND CODE = END
                    Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                    if (cb) {
                        float dx = (float)ptMouse.x - cb->x;
                        float dy = (float)ptMouse.y - cb->y;
                        if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    }
                } //NEW MOUSEBOUND CODE LINE = DISABLE
            }*/
            //DISABLE PERM AIMING = END
        }
        return 0;
    } // End WM_MOUSEMOVE

    case WM_LBUTTONDOWN: {
        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        if (cheatModeEnabled) {
            // Allow dragging any ball freely
            for (Ball& ball : balls) {
                float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                    isDraggingCueBall = true;
                    draggingBallId = ball.id;
                    if (ball.id == 0) {
                        // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                        if (currentPlayer == 1)
                            currentGameState = BALL_IN_HAND_P1;
                        else if (currentPlayer == 2 && !isPlayer2AI)
                            currentGameState = BALL_IN_HAND_P2;
                    }
                    return 0;
                }
            }
        }

        Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

        // Check which player is allowed to interact via mouse click
        bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
        // Define states where interaction is generally allowed
        bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == AIMING || currentGameState == BREAKING ||
            currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
            currentGameState == PRE_BREAK_PLACEMENT);

        // Check Spin Indicator first (Allow if player's turn/aim phase)
        if (canPlayerClickInteract && canInteractState) {
            float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
            if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                isSettingEnglish = true;
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
                isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                return 0;
            }
        }

        if (!cueBall) return 0;

        // Check Ball-in-Hand placement/drag
        bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
        bool isPlayerAllowedToPlace = (isPlacingBall &&
            ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

        if (isPlayerAllowedToPlace) {
            float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                isDraggingCueBall = true;
                isAiming = false; isDraggingStick = false;
            }
            else {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                    cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                    cueBall->vx = 0; cueBall->vy = 0;
                    isDraggingCueBall = false;
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
            }
            return 0;
        }

        // Check for starting Aim (Cue Ball OR Stick)
        bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
            (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

        if (canAim) {
            const float stickDrawLength = 150.0f * 1.4f;
            float currentStickAngle = cueAngle + PI;
            D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
            D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
            float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
            float stickClickThresholdSq = 36.0f;
            float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
            float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

            bool clickedStick = (distToStickSq < stickClickThresholdSq);
            bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

            if (clickedStick || clickedCueArea) {
                isDraggingStick = clickedStick && !clickedCueArea;
                isAiming = clickedCueArea;
                aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                shotPower = 0;
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                if (currentGameState != BREAKING) currentGameState = AIMING;
            }
        }
        return 0;
    } // End WM_LBUTTONDOWN


    case WM_LBUTTONUP: {
        if (cheatModeEnabled && isDraggingCueBall) {
            isDraggingCueBall = false;
            if (draggingBallId == 0) {
                // After dropping CueBall, stay Ball-In-Hand mode if needed
                if (currentPlayer == 1)
                    currentGameState = BALL_IN_HAND_P1;
                else if (currentPlayer == 2 && !isPlayer2AI)
                    currentGameState = BALL_IN_HAND_P2;
            }
            draggingBallId = -1;
            return 0;
        }

        ptMouse.x = LOWORD(lParam);
        ptMouse.y = HIWORD(lParam);

        Ball* cueBall = GetCueBall(); // Get cueBall pointer

        // Check for releasing aim drag (Stick OR Cue Ball)
        if ((isAiming || isDraggingStick) &&
            ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
        {
            bool wasAiming = isAiming;
            bool wasDraggingStick = isDraggingStick;
            isAiming = false; isDraggingStick = false;

            if (shotPower > 0.15f) { // Check power threshold
                if (currentGameState != AI_THINKING) {
                    firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false; pocketedThisTurn.clear();
                }
            }
            else if (currentGameState != AI_THINKING) { // Revert state if power too low
                if (currentGameState == BREAKING) { /* Still breaking */ }
                else {
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                }
            }
            shotPower = 0; // Reset power indicator regardless
        }

        // Handle releasing cue ball drag (placement)
        if (isDraggingCueBall) {
            isDraggingCueBall = false;
            // Check player allowed to place
            bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowed = (isPlacingState &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT)));

            if (isPlayerAllowed && cueBall) {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                    // Finalize position already set by mouse move
                    // Transition state
                    if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                    else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                    else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                    cueAngle = 0.0f;
                }
                else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
            }
        }

        // Handle releasing english setting
        if (isSettingEnglish) {
            isSettingEnglish = false;
        }
        return 0;
    } // End WM_LBUTTONUP

    case WM_DESTROY:
        isMusicPlaying = false;
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
            SaveSettings(); // Save settings on exit
        }
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// --- Direct2D Resource Management ---

HRESULT CreateDeviceResources() {
    HRESULT hr = S_OK;

    // Create Direct2D Factory
    if (!pFactory) {
        hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr)) return hr;
    }

    // Create DirectWrite Factory
    if (!pDWriteFactory) {
        hr = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (FAILED(hr)) return hr;
    }

    // Create Text Formats
    if (!pTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            16.0f, L""en-us"", &pTextFormat
        );
        if (FAILED(hr)) return hr;
        // Center align text
        pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }
    if (!pLargeTextFormat && pDWriteFactory) {
        hr = pDWriteFactory->CreateTextFormat(
            L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
            48.0f, L""en-us"", &pLargeTextFormat
        );
        if (FAILED(hr)) return hr;
        pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
        pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
    }


    // Create Render Target (needs valid hwnd)
    if (!pRenderTarget && hwndMain) {
        RECT rc;
        GetClientRect(hwndMain, &rc);
        D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

        hr = pFactory->CreateHwndRenderTarget(
            D2D1::RenderTargetProperties(),
            D2D1::HwndRenderTargetProperties(hwndMain, size),
            &pRenderTarget
        );
        if (FAILED(hr)) {
            // If failed, release factories if they were created in this call
            SafeRelease(&pTextFormat);
            SafeRelease(&pLargeTextFormat);
            SafeRelease(&pDWriteFactory);
            SafeRelease(&pFactory);
            pRenderTarget = nullptr; // Ensure it's null on failure
            return hr;
        }
    }

    return hr;
}

void DiscardDeviceResources() {
    SafeRelease(&pRenderTarget);
    SafeRelease(&pTextFormat);
    SafeRelease(&pLargeTextFormat);
    SafeRelease(&pDWriteFactory);
    // Keep pFactory until application exit? Or release here too? Let's release.
    SafeRelease(&pFactory);
}

void OnResize(UINT width, UINT height) {
    if (pRenderTarget) {
        D2D1_SIZE_U size = D2D1::SizeU(width, height);
        pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
    }
}

// --- Game Initialization ---
void InitGame() {
    srand((unsigned int)time(NULL)); // Seed random number generator
    isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
    aiPlannedShotDetails.isValid = false; // Reset AI planned shot
    aiIsDisplayingAim = false;
    aiAimDisplayFramesLeft = 0;
    // ... (rest of InitGame())

    // --- Ensure pocketed list is clear from the absolute start ---
    pocketedThisTurn.clear();

    balls.clear(); // Clear existing balls

    // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
    player1Info.assignedType = BallType::NONE;
    player1Info.ballsPocketedCount = 0;
    // Player 1 Name usually remains ""Player 1""
    player2Info.assignedType = BallType::NONE;
    player2Info.ballsPocketedCount = 0;
    // Player 2 Name is set based on gameMode in ShowNewGameDialog

    // Create Cue Ball (ID 0)
    // Initial position will be set during PRE_BREAK_PLACEMENT state
    balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

    // --- Create Object Balls (Temporary List) ---
    std::vector<Ball> objectBalls;
    // Solids (1-7, Yellow)
    for (int i = 1; i <= 7; ++i) {
        objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
    }
    // Stripes (9-15, Red)
    for (int i = 9; i <= 15; ++i) {
        objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
    }
    // 8-Ball (ID 8) - Add it to the list to be placed
    objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });


    // --- Racking Logic (Improved) ---
    float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
    float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

    // Define rack positions (0-14 indices corresponding to triangle spots)
    D2D1_POINT_2F rackPositions[15];
    int rackIndex = 0;
    for (int row = 0; row < 5; ++row) {
        for (int col = 0; col <= row; ++col) {
            if (rackIndex >= 15) break;
            float x = RACK_POS_X + row * spacingX;
            float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
            rackPositions[rackIndex++] = D2D1::Point2F(x, y);
        }
    }

    // Separate 8-ball
    Ball eightBall;
    std::vector<Ball> otherBalls; // Solids and Stripes
    bool eightBallFound = false;
    for (const auto& ball : objectBalls) {
        if (ball.id == 8) {
            eightBall = ball;
            eightBallFound = true;
        }
        else {
            otherBalls.push_back(ball);
        }
    }
    // Ensure 8 ball was actually created (should always be true)
    if (!eightBallFound) {
        // Handle error - perhaps recreate it? For now, proceed.
        eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
    }


    // Shuffle the other 14 balls
    // Use std::shuffle if available (C++11 and later) for better randomness
    // std::random_device rd;
    // std::mt19937 g(rd());
    // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
    std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

    // --- Place balls into the main 'balls' vector in rack order ---
    // Important: Add the cue ball (already created) first.
    // (Cue ball added at the start of the function now)

    // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
    int eightBallRackIndex = 4;
    eightBall.x = rackPositions[eightBallRackIndex].x;
    eightBall.y = rackPositions[eightBallRackIndex].y;
    eightBall.vx = 0;
    eightBall.vy = 0;
    eightBall.isPocketed = false;
    balls.push_back(eightBall); // Add 8 ball to the main vector

    // 2. Place the shuffled Solids and Stripes in the remaining spots
    size_t otherBallIdx = 0;
    //int otherBallIdx = 0;
    for (int i = 0; i < 15; ++i) {
        if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

        if (otherBallIdx < otherBalls.size()) {
            Ball& ballToPlace = otherBalls[otherBallIdx++];
            ballToPlace.x = rackPositions[i].x;
            ballToPlace.y = rackPositions[i].y;
            ballToPlace.vx = 0;
            ballToPlace.vy = 0;
            ballToPlace.isPocketed = false;
            balls.push_back(ballToPlace); // Add to the main game vector
        }
    }
    // --- End Racking Logic ---


    // --- Determine Who Breaks and Initial State ---
    if (isPlayer2AI) {
        /*// AI Mode: Randomly decide who breaks
        if ((rand() % 2) == 0) {
            // AI (Player 2) breaks
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
            aiTurnPending = true; // Trigger AI logic
        }
        else {
            // Player 1 (Human) breaks
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
            aiTurnPending = false;*/
        switch (openingBreakMode) {
        case CPU_BREAK:
            currentPlayer = 2; // AI breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        case P1_BREAK:
            currentPlayer = 1; // Player 1 breaks
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false;
            break;
        case FLIP_COIN_BREAK:
            if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
            }
            else {
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
            }
            break;
        default: // Fallback to CPU break
            currentPlayer = 2;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = true;
            break;
        }
    }
    else {
        // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
        currentPlayer = 1;
        currentGameState = PRE_BREAK_PLACEMENT;
        aiTurnPending = false; // No AI involved
    }

    // Reset other relevant game state variables
    foulCommitted = false;
    gameOverMessage = L"""";
    firstBallPocketedAfterBreak = false;
    // pocketedThisTurn cleared at start
    // Reset shot parameters and input flags
    shotPower = 0.0f;
    cueSpinX = 0.0f;
    cueSpinY = 0.0f;
    isAiming = false;
    isDraggingCueBall = false;
    isSettingEnglish = false;
    cueAngle = 0.0f; // Reset aim angle
}


// --- Game Loop ---
void GameUpdate() {
    if (currentGameState == SHOT_IN_PROGRESS) {
        UpdatePhysics();
        CheckCollisions();

        if (AreBallsMoving()) {
            // When all balls stop, clear aiming flags
            isAiming = false;
            aiIsDisplayingAim = false;
            //ProcessShotResults();
        }

        bool pocketed = CheckPockets(); // Store if any ball was pocketed

        // --- Update pocket flash animation timer ---
        if (pocketFlashTimer > 0.0f) {
            pocketFlashTimer -= 0.02f;
            if (pocketFlashTimer < 0.0f) pocketFlashTimer = 0.0f;
        }

        if (!AreBallsMoving()) {
            ProcessShotResults(); // Determine next state based on what happened
        }
    }

    // --- Check if AI needs to act ---
    else if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
        if (aiIsDisplayingAim) { // AI has decided a shot and is displaying aim
            aiAimDisplayFramesLeft--;
            if (aiAimDisplayFramesLeft <= 0) {
                aiIsDisplayingAim = false; // Done displaying
                if (aiPlannedShotDetails.isValid) {
                    // Execute the planned shot
                    firstHitBallIdThisShot = -1;
                    cueHitObjectBallThisShot = false;
                    railHitAfterContact = false;
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                    ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
                    aiPlannedShotDetails.isValid = false; // Clear the planned shot
                }
                currentGameState = SHOT_IN_PROGRESS;
                foulCommitted = false;
                pocketedThisTurn.clear();
            }
            // Else, continue displaying aim
        }
        else if (aiTurnPending) { // AI needs to start its decision process
            // Valid states for AI to start thinking
            /*/if (currentGameState == PRE_BREAK_PLACEMENT && isOpeningBreakShot) {*/
            //newcode 1 commented out
            /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
                // Handle the break shot
                AIBreakShot();
            }*/ //new code 1 end  
            /*else if (currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING ||
                currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2) {*/

                // aiTurnPending might be consumed by AIBreakShot or remain for next cycle if needed
        /* } //new code 2 commented out
        else if (currentGameState == BALL_IN_HAND_P2 && currentPlayer == 2 && isPlayer2AI) {
            AIPlaceCueBall(); // AI places the ball first
            // After placement, AI needs to decide its shot.
            // Transition to a state where AIMakeDecision will be called for shot selection.
            currentGameState = PLAYER2_TURN; // Or a specific AI_AIMING_AFTER_PLACEMENT state
                                             // aiTurnPending remains true to trigger AIMakeDecision next.
        }
        else if (currentGameState == PLAYER2_TURN && currentPlayer == 2 && isPlayer2AI) {
            // This is for a normal turn (not break, not immediately after ball-in-hand placement)

                currentGameState = AI_THINKING; // Set state to indicate AI is processing
                aiTurnPending = false;         // Consume the pending turn flag
                AIMakeDecision();              // For normal shots (non-break)
            }
            else {
                // Not a state where AI should act
                aiTurnPending = false;
            }*/
            // 2b) AI is ready to think (pending flag)
            // **1) Ball-in-Hand** let AI place the cue ball first
            if (currentGameState == BALL_IN_HAND_P2) {
                // Step 1: AI places the cue ball.
                AIPlaceCueBall();
                // Step 2: Transition to thinking state for shot decision.
                currentGameState = AI_THINKING; //newcode5
                // Step 3: Consume the pending flag for the placement phase.
                //         AIMakeDecision will handle shot planning now.
                aiTurnPending = false; //newcode5
                // Step 4: AI immediately decides the shot from the new position.
                AIMakeDecision(); //newcode5
            }
            // **2) Opening break** special break shot logic
            else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                AIBreakShot();
            }
            else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) { //newcode5
                // General turn for AI to think (not ball-in-hand, not initial break placement)
                currentGameState = AI_THINKING; //newcode5
                aiTurnPending = false; // Consume the flag //newcode5
                AIMakeDecision(); //newcode5
            }
            // **3) Otherwise** normal shot planning
            /*else { //orig uncommented oldcode5
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
            }*/
        }

        //} //bracefix
        // If current state is AI_THINKING but not displaying aim, then AI decision has already been made
    }
}

// --- Physics and Collision ---
void UpdatePhysics() {
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) {
            b.x += b.vx;
            b.y += b.vy;

            // Apply friction
            b.vx *= FRICTION;
            b.vy *= FRICTION;

            // Stop balls if velocity is very low
            if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                b.vx = 0;
                b.vy = 0;
            }
        }
    }
}

void CheckCollisions() {
    float left = TABLE_LEFT;
    float right = TABLE_RIGHT;
    float top = TABLE_TOP;
    float bottom = TABLE_BOTTOM;
    const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

    // --- Reset Per-Frame Sound Flags ---
    bool playedWallSoundThisFrame = false;
    bool playedCollideSoundThisFrame = false;
    // ---

    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b1 = balls[i];
        if (b1.isPocketed) continue;

        bool nearPocket[6];
        for (int p = 0; p < 6; ++p) {
            nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
        }
        bool nearTopLeftPocket = nearPocket[0];
        bool nearTopMidPocket = nearPocket[1];
        bool nearTopRightPocket = nearPocket[2];
        bool nearBottomLeftPocket = nearPocket[3];
        bool nearBottomMidPocket = nearPocket[4];
        bool nearBottomRightPocket = nearPocket[5];

        bool collidedWallThisBall = false;

        // --- Ball-Wall Collisions ---
        // (Check logic unchanged, added sound calls and railHitAfterContact update)
        // Left Wall
        if (b1.x - BALL_RADIUS < left) {
            if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Right Wall
        if (b1.x + BALL_RADIUS > right) {
            if (!nearTopRightPocket && !nearBottomRightPocket) {
                b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Top Wall
        if (b1.y - BALL_RADIUS < top) {
            if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }
        // Bottom Wall
        if (b1.y + BALL_RADIUS > bottom) {
            if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                if (!playedWallSoundThisFrame) {
                    std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                    playedWallSoundThisFrame = true;
                }
                if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
            }
        }

        // Spin effect (Unchanged)
        if (collidedWallThisBall) {
            if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
            if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
            cueSpinX *= 0.7f; cueSpinY *= 0.7f;
        }


        // --- Ball-Ball Collisions ---
        for (size_t j = i + 1; j < balls.size(); ++j) {
            Ball& b2 = balls[j];
            if (b2.isPocketed) continue;

            float dx = b2.x - b1.x; float dy = b2.y - b1.y;
            float distSq = dx * dx + dy * dy;
            float minDist = BALL_RADIUS * 2.0f;

            if (distSq > 1e-6 && distSq < minDist * minDist) {
                float dist = sqrtf(distSq);
                float overlap = minDist - dist;
                float nx = dx / dist; float ny = dy / dist;

                // Separation (Unchanged)
                b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                float velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) { // Colliding
                    // --- Play Ball Collision Sound ---
                    if (!playedCollideSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                        playedCollideSoundThisFrame = true; // Set flag
                    }
                    // --- End Sound ---

                    // --- NEW: Track First Hit and Cue/Object Collision ---
                    if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                        if (b1.id == 0) { // Cue ball hit b2 first
                            firstHitBallIdThisShot = b2.id;
                            cueHitObjectBallThisShot = true;
                        }
                        else if (b2.id == 0) { // Cue ball hit b1 first
                            firstHitBallIdThisShot = b1.id;
                            cueHitObjectBallThisShot = true;
                        }
                        // If neither is cue ball, doesn't count as first hit for foul purposes
                    }
                    else if (b1.id == 0 || b2.id == 0) {
                        // Track subsequent cue ball collisions with object balls
                        cueHitObjectBallThisShot = true;
                    }
                    // --- End First Hit Tracking ---


                    // Impulse (Unchanged)
                    float impulse = velAlongNormal;
                    b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                    b2.vx += impulse * nx; b2.vy += impulse * ny;

                    // Spin Transfer (Unchanged)
                    if (b1.id == 0 || b2.id == 0) {
                        float spinEffectFactor = 0.08f;
                        b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                        b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                        cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                    }
                }
            }
        } // End ball-ball loop
    } // End ball loop
} // End CheckCollisions


bool CheckPockets() {
    bool ballPocketedThisCheck = false; // Local flag for this specific check run
    for (size_t i = 0; i < balls.size(); ++i) {
        Ball& b = balls[i];
        if (!b.isPocketed) { // Only check balls that aren't already flagged as pocketed
            for (int p = 0; p < 6; ++p) {
                float distSq = GetDistanceSq(b.x, b.y, pocketPositions[p].x, pocketPositions[p].y);
                // --- Use updated POCKET_RADIUS ---
                if (distSq < POCKET_RADIUS * POCKET_RADIUS) {
                    b.isPocketed = true;
                    b.vx = b.vy = 0;
                    pocketedThisTurn.push_back(b.id);

                    // --- Play Pocket Sound (Threaded) ---
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound ---

                    break; // Ball is pocketed
                }
            }
        }
    }
    return ballPocketedThisCheck;
}

bool AreBallsMoving() {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
            return true;
        }
    }
    return false;
}

void RespawnCueBall(bool behindHeadstring) { // 'behindHeadstring' only relevant for initial break placement
    Ball* cueBall = GetCueBall();
    if (cueBall) {
        // Reset position to a default
        //disabled for behind headstring (now move anywhere)
        /*cueBall->x = HEADSTRING_X * 0.5f;
        cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;*/
        // Reset position to a default:
        if (behindHeadstring) {
            // Opening break: kitchen center
            cueBall->x = HEADSTRING_X * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        else {
            // Ball-in-hand (foul): center of full table
            cueBall->x = TABLE_LEFT + TABLE_WIDTH / 2.0f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
        }
        cueBall->vx = 0;
        cueBall->vy = 0;
        cueBall->isPocketed = false;

        // Set state based on who gets ball-in-hand
        /*// 'currentPlayer' already reflects who's turn it is NOW (switched before calling this)*/
        // 'currentPlayer' has already been switched to the player whose turn it will be.
        // The 'behindHeadstring' parameter to RespawnCueBall is mostly for historical reasons / initial setup.
        if (currentPlayer == 1) { // Player 2 (AI/Human) fouled, Player 1 (Human) gets ball-in-hand
            currentGameState = BALL_IN_HAND_P1;
            aiTurnPending = false; // Ensure AI flag off
        }
        else { // Player 1 (Human) fouled, Player 2 gets ball-in-hand
            if (isPlayer2AI) {
                // --- CONFIRMED FIX: Set correct state for AI Ball-in-Hand ---
                currentGameState = BALL_IN_HAND_P2; // AI now needs to place the ball
                aiTurnPending = true; // Trigger AI logic (will call AIPlaceCueBall first)
            }
            else { // Human Player 2
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = false; // Ensure AI flag off
            }
        }
        // Handle initial placement state correctly if called from InitGame
        /*if (behindHeadstring && currentGameState != PRE_BREAK_PLACEMENT) {
            // This case might need review depending on exact initial setup flow,
            // but the foul logic above should now be correct.
            // Let's ensure initial state is PRE_BREAK_PLACEMENT if behindHeadstring is true.*/
            //currentGameState = PRE_BREAK_PLACEMENT;
    }
}
//}


// --- Game Logic ---

void ApplyShot(float power, float angle, float spinX, float spinY) {
    Ball* cueBall = GetCueBall();
    if (cueBall) {

        // --- Play Cue Strike Sound (Threaded) ---
        if (power > 0.1f) { // Only play if it's an audible shot
            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
        }
        // --- End Sound ---

        cueBall->vx = cosf(angle) * power;
        cueBall->vy = sinf(angle) * power;

        // Apply English (Spin) - Simplified effect (Unchanged)
        cueBall->vx += sinf(angle) * spinY * 0.5f;
        cueBall->vy -= cosf(angle) * spinY * 0.5f;
        cueBall->vx -= cosf(angle) * spinX * 0.5f;
        cueBall->vy -= sinf(angle) * spinX * 0.5f;

        // Store spin (Unchanged)
        cueSpinX = spinX;
        cueSpinY = spinY;

        // --- Reset Foul Tracking flags for the new shot ---
        // (Also reset in LBUTTONUP, but good to ensure here too)
        firstHitBallIdThisShot = -1;      // No ball hit yet
        cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
        railHitAfterContact = false;     // No rail hit after contact yet
        // --- End Reset ---

                // If this was the opening break shot, clear the flag
        if (isOpeningBreakShot) {
            isOpeningBreakShot = false; // Mark opening break as taken
        }
    }
}


void ProcessShotResults() {
    bool cueBallPocketed = false;
    bool eightBallPocketed = false;
    bool legalBallPocketed = false;
    bool opponentBallPocketed = false;
    bool anyNonCueBallPocketed = false; // Includes opponent balls
    BallType firstPocketedType = BallType::NONE;
    int firstPocketedId = -1;

    PlayerInfo& currentPlayerInfo = (currentPlayer == 1) ? player1Info : player2Info;
    PlayerInfo& opponentPlayerInfo = (currentPlayer == 1) ? player2Info : player1Info;

    // Analyze pocketed balls (Unchanged logic)
    for (int pocketedId : pocketedThisTurn) {
        Ball* b = GetBallById(pocketedId);
        if (!b) continue;
        if (!pocketedThisTurn.empty()) {
            pocketFlashTimer = 1.0f; // Flash boost when any ball is pocketed
        }
        if (b->id == 0) { cueBallPocketed = true; }
        else if (b->id == 8) { eightBallPocketed = true; }
        else {
            anyNonCueBallPocketed = true;
            if (firstPocketedId == -1) { firstPocketedId = b->id; firstPocketedType = b->type; }
            if (currentPlayerInfo.assignedType != BallType::NONE) {
                if (b->type == currentPlayerInfo.assignedType) legalBallPocketed = true;
                else if (b->type == opponentPlayerInfo.assignedType) opponentBallPocketed = true;
            }
        }
    }

    // --- Game Over Checks --- (Unchanged logic)
    if (eightBallPocketed) {
        CheckGameOverConditions(eightBallPocketed, cueBallPocketed);
        if (currentGameState == GAME_OVER) return;
    }

    // --- MODIFIED: Enhanced Foul Checks ---
    bool turnFoul = false;

    // Foul 1: Scratch (Cue ball pocketed)
    if (cueBallPocketed) {
        foulCommitted = true; turnFoul = true;
    }

    // Foul 2: Hit Nothing (Only if not already a scratch)
    // Condition: Cue ball didn't hit *any* object ball during the shot.
    if (!turnFoul && !cueHitObjectBallThisShot) {
        // Check if the cue ball actually moved significantly to constitute a shot attempt
        Ball* cue = GetCueBall();
        // Use a small threshold to avoid foul on accidental tiny nudge if needed
        // For now, any shot attempt that doesn't hit an object ball is a foul.
        // (Could add velocity check from ApplyShot if needed)
        if (cue) { // Ensure cue ball exists
            foulCommitted = true; turnFoul = true;
        }
    }

    // Foul 3: Wrong Ball First (Check only if not already foul and *something* was hit)
    if (!turnFoul && firstHitBallIdThisShot != -1) {
        Ball* firstHitBall = GetBallById(firstHitBallIdThisShot);
        if (firstHitBall) {
            bool isBreakShot = (player1Info.assignedType == BallType::NONE && player2Info.assignedType == BallType::NONE);
            bool mustTarget8Ball = (!isBreakShot && currentPlayerInfo.assignedType != BallType::NONE && currentPlayerInfo.ballsPocketedCount >= 7);

            if (!isBreakShot) { // Standard play rules
                if (mustTarget8Ball) {
                    if (firstHitBall->id != 8) { foulCommitted = true; turnFoul = true; }
                }
                else if (currentPlayerInfo.assignedType != BallType::NONE) { // Colors assigned
                  // Illegal to hit opponent ball OR 8-ball first
                    if (firstHitBall->type == opponentPlayerInfo.assignedType || firstHitBall->id == 8) {
                        foulCommitted = true; turnFoul = true;
                    }
                }
                // If colors NOT assigned yet (e.g. shot immediately after break), hitting any ball is legal first.
            }
            // No specific first-hit foul rules applied for the break itself here.
        }
    }

    // Foul 4: No Rail After Contact (Check only if not already foul)
    // Condition: Cue hit an object ball, BUT after that first contact,
    //            NO ball hit a rail AND NO object ball was pocketed (excluding cue/8-ball).
    if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && !anyNonCueBallPocketed) {
        foulCommitted = true;
        turnFoul = true;
    }

    // Foul 5: Pocketing Opponent's Ball (Optional stricter rule - can uncomment if desired)
    // if (!turnFoul && opponentBallPocketed) {
    //     foulCommitted = true; turnFoul = true;
    // }
    // --- End Enhanced Foul Checks ---


    // --- State Transitions ---
    if (turnFoul) {
        SwitchTurns();
        RespawnCueBall(false); // Ball in hand for opponent (state set in Respawn)
    }
    // --- Assign Ball Types only AFTER checking for fouls on the break/first shot ---
    else if (player1Info.assignedType == BallType::NONE && anyNonCueBallPocketed) {
        // (Assign types logic - unchanged)
        bool firstTypeVerified = false;
        for (int id : pocketedThisTurn) { if (id == firstPocketedId) { firstTypeVerified = true; break; } }

        if (firstTypeVerified && (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE)) {
            AssignPlayerBallTypes(firstPocketedType);
            legalBallPocketed = true;
        }
        // After assignment (or if types already assigned), check if turn continues
        if (legalBallPocketed) { // Player legally pocketed their assigned type (newly or existing)
            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = true;
        }
        else { // Pocketed wrong ball, or only opponent ball, or missed (but no foul committed)
            SwitchTurns();
        }
    }
    // --- Normal Play Results (Types Assigned) ---
    else if (player1Info.assignedType != BallType::NONE) { // Ensure types assigned before this block
        if (legalBallPocketed) { // Legally pocketed own ball
            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = true; // AI continues turn
        }
        else { // No legal ball pocketed (or no ball pocketed at all) and no foul
            SwitchTurns();
        }
    }
    // --- Handle case where shot occurred but no balls pocketed and no foul ---
    else if (!anyNonCueBallPocketed && !turnFoul) {
        SwitchTurns();
    }


    // Update pocketed counts AFTER handling turns/fouls/assignment
    int p1NewlyPocketed = 0;
    int p2NewlyPocketed = 0;
    for (int id : pocketedThisTurn) {
        if (id == 0 || id == 8) continue; // Skip cue ball and 8-ball
        Ball* b = GetBallById(id);
        if (!b) continue; // extra safety
        if (b->type == player1Info.assignedType) p1NewlyPocketed++;
        else if (b->type == player2Info.assignedType) p2NewlyPocketed++;
    }
    if (currentGameState != GAME_OVER) {
        player1Info.ballsPocketedCount += p1NewlyPocketed;
        player2Info.ballsPocketedCount += p2NewlyPocketed;
    }


    // --- Cleanup for next actual shot attempt ---
    pocketedThisTurn.clear();
    // Reset foul tracking flags (done before next shot applied)
    // firstHitBallIdThisShot = -1; // Reset these before next shot call
    // cueHitObjectBallThisShot = false;
    // railHitAfterContact = false;
}

void AssignPlayerBallTypes(BallType firstPocketedType) {
    if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
        if (currentPlayer == 1) {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
        else {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
        }
    }
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.
}

void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
    if (!eightBallPocketed) return; // Only proceed if 8-ball was pocketed

    PlayerInfo& currentPlayerInfo = (currentPlayer == 1) ? player1Info : player2Info;
    bool playerClearedBalls = (currentPlayerInfo.assignedType != BallType::NONE && currentPlayerInfo.ballsPocketedCount >= 7);

    // Loss Conditions:
    // 1. Pocket 8-ball AND scratch (pocket cue ball)
    // 2. Pocket 8-ball before clearing own color group
    if (cueBallPocketed || (!playerClearedBalls && currentPlayerInfo.assignedType != BallType::NONE)) {
        gameOverMessage = (currentPlayer == 1) ? L""Player 2 Wins! (Player 1 fouled on 8-ball)"" : L""Player 1 Wins! (Player 2 fouled on 8-ball)"";
        currentGameState = GAME_OVER;
    }
    // Win Condition:
    // 1. Pocket 8-ball legally after clearing own color group
    else if (playerClearedBalls) {
        gameOverMessage = (currentPlayer == 1) ? L""Player 1 Wins!"" : L""Player 2 Wins!"";
        currentGameState = GAME_OVER;
    }
    // Special case: 8 ball pocketed on break. Usually re-spot or re-rack.
    // Simple: If it happens during assignment phase, treat as foul, respawn 8ball.
    else if (player1Info.assignedType == BallType::NONE) {
        Ball* eightBall = GetBallById(8);
        if (eightBall) {
            eightBall->isPocketed = false;
            // Place 8-ball on foot spot (approx RACK_POS_X) or center if occupied
            eightBall->x = RACK_POS_X;
            eightBall->y = RACK_POS_Y;
            eightBall->vx = eightBall->vy = 0;
            // Check overlap and nudge if necessary (simplified)
        }
        // Apply foul rules if cue ball was also pocketed
        if (cueBallPocketed) {
            foulCommitted = true;
            // Don't switch turns on break scratch + 8ball pocket? Rules vary.
            // Let's make it a foul, switch turns, ball in hand.
            SwitchTurns();
            RespawnCueBall(false); // Ball in hand for opponent
        }
        else {
            // Just respawned 8ball, continue turn or switch based on other balls pocketed.
            // Let ProcessShotResults handle turn logic based on other pocketed balls.
        }
        // Prevent immediate game over message by returning here
        return;
    }


}


void SwitchTurns() {
    currentPlayer = (currentPlayer == 1) ? 2 : 1;
    // Reset aiming state for the new player
    isAiming = false;
    shotPower = 0;
    // Reset foul flag before new turn *really* starts (AI might take over)
    // Foul flag is mainly for display, gets cleared before human/AI shot
    // foulCommitted = false; // Probably better to clear before ApplyShot

    // Set the correct state based on who's turn it is
    if (currentPlayer == 1) {
        currentGameState = PLAYER1_TURN;
        aiTurnPending = false; // Ensure AI flag is off for P1
    }
    else { // Player 2's turn
        if (isPlayer2AI) {
            currentGameState = PLAYER2_TURN; // State indicates it's P2's turn
            aiTurnPending = true;           // Set flag for GameUpdate to trigger AI
            // AI will handle Ball-in-Hand logic if necessary within its decision making
        }
        else {
            currentGameState = PLAYER2_TURN; // Human P2
            aiTurnPending = false;
        }
    }
}

void AIBreakShot() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
    // AI will place the cue ball and then plan the shot.
    if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
        // Place cue ball in the kitchen randomly
        /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
        float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

        // --- AI Places Cue Ball for Break ---
// Decide if placing center or side. For simplicity, let's try placing slightly off-center
// towards one side for a more angled break, or center for direct apex hit.
// A common strategy is to hit the second ball of the rack.

        float placementY = RACK_POS_Y; // Align vertically with the rack center
        float placementX;

        // Randomly choose a side or center-ish placement for variation.
        int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

        if (placementChoice == 0) { // Left-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
        }
        else if (placementChoice == 2) { // Right-ish
            placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
        }
        else { // Center-ish
            placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
        }
        placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

        bool validPos = false;
        int attempts = 0;
        while (!validPos && attempts < 100) {
            /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
            cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                validPos = true; // [cite: 1591]*/
                // Try the chosen X, but vary Y slightly to find a clear spot
            cueBall->x = placementX;
            cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
            cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                validPos = true;
            }
            attempts++; // [cite: 1592]
        }
        if (!validPos) {
            // Fallback position
            /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
            cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
            }
        }
        cueBall->vx = 0; // [cite: 1595]
        cueBall->vy = 0; // [cite: 1596]

        // Plan a break shot: aim at the center of the rack (apex ball)
        float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
        float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

        float dx = targetX - cueBall->x; // [cite: 1599]
        float dy = targetY - cueBall->y; // [cite: 1600]
        float shotAngle = atan2f(dy, dx); // [cite: 1600]
        float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
            cueBall->y = RACK_POS_Y;
        }
        cueBall->vx = 0; cueBall->vy = 0;

        // --- AI Plans the Break Shot ---
        float targetX, targetY;
        // If cue ball is near center of kitchen width, aim for apex.
        // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
        float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
        if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
            // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
            targetX = RACK_POS_X; // Apex ball X
            targetY = RACK_POS_Y; // Apex ball Y
        }
        else {
            // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
            // This is a simplification. A more robust way is to find the actual second ball.
            // For now, aim slightly off the apex towards the side the cue ball is on.
            targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
            targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
        }

        float dx = targetX - cueBall->x;
        float dy = targetY - cueBall->y;
        float shotAngle = atan2f(dy, dx);
        float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

        // Store planned shot details for the AI
        /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
        aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
        aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
        aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
        aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

        aiPlannedShotDetails.angle = shotAngle;
        aiPlannedShotDetails.power = shotPowerValue;
        aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
        /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
        ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
        ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
        ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

        ::cueAngle = aiPlannedShotDetails.angle;
        ::shotPower = aiPlannedShotDetails.power;
        ::cueSpinX = aiPlannedShotDetails.spinX;
        ::cueSpinY = aiPlannedShotDetails.spinY;

        // Set up for AI display via GameUpdate
        /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

        currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                        // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                        // and then execute the shot using aiPlannedShotDetails.
                                        // isOpeningBreakShot will be set to false within ApplyShot.

        // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display

        return; // The break shot is now planned and will be executed by GameUpdate
    }

    // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
    //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
    //    This part can be extended if AIBreakShot needs to handle other scenarios.
    //    For now, the primary logic is above.
}

// --- Helper Functions ---

Ball* GetBallById(int id) {
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id == id) {
            return &balls[i];
        }
    }
    return nullptr;
}

Ball* GetCueBall() {
    return GetBallById(0);
}

float GetDistance(float x1, float y1, float x2, float y2) {
    return sqrtf(GetDistanceSq(x1, y1, x2, y2));
}

float GetDistanceSq(float x1, float y1, float x2, float y2) {
    float dx = x2 - x1;
    float dy = y2 - y1;
    return dx * dx + dy * dy;
}

bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
    // Basic bounds check (inside cushions)
    float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
    float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
    float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
    float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

    if (x < left || x > right || y < top || y > bottom) {
        return false;
    }

    // Check headstring restriction if needed
    if (checkHeadstring && x >= HEADSTRING_X) {
        return false;
    }

    // Check overlap with other balls
    for (size_t i = 0; i < balls.size(); ++i) {
        if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
            if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                return false; // Overlapping another ball
            }
        }
    }

    return true;
}


template <typename T>
void SafeRelease(T** ppT) {
    if (*ppT) {
        (*ppT)->Release();
        *ppT = nullptr;
    }
}

// --- Helper Function for Line Segment Intersection ---
// Finds intersection point of line segment P1->P2 and line segment P3->P4
// Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
{
    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

    // Check if lines are parallel or collinear
    if (fabs(denominator) < 1e-6) {
        return false;
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    // Check if intersection point lies on both segments
    if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
        intersection.x = p1.x + ua * (p2.x - p1.x);
        intersection.y = p1.y + ua * (p2.y - p1.y);
        return true;
    }

    return false;
}

// --- INSERT NEW HELPER FUNCTION HERE ---
// Calculates the squared distance from point P to the line segment AB.
float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
    float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
    if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
    // Consider P projecting onto the line AB infinite line
    // t = [(P-A) . (B-A)] / |B-A|^2
    float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
    t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
    // Projection falls on the segment
    D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
    return GetDistanceSq(p.x, p.y, projection.x, projection.y);
}
// --- End New Helper ---

// --- NEW AI Implementation Functions ---

// Main entry point for AI turn
void AIMakeDecision() {
    //AIShotInfo bestShot = { false }; // Declare here
    // This function is called when currentGameState is AI_THINKING (for a normal shot decision)
    Ball* cueBall = GetCueBall();
    if (!cueBall || !isPlayer2AI || currentPlayer != 2) {
        aiPlannedShotDetails.isValid = false; // Ensure no shot if conditions not met
        return;
    }

    // Phase 1: Placement if needed (Ball-in-Hand or Initial Break)
    /*if ((isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) || currentGameState == BALL_IN_HAND_P2) {
        AIPlaceCueBall(); // Handles kitchen placement for break or regular ball-in-hand
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            currentGameState = BREAKING; // Now AI needs to decide the break shot parameters
        }
        // For regular BALL_IN_HAND_P2, after placement, it will proceed to find a shot.
    }*/

    aiPlannedShotDetails.isValid = false; // Default to no valid shot found yet for this decision cycle
    // Note: isOpeningBreakShot is false here because AIBreakShot handles the break.

     // Phase 2: Decide shot parameters (Break or Normal play)
    /*if (isOpeningBreakShot && currentGameState == BREAKING) {
        // Force cue ball into center of kitchen
        cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
        cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f;
        cueBall->vx = cueBall->vy = 0.0f;

        float rackCenterX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f * 2.0f;
        float rackCenterY = RACK_POS_Y;
        float dx = rackCenterX - cueBall->x;
        float dy = rackCenterY - cueBall->y;

        aiPlannedShotDetails.angle = atan2f(dy, dx);
        aiPlannedShotDetails.power = MAX_SHOT_POWER;
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;

        // Apply shot immediately
        cueAngle = aiPlannedShotDetails.angle;
        shotPower = aiPlannedShotDetails.power;
        cueSpinX = aiPlannedShotDetails.spinX;
        cueSpinY = aiPlannedShotDetails.spinY;

        firstHitBallIdThisShot = -1;
        cueHitObjectBallThisShot = false;
        railHitAfterContact = false;
        isAiming = false;
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        //bool aiIsDisplayingAim = true;

        std::thread([](const TCHAR* soundName) {
            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
            }, TEXT(""cue.wav"")).detach();

            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
            currentGameState = SHOT_IN_PROGRESS;
            isOpeningBreakShot = false;
            aiTurnPending = false;
            pocketedThisTurn.clear();
            return;
    }
    else {*/
    // --- Normal AI Shot Decision (using AIFindBestShot) ---
    AIShotInfo bestShot = AIFindBestShot(); // bugtraq
    //bestShot = AIFindBestShot(); // bugtraq
    if (bestShot.possible) {
        aiPlannedShotDetails.angle = bestShot.angle;
        aiPlannedShotDetails.power = bestShot.power;
        aiPlannedShotDetails.spinX = 0.0f; // AI doesn't use spin yet
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true;
    }
    else {
        // Safety tap if no better shot found
        // Try to hit the closest 'own' ball gently or any ball if types not assigned
        Ball* ballToNudge = nullptr;
        float minDistSq = -1.0f;
        BallType aiTargetType = player2Info.assignedType;
        bool mustHit8Ball = (aiTargetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);

        for (auto& b : balls) {
            if (b.isPocketed || b.id == 0) continue;
            bool canHitThis = false;
            if (mustHit8Ball) canHitThis = (b.id == 8);
            else if (aiTargetType != BallType::NONE) canHitThis = (b.type == aiTargetType);
            else canHitThis = (b.id != 8); // Can hit any non-8-ball if types not assigned

            if (canHitThis) {
                float dSq = GetDistanceSq(cueBall->x, cueBall->y, b.x, b.y);
                if (ballToNudge == nullptr || dSq < minDistSq) {
                    ballToNudge = &b;
                    minDistSq = dSq;
                }
            }
        }
        if (ballToNudge) { // Found a ball to nudge
            aiPlannedShotDetails.angle = atan2f(ballToNudge->y - cueBall->y, ballToNudge->x - cueBall->x);
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.15f; // Gentle tap
        }
        else { // Absolute fallback: small tap forward
            aiPlannedShotDetails.angle = cueAngle; // Keep last angle or default
            //aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.1f;
        }
        aiPlannedShotDetails.spinX = 0.0f;
        aiPlannedShotDetails.spinY = 0.0f;
        aiPlannedShotDetails.isValid = true; // Safety shot is a ""valid"" plan
    }
    //} //bracefix

    // Phase 3: Setup for Aim Display (if a valid shot was decided)
    if (aiPlannedShotDetails.isValid) {
        cueAngle = aiPlannedShotDetails.angle;   // Update global for drawing
        shotPower = aiPlannedShotDetails.power;  // Update global for drawing
        // cueSpinX and cueSpinY could also be set here if AI used them
        cueSpinX = aiPlannedShotDetails.spinX; // Also set these for drawing consistency
        cueSpinY = aiPlannedShotDetails.spinY; //

        aiIsDisplayingAim = true;
        aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
        // currentGameState remains AI_THINKING, GameUpdate will handle the display countdown and shot execution.
            // FIRE THE BREAK SHOT NOW
            // Immediately execute the break shot after setting parameters
        /*ApplyShot(aiPlannedShotDetails.power, aiPlannedShotDetails.angle, aiPlannedShotDetails.spinX, aiPlannedShotDetails.spinY);
        currentGameState = SHOT_IN_PROGRESS;
        aiTurnPending = false;
        isOpeningBreakShot = false;*/
    }
    else {
        // Should not happen if safety shot is always planned, but as a fallback:
        aiIsDisplayingAim = false;
        // If AI truly can't decide anything, maybe switch turn or log error. For now, it will do nothing this frame.
        // Or force a minimal safety tap without display.
        // To ensure game progresses, let's plan a minimal tap if nothing else.
        if (!aiPlannedShotDetails.isValid) { // Double check
            aiPlannedShotDetails.angle = 0.0f;
            aiPlannedShotDetails.power = MAX_SHOT_POWER * 0.05f; // Very small tap
            aiPlannedShotDetails.spinX = 0.0f; aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;
            //cueAngle = aiPlannedShotDetails.angle; shotPower = aiPlannedShotDetails.power;
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;
            cueSpinX = aiPlannedShotDetails.spinX;
            cueSpinY = aiPlannedShotDetails.spinY;
            aiIsDisplayingAim = true; // Allow display for this minimal tap too
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES / 2; // Shorter display for fallback
        }
    }
    // aiTurnPending was set to false by GameUpdate before calling AIMakeDecision.
    // AIMakeDecision's job is to populate aiPlannedShotDetails and trigger display.
}

// AI logic for placing cue ball during ball-in-hand
void AIPlaceCueBall() {
    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    // --- CPU AI Opening Break: Kitchen Placement ---
    /*if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT && currentPlayer == 2 && isPlayer2AI) {
        float kitchenMinX = TABLE_LEFT + BALL_RADIUS;
        float kitchenMaxX = HEADSTRING_X - BALL_RADIUS;
        float kitchenMinY = TABLE_TOP + BALL_RADIUS;
        float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS;
        bool validPositionFound = false;
        int attempts = 0;
        while (!validPositionFound && attempts < 100) {
            cueBall->x = kitchenMinX + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxX - kitchenMinX)));
            cueBall->y = kitchenMinY + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (kitchenMaxY - kitchenMinY)));
            if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                validPositionFound = true;
            }
            attempts++;
        }
        if (!validPositionFound) {
            cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
            cueBall->y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) {
                cueBall->x = HEADSTRING_X - BALL_RADIUS * 2.0f;
                cueBall->y = RACK_POS_Y;
            }
        }
        cueBall->vx = 0; cueBall->vy = 0;
        return;
    }*/
    // --- End CPU AI Opening Break Placement ---

    // This function is now SOLELY for Ball-In-Hand placement for the AI (anywhere on the table).
    // Break placement is handled by AIBreakShot().

    // Simple Strategy: Find the easiest possible shot for the AI's ball type
    // Place the cue ball directly behind that target ball, aiming straight at a pocket.
    // (More advanced: find spot offering multiple options or safety)

    AIShotInfo bestPlacementShot = { false };
    D2D1_POINT_2F bestPlacePos = D2D1::Point2F(HEADSTRING_X * 0.5f, RACK_POS_Y); // Default placement

    // A better default for ball-in-hand (anywhere) might be center table if no shot found.
    bestPlacePos = D2D1::Point2F(TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP + TABLE_HEIGHT / 2.0f);
    float bestPlacementScore = -1.0f; // Keep track of the score for the best placement found

    BallType targetType = player2Info.assignedType;
    bool canTargetAnyPlacement = false; // Local scope variable for placement logic
    if (targetType == BallType::NONE) {
        canTargetAnyPlacement = true;
    }
    bool target8Ball = (!canTargetAnyPlacement && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    if (target8Ball) targetType = BallType::EIGHT_BALL;


    for (auto& targetBall : balls) {
        if (targetBall.isPocketed || targetBall.id == 0) continue;

        // Determine if current ball is a valid target for placement consideration
        bool currentBallIsValidTarget = false;
        if (target8Ball && targetBall.id == 8) currentBallIsValidTarget = true;
        else if (canTargetAnyPlacement && targetBall.id != 8) currentBallIsValidTarget = true;
        else if (!canTargetAnyPlacement && !target8Ball && targetBall.type == targetType) currentBallIsValidTarget = true;

        if (!currentBallIsValidTarget) continue; // Skip if not a valid target

        for (int p = 0; p < 6; ++p) {
            // Calculate ideal cue ball position: straight line behind target ball aiming at pocket p
            float targetToPocketX = pocketPositions[p].x - targetBall.x;
            float targetToPocketY = pocketPositions[p].y - targetBall.y;
            float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);
            if (dist < 1.0f) continue; // Avoid division by zero

            float idealAngle = atan2f(targetToPocketY, targetToPocketX);
            // Place cue ball slightly behind target ball along this line
            float placeDist = BALL_RADIUS * 3.0f; // Place a bit behind
            D2D1_POINT_2F potentialPlacePos = D2D1::Point2F( // Use factory function
                targetBall.x - cosf(idealAngle) * placeDist,
                targetBall.y - sinf(idealAngle) * placeDist
            );

            // Check if this placement is valid (on table, behind headstring if break, not overlapping)
            /*bool behindHeadstringRule = (currentGameState == PRE_BREAK_PLACEMENT);*/
            // For ball-in-hand (NOT break), behindHeadstringRule is false.
            // The currentGameState should be BALL_IN_HAND_P2 when this is called for a foul.
            bool behindHeadstringRule = false; // Player can place anywhere after a foul
            if (IsValidCueBallPosition(potentialPlacePos.x, potentialPlacePos.y, behindHeadstringRule)) {
                // Is path from potentialPlacePos to targetBall clear?
                // Use D2D1::Point2F() factory function here
                if (IsPathClear(potentialPlacePos, D2D1::Point2F(targetBall.x, targetBall.y), 0, targetBall.id)) {
                    // Is path from targetBall to pocket clear?
                    // Use D2D1::Point2F() factory function here
                    if (IsPathClear(D2D1::Point2F(targetBall.x, targetBall.y), pocketPositions[p], targetBall.id, -1)) {
                        // This seems like a good potential placement. Score it?
                        // Easy AI: Just take the first valid one found.
                        /*bestPlacePos = potentialPlacePos;
                        goto placement_found;*/ // Use goto for simplicity in non-OOP structure
                        // This is a possible shot. Score this placement.
// A simple score: distance to target ball (shorter is better for placement).
// More advanced: consider angle to pocket, difficulty of the shot from this placement.
                        AIShotInfo tempShotInfo;
                        tempShotInfo.possible = true;
                        tempShotInfo.targetBall = &targetBall;
                        tempShotInfo.pocketIndex = p;
                        tempShotInfo.ghostBallPos = CalculateGhostBallPos(&targetBall, p); // Not strictly needed for placement score but good for consistency
                        tempShotInfo.angle = idealAngle; // The angle from the placed ball to target
                        // Use EvaluateShot's scoring mechanism if possible, or a simpler one here.
                        float currentScore = 1000.0f / (1.0f + GetDistance(potentialPlacePos.x, potentialPlacePos.y, targetBall.x, targetBall.y)); // Inverse distance

                        if (currentScore > bestPlacementScore) {
                            bestPlacementScore = currentScore;
                            bestPlacePos = potentialPlacePos;
                        }
                    }
                }
            }
        }
    }

placement_found:
    // Place the cue ball at the best found position (or default if no good spot found)
    cueBall->x = bestPlacePos.x;
    cueBall->y = bestPlacePos.y;
    cueBall->vx = 0;
    cueBall->vy = 0;
}


// AI finds the best shot available on the table
AIShotInfo AIFindBestShot() {
    AIShotInfo bestShotOverall = { false };
    Ball* cueBall = GetCueBall();
    if (!cueBall) return bestShotOverall;
    // Ensure cue ball position is up-to-date if AI just placed it
    // (AIPlaceCueBall should have already set cueBall->x, cueBall->y)

    // Determine target ball type for AI (Player 2)
    BallType targetType = player2Info.assignedType;
    bool canTargetAny = false; // Can AI hit any ball (e.g., after break, before assignment)?
    if (targetType == BallType::NONE) {
        // If colors not assigned, AI aims to pocket *something* (usually lowest numbered ball legally)
        // Or, more simply, treat any ball as a potential target to make *a* pocket
        canTargetAny = true; // Simplification: allow targeting any non-8 ball.
        // A better rule is hit lowest numbered ball first on break follow-up.
    }

    // Check if AI needs to shoot the 8-ball
    bool target8Ball = (!canTargetAny && targetType != BallType::NONE && player2Info.ballsPocketedCount >= 7);


    // Iterate through all potential target balls
    for (auto& potentialTarget : balls) {
        if (potentialTarget.isPocketed || potentialTarget.id == 0) continue; // Skip pocketed and cue ball

        // Check if this ball is a valid target
        bool isValidTarget = false;
        if (target8Ball) {
            isValidTarget = (potentialTarget.id == 8);
        }
        else if (canTargetAny) {
            isValidTarget = (potentialTarget.id != 8); // Can hit any non-8 ball
        }
        else { // Colors assigned, not yet shooting 8-ball
            isValidTarget = (potentialTarget.type == targetType);
        }

        if (!isValidTarget) continue; // Skip if not a valid target for this turn

        // Now, check all pockets for this target ball
        for (int p = 0; p < 6; ++p) {
            AIShotInfo currentShot = EvaluateShot(&potentialTarget, p);
            currentShot.involves8Ball = (potentialTarget.id == 8);

            if (currentShot.possible) {
                // Compare scores to find the best shot
                if (!bestShotOverall.possible || currentShot.score > bestShotOverall.score) {
                    bestShotOverall = currentShot;
                }
            }
        }
    } // End loop through potential target balls

    // If targeting 8-ball and no shot found, or targeting own balls and no shot found,
    // need a safety strategy. Current simple AI just takes best found or taps cue ball.

    return bestShotOverall;
}


// Evaluate a potential shot at a specific target ball towards a specific pocket
AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
    AIShotInfo shotInfo;
    shotInfo.possible = false; // Assume not possible initially
    shotInfo.targetBall = targetBall;
    shotInfo.pocketIndex = pocketIndex;

    Ball* cueBall = GetCueBall();
    if (!cueBall || !targetBall) return shotInfo;

    // --- Define local state variables needed for legality checks ---
    BallType aiAssignedType = player2Info.assignedType;
    bool canTargetAny = (aiAssignedType == BallType::NONE); // Can AI hit any ball?
    bool mustTarget8Ball = (!canTargetAny && aiAssignedType != BallType::NONE && player2Info.ballsPocketedCount >= 7);
    // ---

    // 1. Calculate Ghost Ball position
    shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

    // 2. Calculate Angle from Cue Ball to Ghost Ball
    float dx = shotInfo.ghostBallPos.x - cueBall->x;
    float dy = shotInfo.ghostBallPos.y - cueBall->y;
    if (fabs(dx) < 0.01f && fabs(dy) < 0.01f) return shotInfo; // Avoid aiming at same spot
    shotInfo.angle = atan2f(dy, dx);

    // Basic angle validity check (optional)
    if (!IsValidAIAimAngle(shotInfo.angle)) {
        // Maybe log this or handle edge cases
    }

    // 3. Check Path: Cue Ball -> Ghost Ball Position
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
        return shotInfo; // Path blocked
    }

    // 4. Check Path: Target Ball -> Pocket
    // Use D2D1::Point2F() factory function here
    if (!IsPathClear(D2D1::Point2F(targetBall->x, targetBall->y), pocketPositions[pocketIndex], targetBall->id, -1)) {
        return shotInfo; // Path blocked
    }

    // 5. Check First Ball Hit Legality
    float firstHitDistSq = -1.0f;
    // Use D2D1::Point2F() factory function here
    Ball* firstHit = FindFirstHitBall(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.angle, firstHitDistSq);

    if (!firstHit) {
        return shotInfo; // AI aims but doesn't hit anything? Impossible shot.
    }

    // Check if the first ball hit is the intended target ball
    if (firstHit->id != targetBall->id) {
        // Allow hitting slightly off target if it's very close to ghost ball pos
        float ghostDistSq = GetDistanceSq(shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y, firstHit->x, firstHit->y);
        // Allow a tolerance roughly half the ball radius squared
        if (ghostDistSq > (BALL_RADIUS * 0.7f) * (BALL_RADIUS * 0.7f)) {
            // First hit is significantly different from the target point.
            // This shot path leads to hitting the wrong ball first.
            return shotInfo; // Foul or unintended shot
        }
        // If first hit is not target, but very close, allow it for now (might still be foul based on type).
    }

    // Check legality of the *first ball actually hit* based on game rules
    if (!canTargetAny) { // Colors are assigned (or should be)
        if (mustTarget8Ball) { // Must hit 8-ball first
            if (firstHit->id != 8) {
                // return shotInfo; // FOUL - Hitting wrong ball when aiming for 8-ball
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
        }
        else { // Must hit own ball type first
            if (firstHit->type != aiAssignedType && firstHit->id != 8) { // Allow hitting 8-ball if own type blocked? No, standard rules usually require hitting own first.
                // return shotInfo; // FOUL - Hitting opponent ball or 8-ball when shouldn't
                // Keep shot possible for now, rely on AIFindBestShot to prioritize legal ones
            }
            else if (firstHit->id == 8) {
                // return shotInfo; // FOUL - Hitting 8-ball when shouldn't
                // Keep shot possible for now
            }
        }
    }
    // (If canTargetAny is true, hitting any ball except 8 first is legal - assuming not scratching)


    // 6. Calculate Score & Power (Difficulty affects this)
    shotInfo.possible = true; // If we got here, the shot is geometrically possible and likely legal enough for AI to consider

    float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
    float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);

    // Simple Score: Shorter shots are better, straighter shots are slightly better.
    float distanceScore = 1000.0f / (1.0f + cueToGhostDist + targetToPocketDist);

    // Angle Score: Calculate cut angle
    // Vector Cue -> Ghost
    float v1x = shotInfo.ghostBallPos.x - cueBall->x;
    float v1y = shotInfo.ghostBallPos.y - cueBall->y;
    // Vector Target -> Pocket
    float v2x = pocketPositions[pocketIndex].x - targetBall->x;
    float v2y = pocketPositions[pocketIndex].y - targetBall->y;
    // Normalize vectors
    float mag1 = sqrtf(v1x * v1x + v1y * v1y);
    float mag2 = sqrtf(v2x * v2x + v2y * v2y);
    float angleScoreFactor = 0.5f; // Default if vectors are zero len
    if (mag1 > 0.1f && mag2 > 0.1f) {
        v1x /= mag1; v1y /= mag1;
        v2x /= mag2; v2y /= mag2;
        // Dot product gives cosine of angle between cue ball path and target ball path
        float dotProduct = v1x * v2x + v1y * v2y;
        // Straighter shot (dot product closer to 1) gets higher score
        angleScoreFactor = (1.0f + dotProduct) / 2.0f; // Map [-1, 1] to [0, 1]
    }
    angleScoreFactor = std::max(0.1f, angleScoreFactor); // Ensure some minimum score factor

    shotInfo.score = distanceScore * angleScoreFactor;

    // Bonus for pocketing 8-ball legally
    if (mustTarget8Ball && targetBall->id == 8) {
        shotInfo.score *= 10.0; // Strongly prefer the winning shot
    }

    // Penalty for difficult cuts? Already partially handled by angleScoreFactor.

    // 7. Calculate Power
    shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

    // 8. Add Inaccuracy based on Difficulty (same as before)
    float angleError = 0.0f;
    float powerErrorFactor = 1.0f;

    switch (aiDifficulty) {
    case EASY:
        angleError = (float)(rand() % 100 - 50) / 1000.0f; // +/- ~3 deg
        powerErrorFactor = 0.8f + (float)(rand() % 40) / 100.0f; // 80-120%
        shotInfo.power *= 0.8f;
        break;
    case MEDIUM:
        angleError = (float)(rand() % 60 - 30) / 1000.0f; // +/- ~1.7 deg
        powerErrorFactor = 0.9f + (float)(rand() % 20) / 100.0f; // 90-110%
        break;
    case HARD:
        angleError = (float)(rand() % 10 - 5) / 1000.0f; // +/- ~0.3 deg
        powerErrorFactor = 0.98f + (float)(rand() % 4) / 100.0f; // 98-102%
        break;
    }
    shotInfo.angle += angleError;
    shotInfo.power *= powerErrorFactor;
    shotInfo.power = std::max(1.0f, std::min(shotInfo.power, MAX_SHOT_POWER)); // Clamp power

    return shotInfo;
}


// Calculates required power (simplified)
float CalculateShotPower(float cueToGhostDist, float targetToPocketDist) {
    // Basic model: Power needed increases with total distance the balls need to travel.
    // Need enough power for cue ball to reach target AND target to reach pocket.
    float totalDist = cueToGhostDist + targetToPocketDist;

    // Map distance to power (needs tuning)
    // Let's say max power is needed for longest possible shot (e.g., corner to corner ~ 1000 units)
    float powerRatio = std::min(1.0f, totalDist / 800.0f); // Normalize based on estimated max distance

    float basePower = MAX_SHOT_POWER * 0.2f; // Minimum power to move balls reliably
    float variablePower = (MAX_SHOT_POWER * 0.8f) * powerRatio; // Scale remaining power range

    // Harder AI could adjust based on desired cue ball travel (more power for draw/follow)
    return std::min(MAX_SHOT_POWER, basePower + variablePower);
}

// Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex) {
    float targetToPocketX = pocketPositions[pocketIndex].x - targetBall->x;
    float targetToPocketY = pocketPositions[pocketIndex].y - targetBall->y;
    float dist = sqrtf(targetToPocketX * targetToPocketX + targetToPocketY * targetToPocketY);

    if (dist < 1.0f) { // Target is basically in the pocket
        // Aim slightly off-center to avoid weird physics? Or directly at center?
        // For simplicity, return a point slightly behind center along the reverse line.
        return D2D1::Point2F(targetBall->x - targetToPocketX * 0.1f, targetBall->y - targetToPocketY * 0.1f);
    }

    // Normalize direction vector from target to pocket
    float nx = targetToPocketX / dist;
    float ny = targetToPocketY / dist;

    // Ghost ball position is diameter distance *behind* the target ball along this line
    float ghostX = targetBall->x - nx * (BALL_RADIUS * 2.0f);
    float ghostY = targetBall->y - ny * (BALL_RADIUS * 2.0f);

    return D2D1::Point2F(ghostX, ghostY);
}

// Checks if line segment is clear of obstructing balls
bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2) {
    float dx = end.x - start.x;
    float dy = end.y - start.y;
    float segmentLenSq = dx * dx + dy * dy;

    if (segmentLenSq < 0.01f) return true; // Start and end are same point

    for (const auto& ball : balls) {
        if (ball.isPocketed) continue;
        if (ball.id == ignoredBallId1) continue;
        if (ball.id == ignoredBallId2) continue;

        // Check distance from ball center to the line segment
        float ballToStartX = ball.x - start.x;
        float ballToStartY = ball.y - start.y;

        // Project ball center onto the line defined by the segment
        float dot = (ballToStartX * dx + ballToStartY * dy) / segmentLenSq;

        D2D1_POINT_2F closestPointOnLine;
        if (dot < 0) { // Closest point is start point
            closestPointOnLine = start;
        }
        else if (dot > 1) { // Closest point is end point
            closestPointOnLine = end;
        }
        else { // Closest point is along the segment
            closestPointOnLine = D2D1::Point2F(start.x + dot * dx, start.y + dot * dy);
        }

        // Check if the closest point is within collision distance (ball radius + path radius)
        if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * BALL_RADIUS)) {
            // Consider slightly wider path check? Maybe BALL_RADIUS * 1.1f?
            // if (GetDistanceSq(ball.x, ball.y, closestPointOnLine.x, closestPointOnLine.y) < (BALL_RADIUS * 1.1f)*(BALL_RADIUS*1.1f)) {
            return false; // Path is blocked
        }
    }
    return true; // No obstructions found
}

// Finds the first ball hit along a path (simplified)
Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq) {
    Ball* hitBall = nullptr;
    hitDistSq = -1.0f; // Initialize hit distance squared
    float minCollisionDistSq = -1.0f;

    float cosA = cosf(angle);
    float sinA = sinf(angle);

    for (auto& ball : balls) {
        if (ball.isPocketed || ball.id == 0) continue; // Skip cue ball and pocketed

        float dx = ball.x - start.x;
        float dy = ball.y - start.y;

        // Project vector from start->ball onto the aim direction vector
        float dot = dx * cosA + dy * sinA;

        if (dot > 0) { // Ball is generally in front
            // Find closest point on aim line to the ball's center
            float closestPointX = start.x + dot * cosA;
            float closestPointY = start.y + dot * sinA;
            float distSq = GetDistanceSq(ball.x, ball.y, closestPointX, closestPointY);

            // Check if the aim line passes within the ball's radius
            if (distSq < (BALL_RADIUS * BALL_RADIUS)) {
                // Calculate distance from start to the collision point on the ball's circumference
                float backDist = sqrtf(std::max(0.f, BALL_RADIUS * BALL_RADIUS - distSq));
                float collisionDist = dot - backDist; // Distance along aim line to collision

                if (collisionDist > 0) { // Ensure collision is in front
                    float collisionDistSq = collisionDist * collisionDist;
                    if (hitBall == nullptr || collisionDistSq < minCollisionDistSq) {
                        minCollisionDistSq = collisionDistSq;
                        hitBall = &ball; // Found a closer hit ball
                    }
                }
            }
        }
    }
    hitDistSq = minCollisionDistSq; // Return distance squared to the first hit
    return hitBall;
}

// Basic check for reasonable AI aim angles (optional)
bool IsValidAIAimAngle(float angle) {
    // Placeholder - could check for NaN or infinity if calculations go wrong
    return isfinite(angle);
}

//midi func = start
void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
    while (isMusicPlaying) {
        MCI_OPEN_PARMS mciOpen = { 0 };
        mciOpen.lpstrDeviceType = TEXT(""sequencer"");
        mciOpen.lpstrElementName = midiPath;

        if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
            midiDeviceID = mciOpen.wDeviceID;

            MCI_PLAY_PARMS mciPlay = { 0 };
            mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

            // Wait for playback to complete
            MCI_STATUS_PARMS mciStatus = { 0 };
            mciStatus.dwItem = MCI_STATUS_MODE;

            do {
                mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                Sleep(100); // adjust as needed
            } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

void StartMidi(HWND hwnd, const TCHAR* midiPath) {
    if (isMusicPlaying) {
        StopMidi();
    }
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}

void StopMidi() {
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) musicThread.join();
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }
}

/*void PlayGameMusic(HWND hwnd) {
    // Stop any existing playback
    if (isMusicPlaying) {
        isMusicPlaying = false;
        if (musicThread.joinable()) {
            musicThread.join();
        }
        if (midiDeviceID != 0) {
            mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
            midiDeviceID = 0;
        }
    }

    // Get the path of the executable
    TCHAR exePath[MAX_PATH];
    GetModuleFileName(NULL, exePath, MAX_PATH);

    // Extract the directory path
    TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
    if (lastBackslash != NULL) {
        *(lastBackslash + 1) = '\0';
    }

    // Construct the full path to the MIDI file
    static TCHAR midiPath[MAX_PATH];
    _tcscpy_s(midiPath, MAX_PATH, exePath);
    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

    // Start the background playback
    isMusicPlaying = true;
    musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
}*/
//midi func = end

// --- Drawing Functions ---

void OnPaint() {
    HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

    if (SUCCEEDED(hr)) {
        pRenderTarget->BeginDraw();
        DrawScene(pRenderTarget); // Pass render target
        hr = pRenderTarget->EndDraw();

        if (hr == D2DERR_RECREATE_TARGET) {
            DiscardDeviceResources();
            // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
            // But the timer loop will trigger redraw anyway.
        }
    }
    // If CreateDeviceResources failed, EndDraw might not be called.
    // Consider handling this more robustly if needed.
}

void DrawScene(ID2D1RenderTarget* pRT) {
    if (!pRT) return;

    //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
    // Set background color to #ffffcd (RGB: 255, 255, 205)
    pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
    //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

    DrawTable(pRT, pFactory);
    DrawBalls(pRT);
    DrawAimingAids(pRT); // Includes cue stick if aiming
    DrawUI(pRT);
    DrawPowerMeter(pRT);
    DrawSpinIndicator(pRT);
    DrawPocketedBallsIndicator(pRT);
    DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

     // Draw Game Over Message
    if (currentGameState == GAME_OVER && pTextFormat) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
        if (pBrush) {
            D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
            pRT->DrawText(
                gameOverMessage.c_str(),
                (UINT32)gameOverMessage.length(),
                pTextFormat, // Use large format maybe?
                &layoutRect,
                pBrush
            );
            SafeRelease(&pBrush);
        }
    }

}

void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
    ID2D1SolidColorBrush* pBrush = nullptr;

    // === Draw Full Orange Frame (Table Border) ===
    ID2D1SolidColorBrush* pFrameBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
    if (pFrameBrush) {
        D2D1_RECT_F outerRect = D2D1::RectF(
            TABLE_LEFT - CUSHION_THICKNESS,
            TABLE_TOP - CUSHION_THICKNESS,
            TABLE_RIGHT + CUSHION_THICKNESS,
            TABLE_BOTTOM + CUSHION_THICKNESS
        );
        pRT->FillRectangle(&outerRect, pFrameBrush);
        SafeRelease(&pFrameBrush);
    }

    // Draw Table Bed (Green Felt)
    pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
    if (!pBrush) return;
    D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
    pRT->FillRectangle(&tableRect, pBrush);
    SafeRelease(&pBrush);

    // Draw Cushions (Red Border)
    pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
    if (!pBrush) return;
    // Top Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
    // Bottom Cushion (split by middle pocket)
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
    // Left Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    // Right Cushion
    pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
    SafeRelease(&pBrush);


    // Draw Pockets (Black Circles)
    pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
    if (!pBrush) return;
    for (int i = 0; i < 6; ++i) {
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
        pRT->FillEllipse(&ellipse, pBrush);
    }
    SafeRelease(&pBrush);

    // Draw Headstring Line (White)
    pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
    if (!pBrush) return;
    pRT->DrawLine(
        D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
        D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
        pBrush,
        1.0f // Line thickness
    );
    SafeRelease(&pBrush);

    // Draw Semicircle facing West (flat side East)
    // Draw Semicircle facing East (curved side on the East, flat side on the West)
    ID2D1PathGeometry* pGeometry = nullptr;
    HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
    if (SUCCEEDED(hr) && pGeometry)
    {
        ID2D1GeometrySink* pSink = nullptr;
        hr = pGeometry->Open(&pSink);
        if (SUCCEEDED(hr) && pSink)
        {
            float radius = 60.0f; // Radius for the semicircle
            D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

            // For a semicircle facing East (curved side on the East), use the top and bottom points.
            D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

            pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

            D2D1_ARC_SEGMENT arc = {};
            arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
            arc.size = D2D1::SizeF(radius, radius);
            arc.rotationAngle = 0.0f;
            // Use the correct identifier with the extra underscore:
            arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
            arc.arcSize = D2D1_ARC_SIZE_SMALL;

            pSink->AddArc(&arc);
            pSink->EndFigure(D2D1_FIGURE_END_OPEN);
            pSink->Close();
            SafeRelease(&pSink);

            ID2D1SolidColorBrush* pArcBrush = nullptr;
            //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
            pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
            if (pArcBrush)
            {
                pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                SafeRelease(&pArcBrush);
            }
        }
        SafeRelease(&pGeometry);
    }




}


void DrawBalls(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

    pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

    if (!pBrush || !pStripeBrush) {
        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
        return;
    }


    for (size_t i = 0; i < balls.size(); ++i) {
        const Ball& b = balls[i];
        if (!b.isPocketed) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            // Set main ball color
            pBrush->SetColor(b.color);
            pRT->FillEllipse(&ellipse, pBrush);

            // Draw Stripe if applicable
            if (b.type == BallType::STRIPE) {
                // Draw a white band across the middle (simplified stripe)
                D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                // Need to clip this rectangle to the ellipse bounds - complex!
                // Alternative: Draw two colored arcs leaving a white band.
                // Simplest: Draw a white circle inside, slightly smaller.
                D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                pBrush->SetColor(b.color); // Set back to stripe color
                pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                // Let's try drawing a thick white line across
                // This doesn't look great. Just drawing solid red for stripes for now.
            }

            // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
            // if (b.id != 0 && pTextFormat) {
            //     std::wstring numStr = std::to_wstring(b.id);
            //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
            //     ID2D1SolidColorBrush* pNumBrush = nullptr;
            //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
            //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
            //     // Create a smaller text format...
            //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
            //     SafeRelease(&pNumBrush);
            // }
        }
    }

    SafeRelease(&pBrush);
    SafeRelease(&pStripeBrush);
}


void DrawAimingAids(ID2D1RenderTarget* pRT) {
    // Condition check at start (Unchanged)
    //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
        //currentGameState != BREAKING && currentGameState != AIMING)
    //{
        //return;
    //}
        // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
    // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
    bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
        (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
            currentGameState == BREAKING || currentGameState == AIMING);
    // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
    // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
        // NEW Condition: AI is displaying its aim
    bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
        return;
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

    ID2D1SolidColorBrush* pBrush = nullptr;
    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    ID2D1StrokeStyle* pDashedStyle = nullptr;
    ID2D1SolidColorBrush* pCueBrush = nullptr;
    ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

    // Ensure render target is valid
    if (!pRT) return;

    // Create Brushes and Styles (check for failures)
    HRESULT hr;
    hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
    if FAILED(hr) { SafeRelease(&pBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
    // Create reflection brush (e.g., lighter shade or different color)
    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
    if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
    // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
    D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
    ID2D1SolidColorBrush* pCyanBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
    if (FAILED(hr)) {
        SafeRelease(&pCyanBrush);
        // handle error if needed
    }
    // Create a Purple brush for primary and secondary lines
    D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
    ID2D1SolidColorBrush* pPurpleBrush = nullptr;
    hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
    if (FAILED(hr)) {
        SafeRelease(&pPurpleBrush);
        // handle error if needed
    }

    if (pFactory) {
        D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
        strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
        hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        if FAILED(hr) { pDashedStyle = nullptr; }
    }


    // --- Cue Stick Drawing (Unchanged from previous fix) ---
    const float baseStickLength = 150.0f;
    const float baseStickThickness = 4.0f;
    float stickLength = baseStickLength * 1.4f;
    float stickThickness = baseStickThickness * 1.5f;
    float stickAngle = cueAngle + PI;
    float powerOffset = 0.0f;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
    if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
        powerOffset = shotPower * 5.0f;
    }
    D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
    D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
    pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


    // --- Projection Line Calculation ---
    float cosA = cosf(cueAngle);
    float sinA = sinf(cueAngle);
    float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
    D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
    D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

    // Find the first ball hit by the aiming ray
    Ball* hitBall = nullptr;
    float firstHitDistSq = -1.0f;
    D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
    D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

    hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
    if (hitBall) {
        // Calculate the point on the target ball's circumference
        float collisionDist = sqrtf(firstHitDistSq);
        ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
        // Calculate ghost ball position for this specific hit (used for projection consistency)
        ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
    }

    // Find the first rail hit by the aiming ray
    D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
    float minRailDistSq = rayLength * rayLength;
    int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

    // Define table edge segments for intersection checks
    D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
    D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
    D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
    D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

    D2D1_POINT_2F currentIntersection;

    // Check Left Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
    }
    // Check Right Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
    }
    // Check Top Rail
    if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
    }
    // Check Bottom Rail
    if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
        float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
        if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
    }


    // --- Determine final aim line end point ---
    D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
    bool aimingAtRail = true;

    if (hitBall && firstHitDistSq < minRailDistSq) {
        // Ball collision is closer than rail collision
        finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
        aimingAtRail = false;
    }

    // --- Draw Primary Aiming Line ---
    pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

    // --- Draw Target Circle/Indicator ---
    D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
    pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

    // --- Draw Projection/Reflection Lines ---
    if (!aimingAtRail && hitBall) {
        // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
        D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
        pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // Calculate target ball projection based on impact line (cue collision point -> target center)
        float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
        // Clamp angle calculation if distance is tiny
        if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
            targetProjectionAngle = cueAngle; // Fallback if overlapping
        }

        D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
        D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
            hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
            hitBall->y + sinf(targetProjectionAngle) * 50.0f
        );
        // Draw solid line for target projection
        //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

    //new code start

                // Dual trajectory with edge-aware contact simulation
        D2D1_POINT_2F dir = {
            targetProjectionEnd.x - targetStartPoint.x,
            targetProjectionEnd.y - targetStartPoint.y
        };
        float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
        dir.x /= dirLen;
        dir.y /= dirLen;

        D2D1_POINT_2F perp = { -dir.y, dir.x };

        // Approximate cue ball center by reversing from tip
        D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
            targetStartPoint.x - dir.x * BALL_RADIUS,
            targetStartPoint.y - dir.y * BALL_RADIUS
        };

        // REAL contact-ball center - use your physics object's center:
        // (replace 'objectBallPos' with whatever you actually call it)
        // (targetStartPoint is already hitBall->x, hitBall->y)
        D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
        //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

       // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
       // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
       // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
       // and 'perp' is perpendicular to 'dir'.
       // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
        /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
            (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
            /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                (targetStartPoint.y - cueBallCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);*/

            // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
        D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

        // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
        float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
            (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
        float absOffset = fabsf(offset);
        float side = (offset >= 0 ? 1.0f : -1.0f);


        // Actual contact point on target ball edge
        D2D1_POINT_2F contactPoint = {
        contactBallCenter.x + perp.x * BALL_RADIUS * side,
        contactBallCenter.y + perp.y * BALL_RADIUS * side
        };

        // Tangent (cut shot) path from contact point
            // Tangent (cut shot) path: from contact point to contact ball center
        D2D1_POINT_2F objectBallDir = {
            contactBallCenter.x - contactPoint.x,
            contactBallCenter.y - contactPoint.y
        };
        float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
        if (oLen != 0.0f) {
            objectBallDir.x /= oLen;
            objectBallDir.y /= oLen;
        }

        const float PRIMARY_LEN = 150.0f; //default=150.0f
        const float SECONDARY_LEN = 150.0f; //default=150.0f
        const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

        D2D1_POINT_2F primaryEnd = {
            targetStartPoint.x + dir.x * PRIMARY_LEN,
            targetStartPoint.y + dir.y * PRIMARY_LEN
        };

        // Secondary line starts from the contact ball's center
        D2D1_POINT_2F secondaryStart = contactBallCenter;
        D2D1_POINT_2F secondaryEnd = {
            secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
            secondaryStart.y + objectBallDir.y * SECONDARY_LEN
        };

        if (absOffset < STRAIGHT_EPSILON)  // straight shot?
        {
            // Straight: secondary behind primary
                    // secondary behind primary {pDashedStyle param at end}
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        else
        {
            // Cut shot: both visible
                    // both visible for cut shot
            pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
            //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
            pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
            //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
        }
        // End improved trajectory logic

    //new code end

        // -- Cue Ball Path after collision (Optional, requires physics) --
        // Very simplified: Assume cue deflects, angle depends on cut angle.
        // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
        // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
        // D2D1_POINT_2F cueProjectionEnd = ...
        // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Accuracy Comment ---
        // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
        // or shots with spin, is limited by the simplified physics model. Real pool physics involves
        // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
        // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

    }
    else if (aimingAtRail && hitRailIndex != -1) {
        // Aiming at a rail: Draw reflection line
        float reflectAngle = cueAngle;
        // Reflect angle based on which rail was hit
        if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
            reflectAngle = PI - cueAngle; // Reflect horizontal component
        }
        else { // Top or Bottom rail
            reflectAngle = -cueAngle; // Reflect vertical component
        }
        // Normalize angle if needed (atan2 usually handles this)
        while (reflectAngle > PI) reflectAngle -= 2 * PI;
        while (reflectAngle <= -PI) reflectAngle += 2 * PI;


        float reflectionLength = 60.0f; // Length of the reflection line
        D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
            finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
            finalLineEnd.y + sinf(reflectAngle) * reflectionLength
        );

        // Draw the reflection line (e.g., using a different color/style)
        pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
    }

    // Release resources
    SafeRelease(&pBrush);
    SafeRelease(&pGhostBrush);
    SafeRelease(&pCueBrush);
    SafeRelease(&pReflectBrush); // Release new brush
    SafeRelease(&pCyanBrush);
    SafeRelease(&pPurpleBrush);
    SafeRelease(&pDashedStyle);
}


void DrawUI(ID2D1RenderTarget* pRT) {
    if (!pTextFormat || !pLargeTextFormat) return;

    ID2D1SolidColorBrush* pBrush = nullptr;
    pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
    if (!pBrush) return;

    // --- Player Info Area (Top Left/Right) --- (Unchanged)
    float uiTop = TABLE_TOP - 80;
    float uiHeight = 60;
    float p1Left = TABLE_LEFT;
    float p1Width = 150;
    float p2Left = TABLE_RIGHT - p1Width;
    D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
    D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

    // Player 1 Info Text (Unchanged)
    std::wostringstream oss1;
    oss1 << player1Info.name.c_str() << L""\n"";
    if (player1Info.assignedType != BallType::NONE) {
        oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss1 << L""(Undecided)"";
    }
    pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
    // Draw Player 1 Side Ball
    if (player1Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player1Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // Player 2 Info Text (Unchanged)
    std::wostringstream oss2;
    oss2 << player2Info.name.c_str() << L""\n"";
    if (player2Info.assignedType != BallType::NONE) {
        oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
        oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
    }
    else {
        oss2 << L""(Undecided)"";
    }
    pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
    // Draw Player 2 Side Ball
    if (player2Info.assignedType != BallType::NONE)
    {
        ID2D1SolidColorBrush* pBallBrush = nullptr;
        D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
            D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
        pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
        if (pBallBrush)
        {
            D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
            float radius = 10.0f;
            D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
            pRT->FillEllipse(&ball, pBallBrush);
            SafeRelease(&pBallBrush);
            // Draw border around the ball
            ID2D1SolidColorBrush* pBorderBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
            if (pBorderBrush)
            {
                pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                SafeRelease(&pBorderBrush);
            }

            // If stripes, draw a stripe band
            if (player2Info.assignedType == BallType::STRIPE)
            {
                ID2D1SolidColorBrush* pStripeBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                if (pStripeBrush)
                {
                    D2D1_RECT_F stripeRect = D2D1::RectF(
                        ballCenter.x - radius,
                        ballCenter.y - 3.0f,
                        ballCenter.x + radius,
                        ballCenter.y + 3.0f
                    );
                    pRT->FillRectangle(&stripeRect, pStripeBrush);
                    SafeRelease(&pStripeBrush);
                }
            }
        }
    }


    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
        arrowBackX = playerBox.left - 25.0f;
        arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

        float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
        float notchWidth = 10.0f;

        float cx = arrowBackX;
        float cy = arrowCenterY;

        // Define triangle + rectangle tail shape
        D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
        D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
        D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

        // Rectangle coordinates for the tail portion:
        D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
        D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
        D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
        D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseTop);
                pSink->AddLine(r2); // transition from triangle into rectangle
                pSink->AddLine(r1);
                pSink->AddLine(r4);
                pSink->AddLine(r3);
                pSink->AddLine(baseBot);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }


        SafeRelease(&pArrowBrush);
    }

    //original
/*
    // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
    ID2D1SolidColorBrush* pArrowBrush = nullptr;
    pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
    if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
        float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
        float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
        float arrowTipX, arrowBackX;

        if (currentPlayer == 1) {
arrowBackX = p1Rect.left - 25.0f; // Position left of the box
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
            // Define points for right-pointing arrow
            //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
            //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
            //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
            // Enhanced arrow with base rectangle intersection
    float notchDepth = 6.0f; // Depth of square base ""stem""
    float notchWidth = 4.0f; // Thickness of square part

    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
    D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
    D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
        }


        //==================else player 2
        else { // Player 2
         // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
         // Let's keep it consistent: Arrow left of the active player's box, pointing right.
// Let's keep it consistent: Arrow left of the active player's box, pointing right.
arrowBackX = p2Rect.left - 25.0f; // Position left of the box
arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
// Define points for right-pointing arrow
D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

ID2D1PathGeometry* pPath = nullptr;
if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
    ID2D1GeometrySink* pSink = nullptr;
    if (SUCCEEDED(pPath->Open(&pSink))) {
        pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
        pSink->AddLine(pt2);
        pSink->AddLine(pt3);
        pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
        pSink->Close();
        SafeRelease(&pSink);
        pRT->FillGeometry(pPath, pArrowBrush);
    }
    SafeRelease(&pPath);
}
        }
        */

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
    if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
        ID2D1SolidColorBrush* pFoulBrush = nullptr;
        pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
        if (pFoulBrush && pLargeTextFormat) {
            // Calculate Rect for bottom-middle area
            float foulWidth = 200.0f; // Adjust width as needed
            float foulHeight = 60.0f;
            float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
            // Position below the pocketed balls bar
            float foulTop = pocketedBallsBarRect.bottom + 10.0f;
            D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

            // --- Set text alignment to center for foul text ---
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

            // --- Restore default alignment for large text if needed elsewhere ---
            // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

            SafeRelease(&pFoulBrush);
        }
    }

    // Show AI Thinking State (Unchanged from previous step)
    if (currentGameState == AI_THINKING && pTextFormat) {
        ID2D1SolidColorBrush* pThinkingBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
        if (pThinkingBrush) {
            D2D1_RECT_F thinkingRect = p2Rect;
            thinkingRect.top += 20; // Offset within P2 box
            // Ensure default text alignment for this
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
            SafeRelease(&pThinkingBrush);
        }
    }

    SafeRelease(&pBrush);

    // --- Draw CHEAT MODE label if active ---
    if (cheatModeEnabled) {
        ID2D1SolidColorBrush* pCheatBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
        if (pCheatBrush && pTextFormat) {
            D2D1_RECT_F cheatTextRect = D2D1::RectF(
                TABLE_LEFT + 10.0f,
                TABLE_TOP + 10.0f,
                TABLE_LEFT + 200.0f,
                TABLE_TOP + 40.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
        }
        SafeRelease(&pCheatBrush);
    }
}

void DrawPowerMeter(ID2D1RenderTarget* pRT) {
    // Draw Border
    ID2D1SolidColorBrush* pBorderBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
    if (!pBorderBrush) return;
    pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
    SafeRelease(&pBorderBrush);

    // Create Gradient Fill
    ID2D1GradientStopCollection* pGradientStops = nullptr;
    ID2D1LinearGradientBrush* pGradientBrush = nullptr;
    D2D1_GRADIENT_STOP gradientStops[4];
    gradientStops[0].position = 0.0f;
    gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
    gradientStops[1].position = 0.45f;
    gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
    gradientStops[2].position = 0.7f;
    gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
    gradientStops[3].position = 1.0f;
    gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

    pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
    if (pGradientStops) {
        D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
        props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
        props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
        pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
        SafeRelease(&pGradientStops);
    }

    // Calculate Fill Height
    float fillRatio = 0;
    //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
        // Determine if power meter should reflect shot power (human aiming or AI preparing)
    bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
    // NEW Condition: AI is displaying its aim, so show its chosen power
    bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
        currentGameState == AI_THINKING && aiIsDisplayingAim);

    if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
        fillRatio = shotPower / MAX_SHOT_POWER;
    }
    float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
    D2D1_RECT_F fillRect = D2D1::RectF(
        powerMeterRect.left,
        powerMeterRect.bottom - fillHeight,
        powerMeterRect.right,
        powerMeterRect.bottom
    );

    if (pGradientBrush) {
        pRT->FillRectangle(&fillRect, pGradientBrush);
        SafeRelease(&pGradientBrush);
    }

    // Draw scale notches
    ID2D1SolidColorBrush* pNotchBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
    if (pNotchBrush) {
        for (int i = 0; i <= 8; ++i) {
            float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
            pRT->DrawLine(
                D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                pNotchBrush,
                1.5f
            );
        }
        SafeRelease(&pNotchBrush);
    }

    // Draw ""Power"" Label Below Meter
    if (pTextFormat) {
        ID2D1SolidColorBrush* pTextBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
        if (pTextBrush) {
            D2D1_RECT_F textRect = D2D1::RectF(
                powerMeterRect.left - 20.0f,
                powerMeterRect.bottom + 8.0f,
                powerMeterRect.right + 20.0f,
                powerMeterRect.bottom + 38.0f
            );
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
            pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
            SafeRelease(&pTextBrush);
        }
    }

    // Draw Glow Effect if fully charged or fading out
    static float glowPulse = 0.0f;
    static bool glowIncreasing = true;
    static float glowFadeOut = 0.0f; // NEW: tracks fading out

    if (shotPower >= MAX_SHOT_POWER * 0.99f) {
        // While fully charged, keep pulsing normally
        if (glowIncreasing) {
            glowPulse += 0.02f;
            if (glowPulse >= 1.0f) glowIncreasing = false;
        }
        else {
            glowPulse -= 0.02f;
            if (glowPulse <= 0.0f) glowIncreasing = true;
        }
        glowFadeOut = 1.0f; // Reset fade out to full
    }
    else if (glowFadeOut > 0.0f) {
        // If shot fired, gradually fade out
        glowFadeOut -= 0.02f;
        if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
    }

    if (glowFadeOut > 0.0f) {
        ID2D1SolidColorBrush* pGlowBrush = nullptr;
        float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
        pRT->CreateSolidColorBrush(
            D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
            &pGlowBrush
        );
        if (pGlowBrush) {
            float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
            float glowCenterY = powerMeterRect.top;
            D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                12.0f + 3.0f * glowPulse,
                6.0f + 2.0f * glowPulse
            );
            pRT->FillEllipse(&glowEllipse, pGlowBrush);
            SafeRelease(&pGlowBrush);
        }
    }
}

void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pWhiteBrush = nullptr;
    ID2D1SolidColorBrush* pRedBrush = nullptr;

    pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
    pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

    if (!pWhiteBrush || !pRedBrush) {
        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
        return;
    }

    // Draw White Ball Background
    D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
    pRT->FillEllipse(&bgEllipse, pWhiteBrush);
    pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


    // Draw Red Dot for Spin Position
    float dotRadius = 4.0f;
    float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
    float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
    D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
    pRT->FillEllipse(&dotEllipse, pRedBrush);

    SafeRelease(&pWhiteBrush);
    SafeRelease(&pRedBrush);
}


void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
    ID2D1SolidColorBrush* pBgBrush = nullptr;
    ID2D1SolidColorBrush* pBallBrush = nullptr;

    // Ensure render target is valid before proceeding
    if (!pRT) return;

    HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
    if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

    hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
    if (FAILED(hr)) {
        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
        return; // Exit if brush creation fails
    }

    // Draw the background bar (rounded rect)
    D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
    float baseAlpha = 0.8f;
    float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
    float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
    pBgBrush->SetOpacity(finalAlpha);
    pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
    pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

    // --- Draw small circles for pocketed balls inside the bar ---

    // Calculate dimensions based on the bar's height for better scaling
    float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
    float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
    float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
    float padding = spacing * 0.75f; // Add padding from the edges
    float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

    // Starting X positions with padding
    float currentX_P1 = pocketedBallsBarRect.left + padding;
    float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

    int p1DrawnCount = 0;
    int p2DrawnCount = 0;
    const int maxBallsToShow = 7; // Max balls per player in the bar

    for (const auto& b : balls) {
        if (b.isPocketed) {
            // Skip cue ball and 8-ball in this indicator
            if (b.id == 0 || b.id == 8) continue;

            bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
            bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

            if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P1 balls from left to right
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p1DrawnCount++;
            }
            else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                pBallBrush->SetColor(b.color);
                // Draw P2 balls from right to left
                D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                pRT->FillEllipse(&ballEllipse, pBallBrush);
                p2DrawnCount++;
            }
            // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
            // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
        }
    }

    SafeRelease(&pBgBrush);
    SafeRelease(&pBallBrush);
}

void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
    if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
        return; // Only show when placing/dragging
    }

    Ball* cueBall = GetCueBall();
    if (!cueBall) return;

    ID2D1SolidColorBrush* pGhostBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

    if (pGhostBrush) {
        D2D1_POINT_2F drawPos;
        if (isDraggingCueBall) {
            drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
        }
        else {
            // If not dragging but in placement state, show at current ball pos
            drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
        }

        // Check if the placement is valid before drawing differently?
        bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
        bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

        if (!isValid) {
            // Maybe draw red outline if invalid placement?
            pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
        }


        D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
        pRT->FillEllipse(&ghostEllipse, pGhostBrush);
        pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

        SafeRelease(&pGhostBrush);
    }
}"
