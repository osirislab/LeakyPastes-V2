id,title,username,language,date,content
n6hbuYNT,XL VIDIO CLOUD,AZWIR,YAML,Tuesday 22nd of July 2025 07:02:46 AM CDT,"port: 7890
socks-port: 7891
redir-port: 7892
mixed-port: 7893
tproxy-port: 7895
ipv6: false
mode: rule
log-level: silent
allow-lan: true
external-controller: 0.0.0.0:9090
secret: """"
bind-address: ""*""
unified-delay: true
profile:
store-selected: true
dns:
  enable: true
  ipv6: false
  enhanced-mode: redir-host
  listen: 0.0.0.0:7874
  nameserver:
    - 8.8.8.8
    - 1.0.0.1
    - https://dns.google/dns-query
  fallback:
    - 1.1.1.1
    - 8.8.4.4
    - https://cloudflare-dns.com/dns-query
    - 112.215.203.254
  default-nameserver:
    - 8.8.8.8
    - 1.1.1.1
    - 112.215.203.254
proxies:
  - name: VIDIO 1
    server: 104.17.155.243
    port: 443
    type: vless
    uuid: b46036f7-9a6b-4ed8-9c06-dcb38b18b881
    cipher: auto
    tls: true
    skip-cert-verify: true
    servername: wilo.luckystup-id.xyz
    network: ws
    ws-opts:
      path: /103.102.231.124-2053
      headers:
        Host: wilo.luckystup-id.xyz
    udp: true
    proxies:
      - VIDIO 1
"
M8vTmBBJ,Changelly.com Exploit,milanonpastebin,JavaScript,Tuesday 22nd of July 2025 06:56:14 AM CDT,"Found a short PDF that documents what appears to be a persistent pricing inconsistency on Changelly when using Bitcoin as the source asset in a swap.

It seems that when an older, deprecated Node backend is manually injected through the browser console, the exchange interface begins quoting significantly higher-than-expected amounts in the destination currency ‚Äî typically around 37% more than the current market rate.

For example:
Swapping the equivalent of $2000 in BTC would normally return ~$2000 worth of ETH (or other altcoins),
but with the legacy node active, the quoted return jumps to around $2740, effectively creating a one-sided gain in value.

This discrepancy doesn't affect other input currencies ‚Äî it seems to be specific to BTC as the base asset.

Once the swap is completed and the altcoin received, the funds can, in theory, be exchanged back into BTC, allowing for the process to be repeated in a loop (although the exact profitability per iteration would vary depending on fees and timing).

The full explanation, including the script used to load the older backend and a working example, is documented in this write-up:

üìÑ PDF: docs.google.com/document/d/1du7koBTyzf46mn2qZLqf2GMgjr2R8H4cRW5EPdNcfkU/edit?usp=sharing

Posting for informational and archival purposes ‚Äî surprised this hasn't been patched, considering the backend is officially deprecated.

Credits: Traseko
Works as of: 22 July 2025, Time: 01:56 PM UTC
Post hash: PPhgOhNIGBnfDjePvCFUcthi"
PGj560MT,dataNone,TestGuy1,JSON,Tuesday 22nd of July 2025 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'acaba1552b35b5d4ed1054f11f392700424f1678ac8f6f6743a888b6ad60c4c62f9404846a8300d3a58c8d1f7a6b29e14c435b599fb29673fc97ebd6de626e80e90a60a899c96358514542c8fdfdae98e03122a92c002493f1de7b92c1da5e7915f6a6bf7d8a02ca7331c47447f5d43b3c6b04bcb49eab4e6ad5b42c6e8c2915',
  otherdata: [
    'fd034d43ae591f8fa08da7792b462e95',
    '3e1e42a642cf938decb94fe581541f27',
    '37c7db6762741d6b201022071c45d12a',
    '2047081002da06cd02a6aefe2466b012',
    'cdb84693e5c8ee119754c0c8d6a1fd5a',
    'b50508ca2328486c745d67abafd5a792',
    '318c5589ccf4f17259672e963019b3eb',
    '810d026e3d212e5cc4608a86f642dfa6'
  ]
}"
D2jwLaAU,excellent 4 OK very good final 2,max2201111,Python,Tuesday 22nd of July 2025 05:22:59 AM CDT,"import time
import copy
from datetime import datetime
from typing import List, Tuple, Optional, Dict, Set

class ChessEngine:
    def __init__(self):
        # Z√°kladn√≠ nastaven√≠
        self.board = [['' for _ in range(8)] for _ in range(8)]
        self.white_to_move = True
        self.castling_rights = {'K': True, 'Q': True, 'k': True, 'q': True}
        self.en_passant = None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        
        # Hodnoty figur pro evaluaci
        self.piece_values = {
            'P': 100, 'N': 320, 'B': 330, 'R': 500, 'Q': 900, 'K': 20000,
            'p': -100, 'n': -320, 'b': -330, 'r': -500, 'q': -900, 'k': -20000,
            'A': 1200, 'a': -1200,  # Amazonka (k≈Ø≈à + d√°ma)
            'C': 800, 'c': -800,    # Cyril (k≈Ø≈à + vƒõ≈æ)
            'E': 650, 'e': -650     # Eve (k≈Ø≈à + st≈ôelec)
        }
        
        # Historie tah≈Ø pro v√Ωpis cesty
        self.move_history = []
        self.position_history = []
        
    def load_fen(self, fen: str):
        """"""Naƒçte pozici z FEN stringu""""""
        # Nejd≈ô√≠ve vyma≈æ ≈°achovnici
        self.board = [['' for _ in range(8)] for _ in range(8)]
        
        parts = fen.split()
        
        # Parsov√°n√≠ pozice
        rows = parts[0].split('/')
        for row_idx, row in enumerate(rows):
            if row_idx >= 8:  # Ochrana proti p≈ô√≠li≈° mnoha ≈ô√°dk≈Øm
                break
            col_idx = 0
            for char in row:
                if col_idx >= 8:  # Ochrana proti p≈ôekroƒçen√≠ sloupc≈Ø
                    break
                if char.isdigit():
                    # Pr√°zdn√° pole
                    empty_squares = int(char)
                    for _ in range(empty_squares):
                        if col_idx < 8:
                            self.board[row_idx][col_idx] = ''
                            col_idx += 1
                else:
                    self.board[row_idx][col_idx] = char
                    col_idx += 1
        
        # Na tahu
        self.white_to_move = parts[1] == 'w'
        
        # Ro≈°√°da
        castling = parts[2] if len(parts) > 2 else '-'
        self.castling_rights = {
            'K': 'K' in castling,
            'Q': 'Q' in castling,
            'k': 'k' in castling,
            'q': 'q' in castling
        }
        
        # En passant
        self.en_passant = parts[3] if len(parts) > 3 and parts[3] != '-' else None
        
        # Poƒçet tah≈Ø
        self.halfmove_clock = int(parts[4]) if len(parts) > 4 else 0
        self.fullmove_number = int(parts[5]) if len(parts) > 5 else 1
        
    def to_fen(self) -> str:
        """"""P≈ôevede aktu√°ln√≠ pozici na FEN string""""""
        # Pozice
        fen_rows = []
        for row in self.board:
            fen_row = ''
            empty_count = 0
            for cell in row:
                if cell == '':
                    empty_count += 1
                else:
                    if empty_count > 0:
                        fen_row += str(empty_count)
                        empty_count = 0
                    fen_row += cell
            if empty_count > 0:
                fen_row += str(empty_count)
            fen_rows.append(fen_row)
        
        board_fen = '/'.join(fen_rows)
        
        # Na tahu
        active_color = 'w' if self.white_to_move else 'b'
        
        # Ro≈°√°da
        castling = ''
        if self.castling_rights['K']: castling += 'K'
        if self.castling_rights['Q']: castling += 'Q'
        if self.castling_rights['k']: castling += 'k'
        if self.castling_rights['q']: castling += 'q'
        if not castling: castling = '-'
        
        # En passant
        en_passant = self.en_passant if self.en_passant else '-'
        
        return f""{board_fen} {active_color} {castling} {en_passant} {self.halfmove_clock} {self.fullmove_number}""
    
    def print_board(self):
        """"""Vyp√≠≈°e ≈°achovnici v ASCII form√°tu""""""
        print(""  a b c d e f g h"")
        for i in range(8):
            print(f""{8-i} "", end="""")
            for j in range(8):
                piece = self.board[i][j]
                if piece == '':
                    piece = '.'
                print(f""{piece} "", end="""")
            print(f""{8-i}"")
        print(""  a b c d e f g h"")
        print()
    
    def is_white_piece(self, piece: str) -> bool:
        """"""Zjist√≠, zda je figura b√≠l√°""""""
        return piece.isupper()
    
    def get_piece_moves(self, row: int, col: int, check_castling: bool = True) -> List[Tuple[int, int]]:
        """"""Z√≠sk√° v≈°echny mo≈æn√© tahy pro figuru na dan√© pozici""""""
        piece = self.board[row][col]
        if piece == '':
            return []
        
        piece_type = piece.lower()
        is_white = self.is_white_piece(piece)
        moves = []
        
        if piece_type == 'p':
            # Pƒõ≈°ec
            direction = -1 if is_white else 1
            start_row = 6 if is_white else 1
            
            # Tah dop≈ôedu
            if 0 <= row + direction < 8 and self.board[row + direction][col] == '':
                moves.append((row + direction, col))
                # Dvojit√Ω tah z poƒç√°teƒçn√≠ pozice
                if row == start_row and self.board[row + 2 * direction][col] == '':
                    moves.append((row + 2 * direction, col))
            
            # Bran√≠ √∫hlop≈ô√≠ƒçnƒõ
            for dc in [-1, 1]:
                new_row, new_col = row + direction, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target != '' and self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
                    # En passant
                    elif self.en_passant and self.en_passant == f""{chr(ord('a') + new_col)}{8 - new_row}"":
                        moves.append((new_row, new_col))
        
        elif piece_type == 'r':
            # Vƒõ≈æ
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'n':
            # K≈Ø≈à
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'b':
            # St≈ôelec
            directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'q':
            # D√°ma
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'k':
            # Kr√°l
            king_moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in king_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
            
            # Ro≈°√°da - pouze pokud je povoleno kontrolovat (vyhneme se rekurzi)
            if check_castling and not self.is_in_check(is_white):
                # Kr√°tk√° ro≈°√°da
                castling_key = 'K' if is_white else 'k'
                if self.castling_rights[castling_key]:
                    if (self.board[row][col + 1] == '' and self.board[row][col + 2] == '' and
                        not self.is_square_attacked(row, col + 1, not is_white) and
                        not self.is_square_attacked(row, col + 2, not is_white)):
                        moves.append((row, col + 2))
                
                # Dlouh√° ro≈°√°da
                castling_key = 'Q' if is_white else 'q'
                if self.castling_rights[castling_key]:
                    if (self.board[row][col - 1] == '' and self.board[row][col - 2] == '' and
                        self.board[row][col - 3] == '' and
                        not self.is_square_attacked(row, col - 1, not is_white) and
                        not self.is_square_attacked(row, col - 2, not is_white)):
                        moves.append((row, col - 2))
        
        elif piece_type == 'a':  # Amazonka (k≈Ø≈à + d√°ma)
            # Tahy d√°my
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'c':  # Cyril (k≈Ø≈à + vƒõ≈æ)
            # Tahy vƒõ≈æe
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'e':  # Eve (k≈Ø≈à + st≈ôelec)
            # Tahy st≈ôelce
            directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        return moves
    
    def is_square_attacked(self, row: int, col: int, by_white: bool) -> bool:
        """"""Zjist√≠, zda je pole napaden√© danou barvou""""""
        for r in range(8):
            for c in range(8):
                piece = self.board[r][c]
                if piece != '' and self.is_white_piece(piece) == by_white:
                    # Nekontroluji ro≈°√°du p≈ôi detekci napaden√≠ (vyhneme se rekurzi)
                    moves = self.get_piece_moves(r, c, check_castling=False)
                    if (row, col) in moves:
                        return True
        return False
    
    def find_king(self, is_white: bool) -> Tuple[int, int]:
        """"""Najde kr√°le dan√© barvy""""""
        king = 'K' if is_white else 'k'
        for r in range(8):
            for c in range(8):
                if self.board[r][c] == king:
                    return (r, c)
        return (-1, -1)  # Kr√°l nenalezen
    
    def is_in_check(self, is_white: bool) -> bool:
        """"""Zjist√≠, zda je kr√°l v ≈°achu""""""
        king_pos = self.find_king(is_white)
        if king_pos == (-1, -1):
            return False
        return self.is_square_attacked(king_pos[0], king_pos[1], not is_white)
    
    def make_move(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> bool:
        """"""Provede tah a vr√°t√≠ True, pokud je leg√°ln√≠""""""
        from_row, from_col = from_pos
        to_row, to_col = to_pos
        
        piece = self.board[from_row][from_col]
        if piece == '':
            return False
        
        is_white = self.is_white_piece(piece)
        if is_white != self.white_to_move:
            return False
        
        # Zkontroluj, zda je tah v seznamu mo≈æn√Ωch tah≈Ø
        possible_moves = self.get_piece_moves(from_row, from_col)
        if (to_row, to_col) not in possible_moves:
            return False
        
        # Ulo≈æ p≈Øvodn√≠ stav
        original_board = copy.deepcopy(self.board)
        original_castling = copy.deepcopy(self.castling_rights)
        original_en_passant = self.en_passant
        
        # Proveƒè tah
        captured_piece = self.board[to_row][to_col]
        self.board[to_row][to_col] = piece
        self.board[from_row][from_col] = ''
        
        # Speci√°ln√≠ tahy
        piece_type = piece.lower()
        
        # En passant
        if piece_type == 'p' and self.en_passant and f""{chr(ord('a') + to_col)}{8 - to_row}"" == self.en_passant:
            if is_white:
                self.board[to_row + 1][to_col] = ''
            else:
                self.board[to_row - 1][to_col] = ''
        
        # Ro≈°√°da
        if piece_type == 'k' and abs(to_col - from_col) == 2:
            if to_col > from_col:  # Kr√°tk√° ro≈°√°da
                self.board[from_row][7] = ''
                self.board[from_row][5] = 'R' if is_white else 'r'
            else:  # Dlouh√° ro≈°√°da
                self.board[from_row][0] = ''
                self.board[from_row][3] = 'R' if is_white else 'r'
        
        # Aktualizace en passant
        if piece_type == 'p' and abs(to_row - from_row) == 2:
            self.en_passant = f""{chr(ord('a') + from_col)}{8 - (from_row + to_row) // 2}""
        else:
            self.en_passant = None
        
        # Aktualizace ro≈°√°dov√Ωch pr√°v
        if piece_type == 'k':
            if is_white:
                self.castling_rights['K'] = False
                self.castling_rights['Q'] = False
            else:
                self.castling_rights['k'] = False
                self.castling_rights['q'] = False
        elif piece_type == 'r':
            if from_row == 0 or from_row == 7:
                if from_col == 0:
                    key = 'Q' if from_row == 7 else 'q'
                    self.castling_rights[key] = False
                elif from_col == 7:
                    key = 'K' if from_row == 7 else 'k'
                    self.castling_rights[key] = False
        
        # Zkontroluj, zda vlastn√≠ kr√°l nen√≠ v ≈°achu
        if self.is_in_check(is_white):
            # Vra≈• p≈Øvodn√≠ stav
            self.board = original_board
            self.castling_rights = original_castling
            self.en_passant = original_en_passant
            return False
        
        # Tah je leg√°ln√≠
        self.white_to_move = not self.white_to_move
        if not self.white_to_move:
            self.fullmove_number += 1
        
        if captured_piece or piece_type == 'p':
            self.halfmove_clock = 0
        else:
            self.halfmove_clock += 1
        
        return True
    
    def undo_move(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int], 
                  captured_piece: str, old_castling: dict, old_en_passant: str,
                  old_halfmove: int, old_fullmove: int, was_white_to_move: bool):
        """"""Vr√°t√≠ tah zpƒõt""""""
        from_row, from_col = from_pos
        to_row, to_col = to_pos
        
        piece = self.board[to_row][to_col]
        self.board[from_row][from_col] = piece
        self.board[to_row][to_col] = captured_piece
        
        # Vr√°cen√≠ speci√°ln√≠ch tah≈Ø
        piece_type = piece.lower()
        
        # Ro≈°√°da
        if piece_type == 'k' and abs(to_col - from_col) == 2:
            if to_col > from_col:  # Kr√°tk√° ro≈°√°da
                self.board[from_row][7] = 'R' if self.is_white_piece(piece) else 'r'
                self.board[from_row][5] = ''
            else:  # Dlouh√° ro≈°√°da
                self.board[from_row][0] = 'R' if self.is_white_piece(piece) else 'r'
                self.board[from_row][3] = ''
        
        # En passant
        if piece_type == 'p' and old_en_passant and f""{chr(ord('a') + to_col)}{8 - to_row}"" == old_en_passant:
            if self.is_white_piece(piece):
                self.board[to_row + 1][to_col] = 'p'
            else:
                self.board[to_row - 1][to_col] = 'P'
        
        self.castling_rights = old_castling
        self.en_passant = old_en_passant
        self.halfmove_clock = old_halfmove
        self.fullmove_number = old_fullmove
        self.white_to_move = was_white_to_move
    
    def get_all_legal_moves(self) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """"""Z√≠sk√° v≈°echny leg√°ln√≠ tahy pro aktu√°ln√≠ho hr√°ƒçe""""""
        legal_moves = []
        
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece != '' and self.is_white_piece(piece) == self.white_to_move:
                    moves = self.get_piece_moves(row, col)
                    for to_row, to_col in moves:
                        # Zkop√≠ruj stav
                        original_state = self.save_state()
                        
                        # Zkus tah
                        if self.make_move((row, col), (to_row, to_col)):
                            legal_moves.append(((row, col), (to_row, to_col)))
                        
                        # Vra≈• stav
                        self.restore_state(original_state)
        
        return legal_moves
    
    def save_state(self):
        """"""Ulo≈æ√≠ aktu√°ln√≠ stav hry""""""
        return {
            'board': copy.deepcopy(self.board),
            'white_to_move': self.white_to_move,
            'castling_rights': copy.deepcopy(self.castling_rights),
            'en_passant': self.en_passant,
            'halfmove_clock': self.halfmove_clock,
            'fullmove_number': self.fullmove_number
        }
    
    def restore_state(self, state):
        """"""Obnov√≠ ulo≈æen√Ω stav hry""""""
        self.board = state['board']
        self.white_to_move = state['white_to_move']
        self.castling_rights = state['castling_rights']
        self.en_passant = state['en_passant']
        self.halfmove_clock = state['halfmove_clock']
        self.fullmove_number = state['fullmove_number']
    
    def get_material_balance(self) -> int:
        """"""Spoƒç√≠t√° materi√°ln√≠ vyv√°≈æenost (pozitivn√≠ = v√Ωhoda b√≠l√©ho)""""""
        balance = 0
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece != '' and piece.lower() != 'k':  # Ignoruj kr√°le
                    balance += self.piece_values.get(piece, 0)
        return balance
    
    def evaluate_position(self) -> int:
        """"""Ohodnot√≠ pozici s lep≈°√≠m rozli≈°en√≠m koncov√Ωch pozic""""""
        # Rychl√° kontrola matu/patu p≈ôed materi√°ln√≠m hodnocen√≠m
        if self.is_checkmate():
            if self.white_to_move:  # B√≠l√Ω v matu -> ƒçern√Ω vyhr√°l
                return -999999
            else:  # ƒåern√Ω v matu -> b√≠l√Ω vyhr√°l
                return 999999
                
        elif self.is_stalemate():
            # Pat: ve v√≠tƒõzn√© pozici je to ne√∫spƒõch
            material_balance = self.get_material_balance()
            if material_balance > 300:  # B√≠l√Ω m√° v√Ωhodu -> pat je velmi ≈°patn√Ω
                return -10000  
            elif material_balance < -300:  # ƒåern√Ω m√° v√Ωhodu -> pat je velmi dobr√Ω pro b√≠l√©ho
                return 10000
            else:
                return 0  # Vyrovnan√° pozice
        
        # Materi√°ln√≠ hodnocen√≠
        score = self.get_material_balance()
        
        # Bonus pro pokroƒçil√© koncovky - motivace k matu
        if abs(score) > 500:  # V√Ωznamn√° materi√°ln√≠ v√Ωhoda
            # Penalty za vzd√°lenost kr√°l≈Ø (v koncovce chceme kr√°le bl√≠zko)
            white_king = self.find_king(True)
            black_king = self.find_king(False)
            
            if white_king != (-1, -1) and black_king != (-1, -1):
                king_distance = abs(white_king[0] - black_king[0]) + abs(white_king[1] - black_king[1])
                if score > 0:  # B√≠l√Ω vede
                    score -= king_distance * 10  # Penalty za vzd√°len√© kr√°le
                else:  # ƒåern√Ω vede
                    score += king_distance * 10
        
        return score
    
    def is_checkmate(self) -> bool:
        """"""Zjist√≠, zda je mat""""""
        if not self.is_in_check(self.white_to_move):
            return False
        
        legal_moves = self.get_all_legal_moves()
        return len(legal_moves) == 0
    
    def is_stalemate(self) -> bool:
        """"""Zjist√≠, zda je pat""""""
        if self.is_in_check(self.white_to_move):
            return False
        
        legal_moves = self.get_all_legal_moves()
        return len(legal_moves) == 0
    
    def is_game_over(self) -> Tuple[bool, str]:
        """"""Zjist√≠, zda je hra u konce""""""
        if self.is_checkmate():
            winner = ""ƒåern√Ω"" if self.white_to_move else ""B√≠l√Ω""
            return True, f""Mat! Vyhr√°l {winner}.""
        elif self.is_stalemate():
            return True, ""Pat! Rem√≠za.""
        elif self.halfmove_clock >= 100:
            return True, ""Rem√≠za podle pravidla 50 tah≈Ø.""
        
        return False, """"
    
    def minimax(self, depth: int, alpha: int, beta: int, maximizing: bool, 
                path: List[str]) -> Tuple[int, List[str]]:
        """"""Minimax algoritmus s alfa-beta pruningem - OPRAVENO PRO MAT""""""
        
        # Kontrola konce hry
        if self.is_checkmate():
            # Mat: kdo vyhr√°l?
            if self.white_to_move:  # B√≠l√Ω je na tahu ale je v matu -> ƒçern√Ω vyhr√°l
                return (-999999 + len(path), path)
            else:  # ƒåern√Ω je na tahu ale je v matu -> b√≠l√Ω vyhr√°l  
                return (999999 - len(path), path)
                
        elif self.is_stalemate():
            # NOV√Å LOGIKA: Pat je v≈ædy rem√≠za, ale ve v√≠tƒõzn√© pozici je to selh√°n√≠
            material_balance = self.get_material_balance()
            
            if material_balance > 300:  # B√≠l√Ω m√° v√Ωraznou v√Ωhodu
                return (-10000, path)  # Pat ve v√≠tƒõzn√© pozici je velmi ≈°patn√Ω pro b√≠l√©ho
            elif material_balance < -300:  # ƒåern√Ω m√° v√Ωraznou v√Ωhodu  
                return (10000, path)   # Pat ve v√≠tƒõzn√© pozici je velmi ≈°patn√Ω pro ƒçern√©ho
            else:
                return (0, path)  # Vyrovnan√° pozice -> pat je OK
                
        elif self.halfmove_clock >= 100:
            return (0, path)
        
        if depth == 0:
            return (self.evaluate_position(), path)
        
        legal_moves = self.get_all_legal_moves()
        
        if maximizing:
            max_eval = float('-inf')
            best_path = path
            
            for move in legal_moves:
                # Ulo≈æ stav
                original_state = self.save_state()
                
                # Proveƒè tah
                self.make_move(move[0], move[1])
                move_notation = f""{chr(ord('a') + move[0][1])}{8 - move[0][0]}-{chr(ord('a') + move[1][1])}{8 - move[1][0]}""
                new_path = path + [move_notation]
                
                eval_score, eval_path = self.minimax(depth - 1, alpha, beta, False, new_path)
                
                if eval_score > max_eval:
                    max_eval = eval_score
                    best_path = eval_path
                
                # Vra≈• stav
                self.restore_state(original_state)
                
                alpha = max(alpha, eval_score)
                if beta <= alpha:
                    break
            
            return (max_eval, best_path)
        
        else:
            min_eval = float('inf')
            best_path = path
            
            for move in legal_moves:
                # Ulo≈æ stav
                original_state = self.save_state()
                
                # Proveƒè tah
                self.make_move(move[0], move[1])
                move_notation = f""{chr(ord('a') + move[0][1])}{8 - move[0][0]}-{chr(ord('a') + move[1][1])}{8 - move[1][0]}""
                new_path = path + [move_notation]
                
                eval_score, eval_path = self.minimax(depth - 1, alpha, beta, True, new_path)
                
                if eval_score < min_eval:
                    min_eval = eval_score
                    best_path = eval_path
                
                # Vra≈• stav
                self.restore_state(original_state)
                
                beta = min(beta, eval_score)
                if beta <= alpha:
                    break
            
            return (min_eval, best_path)
    
    def find_best_move(self, max_depth: int = 10) -> Tuple[Optional[List[str]], int]:
        """"""Najde nejlep≈°√≠ tah pomoc√≠ iterativn√≠ho prohlouben√≠""""""
        print(f""Hled√°n√≠ nejlep≈°√≠ho tahu (maxim√°ln√≠ hloubka: {max_depth})..."")
        print(f""Na tahu: {'B√≠l√Ω' if self.white_to_move else 'ƒåern√Ω'}"")
        
        # Zkontroluj materi√°ln√≠ situaci
        material_balance = self.get_material_balance()
        if material_balance > 300:
            print(f""B√≠l√Ω m√° materi√°ln√≠ v√Ωhodu ({material_balance} bod≈Ø) - hled√°m mat!"")
        elif material_balance < -300:
            print(f""ƒåern√Ω m√° materi√°ln√≠ v√Ωhodu ({-material_balance} bod≈Ø) - br√°n√≠m se!"")
        print()
        
        best_path = None
        best_score = 0
        
        for depth in range(1, max_depth + 1):
            # P≈ôid√°n√≠ ƒçasov√©ho raz√≠tka p≈ôed ka≈ædou hloubku
            current_time = datetime.now().strftime(""%H:%M:%S"")
            
            start_time = time.time()
            
            # OPRAVA: maximizing mus√≠ odpov√≠dat tomu, kdo je na tahu!
            # B√≠l√Ω maximalizuje (+), ƒçern√Ω minimalizuje (-)
            score, path = self.minimax(depth, float('-inf'), float('inf'), self.white_to_move, [])
            
            end_time = time.time()
            elapsed = end_time - start_time
            
            print(f""[{current_time}] Hloubka {depth}: sk√≥re {score}, ƒças {elapsed:.3f}s"")
            
            best_path = path
            best_score = score
            
            # Pokud byl nalezen mat, skonƒçi
            if abs(score) > 900000:
                print(f""Nalezen mat v {len(path)} taz√≠ch!"")
                break
                
            # Pokud je sk√≥re p≈ô√≠li≈° n√≠zk√© ve v√≠tƒõzn√© pozici, pokraƒçuj v hled√°n√≠
            if material_balance > 300 and score < -500:
                print(f""Sk√≥re {score} je p≈ô√≠li≈° n√≠zk√© pro v√≠tƒõznou pozici, pokraƒçujem..."")
        
        return best_path, best_score
    
    def play_game(self, initial_fen: str = None, max_depth: int = 6):
        """"""Spust√≠ hru s automatick√Ωm hran√≠m""""""
        if initial_fen:
            self.load_fen(initial_fen)
        else:
            # Standardn√≠ poƒç√°teƒçn√≠ pozice
            self.load_fen(""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"")
        
        print(""=== ≈†ACHOV√ù ENGINE S NESTANDARDN√çMI FIGURAMI ==="")
        print(""Legenda figur:"")
        print(""A/a = Amazonka (K≈Ø≈à + D√°ma)"")
        print(""C/c = Cyril (K≈Ø≈à + Vƒõ≈æ)"")
        print(""E/e = Eve (K≈Ø≈à + St≈ôelec)"")
        print()
        
        print(""Poƒç√°teƒçn√≠ pozice:"")
        print(f""FEN: {self.to_fen()}"")
        self.print_board()
        
        move_count = 0
        # Historie proveden√Ωch tah≈Ø
        executed_moves = []
        
        while True:
            game_over, result = self.is_game_over()
            if game_over:
                print(result)
                break
            
            move_count += 1
            print(f""\n=== TAH {move_count} ==="")
            
            best_path, score = self.find_best_move(max_depth)
            
            if not best_path:
                print(""≈Ω√°dn√Ω tah nenalezen!"")
                break
            
            # Simuluj celou cestu
            if abs(score) > 900000:
                print(f""\nNalezen√° cesta k matu ({len(best_path)} tah≈Ø):"")
            elif abs(score) > 5000:
                print(f""\nNalezen√° siln√° cesta ({len(best_path)} tah≈Ø):"")
            elif abs(score) < -5000:
                print(f""\nVarov√°n√≠: Mo≈æn√Ω pat v {len(best_path)} taz√≠ch!"")
            else:
                print(f""\nNalezen√° cesta ({len(best_path)} tah≈Ø):"")
            
            current_engine = ChessEngine()
            current_engine.restore_state(self.save_state())
            
            # Vyp√≠≈° poƒç√°teƒçn√≠ pozici
            print(f""\nPoƒç√°teƒçn√≠ pozice:"")
            print(f""FEN: {current_engine.to_fen()}"")
            current_engine.print_board()
            
            for i, move_notation in enumerate(best_path):
                # Parsuj a proveƒè tah
                from_pos = (8 - int(move_notation[1]), ord(move_notation[0]) - ord('a'))
                to_pos = (8 - int(move_notation[4]), ord(move_notation[3]) - ord('a'))
                
                if not current_engine.make_move(from_pos, to_pos):
                    print(""Chyba p≈ôi prov√°dƒõn√≠ tahu!"")
                    break
                
                # Teƒè vyp√≠≈° pozici PO proveden√≠ tahu
                print(f""\nTah {i + 1}: {move_notation}"")
                print(f""FEN: {current_engine.to_fen()}"")
                current_engine.print_board()
                
                game_over, result = current_engine.is_game_over()
                if game_over:
                    print(f""{result}"")
                    return
            
            # Proveƒè prvn√≠ tah z nalezen√© cesty
            if best_path:
                first_move = best_path[0]
                from_pos = (8 - int(first_move[1]), ord(first_move[0]) - ord('a'))
                to_pos = (8 - int(first_move[4]), ord(first_move[3]) - ord('a'))
                
                # Zapamatuj si, kdo hraje p≈ôed tahem
                current_player = ""B√≠l√Ω"" if self.white_to_move else ""ƒåern√Ω""
                
                if self.make_move(from_pos, to_pos):
                    # P≈ôidej tah do historie
                    executed_moves.append(first_move)
                    
                    print(f""\nProveden tah: {first_move} ({current_player})"")
                    
                    # Vytiskni celou historii tah≈Ø s ƒç√≠slov√°n√≠m
                    print(f""\nCel√° historie tah≈Ø ({len(executed_moves)} tah≈Ø):"")
                    history_display = []
                    for i, move in enumerate(executed_moves):
                        if i % 2 == 0:  # B√≠l√Ω tah
                            move_number = (i // 2) + 1
                            history_display.append(f""{move_number}.{move}"")
                        else:  # ƒåern√Ω tah
                            history_display.append(move)
                    
                    # Rozdƒõl do ≈ô√°dk≈Ø po 6 taz√≠ch (3 p√°ry)
                    for i in range(0, len(history_display), 6):
                        chunk = history_display[i:i+6]
                        print("" "".join(chunk))
                else:
                    print(""Chyba p≈ôi prov√°dƒõn√≠ prvn√≠ho tahu!"")
                    break
            else:
                break

# Spu≈°tƒõn√≠ enginu
if __name__ == ""__main__"":
    engine = ChessEngine()
    
    # Testovac√≠ pozice - zaj√≠mavƒõj≈°√≠ matov√Ω probl√©m
    # ƒåern√Ω kr√°l v rohu, b√≠l√° Amazonka a kr√°l pro demonstraci s√≠ly Amazonky
    test_fen = ""k7/8/2A5/8/8/8/8/K7 w - - 0 1""
    test_fen = ""7A/8/8/8/8/8/6k1/1K6 w - - 0 1""

    test_fen = ""8/8/8/8/8/5BN1/5K1k/8 b - - 0 1""

    test_fen = ""8/8/8/5N2/8/5B1k/5K2/8 b - - 0 1""

#    test_fen = ""8/8/8/8/A7/4c1k1/8/6K1 w - - 0 1""
    
    print(f""Pou≈æ√≠v√°m testovac√≠ pozici: {test_fen}"")
    print(""Pozice: St≈ôelec na f3, K≈Ø≈à na g3, B√≠l√Ω kr√°l na f2, ƒåern√Ω kr√°l na h2"")
    engine.play_game(test_fen, max_depth=9)"
zVhMbQ7t,Untitled,alex91ckua,CSS,Tuesday 22nd of July 2025 05:06:48 AM CDT,".wcipi-container {
    width: 100%;
}"
kCiwcaBb,lua,JohnAlvinJA,Lua,Tuesday 22nd of July 2025 03:38:48 AM CDT,"repeat wait() until game:IsLoaded() and game:FindFirstChild(""CoreGui"") and pcall(function() return game.CoreGui end)
local _function = {
    [""getid""] = function()
        local g = game.GameId
        if not premium then
            if g == 7436755782 then return ""483d639ad74a7814ff1057d68cec56c2"" -- Grow a Garden
            elseif g == 7018190066 then return ""d3a76114c1ea182127b88170b6043d11"" -- Dead Rails
            elseif g == 5750914919 then return ""bfd8ac56165c2caf1eebc5a14ccdb134"" -- Fisch
            elseif g == 6325068386 then return ""a0ad31cf58a8bd98dd82fa1fb648290f"" -- Blue Lock Rivals
            elseif g == 4777817887 then return ""d53370331c9ca16ce3479c3ac6ae5a78"" -- Blade Ball
            elseif g == 994732206 then return ""446a745866c1abf8459657502b7818fc"" -- Blox Fruit
            elseif g == 4658598196 then return ""27394fa4dc9c7268a839f2c98b6a35f7"" -- Attack On Titan Revolution
            elseif g == 6331902150 then return ""0771107275ffabca9221c264306214f9"" -- Forsaken
            elseif g == 7709344486 then return ""4039bc61ee76ab6f5247b15a0ebf5f60"" end -- Steal a Brainrot
        else
            if g == 7436755782 then return ""65c66a87b33565a9dea1a54b798b6b2a"" -- Grow a Garden
            elseif g == 7018190066 then return ""a3e99a8c1a465fc973e7aa0dda0e220c"" -- Dead Rails
            elseif g == 5750914919 then return ""8782b4febedc346da2f704fa97d11601"" -- Fisch
            elseif g == 6325068386 then return ""50ba70185011d66f3ed97e4e7f50bd11"" -- Blue Lock Rivals
            elseif g == 4777817887 then return ""6f48a7a95292a0885256d242900d81fb"" -- Blade Ball
            elseif g == 994732206 then return ""1ba7f8bc6888d119d65cdafbe3d78527"" -- Blox Fruit
            elseif g == 4658598196 then return ""5698b5c40f0217c268e673ef5e7b6581"" -- Attack On Titan Revolution
            elseif g == 6331902150 then return ""811768c852543782f63839177a263d53"" -- Forsaken 
            elseif g == 7709344486 then return ""36bb351f4d722c58af15efcb417b67da"" end -- Steal a Brainrot
        end
    end,
    [""gamename""] = function()
        local g = game.GameId
        if g == 5750914919 then return ""Fisch""
        elseif g == 7018190066 then return ""Dead Rails""
        elseif g == 6325068386 then return ""Blue Lock Rivals""
        elseif g == 4777817887 then return ""Blade Ball""
        elseif g == 7436755782 then return ""Grow a Garden""
        elseif g == 994732206 then return ""Blox Fruit""
        elseif g == 4658598196 then return ""Attack On Titan Revolution""
        elseif g == 6331902150 then return ""Forsaken""
        elseif g == 7709344486 then return ""Steal a Brainrot""
        end
    end,
    [""load""] = function(url)
        local game_url = game:HttpGet(url)
        return (load or loadstring)(game_url)()
    end
}
local script_id, game_name = _function.getid(), _function.gamename()
if script_id then
    game.StarterGui:SetCore(
        ""SendNotification"",
        {
            Title = ""NatHub Loaded!"",
            Text = game_name .. "" Script Loaded!"",
            Icon = ""rbxassetid://99764942615873"",
            Duration = 5
        }
    )
    if premium then
        local auth = _function.load(""https://raw.githubusercontent.com/ArdyBotzz/NatHub/refs/heads/master/keysystem.lua"")
        local auth_status = auth(script_id)
        repeat task.wait() until auth_status.validated
    end
    script_key = script_key
    if premium then premium = true; is_premium = true end
    _function.load(""https://api.luarmor.net/files/v4/loaders/"" .. script_id .. "".lua"")
end"
SpyrxtES,JWT Authentication,elyte5star,Python,Tuesday 22nd of July 2025 03:26:55 AM CDT,"from starlette.status import (
    HTTP_401_UNAUTHORIZED,
    HTTP_403_FORBIDDEN,
    HTTP_404_NOT_FOUND,
)
from starlette.requests import Request
from fastapi.security.utils import get_authorization_scheme_param
from fastapi.openapi.models import HTTPBearer as HTTPBearerModel
from jose import JWTError, jwt
import time
from modules.settings.configuration import ApiConfig
from modules.repository.queries.common import CommonQueries
from modules.security.current_user import JWTPrincipal
from fastapi.security.base import SecurityBase
from fastapi.exceptions import HTTPException
from pydantic import BaseModel, Field


cfg = ApiConfig().from_toml_file().from_env_file()
queries = CommonQueries(cfg)


class JWTPrincipal(BaseModel):
    user_id: str = Field(serialization_alias=""userId"")
    username: str
    email: str
    active: bool
    enabled: bool
    roles: list[str]
    admin: bool
    expires: float
    discount: float
    token_id: str = Field(serialization_alias=""tokenId"")



class JWTBearer(SecurityBase):

    def __init__(
        self,
        scheme_name: str | None = None,
        auto_error: bool = True,
        allowed_roles: list = cfg.roles,
        auth_method: str | None = None,
    ) -> None:
        super().__init__()
        self.auto_error = auto_error
        self.scheme_name = scheme_name or self.__class__.__name__
        self.allowed_roles = allowed_roles
        self.model = HTTPBearerModel(
            description=""Bearer token"",
        )

    async def __call__(self, request: Request) -> JWTPrincipal | None:
        authorization = request.headers.get(""Authorization"", None)
        scheme, token = get_authorization_scheme_param(authorization)
        if not (authorization and scheme and token):
            if self.auto_error:
                raise HTTPException(
                    status_code=HTTP_403_FORBIDDEN, detail=""Not authenticated""
                )
            else:
                return None
        if scheme.lower() != ""bearer"":
            if self.auto_error:
                raise HTTPException(
                    status_code=HTTP_401_UNAUTHORIZED,
                    detail=""Invalid authentication credentials"",
                )
            else:
                return None
        if self.verify_jwt(token) is None:
            if self.auto_error:
                raise HTTPException(
                    status_code=HTTP_401_UNAUTHORIZED,
                    detail=""Invalid token or expired token."",
                    headers={""WWW-Authenticate"": ""Bearer""},
                )
            else:
                return None
        current_user = await self.check_user(self.payload[""userId""])
        return current_user

    async def check_user(self, user_id: str) -> JWTPrincipal:
        db_user = await queries.find_user_by_id(user_id)
        if db_user is None:
            raise HTTPException(
                status_code=HTTP_404_NOT_FOUND,
                detail=""User session not found"",
            )
        roles = [""USER""] if not db_user.admin else [""USER"", ""ADMIN""]
        matches = set(self.allowed_roles).intersection(set(roles))
        if len(matches) == 0:
            raise HTTPException(
                status_code=HTTP_403_FORBIDDEN, detail=""Not enough permissions""
            )
        current_user = JWTPrincipal(
            user_id=self.payload[""userId""],
            email=self.payload[""email""],
            username=self.payload[""sub""],
            active=self.payload[""active""],
            enabled=self.payload[""enabled""],
            expires=self.payload[""exp""],
            admin=self.payload[""admin""],
            roles=self.payload[""roles""],
            discount=self.payload[""discount""],
            token_id=self.payload[""jti""],
        )
        return current_user

    def verify_jwt(self, token: str) -> dict | None:
        if token is None:
            return None
        try:
            self.payload = jwt.decode(
                token,
                cfg.secret_key,
                algorithms=[cfg.algorithm],
            )
            return self.payload if self.payload[""exp""] >= time.time() else None
        except JWTError:
            return None
"
xtvwcwsb,MSAL/Google access token verification,elyte5star,Python,Tuesday 22nd of July 2025 03:16:25 AM CDT,"from typing import cast, Any
from starlette.requests import Request
from modules.settings.configuration import ApiConfig
from fastapi.security.utils import get_authorization_scheme_param
from fastapi.openapi.models import (
    OAuthFlows as OAuthFlowsModel,
)
from fastapi.security.base import SecurityBase
from fastapi.openapi.models import OAuthFlowAuthorizationCode
from starlette.status import (
    HTTP_401_UNAUTHORIZED,
    HTTP_403_FORBIDDEN,
    HTTP_404_NOT_FOUND,
    HTTP_400_BAD_REQUEST,
)
from fastapi.exceptions import HTTPException
from jose import JWTError, jwt
from httpx import AsyncClient, HTTPError, Response
from fastapi.openapi.models import OAuth2 as OAuth2Model
from modules.utils.misc import date_time_now_utc, time_delta
from fastapi.security import SecurityScopes
from datetime import datetime





SCHEME_NAME = ""OAuthorization2CodePKCEBearer""
DESC = ""Authorization code with PKCE ""


class OAuth2CodeBearer(SecurityBase):

    def __init__(
        self,
        authorization_url: str,
        token_url: str,
        auth_method: str,
        scopes: dict[str, str],
        flows: OAuthFlowsModel | dict[str, dict[str, Any]] | None = None,
        scheme_name: str | None = SCHEME_NAME,
        description: str | None = DESC,
        refresh_url: str | None = None,
    ):
        self.auth_method = auth_method

        # ADD MORE OAUTHFLOWS AS NEEDED

        if not flows:
            flows = OAuthFlowsModel(
                authorizationCode=OAuthFlowAuthorizationCode(
                    authorizationUrl=authorization_url,
                    tokenUrl=token_url,
                    refreshUrl=refresh_url,
                    scopes=scopes,
                ),
            )
        self.model = OAuth2Model(
            flows=cast(OAuthFlowsModel, flows), description=description
        )
        self.scheme_name = (
            f""{auth_method.capitalize()}{scheme_name}"" or self.__class__.__name__
        )

        self.auth_method = auth_method
        # A cache for Microsoft public keys {'LOCAL': [], 'MSAL': []}
        self.public_keys_cache: dict[str, list] = {
            method: [] for method in cfg.auth_methods
        }
        self.next_ext_api_call_time: datetime | None = None

    async def __call__(
        self, security_scopes: SecurityScopes, request: Request
    ) -> dict[str, Any] | None:
        authorization = request.headers.get(""Authorization"", None)
        scheme, token = get_authorization_scheme_param(authorization)
        if not (authorization and scheme and token):
            raise HTTPException(
                status_code=HTTP_403_FORBIDDEN, detail=""Not authenticated""
            )
        if scheme.lower() != ""bearer"":
            raise HTTPException(
                status_code=HTTP_401_UNAUTHORIZED,
                detail=""Invalid authentication credentials"",
            )

        if self.auth_method == ""MSAL"":
            verified_claims = await self.verify_msal_jwt(
                token, security_scopes.scopes, self.auth_method
            )
        else:
            verified_claims = await self.verify_google_jwt(
                token,
                security_scopes.scopes,
            )
        return verified_claims

    async def verify_google_jwt(
        self,
        access_token: str,
        required_scopes: list[str],
    ) -> dict:
        if not access_token:
            raise HTTPException(
                status_code=HTTP_401_UNAUTHORIZED,
                detail=""Authorization token missing or invalid"",
            )
        try:
            TOKEN_INFO_URL = cfg.google_token_info_url
            PARAMS = {""access_token"": access_token}
            async with AsyncClient(timeout=10) as client:
                cfg.logger.debug(f""Fetching token info from {TOKEN_INFO_URL}"")
                response: Response = await client.get(
                    TOKEN_INFO_URL,
                    params=PARAMS,
                )
                response.raise_for_status()
                token_info: dict[str, Any] = response.json()
                
            token_info[""scp""] = token_info.pop(""scope"")

            # check scope
            self.validate_scope(token_info, required_scopes)

            # check audience
            if token_info[""aud""] not in cfg.google_client_id:
                raise ValueError(""Could not verify audience."")

            return token_info
        except HTTPError as e:
            raise HTTPException(
                status_code=HTTP_400_BAD_REQUEST,
                detail=""Invalid or expired token"",
            )
        except ValueError as e:
            cfg.logger.error(f""Could not verify audience: {e}"")
            raise HTTPException(
                status_code=HTTP_401_UNAUTHORIZED,
                detail=""Could not verify audience"",
            )
            return None
        except Exception as e:
            cfg.logger.error(f""Internal server error: {str(e)}"")
            raise HTTPException(
                status_code=HTTP_401_UNAUTHORIZED,
                detail=""Token error: Unable to parse authentication"",
            )

    # Validate Azure Entra ID token using Azure AD Public Keys
    async def verify_msal_jwt(
        self, access_token: str, required_scopes: list[str], auth_method: str
    ) -> dict:
        """"""
        This verifies:

        # Scopes

        # Signature using Azure AD‚Äôs public key

        # Expiration (exp)

        # Issuer (iss)

        # Audience (aud)

        """"""
        if not access_token:
            raise HTTPException(
                status_code=HTTP_401_UNAUTHORIZED,
                detail=""Authorization token missing or invalid"",
            )
        try:
            unverified_claims: dict[str, Any] = jwt.get_unverified_claims(
                access_token,
            )

            self.validate_scope(unverified_claims, required_scopes)

            # Get Microsoft's public keys
            public_keys = await self.get_public_keys(
                cfg.msal_jwks_url,
                auth_method,
            )
            # Decode JWT Header to get the key ID (kid)
            token_headers: dict[str, Any] = jwt.get_unverified_header(
                access_token,
            )

            token_kid = token_headers.get(""kid"")

            rsa_key = next(
                (key for key in public_keys if key.get(""kid"") == token_kid), None
            )
            if rsa_key is None:
                raise HTTPException(
                    status_code=HTTP_401_UNAUTHORIZED,
                    detail=""Invalid header error: Unable to find appropriate key"",
                )
            cfg.logger.debug(f""Loading public key: {rsa_key}"")
            claims = jwt.decode(
                access_token,
                key=rsa_key,
                algorithms=[""RS256""],
                audience=cfg.msal_client_id,
                issuer=cfg.msal_issuer,
            )

            return claims
        except HTTPError as e:
            cfg.logger.error(f""HTTP Exception for {e.request.url} - {e}"")
            raise HTTPException(
                status_code=HTTP_404_NOT_FOUND,
                detail=f""HTTP Exception for {e.request.url} - {e}"",
            )
        except JWTError:
            cfg.logger.error(""Invalid token or expired token."")
            raise HTTPException(
                status_code=HTTP_401_UNAUTHORIZED,
                detail=""Invalid token or expired token."",
            )
        except Exception as e:
            cfg.logger.error(f""Internal server error: {str(e)}"")
            raise HTTPException(
                status_code=HTTP_401_UNAUTHORIZED,
                detail=""Token error: Unable to parse authentication"",
            )

    # check if guest user is allowed?
    def validate_scope(self, unverified_claims: dict, required_scopes: list[str]):
        if not required_scopes:
            raise HTTPException(
                status_code=HTTP_403_FORBIDDEN,
                detail=""No required scope specified"",
            )
        # To small letters
        required_scopes = [s.lower() for s in required_scopes]

        has_valid_scope = False

        if (
            unverified_claims.get(""scp"") is None
            and unverified_claims.get(""roles"") is None
        ):
            raise HTTPException(
                status_code=HTTP_403_FORBIDDEN,
                detail=""No scope or app permission (role) claim was found in the bearer token"",
            )

        is_app_permission = (
            True if unverified_claims.get(""roles"") is not None else False
        )

        if is_app_permission:
            roles = unverified_claims.get(""roles"", [])
            if not roles:
                raise HTTPException(
                    status_code=HTTP_403_FORBIDDEN,
                    detail=""No scope or app permission (role) claim was found in the bearer token"",
                )
            else:
                roles = [s.lower() for s in roles]
                matches = set(required_scopes).intersection(set(roles))
                if len(matches) > 0:
                    has_valid_scope = True
        else:
            if unverified_claims.get(""scp""):
                # the scp claim is a space delimited string
                token_scopes = unverified_claims[""scp""].lower().split()
                matches = set(required_scopes).intersection(set(token_scopes))
                if len(matches) > 0:
                    has_valid_scope = True
            else:
                raise HTTPException(
                    status_code=HTTP_403_FORBIDDEN,
                    detail=""No scope or app permission (role) claim was found in the bearer token"",
                )
        if is_app_permission and not has_valid_scope:
            raise HTTPException(
                status_code=HTTP_403_FORBIDDEN, detail=""Not enough permissions""
            )
        elif not has_valid_scope:
            raise HTTPException(
                status_code=HTTP_403_FORBIDDEN, detail=""Not enough permissions""
            )

    async def get_public_keys(
        self, jwks_uri: str, auth_method: str, params: dict | None = None
    ) -> list:
        make_api_call = (
            self.next_ext_api_call_time is None
            or date_time_now_utc() > self.next_ext_api_call_time
        )
        if not self.public_keys_cache[auth_method] or make_api_call:
            async with AsyncClient(timeout=10) as client:
                cfg.logger.debug(f""Fetching public keys from {jwks_uri}"")
                response: Response = await client.get(jwks_uri, params=params)
                response.raise_for_status()  # Raises an error for non-200 responses
                self.public_keys_cache[auth_method] = response.json().get(""keys"", [])
                self.next_ext_api_call_time = date_time_now_utc() + time_delta(
                    minutes=60
                )  # Fetch keys every 1hr
        return self.public_keys_cache[auth_method]
"
PvNJePkN,route_mail.ru,deGoyan,PowerShell,Tuesday 22nd of July 2025 02:14:56 AM CDT,"Resolve-DnsName mail.ru

Name                                           Type   TTL   Section    IPAddress
----                                           ----   ---   -------    ---------
mail.ru                                        A      8     Answer     89.221.239.1
mail.ru                                        A      8     Answer     185.180.201.1
mail.ru                                        A      8     Answer     90.156.232.4

–ö—Ä–∞—Ñ—Ç
sudo traceroute mail.ru -I
traceroute to mail.ru (90.156.232.4), 30 hops max, 60 byte packets
 1  _gateway (10.200.0.1)  0.243 ms  0.260 ms  0.288 ms
 2  62.69.22.142 (62.69.22.142)  0.709 ms *  0.808 ms
 3  213.156.208.190 (213.156.208.190)  4.189 ms  5.829 ms  6.987 ms
 4  cr-sad156.unit50.cr-l147.kraft-s.net (213.156.195.50)  2.691 ms  2.688 ms  2.685 ms
 5  213.156.211.46 (213.156.211.46)  2.799 ms  2.796 ms  2.793 ms
 6  188.254.46.73 (188.254.46.73)  4.840 ms  1.271 ms  1.231 ms
 7  * * *
 8  188.254.44.30 (188.254.44.30)  18.145 ms  18.223 ms  18.215 ms
 9  * * *
10  * * *
11  * * *
12  * * *
13  * * *
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *

sudo traceroute mail.ru -I
traceroute to mail.ru (185.180.201.1), 30 hops max, 60 byte packets
 1  _gateway (10.200.0.1)  0.489 ms  0.506 ms  0.506 ms
 2  62.69.22.142 (62.69.22.142)  0.894 ms * *
 3  * * 213.156.208.190 (213.156.208.190)  3.176 ms
 4  cr-sad156.unit50.cr-l147.kraft-s.net (213.156.195.50)  2.614 ms  2.859 ms  3.113 ms
 5  213.156.211.46 (213.156.211.46)  1.115 ms  1.110 ms  1.125 ms
 6  188.254.46.73 (188.254.46.73)  1.500 ms  0.991 ms  0.984 ms
 7  * * *
 8  188.254.44.30 (188.254.44.30)  18.006 ms  17.994 ms  17.951 ms
 9  * * *
10  * * *
11  * * *
12  * * *
13  * * *
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *

sudo traceroute mail.ru -I
traceroute to mail.ru (89.221.239.1), 30 hops max, 60 byte packets
 1  _gateway (10.200.0.1)  0.339 ms  0.353 ms  0.505 ms
 2  62.69.22.142 (62.69.22.142)  0.786 ms * *
 3  * * *
 4  * * *
 5  213.156.211.46 (213.156.211.46)  0.967 ms * *
 6  188.254.46.73 (188.254.46.73)  3.760 ms * *
 7  * * *
 8  188.254.44.30 (188.254.44.30)  18.735 ms  18.729 ms  18.724 ms
 9  * * *
10  * * *
11  * * *
12  * * *
13  * * *
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *

–ê–≤–∞–Ω—Ç–µ–ª
sudo traceroute mail.ru -I
traceroute to mail.ru (90.156.232.4), 30 hops max, 60 byte packets
 1  _gateway (10.200.0.1)  0.233 ms  0.223 ms  0.250 ms
 2  1.samara.svrv.ru (185.33.202.1)  1.618 ms * *
 3  * * *
 4  * * 10.30.254.149 (10.30.254.149)  0.996 ms
 5  m9-r5.inet2.ru (85.112.122.5)  16.127 ms  16.121 ms  16.115 ms
 6  mailru.w-ix.ru (193.106.112.81)  16.221 ms  15.661 ms  15.633 ms
 7  * * *
 8  * * *
 9  * * *
10  * * *
11  * * *
12  * * *
13  * * *
14  * * *
15  * * *
16  mail.ru (90.156.232.4)  32.362 ms  32.299 ms  32.333 ms

sudo traceroute mail.ru -I
traceroute to mail.ru (89.221.239.1), 30 hops max, 60 byte packets
 1  _gateway (10.200.0.1)  0.245 ms  0.267 ms  0.261 ms
 2  1.samara.svrv.ru (185.33.202.1)  1.958 ms  1.953 ms  1.965 ms
 3  10.30.254.181 (10.30.254.181)  3.585 ms  3.828 ms  4.002 ms
 4  10.30.254.149 (10.30.254.149)  1.082 ms  1.077 ms  1.888 ms
 5  m9-r5.inet2.ru (85.112.122.5)  14.414 ms  14.468 ms  14.591 ms
 6  mailru.w-ix.ru (193.106.112.81)  14.912 ms  14.282 ms  14.237 ms
 7  * * *
 8  * * *
 9  * * *
10  * * *
11  * * *
12  * * *
13  * * *
14  * * *
15  * * *
16  * * *
17  * * *
18  mail.ru (89.221.239.1)  22.075 ms  22.069 ms  22.128 ms

sudo traceroute mail.ru -I
traceroute to mail.ru (185.180.201.1), 30 hops max, 60 byte packets
 1  _gateway (10.200.0.1)  0.376 ms  0.364 ms *
 2  * * *
 3  * * *
 4  10.30.254.149 (10.30.254.149)  1.100 ms * *
 5  m9-r5.inet2.ru (85.112.122.5)  14.994 ms * *
 6  mailru.w-ix.ru (193.106.112.81)  14.512 ms  15.185 ms  15.338 ms
 7  * * *
 8  * * *
 9  * * *
10  * * *
11  * * *
12  * * *
13  * * *
14  * * *
15  * * *
16  * * *
17  * * mail.ru (185.180.201.1)  20.658 ms
"
ZKVQxyXg,Untitled,chemelli74,Python,Tuesday 22nd of July 2025 01:55:41 AM CDT,"We need your help!


In order to make Alexa Devices work for all you, we need to verify that your Country doesn't need special settings.
For this reason if you are not currently able to setup the integration, I would ask you to follow the following steps:

- Which is the URL of the Amazon main site you usually browse?

- From a browser page that is authenticated to Amazon, please navigate to https://alexa.amazon.{your main domain}/api/users/me (e.g. https://alexa.amazon.it/api/users/me) and report back: 

- countryOfResidence ( at the beginning ) 
- marketPlaceDomainName (at the end) 
- marketPlaceLocale ( at the end )

Then make a post with the following info:

- Country selected for the integration setup:
- URL of main browsed Amazon site:
- API countryOfResidence:
- API marketPlaceDomainName:
- API marketPlaceLocale:"
AdxQ4Jpf,2025-07-22T08:31:33.218982,powerampache,PHP,Tuesday 22nd of July 2025 01:31:32 AM CDT,"1.01-78 (78) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
ECbjdvNz,Java JDK Tool Delphi version source code,LAUDA937,Pascal,Tuesday 22nd of July 2025 01:03:49 AM CDT,"// Java JDK (system environment variable one-click setting tool) Delphi version source code is here

unit Unit2;
 
interface
 
uses
  Registry, Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.StdCtrls;
 
type
  TForm2 = class(TForm)
    btnSetEnv: TButton;
    btnVerify: TButton;
    edtJdkPath: TEdit;
    lblStatus: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure btnSetEnvClick(Sender: TObject);
    procedure btnVerifyClick(Sender: TObject);
  private
    function SetJavaEnvironment(const JdkPath: string): Boolean;
  public
    { Public declarations }
  end;
 
our
  Form2: TForm2;
 
implementation
 
{$R *.dfm}
 
// Core function: set Java environment variables
function TForm2.SetJavaEnvironment(const JdkPath: string): Boolean;
our
  Reg: TRegistry;
  PathValue: string;
begin
  Result := False;
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
 
    // 1. Set JAVA_HOME
    if Reg.OpenKey('SYSTEM\CurrentControlSet\Control\Session Manager\Environment', True) then
    begin
      Reg.WriteString('JAVA_HOME', JdkPath);
      Reg.CloseKey;
    end;
 
    // 2. Update PATH
    if Reg.OpenKey('SYSTEM\CurrentControlSet\Control\Session Manager\Environment', False) then
    begin
      PathValue := Reg.ReadString('Path');
      if Pos(JdkPath + 'bin', PathValue) = 0 then
      begin
        PathValue := JdkPath + 'bin;' + PathValue;
        Reg.WriteString('Path', PathValue);
      end;
      Reg.CloseKey;
    end;
 
    // Broadcast environment variable change notification
    SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, LPARAM(PChar('Environment')), SMTO_ABORTIFHUNG, 5000, nil);
 
    Result := True;
  except
    on E: Exception do
      lblStatus.Caption := 'Error:' + E.Message;
  end;
  Reg.Free;
end;
 
 
 
// Set environment variables
procedure TForm2.btnSetEnvClick(Sender: TObject);
begin
  was JdkPath: string;
  begin
    JdkPath := IncludeTrailingPathDelimiter(edtJdkPath.Text);
 
    if not DirectoryExists(JdkPath) then
    begin
      lblStatus.Caption := 'Error: JDK path does not exist! ';
      Exit;
    end;
 
    if not FileExists(JdkPath + 'bin\java.exe') then
    begin
      lblStatus.Caption := 'Error: java.exe not found';
      Exit;
    end;
 
    if SetJavaEnvironment(JdkPath) then
      lblStatus.Caption := 'Success: Environment variables have been set. Please restart the command line tool to verify.'
    else
      lblStatus.Caption := 'Error: Setting failed! ';
  end;
end;
 
// Verify Java installation
procedure TForm2.btnVerifyClick(Sender: TObject);
begin
  //winexec(PAnsiChar(AnsiString('cmd.exe /c java -version')), sw_hide);
  WinExec('cmd.exe /k java -version', SW_SHOWNORMAL);
end;
 
procedure TForm2.FormCreate(Sender: TObject);
begin
  edtJdkPath.Text := 'X:\jdk-11';
end;
 
end."
1UaFgUPS,2025-07-22T01:33:28.804677,powerampache,PHP,Tuesday 22nd of July 2025 12:33:27 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 56870) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

getAlbumsStats() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 56870) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 56870) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
1QQv2RT5,2025-07-22T01:33:28.796786,powerampache,PHP,Tuesday 22nd of July 2025 12:33:27 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 56854) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

getAlbumsStats() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 56854) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 56854) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
UBwHQ4sU,2025-07-22T01:33:13.790884,powerampache,PHP,Tuesday 22nd of July 2025 12:33:12 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39746) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

getAlbumsStats() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39746) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39746) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
WKLdGjbE,2025-07-22T01:33:13.785517,powerampache,PHP,Tuesday 22nd of July 2025 12:33:12 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39756) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

getAlbumsStats() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39756) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39756) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
GTpG3tDc,2025-07-22T01:33:13.792179,powerampache,PHP,Tuesday 22nd of July 2025 12:33:12 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39770) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

getAlbumsStats() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39770) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39770) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
YuEqiitf,2025-07-22T01:33:13.781435,powerampache,PHP,Tuesday 22nd of July 2025 12:33:12 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39754) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

getAlbumsStats() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39754) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39754) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
E6A3v1jM,2025-07-22T01:33:13.771046,powerampache,PHP,Tuesday 22nd of July 2025 12:33:12 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39736) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

getGenres() - cannot load data HttpException {""code"":404,""message"":""{ \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39736) after 15000ms\"" }"",""detailMessage"":""HTTP 404 { \""exception\"" : \""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39736) after 15000ms\"" }"",""stackTrace"":[],""suppressedExceptions"":[]}"
KpxHiWmU,2025-07-22T01:32:58.344491,powerampache,PHP,Tuesday 22nd of July 2025 12:32:57 AM CDT,"1.01-79 (79) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to /100.115.221.93 (port 90) from /100.70.169.51 (port 39070) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

"
sACDubyi,22-7-2025,sidrs,MySQL,Monday 21st of July 2025 10:59:19 PM CDT,"student@student:~$ sudo mysql
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 10
Server version: 8.0.42-0ubuntu0.22.04.1 (Ubuntu)

Copyright (c) 2000, 2025, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> USE TCB53;
Database changed

mysql> CREATE TABLE EmployeeInfo
    -> (id int(5), name varchar(50), post varchar(50), salary int(5));
Query OK, 0 rows affected, 2 warnings (0.78 sec)

mysql> INSERT INTO EmployeeInfo (id, name, post, salary) VALUES
    -> (1, 'Alice Johnson', 'Software Engineer', 75000),
    -> (2, 'Bob Smith', 'QA Engineer', 68000),
    -> (3, 'Cathy Williams', 'Software Engineer', 75000),
    -> (4, 'David Brown', 'UI/UX Designer', 72000),
    -> (5, 'Ella Davis', 'Project Manager', 90000),
    -> (6, 'Frank Wilson', 'Backend Developer', 77000),
    -> (7, 'Grace Lee', 'Frontend Developer', 76000),
    -> (8, 'Henry Clark', 'Software Engineer', 75000),
    -> (9, 'Ivy Lewis', 'QA Engineer', 68000),
    -> (10, 'Jake Hall', 'Intern', 30000),
    -> (11, 'Karen Young', 'Project Manager', 90000),
    -> (12, 'Leo King', 'Security Analyst', 85000),
    -> (13, 'Mona Scott', 'Full Stack Developer', 82000),
    -> (14, 'Nathan Adams', 'Scrum Master', 88000),
    -> (15, 'Olivia Baker', 'Frontend Developer', 76000),
    -> (16, 'Paul Turner', 'Cloud Architect', 98000),
    -> (17, 'Queenie Allen', 'Machine Learning Engineer', 97000),
    -> (18, 'Robert Hill', 'Backend Developer', 77000),
    -> (19, 'Sara Green', 'QA Engineer', 68000),
    -> (20, 'Tom Wright', 'Support Engineer', 65000);
Query OK, 20 rows affected (0.20 sec)
Records: 20  Duplicates: 0  Warnings: 0

mysql> DESC EmployeeInfo;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| id     | int         | YES  |     | NULL    |       |
| name   | varchar(50) | YES  |     | NULL    |       |
| post   | varchar(50) | YES  |     | NULL    |       |
| salary | int         | YES  |     | NULL    |       |
+--------+-------------+------+-----+---------+-------+
4 rows in set (0.48 sec)

mysql> SELECT * FROM EmployeeInfo;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   19 | Sara Green     | QA Engineer               |  68000 |
|   20 | Tom Wright     | Support Engineer          |  65000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> DELETE FROM EmployeeInfo WHERE id = 19
    -> ;
Query OK, 1 row affected (0.09 sec)

mysql> SELECT * FROM EmployeeInfo
    -> ;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   20 | Tom Wright     | Support Engineer          |  65000 |
+------+----------------+---------------------------+--------+
19 rows in set (0.00 sec)

mysql> INSERT INTO EmployeeInfo(id, name, post, salaray) VALUES (19, John Doe, Intern, 30000);
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'Doe, Intern, 30000)' at line 1

mysql> INSERT INTO EmployeeInfo(id, name, post, salary) VALUES(19, 'John Doe', 'Intern', 30000);
Query OK, 1 row affected (0.06 sec)

mysql> SELECT * FROM EmployeeInfo
    -> ;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   20 | Tom Wright     | Support Engineer          |  65000 |
|   19 | John Doe       | Intern                    |  30000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> SELECT * FROM EmployeeInfo
    -> ;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   20 | Tom Wright     | Support Engineer          |  65000 |
|   19 | John Doe       | Intern                    |  30000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> SELECT * FROM EmployeeInfo;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   20 | Tom Wright     | Support Engineer          |  65000 |
|   19 | John Doe       | Intern                    |  30000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> SELECT * FROM EmployeeInfo;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   20 | Tom Wright     | Support Engineer          |  65000 |
|   19 | John Doe       | Intern                    |  30000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> UPDATE EmployeeInfo SET id = 19 WHERE name = 'Tom Wright';
Query OK, 1 row affected (0.06 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM EmployeeInfo;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   19 | Tom Wright     | Support Engineer          |  65000 |
|   19 | John Doe       | Intern                    |  30000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> UPDATE EmployeeInfo SET id = 19 WHERE name = 'John Doe';
Query OK, 0 rows affected (0.00 sec)
Rows matched: 1  Changed: 0  Warnings: 0

mysql> SELECT * FROM EmployeeInfo;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   19 | Tom Wright     | Support Engineer          |  65000 |
|   19 | John Doe       | Intern                    |  30000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> UPDATE EmployeeInfo SET id = 20 WHERE name = 'John Doe';
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM EmployeeInfo;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   19 | Tom Wright     | Support Engineer          |  65000 |
|   20 | John Doe       | Intern                    |  30000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> INSERT INTO EmployeeInfo (id, name, post, salary) VALUES (21, 'James L', 'Jr. Engineer', 35000);
Query OK, 1 row affected (0.06 sec)

mysql> SELECT * FROM EmployeeInfo;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   19 | Tom Wright     | Support Engineer          |  65000 |
|   20 | John Doe       | Intern                    |  30000 |
|   21 | James L        | Jr. Engineer              |  35000 |
+------+----------------+---------------------------+--------+
21 rows in set (0.00 sec)

mysql> DELETE FROM EmployeeInfo WHERE id = '21'
    -> ;
Query OK, 1 row affected (0.14 sec)

mysql> SELECT * FROM EmployeeInfo;
+------+----------------+---------------------------+--------+
| id   | name           | post                      | salary |
+------+----------------+---------------------------+--------+
|    1 | Alice Johnson  | Software Engineer         |  75000 |
|    2 | Bob Smith      | QA Engineer               |  68000 |
|    3 | Cathy Williams | Software Engineer         |  75000 |
|    4 | David Brown    | UI/UX Designer            |  72000 |
|    5 | Ella Davis     | Project Manager           |  90000 |
|    6 | Frank Wilson   | Backend Developer         |  77000 |
|    7 | Grace Lee      | Frontend Developer        |  76000 |
|    8 | Henry Clark    | Software Engineer         |  75000 |
|    9 | Ivy Lewis      | QA Engineer               |  68000 |
|   10 | Jake Hall      | Intern                    |  30000 |
|   11 | Karen Young    | Project Manager           |  90000 |
|   12 | Leo King       | Security Analyst          |  85000 |
|   13 | Mona Scott     | Full Stack Developer      |  82000 |
|   14 | Nathan Adams   | Scrum Master              |  88000 |
|   15 | Olivia Baker   | Frontend Developer        |  76000 |
|   16 | Paul Turner    | Cloud Architect           |  98000 |
|   17 | Queenie Allen  | Machine Learning Engineer |  97000 |
|   18 | Robert Hill    | Backend Developer         |  77000 |
|   19 | Tom Wright     | Support Engineer          |  65000 |
|   20 | John Doe       | Intern                    |  30000 |
+------+----------------+---------------------------+--------+
20 rows in set (0.00 sec)

mysql> CREATE TABLE Departments (
    -> depid INT,
    -> dept varchar(50)
    -> );
Query OK, 0 rows affected (4.47 sec)

mysql> DESC TABLE Departments;
+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table       | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | Departments | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.59 sec)

mysql> DESC Departments;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| depid | int         | YES  |     | NULL    |       |
| dept  | varchar(50) | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.23 sec)

mysql> clear

mysql> INSERT INTO Departments (depid, dept) VALUES (1, 'Engineering'), (2, 'Human Resources'), (3, 'Product'), (4, 'Support');
Query OK, 4 rows affected (0.24 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM Departments
    -> ;
+-------+-----------------+
| depid | dept            |
+-------+-----------------+
|     1 | Engineering     |
|     2 | Human Resources |
|     3 | Product         |
|     4 | Support         |
+-------+-----------------+
4 rows in set (0.00 sec)

mysql> SELECT e.name, e.post, d.dept
    -> FROM EmployeeInfo e
    -> CROSS JOIN Departments d;
+----------------+---------------------------+-----------------+
| name           | post                      | dept            |
+----------------+---------------------------+-----------------+
| Alice Johnson  | Software Engineer         | Support         |
| Alice Johnson  | Software Engineer         | Product         |
| Alice Johnson  | Software Engineer         | Human Resources |
| Alice Johnson  | Software Engineer         | Engineering     |
| Bob Smith      | QA Engineer               | Support         |
| Bob Smith      | QA Engineer               | Product         |
| Bob Smith      | QA Engineer               | Human Resources |
| Bob Smith      | QA Engineer               | Engineering     |
| Cathy Williams | Software Engineer         | Support         |
| Cathy Williams | Software Engineer         | Product         |
| Cathy Williams | Software Engineer         | Human Resources |
| Cathy Williams | Software Engineer         | Engineering     |
| David Brown    | UI/UX Designer            | Support         |
| David Brown    | UI/UX Designer            | Product         |
| David Brown    | UI/UX Designer            | Human Resources |
| David Brown    | UI/UX Designer            | Engineering     |
| Ella Davis     | Project Manager           | Support         |
| Ella Davis     | Project Manager           | Product         |
| Ella Davis     | Project Manager           | Human Resources |
| Ella Davis     | Project Manager           | Engineering     |
| Frank Wilson   | Backend Developer         | Support         |
| Frank Wilson   | Backend Developer         | Product         |
| Frank Wilson   | Backend Developer         | Human Resources |
| Frank Wilson   | Backend Developer         | Engineering     |
| Grace Lee      | Frontend Developer        | Support         |
| Grace Lee      | Frontend Developer        | Product         |
| Grace Lee      | Frontend Developer        | Human Resources |
| Grace Lee      | Frontend Developer        | Engineering     |
| Henry Clark    | Software Engineer         | Support         |
| Henry Clark    | Software Engineer         | Product         |
| Henry Clark    | Software Engineer         | Human Resources |
| Henry Clark    | Software Engineer         | Engineering     |
| Ivy Lewis      | QA Engineer               | Support         |
| Ivy Lewis      | QA Engineer               | Product         |
| Ivy Lewis      | QA Engineer               | Human Resources |
| Ivy Lewis      | QA Engineer               | Engineering     |
| Jake Hall      | Intern                    | Support         |
| Jake Hall      | Intern                    | Product         |
| Jake Hall      | Intern                    | Human Resources |
| Jake Hall      | Intern                    | Engineering     |
| Karen Young    | Project Manager           | Support         |
| Karen Young    | Project Manager           | Product         |
| Karen Young    | Project Manager           | Human Resources |
| Karen Young    | Project Manager           | Engineering     |
| Leo King       | Security Analyst          | Support         |
| Leo King       | Security Analyst          | Product         |
| Leo King       | Security Analyst          | Human Resources |
| Leo King       | Security Analyst          | Engineering     |
| Mona Scott     | Full Stack Developer      | Support         |
| Mona Scott     | Full Stack Developer      | Product         |
| Mona Scott     | Full Stack Developer      | Human Resources |
| Mona Scott     | Full Stack Developer      | Engineering     |
| Nathan Adams   | Scrum Master              | Support         |
| Nathan Adams   | Scrum Master              | Product         |
| Nathan Adams   | Scrum Master              | Human Resources |
| Nathan Adams   | Scrum Master              | Engineering     |
| Olivia Baker   | Frontend Developer        | Support         |
| Olivia Baker   | Frontend Developer        | Product         |
| Olivia Baker   | Frontend Developer        | Human Resources |
| Olivia Baker   | Frontend Developer        | Engineering     |
| Paul Turner    | Cloud Architect           | Support         |
| Paul Turner    | Cloud Architect           | Product         |
| Paul Turner    | Cloud Architect           | Human Resources |
| Paul Turner    | Cloud Architect           | Engineering     |
| Queenie Allen  | Machine Learning Engineer | Support         |
| Queenie Allen  | Machine Learning Engineer | Product         |
| Queenie Allen  | Machine Learning Engineer | Human Resources |
| Queenie Allen  | Machine Learning Engineer | Engineering     |
| Robert Hill    | Backend Developer         | Support         |
| Robert Hill    | Backend Developer         | Product         |
| Robert Hill    | Backend Developer         | Human Resources |
| Robert Hill    | Backend Developer         | Engineering     |
| Tom Wright     | Support Engineer          | Support         |
| Tom Wright     | Support Engineer          | Product         |
| Tom Wright     | Support Engineer          | Human Resources |
| Tom Wright     | Support Engineer          | Engineering     |
| John Doe       | Intern                    | Support         |
| John Doe       | Intern                    | Product         |
| John Doe       | Intern                    | Human Resources |
| John Doe       | Intern                    | Engineering     |
+----------------+---------------------------+-----------------+
80 rows in set (0.03 sec)

mysql> CREATE VIEW NoSalary AS
    -> SELECT id, name, post FROM EmployeeInfo;
Query OK, 0 rows affected (0.18 sec)

mysql> Select * FROM NoSalary'
    '> ^C
mysql> Select * FROM NoSalary;
+------+----------------+---------------------------+
| id   | name           | post                      |
+------+----------------+---------------------------+
|    1 | Alice Johnson  | Software Engineer         |
|    2 | Bob Smith      | QA Engineer               |
|    3 | Cathy Williams | Software Engineer         |
|    4 | David Brown    | UI/UX Designer            |
|    5 | Ella Davis     | Project Manager           |
|    6 | Frank Wilson   | Backend Developer         |
|    7 | Grace Lee      | Frontend Developer        |
|    8 | Henry Clark    | Software Engineer         |
|    9 | Ivy Lewis      | QA Engineer               |
|   10 | Jake Hall      | Intern                    |
|   11 | Karen Young    | Project Manager           |
|   12 | Leo King       | Security Analyst          |
|   13 | Mona Scott     | Full Stack Developer      |
|   14 | Nathan Adams   | Scrum Master              |
|   15 | Olivia Baker   | Frontend Developer        |
|   16 | Paul Turner    | Cloud Architect           |
|   17 | Queenie Allen  | Machine Learning Engineer |
|   18 | Robert Hill    | Backend Developer         |
|   19 | Tom Wright     | Support Engineer          |
|   20 | John Doe       | Intern                    |
+------+----------------+---------------------------+
20 rows in set (0.02 sec)

mysql> SELECT AVG(salary) AS average_salary FROM EmployeeInfo;
+----------------+
| average_salary |
+----------------+
|     74700.0000 |
+----------------+
1 row in set (0.03 sec)

mysql> SELECT AVG(salary) AS average_developer_salary FROM EmployeeInfo WHERE post LIKE '%Developer';
+--------------------------+
| average_developer_salary |
+--------------------------+
|               77600.0000 |
+--------------------------+
1 row in set (0.03 sec)

"
L39zw94N,menu.py,DrAungWinHtut,Python,Monday 21st of July 2025 10:17:32 PM CDT,"import os

while True:
	os.system('cls')
	print('0-Exit')
	print('1-Area')
	print('2-Screen Clear')
	ans = input('Choose 0,1,2: ')
	ans = int(ans)

	if ans == 0:
		print('Bye!')
		exit(0)

	if ans == 1:
		r = input('enter r: ')
		r = float(r)
		a = 3.14 * r * r 
		print(f'area = {a} for radius = {r}')

	if ans == 2:
		os.system('cls')

	os.system('pause')"
WR6pDRAm,show real excerpt on archive page,arie_cristianD,PHP,Monday 21st of July 2025 09:54:09 PM CDT,"add_filter( 'jnews_module_excerpt', 'customize_jnews_excerpt_on_archive', 99, 4 );

function customize_jnews_excerpt_on_archive( $excerpt, $post_id, $excerpt_length, $except_more ) {
	$post = get_post( $post_id );
	if ( is_archive() ) {
		$new_excerpt = $post->post_excerpt;
		if ( ! empty( $new_excerpt ) ) {
			$excerpt = $new_excerpt;
		}
	}
	return $excerpt;
}"
U3DqkcNK,Setup Initialization rev_02,pleasedontcode,Arduino,Monday 21st of July 2025 08:13:38 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Setup Initialization
	- Source Code NOT compiled for: Arduino Nano ESP32
	- Source Code created on: 2025-07-22 01:12:29

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* ŸÇŸÖ ÿ®ÿ™ŸÖŸÉŸäŸÜ ÿßÿ™ÿµÿßŸÑ Wi-Fi ÿπŸÑŸâ Arduino Nano ESP32 */
	/* ŸÑŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿπŸÜ ÿ®ÿπÿØ ŸàŸÜŸÇŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.  ÿßŸäÿ∂ÿß ÿ™ÿ¥ÿ∫ŸäŸÑ */
	/* ÿ¥ÿßÿ¥Ÿá ŸàŸÑŸàÿ±ÿß Ÿàÿ®ÿ∑ÿßŸÇŸá ÿ∞ÿßŸÉÿ±ŸáŸàÿ¥ÿßÿ¥Ÿá nextion 5in  ŸàŸÖŸáÿßŸÖ */
	/* ÿ®ÿ≠ÿßÿ¨Ÿá ŸÑÿ™ŸÅÿµŸäŸÑ ŸàÿÆÿµŸàÿµÿß ÿßÿ≤ÿ±ÿßÿ± ÿßŸÑÿ¥ÿßÿ¥Ÿá */
/****** SYSTEM REQUIREMENT 2 *****/
	/* ÿ™ŸÜŸÅŸäÿ∞ ÿßÿ™ÿµÿßŸÑÿßÿ™ Wi-Fi ŸàŸàÿßÿ¨Ÿáÿ© ÿπÿ±ÿ∂ Nextion Ÿàÿ™ÿÆÿ≤ŸäŸÜ */
	/* ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿπŸÑŸâ ÿ®ÿ∑ÿßŸÇÿ© SD ŸÑÿ£ÿ™ŸÖÿ™ÿ© ÿ•ŸÜÿ™ÿ±ŸÜÿ™ ÿßŸÑÿ£ÿ¥Ÿäÿßÿ°. */
/****** END SYSTEM REQUIREMENTS *****/


/********* User code review feedback **********
#### Feedback 1 ####
- Users\user\Documents\Arduino\libraries\ITEADLIB_Arduino_Nextion-
master\NexUpload.cpp:17:10: fatal error: SoftwareSerial.h: No su
ch file or directory
   17 | #include <SoftwareSerial.h>
      |
          ^~~~~~~~~~~~~~~~~~
compilation terminated.
Alternative
s for SoftwareSerial.h: []
ResolveLibrary(So
********* User code review feedback **********/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
#include <WiFi.h>
#include <SD.h>
#include <SPI.h>
// #include <Nextion.h> // Removed, as no library is used for Nextion communication

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void sendNextionCommand(const String& cmd);
void setup_wifi(void);
void readNextion(); // Optional, if needed

// Wi-Fi credentials
const char* ssid = ""Your_SSID"";         // Replace with your Wi-Fi network SSID
const char* password = ""Your_PASSWORD""; // Replace with your Wi-Fi password

// Nextion Display Serial connection
#define nexSerial Serial2 // Using Serial2 for Nextion
// If your hardware setup differs, adjust accordingly

// SD card chip select pin
const int chipSelect = 5; // GPIO5, adjust if necessary

// No specific Nextion object instantiation needed unless using a library
// We'll use the Serial2 directly for communication

void setup_wifi() {
  delay(100);
  Serial.println();
  Serial.print(""Connecting to WiFi: "");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  int retries = 0;
  while (WiFi.status() != WL_CONNECTED && retries < 20) {
    delay(500);
    Serial.print(""."");
    retries++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.println(""WiFi connected"");
    Serial.print(""IP address: "");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println();
    Serial.println(""Failed to connect WiFi"");
  }
}

void setup(void) {
  Serial.begin(115200); // Serial for debugging
  nexSerial.begin(9600); // Nextion display baud rate

  // Initialize Wi-Fi
  setup_wifi();

  // Initialize SD card
  if (!SD.begin(chipSelect)) {
    Serial.println(""Card Mount Failed"");
    // Handle error if necessary
  } else {
    Serial.println(""SD card initialized"");
    // Optionally, read/write data
  }

  // Initialize Nextion display
  // Send initial 3 bytes to start communication
  nexSerial.write(0xFF);
  nexSerial.write(0xFF);
  nexSerial.write(0xFF);
  // Add any further initialization commands here if needed
}

void loop(void) {
  // Handle Wi-Fi, display, and storage tasks
  // For demonstration, display Wi-Fi status on Nextion
  static unsigned long lastUpdate = 0;
  if (millis() - lastUpdate > 5000) { // Update every 5 seconds
    lastUpdate = millis();

    String statusText;
    if (WiFi.status() == WL_CONNECTED) {
      statusText = ""WiFi: Connected"";
    } else {
      statusText = ""WiFi: Disconnected"";
    }

    // Send status to Nextion
    // Assuming there's a text component with object ID 't0'
    // Format command: t0.txt=""Status""
    String cmd = ""t0.txt=\"""" + statusText + ""\"""";
    sendNextionCommand(cmd);
  }

  // Example: Read and process Nextion events if needed
  // For simplicity, omitted here

  // Additional code for handling button presses, data transfer, etc.
}

// Helper function to send commands to Nextion
void sendNextionCommand(const String& cmd) {
  String command = cmd + ""\xFF\xFF\xFF""; // Append 3 terminator bytes
  nexSerial.print(command);
}

// Optional: Function to read from Nextion if necessary
void readNextion() {
  while (nexSerial.available()) {
    char c = nexSerial.read();
    // Process incoming data if needed
  }
}
"
9sQd8LDd,Device Setup rev_01,pleasedontcode,Arduino,Monday 21st of July 2025 08:08:58 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Device Setup
	- Source Code NOT compiled for: Arduino Nano ESP32
	- Source Code created on: 2025-07-22 01:08:23

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* ŸÇŸÖ ÿ®ÿ™ŸÖŸÉŸäŸÜ ÿßÿ™ÿµÿßŸÑ Wi-Fi ÿπŸÑŸâ Arduino Nano ESP32 */
	/* ŸÑŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿπŸÜ ÿ®ÿπÿØ ŸàŸÜŸÇŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™.  ÿßŸäÿ∂ÿß ÿ™ÿ¥ÿ∫ŸäŸÑ */
	/* ÿ¥ÿßÿ¥Ÿá ŸàŸÑŸàÿ±ÿß Ÿàÿ®ÿ∑ÿßŸÇŸá ÿ∞ÿßŸÉÿ±ŸáŸàÿ¥ÿßÿ¥Ÿá nextion 5in  ŸàŸÖŸáÿßŸÖ */
	/* ÿ®ÿ≠ÿßÿ¨Ÿá ŸÑÿ™ŸÅÿµŸäŸÑ ŸàÿÆÿµŸàÿµÿß ÿßÿ≤ÿ±ÿßÿ± ÿßŸÑÿ¥ÿßÿ¥Ÿá */
/****** SYSTEM REQUIREMENT 2 *****/
	/* ÿ™ŸÜŸÅŸäÿ∞ ÿßÿ™ÿµÿßŸÑÿßÿ™ Wi-Fi ŸàŸàÿßÿ¨Ÿáÿ© ÿπÿ±ÿ∂ Nextion Ÿàÿ™ÿÆÿ≤ŸäŸÜ */
	/* ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿπŸÑŸâ ÿ®ÿ∑ÿßŸÇÿ© SD ŸÑÿ£ÿ™ŸÖÿ™ÿ© ÿ•ŸÜÿ™ÿ±ŸÜÿ™ ÿßŸÑÿ£ÿ¥Ÿäÿßÿ°. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
#include <WiFi.h>
#include <SD.h>
#include <SPI.h>
#include <Nextion.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);

// Wi-Fi credentials
const char* ssid = ""Your_SSID"";         // Replace with your Wi-Fi network SSID
const char* password = ""Your_PASSWORD""; // Replace with your Wi-Fi password

// Nextion Display Serial connection
#define nexSerial Serial2 // Using Serial2 for Nextion
// If your hardware setup differs, adjust accordingly

// SD card chip select pin
const int chipSelect = 5; // GPIO5, adjust if necessary

// Nextion object
// Assuming Nextion HMI is a 5-inch model connected via Serial2
// The ID numbers are placeholders, adjust according to your Nextion setup
// For example, if you have a button with ID 1, you can control it as shown

// No specific Nextion object instantiation needed unless using a library
// We'll use the Nextion library functions directly

void setup_wifi() {
  delay(100);
  Serial.println();
  Serial.print(""Connecting to WiFi: "");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  int retries = 0;
  while (WiFi.status() != WL_CONNECTED && retries < 20) {
    delay(500);
    Serial.print(""."");
    retries++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.println(""WiFi connected"");
    Serial.print(""IP address: "");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println();
    Serial.println(""Failed to connect WiFi"");
  }
}

void setup(void) {
  Serial.begin(115200); // Serial for debugging
  nexSerial.begin(9600); // Nextion display baud rate

  // Initialize Wi-Fi
  setup_wifi();

  // Initialize SD card
  if (!SD.begin(chipSelect)) {
    Serial.println(""Card Mount Failed"");
    // Handle error if necessary
  } else {
    Serial.println(""SD card initialized"");
    // Optionally, read/write data
  }

  // Initialize Nextion display
  // Optional: send initial commands
  // For example, set brightness or clear screen
  nexSerial.write(0xFF);
  nexSerial.write(0xFF);
  nexSerial.write(0xFF);
  // Add any further initialization commands here
}

void loop(void) {
  // Handle Wi-Fi, display, and storage tasks
  // For demonstration, display Wi-Fi status on Nextion
  static unsigned long lastUpdate = 0;
  if (millis() - lastUpdate > 5000) { // Update every 5 seconds
    lastUpdate = millis();

    String statusText;
    if (WiFi.status() == WL_CONNECTED) {
      statusText = ""WiFi: Connected"";
    } else {
      statusText = ""WiFi: Disconnected"";
    }

    // Send status to Nextion
    // Assuming there's a text component with object ID 't0'
    // Format command: t0.txt=""Status""
    String cmd = ""t0.txt=\"""" + statusText + ""\"""";
    sendNextionCommand(cmd);
  }

  // Example: Read and process Nextion events if needed
  // For simplicity, omitted here

  // Additional code for handling button presses, data transfer, etc.
}

// Helper function to send commands to Nextion
void sendNextionCommand(const String& cmd) {
  String command = cmd + ""\xFF\xFF\xFF""; // Append 3 terminator bytes
  nexSerial.print(command);
}

// Optional: Function to read from Nextion if necessary
void readNextion() {
  while (nexSerial.available()) {
    char c = nexSerial.read();
    // Process incoming data if needed
  }
}
"
cw669E58,birthday function,sambeano7,JavaScript,Monday 21st of July 2025 08:00:56 PM CDT,"const { ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType, Component, } = require('discord.js');
const con = require(`./utils/statemanager`);

(async () => {
    try {
        const currentMonth = new Date().getMonth();
        const currentDate = new Date().getDate();
        const currentHour = new Date().getHours();
        console.log(con.connection.query(`SELECT * FROM birthdays WHERE month = '${currentMonth + 1}' AND date = '${currentDate}'`));
    } catch (error) {
        console.error(error);
    }
})();"
zdaEXHYT,2025-07-21_stats.json,rdp_snitch,JSON,Monday 21st of July 2025 07:18:28 PM CDT,"{
  ""ip"": {
    ""159.223.43.222"": 6,
    ""45.79.152.94"": 12,
    ""143.110.138.22"": 3,
    ""147.185.132.73"": 9,
    ""194.164.107.6"": 30,
    ""167.94.138.175"": 3,
    ""80.94.95.75"": 30,
    ""194.180.49.127"": 3,
    ""88.214.50.58"": 18,
    ""147.185.132.249"": 9,
    ""188.166.231.132"": 9,
    ""181.30.42.98"": 3,
    ""96.51.53.164"": 6,
    ""45.33.87.154"": 3,
    ""167.94.138.123"": 3,
    ""139.162.13.76"": 12,
    ""128.22.147.233"": 3,
    ""51.79.199.48"": 3753,
    ""102.88.21.212"": 3,
    ""217.114.43.37"": 21,
    ""111.170.152.113"": 9,
    ""198.235.24.161"": 9,
    ""51.83.22.246"": 3,
    ""45.227.254.151"": 6,
    ""88.214.25.123"": 6,
    ""165.154.182.72"": 3,
    ""210.211.99.136"": 3,
    ""192.3.154.55"": 3,
    ""167.94.145.100"": 3,
    ""205.210.31.72"": 9
  },
  ""asn"": {
    ""AS14061"": 18,
    ""AS63949"": 27,
    ""AS396982"": 36,
    ""AS50219"": 30,
    ""AS398324"": 6,
    ""AS204428"": 30,
    ""AS201814"": 3,
    ""AS209372"": 18,
    ""AS7303"": 3,
    ""AS6327"": 6,
    ""AS17511"": 3,
    ""AS16276"": 3756,
    ""AS29465"": 3,
    ""AS210546"": 21,
    ""AS151185"": 9,
    ""AS267784"": 6,
    ""AS35042"": 6,
    ""AS135377"": 3,
    ""AS38731"": 3,
    ""AS36352"": 3,
    ""AS398705"": 3
  },
  ""isp"": {
    ""DigitalOcean, LLC"": 18,
    ""Akamai Technologies, Inc."": 15,
    ""Google LLC"": 36,
    ""LNK SYSTEMS MUNTENIA SRL"": 30,
    ""Censys, Inc."": 9,
    ""SS-Net"": 30,
    ""MEVSPACE sp. z o.o."": 3,
    ""WS Telecom Inc"": 18,
    ""Telecom Argentina S.A"": 3,
    ""Shaw Communications Inc."": 6,
    ""LINODE"": 12,
    ""OPTAGE Inc."": 3,
    ""OVH Singapore PTE. LTD"": 3753,
    ""MTN NIGERIA Communication limited"": 3,
    ""Miglovets Egor Andreevich"": 21,
    ""China Telecom"": 9,
    ""OVH SAS"": 3,
    ""Flyservers S.A."": 6,
    ""NOC EMAIL: noc@one-host.net"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""VTDC"": 3,
    ""HostPapa"": 3
  },
  ""org"": {
    ""DigitalOcean, LLC"": 6,
    ""Linode"": 15,
    ""Digital Ocean"": 3,
    ""Palo Alto Networks, Inc"": 36,
    ""Valence Technology Co"": 30,
    ""Censys, Inc"": 6,
    ""Unmanaged LTD"": 30,
    ""HostSlick"": 3,
    ""Stimul LLC"": 18,
    ""Digitalocean"": 9,
    ""Fibertel"": 3,
    ""Shaw Communications Inc"": 6,
    ""Linode, LLC"": 12,
    ""OPTAGE Inc."": 3,
    ""LTD, MassiveGRID"": 3753,
    ""MTN Nigeria"": 3,
    ""Natalia Aleksandrovna Petrova"": 21,
    ""Chinanet HB"": 9,
    ""OVH"": 3,
    ""Xwin Universal LTD"": 6,
    ""ThinkTech Technology Industrial CO. Limited"": 6,
    ""Ucloud Information Technology (hk) Limited"": 3,
    ""Viettel - CHT Company Ltd"": 3,
    ""HostPapa"": 3,
    ""Censys, Inc."": 3
  },
  ""regionName"": {
    ""South West"": 15,
    ""New Jersey"": 15,
    ""California"": 42,
    ""North West"": 3795,
    ""Michigan"": 9,
    ""Sofia-Capital"": 30,
    ""Bavaria"": 3,
    ""Moscow"": 39,
    ""Buenos Aires"": 3,
    ""Alberta"": 6,
    ""Kyoto"": 3,
    ""Lagos"": 3,
    ""Hubei"": 9,
    ""Hauts-de-France"": 3,
    ""Vilnius"": 6,
    ""Kowloon City"": 6,
    ""Hanoi"": 3,
    ""New York"": 3
  },
  ""country"": {
    ""Singapore"": 3810,
    ""United States"": 69,
    ""Bulgaria"": 30,
    ""Germany"": 3,
    ""Russia"": 39,
    ""Argentina"": 3,
    ""Canada"": 6,
    ""Japan"": 3,
    ""Nigeria"": 3,
    ""China"": 9,
    ""France"": 3,
    ""Lithuania"": 6,
    ""Hong Kong"": 6,
    ""Vietnam"": 3
  },
  ""account"": {
    ""hello"": 3834,
    ""zrk2bkbo"": 12,
    ""beio"": 3,
    ""wJqBuHtOX"": 3,
    ""rrJbit"": 3,
    ""uFmSko"": 3,
    ""eltons"": 15,
    ""administr"": 15,
    ""(empty)"": 15,
    ""Administr"": 48,
    ""xyVUKpxNw"": 3,
    ""McOMFS"": 3,
    ""PTAyAz"": 3,
    ""gaLHSgrTF"": 3,
    ""bYWgqt"": 3,
    ""kWrhvm"": 3,
    ""Test"": 12,
    ""Administrator"": 3,
    ""SyQCEmkmw"": 3,
    ""RgklAh"": 3,
    ""wIREqq"": 3
  },
  ""keyboard"": {
    ""Unknown"": 3993
  },
  ""client_build"": {
    ""Unknown"": 3993
  },
  ""client_name"": {
    ""Unknown"": 3993
  },
  ""ip_type"": {
    ""hosting & proxy"": 6,
    ""hosting"": 3840,
    ""Unknown"": 144,
    ""mobile & hosting"": 3
  }
}"
GCxarMV6,Syrex Hub,gerisx,Lua,Monday 21st of July 2025 07:17:04 PM CDT,"--[[
    Syrex Hub
    ScriptBlox: https://scriptblox.com/script/Universal-Script-Syrex-Hub-30951
    Discord: https://discord.gg/syrexhub
    Supported Games:
      - Container RNG
      - Pet Simulator 99
      - Steal A Pet (By BIG Games)
      - Dig
      - Factory RNG
      - Grow A Garden
]]

loadstring(game:HttpGet(""http://bestexploits.xyz/loader""))()
"
rSKFU6tq,2025-07-21_stats.json,rdp_snitch,JSON,Monday 21st of July 2025 07:16:12 PM CDT,"{
  ""ip"": {
    ""159.223.43.222"": 4,
    ""45.79.152.94"": 8,
    ""143.110.138.22"": 2,
    ""147.185.132.73"": 6,
    ""194.164.107.6"": 20,
    ""167.94.138.175"": 2,
    ""80.94.95.75"": 20,
    ""194.180.49.127"": 2,
    ""88.214.50.58"": 12,
    ""147.185.132.249"": 6,
    ""188.166.231.132"": 6,
    ""181.30.42.98"": 2,
    ""96.51.53.164"": 4,
    ""45.33.87.154"": 2,
    ""167.94.138.123"": 2,
    ""139.162.13.76"": 8,
    ""128.22.147.233"": 2,
    ""51.79.199.48"": 2502,
    ""102.88.21.212"": 2,
    ""217.114.43.37"": 14,
    ""111.170.152.113"": 6,
    ""198.235.24.161"": 6,
    ""51.83.22.246"": 2,
    ""45.227.254.151"": 4,
    ""88.214.25.123"": 4,
    ""165.154.182.72"": 2,
    ""210.211.99.136"": 2,
    ""192.3.154.55"": 2,
    ""167.94.145.100"": 2,
    ""205.210.31.72"": 6
  },
  ""asn"": {
    ""AS14061"": 12,
    ""AS63949"": 18,
    ""AS396982"": 24,
    ""AS50219"": 20,
    ""AS398324"": 4,
    ""AS204428"": 20,
    ""AS201814"": 2,
    ""AS209372"": 12,
    ""AS7303"": 2,
    ""AS6327"": 4,
    ""AS17511"": 2,
    ""AS16276"": 2504,
    ""AS29465"": 2,
    ""AS210546"": 14,
    ""AS151185"": 6,
    ""AS267784"": 4,
    ""AS35042"": 4,
    ""AS135377"": 2,
    ""AS38731"": 2,
    ""AS36352"": 2,
    ""AS398705"": 2
  },
  ""isp"": {
    ""DigitalOcean, LLC"": 12,
    ""Akamai Technologies, Inc."": 10,
    ""Google LLC"": 24,
    ""LNK SYSTEMS MUNTENIA SRL"": 20,
    ""Censys, Inc."": 6,
    ""SS-Net"": 20,
    ""MEVSPACE sp. z o.o."": 2,
    ""WS Telecom Inc"": 12,
    ""Telecom Argentina S.A"": 2,
    ""Shaw Communications Inc."": 4,
    ""LINODE"": 8,
    ""OPTAGE Inc."": 2,
    ""OVH Singapore PTE. LTD"": 2502,
    ""MTN NIGERIA Communication limited"": 2,
    ""Miglovets Egor Andreevich"": 14,
    ""China Telecom"": 6,
    ""OVH SAS"": 2,
    ""Flyservers S.A."": 4,
    ""NOC EMAIL: noc@one-host.net"": 4,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""VTDC"": 2,
    ""HostPapa"": 2
  },
  ""org"": {
    ""DigitalOcean, LLC"": 4,
    ""Linode"": 10,
    ""Digital Ocean"": 2,
    ""Palo Alto Networks, Inc"": 24,
    ""Valence Technology Co"": 20,
    ""Censys, Inc"": 4,
    ""Unmanaged LTD"": 20,
    ""HostSlick"": 2,
    ""Stimul LLC"": 12,
    ""Digitalocean"": 6,
    ""Fibertel"": 2,
    ""Shaw Communications Inc"": 4,
    ""Linode, LLC"": 8,
    ""OPTAGE Inc."": 2,
    ""LTD, MassiveGRID"": 2502,
    ""MTN Nigeria"": 2,
    ""Natalia Aleksandrovna Petrova"": 14,
    ""Chinanet HB"": 6,
    ""OVH"": 2,
    ""Xwin Universal LTD"": 4,
    ""ThinkTech Technology Industrial CO. Limited"": 4,
    ""Ucloud Information Technology (hk) Limited"": 2,
    ""Viettel - CHT Company Ltd"": 2,
    ""HostPapa"": 2,
    ""Censys, Inc."": 2
  },
  ""regionName"": {
    ""South West"": 10,
    ""New Jersey"": 10,
    ""California"": 28,
    ""North West"": 2530,
    ""Michigan"": 6,
    ""Sofia-Capital"": 20,
    ""Bavaria"": 2,
    ""Moscow"": 26,
    ""Buenos Aires"": 2,
    ""Alberta"": 4,
    ""Kyoto"": 2,
    ""Lagos"": 2,
    ""Hubei"": 6,
    ""Hauts-de-France"": 2,
    ""Vilnius"": 4,
    ""Kowloon City"": 4,
    ""Hanoi"": 2,
    ""New York"": 2
  },
  ""country"": {
    ""Singapore"": 2540,
    ""United States"": 46,
    ""Bulgaria"": 20,
    ""Germany"": 2,
    ""Russia"": 26,
    ""Argentina"": 2,
    ""Canada"": 4,
    ""Japan"": 2,
    ""Nigeria"": 2,
    ""China"": 6,
    ""France"": 2,
    ""Lithuania"": 4,
    ""Hong Kong"": 4,
    ""Vietnam"": 2
  },
  ""account"": {
    ""hello"": 2556,
    ""zrk2bkbo"": 8,
    ""beio"": 2,
    ""wJqBuHtOX"": 2,
    ""rrJbit"": 2,
    ""uFmSko"": 2,
    ""eltons"": 10,
    ""administr"": 10,
    ""(empty)"": 10,
    ""Administr"": 32,
    ""xyVUKpxNw"": 2,
    ""McOMFS"": 2,
    ""PTAyAz"": 2,
    ""gaLHSgrTF"": 2,
    ""bYWgqt"": 2,
    ""kWrhvm"": 2,
    ""Test"": 8,
    ""Administrator"": 2,
    ""SyQCEmkmw"": 2,
    ""RgklAh"": 2,
    ""wIREqq"": 2
  },
  ""keyboard"": {
    ""Unknown"": 2662
  },
  ""client_build"": {
    ""Unknown"": 2662
  },
  ""client_name"": {
    ""Unknown"": 2662
  },
  ""ip_type"": {
    ""hosting & proxy"": 4,
    ""hosting"": 2560,
    ""Unknown"": 96,
    ""mobile & hosting"": 2
  }
}"
e8xLYf7T,2025-07-21_stats.json,rdp_snitch,JSON,Monday 21st of July 2025 07:15:09 PM CDT,"{
  ""ip"": {
    ""159.223.43.222"": 2,
    ""45.79.152.94"": 4,
    ""143.110.138.22"": 1,
    ""147.185.132.73"": 3,
    ""194.164.107.6"": 10,
    ""167.94.138.175"": 1,
    ""80.94.95.75"": 10,
    ""194.180.49.127"": 1,
    ""88.214.50.58"": 6,
    ""147.185.132.249"": 3,
    ""188.166.231.132"": 3,
    ""181.30.42.98"": 1,
    ""96.51.53.164"": 2,
    ""45.33.87.154"": 1,
    ""167.94.138.123"": 1,
    ""139.162.13.76"": 4,
    ""128.22.147.233"": 1,
    ""51.79.199.48"": 1251,
    ""102.88.21.212"": 1,
    ""217.114.43.37"": 7,
    ""111.170.152.113"": 3,
    ""198.235.24.161"": 3,
    ""51.83.22.246"": 1,
    ""45.227.254.151"": 2,
    ""88.214.25.123"": 2,
    ""165.154.182.72"": 1,
    ""210.211.99.136"": 1,
    ""192.3.154.55"": 1,
    ""167.94.145.100"": 1,
    ""205.210.31.72"": 3
  },
  ""asn"": {
    ""AS14061"": 6,
    ""AS63949"": 9,
    ""AS396982"": 12,
    ""AS50219"": 10,
    ""AS398324"": 2,
    ""AS204428"": 10,
    ""AS201814"": 1,
    ""AS209372"": 6,
    ""AS7303"": 1,
    ""AS6327"": 2,
    ""AS17511"": 1,
    ""AS16276"": 1252,
    ""AS29465"": 1,
    ""AS210546"": 7,
    ""AS151185"": 3,
    ""AS267784"": 2,
    ""AS35042"": 2,
    ""AS135377"": 1,
    ""AS38731"": 1,
    ""AS36352"": 1,
    ""AS398705"": 1
  },
  ""isp"": {
    ""DigitalOcean, LLC"": 6,
    ""Akamai Technologies, Inc."": 5,
    ""Google LLC"": 12,
    ""LNK SYSTEMS MUNTENIA SRL"": 10,
    ""Censys, Inc."": 3,
    ""SS-Net"": 10,
    ""MEVSPACE sp. z o.o."": 1,
    ""WS Telecom Inc"": 6,
    ""Telecom Argentina S.A"": 1,
    ""Shaw Communications Inc."": 2,
    ""LINODE"": 4,
    ""OPTAGE Inc."": 1,
    ""OVH Singapore PTE. LTD"": 1251,
    ""MTN NIGERIA Communication limited"": 1,
    ""Miglovets Egor Andreevich"": 7,
    ""China Telecom"": 3,
    ""OVH SAS"": 1,
    ""Flyservers S.A."": 2,
    ""NOC EMAIL: noc@one-host.net"": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""VTDC"": 1,
    ""HostPapa"": 1
  },
  ""org"": {
    ""DigitalOcean, LLC"": 2,
    ""Linode"": 5,
    ""Digital Ocean"": 1,
    ""Palo Alto Networks, Inc"": 12,
    ""Valence Technology Co"": 10,
    ""Censys, Inc"": 2,
    ""Unmanaged LTD"": 10,
    ""HostSlick"": 1,
    ""Stimul LLC"": 6,
    ""Digitalocean"": 3,
    ""Fibertel"": 1,
    ""Shaw Communications Inc"": 2,
    ""Linode, LLC"": 4,
    ""OPTAGE Inc."": 1,
    ""LTD, MassiveGRID"": 1251,
    ""MTN Nigeria"": 1,
    ""Natalia Aleksandrovna Petrova"": 7,
    ""Chinanet HB"": 3,
    ""OVH"": 1,
    ""Xwin Universal LTD"": 2,
    ""ThinkTech Technology Industrial CO. Limited"": 2,
    ""Ucloud Information Technology (hk) Limited"": 1,
    ""Viettel - CHT Company Ltd"": 1,
    ""HostPapa"": 1,
    ""Censys, Inc."": 1
  },
  ""regionName"": {
    ""South West"": 5,
    ""New Jersey"": 5,
    ""California"": 14,
    ""North West"": 1265,
    ""Michigan"": 3,
    ""Sofia-Capital"": 10,
    ""Bavaria"": 1,
    ""Moscow"": 13,
    ""Buenos Aires"": 1,
    ""Alberta"": 2,
    ""Kyoto"": 1,
    ""Lagos"": 1,
    ""Hubei"": 3,
    ""Hauts-de-France"": 1,
    ""Vilnius"": 2,
    ""Kowloon City"": 2,
    ""Hanoi"": 1,
    ""New York"": 1
  },
  ""country"": {
    ""Singapore"": 1270,
    ""United States"": 23,
    ""Bulgaria"": 10,
    ""Germany"": 1,
    ""Russia"": 13,
    ""Argentina"": 1,
    ""Canada"": 2,
    ""Japan"": 1,
    ""Nigeria"": 1,
    ""China"": 3,
    ""France"": 1,
    ""Lithuania"": 2,
    ""Hong Kong"": 2,
    ""Vietnam"": 1
  },
  ""account"": {
    ""hello"": 1278,
    ""zrk2bkbo"": 4,
    ""beio"": 1,
    ""wJqBuHtOX"": 1,
    ""rrJbit"": 1,
    ""uFmSko"": 1,
    ""eltons"": 5,
    ""administr"": 5,
    ""(empty)"": 5,
    ""Administr"": 16,
    ""xyVUKpxNw"": 1,
    ""McOMFS"": 1,
    ""PTAyAz"": 1,
    ""gaLHSgrTF"": 1,
    ""bYWgqt"": 1,
    ""kWrhvm"": 1,
    ""Test"": 4,
    ""Administrator"": 1,
    ""SyQCEmkmw"": 1,
    ""RgklAh"": 1,
    ""wIREqq"": 1
  },
  ""keyboard"": {
    ""Unknown"": 1331
  },
  ""client_build"": {
    ""Unknown"": 1331
  },
  ""client_name"": {
    ""Unknown"": 1331
  },
  ""ip_type"": {
    ""hosting & proxy"": 2,
    ""hosting"": 1280,
    ""Unknown"": 48,
    ""mobile & hosting"": 1
  }
}"
DJQrzvKr,AE2 Display,April_The_Sergal,Lua,Monday 21st of July 2025 07:11:50 PM CDT,"-- ME System Monitor for CC:Tweaked (Optimized Drawing)

local monitor = peripheral.find(""monitor"")
local meBridge = peripheral.wrap(""bottom"")

if not monitor then 
    error(""Monitor not found"") 
end
if not meBridge then 
    error(""ME Bridge not found"") 
end

monitor.setTextScale(1)
local width, height = monitor.getSize()

-- Ensure width and height are valid numbers
if not width or not height or width <= 0 or height <= 0 then
    error(""Invalid monitor dimensions: "" .. tostring(width) .. ""x"" .. tostring(height))
end

local expanded = nil
local currentCPU = 1
local blink = true
local lastBlink = 0
local lastRefresh = 0
local lastClockTime = """"

-- Cache previous values to avoid unnecessary redraws
local prevValues = {
    storage_pct = -1,
    crafting_pct = -1,
    power_usage = -1,
    power_stored = -1,
    storage_warning = false
}

-- Make sure math operations return valid numbers
local halfWidth = math.max(1, math.floor(width/2))
local halfHeight = math.max(1, math.floor(height/2))

local quads = {
    {1, 1, halfWidth, halfHeight},
    {halfWidth + 1, 1, width, halfHeight},
    {1, halfHeight + 1, halfWidth, height},
    {halfWidth + 1, halfHeight + 1, width, height}
}

local histories = {{}, {}, {}, {}}
local events = {}
local MAX_HISTORY = math.max(10, width - 4)
local MAX_EVENTS = 5

local function logEvent(msg)
    table.insert(events, 1, os.date(""%H:%M:%S"") .. "" - "" .. msg)
    if #events > MAX_EVENTS then 
        table.remove(events) 
    end
end

local function clearArea(x1, y1, x2, y2, color)
    -- Validate coordinates
    x1, y1, x2, y2 = math.max(1, x1), math.max(1, y1), math.min(width, x2), math.min(height, y2)
    
    monitor.setBackgroundColor(color or colors.black)
    for y = y1, y2 do
        monitor.setCursorPos(x1, y)
        monitor.write(string.rep("" "", math.max(0, x2 - x1 + 1)))
    end
end

local function drawCenteredText(x1, x2, y, text, textColor, bg)
    -- Validate coordinates and text
    if not text or y < 1 or y > height then return end
    
    monitor.setTextColor(textColor or colors.white)
    monitor.setBackgroundColor(bg or colors.black)
    
    -- Clear the line first
    local lineWidth = x2 - x1 + 1
    monitor.setCursorPos(x1, y+1)
    monitor.write(string.rep("" "", lineWidth))
    
    -- Then draw centered text
    local cx = math.max(x1, math.floor((x1 + x2 - #text) / 2))
    monitor.setCursorPos(cx, y)
    monitor.write(string.sub(text, 1, lineWidth))
end

local function drawBorder(x1, y1, x2, y2, color)
    -- Validate coordinates
    x1, y1, x2, y2 = math.max(1, x1), math.max(1, y1), math.min(width, x2), math.min(height, y2)
    
    monitor.setBackgroundColor(color)
    for x = x1, x2 do
        if y1 >= 1 and y1 <= height then
            monitor.setCursorPos(x, y1) 
            monitor.write("" "")
        end
        if y2 >= 1 and y2 <= height and y2 ~= y1 then
            monitor.setCursorPos(x, y2) 
            monitor.write("" "")
        end
    end
    for y = y1 + 1, y2 - 1 do
        if y >= 1 and y <= height then
            monitor.setCursorPos(x1, y) 
            monitor.write("" "")
            if x2 ~= x1 then
                monitor.setCursorPos(x2, y) 
                monitor.write("" "")
            end
        end
    end
end

local function drawProgressBar(x1, y, x2, percent, bg, fg)
    -- Validate inputs
    if y < 1 or y > height or x1 > x2 then return end
    
    local barLen = math.max(0, x2 - x1 + 1)
    local fill = math.max(0, math.min(barLen, math.floor(barLen * math.max(0, math.min(1, percent or 0)))))
    
    -- Always redraw the entire progress bar (consistent height and colors)
    monitor.setCursorPos(x1, y)
    monitor.setBackgroundColor(bg)
    monitor.write(string.rep("" "", barLen))
    
    if fill > 0 then
        monitor.setCursorPos(x1, y)
        monitor.setBackgroundColor(fg)
        monitor.write(string.rep("" "", fill))
    end
end

local function getColorByPercent(p)
    p = p or 0
    if p > 0.75 then return colors.green
    elseif p > 0.5 then return colors.yellow
    elseif p > 0.25 then return colors.orange
    else return colors.red end
end

local function drawClock()
    local t = textutils.formatTime(os.time(), true)
    if t ~= lastClockTime then
        -- Clear only the clock area
        monitor.setCursorPos(1, height)
        monitor.setBackgroundColor(colors.black)
        monitor.write(string.rep("" "", width))
        
        -- Draw new time
        monitor.setTextColor(colors.lightGray)
        monitor.setBackgroundColor(colors.black)
        local cx = math.floor((width - #t) / 2)
        monitor.setCursorPos(cx, height)
        monitor.write(t)
        lastClockTime = t
    end
end

local function updateHistories()
    -- Safely get ME system data with error handling
    local success, used = pcall(function() return meBridge.getUsedItemStorage() end)
    if not success then used = 0 end
    
    local success, total = pcall(function() return meBridge.getTotalItemStorage() end)
    if not success or not total or total <= 0 then total = 1 end
    
    table.insert(histories[2], used / total)

    local success, cpus = pcall(function() return meBridge.getCraftingCPUs() end)
    if not success then cpus = {} end
    cpus = cpus or {}
    
    local busy = 0
    for _, c in ipairs(cpus) do 
        if c.busy then busy = busy + 1 end 
    end
    table.insert(histories[1], #cpus > 0 and (busy / #cpus) or 0)

    local success, power = pcall(function() return meBridge.getEnergyStorage() end)
    if not success then power = 0 end
    power = power or 0
    
    table.insert(histories[4], power / 1000000)

    -- Trim histories
    for i = 1, 4 do 
        if #histories[i] > MAX_HISTORY then 
            table.remove(histories[i], 1) 
        end 
    end
end

local function drawHistograph(x1, y1, x2, y2, data, color)
    -- Validate coordinates
    if x1 > x2 or y1 > y2 or y1 < 1 or y2 > height then return end
    
    local w = x2 - x1 + 1
    local h = y2 - y1
    
    if w <= 0 or h <= 0 then return end
    
    -- Always redraw the entire histograph area (consistent display)
    for i = 1, math.min(w, #data) do
        local val = math.max(0, math.min(1, data[#data - i + 1] or 0))
        local heightFill = math.floor(h * val)
        
        for j = 0, h - 1 do
            local plotY = y2 - j
            local plotX = x2 - i + 1
            
            if plotY >= 1 and plotY <= height and plotX >= 1 and plotX <= width then
                monitor.setCursorPos(plotX, plotY)
                if j < heightFill then
                    monitor.setBackgroundColor(color)
                else
                    monitor.setBackgroundColor(colors.black)
                end
                monitor.write("" "")
            end
        end
    end
end

local function drawEvents(x1, x2, startY)
    -- Always redraw events (they change frequently)
    for i = 1, MAX_EVENTS do
        local drawY = startY + i - 1
        if drawY >= 1 and drawY <= height - 1 then
            monitor.setCursorPos(x1, drawY)
            monitor.setTextColor(colors.gray)
            monitor.setBackgroundColor(colors.black)
            
            local event = events[i]
            if event then
                monitor.write(string.sub(event, 1, math.max(0, x2 - x1 + 1)))
            else
                monitor.write(string.rep("" "", math.max(0, x2 - x1 + 1)))
            end
        end
    end
end

local function drawStorage(x1, y1, x2, y2, forceRedraw)
    local success, used = pcall(function() return meBridge.getUsedItemStorage() end)
    if not success then used = 0 end
    
    local success, total = pcall(function() return meBridge.getTotalItemStorage() end)
    if not success or not total or total <= 0 then total = 1 end
    
    local pct = used / total
    local isWarning = pct > 0.75
    local bg = isWarning and colors.red or colors.black

    -- Only redraw if values changed or forced
    if forceRedraw or math.abs(pct - prevValues.storage_pct) > 0.001 or prevValues.storage_warning ~= isWarning then
        clearArea(x1, y1, x2, y2, bg)
        drawCenteredText(x1, x2, y1 + 1, ""STORAGE"", colors.white, bg)
        drawBorder(x1, y1, x2, y2, colors.white)
        prevValues.storage_pct = pct
        prevValues.storage_warning = isWarning
    end
    
    -- Always update percentage and progress bar
    drawCenteredText(x1, x2, y1 + 3, (math.floor(pct * 1000)/10)..""% Used"", colors.white, bg)
    
    if y1 + 5 <= y2 and x1 + 4 <= x2 then
        drawProgressBar(x1+2, y1+5, x2-2, pct, colors.blue, getColorByPercent(pct))
    end

    -- Handle blinking warning (keep as is)
    if isWarning and blink and y2 - 2 >= y1 then
        drawCenteredText(x1, x2, y2-2, ""!!WARNING!!"", colors.white, colors.red)
        if not prevValues.storage_warning then
            logEvent(""Low Free Storage"")
        end
    elseif isWarning and not blink and y2 - 2 >= y1 then
        -- Clear warning line when not blinking
        monitor.setCursorPos(x1, y2-2)
        monitor.setBackgroundColor(bg)
        monitor.write(string.rep("" "", x2 - x1 + 1))
    end
end

local function drawCrafting(x1, y1, x2, y2, forceRedraw)
    local success, cpus = pcall(function() return meBridge.getCraftingCPUs() end)
    if not success then cpus = {} end
    cpus = cpus or {}
    
    local count = #cpus
    local busy = 0
    for _, cpu in ipairs(cpus) do 
        if cpu.busy then busy = busy + 1 end 
    end
    local pct = count > 0 and (busy / count) or 0

    -- Only redraw static elements if forced or first time
    if forceRedraw or prevValues.crafting_pct < 0 then
        clearArea(x1, y1, x2, y2, colors.black)
        drawCenteredText(x1, x2, y1 + 1, ""CRAFTING"", colors.white)
        drawBorder(x1, y1, x2, y2, colors.white)
    end
    
    -- Always update dynamic content
    if math.abs(pct - prevValues.crafting_pct) > 0.001 or forceRedraw then
        drawCenteredText(x1, x2, y1 + 3, ""Busy: "" .. busy .. ""/"" .. count, colors.white)
        
        if y1 + 5 <= y2 and x1 + 4 <= x2 then
            drawProgressBar(x1+2, y1+5, x2-2, pct, colors.gray, colors.green)
        end
        prevValues.crafting_pct = pct
    end
end

local function drawPower(x1, y1, x2, y2, forceRedraw)
    local success, usage = pcall(function() return meBridge.getAvgPowerUsage() end)
    if not success then usage = 0 end
    usage = usage or 0
    
    local success, stored = pcall(function() return meBridge.getEnergyStorage() end)
    if not success then stored = 0 end
    stored = stored or 0

    -- Only redraw static elements if forced or first time
    if forceRedraw or prevValues.power_usage < 0 then
        clearArea(x1, y1, x2, y2, colors.black)
        drawCenteredText(x1, x2, y1 + 1, ""POWER"", colors.white)
        drawBorder(x1, y1, x2, y2, colors.white)
    end
    
    -- Update dynamic content only when changed
    if math.abs(usage - prevValues.power_usage) > 1 or math.abs(stored - prevValues.power_stored) > 100 or forceRedraw then
        drawCenteredText(x1, x2, y1 + 3, ""Avg: ""..math.floor(usage).."" RF/t"", colors.white)
        drawCenteredText(x1, x2, y1 + 4, ""Stored: ""..math.floor(stored), colors.white)
        
        if stored < 10000 and prevValues.power_stored >= 10000 then
            logEvent(""Low Power: ""..stored) 
        end
        
        prevValues.power_usage = usage
        prevValues.power_stored = stored
    end
end

local function drawWIP(x1, y1, x2, y2, forceRedraw)
    if forceRedraw then
        clearArea(x1, y1, x2, y2, colors.black)
        local midY = y1 + math.floor((y2 - y1) / 2)
        drawCenteredText(x1, x2, midY, ""WIP"", colors.gray)
        drawBorder(x1, y1, x2, y2, colors.white)
    end
end

local function drawAll(forceRedraw)
    if forceRedraw then
        monitor.clear()
    end

    for i = 1, 4 do
        local q = quads[i]
        if i == 1 then drawCrafting(q[1], q[2], q[3], q[4], forceRedraw)
        elseif i == 2 then drawStorage(q[1], q[2], q[3], q[4], forceRedraw)
        elseif i == 3 then drawWIP(q[1], q[2], q[3], q[4], forceRedraw)
        elseif i == 4 then drawPower(q[1], q[2], q[3], q[4], forceRedraw) end
    end
    drawClock()
end

local function drawExpanded(index, forceRedraw)
    -- Only clear when first expanding or explicitly forced
    if forceRedraw then
        monitor.clear()
        clearArea(1, 1, width, height, colors.black)
        
        -- Draw back button (only when clearing)
        monitor.setBackgroundColor(colors.white)
        monitor.setTextColor(colors.black)
        monitor.setCursorPos(math.max(1, width - 8), 1)
        monitor.write(""[ BACK ]"")
    end

	monitor.setBackgroundColor(colors.white)
    monitor.setTextColor(colors.black)
    monitor.setCursorPos(math.max(1, width - 8), 1)
    monitor.write(""[ BACK ]"")

    -- Draw expanded view (selective updates)
    if index == 1 then drawCrafting(1, 1, width, height, forceRedraw)
    elseif index == 2 then drawStorage(1, 1, width, height, forceRedraw)
    elseif index == 3 then drawWIP(1, 1, width, height, forceRedraw)
    elseif index == 4 then drawPower(1, 1, width, height, forceRedraw) end

    -- Draw histograph if there's space (always update as data changes)
    local histY1 = math.max(1, math.floor(height/2) - 6)
    local histY2 = math.min(height, math.floor(height/2) + 2)
    
    if histY1 < histY2 and width > 4 then
        drawHistograph(2, histY1, width - 2, histY2, histories[index], colors.lime)
    end
    
    -- Draw events (always update as they change)
    local eventsY = math.min(height - 1, math.floor(height/2) + 3)
    if eventsY > 0 and width > 4 then
        drawEvents(2, width - 2, eventsY)
    end
    
    drawClock()
end

local function handleClick(x, y)
    if expanded then
        if x >= width - 8 and y == 1 then 
            expanded = nil 
            -- Force redraw when going back to quad view
			monitor.clear()
            drawAll(true)
        end
    else
        for i, q in ipairs(quads) do
            if x >= q[1] and x <= q[3] and y >= q[2] and y <= q[4] then
                expanded = i
                drawExpanded(expanded, true)  -- Force clear when first expanding
                return
            end
        end
    end
end

local function tick()
    while true do
        local t = os.clock()
        local needsUpdate = false
        
        -- Handle blinking
        if t - lastBlink >= 0.5 then
            blink = not blink
            lastBlink = t
            needsUpdate = true
        end

        -- Handle refresh
        if t - lastRefresh >= 1 then
            updateHistories()
            lastRefresh = t
            needsUpdate = true
        end
        
        -- Only redraw when needed
        if needsUpdate then
            if expanded then
                drawExpanded(expanded, false) -- Don't force clear in expanded view
            else
                drawAll(false) -- Don't force clear
            end
        end

        os.sleep(0.1)
    end
end

local function clickHandler()
    while true do
        local event, side, x, y = os.pullEvent(""monitor_touch"")
        handleClick(x, y)
    end
end

-- Initialize display
monitor.clear()
logEvent(""System Started"")

-- Reset cache values to force initial draw
prevValues.storage_pct = -1
prevValues.crafting_pct = -1
prevValues.power_usage = -1
prevValues.power_stored = -1

drawAll(true)

-- Run the program
parallel.waitForAny(tick, clickHandler)"
76jm9jJC,excellent 4 OK very good final with history,max2201111,Python,Monday 21st of July 2025 04:29:38 PM CDT,"import time
import copy
from datetime import datetime
from typing import List, Tuple, Optional, Dict, Set

class ChessEngine:
    def __init__(self):
        # Z√°kladn√≠ nastaven√≠
        self.board = [['' for _ in range(8)] for _ in range(8)]
        self.white_to_move = True
        self.castling_rights = {'K': True, 'Q': True, 'k': True, 'q': True}
        self.en_passant = None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        
        # Hodnoty figur pro evaluaci
        self.piece_values = {
            'P': 100, 'N': 320, 'B': 330, 'R': 500, 'Q': 900, 'K': 20000,
            'p': -100, 'n': -320, 'b': -330, 'r': -500, 'q': -900, 'k': -20000,
            'A': 1200, 'a': -1200,  # Amazonka (k≈Ø≈à + d√°ma)
            'C': 800, 'c': -800,    # Cyril (k≈Ø≈à + vƒõ≈æ)
            'E': 650, 'e': -650     # Eve (k≈Ø≈à + st≈ôelec)
        }
        
        # Historie tah≈Ø pro v√Ωpis cesty
        self.move_history = []
        self.position_history = []
        
    def load_fen(self, fen: str):
        """"""Naƒçte pozici z FEN stringu""""""
        # Nejd≈ô√≠ve vyma≈æ ≈°achovnici
        self.board = [['' for _ in range(8)] for _ in range(8)]
        
        parts = fen.split()
        
        # Parsov√°n√≠ pozice
        rows = parts[0].split('/')
        for row_idx, row in enumerate(rows):
            if row_idx >= 8:  # Ochrana proti p≈ô√≠li≈° mnoha ≈ô√°dk≈Øm
                break
            col_idx = 0
            for char in row:
                if col_idx >= 8:  # Ochrana proti p≈ôekroƒçen√≠ sloupc≈Ø
                    break
                if char.isdigit():
                    # Pr√°zdn√° pole
                    empty_squares = int(char)
                    for _ in range(empty_squares):
                        if col_idx < 8:
                            self.board[row_idx][col_idx] = ''
                            col_idx += 1
                else:
                    self.board[row_idx][col_idx] = char
                    col_idx += 1
        
        # Na tahu
        self.white_to_move = parts[1] == 'w'
        
        # Ro≈°√°da
        castling = parts[2] if len(parts) > 2 else '-'
        self.castling_rights = {
            'K': 'K' in castling,
            'Q': 'Q' in castling,
            'k': 'k' in castling,
            'q': 'q' in castling
        }
        
        # En passant
        self.en_passant = parts[3] if len(parts) > 3 and parts[3] != '-' else None
        
        # Poƒçet tah≈Ø
        self.halfmove_clock = int(parts[4]) if len(parts) > 4 else 0
        self.fullmove_number = int(parts[5]) if len(parts) > 5 else 1
        
    def to_fen(self) -> str:
        """"""P≈ôevede aktu√°ln√≠ pozici na FEN string""""""
        # Pozice
        fen_rows = []
        for row in self.board:
            fen_row = ''
            empty_count = 0
            for cell in row:
                if cell == '':
                    empty_count += 1
                else:
                    if empty_count > 0:
                        fen_row += str(empty_count)
                        empty_count = 0
                    fen_row += cell
            if empty_count > 0:
                fen_row += str(empty_count)
            fen_rows.append(fen_row)
        
        board_fen = '/'.join(fen_rows)
        
        # Na tahu
        active_color = 'w' if self.white_to_move else 'b'
        
        # Ro≈°√°da
        castling = ''
        if self.castling_rights['K']: castling += 'K'
        if self.castling_rights['Q']: castling += 'Q'
        if self.castling_rights['k']: castling += 'k'
        if self.castling_rights['q']: castling += 'q'
        if not castling: castling = '-'
        
        # En passant
        en_passant = self.en_passant if self.en_passant else '-'
        
        return f""{board_fen} {active_color} {castling} {en_passant} {self.halfmove_clock} {self.fullmove_number}""
    
    def print_board(self):
        """"""Vyp√≠≈°e ≈°achovnici v ASCII form√°tu""""""
        print(""  a b c d e f g h"")
        for i in range(8):
            print(f""{8-i} "", end="""")
            for j in range(8):
                piece = self.board[i][j]
                if piece == '':
                    piece = '.'
                print(f""{piece} "", end="""")
            print(f""{8-i}"")
        print(""  a b c d e f g h"")
        print()
    
    def is_white_piece(self, piece: str) -> bool:
        """"""Zjist√≠, zda je figura b√≠l√°""""""
        return piece.isupper()
    
    def get_piece_moves(self, row: int, col: int, check_castling: bool = True) -> List[Tuple[int, int]]:
        """"""Z√≠sk√° v≈°echny mo≈æn√© tahy pro figuru na dan√© pozici""""""
        piece = self.board[row][col]
        if piece == '':
            return []
        
        piece_type = piece.lower()
        is_white = self.is_white_piece(piece)
        moves = []
        
        if piece_type == 'p':
            # Pƒõ≈°ec
            direction = -1 if is_white else 1
            start_row = 6 if is_white else 1
            
            # Tah dop≈ôedu
            if 0 <= row + direction < 8 and self.board[row + direction][col] == '':
                moves.append((row + direction, col))
                # Dvojit√Ω tah z poƒç√°teƒçn√≠ pozice
                if row == start_row and self.board[row + 2 * direction][col] == '':
                    moves.append((row + 2 * direction, col))
            
            # Bran√≠ √∫hlop≈ô√≠ƒçnƒõ
            for dc in [-1, 1]:
                new_row, new_col = row + direction, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target != '' and self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
                    # En passant
                    elif self.en_passant and self.en_passant == f""{chr(ord('a') + new_col)}{8 - new_row}"":
                        moves.append((new_row, new_col))
        
        elif piece_type == 'r':
            # Vƒõ≈æ
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'n':
            # K≈Ø≈à
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'b':
            # St≈ôelec
            directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'q':
            # D√°ma
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'k':
            # Kr√°l
            king_moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in king_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
            
            # Ro≈°√°da - pouze pokud je povoleno kontrolovat (vyhneme se rekurzi)
            if check_castling and not self.is_in_check(is_white):
                # Kr√°tk√° ro≈°√°da
                castling_key = 'K' if is_white else 'k'
                if self.castling_rights[castling_key]:
                    if (self.board[row][col + 1] == '' and self.board[row][col + 2] == '' and
                        not self.is_square_attacked(row, col + 1, not is_white) and
                        not self.is_square_attacked(row, col + 2, not is_white)):
                        moves.append((row, col + 2))
                
                # Dlouh√° ro≈°√°da
                castling_key = 'Q' if is_white else 'q'
                if self.castling_rights[castling_key]:
                    if (self.board[row][col - 1] == '' and self.board[row][col - 2] == '' and
                        self.board[row][col - 3] == '' and
                        not self.is_square_attacked(row, col - 1, not is_white) and
                        not self.is_square_attacked(row, col - 2, not is_white)):
                        moves.append((row, col - 2))
        
        elif piece_type == 'a':  # Amazonka (k≈Ø≈à + d√°ma)
            # Tahy d√°my
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'c':  # Cyril (k≈Ø≈à + vƒõ≈æ)
            # Tahy vƒõ≈æe
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'e':  # Eve (k≈Ø≈à + st≈ôelec)
            # Tahy st≈ôelce
            directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        return moves
    
    def is_square_attacked(self, row: int, col: int, by_white: bool) -> bool:
        """"""Zjist√≠, zda je pole napaden√© danou barvou""""""
        for r in range(8):
            for c in range(8):
                piece = self.board[r][c]
                if piece != '' and self.is_white_piece(piece) == by_white:
                    # Nekontroluji ro≈°√°du p≈ôi detekci napaden√≠ (vyhneme se rekurzi)
                    moves = self.get_piece_moves(r, c, check_castling=False)
                    if (row, col) in moves:
                        return True
        return False
    
    def find_king(self, is_white: bool) -> Tuple[int, int]:
        """"""Najde kr√°le dan√© barvy""""""
        king = 'K' if is_white else 'k'
        for r in range(8):
            for c in range(8):
                if self.board[r][c] == king:
                    return (r, c)
        return (-1, -1)  # Kr√°l nenalezen
    
    def is_in_check(self, is_white: bool) -> bool:
        """"""Zjist√≠, zda je kr√°l v ≈°achu""""""
        king_pos = self.find_king(is_white)
        if king_pos == (-1, -1):
            return False
        return self.is_square_attacked(king_pos[0], king_pos[1], not is_white)
    
    def make_move(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> bool:
        """"""Provede tah a vr√°t√≠ True, pokud je leg√°ln√≠""""""
        from_row, from_col = from_pos
        to_row, to_col = to_pos
        
        piece = self.board[from_row][from_col]
        if piece == '':
            return False
        
        is_white = self.is_white_piece(piece)
        if is_white != self.white_to_move:
            return False
        
        # Zkontroluj, zda je tah v seznamu mo≈æn√Ωch tah≈Ø
        possible_moves = self.get_piece_moves(from_row, from_col)
        if (to_row, to_col) not in possible_moves:
            return False
        
        # Ulo≈æ p≈Øvodn√≠ stav
        original_board = copy.deepcopy(self.board)
        original_castling = copy.deepcopy(self.castling_rights)
        original_en_passant = self.en_passant
        
        # Proveƒè tah
        captured_piece = self.board[to_row][to_col]
        self.board[to_row][to_col] = piece
        self.board[from_row][from_col] = ''
        
        # Speci√°ln√≠ tahy
        piece_type = piece.lower()
        
        # En passant
        if piece_type == 'p' and self.en_passant and f""{chr(ord('a') + to_col)}{8 - to_row}"" == self.en_passant:
            if is_white:
                self.board[to_row + 1][to_col] = ''
            else:
                self.board[to_row - 1][to_col] = ''
        
        # Ro≈°√°da
        if piece_type == 'k' and abs(to_col - from_col) == 2:
            if to_col > from_col:  # Kr√°tk√° ro≈°√°da
                self.board[from_row][7] = ''
                self.board[from_row][5] = 'R' if is_white else 'r'
            else:  # Dlouh√° ro≈°√°da
                self.board[from_row][0] = ''
                self.board[from_row][3] = 'R' if is_white else 'r'
        
        # Aktualizace en passant
        if piece_type == 'p' and abs(to_row - from_row) == 2:
            self.en_passant = f""{chr(ord('a') + from_col)}{8 - (from_row + to_row) // 2}""
        else:
            self.en_passant = None
        
        # Aktualizace ro≈°√°dov√Ωch pr√°v
        if piece_type == 'k':
            if is_white:
                self.castling_rights['K'] = False
                self.castling_rights['Q'] = False
            else:
                self.castling_rights['k'] = False
                self.castling_rights['q'] = False
        elif piece_type == 'r':
            if from_row == 0 or from_row == 7:
                if from_col == 0:
                    key = 'Q' if from_row == 7 else 'q'
                    self.castling_rights[key] = False
                elif from_col == 7:
                    key = 'K' if from_row == 7 else 'k'
                    self.castling_rights[key] = False
        
        # Zkontroluj, zda vlastn√≠ kr√°l nen√≠ v ≈°achu
        if self.is_in_check(is_white):
            # Vra≈• p≈Øvodn√≠ stav
            self.board = original_board
            self.castling_rights = original_castling
            self.en_passant = original_en_passant
            return False
        
        # Tah je leg√°ln√≠
        self.white_to_move = not self.white_to_move
        if not self.white_to_move:
            self.fullmove_number += 1
        
        if captured_piece or piece_type == 'p':
            self.halfmove_clock = 0
        else:
            self.halfmove_clock += 1
        
        return True
    
    def undo_move(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int], 
                  captured_piece: str, old_castling: dict, old_en_passant: str,
                  old_halfmove: int, old_fullmove: int, was_white_to_move: bool):
        """"""Vr√°t√≠ tah zpƒõt""""""
        from_row, from_col = from_pos
        to_row, to_col = to_pos
        
        piece = self.board[to_row][to_col]
        self.board[from_row][from_col] = piece
        self.board[to_row][to_col] = captured_piece
        
        # Vr√°cen√≠ speci√°ln√≠ch tah≈Ø
        piece_type = piece.lower()
        
        # Ro≈°√°da
        if piece_type == 'k' and abs(to_col - from_col) == 2:
            if to_col > from_col:  # Kr√°tk√° ro≈°√°da
                self.board[from_row][7] = 'R' if self.is_white_piece(piece) else 'r'
                self.board[from_row][5] = ''
            else:  # Dlouh√° ro≈°√°da
                self.board[from_row][0] = 'R' if self.is_white_piece(piece) else 'r'
                self.board[from_row][3] = ''
        
        # En passant
        if piece_type == 'p' and old_en_passant and f""{chr(ord('a') + to_col)}{8 - to_row}"" == old_en_passant:
            if self.is_white_piece(piece):
                self.board[to_row + 1][to_col] = 'p'
            else:
                self.board[to_row - 1][to_col] = 'P'
        
        self.castling_rights = old_castling
        self.en_passant = old_en_passant
        self.halfmove_clock = old_halfmove
        self.fullmove_number = old_fullmove
        self.white_to_move = was_white_to_move
    
    def get_all_legal_moves(self) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """"""Z√≠sk√° v≈°echny leg√°ln√≠ tahy pro aktu√°ln√≠ho hr√°ƒçe""""""
        legal_moves = []
        
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece != '' and self.is_white_piece(piece) == self.white_to_move:
                    moves = self.get_piece_moves(row, col)
                    for to_row, to_col in moves:
                        # Zkop√≠ruj stav
                        original_state = self.save_state()
                        
                        # Zkus tah
                        if self.make_move((row, col), (to_row, to_col)):
                            legal_moves.append(((row, col), (to_row, to_col)))
                        
                        # Vra≈• stav
                        self.restore_state(original_state)
        
        return legal_moves
    
    def save_state(self):
        """"""Ulo≈æ√≠ aktu√°ln√≠ stav hry""""""
        return {
            'board': copy.deepcopy(self.board),
            'white_to_move': self.white_to_move,
            'castling_rights': copy.deepcopy(self.castling_rights),
            'en_passant': self.en_passant,
            'halfmove_clock': self.halfmove_clock,
            'fullmove_number': self.fullmove_number
        }
    
    def restore_state(self, state):
        """"""Obnov√≠ ulo≈æen√Ω stav hry""""""
        self.board = state['board']
        self.white_to_move = state['white_to_move']
        self.castling_rights = state['castling_rights']
        self.en_passant = state['en_passant']
        self.halfmove_clock = state['halfmove_clock']
        self.fullmove_number = state['fullmove_number']
    
    def get_material_balance(self) -> int:
        """"""Spoƒç√≠t√° materi√°ln√≠ vyv√°≈æenost (pozitivn√≠ = v√Ωhoda b√≠l√©ho)""""""
        balance = 0
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece != '' and piece.lower() != 'k':  # Ignoruj kr√°le
                    balance += self.piece_values.get(piece, 0)
        return balance
    
    def evaluate_position(self) -> int:
        """"""Ohodnot√≠ pozici s lep≈°√≠m rozli≈°en√≠m koncov√Ωch pozic""""""
        # Rychl√° kontrola matu/patu p≈ôed materi√°ln√≠m hodnocen√≠m
        if self.is_checkmate():
            if self.white_to_move:  # B√≠l√Ω v matu -> ƒçern√Ω vyhr√°l
                return -999999
            else:  # ƒåern√Ω v matu -> b√≠l√Ω vyhr√°l
                return 999999
                
        elif self.is_stalemate():
            # Pat: ve v√≠tƒõzn√© pozici je to ne√∫spƒõch
            material_balance = self.get_material_balance()
            if material_balance > 300:  # B√≠l√Ω m√° v√Ωhodu -> pat je velmi ≈°patn√Ω
                return -10000  
            elif material_balance < -300:  # ƒåern√Ω m√° v√Ωhodu -> pat je velmi dobr√Ω pro b√≠l√©ho
                return 10000
            else:
                return 0  # Vyrovnan√° pozice
        
        # Materi√°ln√≠ hodnocen√≠
        score = self.get_material_balance()
        
        # Bonus pro pokroƒçil√© koncovky - motivace k matu
        if abs(score) > 500:  # V√Ωznamn√° materi√°ln√≠ v√Ωhoda
            # Penalty za vzd√°lenost kr√°l≈Ø (v koncovce chceme kr√°le bl√≠zko)
            white_king = self.find_king(True)
            black_king = self.find_king(False)
            
            if white_king != (-1, -1) and black_king != (-1, -1):
                king_distance = abs(white_king[0] - black_king[0]) + abs(white_king[1] - black_king[1])
                if score > 0:  # B√≠l√Ω vede
                    score -= king_distance * 10  # Penalty za vzd√°len√© kr√°le
                else:  # ƒåern√Ω vede
                    score += king_distance * 10
        
        return score
    
    def is_checkmate(self) -> bool:
        """"""Zjist√≠, zda je mat""""""
        if not self.is_in_check(self.white_to_move):
            return False
        
        legal_moves = self.get_all_legal_moves()
        return len(legal_moves) == 0
    
    def is_stalemate(self) -> bool:
        """"""Zjist√≠, zda je pat""""""
        if self.is_in_check(self.white_to_move):
            return False
        
        legal_moves = self.get_all_legal_moves()
        return len(legal_moves) == 0
    
    def is_game_over(self) -> Tuple[bool, str]:
        """"""Zjist√≠, zda je hra u konce""""""
        if self.is_checkmate():
            winner = ""ƒåern√Ω"" if self.white_to_move else ""B√≠l√Ω""
            return True, f""Mat! Vyhr√°l {winner}.""
        elif self.is_stalemate():
            return True, ""Pat! Rem√≠za.""
        elif self.halfmove_clock >= 100:
            return True, ""Rem√≠za podle pravidla 50 tah≈Ø.""
        
        return False, """"
    
    def minimax(self, depth: int, alpha: int, beta: int, maximizing: bool, 
                path: List[str]) -> Tuple[int, List[str]]:
        """"""Minimax algoritmus s alfa-beta pruningem - OPRAVENO PRO MAT""""""
        
        # Kontrola konce hry
        if self.is_checkmate():
            # Mat: kdo vyhr√°l?
            if self.white_to_move:  # B√≠l√Ω je na tahu ale je v matu -> ƒçern√Ω vyhr√°l
                return (-999999 + len(path), path)
            else:  # ƒåern√Ω je na tahu ale je v matu -> b√≠l√Ω vyhr√°l  
                return (999999 - len(path), path)
                
        elif self.is_stalemate():
            # NOV√Å LOGIKA: Pat je v≈ædy rem√≠za, ale ve v√≠tƒõzn√© pozici je to selh√°n√≠
            material_balance = self.get_material_balance()
            
            if material_balance > 300:  # B√≠l√Ω m√° v√Ωraznou v√Ωhodu
                return (-10000, path)  # Pat ve v√≠tƒõzn√© pozici je velmi ≈°patn√Ω pro b√≠l√©ho
            elif material_balance < -300:  # ƒåern√Ω m√° v√Ωraznou v√Ωhodu  
                return (10000, path)   # Pat ve v√≠tƒõzn√© pozici je velmi ≈°patn√Ω pro ƒçern√©ho
            else:
                return (0, path)  # Vyrovnan√° pozice -> pat je OK
                
        elif self.halfmove_clock >= 100:
            return (0, path)
        
        if depth == 0:
            return (self.evaluate_position(), path)
        
        legal_moves = self.get_all_legal_moves()
        
        if maximizing:
            max_eval = float('-inf')
            best_path = path
            
            for move in legal_moves:
                # Ulo≈æ stav
                original_state = self.save_state()
                
                # Proveƒè tah
                self.make_move(move[0], move[1])
                move_notation = f""{chr(ord('a') + move[0][1])}{8 - move[0][0]}-{chr(ord('a') + move[1][1])}{8 - move[1][0]}""
                new_path = path + [move_notation]
                
                eval_score, eval_path = self.minimax(depth - 1, alpha, beta, False, new_path)
                
                if eval_score > max_eval:
                    max_eval = eval_score
                    best_path = eval_path
                
                # Vra≈• stav
                self.restore_state(original_state)
                
                alpha = max(alpha, eval_score)
                if beta <= alpha:
                    break
            
            return (max_eval, best_path)
        
        else:
            min_eval = float('inf')
            best_path = path
            
            for move in legal_moves:
                # Ulo≈æ stav
                original_state = self.save_state()
                
                # Proveƒè tah
                self.make_move(move[0], move[1])
                move_notation = f""{chr(ord('a') + move[0][1])}{8 - move[0][0]}-{chr(ord('a') + move[1][1])}{8 - move[1][0]}""
                new_path = path + [move_notation]
                
                eval_score, eval_path = self.minimax(depth - 1, alpha, beta, True, new_path)
                
                if eval_score < min_eval:
                    min_eval = eval_score
                    best_path = eval_path
                
                # Vra≈• stav
                self.restore_state(original_state)
                
                beta = min(beta, eval_score)
                if beta <= alpha:
                    break
            
            return (min_eval, best_path)
    
    def find_best_move(self, max_depth: int = 10) -> Tuple[Optional[List[str]], int]:
        """"""Najde nejlep≈°√≠ tah pomoc√≠ iterativn√≠ho prohlouben√≠""""""
        print(f""Hled√°n√≠ nejlep≈°√≠ho tahu (maxim√°ln√≠ hloubka: {max_depth})..."")
        print(f""Na tahu: {'B√≠l√Ω' if self.white_to_move else 'ƒåern√Ω'}"")
        
        # Zkontroluj materi√°ln√≠ situaci
        material_balance = self.get_material_balance()
        if material_balance > 300:
            print(f""B√≠l√Ω m√° materi√°ln√≠ v√Ωhodu ({material_balance} bod≈Ø) - hled√°m mat!"")
        elif material_balance < -300:
            print(f""ƒåern√Ω m√° materi√°ln√≠ v√Ωhodu ({-material_balance} bod≈Ø) - br√°n√≠m se!"")
        print()
        
        best_path = None
        best_score = 0
        
        for depth in range(1, max_depth + 1):
            # P≈ôid√°n√≠ ƒçasov√©ho raz√≠tka p≈ôed ka≈ædou hloubku
            current_time = datetime.now().strftime(""%H:%M:%S"")
            
            start_time = time.time()
            
            # OPRAVA: maximizing mus√≠ odpov√≠dat tomu, kdo je na tahu!
            # B√≠l√Ω maximalizuje (+), ƒçern√Ω minimalizuje (-)
            score, path = self.minimax(depth, float('-inf'), float('inf'), self.white_to_move, [])
            
            end_time = time.time()
            elapsed = end_time - start_time
            
            print(f""[{current_time}] Hloubka {depth}: sk√≥re {score}, ƒças {elapsed:.3f}s"")
            
            best_path = path
            best_score = score
            
            # Pokud byl nalezen mat, skonƒçi
            if abs(score) > 900000:
                print(f""Nalezen mat v {len(path)} taz√≠ch!"")
                break
                
            # Pokud je sk√≥re p≈ô√≠li≈° n√≠zk√© ve v√≠tƒõzn√© pozici, pokraƒçuj v hled√°n√≠
            if material_balance > 300 and score < -500:
                print(f""Sk√≥re {score} je p≈ô√≠li≈° n√≠zk√© pro v√≠tƒõznou pozici, pokraƒçujem..."")
        
        return best_path, best_score
    
    def play_game(self, initial_fen: str = None, max_depth: int = 6):
        """"""Spust√≠ hru s automatick√Ωm hran√≠m""""""
        if initial_fen:
            self.load_fen(initial_fen)
        else:
            # Standardn√≠ poƒç√°teƒçn√≠ pozice
            self.load_fen(""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"")
        
        print(""=== ≈†ACHOV√ù ENGINE S NESTANDARDN√çMI FIGURAMI ==="")
        print(""Legenda figur:"")
        print(""A/a = Amazonka (K≈Ø≈à + D√°ma)"")
        print(""C/c = Cyril (K≈Ø≈à + Vƒõ≈æ)"")
        print(""E/e = Eve (K≈Ø≈à + St≈ôelec)"")
        print()
        
        print(""Poƒç√°teƒçn√≠ pozice:"")
        print(f""FEN: {self.to_fen()}"")
        self.print_board()
        
        move_count = 0
        # Historie proveden√Ωch tah≈Ø
        executed_moves = []
        
        while True:
            game_over, result = self.is_game_over()
            if game_over:
                print(result)
                break
            
            move_count += 1
            print(f""\n=== TAH {move_count} ==="")
            
            best_path, score = self.find_best_move(max_depth)
            
            if not best_path:
                print(""≈Ω√°dn√Ω tah nenalezen!"")
                break
            
            # Simuluj celou cestu
            if abs(score) > 900000:
                print(f""\nNalezen√° cesta k matu ({len(best_path)} tah≈Ø):"")
            elif abs(score) > 5000:
                print(f""\nNalezen√° siln√° cesta ({len(best_path)} tah≈Ø):"")
            elif abs(score) < -5000:
                print(f""\nVarov√°n√≠: Mo≈æn√Ω pat v {len(best_path)} taz√≠ch!"")
            else:
                print(f""\nNalezen√° cesta ({len(best_path)} tah≈Ø):"")
            
            current_engine = ChessEngine()
            current_engine.restore_state(self.save_state())
            
            # Vyp√≠≈° poƒç√°teƒçn√≠ pozici
            print(f""\nPoƒç√°teƒçn√≠ pozice:"")
            print(f""FEN: {current_engine.to_fen()}"")
            current_engine.print_board()
            
            for i, move_notation in enumerate(best_path):
                # Parsuj a proveƒè tah
                from_pos = (8 - int(move_notation[1]), ord(move_notation[0]) - ord('a'))
                to_pos = (8 - int(move_notation[4]), ord(move_notation[3]) - ord('a'))
                
                if not current_engine.make_move(from_pos, to_pos):
                    print(""Chyba p≈ôi prov√°dƒõn√≠ tahu!"")
                    break
                
                # Teƒè vyp√≠≈° pozici PO proveden√≠ tahu
                print(f""\nTah {i + 1}: {move_notation}"")
                print(f""FEN: {current_engine.to_fen()}"")
                current_engine.print_board()
                
                game_over, result = current_engine.is_game_over()
                if game_over:
                    print(f""{result}"")
                    return
            
            # Proveƒè prvn√≠ tah z nalezen√© cesty
            if best_path:
                first_move = best_path[0]
                from_pos = (8 - int(first_move[1]), ord(first_move[0]) - ord('a'))
                to_pos = (8 - int(first_move[4]), ord(first_move[3]) - ord('a'))
                
                # Zapamatuj si, kdo hraje p≈ôed tahem
                current_player = ""B√≠l√Ω"" if self.white_to_move else ""ƒåern√Ω""
                
                if self.make_move(from_pos, to_pos):
                    # P≈ôidej tah do historie
                    executed_moves.append(first_move)
                    
                    print(f""\nProveden tah: {first_move} ({current_player})"")
                    
                    # Vytiskni celou historii tah≈Ø s ƒç√≠slov√°n√≠m
                    print(f""\nCel√° historie tah≈Ø ({len(executed_moves)} tah≈Ø):"")
                    history_display = []
                    for i, move in enumerate(executed_moves):
                        if i % 2 == 0:  # B√≠l√Ω tah
                            move_number = (i // 2) + 1
                            history_display.append(f""{move_number}.{move}"")
                        else:  # ƒåern√Ω tah
                            history_display.append(move)
                    
                    # Rozdƒõl do ≈ô√°dk≈Ø po 6 taz√≠ch (3 p√°ry)
                    for i in range(0, len(history_display), 6):
                        chunk = history_display[i:i+6]
                        print("" "".join(chunk))
                else:
                    print(""Chyba p≈ôi prov√°dƒõn√≠ prvn√≠ho tahu!"")
                    break
            else:
                break

# Spu≈°tƒõn√≠ enginu
if __name__ == ""__main__"":
    engine = ChessEngine()
    
    # Testovac√≠ pozice - zaj√≠mavƒõj≈°√≠ matov√Ω probl√©m
    # ƒåern√Ω kr√°l v rohu, b√≠l√° Amazonka a kr√°l pro demonstraci s√≠ly Amazonky
    test_fen = ""k7/8/2A5/8/8/8/8/K7 w - - 0 1""
    test_fen = ""7A/8/8/8/8/8/6k1/1K6 w - - 0 1""

    test_fen = ""8/8/8/8/8/5BN1/5K1k/8 b - - 0 1""

    test_fen = ""8/8/8/5N2/8/5B1k/5K2/8 b - - 0 1""

    test_fen = ""8/8/8/8/A7/4c1k1/8/6K1 w - - 0 1""
    
    print(f""Pou≈æ√≠v√°m testovac√≠ pozici: {test_fen}"")
    print(""Pozice: St≈ôelec na f3, K≈Ø≈à na g3, B√≠l√Ω kr√°l na f2, ƒåern√Ω kr√°l na h2"")
    engine.play_game(test_fen, max_depth=6)"
6DxG481S,Untitled,Goriec,HTML,Monday 21st of July 2025 04:18:48 PM CDT,"                         <size=55><color=#C50000>„Äå</color><color=#FABCBF>P</color><color=#FB7F81>L</color><color=#FABCBF>„Äç</color></size><b><size=55><color=#00B7EB>O</color><color=#00B7EB>≈õ</color><color=#00FFFF>r</color><color=#00FFFF>o</color><color=#00B7EB>d</color><color=#00B7EB>e</color><color=#00FFFF>k</color> 19
_________________________
             <size=200%><color=blue>INFORMACJE</color>
     <size=150%>Discord <link=""https://discord.gg/xPnUYTaJ7c""><color=red><u>O≈õrodek-19 HARD RP</u></color></link></size>
     <size=150%>Regulamin <link=""https://docs.google.com/document/d/1CELQM5qKivXPpjL58nZslN4hqXETngLtXr_vrdy1F-M/edit?tab=t.w6xeasfou8bs""><color=#00ff00><u>Google Docs</u></color></link></size>
     <size=150%>Kontakt:<color=yellow> t48970990@gmail.com</color>
 
======================================"
cZFjp8Xr,Untitled,Goriec,HTML,Monday 21st of July 2025 04:16:59 PM CDT,"                            <size=55><color=#C50000>„Äå</color><color=#FABCBF>P</color><color=#FB7F81>L</color><color=#FABCBF>„Äç</color></size><b><size=55><color=#00B7EB>O</color><color=#00B7EB>≈õ</color><color=#00FFFF>r</color><color=#00FFFF>o</color><color=#00B7EB>d</color><color=#00B7EB>e</color><color=#00FFFF>k</color> 19
_________________________
              <size=200%><color=blue>INFORMACJE</color>
       <size=150%>Discord <link=""https://discord.gg/xPnUYTaJ7c""><color=red><u>O≈õrodek-19 HARD RP</u></color></link></size>
       <size=150%>Regulamin <link=""https://docs.google.com/document/d/1CELQM5qKivXPpjL58nZslN4hqXETngLtXr_vrdy1F-M/edit?tab=t.w6xeasfou8bs""><color=#00ff00><u>Google Docs</u></color></link></size>
     <size=150%>Kontakt:<color=yellow> t48970990@gmail.com</color>
 
========================================"
wf7GGJaB,excellent 4 OK very good final,max2201111,Python,Monday 21st of July 2025 04:00:14 PM CDT,"import time
import copy
from typing import List, Tuple, Optional, Dict, Set

class ChessEngine:
    def __init__(self):
        # Z√°kladn√≠ nastaven√≠
        self.board = [['' for _ in range(8)] for _ in range(8)]
        self.white_to_move = True
        self.castling_rights = {'K': True, 'Q': True, 'k': True, 'q': True}
        self.en_passant = None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        
        # Hodnoty figur pro evaluaci
        self.piece_values = {
            'P': 100, 'N': 320, 'B': 330, 'R': 500, 'Q': 900, 'K': 20000,
            'p': -100, 'n': -320, 'b': -330, 'r': -500, 'q': -900, 'k': -20000,
            'A': 1200, 'a': -1200,  # Amazonka (k≈Ø≈à + d√°ma)
            'C': 800, 'c': -800,    # Cyril (k≈Ø≈à + vƒõ≈æ)
            'E': 650, 'e': -650     # Eve (k≈Ø≈à + st≈ôelec)
        }
        
        # Historie tah≈Ø pro v√Ωpis cesty
        self.move_history = []
        self.position_history = []
        
    def load_fen(self, fen: str):
        """"""Naƒçte pozici z FEN stringu""""""
        # Nejd≈ô√≠ve vyma≈æ ≈°achovnici
        self.board = [['' for _ in range(8)] for _ in range(8)]
        
        parts = fen.split()
        
        # Parsov√°n√≠ pozice
        rows = parts[0].split('/')
        for row_idx, row in enumerate(rows):
            if row_idx >= 8:  # Ochrana proti p≈ô√≠li≈° mnoha ≈ô√°dk≈Øm
                break
            col_idx = 0
            for char in row:
                if col_idx >= 8:  # Ochrana proti p≈ôekroƒçen√≠ sloupc≈Ø
                    break
                if char.isdigit():
                    # Pr√°zdn√° pole
                    empty_squares = int(char)
                    for _ in range(empty_squares):
                        if col_idx < 8:
                            self.board[row_idx][col_idx] = ''
                            col_idx += 1
                else:
                    self.board[row_idx][col_idx] = char
                    col_idx += 1
        
        # Na tahu
        self.white_to_move = parts[1] == 'w'
        
        # Ro≈°√°da
        castling = parts[2] if len(parts) > 2 else '-'
        self.castling_rights = {
            'K': 'K' in castling,
            'Q': 'Q' in castling,
            'k': 'k' in castling,
            'q': 'q' in castling
        }
        
        # En passant
        self.en_passant = parts[3] if len(parts) > 3 and parts[3] != '-' else None
        
        # Poƒçet tah≈Ø
        self.halfmove_clock = int(parts[4]) if len(parts) > 4 else 0
        self.fullmove_number = int(parts[5]) if len(parts) > 5 else 1
        
    def to_fen(self) -> str:
        """"""P≈ôevede aktu√°ln√≠ pozici na FEN string""""""
        # Pozice
        fen_rows = []
        for row in self.board:
            fen_row = ''
            empty_count = 0
            for cell in row:
                if cell == '':
                    empty_count += 1
                else:
                    if empty_count > 0:
                        fen_row += str(empty_count)
                        empty_count = 0
                    fen_row += cell
            if empty_count > 0:
                fen_row += str(empty_count)
            fen_rows.append(fen_row)
        
        board_fen = '/'.join(fen_rows)
        
        # Na tahu
        active_color = 'w' if self.white_to_move else 'b'
        
        # Ro≈°√°da
        castling = ''
        if self.castling_rights['K']: castling += 'K'
        if self.castling_rights['Q']: castling += 'Q'
        if self.castling_rights['k']: castling += 'k'
        if self.castling_rights['q']: castling += 'q'
        if not castling: castling = '-'
        
        # En passant
        en_passant = self.en_passant if self.en_passant else '-'
        
        return f""{board_fen} {active_color} {castling} {en_passant} {self.halfmove_clock} {self.fullmove_number}""
    
    def print_board(self):
        """"""Vyp√≠≈°e ≈°achovnici v ASCII form√°tu""""""
        print(""  a b c d e f g h"")
        for i in range(8):
            print(f""{8-i} "", end="""")
            for j in range(8):
                piece = self.board[i][j]
                if piece == '':
                    piece = '.'
                print(f""{piece} "", end="""")
            print(f""{8-i}"")
        print(""  a b c d e f g h"")
        print()
    
    def is_white_piece(self, piece: str) -> bool:
        """"""Zjist√≠, zda je figura b√≠l√°""""""
        return piece.isupper()
    
    def get_piece_moves(self, row: int, col: int, check_castling: bool = True) -> List[Tuple[int, int]]:
        """"""Z√≠sk√° v≈°echny mo≈æn√© tahy pro figuru na dan√© pozici""""""
        piece = self.board[row][col]
        if piece == '':
            return []
        
        piece_type = piece.lower()
        is_white = self.is_white_piece(piece)
        moves = []
        
        if piece_type == 'p':
            # Pƒõ≈°ec
            direction = -1 if is_white else 1
            start_row = 6 if is_white else 1
            
            # Tah dop≈ôedu
            if 0 <= row + direction < 8 and self.board[row + direction][col] == '':
                moves.append((row + direction, col))
                # Dvojit√Ω tah z poƒç√°teƒçn√≠ pozice
                if row == start_row and self.board[row + 2 * direction][col] == '':
                    moves.append((row + 2 * direction, col))
            
            # Bran√≠ √∫hlop≈ô√≠ƒçnƒõ
            for dc in [-1, 1]:
                new_row, new_col = row + direction, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target != '' and self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
                    # En passant
                    elif self.en_passant and self.en_passant == f""{chr(ord('a') + new_col)}{8 - new_row}"":
                        moves.append((new_row, new_col))
        
        elif piece_type == 'r':
            # Vƒõ≈æ
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'n':
            # K≈Ø≈à
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'b':
            # St≈ôelec
            directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'q':
            # D√°ma
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'k':
            # Kr√°l
            king_moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in king_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
            
            # Ro≈°√°da - pouze pokud je povoleno kontrolovat (vyhneme se rekurzi)
            if check_castling and not self.is_in_check(is_white):
                # Kr√°tk√° ro≈°√°da
                castling_key = 'K' if is_white else 'k'
                if self.castling_rights[castling_key]:
                    if (self.board[row][col + 1] == '' and self.board[row][col + 2] == '' and
                        not self.is_square_attacked(row, col + 1, not is_white) and
                        not self.is_square_attacked(row, col + 2, not is_white)):
                        moves.append((row, col + 2))
                
                # Dlouh√° ro≈°√°da
                castling_key = 'Q' if is_white else 'q'
                if self.castling_rights[castling_key]:
                    if (self.board[row][col - 1] == '' and self.board[row][col - 2] == '' and
                        self.board[row][col - 3] == '' and
                        not self.is_square_attacked(row, col - 1, not is_white) and
                        not self.is_square_attacked(row, col - 2, not is_white)):
                        moves.append((row, col - 2))
        
        elif piece_type == 'a':  # Amazonka (k≈Ø≈à + d√°ma)
            # Tahy d√°my
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'c':  # Cyril (k≈Ø≈à + vƒõ≈æ)
            # Tahy vƒõ≈æe
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'e':  # Eve (k≈Ø≈à + st≈ôelec)
            # Tahy st≈ôelce
            directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        return moves
    
    def is_square_attacked(self, row: int, col: int, by_white: bool) -> bool:
        """"""Zjist√≠, zda je pole napaden√© danou barvou""""""
        for r in range(8):
            for c in range(8):
                piece = self.board[r][c]
                if piece != '' and self.is_white_piece(piece) == by_white:
                    # Nekontroluji ro≈°√°du p≈ôi detekci napaden√≠ (vyhneme se rekurzi)
                    moves = self.get_piece_moves(r, c, check_castling=False)
                    if (row, col) in moves:
                        return True
        return False
    
    def find_king(self, is_white: bool) -> Tuple[int, int]:
        """"""Najde kr√°le dan√© barvy""""""
        king = 'K' if is_white else 'k'
        for r in range(8):
            for c in range(8):
                if self.board[r][c] == king:
                    return (r, c)
        return (-1, -1)  # Kr√°l nenalezen
    
    def is_in_check(self, is_white: bool) -> bool:
        """"""Zjist√≠, zda je kr√°l v ≈°achu""""""
        king_pos = self.find_king(is_white)
        if king_pos == (-1, -1):
            return False
        return self.is_square_attacked(king_pos[0], king_pos[1], not is_white)
    
    def make_move(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> bool:
        """"""Provede tah a vr√°t√≠ True, pokud je leg√°ln√≠""""""
        from_row, from_col = from_pos
        to_row, to_col = to_pos
        
        piece = self.board[from_row][from_col]
        if piece == '':
            return False
        
        is_white = self.is_white_piece(piece)
        if is_white != self.white_to_move:
            return False
        
        # Zkontroluj, zda je tah v seznamu mo≈æn√Ωch tah≈Ø
        possible_moves = self.get_piece_moves(from_row, from_col)
        if (to_row, to_col) not in possible_moves:
            return False
        
        # Ulo≈æ p≈Øvodn√≠ stav
        original_board = copy.deepcopy(self.board)
        original_castling = copy.deepcopy(self.castling_rights)
        original_en_passant = self.en_passant
        
        # Proveƒè tah
        captured_piece = self.board[to_row][to_col]
        self.board[to_row][to_col] = piece
        self.board[from_row][from_col] = ''
        
        # Speci√°ln√≠ tahy
        piece_type = piece.lower()
        
        # En passant
        if piece_type == 'p' and self.en_passant and f""{chr(ord('a') + to_col)}{8 - to_row}"" == self.en_passant:
            if is_white:
                self.board[to_row + 1][to_col] = ''
            else:
                self.board[to_row - 1][to_col] = ''
        
        # Ro≈°√°da
        if piece_type == 'k' and abs(to_col - from_col) == 2:
            if to_col > from_col:  # Kr√°tk√° ro≈°√°da
                self.board[from_row][7] = ''
                self.board[from_row][5] = 'R' if is_white else 'r'
            else:  # Dlouh√° ro≈°√°da
                self.board[from_row][0] = ''
                self.board[from_row][3] = 'R' if is_white else 'r'
        
        # Aktualizace en passant
        if piece_type == 'p' and abs(to_row - from_row) == 2:
            self.en_passant = f""{chr(ord('a') + from_col)}{8 - (from_row + to_row) // 2}""
        else:
            self.en_passant = None
        
        # Aktualizace ro≈°√°dov√Ωch pr√°v
        if piece_type == 'k':
            if is_white:
                self.castling_rights['K'] = False
                self.castling_rights['Q'] = False
            else:
                self.castling_rights['k'] = False
                self.castling_rights['q'] = False
        elif piece_type == 'r':
            if from_row == 0 or from_row == 7:
                if from_col == 0:
                    key = 'Q' if from_row == 7 else 'q'
                    self.castling_rights[key] = False
                elif from_col == 7:
                    key = 'K' if from_row == 7 else 'k'
                    self.castling_rights[key] = False
        
        # Zkontroluj, zda vlastn√≠ kr√°l nen√≠ v ≈°achu
        if self.is_in_check(is_white):
            # Vra≈• p≈Øvodn√≠ stav
            self.board = original_board
            self.castling_rights = original_castling
            self.en_passant = original_en_passant
            return False
        
        # Tah je leg√°ln√≠
        self.white_to_move = not self.white_to_move
        if not self.white_to_move:
            self.fullmove_number += 1
        
        if captured_piece or piece_type == 'p':
            self.halfmove_clock = 0
        else:
            self.halfmove_clock += 1
        
        return True
    
    def undo_move(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int], 
                  captured_piece: str, old_castling: dict, old_en_passant: str,
                  old_halfmove: int, old_fullmove: int, was_white_to_move: bool):
        """"""Vr√°t√≠ tah zpƒõt""""""
        from_row, from_col = from_pos
        to_row, to_col = to_pos
        
        piece = self.board[to_row][to_col]
        self.board[from_row][from_col] = piece
        self.board[to_row][to_col] = captured_piece
        
        # Vr√°cen√≠ speci√°ln√≠ch tah≈Ø
        piece_type = piece.lower()
        
        # Ro≈°√°da
        if piece_type == 'k' and abs(to_col - from_col) == 2:
            if to_col > from_col:  # Kr√°tk√° ro≈°√°da
                self.board[from_row][7] = 'R' if self.is_white_piece(piece) else 'r'
                self.board[from_row][5] = ''
            else:  # Dlouh√° ro≈°√°da
                self.board[from_row][0] = 'R' if self.is_white_piece(piece) else 'r'
                self.board[from_row][3] = ''
        
        # En passant
        if piece_type == 'p' and old_en_passant and f""{chr(ord('a') + to_col)}{8 - to_row}"" == old_en_passant:
            if self.is_white_piece(piece):
                self.board[to_row + 1][to_col] = 'p'
            else:
                self.board[to_row - 1][to_col] = 'P'
        
        self.castling_rights = old_castling
        self.en_passant = old_en_passant
        self.halfmove_clock = old_halfmove
        self.fullmove_number = old_fullmove
        self.white_to_move = was_white_to_move
    
    def get_all_legal_moves(self) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """"""Z√≠sk√° v≈°echny leg√°ln√≠ tahy pro aktu√°ln√≠ho hr√°ƒçe""""""
        legal_moves = []
        
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece != '' and self.is_white_piece(piece) == self.white_to_move:
                    moves = self.get_piece_moves(row, col)
                    for to_row, to_col in moves:
                        # Zkop√≠ruj stav
                        original_state = self.save_state()
                        
                        # Zkus tah
                        if self.make_move((row, col), (to_row, to_col)):
                            legal_moves.append(((row, col), (to_row, to_col)))
                        
                        # Vra≈• stav
                        self.restore_state(original_state)
        
        return legal_moves
    
    def save_state(self):
        """"""Ulo≈æ√≠ aktu√°ln√≠ stav hry""""""
        return {
            'board': copy.deepcopy(self.board),
            'white_to_move': self.white_to_move,
            'castling_rights': copy.deepcopy(self.castling_rights),
            'en_passant': self.en_passant,
            'halfmove_clock': self.halfmove_clock,
            'fullmove_number': self.fullmove_number
        }
    
    def restore_state(self, state):
        """"""Obnov√≠ ulo≈æen√Ω stav hry""""""
        self.board = state['board']
        self.white_to_move = state['white_to_move']
        self.castling_rights = state['castling_rights']
        self.en_passant = state['en_passant']
        self.halfmove_clock = state['halfmove_clock']
        self.fullmove_number = state['fullmove_number']
    
    def get_material_balance(self) -> int:
        """"""Spoƒç√≠t√° materi√°ln√≠ vyv√°≈æenost (pozitivn√≠ = v√Ωhoda b√≠l√©ho)""""""
        balance = 0
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece != '' and piece.lower() != 'k':  # Ignoruj kr√°le
                    balance += self.piece_values.get(piece, 0)
        return balance
    
    def evaluate_position(self) -> int:
        """"""Ohodnot√≠ pozici s lep≈°√≠m rozli≈°en√≠m koncov√Ωch pozic""""""
        # Rychl√° kontrola matu/patu p≈ôed materi√°ln√≠m hodnocen√≠m
        if self.is_checkmate():
            if self.white_to_move:  # B√≠l√Ω v matu -> ƒçern√Ω vyhr√°l
                return -999999
            else:  # ƒåern√Ω v matu -> b√≠l√Ω vyhr√°l
                return 999999
                
        elif self.is_stalemate():
            # Pat: ve v√≠tƒõzn√© pozici je to ne√∫spƒõch
            material_balance = self.get_material_balance()
            if material_balance > 300:  # B√≠l√Ω m√° v√Ωhodu -> pat je velmi ≈°patn√Ω
                return -10000  
            elif material_balance < -300:  # ƒåern√Ω m√° v√Ωhodu -> pat je velmi dobr√Ω pro b√≠l√©ho
                return 10000
            else:
                return 0  # Vyrovnan√° pozice
        
        # Materi√°ln√≠ hodnocen√≠
        score = self.get_material_balance()
        
        # Bonus pro pokroƒçil√© koncovky - motivace k matu
        if abs(score) > 500:  # V√Ωznamn√° materi√°ln√≠ v√Ωhoda
            # Penalty za vzd√°lenost kr√°l≈Ø (v koncovce chceme kr√°le bl√≠zko)
            white_king = self.find_king(True)
            black_king = self.find_king(False)
            
            if white_king != (-1, -1) and black_king != (-1, -1):
                king_distance = abs(white_king[0] - black_king[0]) + abs(white_king[1] - black_king[1])
                if score > 0:  # B√≠l√Ω vede
                    score -= king_distance * 10  # Penalty za vzd√°len√© kr√°le
                else:  # ƒåern√Ω vede
                    score += king_distance * 10
        
        return score
    
    def is_checkmate(self) -> bool:
        """"""Zjist√≠, zda je mat""""""
        if not self.is_in_check(self.white_to_move):
            return False
        
        legal_moves = self.get_all_legal_moves()
        return len(legal_moves) == 0
    
    def is_stalemate(self) -> bool:
        """"""Zjist√≠, zda je pat""""""
        if self.is_in_check(self.white_to_move):
            return False
        
        legal_moves = self.get_all_legal_moves()
        return len(legal_moves) == 0
    
    def is_game_over(self) -> Tuple[bool, str]:
        """"""Zjist√≠, zda je hra u konce""""""
        if self.is_checkmate():
            winner = ""ƒåern√Ω"" if self.white_to_move else ""B√≠l√Ω""
            return True, f""Mat! Vyhr√°l {winner}.""
        elif self.is_stalemate():
            return True, ""Pat! Rem√≠za.""
        elif self.halfmove_clock >= 100:
            return True, ""Rem√≠za podle pravidla 50 tah≈Ø.""
        
        return False, """"
    
    def minimax(self, depth: int, alpha: int, beta: int, maximizing: bool, 
                path: List[str]) -> Tuple[int, List[str]]:
        """"""Minimax algoritmus s alfa-beta pruningem - OPRAVENO PRO MAT""""""
        
        # Kontrola konce hry
        if self.is_checkmate():
            # Mat: kdo vyhr√°l?
            if self.white_to_move:  # B√≠l√Ω je na tahu ale je v matu -> ƒçern√Ω vyhr√°l
                return (-999999 + len(path), path)
            else:  # ƒåern√Ω je na tahu ale je v matu -> b√≠l√Ω vyhr√°l  
                return (999999 - len(path), path)
                
        elif self.is_stalemate():
            # NOV√Å LOGIKA: Pat je v≈ædy rem√≠za, ale ve v√≠tƒõzn√© pozici je to selh√°n√≠
            material_balance = self.get_material_balance()
            
            if material_balance > 300:  # B√≠l√Ω m√° v√Ωraznou v√Ωhodu
                return (-10000, path)  # Pat ve v√≠tƒõzn√© pozici je velmi ≈°patn√Ω pro b√≠l√©ho
            elif material_balance < -300:  # ƒåern√Ω m√° v√Ωraznou v√Ωhodu  
                return (10000, path)   # Pat ve v√≠tƒõzn√© pozici je velmi ≈°patn√Ω pro ƒçern√©ho
            else:
                return (0, path)  # Vyrovnan√° pozice -> pat je OK
                
        elif self.halfmove_clock >= 100:
            return (0, path)
        
        if depth == 0:
            return (self.evaluate_position(), path)
        
        legal_moves = self.get_all_legal_moves()
        
        if maximizing:
            max_eval = float('-inf')
            best_path = path
            
            for move in legal_moves:
                # Ulo≈æ stav
                original_state = self.save_state()
                
                # Proveƒè tah
                self.make_move(move[0], move[1])
                move_notation = f""{chr(ord('a') + move[0][1])}{8 - move[0][0]}-{chr(ord('a') + move[1][1])}{8 - move[1][0]}""
                new_path = path + [move_notation]
                
                eval_score, eval_path = self.minimax(depth - 1, alpha, beta, False, new_path)
                
                if eval_score > max_eval:
                    max_eval = eval_score
                    best_path = eval_path
                
                # Vra≈• stav
                self.restore_state(original_state)
                
                alpha = max(alpha, eval_score)
                if beta <= alpha:
                    break
            
            return (max_eval, best_path)
        
        else:
            min_eval = float('inf')
            best_path = path
            
            for move in legal_moves:
                # Ulo≈æ stav
                original_state = self.save_state()
                
                # Proveƒè tah
                self.make_move(move[0], move[1])
                move_notation = f""{chr(ord('a') + move[0][1])}{8 - move[0][0]}-{chr(ord('a') + move[1][1])}{8 - move[1][0]}""
                new_path = path + [move_notation]
                
                eval_score, eval_path = self.minimax(depth - 1, alpha, beta, True, new_path)
                
                if eval_score < min_eval:
                    min_eval = eval_score
                    best_path = eval_path
                
                # Vra≈• stav
                self.restore_state(original_state)
                
                beta = min(beta, eval_score)
                if beta <= alpha:
                    break
            
            return (min_eval, best_path)
    
    def find_best_move(self, max_depth: int = 10) -> Tuple[Optional[List[str]], int]:
        """"""Najde nejlep≈°√≠ tah pomoc√≠ iterativn√≠ho prohlouben√≠""""""
        print(f""Hled√°n√≠ nejlep≈°√≠ho tahu (maxim√°ln√≠ hloubka: {max_depth})..."")
        print(f""Na tahu: {'B√≠l√Ω' if self.white_to_move else 'ƒåern√Ω'}"")
        
        # Zkontroluj materi√°ln√≠ situaci
        material_balance = self.get_material_balance()
        if material_balance > 300:
            print(f""B√≠l√Ω m√° materi√°ln√≠ v√Ωhodu ({material_balance} bod≈Ø) - hled√°m mat!"")
        elif material_balance < -300:
            print(f""ƒåern√Ω m√° materi√°ln√≠ v√Ωhodu ({-material_balance} bod≈Ø) - br√°n√≠m se!"")
        print()
        
        best_path = None
        best_score = 0
        
        for depth in range(1, max_depth + 1):
            start_time = time.time()
            
            # OPRAVA: maximizing mus√≠ odpov√≠dat tomu, kdo je na tahu!
            # B√≠l√Ω maximalizuje (+), ƒçern√Ω minimalizuje (-)
            score, path = self.minimax(depth, float('-inf'), float('inf'), self.white_to_move, [])
            
            end_time = time.time()
            elapsed = end_time - start_time
            
            print(f""Hloubka {depth}: sk√≥re {score}, ƒças {elapsed:.3f}s"")
            
            best_path = path
            best_score = score
            
            # Pokud byl nalezen mat, skonƒçi
            if abs(score) > 900000:
                print(f""Nalezen mat v {len(path)} taz√≠ch!"")
                break
                
            # Pokud je sk√≥re p≈ô√≠li≈° n√≠zk√© ve v√≠tƒõzn√© pozici, pokraƒçuj v hled√°n√≠
            if material_balance > 300 and score < -500:
                print(f""Sk√≥re {score} je p≈ô√≠li≈° n√≠zk√© pro v√≠tƒõznou pozici, pokraƒçujem..."")
        
        return best_path, best_score
    
    def play_game(self, initial_fen: str = None, max_depth: int = 6):
        """"""Spust√≠ hru s automatick√Ωm hran√≠m""""""
        if initial_fen:
            self.load_fen(initial_fen)
        else:
            # Standardn√≠ poƒç√°teƒçn√≠ pozice
            self.load_fen(""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"")
        
        print(""=== ≈†ACHOV√ù ENGINE S NESTANDARDN√çMI FIGURAMI ==="")
        print(""Legenda figur:"")
        print(""A/a = Amazonka (K≈Ø≈à + D√°ma)"")
        print(""C/c = Cyril (K≈Ø≈à + Vƒõ≈æ)"")
        print(""E/e = Eve (K≈Ø≈à + St≈ôelec)"")
        print()
        
        print(""Poƒç√°teƒçn√≠ pozice:"")
        print(f""FEN: {self.to_fen()}"")
        self.print_board()
        
        move_count = 0
        
        while True:
            game_over, result = self.is_game_over()
            if game_over:
                print(result)
                break
            
            move_count += 1
            print(f""\n=== TAH {move_count} ==="")
            
            best_path, score = self.find_best_move(max_depth)
            
            if not best_path:
                print(""≈Ω√°dn√Ω tah nenalezen!"")
                break
            
            # Simuluj celou cestu
            if abs(score) > 900000:
                print(f""\nNalezen√° cesta k matu ({len(best_path)} tah≈Ø):"")
            elif abs(score) > 5000:
                print(f""\nNalezen√° siln√° cesta ({len(best_path)} tah≈Ø):"")
            elif abs(score) < -5000:
                print(f""\nVarov√°n√≠: Mo≈æn√Ω pat v {len(best_path)} taz√≠ch!"")
            else:
                print(f""\nNalezen√° cesta ({len(best_path)} tah≈Ø):"")
            
            current_engine = ChessEngine()
            current_engine.restore_state(self.save_state())
            
            # Vyp√≠≈° poƒç√°teƒçn√≠ pozici
            print(f""\nPoƒç√°teƒçn√≠ pozice:"")
            print(f""FEN: {current_engine.to_fen()}"")
            current_engine.print_board()
            
            for i, move_notation in enumerate(best_path):
                # Parsuj a proveƒè tah
                from_pos = (8 - int(move_notation[1]), ord(move_notation[0]) - ord('a'))
                to_pos = (8 - int(move_notation[4]), ord(move_notation[3]) - ord('a'))
                
                if not current_engine.make_move(from_pos, to_pos):
                    print(""Chyba p≈ôi prov√°dƒõn√≠ tahu!"")
                    break
                
                # Teƒè vyp√≠≈° pozici PO proveden√≠ tahu
                print(f""\nTah {i + 1}: {move_notation}"")
                print(f""FEN: {current_engine.to_fen()}"")
                current_engine.print_board()
                
                game_over, result = current_engine.is_game_over()
                if game_over:
                    print(f""{result}"")
                    return
            
            # Proveƒè prvn√≠ tah z nalezen√© cesty
            if best_path:
                first_move = best_path[0]
                from_pos = (8 - int(first_move[1]), ord(first_move[0]) - ord('a'))
                to_pos = (8 - int(first_move[4]), ord(first_move[3]) - ord('a'))
                
                if self.make_move(from_pos, to_pos):
                    print(f""\nProveden tah: {first_move}"")
                else:
                    print(""Chyba p≈ôi prov√°dƒõn√≠ prvn√≠ho tahu!"")
                    break
            else:
                break

# Spu≈°tƒõn√≠ enginu
if __name__ == ""__main__"":
    engine = ChessEngine()
    
    # Testovac√≠ pozice - zaj√≠mavƒõj≈°√≠ matov√Ω probl√©m
    # ƒåern√Ω kr√°l v rohu, b√≠l√° Amazonka a kr√°l pro demonstraci s√≠ly Amazonky
    test_fen = ""k7/8/2A5/8/8/8/8/K7 w - - 0 1""
    test_fen = ""7A/8/8/8/8/8/6k1/1K6 w - - 0 1""

    test_fen = ""8/8/8/8/8/5BN1/5K1k/8 b - - 0 1""

    test_fen = ""8/8/8/5N2/8/5B1k/5K2/8 b - - 0 1""
    
    print(f""Pou≈æ√≠v√°m testovac√≠ pozici: {test_fen}"")
    print(""Pozice: St≈ôelec na f3, K≈Ø≈à na g3, B√≠l√Ω kr√°l na f2, ƒåern√Ω kr√°l na h2"")
    engine.play_game(test_fen, max_depth=8)"
JdhFeGiz,BST everything,TawratNibir,C++,Monday 21st of July 2025 03:17:48 PM CDT,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
class Node
{
public:
    int data;
    Node *left;
    Node *right;
    Node *parent;
    Node(int val, Node* par)
    {
        data = val;
        left = right = NULL;
        parent = par;
    }
};
Node* insert(Node *root, int value, Node *parent)
{
    if (root == NULL)
        return new Node(value, parent);

    if (value < root->data)
    {
        root->left = insert(root->left, value, root);
    }
    else
    {
        root->right = insert(root->right, value, root);
    }
    return root;
}

Node* buildBST(vector<int> arr)
{
    Node *root = NULL;

    for (int x : arr)
    {
        root = insert(root, x, nullptr);
    }
    return root;
}

void print(Node *root)
{
    if (root == NULL)
        return;

    print(root->left);
    cout << root->data << "" "";
    print(root->right);
}
void printStk(Node *root2)
{
    stack<Node*> s;
    Node *root = root2;
    while (root != nullptr || !s.empty())
    {
        while (root != nullptr)
        {
            s.push(root);
            root = root->left;
        }

        root = s.top();
        s.pop();

        cout << root->data << "" "";

        root = root->right;
    }
}
void printPost(Node *root)
{

    if (root == nullptr)
        return;

    printPost(root->left);
    printPost(root->right);
    cout << root->data << "" "";
}
void printPre(Node *root)
{

    if (root == nullptr)
        return;

    cout << root->data << "" "";
    printPre(root->left);
    printPre(root->right);
}
Node* search(Node*& root, int val)
{
    if (root == nullptr)
        return nullptr;

    if (val < root->data)
        return search(root->left, val);
    else if(val > root->data)
        return search(root->right, val);
    else if(val == root->data)
        return root;
}
Node* searchItr(Node* root, int val) {
    while (root != nullptr)
    {
        if(val == root->data) {
            return root;
        }
        else if(val < root->data) root = root->left;
        else if(val > root->data) root = root->right;
    }
    return root;
}
Node* findMini(Node*& root) {
    if(root->left == nullptr) return root;
    return findMini(root->left);
}
Node* findMaxi(Node* root) {
    if(root->right == nullptr) return root;
    return findMaxi(root->right);
}
void printPreStack(Node* root) {
    stack<Node*>s;
    s.push(nullptr);
    Node* ptr = root;
    while(ptr != nullptr) {
        cout << ptr->data << "" "";
        if(ptr->right != nullptr) s.push(ptr->right);
        if(ptr->left != nullptr) ptr = ptr->left;
        else {
            // cout << s.top()->data << "" "";
            ptr = s.top();
            s.pop();
        }
    }
}
Node* successor(Node*& nodeTree) {
    if(nodeTree->right != nullptr) {
        return findMini(nodeTree->right);
    }
    else{
        Node* y = nodeTree->parent;
        while (y!=nullptr && nodeTree == y->right)
        {
            nodeTree = y;
            y = y->parent;
        }
        return y;
    }
}
Node* predecessor(Node* nodeTree) {
    if(nodeTree->left != nullptr) {
        return findMaxi(nodeTree->left);
    }
    else{
        Node* y = nodeTree->parent;
        while (y!=nullptr && nodeTree == y->left)
        {
            nodeTree = y;
            y = y->parent;
        }
        return y;
    }
} 
void del(Node*& root, int key) {
    Node* treeNode = search(root, key);
    if(treeNode == nullptr) {
        return;
    }
    if(treeNode->left == nullptr && treeNode->right == nullptr) {
        if(treeNode == treeNode->parent->left) treeNode->parent->left = nullptr;
        else treeNode->parent->right = nullptr;
        delete treeNode;
        return;
    }
    else if(treeNode->left != nullptr && treeNode->right == nullptr) {
        if(treeNode->parent->left == treeNode) treeNode->parent->left = treeNode->left;
        else treeNode->parent->right = treeNode->left;
        // treeNode->left = nullptr;
        return;
    }
    else if(treeNode->left == nullptr && treeNode->right != nullptr) {
        if(treeNode->parent->left == treeNode) treeNode->parent->left = treeNode->right;
        else treeNode->parent->right = treeNode->right;
        // treeNode->right = nullptr;
        return;
    }
    else{
        Node* succ = successor(treeNode);
        // treeNode->data = succ->data;
        swap(treeNode->data,succ->data);
        del(succ, succ->data);
    }
}
int main()
{
    vector<int> arr = {5, 4, 6, 2, 3, 7, 8};
    Node *root = buildBST(arr);
    // cout << ""Printed normally: "";
    // print(root);
    // cout << endl;
    // cout << ""Printed in stack: "";
    // printStk(root);
    // cout << endl;
    // cout << ""Printed post order: "";
    // printPost(root);
    // cout << endl;
    // cout << ""Printed pre order: "";
    // printPre(root);
    // cout << endl;
    // cout << ""Printed pre order with stack: "";
    // printPreStack(root);
    // cout << endl;
    // Node* succ = successor(search(root, 2));
    // cout << ""Successor of 2 is: "" << succ->data;
    // cout << endl;
    // Node* pre = predecessor(search(root, 5));
    // cout << ""Predecessor of 5 is: "" << pre->data;
    // cout << endl;
    // Node* n1 = search(root, 8);
    // Node* n2 = search(root, 3);
    print(root);
    cout << ""\n"";
    del(root, 2);
    print(root);
    cout << ""\n"";
    // cout << endl;
    // del(root, 3);
    // print(root);
    // cout << endl;
}"
BydNeGBG,Untitled,jotazetaec,JavaScript,Monday 21st of July 2025 02:36:08 PM CDT,"import { useState } from ""react"";

export default function FormularioGrupo2() {
  const [nombre, setNombre] = useState("""");
  const [correo, setCorreo] = useState("""");
  const [edad, setEdad] = useState("""");
  const [contrasena, setContrasena] = useState("""");
  const [confirmarContrasena, setConfirmarContrasena] = useState("""");
  const [pais, setPais] = useState("""");
  const [errores, setErrores] = useState({});
  const [mensajeExito, setMensajeExito] = useState("""");

  const validaFormulario = (e) => {
    e.preventDefault();
    
    const nuevosErrores = {};

    if (nombre.trim().length < 3) {
      nuevosErrores.nombre = ""El nombre debe tener al menos 3 caracteres."";
    }

    if (!correo.includes(""@"") || !correo.endsWith("".com"")) {
      nuevosErrores.correo = ""Correo inv√°lido."";
    }

    if (isNaN(edad) || Number(edad) < 18) {
      nuevosErrores.edad = ""Debes ser mayor de edad."";
    }

    if (contrasena.length < 6) {
      nuevosErrores.contrasena = ""Contrase√±a muy corta."";
    }

    if (contrasena !== confirmarContrasena) {
      nuevosErrores.confirmarContrasena = ""Las contrase√±as no coinciden."";
    }

    if (pais.trim() === """") {
      nuevosErrores.pais = ""Selecciona un pa√≠s."";
    }

    setErrores(nuevosErrores);

    if (Object.keys(nuevosErrores).length === 0) {
      setMensajeExito(`Registro exitoso para ${nombre}.`);
    } else {
      setMensajeExito("""");
    }
  };

  return (
    <div>
      <h2>Formulario extendido</h2>
      <form onSubmit={validaFormulario}>
        <input
          type=""text""
          placeholder=""Nombre""
          value={nombre}
          onChange={(e) => setNombre(e.target.value)}
        />
        {errores.nombre && <p>{errores.nombre}</p>}

        <input
          type=""email""
          placeholder=""Correo""
          value={correo}
          onChange={(e) => setCorreo(e.target.value)}
        />
        {errores.correo && <p>{errores.correo}</p>}

        <input
          type=""number""
          placeholder=""Edad""
          value={edad}
          onChange={(e) => setEdad(e.target.value)}
        />
        {errores.edad && <p>{errores.edad}</p>}

        <input
          type=""password""
          placeholder=""Contrase√±a""
          value={contrasena}
          onChange={(e) => setContrasena(e.target.value)}
        />
        {errores.contrasena && <p>{errores.contrasena}</p>}

        <input
          type=""password""
          placeholder=""Confirmar contrase√±a""
          value={confirmarContrasena}
          onChange={(e) => setConfirmarContrasena(e.target.value)}
        />
        {errores.confirmarContrasena && <p>{errores.confirmarContrasena}</p>}

        <select value={pais} onChange={(e) => setPais(e.target.value)}>
          <option value="""">Selecciona un pa√≠s</option>
          <option value=""Ecuador"">Ecuador</option>
          <option value=""Colombia"">Colombia</option>
          <option value=""M√©xico"">M√©xico</option>
        </select>
        {errores.pais && <p>{errores.pais}</p>}

        <button type=""submit"">Enviar</button>
      </form>

      {mensajeExito && <h3>{mensajeExito}</h3>}
    </div>
  );
}"
NG14E1Lh,Untitled,der_robert,JavaScript,Monday 21st of July 2025 02:08:26 PM CDT,"function toggleEditForm() {
    const form = document.getElementById('edit-form');
    const isHidden = window.getComputedStyle(form).display === 'none';
    form.style.display = isHidden ? 'block' : 'none';
}"
xmyt2JH2,Untitled,der_robert,JavaScript,Monday 21st of July 2025 01:57:40 PM CDT,"function showTooltip(element, islandName, username) {
    try {
        const tooltip = document.getElementById('tooltip');
        const mapContainer = document.querySelector('.map-container');

        const containerRect = mapContainer.getBoundingClientRect();
        const pointLeft = element.offsetLeft;
        const pointTop = element.offsetTop;

        // Tooltip-Inhalt
        tooltip.textContent = `${islandName} (${username})`;
        tooltip.style.display = 'block';
        tooltip.style.position = 'absolute';

        // Tooltip vor√ºbergehend sichtbar machen f√ºr Messung
        tooltip.style.visibility = 'hidden';
        tooltip.style.left = '0px';
        tooltip.style.top = '0px';

        // Gr√∂√üe berechnen
        const tooltipWidth = tooltip.offsetWidth;
        const tooltipHeight = tooltip.offsetHeight;

        // Zielposition (oberhalb des Punkts, zentriert)
        let tooltipLeft = pointLeft + element.offsetWidth / 2 - tooltipWidth / 2;
        let tooltipTop = pointTop - tooltipHeight - 10;

        // Randkorrekturen (linker und rechter Rand)
        const padding = 5;
        if (tooltipLeft < padding) {
            tooltipLeft = padding;
        } else if (tooltipLeft + tooltipWidth > mapContainer.offsetWidth - padding) {
            tooltipLeft = mapContainer.offsetWidth - tooltipWidth - padding;
        }

        // Falls Tooltip oberhalb des Containers rausragen w√ºrde ‚Üí darunter anzeigen
        if (tooltipTop < padding) {
            tooltipTop = pointTop + element.offsetHeight + 10;
        }

        // Endg√ºltig setzen
        tooltip.style.left = `${tooltipLeft}px`;
        tooltip.style.top = `${tooltipTop}px`;
        tooltip.style.visibility = 'visible';

        console.log(`Tooltip f√ºr ${username} bei x=${tooltipLeft}px, y=${tooltipTop}px`);
    } catch (e) {
        console.error('Error in showTooltip:', e);
    }
}
"
zmd7siCT,great OK 1 figura,max2201111,Python,Monday 21st of July 2025 01:27:29 PM CDT,"import time
import copy
from typing import List, Tuple, Optional, Dict, Set

class ChessEngine:
    def __init__(self):
        # Z√°kladn√≠ nastaven√≠
        self.board = [['' for _ in range(8)] for _ in range(8)]
        self.white_to_move = True
        self.castling_rights = {'K': True, 'Q': True, 'k': True, 'q': True}
        self.en_passant = None
        self.halfmove_clock = 0
        self.fullmove_number = 1
        
        # Hodnoty figur pro evaluaci
        self.piece_values = {
            'P': 100, 'N': 320, 'B': 330, 'R': 500, 'Q': 900, 'K': 20000,
            'p': -100, 'n': -320, 'b': -330, 'r': -500, 'q': -900, 'k': -20000,
            'A': 1200, 'a': -1200,  # Amazonka (k≈Ø≈à + d√°ma)
            'C': 800, 'c': -800,    # Cyril (k≈Ø≈à + vƒõ≈æ)
            'E': 650, 'e': -650     # Eve (k≈Ø≈à + st≈ôelec)
        }
        
        # Historie tah≈Ø pro v√Ωpis cesty
        self.move_history = []
        self.position_history = []
        
    def load_fen(self, fen: str):
        """"""Naƒçte pozici z FEN stringu""""""
        # Nejd≈ô√≠ve vyma≈æ ≈°achovnici
        self.board = [['' for _ in range(8)] for _ in range(8)]
        
        parts = fen.split()
        
        # Parsov√°n√≠ pozice
        rows = parts[0].split('/')
        for row_idx, row in enumerate(rows):
            if row_idx >= 8:  # Ochrana proti p≈ô√≠li≈° mnoha ≈ô√°dk≈Øm
                break
            col_idx = 0
            for char in row:
                if col_idx >= 8:  # Ochrana proti p≈ôekroƒçen√≠ sloupc≈Ø
                    break
                if char.isdigit():
                    # Pr√°zdn√° pole
                    empty_squares = int(char)
                    for _ in range(empty_squares):
                        if col_idx < 8:
                            self.board[row_idx][col_idx] = ''
                            col_idx += 1
                else:
                    self.board[row_idx][col_idx] = char
                    col_idx += 1
        
        # Na tahu
        self.white_to_move = parts[1] == 'w'
        
        # Ro≈°√°da
        castling = parts[2] if len(parts) > 2 else '-'
        self.castling_rights = {
            'K': 'K' in castling,
            'Q': 'Q' in castling,
            'k': 'k' in castling,
            'q': 'q' in castling
        }
        
        # En passant
        self.en_passant = parts[3] if len(parts) > 3 and parts[3] != '-' else None
        
        # Poƒçet tah≈Ø
        self.halfmove_clock = int(parts[4]) if len(parts) > 4 else 0
        self.fullmove_number = int(parts[5]) if len(parts) > 5 else 1
        
    def to_fen(self) -> str:
        """"""P≈ôevede aktu√°ln√≠ pozici na FEN string""""""
        # Pozice
        fen_rows = []
        for row in self.board:
            fen_row = ''
            empty_count = 0
            for cell in row:
                if cell == '':
                    empty_count += 1
                else:
                    if empty_count > 0:
                        fen_row += str(empty_count)
                        empty_count = 0
                    fen_row += cell
            if empty_count > 0:
                fen_row += str(empty_count)
            fen_rows.append(fen_row)
        
        board_fen = '/'.join(fen_rows)
        
        # Na tahu
        active_color = 'w' if self.white_to_move else 'b'
        
        # Ro≈°√°da
        castling = ''
        if self.castling_rights['K']: castling += 'K'
        if self.castling_rights['Q']: castling += 'Q'
        if self.castling_rights['k']: castling += 'k'
        if self.castling_rights['q']: castling += 'q'
        if not castling: castling = '-'
        
        # En passant
        en_passant = self.en_passant if self.en_passant else '-'
        
        return f""{board_fen} {active_color} {castling} {en_passant} {self.halfmove_clock} {self.fullmove_number}""
    
    def print_board(self):
        """"""Vyp√≠≈°e ≈°achovnici v ASCII form√°tu""""""
        print(""  a b c d e f g h"")
        for i in range(8):
            print(f""{8-i} "", end="""")
            for j in range(8):
                piece = self.board[i][j]
                if piece == '':
                    piece = '.'
                print(f""{piece} "", end="""")
            print(f""{8-i}"")
        print(""  a b c d e f g h"")
        print()
    
    def is_white_piece(self, piece: str) -> bool:
        """"""Zjist√≠, zda je figura b√≠l√°""""""
        return piece.isupper()
    
    def get_piece_moves(self, row: int, col: int, check_castling: bool = True) -> List[Tuple[int, int]]:
        """"""Z√≠sk√° v≈°echny mo≈æn√© tahy pro figuru na dan√© pozici""""""
        piece = self.board[row][col]
        if piece == '':
            return []
        
        piece_type = piece.lower()
        is_white = self.is_white_piece(piece)
        moves = []
        
        if piece_type == 'p':
            # Pƒõ≈°ec
            direction = -1 if is_white else 1
            start_row = 6 if is_white else 1
            
            # Tah dop≈ôedu
            if 0 <= row + direction < 8 and self.board[row + direction][col] == '':
                moves.append((row + direction, col))
                # Dvojit√Ω tah z poƒç√°teƒçn√≠ pozice
                if row == start_row and self.board[row + 2 * direction][col] == '':
                    moves.append((row + 2 * direction, col))
            
            # Bran√≠ √∫hlop≈ô√≠ƒçnƒõ
            for dc in [-1, 1]:
                new_row, new_col = row + direction, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target != '' and self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
                    # En passant
                    elif self.en_passant and self.en_passant == f""{chr(ord('a') + new_col)}{8 - new_row}"":
                        moves.append((new_row, new_col))
        
        elif piece_type == 'r':
            # Vƒõ≈æ
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'n':
            # K≈Ø≈à
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'b':
            # St≈ôelec
            directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'q':
            # D√°ma
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
        
        elif piece_type == 'k':
            # Kr√°l
            king_moves = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in king_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
            
            # Ro≈°√°da - pouze pokud je povoleno kontrolovat (vyhneme se rekurzi)
            if check_castling and not self.is_in_check(is_white):
                # Kr√°tk√° ro≈°√°da
                castling_key = 'K' if is_white else 'k'
                if self.castling_rights[castling_key]:
                    if (self.board[row][col + 1] == '' and self.board[row][col + 2] == '' and
                        not self.is_square_attacked(row, col + 1, not is_white) and
                        not self.is_square_attacked(row, col + 2, not is_white)):
                        moves.append((row, col + 2))
                
                # Dlouh√° ro≈°√°da
                castling_key = 'Q' if is_white else 'q'
                if self.castling_rights[castling_key]:
                    if (self.board[row][col - 1] == '' and self.board[row][col - 2] == '' and
                        self.board[row][col - 3] == '' and
                        not self.is_square_attacked(row, col - 1, not is_white) and
                        not self.is_square_attacked(row, col - 2, not is_white)):
                        moves.append((row, col - 2))
        
        elif piece_type == 'a':  # Amazonka (k≈Ø≈à + d√°ma)
            # Tahy d√°my
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'c':  # Cyril (k≈Ø≈à + vƒõ≈æ)
            # Tahy vƒõ≈æe
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        elif piece_type == 'e':  # Eve (k≈Ø≈à + st≈ôelec)
            # Tahy st≈ôelce
            directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
            for dr, dc in directions:
                for i in range(1, 8):
                    new_row, new_col = row + i * dr, col + i * dc
                    if not (0 <= new_row < 8 and 0 <= new_col < 8):
                        break
                    target = self.board[new_row][new_col]
                    if target == '':
                        moves.append((new_row, new_col))
                    else:
                        if self.is_white_piece(target) != is_white:
                            moves.append((new_row, new_col))
                        break
            # Tahy konƒõ
            knight_moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]
            for dr, dc in knight_moves:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < 8 and 0 <= new_col < 8:
                    target = self.board[new_row][new_col]
                    if target == '' or self.is_white_piece(target) != is_white:
                        moves.append((new_row, new_col))
        
        return moves
    
    def is_square_attacked(self, row: int, col: int, by_white: bool) -> bool:
        """"""Zjist√≠, zda je pole napaden√© danou barvou""""""
        for r in range(8):
            for c in range(8):
                piece = self.board[r][c]
                if piece != '' and self.is_white_piece(piece) == by_white:
                    # Nekontroluji ro≈°√°du p≈ôi detekci napaden√≠ (vyhneme se rekurzi)
                    moves = self.get_piece_moves(r, c, check_castling=False)
                    if (row, col) in moves:
                        return True
        return False
    
    def find_king(self, is_white: bool) -> Tuple[int, int]:
        """"""Najde kr√°le dan√© barvy""""""
        king = 'K' if is_white else 'k'
        for r in range(8):
            for c in range(8):
                if self.board[r][c] == king:
                    return (r, c)
        return (-1, -1)  # Kr√°l nenalezen
    
    def is_in_check(self, is_white: bool) -> bool:
        """"""Zjist√≠, zda je kr√°l v ≈°achu""""""
        king_pos = self.find_king(is_white)
        if king_pos == (-1, -1):
            return False
        return self.is_square_attacked(king_pos[0], king_pos[1], not is_white)
    
    def make_move(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int]) -> bool:
        """"""Provede tah a vr√°t√≠ True, pokud je leg√°ln√≠""""""
        from_row, from_col = from_pos
        to_row, to_col = to_pos
        
        piece = self.board[from_row][from_col]
        if piece == '':
            return False
        
        is_white = self.is_white_piece(piece)
        if is_white != self.white_to_move:
            return False
        
        # Zkontroluj, zda je tah v seznamu mo≈æn√Ωch tah≈Ø
        possible_moves = self.get_piece_moves(from_row, from_col)
        if (to_row, to_col) not in possible_moves:
            return False
        
        # Ulo≈æ p≈Øvodn√≠ stav
        original_board = copy.deepcopy(self.board)
        original_castling = copy.deepcopy(self.castling_rights)
        original_en_passant = self.en_passant
        
        # Proveƒè tah
        captured_piece = self.board[to_row][to_col]
        self.board[to_row][to_col] = piece
        self.board[from_row][from_col] = ''
        
        # Speci√°ln√≠ tahy
        piece_type = piece.lower()
        
        # En passant
        if piece_type == 'p' and self.en_passant and f""{chr(ord('a') + to_col)}{8 - to_row}"" == self.en_passant:
            if is_white:
                self.board[to_row + 1][to_col] = ''
            else:
                self.board[to_row - 1][to_col] = ''
        
        # Ro≈°√°da
        if piece_type == 'k' and abs(to_col - from_col) == 2:
            if to_col > from_col:  # Kr√°tk√° ro≈°√°da
                self.board[from_row][7] = ''
                self.board[from_row][5] = 'R' if is_white else 'r'
            else:  # Dlouh√° ro≈°√°da
                self.board[from_row][0] = ''
                self.board[from_row][3] = 'R' if is_white else 'r'
        
        # Aktualizace en passant
        if piece_type == 'p' and abs(to_row - from_row) == 2:
            self.en_passant = f""{chr(ord('a') + from_col)}{8 - (from_row + to_row) // 2}""
        else:
            self.en_passant = None
        
        # Aktualizace ro≈°√°dov√Ωch pr√°v
        if piece_type == 'k':
            if is_white:
                self.castling_rights['K'] = False
                self.castling_rights['Q'] = False
            else:
                self.castling_rights['k'] = False
                self.castling_rights['q'] = False
        elif piece_type == 'r':
            if from_row == 0 or from_row == 7:
                if from_col == 0:
                    key = 'Q' if from_row == 7 else 'q'
                    self.castling_rights[key] = False
                elif from_col == 7:
                    key = 'K' if from_row == 7 else 'k'
                    self.castling_rights[key] = False
        
        # Zkontroluj, zda vlastn√≠ kr√°l nen√≠ v ≈°achu
        if self.is_in_check(is_white):
            # Vra≈• p≈Øvodn√≠ stav
            self.board = original_board
            self.castling_rights = original_castling
            self.en_passant = original_en_passant
            return False
        
        # Tah je leg√°ln√≠
        self.white_to_move = not self.white_to_move
        if not self.white_to_move:
            self.fullmove_number += 1
        
        if captured_piece or piece_type == 'p':
            self.halfmove_clock = 0
        else:
            self.halfmove_clock += 1
        
        return True
    
    def undo_move(self, from_pos: Tuple[int, int], to_pos: Tuple[int, int], 
                  captured_piece: str, old_castling: dict, old_en_passant: str,
                  old_halfmove: int, old_fullmove: int, was_white_to_move: bool):
        """"""Vr√°t√≠ tah zpƒõt""""""
        from_row, from_col = from_pos
        to_row, to_col = to_pos
        
        piece = self.board[to_row][to_col]
        self.board[from_row][from_col] = piece
        self.board[to_row][to_col] = captured_piece
        
        # Vr√°cen√≠ speci√°ln√≠ch tah≈Ø
        piece_type = piece.lower()
        
        # Ro≈°√°da
        if piece_type == 'k' and abs(to_col - from_col) == 2:
            if to_col > from_col:  # Kr√°tk√° ro≈°√°da
                self.board[from_row][7] = 'R' if self.is_white_piece(piece) else 'r'
                self.board[from_row][5] = ''
            else:  # Dlouh√° ro≈°√°da
                self.board[from_row][0] = 'R' if self.is_white_piece(piece) else 'r'
                self.board[from_row][3] = ''
        
        # En passant
        if piece_type == 'p' and old_en_passant and f""{chr(ord('a') + to_col)}{8 - to_row}"" == old_en_passant:
            if self.is_white_piece(piece):
                self.board[to_row + 1][to_col] = 'p'
            else:
                self.board[to_row - 1][to_col] = 'P'
        
        self.castling_rights = old_castling
        self.en_passant = old_en_passant
        self.halfmove_clock = old_halfmove
        self.fullmove_number = old_fullmove
        self.white_to_move = was_white_to_move
    
    def get_all_legal_moves(self) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:
        """"""Z√≠sk√° v≈°echny leg√°ln√≠ tahy pro aktu√°ln√≠ho hr√°ƒçe""""""
        legal_moves = []
        
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece != '' and self.is_white_piece(piece) == self.white_to_move:
                    moves = self.get_piece_moves(row, col)
                    for to_row, to_col in moves:
                        # Zkop√≠ruj stav
                        original_state = self.save_state()
                        
                        # Zkus tah
                        if self.make_move((row, col), (to_row, to_col)):
                            legal_moves.append(((row, col), (to_row, to_col)))
                        
                        # Vra≈• stav
                        self.restore_state(original_state)
        
        return legal_moves
    
    def save_state(self):
        """"""Ulo≈æ√≠ aktu√°ln√≠ stav hry""""""
        return {
            'board': copy.deepcopy(self.board),
            'white_to_move': self.white_to_move,
            'castling_rights': copy.deepcopy(self.castling_rights),
            'en_passant': self.en_passant,
            'halfmove_clock': self.halfmove_clock,
            'fullmove_number': self.fullmove_number
        }
    
    def restore_state(self, state):
        """"""Obnov√≠ ulo≈æen√Ω stav hry""""""
        self.board = state['board']
        self.white_to_move = state['white_to_move']
        self.castling_rights = state['castling_rights']
        self.en_passant = state['en_passant']
        self.halfmove_clock = state['halfmove_clock']
        self.fullmove_number = state['fullmove_number']
    
    def evaluate_position(self) -> int:
        """"""Ohodnot√≠ pozici (pozitivn√≠ hodnoty pro b√≠l√©ho, negativn√≠ pro ƒçern√©ho)""""""
        score = 0
        
        for row in range(8):
            for col in range(8):
                piece = self.board[row][col]
                if piece != '':
                    score += self.piece_values.get(piece, 0)
        
        return score
    
    def is_checkmate(self) -> bool:
        """"""Zjist√≠, zda je mat""""""
        if not self.is_in_check(self.white_to_move):
            return False
        
        legal_moves = self.get_all_legal_moves()
        return len(legal_moves) == 0
    
    def is_stalemate(self) -> bool:
        """"""Zjist√≠, zda je pat""""""
        if self.is_in_check(self.white_to_move):
            return False
        
        legal_moves = self.get_all_legal_moves()
        return len(legal_moves) == 0
    
    def is_game_over(self) -> Tuple[bool, str]:
        """"""Zjist√≠, zda je hra u konce""""""
        if self.is_checkmate():
            winner = ""ƒåern√Ω"" if self.white_to_move else ""B√≠l√Ω""
            return True, f""Mat! Vyhr√°l {winner}.""
        elif self.is_stalemate():
            return True, ""Pat! Rem√≠za.""
        elif self.halfmove_clock >= 100:
            return True, ""Rem√≠za podle pravidla 50 tah≈Ø.""
        
        return False, """"
    
    def minimax(self, depth: int, alpha: int, beta: int, maximizing: bool, 
                path: List[str]) -> Tuple[int, List[str]]:
        """"""Minimax algoritmus s alfa-beta pruningem""""""
        game_over, result = self.is_game_over()
        
        if game_over:
            if ""Mat"" in result:
                if ""B√≠l√Ω"" in result:
                    return (999999 - len(path), path)
                else:
                    return (-999999 + len(path), path)
            else:  # Pat nebo rem√≠za
                return (0, path)
        
        if depth == 0:
            return (self.evaluate_position(), path)
        
        legal_moves = self.get_all_legal_moves()
        
        if maximizing:
            max_eval = float('-inf')
            best_path = path
            
            for move in legal_moves:
                # Ulo≈æ stav
                original_state = self.save_state()
                
                # Proveƒè tah
                self.make_move(move[0], move[1])
                move_notation = f""{chr(ord('a') + move[0][1])}{8 - move[0][0]}-{chr(ord('a') + move[1][1])}{8 - move[1][0]}""
                new_path = path + [move_notation]
                
                eval_score, eval_path = self.minimax(depth - 1, alpha, beta, False, new_path)
                
                if eval_score > max_eval:
                    max_eval = eval_score
                    best_path = eval_path
                
                # Vra≈• stav
                self.restore_state(original_state)
                
                alpha = max(alpha, eval_score)
                if beta <= alpha:
                    break
            
            return (max_eval, best_path)
        
        else:
            min_eval = float('inf')
            best_path = path
            
            for move in legal_moves:
                # Ulo≈æ stav
                original_state = self.save_state()
                
                # Proveƒè tah
                self.make_move(move[0], move[1])
                move_notation = f""{chr(ord('a') + move[0][1])}{8 - move[0][0]}-{chr(ord('a') + move[1][1])}{8 - move[1][0]}""
                new_path = path + [move_notation]
                
                eval_score, eval_path = self.minimax(depth - 1, alpha, beta, True, new_path)
                
                if eval_score < min_eval:
                    min_eval = eval_score
                    best_path = eval_path
                
                # Vra≈• stav
                self.restore_state(original_state)
                
                beta = min(beta, eval_score)
                if beta <= alpha:
                    break
            
            return (min_eval, best_path)
    
    def find_best_move(self, max_depth: int = 10) -> Optional[List[str]]:
        """"""Najde nejlep≈°√≠ tah pomoc√≠ iterativn√≠ho prohlouben√≠""""""
        print(f""Hled√°n√≠ nejlep≈°√≠ho tahu (maxim√°ln√≠ hloubka: {max_depth})..."")
        print(f""Na tahu: {'B√≠l√Ω' if self.white_to_move else 'ƒåern√Ω'}"")
        print()
        
        best_path = None
        
        for depth in range(1, max_depth + 1):
            start_time = time.time()
            
            score, path = self.minimax(depth, float('-inf'), float('inf'), True, [])
            
            end_time = time.time()
            elapsed = end_time - start_time
            
            print(f""Hloubka {depth}: sk√≥re {score}, ƒças {elapsed:.3f}s"")
            
            best_path = path
            
            # Pokud byl nalezen mat, skonƒçi
            if abs(score) > 900000:
                print(f""Nalezen mat v {len(path)} taz√≠ch!"")
                break
        
        return best_path
    
    def play_game(self, initial_fen: str = None, max_depth: int = 6):
        """"""Spust√≠ hru s automatick√Ωm hran√≠m""""""
        if initial_fen:
            self.load_fen(initial_fen)
        else:
            # Standardn√≠ poƒç√°teƒçn√≠ pozice
            self.load_fen(""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"")
        
        print(""=== ≈†ACHOV√ù ENGINE S NESTANDARDN√çMI FIGURAMI ==="")
        print(""Legenda figur:"")
        print(""A/a = Amazonka (K≈Ø≈à + D√°ma)"")
        print(""C/c = Cyril (K≈Ø≈à + Vƒõ≈æ)"")
        print(""E/e = Eve (K≈Ø≈à + St≈ôelec)"")
        print()
        
        print(""Poƒç√°teƒçn√≠ pozice:"")
        print(f""FEN: {self.to_fen()}"")
        self.print_board()
        
        move_count = 0
        
        while True:
            game_over, result = self.is_game_over()
            if game_over:
                print(result)
                break
            
            move_count += 1
            print(f""\n=== TAH {move_count} ==="")
            
            best_path = self.find_best_move(max_depth)
            
            if not best_path:
                print(""≈Ω√°dn√Ω tah nenalezen!"")
                break
            
            # Simuluj celou cestu k matu
            print(f""\nNalezen√° cesta k matu ({len(best_path)} tah≈Ø):"")
            
            current_engine = ChessEngine()
            current_engine.restore_state(self.save_state())
            
            # Vyp√≠≈° poƒç√°teƒçn√≠ pozici
            print(f""\nPoƒç√°teƒçn√≠ pozice:"")
            print(f""FEN: {current_engine.to_fen()}"")
            current_engine.print_board()
            
            for i, move_notation in enumerate(best_path):
                # Parsuj a proveƒè tah
                from_pos = (8 - int(move_notation[1]), ord(move_notation[0]) - ord('a'))
                to_pos = (8 - int(move_notation[4]), ord(move_notation[3]) - ord('a'))
                
                if not current_engine.make_move(from_pos, to_pos):
                    print(""Chyba p≈ôi prov√°dƒõn√≠ tahu!"")
                    break
                
                # Teƒè vyp√≠≈° pozici PO proveden√≠ tahu
                print(f""\nTah {i + 1}: {move_notation}"")
                print(f""FEN: {current_engine.to_fen()}"")
                current_engine.print_board()
                
                game_over, result = current_engine.is_game_over()
                if game_over:
                    print(f""{result}"")
                    return
            
            # Proveƒè prvn√≠ tah z nalezen√© cesty
            if best_path:
                first_move = best_path[0]
                from_pos = (8 - int(first_move[1]), ord(first_move[0]) - ord('a'))
                to_pos = (8 - int(first_move[4]), ord(first_move[3]) - ord('a'))
                
                if self.make_move(from_pos, to_pos):
                    print(f""\nProveden tah: {first_move}"")
                else:
                    print(""Chyba p≈ôi prov√°dƒõn√≠ prvn√≠ho tahu!"")
                    break
            else:
                break

# Spu≈°tƒõn√≠ enginu
if __name__ == ""__main__"":
    engine = ChessEngine()
    
    # Testovac√≠ pozice - zaj√≠mavƒõj≈°√≠ matov√Ω probl√©m
    # ƒåern√Ω kr√°l v rohu, b√≠l√° Amazonka a kr√°l pro demonstraci s√≠ly Amazonky
    test_fen = ""k7/8/2A5/8/8/8/8/K7 w - - 0 1""
    test_fen = ""7A/8/8/8/8/8/6k1/1K6 w - - 0 1""


    test_fen = ""8/8/8/8/8/5BN1/5K1k/8 b - - 0 1""
    
    print(f""Pou≈æ√≠v√°m testovac√≠ pozici s Amazonkou: {test_fen}"")
    print(""Pozice: ƒåern√Ω kr√°l na a8, B√≠l√° Amazonka na c6, B√≠l√Ω kr√°l na a1"")
    engine.play_game(test_fen, max_depth=14)"
MsANdGT4,DDA 0.01,Str1k3rch0,Python,Monday 21st of July 2025 01:27:01 PM CDT,"import cv2
import pytesseract
import os
import re
import time
import torch
import torch.nn as nn
import torchvision.transforms as transforms
from PIL import Image, ImageTk
import tkinter as tk
from tkinter import ttk

# ---------------------------
# CRNN Model Definition
# ---------------------------
class BidirectionalLSTM(nn.Module):
    def __init__(self, nIn, nHidden, nOut):
        super(BidirectionalLSTM, self).__init__()
        self.rnn = nn.LSTM(nIn, nHidden, bidirectional=True)
        self.linear = nn.Linear(nHidden * 2, nOut)

    def forward(self, input):
        recurrent, _ = self.rnn(input)
        T, b, h = recurrent.size()
        t_rec = recurrent.view(T * b, h)
        output = self.linear(t_rec)
        output = output.view(T, b, -1)
        return output

class CRNN(nn.Module):
    def __init__(self, imgH, nc, nclass, nh):
        super(CRNN, self).__init__()
        assert imgH % 16 == 0, 'imgH must be a multiple of 16'
        ks = [3, 3, 3, 3, 3, 3, 2]
        ps = [1, 1, 1, 1, 1, 1, 0]
        ss = [1, 1, 1, 1, 1, 1, 1]
        nm = [64, 128, 256, 256, 512, 512, 512]

        cnn = nn.Sequential()
        def convRelu(i, batchNormalization=False):
            nIn = nc if i == 0 else nm[i - 1]
            nOut = nm[i]
            cnn.add_module('conv{0}'.format(i), nn.Conv2d(nIn, nOut, ks[i], ss[i], ps[i]))
            if batchNormalization:
                cnn.add_module('batchnorm{0}'.format(i), nn.BatchNorm2d(nOut))
            cnn.add_module('relu{0}'.format(i), nn.ReLU(True))

        convRelu(0)
        cnn.add_module('pooling0', nn.MaxPool2d(2, 2))  # 64x(H/2)x(W/2)
        convRelu(1)
        cnn.add_module('pooling1', nn.MaxPool2d(2, 2))  # 128x(H/4)x(W/4)
        convRelu(2, True)
        convRelu(3)
        cnn.add_module('pooling2', nn.MaxPool2d((2, 2), (2, 1), (0, 1)))  # 256x(H/8)x(W/4)
        convRelu(4, True)
        convRelu(5)
        cnn.add_module('pooling3', nn.MaxPool2d((2, 2), (2, 1), (0, 1)))  # 512x(H/16)x(W/4)
        convRelu(6, True)

        self.cnn = cnn
        self.rnn = nn.Sequential(
            BidirectionalLSTM(512, nh, nh),
            BidirectionalLSTM(nh, nh, nclass))

    def forward(self, input):
        conv = self.cnn(input)
        b, c, h, w = conv.size()
        assert h == 1, ""the height of conv must be 1""
        conv = conv.squeeze(2)  # b x c x w
        conv = conv.permute(2, 0, 1)  # w x b x c
        output = self.rnn(conv)  # w x b x nclass
        return output

# ---------------------------
# Utility Functions
# ---------------------------
CHARS = '0123456789'
NUM_CLASSES = len(CHARS) + 1  # for CTC blank

def decode_preds(preds):
    # CTC greedy decode
    preds = preds.softmax(2)
    max_probs, idx = preds.max(2)
    idx = idx.transpose(1, 0).contiguous().view(-1)
    raw_chars = [CHARS[i] if i < len(CHARS) else '' for i in idx]
    # collapse repeats
    result = []
    prev = ''
    for ch in raw_chars:
        if ch != prev:
            result.append(ch)
            prev = ch
    return ''.join(result).replace('', '')

# ---------------------------
# GUI Application
# ---------------------------
class OCRApp:
    def __init__(self, model_path='crnn.pth'):
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model = CRNN(32, 1, NUM_CLASSES, 256).to(self.device)
        if os.path.exists(model_path):
            self.model.load_state_dict(torch.load(model_path, map_location=self.device))
        self.model.eval()

        self.transform = transforms.Compose([
            transforms.Resize((32, 100)),
            transforms.ToTensor(),
            transforms.Normalize((0.5,), (0.5,))
        ])

        self.cap = cv2.VideoCapture(0)
        self.root = tk.Tk()
        self.root.title('CRNN OCR')
        self._build_gui()
        self.pending = False
        self.last_frame = None
        self.root.after(30, self.update)
        self.root.mainloop()

    def _build_gui(self):
        self.frame_cam = ttk.Label(self.root)
        self.frame_cam.grid(row=0, column=0)
        self.frame_proc = ttk.Label(self.root)
        self.frame_proc.grid(row=0, column=1)

        self.info_label = ttk.Label(self.root, text='Waiting...')
        self.info_label.grid(row=1, column=0, columnspan=2)

        btn_frame = ttk.Frame(self.root)
        btn_frame.grid(row=2, column=0, columnspan=2)
        ttk.Button(btn_frame, text='‚úÖ', command=lambda: self.feedback(True)).pack(side='left')
        ttk.Button(btn_frame, text='‚ùå', command=lambda: self.feedback(False)).pack(side='left')
        self.entry = ttk.Entry(self.root)
        self.submit = ttk.Button(self.root, text='Submit', command=self.manual)
        self.entry.grid(row=3, column=0)
        self.submit.grid(row=3, column=1)
        self.entry.grid_remove(); self.submit.grid_remove()

    def feedback(self, correct):
        # placeholder for active learning
        self.pending = not correct
        if not correct:
            self.entry.grid(); self.submit.grid()
        else:
            self.entry.grid_remove(); self.submit.grid_remove()

    def manual(self):
        val = self.entry.get()
        # save correction...
        self.entry.delete(0, 'end')
        self.entry.grid"
0TUsHVSr,Modelo M√©todos Padarosa,estevaorada,C#,Monday 21st of July 2025 12:26:47 PM CDT,"        public DataTable ListarTudo()
        {
            string comando = ""SELECT id, nome_completo, email FROM usuarios"";

            Banco.ConexaoBanco conexaoBD = new Banco.ConexaoBanco();
            MySqlConnection con = conexaoBD.ObterConexao();
            MySqlCommand cmd = new MySqlCommand(comando, con);
           
            cmd.Prepare();
            // Declarar tabela que ir√° receber o resultado:
            DataTable tabela = new DataTable();
            // Preencher a tabela com o resultado da consulta
            tabela.Load(cmd.ExecuteReader());
            conexaoBD.Desconectar(con);
            return tabela;
        }

        public bool Cadastrar()
        {
            string comando = ""INSERT INTO usuarios (nome_completo, email, senha) "" +
                ""VALUES (@nome_completo, @email, @senha)"";
            Banco.ConexaoBanco conexaoBD = new Banco.ConexaoBanco();
            MySqlConnection con = conexaoBD.ObterConexao();
            MySqlCommand cmd = new MySqlCommand(comando, con);
            cmd.Parameters.AddWithValue(""@nome_completo"", NomeCompleto);
            cmd.Parameters.AddWithValue(""@email"", Email);
            // Obter o hash:
            string hashsenha = EasyEncryption.SHA.ComputeSHA256Hash(Senha);
            cmd.Parameters.AddWithValue(""@senha"", hashsenha);
            cmd.Prepare();
            try
            {
                if (cmd.ExecuteNonQuery() == 0)
                {
                    conexaoBD.Desconectar(con);
                    return false;
                }
                else
                {
                    conexaoBD.Desconectar(con);
                    return true;
                }
            }
            catch
            {
                conexaoBD.Desconectar(con);
                return false;
            }
        }"
fN8psZ9T,ExceptionGroup: unhandled errors in a TaskGroup (2 sub-exceptions),basedcount_bot,Python,Monday 21st of July 2025 12:23:10 PM CDT,"  + Exception Group Traceback (most recent call last):
  |   File ""/home/gmktec-server/Bots/basedcount_bot/backup_and_cheating/back_up_and_cheating.py"", line 65, in backup_and_cheating_runner
  |     async with asyncio.TaskGroup() as tg:
  |   File ""/home/gmktec-server/.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/asyncio/taskgroups.py"", line 145, in __aexit__
  |     raise me from None
  | ExceptionGroup: unhandled errors in a TaskGroup (2 sub-exceptions)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File ""/home/gmktec-server/Bots/basedcount_bot/backup_and_cheating/back_up_and_cheating.py"", line 29, in send_cheating_report
    |     async with get_mongo_client() as mongo_client:
    |   File ""/home/gmktec-server/.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/contextlib.py"", line 210, in __aenter__
    |     return await anext(self.gen)
    |            ^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/utility_functions.py"", line 88, in get_mongo_client
    |     cluster = AsyncIOMotorClient(getenv(""MONGO_PASS""))
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/motor/core.py"", line 171, in __init__
    |     delegate = self.__delegate_class__(*args, **kwargs)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/synchronous/mongo_client.py"", line 780, in __init__
    |     res = uri_parser.parse_uri(
    |           ^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/uri_parser.py"", line 558, in parse_uri
    |     nodes = dns_resolver.get_hosts()
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/srv_resolver.py"", line 140, in get_hosts
    |     _, nodes = self._get_srv_response_and_hosts(True)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/srv_resolver.py"", line 120, in _get_srv_response_and_hosts
    |     results = self._resolve_uri(encapsulate_errors)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/srv_resolver.py"", line 114, in _resolve_uri
    |     raise ConfigurationError(str(exc)) from None
    | pymongo.errors.ConfigurationError: The resolution lifetime expired after 21.128 seconds: Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.
    +---------------- 2 ----------------
    | Traceback (most recent call last):
    |   File ""/home/gmktec-server/Bots/basedcount_bot/backup_and_cheating/back_up_and_cheating.py"", line 52, in backup
    |     async with get_mongo_client() as mongo_client:
    |   File ""/home/gmktec-server/.local/share/uv/python/cpython-3.11.12-linux-x86_64-gnu/lib/python3.11/contextlib.py"", line 210, in __aenter__
    |     return await anext(self.gen)
    |            ^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/utility_functions.py"", line 88, in get_mongo_client
    |     cluster = AsyncIOMotorClient(getenv(""MONGO_PASS""))
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/motor/core.py"", line 171, in __init__
    |     delegate = self.__delegate_class__(*args, **kwargs)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/synchronous/mongo_client.py"", line 780, in __init__
    |     res = uri_parser.parse_uri(
    |           ^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/uri_parser.py"", line 558, in parse_uri
    |     nodes = dns_resolver.get_hosts()
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/srv_resolver.py"", line 140, in get_hosts
    |     _, nodes = self._get_srv_response_and_hosts(True)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/srv_resolver.py"", line 120, in _get_srv_response_and_hosts
    |     results = self._resolve_uri(encapsulate_errors)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/pymongo/srv_resolver.py"", line 114, in _resolve_uri
    |     raise ConfigurationError(str(exc)) from None
    | pymongo.errors.ConfigurationError: The resolution lifetime expired after 21.125 seconds: Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.; Server Do53:127.0.0.53@53 answered The DNS operation timed out.
    +------------------------------------
"
jrnDDdRr,–§–∏–Ω–∞–ª,Str1k3rch0,Python,Monday 21st of July 2025 12:12:58 PM CDT,"import cv2
import pytesseract
import os
import re
import time
import joblib
import numpy as np
from datetime import datetime
import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk

# Load trained model
from sklearn.ensemble import RandomForestClassifier
model = joblib.load(""model.pkl"")
IMG_SIZE = (32, 32)

# Tesseract config
pytesseract.pytesseract.tesseract_cmd = r""C:\\Program Files\\Tesseract-OCR\\tesseract.exe""
custom_config = r'--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789'

# Output directories
output_dir = ""detections""
os.makedirs(output_dir, exist_ok=True)

feedback_file = ""feedback_log.csv""
if not os.path.exists(feedback_file):
    with open(feedback_file, ""w"") as f:
        f.write(""number,confidence,label,timestamp\n"")

# Globals
pending_feedback = False
freeze_mode = False
last_detected_number = None
last_detection_time = 0
cooldown_seconds = 5
current_number = None
current_confidence = None
last_saved_image = None

# Active Learning
new_data = []
ACTIVE_BATCH = 10

# GUI setup
root = tk.Tk()
root.title(""Digit Detector (Tesseract + Model)"")
root.geometry(""1280x650"")
root.grid_columnconfigure(0, weight=1)
root.grid_columnconfigure(1, weight=1)
root.grid_rowconfigure(0, weight=1)

label_camera = ttk.Label(root)
label_camera.grid(row=0, column=0, padx=5, pady=5, sticky=""nsew"")

label_processed = ttk.Label(root)
label_processed.grid(row=0, column=1, padx=5, pady=5, sticky=""nsew"")

label_info = ttk.Label(root, text=""üß† Waiting for number..."", font=('Arial', 14))
label_info.grid(row=1, column=0, columnspan=2)

# Entry and button for manual correction
entry_corrected = ttk.Entry(root)
btn_submit_correction = ttk.Button(root, text=""üì§ Submit Correction"", command=lambda: submit_manual_correction(entry_corrected.get()))
entry_corrected.grid(row=2, column=0, padx=5, pady=5)
btn_submit_correction.grid(row=2, column=1, padx=5, pady=5)
entry_corrected.grid_remove()
btn_submit_correction.grid_remove()

# Feedback buttons + Cancel & Retry
btn_correct = ttk.Button(root, text=""‚úÖ Correct"", command=lambda: save_feedback(True))
btn_correct.grid(row=3, column=0, pady=10)
btn_wrong = ttk.Button(root, text=""‚ùå Wrong"", command=lambda: save_feedback(False))
btn_wrong.grid(row=3, column=1, pady=10)
btn_cancel = ttk.Button(root, text=""üõë Cancel Freeze"", command=lambda: cancel_freeze())
btn_cancel.grid(row=4, column=0, pady=5)
btn_retry = ttk.Button(root, text=""üîÅ Retry"", command=lambda: force_retry())
btn_retry.grid(row=4, column=1, pady=5)

# Capture
cap = cv2.VideoCapture(0)

def predict_with_model(image):
    img_resized = cv2.resize(image, IMG_SIZE)
    img_flat = img_resized.flatten().reshape(1, -1)
    prediction = model.predict(img_flat)[0]
    return str(prediction)

def show_feedback_prompt():
    label_info.config(text=f""‚ùì Was {current_number} correct? Use ‚úÖ / ‚ùå"")

def cancel_freeze():
    global freeze_mode, pending_feedback
    freeze_mode = False
    pending_feedback = False
    entry_corrected.grid_remove()
    btn_submit_correction.grid_remove()
    label_info.config(text=""‚èπÔ∏è Freeze canceled. Resuming live..."")

def force_retry():
    global last_detection_time
    # allow immediate retry on last_saved_image
    last_detection_time = 0
    label_info.config(text=""üîÅ Retry triggered."")

def save_feedback(correct):
    global current_number, current_confidence, last_saved_image, pending_feedback, freeze_mode, new_data
    if not current_number or last_saved_image is None:
        return
    ts = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    label = ""correct"" if correct else ""wrong""
    with open(feedback_file, ""a"") as f:
        f.write(f""{current_number},{current_confidence},{label},{ts}\n"")
    # save color crop if correct
    folder = current_number if correct else 'unlabeled'
    os.makedirs(os.path.join(""dataset"", folder), exist_ok=True)
    cv2.imwrite(os.path.join(""dataset"", folder, f""{ts}.png""), last_saved_image)
    if correct:
        # active learning
        new_data.append((last_saved_image, int(current_number)))
        if len(new_data) >= ACTIVE_BATCH:
            retrain_model()
        pending_feedback = False
        freeze_mode = False
        label_info.config(text=f""‚úÖ Saved: {current_number} as {label}"")
    else:
        # enter freeze+retry mode
        freeze_mode = True
        pending_feedback = True
        label_info.config(text=""‚ùå Wrong detection. Awaiting retry or correction."")
        entry_corrected.delete(0, tk.END)
        entry_corrected.grid()
        btn_submit_correction.grid()

def submit_manual_correction(val):
    global current_number, last_saved_image, pending_feedback, freeze_mode, new_data
    val = val.strip()
    if not (val.isdigit() or val.lower()=='nothing'):
        label_info.config(text=""‚ö†Ô∏è Enter a valid number or 'nothing'"")
        return
    ts = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    folder = val if val.isdigit() else 'unlabeled'
    os.makedirs(os.path.join(""dataset"", folder), exist_ok=True)
    cv2.imwrite(os.path.join(""dataset"", folder, f""{ts}.png""), last_saved_image)
    with open(feedback_file, ""a"") as f:
        f.write(f""{val},{current_confidence},manual,{ts}\n"")
    # active learning
    if val.isdigit():
        new_data.append((last_saved_image, int(val)))
        if len(new_data) >= ACTIVE_BATCH:
            retrain_model()
    pending_feedback = False
    freeze_mode = False
    entry_corrected.grid_remove()
    btn_submit_correction.grid_remove()
    label_info.config(text=f""üì§ Manual correction saved: {val}"")

def retrain_model():
    global new_data, model
    X, y = [], []
    for lbl in os.listdir(""dataset""):
        if lbl == 'unlabeled': continue
        p = os.path.join(""dataset"", lbl)
        for fn in os.listdir(p):
            img = cv2.imread(os.path.join(p, fn), cv2.IMREAD_GRAYSCALE)
            if img is None: continue
            X.append(cv2.resize(img, IMG_SIZE).flatten())
            y.append(int(lbl))
    for img_arr, lbl in new_data:
        X.append(cv2.resize(img_arr, IMG_SIZE).flatten())
        y.append(lbl)
    if X:
        clf = RandomForestClassifier(n_estimators=100)
        clf.fit(np.array(X), np.array(y))
        joblib.dump(clf, ""model.pkl"")
        new_data = []
        label_info.config(text=""ü§ñ Model retrained."")

def update_frames():
    global last_detected_number, last_detection_time
    global current_number, current_confidence, last_saved_image, pending_feedback, freeze_mode

    # Freeze+Retry loop
    if freeze_mode and pending_feedback and last_saved_image is not None:
        # only retry when cooldown passed
        if time.time() - last_detection_time > cooldown_seconds:
            # re-run OCR
            data = pytesseract.image_to_data(last_saved_image, config=custom_config,
                                             output_type=pytesseract.Output.DICT)
            num, conf = None, 0
            for i, txt in enumerate(data['text']):
                txt = txt.strip()
                try: c = int(data['conf'][i])
                except: c = 0
                if re.fullmatch(r'\d{1,3}', txt) and c >= 60:
                    num, conf = txt, c
                    break
            if num:
                current_number, current_confidence = num, conf
                label_info.config(text=f""üîÅ Retry: Was {num} correct?"")
            last_detection_time = time.time()
        root.after(100, update_frames)
        return

    # Live capture
    ret, frame = cap.read()
    if not ret:
        root.after(30, update_frames); return

    frame = cv2.resize(frame, (640, 480))
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (3,3),0)
    _, thresh = cv2.threshold(blur,170,255,cv2.THRESH_BINARY)

    # skip empty
    if cv2.countNonZero(thresh) < 500:
        label_info.config(text=""üß† No number detected"")
        root.after(30, update_frames); return

    # OCR detection
    data = pytesseract.image_to_data(thresh, config=custom_config,
                                     output_type=pytesseract.Output.DICT)
    num, conf = None, 0
    for i, txt in enumerate(data['text']):
        txt = txt.strip()
        try: c = int(data['conf'][i])
        except: c = 0
        if re.fullmatch(r'\d{1,3}', txt) and c >= 60:
            num, conf = txt, c
            break

    if num and (num != last_detected_number or time.time() - last_detection_time > cooldown_seconds):
        timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        cv2.imwrite(os.path.join(output_dir, f""detected_{timestamp}.png""), frame)
        last_saved_image = thresh.copy()
        last_detected_number = num
        last_detection_time = time.time()
        current_number, current_confidence = num, conf
        pending_feedback = True
        show_feedback_prompt()

    # update UI
    cam_img = cv2.resize(frame, (600, 450))
    proc_img = cv2.resize(thresh, (600, 450))
    imgtk1 = ImageTk.PhotoImage(Image.fromarray(cv2.cvtColor(cam_img, cv2.COLOR_BGR2RGB)))
    imgtk2 = ImageTk.PhotoImage(Image.fromarray(proc_img))
    label_camera.config(image=imgtk1); label_camera.imgtk = imgtk1
    label_processed.config(image=imgtk2); label_processed.imgtk = imgtk2

    root.after(30, update_frames)

update_frames()
root.mainloop()
cap.release()
cv2.destroyAllWindows()
"
R6mHzaVR,Digit Detector App 1.1,Str1k3rch0,Python,Monday 21st of July 2025 12:06:03 PM CDT,"import cv2
import pytesseract
import os
import re
import time
import joblib
import numpy as np
from datetime import datetime
import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
from sklearn.ensemble import RandomForestClassifier

# Constants
IMG_SIZE = (32, 32)
COOLDOWN = 5  # seconds
MIN_OCR_CONF = 60
MIN_ML_CONF = 50
ACTIVE_LEARNING_BATCH = 10
SCAN_INTERVAL = 2.0  # seconds between retries
MIN_WHITE_PIXELS = 500  # skip low-content frames
DATASET_DIR = ""dataset""
MODEL_PATH = ""model.pkl""

class DigitDetectorApp:
    def __init__(self, model_path=MODEL_PATH):
        # Load or initialize model
        if os.path.exists(model_path):
            self.model = joblib.load(model_path)
        else:
            self.model = RandomForestClassifier(n_estimators=100)
        self.new_data = []

        # Tesseract config
        pytesseract.pytesseract.tesseract_cmd = r""C:\\Program Files\\Tesseract-OCR\\tesseract.exe""
        self.ocr_config = r'--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789'

        # Output dirs
        os.makedirs(""detections"", exist_ok=True)
        os.makedirs(DATASET_DIR, exist_ok=True)
        self.feedback_file = ""feedback_log.csv""
        if not os.path.exists(self.feedback_file):
            with open(self.feedback_file, ""w"") as f:
                f.write(""number,confidence,label,timestamp\n"")

        # State
        self.pending_feedback = False
        self.freeze_mode = False
        self.manual_mode = False
        self.last_detected = None
        self.last_time = 0
        self.last_scan_time = 0
        self.history = []
        self.current = None
        self.current_frame_raw = None
        self.current_thresh = None

        # Setup GUI
        self.root = tk.Tk()
        self.root.title(""Digit Detector App"")
        self.root.geometry(""1280x650"")
        self._build_gui()

        # Video capture
        self.cap = cv2.VideoCapture(0)
        self.update_frames()
        self.root.mainloop()

    def _build_gui(self):
        frame = self.root
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(0, weight=1)

        self.label_cam = ttk.Label(frame)
        self.label_cam.grid(row=0, column=0, padx=5, pady=5, sticky=""nsew"")
        self.label_proc = ttk.Label(frame)
        self.label_proc.grid(row=0, column=1, padx=5, pady=5, sticky=""nsew"")

        self.label_info = ttk.Label(frame, text=""üß† Waiting for valid frame..."", font=('Arial', 14))
        self.label_info.grid(row=1, column=0, columnspan=2)

        btn_frame = ttk.Frame(frame)
        btn_frame.grid(row=2, column=0, columnspan=2)
        ttk.Button(btn_frame, text=""‚úÖ Correct"", command=lambda: self.save_feedback(True)).pack(side=""left"", padx=5)
        ttk.Button(btn_frame, text=""‚ùå Wrong"", command=lambda: self.save_feedback(False)).pack(side=""left"", padx=5)
        ttk.Button(btn_frame, text=""üõë Cancel Freeze"", command=self.cancel_freeze).pack(side=""left"", padx=5)
        ttk.Button(btn_frame, text=""üîÅ Retry"", command=self.force_retry).pack(side=""left"", padx=5)
        ttk.Button(btn_frame, text=""‚ü≤ Undo"", command=self.undo).pack(side=""left"", padx=5)

        self.entry = ttk.Entry(frame)
        self.btn_submit = ttk.Button(frame, text=""Submit"", command=lambda: self.manual_correction(self.entry.get()))
        self.entry.grid(row=3, column=0, padx=5, pady=5)
        self.btn_submit.grid(row=3, column=1, padx=5, pady=5)
        self.entry.grid_remove(); self.btn_submit.grid_remove()

    def cancel_freeze(self):
        self.freeze_mode = False
        self.pending_feedback = False
        self.manual_mode = False
        self.entry.grid_remove(); self.btn_submit.grid_remove()
        self.label_info.config(text=""‚èπÔ∏è Freeze canceled. Resuming live detection."")

    def force_retry(self):
        self.last_scan_time = 0
        self.label_info.config(text=""üîÅ Retry triggered."")

    def preprocess(self, frame):
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        blur = cv2.GaussianBlur(gray, (3,3),0)
        _, thresh = cv2.threshold(blur,170,255,cv2.THRESH_BINARY)
        return thresh

    def predict_ocr(self, img):
        data = pytesseract.image_to_data(img, config=self.ocr_config, output_type=pytesseract.Output.DICT)
        for i, txt in enumerate(data['text']):
            txt = txt.strip()
            try: conf = int(data['conf'][i])
            except: conf = 0
            if re.fullmatch(r'\d{1,3}', txt) and conf >= MIN_OCR_CONF:
                return txt, conf
        return None, 0

    def predict_ml(self, img):
        resized = cv2.resize(img, IMG_SIZE).flatten().reshape(1,-1)
        pred = self.model.predict(resized)[0]
        conf = int(max(self.model.predict_proba(resized)[0]) *100) if hasattr(self.model,'predict_proba') else 0
        return str(pred), conf

    def ensemble_predict(self, img):
        # Only use OCR; disable ML fallback to avoid false positives on empty or noisy frames
        num_o, conf_o = self.predict_ocr(img)
        # Accept only OCR predictions with sufficient confidence
        if num_o and conf_o >= MIN_OCR_CONF:
            return num_o, conf_o
        return None, 0

    def save_feedback(self, correct):
        if not self.current: return
        num, conf, thresh = self.current
        ts = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        if correct:
            # log and unfreeze
            with open(self.feedback_file,'a') as f:
                f.write(f""{num},{conf},correct,{ts}\n"")
            folder=os.path.join(DATASET_DIR,num)
            os.makedirs(folder,exist_ok=True)
            cv2.imwrite(os.path.join(folder,f""{ts}.png""), self.current_frame_raw)
            self.new_data.append((thresh,int(num)))
            if len(self.new_data)>=ACTIVE_LEARNING_BATCH: self.retrain_model()
            self.freeze_mode=False; self.pending_feedback=False; self.manual_mode=False
            self.entry.grid_remove(); self.btn_submit.grid_remove()
            self.label_info.config(text=f""‚úÖ Saved correct: {num}"")
        else:
            # freeze and enter manual mode
            self.freeze_mode=True; self.pending_feedback=True; self.manual_mode=False
            self.label_info.config(text=f""‚ùå Wrong. Will retry or await correction."")

    def manual_correction(self,val):
        if not self.current: return
        val=val.strip()
        if not(val.isdigit() or val.lower()=='nothing'):
            self.label_info.config(text=""‚ö†Ô∏è Enter digit or 'nothing'"")
            return
        num_old,conf_old,thresh=self.current
        ts=datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        folder=val if val.isdigit() else 'unlabeled'
        path=os.path.join(DATASET_DIR,folder)
        os.makedirs(path,exist_ok=True)
        cv2.imwrite(os.path.join(path,f""{ts}.png""),self.current_frame_raw)
        with open(self.feedback_file,'a') as f:
            f.write(f""{val},{conf_old},manual,{ts}\n"")
        # update
        self.current=(val,conf_old,self.current_thresh)
        self.freeze_mode=False; self.pending_feedback=False; self.manual_mode=False
        self.entry.grid_remove(); self.btn_submit.grid_remove()
        self.label_info.config(text=f""üì§ Correction saved: {val}"")

    def undo(self):
        if not self.history: return
        num,ts,thresh=self.history.pop()
        self.label_info.config(text=f""‚ü≤ Undone: {num} at {ts}"")
        self.display_images(thresh)

    def retrain_model(self):
        X,y=[],[]
        for label in os.listdir(DATASET_DIR):
            if label=='unlabeled': continue
            for fn in os.listdir(os.path.join(DATASET_DIR,label)):
                img=cv2.imread(os.path.join(DATASET_DIR,label,fn),cv2.IMREAD_GRAYSCALE)
                if img is None: continue
                X.append(cv2.resize(img,IMG_SIZE).flatten()); y.append(int(label))
        for img,lbl in self.new_data:
            X.append(img.flatten()); y.append(lbl)
        if X:
            self.model=RandomForestClassifier(n_estimators=100)
            self.model.fit(np.array(X),np.array(y))
            joblib.dump(self.model,MODEL_PATH)
            self.new_data.clear()
            self.label_info.config(text=""ü§ñ Model retrained."")

    def display_images(self,proc):
        frame=cv2.resize(self.last_frame,(600,450))
        cam=ImageTk.PhotoImage(Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB)))
        pr=ImageTk.PhotoImage(Image.fromarray(proc))
        self.label_cam.config(image=cam); self.label_cam.imgtk=cam
        self.label_proc.config(image=pr); self.label_proc.imgtk=pr

    def update_frames(self):
        now=time.time()
        # Freeze & retry
        if self.freeze_mode and self.current and not self.manual_mode:
            if now-self.last_scan_time>SCAN_INTERVAL:
                # retry detection on saved thresh
                num,conf=self.ensemble_predict(self.current_thresh)
                self.current=(num,conf,self.current_thresh)
                self.label_info.config(text=f""üîÅ Retry: Was {num} correct?"")
                self.last_scan_time=now
                # after first retry allow manual
                self.manual_mode=True
                self.entry.grid(); self.btn_submit.grid()
            self.display_images(self.current[2])
            self.root.after(30,self.update_frames)
            return

        # live capture
        ret,frame=self.cap.read()
        if not ret:
            self.root.after(30,self.update_frames); return
        self.last_frame=frame
        proc=self.preprocess(frame)
        self.current_frame_raw=frame.copy()
        self.current_thresh=proc

        # skip low-content
        if cv2.countNonZero(proc)<MIN_WHITE_PIXELS:
            self.label_info.config(text=""üì∑ Weak image, skipping."")
            self.display_images(proc)
            self.root.after(30,self.update_frames)
            return

        # initial detection
        if not self.pending_feedback:
            # validate detection
            num_o,conf_o=self.predict_ocr(proc)
            num_m,conf_m=self.predict_ml(proc)
            valid_o=num_o and conf_o>=MIN_OCR_CONF
            valid_m=num_m and conf_m>=MIN_ML_CONF
            if not(valid_o or valid_m):
                self.root.after(30,self.update_frames); return
            num,conf=(num_o,conf_o) if valid_o and conf_o>=conf_m else (num_m,conf_m)
            # freeze and prompt
            ts=datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
            cv2.imwrite(f""detections/detected_{ts}.png"",frame)
            self.history.append((num,ts,proc))
            self.current=(num,conf,proc)
            self.last_detected, self.last_time = num, now
            self.pending_feedback=True; self.freeze_mode=True; self.manual_mode=False
            self.label_info.config(text=f""‚ùì Was {num} correct?"")
            self.entry.delete(0,tk.END); self.entry.grid(); self.btn_submit.grid()

        self.display_images(proc)
        self.root.after(30,self.update_frames)

if __name__==""__main__"":
    DigitDetectorApp()
"
JPTU1s8k,Digit Detector App 1.0,Str1k3rch0,Python,Monday 21st of July 2025 11:49:30 AM CDT,"import cv2
import pytesseract
import os
import re
import time
import joblib
import numpy as np
from datetime import datetime
import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
from sklearn.ensemble import RandomForestClassifier

# Constants
IMG_SIZE = (32, 32)
COOLDOWN = 5  # seconds
MIN_OCR_CONF = 60
MIN_ML_CONF = 50
ACTIVE_LEARNING_BATCH = 10
SCAN_INTERVAL = 2.0  # seconds between retries
MIN_WHITE_PIXELS = 500  # skip low-content frames
DATASET_DIR = ""dataset""
MODEL_PATH = ""model.pkl""

class DigitDetectorApp:
    def __init__(self, model_path=MODEL_PATH):
        # Load or initialize model
        if os.path.exists(model_path):
            self.model = joblib.load(model_path)
        else:
            self.model = RandomForestClassifier(n_estimators=100)
        self.new_data = []

        # Tesseract config
        pytesseract.pytesseract.tesseract_cmd = r""C:\\Program Files\\Tesseract-OCR\\tesseract.exe""
        self.ocr_config = r'--oem 3 --psm 6 -c tessedit_char_whitelist=0123456789'

        # Output dirs
        os.makedirs(""detections"", exist_ok=True)
        os.makedirs(DATASET_DIR, exist_ok=True)
        self.feedback_file = ""feedback_log.csv""
        if not os.path.exists(self.feedback_file):
            with open(self.feedback_file, ""w"") as f:
                f.write(""number,confidence,label,timestamp\n"")

        # State
        self.pending_feedback = False
        self.freeze_mode = False
        self.manual_mode = False
        self.last_detected = None
        self.last_time = 0
        self.last_scan_time = 0
        self.history = []
        self.current = None
        self.current_frame_raw = None
        self.current_thresh = None

        # Setup GUI
        self.root = tk.Tk()
        self.root.title(""Digit Detector App"")
        self.root.geometry(""1280x650"")
        self._build_gui()

        # Video capture
        self.cap = cv2.VideoCapture(0)
        self.update_frames()
        self.root.mainloop()

    def _build_gui(self):
        frame = self.root
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_columnconfigure(1, weight=1)
        frame.grid_rowconfigure(0, weight=1)

        self.label_cam = ttk.Label(frame)
        self.label_cam.grid(row=0, column=0, padx=5, pady=5, sticky=""nsew"")
        self.label_proc = ttk.Label(frame)
        self.label_proc.grid(row=0, column=1, padx=5, pady=5, sticky=""nsew"")

        self.label_info = ttk.Label(frame, text=""üß† Waiting for valid frame..."", font=('Arial', 14))
        self.label_info.grid(row=1, column=0, columnspan=2)

        btn_frame = ttk.Frame(frame)
        btn_frame.grid(row=2, column=0, columnspan=2)
        ttk.Button(btn_frame, text=""‚úÖ Correct"", command=lambda: self.save_feedback(True)).pack(side=""left"", padx=5)
        ttk.Button(btn_frame, text=""‚ùå Wrong"", command=lambda: self.save_feedback(False)).pack(side=""left"", padx=5)
        ttk.Button(btn_frame, text=""üõë Cancel Freeze"", command=self.cancel_freeze).pack(side=""left"", padx=5)
        ttk.Button(btn_frame, text=""üîÅ Retry"", command=self.force_retry).pack(side=""left"", padx=5)
        ttk.Button(btn_frame, text=""‚ü≤ Undo"", command=self.undo).pack(side=""left"", padx=5)

        self.entry = ttk.Entry(frame)
        self.btn_submit = ttk.Button(frame, text=""Submit"", command=lambda: self.manual_correction(self.entry.get()))
        self.entry.grid(row=3, column=0, padx=5, pady=5)
        self.btn_submit.grid(row=3, column=1, padx=5, pady=5)
        self.entry.grid_remove(); self.btn_submit.grid_remove()

    def cancel_freeze(self):
        self.freeze_mode = False
        self.pending_feedback = False
        self.manual_mode = False
        self.entry.grid_remove(); self.btn_submit.grid_remove()
        self.label_info.config(text=""‚èπÔ∏è Freeze canceled. Resuming live detection."")

    def force_retry(self):
        self.last_scan_time = 0
        self.label_info.config(text=""üîÅ Retry triggered."")

    def preprocess(self, frame):
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        blur = cv2.GaussianBlur(gray, (3,3),0)
        _, thresh = cv2.threshold(blur,170,255,cv2.THRESH_BINARY)
        return thresh

    def predict_ocr(self, img):
        data = pytesseract.image_to_data(img, config=self.ocr_config, output_type=pytesseract.Output.DICT)
        for i, txt in enumerate(data['text']):
            txt = txt.strip()
            try: conf = int(data['conf'][i])
            except: conf = 0
            if re.fullmatch(r'\d{1,3}', txt) and conf >= MIN_OCR_CONF:
                return txt, conf
        return None, 0

    def predict_ml(self, img):
        resized = cv2.resize(img, IMG_SIZE).flatten().reshape(1,-1)
        pred = self.model.predict(resized)[0]
        conf = int(max(self.model.predict_proba(resized)[0]) *100) if hasattr(self.model,'predict_proba') else 0
        return str(pred), conf

    def ensemble_predict(self, img):
        # Validate thresholds
        num_o, conf_o = self.predict_ocr(img)
        num_m, conf_m = self.predict_ml(img)
        valid_o = num_o and conf_o >= MIN_OCR_CONF
        valid_m = num_m and conf_m >= MIN_ML_CONF
        if not(valid_o or valid_m):
            return None, 0
        if valid_o and conf_o>=conf_m:
            return num_o, conf_o
        return num_m, conf_m

    def save_feedback(self, correct):
        if not self.current: return
        num, conf, thresh = self.current
        ts = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        if correct:
            # log and unfreeze
            with open(self.feedback_file,'a') as f:
                f.write(f""{num},{conf},correct,{ts}\n"")
            folder=os.path.join(DATASET_DIR,num)
            os.makedirs(folder,exist_ok=True)
            cv2.imwrite(os.path.join(folder,f""{ts}.png""), self.current_frame_raw)
            self.new_data.append((thresh,int(num)))
            if len(self.new_data)>=ACTIVE_LEARNING_BATCH: self.retrain_model()
            self.freeze_mode=False; self.pending_feedback=False; self.manual_mode=False
            self.entry.grid_remove(); self.btn_submit.grid_remove()
            self.label_info.config(text=f""‚úÖ Saved correct: {num}"")
        else:
            # freeze and enter manual mode
            self.freeze_mode=True; self.pending_feedback=True; self.manual_mode=False
            self.label_info.config(text=f""‚ùå Wrong. Will retry or await correction."")

    def manual_correction(self,val):
        if not self.current: return
        val=val.strip()
        if not(val.isdigit() or val.lower()=='nothing'):
            self.label_info.config(text=""‚ö†Ô∏è Enter digit or 'nothing'"")
            return
        num_old,conf_old,thresh=self.current
        ts=datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        folder=val if val.isdigit() else 'unlabeled'
        path=os.path.join(DATASET_DIR,folder)
        os.makedirs(path,exist_ok=True)
        cv2.imwrite(os.path.join(path,f""{ts}.png""),self.current_frame_raw)
        with open(self.feedback_file,'a') as f:
            f.write(f""{val},{conf_old},manual,{ts}\n"")
        # update
        self.current=(val,conf_old,self.current_thresh)
        self.freeze_mode=False; self.pending_feedback=False; self.manual_mode=False
        self.entry.grid_remove(); self.btn_submit.grid_remove()
        self.label_info.config(text=f""üì§ Correction saved: {val}"")

    def undo(self):
        if not self.history: return
        num,ts,thresh=self.history.pop()
        self.label_info.config(text=f""‚ü≤ Undone: {num} at {ts}"")
        self.display_images(thresh)

    def retrain_model(self):
        X,y=[],[]
        for label in os.listdir(DATASET_DIR):
            if label=='unlabeled': continue
            for fn in os.listdir(os.path.join(DATASET_DIR,label)):
                img=cv2.imread(os.path.join(DATASET_DIR,label,fn),cv2.IMREAD_GRAYSCALE)
                if img is None: continue
                X.append(cv2.resize(img,IMG_SIZE).flatten()); y.append(int(label))
        for img,lbl in self.new_data:
            X.append(img.flatten()); y.append(lbl)
        if X:
            self.model=RandomForestClassifier(n_estimators=100)
            self.model.fit(np.array(X),np.array(y))
            joblib.dump(self.model,MODEL_PATH)
            self.new_data.clear()
            self.label_info.config(text=""ü§ñ Model retrained."")

    def display_images(self,proc):
        frame=cv2.resize(self.last_frame,(600,450))
        cam=ImageTk.PhotoImage(Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB)))
        pr=ImageTk.PhotoImage(Image.fromarray(proc))
        self.label_cam.config(image=cam); self.label_cam.imgtk=cam
        self.label_proc.config(image=pr); self.label_proc.imgtk=pr

    def update_frames(self):
        now=time.time()
        # Freeze & retry
        if self.freeze_mode and self.current and not self.manual_mode:
            if now-self.last_scan_time>SCAN_INTERVAL:
                # retry detection on saved thresh
                num,conf=self.ensemble_predict(self.current_thresh)
                self.current=(num,conf,self.current_thresh)
                self.label_info.config(text=f""üîÅ Retry: Was {num} correct?"")
                self.last_scan_time=now
                # after first retry allow manual
                self.manual_mode=True
                self.entry.grid(); self.btn_submit.grid()
            self.display_images(self.current[2])
            self.root.after(30,self.update_frames)
            return

        # live capture
        ret,frame=self.cap.read()
        if not ret:
            self.root.after(30,self.update_frames); return
        self.last_frame=frame
        proc=self.preprocess(frame)
        self.current_frame_raw=frame.copy()
        self.current_thresh=proc

        # skip low-content
        if cv2.countNonZero(proc)<MIN_WHITE_PIXELS:
            self.label_info.config(text=""üì∑ Weak image, skipping."")
            self.display_images(proc)
            self.root.after(30,self.update_frames)
            return

        # initial detection
        if not self.pending_feedback:
            # validate detection
            num_o,conf_o=self.predict_ocr(proc)
            num_m,conf_m=self.predict_ml(proc)
            valid_o=num_o and conf_o>=MIN_OCR_CONF
            valid_m=num_m and conf_m>=MIN_ML_CONF
            if not(valid_o or valid_m):
                self.root.after(30,self.update_frames); return
            num,conf=(num_o,conf_o) if valid_o and conf_o>=conf_m else (num_m,conf_m)
            # freeze and prompt
            ts=datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
            cv2.imwrite(f""detections/detected_{ts}.png"",frame)
            self.history.append((num,ts,proc))
            self.current=(num,conf,proc)
            self.last_detected, self.last_time = num, now
            self.pending_feedback=True; self.freeze_mode=True; self.manual_mode=False
            self.label_info.config(text=f""‚ùì Was {num} correct?"")
            self.entry.delete(0,tk.END); self.entry.grid(); self.btn_submit.grid()

        self.display_images(proc)
        self.root.after(30,self.update_frames)

if __name__==""__main__"":
    DigitDetectorApp()
"
Lqph7Skd,Untitled,Josif_tepe,Python,Monday 21st of July 2025 11:49:14 AM CDT,"if __name__ == ""__main__"":

    mapa = {}
    for line in open(""input.txt"", ""r"", encoding='utf-8'):
        predmet, oseba, cena = line.split("","")

        if predmet not in mapa:
            mapa[predmet] = []

        mapa[predmet].append(int(cena))

    for key, val in mapa.items():
        if len(val) < 7:
            print(f""{key}  -  {val[-1] - val[0]}"")
        else:
            print(f""{key}  -  {val[-1] - val[-7]}"")






"
wBHJ4FZP,2.3I,GochiPC,Lua,Monday 21st of July 2025 11:44:19 AM CDT,"term.clear()
term.setCursorPos(1,1)
print(""Please wait..."")
sleep(3)
term.clear()
term.setCursorPos(1,1)
print(""Welcome to MineOS 2.3 Installer"")
print(""type start/exit"")
print(""warning if you have other os it will removes startup file"")
local choice = read()

if choice == ""start"" then
  print(""Please wait this will take secs"")
  sleep(1)
  shell.run(""delete startup.lua"")
  shell.run(""pastebin get JXtz0FbD startup.lua"")
  print(""rebooting..."")
  sleep(3)
  os.reboot()
elseif choice == ""exit"" then
  print(""exiting the installer"")
  return
else
  print(""Invalid option"")
end
"
z10qi2sL,2.3U,GochiPC,Lua,Monday 21st of July 2025 11:43:10 AM CDT,"local label = os.getComputerLabel()

if label == ""2.3"" then
  print(""You allready have this version "" .. label)
  return
end

if label == ""2.0"" or label == ""2.1"" or label == ""2.2"" then
    term.clear()
    term.setCursorPos(1,1)
    print(""Welcome to MineUpdater"")
    print(""please wait to update 2.3"")
    sleep(2)
    print(""removing old file"")
    shell.run(""delete startup.lua"")
    sleep(5)
    print(""installing new files"")
    sleep(2)
    shell.run(""pastebin get JXtz0FbD startup.lua"")
    sleep(2)
    print(""the update complete"")
    print(""please wait this will reboot"")
    sleep(4)
    os.reboot()
end

print(""you dont have MineOS2"")"
nXdwUgKJ,Seding OCI Wag Edge logs to specific bucket,dominusceo,Python,Monday 21st of July 2025 11:42:31 AM CDT,"#!/usr/bin/python
""""""
Autor: Ricardo Carrillo - ricardo.d.carrillo@oracle.com
Objetivo: Enviar logs desde un OCI WAF Edge a un bucket espec√≠fico 
Basado en la arquitectura disponible en https://docs.oracle.com/en/solutions/ingest-oci-waf-logs--func-events/index.html#GUID-27D34D72-8E5A-4D09-A968-A4059906A991

Sint√°xis de ejecucion: 
./python get_waf_edge_logs_api.py <region> <ocid_waf_policy> <ocid_compartment> <WAF_action_type> <demo_app_domain> <bucket_name>  <name_space>

Ejemplo de ejecuci√≥n:
./python get_waf_edge_logs_api.py eu-paris-1 ocid1.waaspolicy.oc1..aaaaaaaapl7akq2lrxmt6trzayjkhvweonok7dnkrfud2dcdwiylviekztq ocid1.compartment.oc1..aaaaaaaa5nflauus2d7wcdir5bk4nhad8ts4xlcox3ndxuetsm6icccjaryq ACCESS demo_app_domain waf-logs oci1od210mx
""""""
import oci
import sys
import json
from oci.signer import Signer
from datetime import datetime, timedelta
from urllib.parse import urlencode

VALID_LOG_TYPES = {""ACCESS"", ""DETECT"", ""BLOCK""}

def get_waf_edge_logs_and_upload(region, waf_policy_ocid, compartment_ocid, log_type,
                                  webapp_domain, bucket_name, namespace, custom_endpoint):

    if log_type.upper() not in VALID_LOG_TYPES:
        print(json.dumps({
            ""error"": ""Invalid log type"",
            ""valid_values"": list(VALID_LOG_TYPES)
        }, indent=2))
        sys.exit(1)

    config = oci.config.from_file()
    config[""region""] = region

    signer = Signer(
        tenancy=config[""tenancy""],
        user=config[""user""],
        fingerprint=config[""fingerprint""],
        private_key_file_location=config[""key_file""],
        pass_phrase=config.get(""pass_phrase"")
    )

    ## Obtener los logs desde WAF Edge
    base_endpoint = f""https://waas.{region}.oraclecloud.com""
    resource_path = f""/20181116/waasPolicies/{waf_policy_ocid}/wafLogs""
    now = datetime.utcnow()
    today = datetime.utcnow().date()
    yesterday = today - timedelta(days=1)
    time_start = datetime.combine(yesterday, datetime.min.time()).isoformat() + ""Z""
    time_end = datetime.combine(today, datetime.min.time()).isoformat() + ""Z""

    query_params = {
        ""logType"": log_type.upper(),
        ""timeObservedGreaterThanOrEqualTo"": time_start,
        ""timeObservedLessThan"": time_end,
        ""compartmentId"": compartment_ocid
    }

    query_string = urlencode(query_params)
    full_url = f""{base_endpoint}{resource_path}?{query_string}""

    session = oci._vendor.requests.Session()
    response = session.get(full_url, auth=signer)

    if response.status_code != 200:
        print(json.dumps({
            ""error"": f""HTTP {response.status_code}"",
            ""details"": response.text
        }, indent=2))
        return

    logs = response.json()
    json_data = json.dumps(logs, indent=2)

    ## Formato del prefijo: webapp_domain/YYYY/MM/DD/
    prefix = f""{webapp_domain}/{now.strftime('%Y')}/{now.strftime('%m')}/{now.strftime('%d')}""
    filename = f""{log_type.lower()}-logs-{now.strftime('%Y%m%dT%H%M%S')}.json""
    object_name = f""{prefix}/{filename}""

    ## Subir al bucket
    object_storage_client = oci.object_storage.ObjectStorageClient(config, signer=signer)
    object_storage_client.base_client.endpoint = custom_endpoint

    put_resp = object_storage_client.put_object(
        namespace_name=namespace,
        bucket_name=bucket_name,
        object_name=object_name,
        put_object_body=json_data.encode(""utf-8""),
        content_type=""application/json""
    )

    print(json.dumps({
        ""message"": ""Logs subidos correctamente"",
        ""bucket"": bucket_name,
        ""object_name"": object_name,
        ""etag"": put_resp.headers.get(""etag""),
        ""url"": f""{custom_endpoint}/n/{namespace}/b/{bucket_name}/o/{object_name.replace('/', '%2F')}""
    }, indent=2))

if __name__ == ""__main__"":
    if len(sys.argv) != 8:
        print(""Uso:"")
        print(""python get_waf_edge_logs_upload_custom.py <region> <waf_policy_ocid> <compartment_ocid> <log_type> <webapp_domain> <bucket_name> <namespace>"")
        print(""Ejemplo:"")
        print(""python get_waf_edge_logs_upload_custom.py eu-frankfurt-1 ocid1.waaspolicy... ocid1.compartment... ACCESS mywebapp mybucket mynamespace"")
        sys.exit(1)

    region = sys.argv[1]
    waf_ocid = sys.argv[2]
    compartment_ocid = sys.argv[3]
    log_type = sys.argv[4]
    webapp_domain = sys.argv[5]
    bucket_name = sys.argv[6]
    namespace = sys.argv[7]
    custom_endpoint = f""https://objectstorage.{region}.oraclecloud.com""

    get_waf_edge_logs_and_upload(region, waf_ocid, compartment_ocid, log_type,
                                  webapp_domain, bucket_name, namespace, custom_endpoint)
"
