id,title,username,language,date,content
E7cLtS82,"PyPtt get_post(boardkey, aid=Aid) Error",yehchge,Python,Thursday 19th of June 2025 12:45:43 AM CDT,"    [50] => [06.19 13:42:13][PyPtt][INFO] 推文 ... 成功
    [51] => Traceback (most recent call last):
    [52] =>   File ""push_ptt_article.py"", line 114, in verify
    [53] =>     post_info = PTTBot.get_post(BoardKey, aid=Aid)
    [54] =>   File ""/usr/local/lib/python3.8/dist-packages/PyPtt/PTT.py"", line 349, in get_post
    [55] =>     return _api_get_post.get_post(
    [56] =>   File ""/usr/local/lib/python3.8/dist-packages/PyPtt/_api_get_post.py"", line 53, in get_post
    [57] =>     if index > 0 and aid is not None:
    [58] => TypeError: '>' not supported between instances of 'NoneType' and 'int'
    [59] => [06.19 13:42:13][PyPtt][INFO] 登出
    [60] => [06.19 13:42:13][PyPtt][INFO] 登出 ... 成功"
VwPyFdcb,logs_helix,Friks12829,Lua,Thursday 19th of June 2025 12:32:44 AM CDT,"--[[-------------------------------------------------------------------------
Остальное
---------------------------------------------------------------------------]]
local category = ""Наручники""
local name = ""DC_LOG_HANDCUFFS""
local format = ""Игрок %s воткнул кляп игроку %s""
local hookName = ""OnHandcuffGag""	
DC_CORE:AddHook(category,  hookName, name, function(ply, target)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
			[2] = 
				{ 	
					target.Nick and target:Nick() or ""???"",
					target.SteamID and target:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		target.Nick and target:Nick() or ""???""
	)
end)

local format = ""Игрок %s закрыл глаза игроку %s""
local hookName = ""OnHandcuffBlindfold""	
DC_CORE:AddHook(category,  hookName, name, function(ply, target)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
			[2] = 
				{ 	
					target.Nick and target:Nick() or ""???"",
					target.SteamID and target:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		target.Nick and target:Nick() or ""???""
	)
end)

local format = ""Игрок %s начал тащить игрока %s""
local hookName = ""OnHandcuffStartDragging""	
DC_CORE:AddHook(category,  hookName, name, function(ply, target)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
			[2] = 
				{ 	
					target.Nick and target:Nick() or ""???"",
					target.SteamID and target:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		target.Nick and target:Nick() or ""???""
	)
end)

local format = ""Игрок %s перестал тащить игрока %s""
local hookName = ""OnHandcuffStopDragging""	
DC_CORE:AddHook(category,  hookName, name, function(ply, target)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
			[2] = 
				{ 	
					target.Nick and target:Nick() or ""???"",
					target.SteamID and target:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		target.Nick and target:Nick() or ""???""
	)
end)

local format = ""Игрок %s снял наручники с игрока %s""
local hookName = ""OnHandcuffUnTied""	
DC_CORE:AddHook(category,  hookName, name, function(ply, target)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
			[2] = 
				{ 	
					target.Nick and target:Nick() or ""???"",
					target.SteamID and target:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		target.Nick and target:Nick() or ""???""
	)
end)

local format = ""Игрок %s надель наручники на игрока %s""
local hookName = ""OnHandcuffed""	
DC_CORE:AddHook(category,  hookName, name, function(ply, target)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
			[2] = 
				{ 	
					target.Nick and target:Nick() or ""???"",
					target.SteamID and target:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		target.Nick and target:Nick() or ""???""
	)
end)

local format = ""Игрок %s порвал наручники""
local hookName = ""OnHandcuffBreak""	
DC_CORE:AddHook(category,  hookName, name, function(ply, target)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???""
	)
end)

local category = ""Чат""
local name = ""DC_LOG_CHAT""
local format = ""%s написал %s""
local hookName = DarkRP and 'PostPlayerSay' or 'PlayerSay'	
DC_CORE:AddHook(category,  hookName, name, function(ply, text)
    if not text then return end

	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		string.Trim(text)
	)
end)

local category = ""Анонимный чат""
local name = ""DC_LOG_ANONCHAT""
local format = ""%s написал %s""
local hookName = 'DC_AnonChat'	
DC_CORE:AddHook(category,  hookName, name, function(cmd, text, ply)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		string.Trim(text)
	)
end)

local category = ""Урон""
local name = ""DC_LOG_DAMAGE""
local format = ""%s нанес %s урона игроку %s с помощью %s""
local hookName = 'EntityTakeDamage'	
DC_CORE:AddHook(category,  hookName, name, function(ent, dmginfo)
	local attacker = dmginfo:GetAttacker()
	if ent:IsPlayer() and IsValid(attacker) and attacker:IsPlayer() then
		if dmginfo:GetDamage() < 8 then return end
		local inflictor = dmginfo:GetInflictor()
		DC_CORE:AddLog(category, hookName, format,
			{
				[1] = 
					{ 	
						ent.Nick and ent:Nick() or ""???"",
						ent.SteamID and ent:SteamID() or ""???""
					},
				[2] = 
					{ 	
						attacker.Nick and attacker:Nick() or ""???"",
						attacker.SteamID and attacker:SteamID() or ""???""
					},
			}, 
			attacker.Nick and attacker:Nick() or ""???"",
			math.Round(dmginfo:GetDamage()),
			ent.Nick and ent:Nick() or ""???"",
			inflictor and inflictor:IsValid() and inflictor:GetClass() or ""???""
		)
	end	
end)

local category = ""Пропы""
local name = ""DC_LOG_PROPS""
local format = ""%s заспавнил %s""
local hookName = 'PlayerSpawnProp'	
DC_CORE:AddHook(category,  hookName, name, function(ply, mdl)
	DC_CORE:AddLog(category, hookName, format,
		{
			[1] = 
				{ 	
					ply.Nick and ply:Nick() or ""???"",
					ply.SteamID and ply:SteamID() or ""???""
				},
		}, 
		ply.Nick and ply:Nick() or ""???"",
		mdl or ""??""
	)
end)

local category = ""Работы""
local name = ""DC_LOG_JOBS""
local format = ""%s поменял работу на %s с %s""
local hookName = 'OnPlayerChangedTeam'	
DC_CORE:AddHook(category,  hookName, name, function(ply, old, new)
	if IsValid(ply) then
		DC_CORE:AddLog(category, hookName, format,
			{
				[1] = 
					{ 	
						ply.Nick and ply:Nick() or ""???"",
						ply.SteamID and ply:SteamID() or ""???""
					},
			}, 
			ply.Nick and ply:Nick() or ""???"",
			team.GetName(new),
			team.GetName(old)
		)
	end
end)

local category = ""Инвентарь""
local name = ""DC_LOG_POCKET""
local format = ""%s поднял %s""
local hookName = 'onPocketItemAdded'	
DC_CORE:AddHook(category,  hookName, name, function(ply, ent)
	if IsValid(ply) then
		DC_CORE:AddLog(category, hookName, format,
			{
				[1] = 
					{ 	
						ply.Nick and ply:Nick() or ""???"",
						ply.SteamID and ply:SteamID() or ""???""
					},
			}, 
			ply.Nick and ply:Nick() or ""???"",
			ent:GetClass()
		)
	end
end)

local category = ""Персонажи""
local name = ""DC_LOG_CHARACTERS""
local format = ""Игрок %s создал персонажа %s""
local hookName = ""OnCharacterCreated""
DC_CORE:AddHook(category, hookName, name, function(client, character)
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:SteamName() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:SteamName() or ""???"",
        character:GetName() or ""???""
    )
end)

local format = ""Игрок %s загрузил персонажа %s""
local hookName = ""CharacterLoaded""
DC_CORE:AddHook(category, hookName, name, function(character)
    local client = character:GetPlayer()
    if IsValid(client) then
        DC_CORE:AddLog(category, hookName, format,
            {
                [1] = {
                    client:SteamName() or ""???"",
                    client:SteamID() or ""???""
                }
            },
            client:SteamName() or ""???"",
            character:GetName() or ""???""
        )
    end
end)

local format = ""Игрок %s удалил персонажа %s""
local hookName = ""PreCharacterDeleted""
DC_CORE:AddHook(category, hookName, name, function(client, character)
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:SteamName() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:SteamName() or ""???"",
        character:GetName() or ""???""
    )
end)

local category = ""Предметы""
local name = ""DC_LOG_ITEMS""
local format = ""Игрок %s использовал действие '%s' на предмете '%s' (#%s)""
local hookName = ""PlayerInteractItem""
DC_CORE:AddHook(category, hookName, name, function(client, action, item)
    if not IsValid(client) or not item then return end
    
    local itemID = isentity(item) and item.ixItemID or item
    local itemInstance = ix.item.instances[itemID]
    if not itemInstance then return end

    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        action or ""???"",
        itemInstance:GetName() or ""???"",
        itemInstance:GetID() or ""???""
    )
end)

local format = ""Игрок %s получил предмет '%s' (#%s)""
local hookName = ""InventoryItemAdded""
DC_CORE:AddHook(category, hookName, name, function(oldInv, inventory, item)
    if not inventory.owner or (oldInv and oldInv.owner == inventory.owner) then return end
    
    local character = ix.char.loaded[inventory.owner]
    if not character then return end
    
    local client = character:GetPlayer()
    if not IsValid(client) then return end

    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        item:GetName() or ""???"",
        item:GetID() or ""???""
    )
end)

local format = ""Игрок %s потерял предмет '%s' (#%s)""
local hookName = ""InventoryItemRemoved""
DC_CORE:AddHook(category, hookName, name, function(inventory, item)
    if not inventory.owner then return end
    
    local character = ix.char.loaded[inventory.owner]
    if not character then return end
    
    local client = character:GetPlayer()
    if not IsValid(client) then return end

    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        item:GetName() or ""???"",
        item:GetID() or ""???""
    )
end)

local category = ""Хранилище""
local name = ""DC_LOG_STORAGE""
local format = ""Игрок %s взял %s %s из '%s' (#%s) (осталось %s %s)""
local hookName = ""storageMoneyTake""
DC_CORE:AddHook(category, hookName, name, function(client, entity, amount, total)
    if not IsValid(client) or not IsValid(entity) then return end
    
    local name = entity.GetDisplayName and entity:GetDisplayName() or entity:GetName()
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        amount,
        ix.currency.plural,
        name,
        entity:GetInventory():GetID(),
        total,
        ix.currency.plural
    )
end)

local format = ""Игрок %s положил %s %s в '%s' (#%s) (теперь %s %s)""
local hookName = ""storageMoneyGive""
DC_CORE:AddHook(category, hookName, name, function(client, entity, amount, total)
    if not IsValid(client) or not IsValid(entity) then return end
    
    local name = entity.GetDisplayName and entity:GetDisplayName() or entity:GetName()
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        amount,
        ix.currency.plural,
        name,
        entity:GetInventory():GetID(),
        total,
        ix.currency.plural
    )
end)

local category = ""Плагины""
local name = ""DC_LOG_PLUGINS""
local format = ""Админ %s включил плагин %s для следующего перезапуска""
local hookName = ""pluginLoaded""
DC_CORE:AddHook(category, hookName, name, function(client, uniqueID)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        uniqueID or ""???""
    )
end)

local format = ""Админ %s выключил плагин %s для следующего перезапуска""
local hookName = ""pluginUnloaded""
DC_CORE:AddHook(category, hookName, name, function(client, uniqueID)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        uniqueID or ""???""
    )
end)

local category = ""Зоны""
local name = ""DC_LOG_AREAS""
local format = ""Админ %s создал зону %s""
local hookName = ""ixAreaAdd""
DC_CORE:AddHook(category, hookName, name, function(client, id)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        id or ""???""
    )
end)

local format = ""Админ %s удалил зону %s""
local hookName = ""ixAreaRemove""
DC_CORE:AddHook(category, hookName, name, function(client, id)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        id or ""???""
    )
end)

local category = ""Режим наблюдателя""
local name = ""DC_LOG_OBSERVER""
local format = ""Админ %s вошел в режим наблюдателя""
local hookName = ""observerEnter""
DC_CORE:AddHook(category, hookName, name, function(client)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???""
    )
end)

local format = ""Админ %s вышел из режима наблюдателя""
local hookName = ""observerExit""
DC_CORE:AddHook(category, hookName, name, function(client)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???""
    )
end)

local category = ""Сохранение пропов""
local name = ""DC_LOG_PERSISTENCE""
local format = ""Админ %s %s сохранение для '%s'""
local hookName = ""persist""
DC_CORE:AddHook(category, hookName, name, function(client, model, enabled)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        enabled and ""включил"" or ""выключил"",
        model or ""???""
    )
end)

local category = ""Спавн пропов""
local name = ""DC_LOG_PROPSPAWN""
local format = ""Игрок %s заспавнил проп '%s'""
local hookName = ""PlayerSpawnedProp""
DC_CORE:AddHook(category, hookName, name, function(client, model, entity)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        model or ""???""
    )
end)

local format = ""Игрок %s заспавнил эффект '%s'""
local hookName = ""PlayerSpawnedEffect""
DC_CORE:AddHook(category, hookName, name, function(client, model, entity)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        model or ""???""
    )
end)

local format = ""Игрок %s заспавнил регдолл '%s'""
local hookName = ""PlayerSpawnedRagdoll""
DC_CORE:AddHook(category, hookName, name, function(client, model, entity)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        model or ""???""
    )
end)

local format = ""Игрок %s заспавнил NPC '%s'""
local hookName = ""PlayerSpawnedNPC""
DC_CORE:AddHook(category, hookName, name, function(client, entity)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        entity:GetClass() or ""???""
    )
end)

local format = ""Игрок %s заспавнил оружие '%s'""
local hookName = ""PlayerSpawnedSWEP""
DC_CORE:AddHook(category, hookName, name, function(client, entity)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        entity:GetClass() or ""???""
    )
end)

local format = ""Игрок %s заспавнил энтити '%s'""
local hookName = ""PlayerSpawnedSENT""
DC_CORE:AddHook(category, hookName, name, function(client, entity)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        entity:GetClass() or ""???""
    )
end)

local format = ""Игрок %s заспавнил транспорт '%s'""
local hookName = ""PlayerSpawnedVehicle""
DC_CORE:AddHook(category, hookName, name, function(client, entity)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        entity:GetClass() or ""???""
    )
end)

local category = ""Панели""
local name = ""DC_LOG_PANEL""
local format = ""Админ %s добавил панель с URL '%s'""
local hookName = ""OnPanelAdd""
DC_CORE:AddHook(category, hookName, name, function(client, url, scale, brightness)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        url or ""???""
    )
end)

local format = ""Админ %s удалил панель(и) в радиусе %s""
local hookName = ""OnPanelRemove""
DC_CORE:AddHook(category, hookName, name, function(client, radius)
    if not IsValid(client) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                client:Name() or ""???"",
                client:SteamID() or ""???""
            }
        },
        client:Name() or ""???"",
        radius or ""???""
    )
end)

local category = ""SAM Команды""
local name = ""DC_LOG_SAM_CMDS""
local format = ""Админ %s %s команду %s""
local hookName = ""SAM.CommandAdded""
DC_CORE:AddHook(category, hookName, name, function(ply, cmd_name, cmd)
    if not IsValid(ply) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        ""добавил"",
        cmd_name or ""???""
    )
end)

local format = ""Админ %s %s команду %s""
local hookName = ""SAM.CommandModified""
DC_CORE:AddHook(category, hookName, name, function(ply, cmd_name, cmd)
    if not IsValid(ply) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        ""изменил"",
        cmd_name or ""???""
    )
end)

local format = ""Админ %s %s команду %s""
local hookName = ""SAM.CommandRemoved""
DC_CORE:AddHook(category, hookName, name, function(ply, cmd_name, cmd)
    if not IsValid(ply) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        ""удалил"",
        cmd_name or ""???""
    )
end)

local category = ""SAM Ранги""
local name = ""DC_LOG_SAM_RANKS""
local format = ""Админ %s изменил ранг игрока %s с %s на %s""
local hookName = ""SAM.ChangedPlayerRank""
DC_CORE:AddHook(category, hookName, name, function(ply, target, rank, old_rank)
    if not IsValid(ply) or not IsValid(target) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            },
            [2] = {
                target:Name() or ""???"",
                target:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        target:Name() or ""???"",
        old_rank or ""???"",
        rank or ""???""
    )
end)

local format = ""Админ %s %s разрешение %s для ранга %s""
local hookName = ""SAM.RankPermissionGiven""
DC_CORE:AddHook(category, hookName, name, function(ply, permission, rank)
    if not IsValid(ply) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        ""выдал"",
        permission or ""???"",
        rank or ""???""
    )
end)

local format = ""Админ %s %s разрешение %s у ранга %s""
local hookName = ""SAM.RankPermissionTaken""
DC_CORE:AddHook(category, hookName, name, function(ply, permission, rank)
    if not IsValid(ply) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        ""отозвал"",
        permission or ""???"",
        rank or ""???""
    )
end)

local format = ""Админ %s изменил наследование ранга %s на %s""
local hookName = ""SAM.ChangedInheritRank""
DC_CORE:AddHook(category, hookName, name, function(ply, rank, inherit)
    if not IsValid(ply) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        rank or ""???"",
        inherit or ""???""
    )
end)

local category = ""Защита пропов""
local name = ""DC_LOG_GPROTECT""
local format = ""Игрок %s добавил %s в историю отмены""
local hookName = ""gP:UndoAdded""
DC_CORE:AddHook(category, hookName, name, function(ply, ent)
    if not IsValid(ply) or not IsValid(ent) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        ent:GetClass() or ""???""
    )
end)

local format = ""Игрок %s добавил %s в очистку (тип: %s)""
local hookName = ""gP:CleanupAdded""
DC_CORE:AddHook(category, hookName, name, function(ply, ent, Type)
    if not IsValid(ply) or not IsValid(ent) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        ent:GetClass() or ""???"",
        Type or ""???""
    )
end)

local format = ""Игрок %s зарегистрировал клавишную привязку %s""
local hookName = ""gP:NumpadRegistered""
DC_CORE:AddHook(category, hookName, name, function(ply, name)
    if not IsValid(ply) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        name or ""???""
    )
end)

local category = ""Оружие""
local name = ""DC_LOG_WEAPONS""
local format = ""Игрок %s снял все оружие с игрока %s""
local hookName = ""PlayerStripWeapons""
DC_CORE:AddHook(category, hookName, name, function(ply)
    if not IsValid(ply) then return end
    
    DC_CORE:AddLog(category, hookName, format,
        {
            [1] = {
                ply:Name() or ""???"",
                ply:SteamID() or ""???""
            }
        },
        ply:Name() or ""???"",
        ply:Name() or ""???""
    )
end)"
weMbQtUj,flutter_paging_viewmodel_example_2,chayanforyou,Dart,Thursday 19th of June 2025 12:12:49 AM CDT,"class DoctorListViewModel extends StateNotifier<DoctorPagingState> {
  final DefaultQueryParams _param;

  DoctorListViewModel(this._param)
      : super(
          DoctorPagingState(
            pagingState: PagingState(),
          ),
        );

  String? _searchTerm;
  bool _isDisposed = false;

  @override
  void dispose() {
    _isDisposed = true;
    super.dispose();
  }

  /// Fetches the next page of data
  Future<void> fetchNextPage() async {
    final paging = state.pagingState;
    if (paging.isLoading) return;

    final newPaging = paging.copyWith(isLoading: true, error: null);
    state = state.copyWith(pagingState: newPaging);

    try {
      final newKey = paging.keys?.last == null ? 0 : paging.keys!.last + 1;
      final doctorResponse = await DoctorRepository.instance.getDoctors(
        employeeId: _param.employeeId,
        year: _param.year,
        month: _param.month,
        levelCode: _param.levelCode,
        page: newKey,
        term: _searchTerm,
        selectedOnly: _param.selectedOnly,
      );

      final doctorData = doctorResponse.data;

      final updatedPaging = paging.copyWith(
        pages: [...?paging.pages, doctorData.doctors?.content ?? []],
        keys: [...?paging.keys, newKey],
        hasNextPage: doctorData.doctors?.hasNext,
        isLoading: false,
      );

      state = state.copyWith(
        pagingState: updatedPaging,
        totalDoctors: doctorData.doctors?.totalElements ?? 0,
        selectedDoctors: doctorData.selectedDoctor ?? 0,
        approved: doctorData.approved ?? true,
        editable: doctorData.editable ?? false,
      );

      // trigger the status message listener
      doctorPlanApprovedNotifier.value = state.approved;
    } catch (error) {
      if (_isDisposed) return;
      final failedPaging = paging.copyWith(
        error: error,
        isLoading: false,
      );
      state = state.copyWith(pagingState: failedPaging);
    }
  }

  /// Updates search term and refreshes the list
  void updateSearchTerm(String searchTerm) {
    _searchTerm = searchTerm;
    refreshList();
  }

  /// Refreshes the list and fetches the first page
  void refreshList() {
    state = state.copyWith(
      pagingState: PagingState(),
      totalDoctors: 0,
      selectedDoctors: 0,
      approved: false,
    );
    fetchNextPage();
  }

  /// Method to toggle the selection of a Doctor
  void toggleSelection(DoctorData content) {
    final oldPaging = state.pagingState;
    int updatedSelectedCount = state.selectedDoctors;

    final updatedPages = oldPaging.pages?.map((page) {
      return page.map((c) {
        if (c.doctor?.id == content.doctor?.id) {
          final wasSelected = c.selected;
          final nowSelected = !wasSelected;

          if (nowSelected) {
            updatedSelectedCount++;
          } else {
            updatedSelectedCount--;
          }

          return c.copyWith(selected: nowSelected);
        }
        return c;
      }).toList();
    }).toList();

    state = state.copyWith(
      pagingState: oldPaging.copyWith(pages: updatedPages),
      selectedDoctors: updatedSelectedCount,
    );
  }
}

/// **Provider for ViewModel**
final doctorListViewModelProvider =
    StateNotifierProvider.family.autoDispose<DoctorListViewModel, DoctorPagingState, DefaultQueryParams>((ref, param) {
  return DoctorListViewModel(param);
});


// --------------------------------------------------


final doctorListState = ref.watch(doctorListViewModelProvider(_params));
final doctorListViewModel = ref.read(doctorListViewModelProvider(_params).notifier);

PagedListView<int, DoctorData>.separated(
  state: doctorListState.pagingState,
  fetchNextPage: doctorListViewModel.fetchNextPage,
  builderDelegate: PagedChildBuilderDelegate(
    itemBuilder: (context, item, index) {
      return DoctorListItem(
        doctorData: item,
        clickable: doctorListState.editable,
        onClick: () => _toggleSelection(item, doctorListViewModel),
      );
    },
  ),
  separatorBuilder: (BuildContext context, int index) {
    return const Divider(color: AppColors.dividerColor, height: 1);
  },
),"
keMvP9h2,flutter_paging_viewmodel_example_1,chayanforyou,Dart,Thursday 19th of June 2025 12:09:09 AM CDT,"class LocationViewModel extends StateNotifier<AsyncValue<List<Places>>> {
  final List<Places> initialLocations;
  final String employeeId;
  final int year;
  final int month;
  final String shift;

  LocationViewModel({
    required this.initialLocations,
    required this.employeeId,
    required this.year,
    required this.month,
    required this.shift,
  }) : super(const AsyncValue.loading()) {
    _fetchLocations();
  }

  String _searchTerm = '';
  List<Places> _locations = [];

  // Getter for the selected locations
  List<Places> get selectedLocations => initialLocations;

  // Method to fetch locations
  Future<void> _fetchLocations() async {
    try {
      state = const AsyncValue.loading();
      final response = await TourPlanRepository.instance.getTourPlanLocation(employeeId, year, month, shift);
      final locations = response.data ?? [];
      _locations = locations
          .map((location) => location.copyWith(
        selected: initialLocations.any((loc) => loc.uniqueKey == location.uniqueKey),
      )).toList();

      state = AsyncValue.data(_locations);
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }

  // Method to update the search term
  void updateSearchTerm(String term) {
    _searchTerm = term.trim();
    state = AsyncValue.data(_filterLocations());
  }

  // Method to toggle the selection of a location
  void toggleSelection(Places location) {
    final index = _locations.indexWhere((l) => l.uniqueKey == location.uniqueKey);
    if (index != -1) {
      final isSelected = _locations[index].selected;
      // Update the main list
      _locations[index] = _locations[index].copyWith(selected: !isSelected);

      // Update the selected list
      if (isSelected) {
        initialLocations.removeWhere((l) => l.uniqueKey == location.uniqueKey);
      } else {
        initialLocations.add(_locations[index]);
      }

      // Update state without resetting the filtered list
      state = AsyncValue.data(_filterLocations());
    }
  }


  // Method to filter locations based on search term
  List<Places> _filterLocations() {
    return _locations.where((location) {
      return location.locationName?.toLowerCase().contains(_searchTerm.toLowerCase()) ?? false;
    }).toList();
  }
}

final locationViewModelProvider =
    StateNotifierProvider.family.autoDispose<LocationViewModel, AsyncValue<List<Places>>, LocationQueryParams>(
  (ref, params) => LocationViewModel(
    initialLocations: params.initialLocations,
    employeeId: params.employeeId,
    year: params.year,
    month: params.month,
    shift: params.shift,
  ),
);

// --------------------------------------------------

class LocationViewModel extends StateNotifier<PagingState<int, Places>> {
  final List<Places> initialLocations;
  final int year;
  final int month;
  final Debouncer _debounce = Debouncer();
  String? _searchTerm;

  LocationViewModel({
    required this.initialLocations,
    required this.year,
    required this.month,
  }) : super(PagingState());

  List<Places> get selectedLocations => initialLocations;

  /// Fetches the next page of data
  Future<void> fetchNextPage() async {
    if (state.isLoading) return;

    state = state.copyWith(isLoading: true, error: null);

    try {
      final newKey = state.keys?.isNotEmpty == true ? state.keys!.last + 1 : 0;
      final response = await TourPlanRepository.instance.getTourPlanLocation(year, month, newKey, _searchTerm);
      final locations = response.data.content ?? [];

      final newItems = locations.map((location) {
        return location.copyWith(
          selected: initialLocations.any((loc) => loc.id == location.id),
        );
      }).toList();

      state = state.copyWith(
        pages: [...?state.pages, newItems],
        keys: [...?state.keys, newKey],
        hasNextPage: response.data.hasNext,
        isLoading: false,
      );
    } catch (error) {
      state = state.copyWith(
        error: error,
        isLoading: false,
      );
    }
  }

  /// Updates search term and refreshes the list
  void updateSearchTerm(String searchTerm) {
    _searchTerm = searchTerm;
    _debounce.run(() {
      refreshList();
    });
  }

  /// Clear search and refreshes the list
  void clearSearchTerm() {
    _searchTerm = null;
    _debounce.run(() {
      refreshList();
    });
  }

  /// Refreshes the list and fetches the first page
  void refreshList() {
    state = PagingState();
    fetchNextPage();
  }

  void toggleSelection(Places location) {
    final updatedPages = state.pages?.map((page) {
      return page.map((loc) {
        if (loc.id == location.id) {
          return loc.copyWith(selected: !(loc.selected));
        }
        return loc;
      }).toList();
    }).toList();

    state = state.copyWith(pages: updatedPages);

    if (location.selected == true) {
      initialLocations.remove(location);
    } else {
      initialLocations.add(location);
    }
  }
}

final locationViewModelProvider =
    StateNotifierProvider.family.autoDispose<LocationViewModel, PagingState<int, Places>, LocationQueryParams>(
  (ref, params) => LocationViewModel(
    initialLocations: params.initialLocations,
    year: params.year,
    month: params.month,
  ),
);

// --------------------------------------------------

class LocationViewModel extends StateNotifier<AsyncValue<List<Places>>> {
  final List<Places> initialLocations;
  final String employeeId;
  final int year;
  final int month;
  final Debouncer _debounce = Debouncer();
  String _searchTerm = '';

  LocationViewModel({
    required this.initialLocations,
    required this.employeeId,
    required this.year,
    required this.month,
  }) : super(const AsyncValue.loading()) {
    _fetchLocations();
  }

  String get searchTerm => _searchTerm;

  // Method to fetch locations from the API based on the search term
  Future<void> _fetchLocations() async {
    try {
      state = const AsyncValue.loading();
      final response = await TourPlanRepository.instance.getTourPlanLocation(employeeId, year, month);
      final locations = response.data ?? [];

      // Update the state with the new list of places
      state = AsyncValue.data(
        locations.map((location) {
          return location.copyWith(
            selected: initialLocations.any((loc) => loc.id == location.id),
          );
        }).toList(),
      );
    } catch (e, stackTrace) {
      state = AsyncValue.error(e, stackTrace);
    }
  }

  // Method to update the search term with debounce
  void updateSearchTerm(String term) {
    _searchTerm = term.trim();

    _debounce.run(() {
      _fetchLocations();
    });
  }

  // Method to toggle the selection of a location
  void toggleSelection(Places location) {
    final locations = state.value ?? [];

    final index = locations.indexWhere((l) => l.id == location.id);
    if (index == -1) return;

    final isSelected = locations[index].selected;
    final updatedLocation = locations[index].copyWith(selected: !isSelected);

    locations[index] = updatedLocation;

    state = AsyncValue.data(locations);

    if (isSelected) {
      initialLocations.removeWhere((l) => l.id == location.id);
    } else {
      initialLocations.add(updatedLocation);
    }
  }

  // Getter for the selected locations
  List<Places> get selectedLocations => initialLocations;
}

final locationViewModelProvider =
    StateNotifierProvider.family.autoDispose<LocationViewModel, AsyncValue<List<Places>>, LocationQueryParams>(
  (ref, params) => LocationViewModel(
    initialLocations: params.initialLocations,
    employeeId: params.employeeId,
    year: params.year,
    month: params.month,
  ),
);
"
heYMc55u,Multi Server Bot,R2dTOO,Python,Wednesday 18th of June 2025 09:51:22 PM CDT,"import discord
from discord.ext import commands
from discord import ui, SelectOption
from discord import app_commands
from datetime import datetime, timedelta
from pytz import timezone, utc
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from collections import defaultdict
import os, io, json, logging, asyncio

# ————— Logging Setup —————
logging.basicConfig(filename=""fitness_bot.log"", level=logging.INFO,
                    format=""%(asctime)s [%(levelname)s] %(message)s"")
log = logging.getLogger()
log.info(""=== Bot startup ==="")

# ————— Config Utilities —————
CONFIG_FILE = ""server_configs.json""
COMMON_TIMEZONES = [
    ""UTC"", ""US/Eastern"", ""US/Central"", ""US/Mountain"", ""US/Pacific"",
    ""Europe/London"", ""Europe/Berlin"", ""Asia/Tokyo"", ""Australia/Sydney""
]

def load_configs():
    try:
        data = json.load(open(CONFIG_FILE))
        return data if isinstance(data, dict) else {}
    except (FileNotFoundError, json.JSONDecodeError):
        return {}

def save_configs(cfg):
    with open(CONFIG_FILE, ""w"") as f:
        json.dump(cfg, f, indent=2)

server_configs = load_configs()
daily_log_cache = defaultdict(set)

# ————— Google Sheets Setup —————
CREDENTIALS_FILE = '/home/r23dprinting/fitness-challenge-462612-78786b6edf2e.json'
scope = ['https://spreadsheets.google.com/feeds','https://www.googleapis.com/auth/drive']
creds = ServiceAccountCredentials.from_json_keyfile_name(CREDENTIALS_FILE, scope)
client = gspread.authorize(creds)

# ————— Helpers —————
def is_admin(ctx, cfg):
    return ctx.user.guild_permissions.administrator or any(
        r.name == cfg.get(""admin_role"") for r in ctx.user.roles
    )

# ————— Config Flow Modals —————
CONFIG_KEYS = [
    (""sheet_name"", ""Google Sheet name""),
    (""thread_name"", ""Exact thread name""),
    (""channel_name"", ""Parent channel name""),
    (""admin_role"", ""Admin role name""),
    (""hashtag"", ""Hashtag (#include, or leave blank)""),
    (""timezone"", ""Timezone""),
    (""start_date"", ""Challenge start date (YYYY-MM-DD)""),
    (""end_date"", ""Challenge end date (YYYY-MM-DD)""),
    (""goal_days"", ""Goal days (number)""),
    (""auto_summaries"", ""Send auto-summaries? (yes/no)"")
]

class ConfigFlow:
    def __init__(self, guild_id, existing=None):
        self.guild_id = guild_id
        self.data = existing.copy() if existing else {}
        self.step = 0

class InputModal(ui.Modal):
    def __init__(self, flow: ConfigFlow, key, label):
        super().__init__(title=f""Set {label}"")
        self.flow = flow
        self.key = key
        default_val = self.flow.data.get(self.key, """")
        self.add_item(ui.TextInput(label=label, style=discord.TextStyle.short, default=default_val))

    async def on_submit(self, interaction):
        val = self.children[0].value.strip()
        if self.key == ""goal_days"" and not val.isdigit():
            return await interaction.response.send_message(""❌ Must be a number."", ephemeral=True)
        if self.key == ""auto_summaries"":
            lv = val.lower()
            if lv not in (""yes"", ""no""):
                return await interaction.response.send_message(""❌ Enter yes or no."", ephemeral=True)
            val = (lv == ""yes"")
        self.flow.data[self.key] = val
        self.flow.step += 1
        if self.flow.step < len(CONFIG_KEYS):
            nk, nl = CONFIG_KEYS[self.flow.step]
            if nk == ""timezone"":
                await interaction.response.send_modal(TimezoneModal(self.flow))
            else:
                await interaction.response.send_modal(InputModal(self.flow, nk, nl))
        else:
            server_configs[str(self.flow.guild_id)] = self.flow.data
            save_configs(server_configs)
            await interaction.response.send_message(""✅ Configuration saved & reloaded!"", ephemeral=True)

class TimezoneModal(ui.Modal):
    def __init__(self, flow: ConfigFlow):
        super().__init__(title=""Enter Timezone (e.g. US/Eastern)"")
        self.flow = flow
        self.add_item(ui.TextInput(label=""Timezone"", placeholder=""e.g. US/Eastern""))

    async def on_submit(self, interaction: discord.Interaction):
        val = self.children[0].value.strip()
        if val not in COMMON_TIMEZONES:
            return await interaction.response.send_message(
                ""❌ Invalid timezone. Must be one of:\n"" +
                "", "".join(COMMON_TIMEZONES), ephemeral=True
            )
        self.flow.data[""timezone""] = val
        self.flow.step += 1
        nk, nl = CONFIG_KEYS[self.flow.step]
        await interaction.response.send_modal(InputModal(self.flow, nk, nl))

# ————— Bot Init —————
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True
bot = commands.Bot(command_prefix=""!"", intents=intents)

@bot.event
async def on_ready():
    log.info(""Bot is online and ready"")
    try:
        synced = await bot.tree.sync()
        log.info(f""Synced {len(synced)} application commands"")
    except Exception as e:
        log.error(f""Slash sync failed: {e}"")
    asyncio.create_task(summary_scheduler())

@bot.event
async def on_message(message: discord.Message):
    if message.author.bot or not message.guild:
        return
    cfg = server_configs.get(str(message.guild.id))
    if not cfg:
        return
    thread = message.channel if isinstance(message.channel, discord.Thread) else None
    if not thread or thread.name != cfg[""thread_name""] or thread.parent.name != cfg[""channel_name""]:
        return
    if not (message.attachments or cfg.get(""hashtag"", """").lower() in message.content.lower()):
        return

    tz = timezone(cfg[""timezone""])
    now = utc.localize(datetime.utcnow()).astimezone(tz)
    try:
        sd = datetime.fromisoformat(cfg[""start_date""]).date()
        ed = datetime.fromisoformat(cfg[""end_date""]).date()
    except:
        log.error(f""Invalid dates for guild {message.guild.id}"")
        return

    if not (sd <= now.date() <= ed):
        try:
            await message.author.send(
                f""💪 Good job staying active!\nYour activity in **{message.guild.name}** wasn’t logged — ""
                f""challenge runs **{sd.strftime('%b %d')} to {ed.strftime('%b %d')} ({tz.zone})**.""
            )
            log.info(f""Sent DM to {message.author}"")
        except discord.Forbidden:
            log.warning(f""Cannot DM {message.author}"")
        return

    dstr = now.date().isoformat()
    uid = str(message.author.id)
    if uid not in daily_log_cache[dstr]:
        try:
            client.open(cfg[""sheet_name""]).sheet1.append_row([uid, str(message.author), now.isoformat()])
            daily_log_cache[dstr].add(uid)
            log.info(f""Logged {message.author}"")
        except Exception as e:
            log.error(f""Sheet append failed: {e}"")

    await bot.process_commands(message)


# ————— Slash (Tree) Commands —————
@bot.tree.command(name=""progress"", description=""Your monthly activity count"")
async def progress(interaction: discord.Interaction):
    cfg = server_configs[str(interaction.guild.id)]
    sheet = client.open(cfg[""sheet_name""]).sheet1
    days = {r['Timestamp'].split(""T"")[0] for r in sheet.get_all_records() if r['UserID'] == str(interaction.user.id)}
    await interaction.response.send_message(f""You’ve logged {len(days)} day(s) this challenge! 💪"", ephemeral=True)

@bot.tree.command(name=""streak"", description=""Your current activity streak"")
async def streak(interaction: discord.Interaction):
    cfg = server_configs[str(interaction.guild.id)]
    sheet = client.open(cfg[""sheet_name""]).sheet1
    recs = sorted(sheet.get_all_records(), key=lambda r: r['Timestamp'])
    days = sorted({r['Timestamp'].split(""T"")[0] for r in recs if r['UserID'] == str(interaction.user.id)}, reverse=True)
    streak_count = 0
    today = datetime.utcnow().date()
    for d in days:
        if datetime.fromisoformat(d).date() == today - timedelta(days=streak_count):
            streak_count += 1
        else:
            break
    await interaction.response.send_message(f""🔥 Your current streak: {streak_count} day(s)"", ephemeral=True)

@bot.tree.command(name=""check"", description=""ADMIN: Check another member’s log days"")
async def check(interaction: discord.Interaction, member: discord.Member):
    cfg = server_configs[str(interaction.guild.id)]
    if not is_admin(interaction, cfg):
        return await interaction.response.send_message(""❌ No permission"", ephemeral=True)
    sheet = client.open(cfg[""sheet_name""]).sheet1
    days = {r['Timestamp'].split(""T"")[0] for r in sheet.get_all_records() if r['UserID'] == str(member.id)}
    await interaction.response.send_message(f""{member.display_name} has logged {len(days)} day(s)."", ephemeral=True)

@bot.tree.command(name=""leaderboard"", description=""ADMIN: View top participants"")
async def leaderboard(interaction: discord.Interaction):
    cfg = server_configs[str(interaction.guild.id)]
    if not is_admin(interaction, cfg):
        return await interaction.response.send_message(""❌ No permission"", ephemeral=True)
    sheet = client.open(cfg[""sheet_name""]).sheet1
    counts = defaultdict(set)
    for r in sheet.get_all_records():
        counts[r['UserID']].add(r['Timestamp'].split(""T"")[0])
    sorted_lb = sorted(counts.items(), key=lambda x: len(x[1]), reverse=True)
    msg = ""🏆 Leaderboard:\n""
    for i, (uid, ds) in enumerate(sorted_lb[:10]):
        member = interaction.guild.get_member(int(uid))
        name = member.display_name if member else uid
        msg += f""{i+1}. {name} – {len(ds)} day(s)\n""
    await interaction.response.send_message(msg, ephemeral=True)

@bot.tree.command(name=""export"", description=""ADMIN: Export logs to CSV"")
async def export(interaction: discord.Interaction):
    cfg = server_configs[str(interaction.guild.id)]
    if not is_admin(interaction, cfg):
        return await interaction.response.send_message(""❌ No permission"", ephemeral=True)
    csv_content = ""\n"".join("","".join(r) for r in client.open(cfg[""sheet_name""]).sheet1.get_all_values())
    await interaction.response.send_message(file=discord.File(fp=io.StringIO(csv_content), filename=""fitness_log.csv""), ephemeral=True)

@bot.tree.command(name=""reset_cache"", description=""ADMIN: Reset today’s in-memory log cache"")
async def reset_cache(interaction: discord.Interaction):
    cfg = server_configs[str(interaction.guild.id)]
    if not is_admin(interaction, cfg):
        return await interaction.response.send_message(""❌ No permission"", ephemeral=True)
    today = datetime.utcnow().date().isoformat()
    if today in daily_log_cache:
        del daily_log_cache[today]
        await interaction.response.send_message(""♻️ Today’s log cache has been reset."", ephemeral=True)
    else:
        await interaction.response.send_message(""ℹ️ No cached entries today."", ephemeral=True)

@bot.tree.command(name=""reload_config"", description=""ADMIN: Reload JSON config file"")
async def reload_config(interaction: discord.Interaction):
    global server_configs  # <- move this line to the top
    cfg = server_configs.get(str(interaction.guild.id))
    if not is_admin(interaction, cfg):
        return await interaction.response.send_message(""❌ No permission"", ephemeral=True)
    server_configs = load_configs()
    await interaction.response.send_message(""🔄 Configuration reloaded."", ephemeral=True)

class ConfigPromptView(ui.View):
    def __init__(self, interaction, cfg):
        super().__init__(timeout=60)
        self.cfg = cfg

    @ui.button(label=""Edit Settings"", style=discord.ButtonStyle.primary)
    async def edit(self, interaction: discord.Interaction, button: discord.ui.Button):
        flow = ConfigFlow(interaction.guild.id, self.cfg)
        nk, nl = CONFIG_KEYS[0]
        await interaction.response.send_modal(InputModal(flow, nk, nl))
        self.stop()

    @ui.button(label=""Keep Current Settings"", style=discord.ButtonStyle.secondary)
    async def keep(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message(""✅ Keeping existing configuration."", ephemeral=True)
        self.stop()

@bot.tree.command(name=""configure"", description=""ADMIN: Setup or update this server"")
async def configure(interaction: discord.Interaction):
    if not interaction.user.guild_permissions.administrator:
        return await interaction.response.send_message(""❌ Admins only."", ephemeral=True)

    cfg = server_configs.get(str(interaction.guild.id))
    if not cfg:
        await interaction.response.send_message(""🆕 Starting new server setup..."", ephemeral=True)
        flow = ConfigFlow(interaction.guild.id)
        nk, nl = CONFIG_KEYS[0]
        return await interaction.response.send_modal(InputModal(flow, nk, nl))

    summary = (
        f""**Current Configuration:**\n""
        f""- Sheet: `{cfg.get('sheet_name', 'N/A')}`\n""
        f""- Channel: `{cfg.get('channel_name', 'N/A')}`\n""
        f""- Thread: `{cfg.get('thread_name', 'N/A')}`\n""
        f""- Admin role: `{cfg.get('admin_role', 'N/A')}`\n""
        f""- Hashtag: `{cfg.get('hashtag', 'None')}`\n""
        f""- Timezone: `{cfg.get('timezone', 'N/A')}`\n""
        f""- Challenge: {cfg.get('start_date', 'N/A')} → {cfg.get('end_date', 'N/A')} ""
        f""(Goal: {cfg.get('goal_days','n/a')}, AutoSummaries: {cfg.get('auto_summaries','yes')})\n\n""
        f""🔧 Do you want to edit this configuration?""
    )
    await interaction.response.send_message(summary, view=ConfigPromptView(interaction, cfg), ephemeral=True)

@bot.tree.command(name=""view_config"", description=""ADMIN: View current configuration"")
async def view_config(interaction: discord.Interaction):
    cfg = server_configs.get(str(interaction.guild.id))
    if not cfg or not interaction.user.guild_permissions.administrator:
        return await interaction.response.send_message(""❌ No permission or not configured."", ephemeral=True)

    await interaction.response.send_message(
        f""**Configuration for {interaction.guild.name}:**\n""
        f""- Sheet: `{cfg.get('sheet_name', 'N/A')}`\n""
        f""- Channel: `{cfg.get('channel_name', 'N/A')}`\n""
        f""- Thread: `{cfg.get('thread_name', 'N/A')}`\n""
        f""- Admin role: `{cfg.get('admin_role', 'N/A')}`\n""
        f""- Hashtag: `{cfg.get('hashtag', 'None')}`\n""
        f""- Timezone: `{cfg.get('timezone', 'N/A')}`\n""
        f""- Challenge: {cfg.get('start_date', 'N/A')} → {cfg.get('end_date', 'N/A')} ""
        f""(Goal: {cfg.get('goal_days','n/a')}, AutoSummaries: {cfg.get('auto_summaries','yes')})\n\n""
        f""🔑 Make sure your sheet is shared with `{creds.service_account_email}` as Editor."",
        ephemeral=True
    )

@bot.tree.command(name=""help"", description=""Show available commands"")
async def _help(interaction: discord.Interaction):
    cfg = server_configs.get(str(interaction.guild.id))
    admin = cfg and is_admin(interaction, cfg)
    lines = [""**Available Commands:**"",
             ""• /progress – Your monthly log count"",
             ""• /streak – Your current activity streak""]
    if admin:
        lines += [
            """", ""**Admin Commands:**"",
            ""• /check @user – View another user’s stats"",
            ""• /leaderboard – View top participants"",
            ""• /export – Export logs to CSV"",
            ""• /reset_cache – Clear today’s cache"",
            ""• /reload_config – Reload config file"",
            ""• /configure – Setup/update this server"",
            ""• /view_config – View current settings""
        ]
    lines.append(""• /help – Show this help message"")
    await interaction.response.send_message(""\n"".join(lines), ephemeral=True)

# ————— Summary Scheduler (stub) —————
async def summary_scheduler():
    await bot.wait_until_ready()
    while True:
        await asyncio.sleep(86400)
        # future summary/notification logic happens here

# ————— Run the Bot —————
bot.run(os.getenv(""DISCORD_BOT_TOKEN""))"
YDKRE7q4,Untitled,thelebaron,C#,Wednesday 18th of June 2025 09:13:48 PM CDT,"public static void ConstructData(this ref BlobBuilder builder, ref DenseClip root, Animator animator, AnimationClip clip,
                                         Dictionary<string, EditorCurveBinding> curveDict)
        {
            int                           ratio   = curveDict.Count <= UseBucketCapacityRatioOfThreeUpTo ? 3 : 2;
            List<Tuple<string, string[]>> mapping = HumanoidRemapping.BoneToMuscleList;
   
            int capacity       = curveDict.Count;
            int bucketCapacity = math.ceilpow2(capacity * ratio);

            // bucketCapacityMask is neccessary for retrieval so set it on the data too
            int bucketCapacityMask = bucketCapacity - 1;
            int keyCapacity        = capacity;
            
            BlobBuilderArray<BlobArray<BlobCurve>> values  = builder.Allocate(ref root.HumanoidCurveData.data.values, capacity);
            BlobBuilderArray<uint>                 keys    = builder.Allocate(ref root.HumanoidCurveData.data.keys, capacity);
            BlobBuilderArray<int>                  next    = builder.Allocate(ref root.HumanoidCurveData.data.next, capacity);
            BlobBuilderArray<int>                  buckets = builder.Allocate(ref root.HumanoidCurveData.data.buckets, bucketCapacity);

            Debug.Log($"" values {values.Length}"");

            // so far the only way I've found to modify the true count on the data itself (without using unsafe code)
            // is by storing it in an array we can still access in the Add method.
            // count is only used in GetKeyArray and GetValueArray to size the array to the true count instead of capacity
            // count and keyCapacity are like
            BlobBuilderArray<int> count = builder.Allocate(ref root.HumanoidCurveData.data.count, 1);
            // Clear
            for (int i = 0; i < buckets.Length; i++)
                buckets[i] = -1;
            for (int i = 0; i < next.Length; i++)
                next[i] = -1;

            // Add logic
            for (var index = 0; index < mapping.Count; index++)
            {
                Tuple<string, string[]> boneMap       = mapping[index];
                uint      key           = mathex.CalculateHash32(boneMap.Item1);
                string[] propertyNames = boneMap.Item2;

                ref int c      = ref count[0];
                int     bucket = key.GetHashCode() & bucketCapacityMask;
                int     bucketIndex  = c++;

                int                         propertyCount     = 3;
                BlobBuilderArray<BlobCurve> curveArrayBuilder = builder.Allocate(ref values[index], propertyCount);

                for (int i = 0; i < propertyCount; i++)
                {
                    // we just add an empty key for missing properties
                    if (propertyNames[i].Equals(""""))
                    {
                        // Allocate single keyframe if no actual data
                        BlobBuilderArray<Key> emptyKeyframeBuilder = builder.Allocate<Key>(ref curveArrayBuilder[i].Keyframes, 1);
                        emptyKeyframeBuilder[0] = new Key();
                        continue;
                    }

                    // Get the curve for the property
                    AnimationCurve        curve            = AnimationUtility.GetEditorCurve(clip, curveDict.GetValueOrDefault(propertyNames[i]));
                    BlobBuilderArray<Key> keyframesBuilder = builder.Allocate<Key>(ref curveArrayBuilder[i].Keyframes, curve.keys.Length);

                    // Directly populate the blob array from curve keys
                    for (int kIndex = 0; kIndex < curve.keys.Length; kIndex++)
                    {
                        keyframesBuilder[kIndex] = new Key(curve.keys[kIndex]);
                    }
                }

                keys[index] = key;
                //values[index] =
                next[index]     = buckets[bucket];
                buckets[bucket] = index;
            }
        }"
CTaqVgdh,Untitled,thelebaron,C#,Wednesday 18th of June 2025 09:02:58 PM CDT,"public static void ConstructData(this ref BlobBuilder builder, ref DenseClip root, Animator animator, AnimationClip clip,
                                         Dictionary<string, EditorCurveBinding> curveDict)
        {
            int ratio = curveDict.Count <= UseBucketCapacityRatioOfThreeUpTo ? 3 : 2;
            var mapping = HumanoidRemapping.BoneToMuscleList;
   
            var capacity       = curveDict.Count;
            int bucketCapacity = math.ceilpow2(capacity * ratio);

            // bucketCapacityMask is neccessary for retrieval so set it on the data too
            var bucketCapacityMask = bucketCapacity - 1;
            var keyCapacity        = capacity;
            
            BlobBuilderArray<BlobArray<BlobCurve>> values  = builder.Allocate(ref root.HumanoidCurveData.data.values, capacity);
            var                keys    = builder.Allocate(ref root.HumanoidCurveData.data.keys, capacity);
            var                next    = builder.Allocate(ref root.HumanoidCurveData.data.next, capacity);
            var                buckets = builder.Allocate(ref root.HumanoidCurveData.data.buckets, bucketCapacity);

            // so far the only way I've found to modify the true count on the data itself (without using unsafe code)
            // is by storing it in an array we can still access in the Add method.
            // count is only used in GetKeyArray and GetValueArray to size the array to the true count instead of capacity
            // count and keyCapacity are like
            var count = builder.Allocate(ref root.HumanoidCurveData.data.count, 1);
            // Clear
            for (int i = 0; i < buckets.Length; i++)
                buckets[i] = -1;
            for (int i = 0; i < next.Length; i++)
                next[i] = -1;

            // Add logic
            foreach (Tuple<string, string[]> boneMap in mapping)
            {
                var      key           = mathex.CalculateHash32(boneMap.Item1);
                string[] propertyNames = boneMap.Item2;
                
                ref int c      = ref count[0];
                int     bucket = key.GetHashCode() & bucketCapacityMask;
                int     index  = c++;

                var propertyCount     = 3;
                var curveArrayBuilder = builder.Allocate(ref values[index], propertyCount);

                for (int i = 0; i < propertyCount; i++)
                {
                    // we just add an empty key for missing properties
                    if (propertyNames[i].Equals(""""))
                    {
                        // Allocate single keyframe if no actual data
                        var emptyKeyframeBuilder = builder.Allocate<Key>(ref curveArrayBuilder[i].Keyframes, 1);
                        emptyKeyframeBuilder[0] = new Key();
                        continue;
                    }

                    // Get the curve for the property
                    var curve = AnimationUtility.GetEditorCurve(clip, curveDict.GetValueOrDefault(propertyNames[i]));
                    var keyframesBuilder = builder.Allocate<Key>(ref curveArrayBuilder[i].Keyframes, curve.keys.Length);
                    
                    // Directly populate the blob array from curve keys
                    for (int kIndex = 0; kIndex < curve.keys.Length; kIndex++)
                    {
                        keyframesBuilder[kIndex] = new Key(curve.keys[kIndex]);
                    }
                }

                keys[index] = key;
                //values[index] =
                next[index] = buckets[bucket];
                buckets[bucket] = index;
            }
        }"
zRUgtcVm,cc-wheat-farm,asianhaydenxd,Lua,Wednesday 18th of June 2025 08:50:43 PM CDT,"local function replant()
    local success, data = turtle.inspectDown()
    if not success then return end
    if data.name ~= ""minecraft:wheat"" then return end
    if data.state.age ~= 7 then return end
    turtle.digDown()
    turtle.placeDown()
end

local function harvestLayer()
    -- Turtle should be over belt facing towards the farm.
    for i=1,2 do
        turtle.forward()
    end

    for i=1,4 do
        replant()
        for i=1,8 do
            turtle.forward()
            replant()
        end
        turtle.turnRight()
        turtle.forward()
        turtle.turnRight()

        replant()
        for i=1,8 do
            turtle.forward()
            replant()
        end
        turtle.turnLeft()
        turtle.forward()
        turtle.turnLeft()
    end
    replant()
    for i=1,8 do
        turtle.forward()
        replant()
    end

    turtle.turnLeft()
    for i=1,8 do
        turtle.forward()
    end
    turtle.turnLeft()
    for i=1,10 do
        turtle.forward()
    end
    for i=1,2 do
        turtle.turnLeft()
    end
end

local function dropAll(itemName)
    for i=1,16 do
        turtle.select(i)
        local item = turtle.getItemDetail()
        if item and item.name:find(itemName) then
            turtle.dropDown()
        end
    end
end

local function harvestAll()
    harvestLayer()
    for i=1,2 do
        for i=1,4 do
            turtle.up()
        end
        harvestLayer()
    end
    for i=1,8 do
        turtle.down()
    end
    dropAll(""wheat"")
    turtle.turnLeft()
    for i=1,2 do turtle.forward() end
    turtle.dropAll(""seed"")
    for i=1,2 do turtle.turnRight() end
    for i=1,2 do turtle.forward() end
    turtle.turnLeft()
end

turtle.select(1)

while true do
    harvestAll()
end"
fJeiv9kT,2025-06-17_stats.json,rdp_snitch,JSON,Wednesday 18th of June 2025 07:18:38 PM CDT,"{
  ""ip"": {
    ""172.236.141.242"": 8325,
    ""24.173.30.170"": 12186,
    ""14.225.202.191"": 204,
    ""194.165.16.164"": 6,
    ""91.238.181.92"": 12,
    ""139.59.237.217"": 15,
    ""157.66.222.138"": 6,
    ""205.210.31.81"": 9,
    ""103.87.131.65"": 12,
    ""111.170.152.113"": 18,
    ""2.57.121.247"": 3,
    ""92.63.197.23"": 18,
    ""8.219.100.95"": 6,
    ""194.180.49.127"": 3,
    ""205.210.31.219"": 9,
    ""194.164.107.6"": 30,
    ""167.172.131.118"": 11346,
    ""185.196.220.41"": 9,
    ""205.210.31.180"": 9,
    ""146.190.167.180"": 3,
    ""152.32.139.96"": 3,
    ""194.165.16.161"": 6,
    ""147.185.132.66"": 9,
    ""162.142.125.204"": 3,
    ""167.94.145.110"": 3
  },
  ""asn"": {
    ""AS63949"": 8325,
    ""AS11427"": 12186,
    ""AS135905"": 204,
    ""AS48721"": 12,
    ""AS49434"": 12,
    ""AS14061"": 11364,
    ""AS150895"": 6,
    ""AS396982"": 36,
    ""AS55947"": 12,
    ""AS151185"": 18,
    ""AS47890"": 3,
    ""AS210848"": 18,
    ""AS45102"": 6,
    ""AS201814"": 3,
    ""AS50219"": 30,
    ""AS213438"": 9,
    ""AS135377"": 3,
    ""AS398324"": 3,
    ""AS398705"": 3
  },
  ""isp"": {
    ""Akamai Technologies, Inc."": 8325,
    ""Charter Communications Inc"": 12186,
    ""Vietnam Posts and Telecommunications Group"": 204,
    ""Flyservers S.A."": 12,
    ""Datacenter location PAR1 France"": 12,
    ""DIGITALOCEAN"": 15,
    ""TANTHOIVPS"": 6,
    ""Google LLC"": 36,
    ""Bangalore Broadband Network Pvt Ltd"": 12,
    ""China Telecom"": 18,
    ""Unmanaged LTD"": 3,
    ""Telkom Internet LTD"": 18,
    ""Alibaba (US) Technology Co., Ltd."": 6,
    ""MEVSPACE sp. z o.o."": 3,
    ""LNK SYSTEMS MUNTENIA SRL"": 30,
    ""DigitalOcean, LLC"": 11349,
    ""ColocaTel Inc."": 9,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Censys, Inc."": 6
  },
  ""org"": {
    ""Akamai Technologies, Inc."": 8325,
    ""Spectrum"": 12186,
    ""VNPT"": 204,
    ""Flyservers S.A"": 12,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""DigitalOcean, LLC"": 11364,
    ""Tan VPS Company Limited"": 6,
    ""Palo Alto Networks, Inc"": 36,
    ""Unknown"": 12,
    ""Chinanet HB"": 18,
    ""Unmanaged LTD"": 3,
    ""Korotkij Denis Aleksandrovich"": 18,
    ""Alibaba.com Singapore E-Commerce Private Limited"": 6,
    ""HostSlick"": 3,
    ""Valence Technology Co"": 30,
    ""Colocatel Inc"": 9,
    ""Ucloud Information Technology"": 3,
    ""Censys Inc"": 3,
    ""Censys, Inc."": 3
  },
  ""regionName"": {
    ""South East"": 8325,
    ""Texas"": 12186,
    ""Hanoi"": 204,
    ""Kaunas"": 12,
    ""\u00cele-de-France"": 12,
    ""South West"": 15,
    ""B\u00ecnh \u0110\u1ecbnh Province"": 6,
    ""California"": 39,
    ""Karnataka"": 12,
    ""Hubei"": 18,
    ""England"": 3,
    ""North Holland"": 18,
    ""North West"": 36,
    ""Bavaria"": 3,
    ""New Jersey"": 11346,
    ""Virginia"": 9,
    ""Seoul"": 3,
    ""Michigan"": 6
  },
  ""country"": {
    ""Singapore"": 8376,
    ""United States"": 23586,
    ""Vietnam"": 210,
    ""Lithuania"": 12,
    ""France"": 12,
    ""India"": 12,
    ""China"": 18,
    ""United Kingdom"": 3,
    ""The Netherlands"": 18,
    ""Germany"": 3,
    ""South Korea"": 3
  },
  ""account"": {
    ""hello"": 32124,
    ""Test"": 24,
    ""fDwfFzZZx"": 3,
    ""lUMKht"": 3,
    ""lSAFNq"": 3,
    ""Administr"": 21,
    ""XeGiVCxed"": 3,
    ""QyyevX"": 3,
    ""PopGKw"": 3,
    ""eltons"": 15,
    ""administr"": 15,
    ""Domain"": 9,
    ""NdFQdXeUP"": 3,
    ""wyysfn"": 3,
    ""DVPYnV"": 3,
    ""Administrator"": 3,
    ""oJbOmaFae"": 3,
    ""CzQalH"": 3,
    ""rkdbQY"": 3,
    ""(empty)"": 6
  },
  ""keyboard"": {
    ""Unknown"": 32253
  },
  ""client_build"": {
    ""Unknown"": 32253
  },
  ""client_name"": {
    ""Unknown"": 32253
  },
  ""ip_type"": {
    ""hosting"": 19746,
    ""Unknown"": 12507
  }
}"
M5J3FEtN,2025-06-17_stats.json,rdp_snitch,JSON,Wednesday 18th of June 2025 07:16:17 PM CDT,"{
  ""ip"": {
    ""172.236.141.242"": 8324,
    ""24.173.30.170"": 12184,
    ""14.225.202.191"": 202,
    ""194.165.16.164"": 6,
    ""91.238.181.92"": 12,
    ""139.59.237.217"": 15,
    ""157.66.222.138"": 6,
    ""205.210.31.81"": 9,
    ""103.87.131.65"": 12,
    ""111.170.152.113"": 18,
    ""2.57.121.247"": 3,
    ""92.63.197.23"": 18,
    ""8.219.100.95"": 6,
    ""194.180.49.127"": 3,
    ""205.210.31.219"": 9,
    ""194.164.107.6"": 30,
    ""167.172.131.118"": 11346,
    ""185.196.220.41"": 9,
    ""205.210.31.180"": 9,
    ""146.190.167.180"": 3,
    ""152.32.139.96"": 3,
    ""194.165.16.161"": 6,
    ""147.185.132.66"": 9,
    ""162.142.125.204"": 3,
    ""167.94.145.110"": 3
  },
  ""asn"": {
    ""AS63949"": 8324,
    ""AS11427"": 12184,
    ""AS135905"": 202,
    ""AS48721"": 12,
    ""AS49434"": 12,
    ""AS14061"": 11364,
    ""AS150895"": 6,
    ""AS396982"": 36,
    ""AS55947"": 12,
    ""AS151185"": 18,
    ""AS47890"": 3,
    ""AS210848"": 18,
    ""AS45102"": 6,
    ""AS201814"": 3,
    ""AS50219"": 30,
    ""AS213438"": 9,
    ""AS135377"": 3,
    ""AS398324"": 3,
    ""AS398705"": 3
  },
  ""isp"": {
    ""Akamai Technologies, Inc."": 8324,
    ""Charter Communications Inc"": 12184,
    ""Vietnam Posts and Telecommunications Group"": 202,
    ""Flyservers S.A."": 12,
    ""Datacenter location PAR1 France"": 12,
    ""DIGITALOCEAN"": 15,
    ""TANTHOIVPS"": 6,
    ""Google LLC"": 36,
    ""Bangalore Broadband Network Pvt Ltd"": 12,
    ""China Telecom"": 18,
    ""Unmanaged LTD"": 3,
    ""Telkom Internet LTD"": 18,
    ""Alibaba (US) Technology Co., Ltd."": 6,
    ""MEVSPACE sp. z o.o."": 3,
    ""LNK SYSTEMS MUNTENIA SRL"": 30,
    ""DigitalOcean, LLC"": 11349,
    ""ColocaTel Inc."": 9,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Censys, Inc."": 6
  },
  ""org"": {
    ""Akamai Technologies, Inc."": 8324,
    ""Spectrum"": 12184,
    ""VNPT"": 202,
    ""Flyservers S.A"": 12,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""DigitalOcean, LLC"": 11364,
    ""Tan VPS Company Limited"": 6,
    ""Palo Alto Networks, Inc"": 36,
    ""Unknown"": 12,
    ""Chinanet HB"": 18,
    ""Unmanaged LTD"": 3,
    ""Korotkij Denis Aleksandrovich"": 18,
    ""Alibaba.com Singapore E-Commerce Private Limited"": 6,
    ""HostSlick"": 3,
    ""Valence Technology Co"": 30,
    ""Colocatel Inc"": 9,
    ""Ucloud Information Technology"": 3,
    ""Censys Inc"": 3,
    ""Censys, Inc."": 3
  },
  ""regionName"": {
    ""South East"": 8324,
    ""Texas"": 12184,
    ""Hanoi"": 202,
    ""Kaunas"": 12,
    ""\u00cele-de-France"": 12,
    ""South West"": 15,
    ""B\u00ecnh \u0110\u1ecbnh Province"": 6,
    ""California"": 39,
    ""Karnataka"": 12,
    ""Hubei"": 18,
    ""England"": 3,
    ""North Holland"": 18,
    ""North West"": 36,
    ""Bavaria"": 3,
    ""New Jersey"": 11346,
    ""Virginia"": 9,
    ""Seoul"": 3,
    ""Michigan"": 6
  },
  ""country"": {
    ""Singapore"": 8375,
    ""United States"": 23584,
    ""Vietnam"": 208,
    ""Lithuania"": 12,
    ""France"": 12,
    ""India"": 12,
    ""China"": 18,
    ""United Kingdom"": 3,
    ""The Netherlands"": 18,
    ""Germany"": 3,
    ""South Korea"": 3
  },
  ""account"": {
    ""hello"": 32119,
    ""Test"": 24,
    ""fDwfFzZZx"": 3,
    ""lUMKht"": 3,
    ""lSAFNq"": 3,
    ""Administr"": 21,
    ""XeGiVCxed"": 3,
    ""QyyevX"": 3,
    ""PopGKw"": 3,
    ""eltons"": 15,
    ""administr"": 15,
    ""Domain"": 9,
    ""NdFQdXeUP"": 3,
    ""wyysfn"": 3,
    ""DVPYnV"": 3,
    ""Administrator"": 3,
    ""oJbOmaFae"": 3,
    ""CzQalH"": 3,
    ""rkdbQY"": 3,
    ""(empty)"": 6
  },
  ""keyboard"": {
    ""Unknown"": 32248
  },
  ""client_build"": {
    ""Unknown"": 32248
  },
  ""client_name"": {
    ""Unknown"": 32248
  },
  ""ip_type"": {
    ""hosting"": 19745,
    ""Unknown"": 12503
  }
}"
5T8BkRwb,2025-06-17_stats.json,rdp_snitch,JSON,Wednesday 18th of June 2025 07:15:13 PM CDT,"{
  ""ip"": {
    ""172.236.141.242"": 8323,
    ""24.173.30.170"": 12182,
    ""14.225.202.191"": 200,
    ""194.165.16.164"": 6,
    ""91.238.181.92"": 12,
    ""139.59.237.217"": 15,
    ""157.66.222.138"": 6,
    ""205.210.31.81"": 9,
    ""103.87.131.65"": 12,
    ""111.170.152.113"": 18,
    ""2.57.121.247"": 3,
    ""92.63.197.23"": 18,
    ""8.219.100.95"": 6,
    ""194.180.49.127"": 3,
    ""205.210.31.219"": 9,
    ""194.164.107.6"": 30,
    ""167.172.131.118"": 11346,
    ""185.196.220.41"": 9,
    ""205.210.31.180"": 9,
    ""146.190.167.180"": 3,
    ""152.32.139.96"": 3,
    ""194.165.16.161"": 6,
    ""147.185.132.66"": 9,
    ""162.142.125.204"": 3,
    ""167.94.145.110"": 3
  },
  ""asn"": {
    ""AS63949"": 8323,
    ""AS11427"": 12182,
    ""AS135905"": 200,
    ""AS48721"": 12,
    ""AS49434"": 12,
    ""AS14061"": 11364,
    ""AS150895"": 6,
    ""AS396982"": 36,
    ""AS55947"": 12,
    ""AS151185"": 18,
    ""AS47890"": 3,
    ""AS210848"": 18,
    ""AS45102"": 6,
    ""AS201814"": 3,
    ""AS50219"": 30,
    ""AS213438"": 9,
    ""AS135377"": 3,
    ""AS398324"": 3,
    ""AS398705"": 3
  },
  ""isp"": {
    ""Akamai Technologies, Inc."": 8323,
    ""Charter Communications Inc"": 12182,
    ""Vietnam Posts and Telecommunications Group"": 200,
    ""Flyservers S.A."": 12,
    ""Datacenter location PAR1 France"": 12,
    ""DIGITALOCEAN"": 15,
    ""TANTHOIVPS"": 6,
    ""Google LLC"": 36,
    ""Bangalore Broadband Network Pvt Ltd"": 12,
    ""China Telecom"": 18,
    ""Unmanaged LTD"": 3,
    ""Telkom Internet LTD"": 18,
    ""Alibaba (US) Technology Co., Ltd."": 6,
    ""MEVSPACE sp. z o.o."": 3,
    ""LNK SYSTEMS MUNTENIA SRL"": 30,
    ""DigitalOcean, LLC"": 11349,
    ""ColocaTel Inc."": 9,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Censys, Inc."": 6
  },
  ""org"": {
    ""Akamai Technologies, Inc."": 8323,
    ""Spectrum"": 12182,
    ""VNPT"": 200,
    ""Flyservers S.A"": 12,
    ""ThinkTech Technology Industrial CO. Limited"": 12,
    ""DigitalOcean, LLC"": 11364,
    ""Tan VPS Company Limited"": 6,
    ""Palo Alto Networks, Inc"": 36,
    ""Unknown"": 12,
    ""Chinanet HB"": 18,
    ""Unmanaged LTD"": 3,
    ""Korotkij Denis Aleksandrovich"": 18,
    ""Alibaba.com Singapore E-Commerce Private Limited"": 6,
    ""HostSlick"": 3,
    ""Valence Technology Co"": 30,
    ""Colocatel Inc"": 9,
    ""Ucloud Information Technology"": 3,
    ""Censys Inc"": 3,
    ""Censys, Inc."": 3
  },
  ""regionName"": {
    ""South East"": 8323,
    ""Texas"": 12182,
    ""Hanoi"": 200,
    ""Kaunas"": 12,
    ""\u00cele-de-France"": 12,
    ""South West"": 15,
    ""B\u00ecnh \u0110\u1ecbnh Province"": 6,
    ""California"": 39,
    ""Karnataka"": 12,
    ""Hubei"": 18,
    ""England"": 3,
    ""North Holland"": 18,
    ""North West"": 36,
    ""Bavaria"": 3,
    ""New Jersey"": 11346,
    ""Virginia"": 9,
    ""Seoul"": 3,
    ""Michigan"": 6
  },
  ""country"": {
    ""Singapore"": 8374,
    ""United States"": 23582,
    ""Vietnam"": 206,
    ""Lithuania"": 12,
    ""France"": 12,
    ""India"": 12,
    ""China"": 18,
    ""United Kingdom"": 3,
    ""The Netherlands"": 18,
    ""Germany"": 3,
    ""South Korea"": 3
  },
  ""account"": {
    ""hello"": 32114,
    ""Test"": 24,
    ""fDwfFzZZx"": 3,
    ""lUMKht"": 3,
    ""lSAFNq"": 3,
    ""Administr"": 21,
    ""XeGiVCxed"": 3,
    ""QyyevX"": 3,
    ""PopGKw"": 3,
    ""eltons"": 15,
    ""administr"": 15,
    ""Domain"": 9,
    ""NdFQdXeUP"": 3,
    ""wyysfn"": 3,
    ""DVPYnV"": 3,
    ""Administrator"": 3,
    ""oJbOmaFae"": 3,
    ""CzQalH"": 3,
    ""rkdbQY"": 3,
    ""(empty)"": 6
  },
  ""keyboard"": {
    ""Unknown"": 32243
  },
  ""client_build"": {
    ""Unknown"": 32243
  },
  ""client_name"": {
    ""Unknown"": 32243
  },
  ""ip_type"": {
    ""hosting"": 19744,
    ""Unknown"": 12499
  }
}"
KftgQxmT,stripmine.lua,Ubidibity,Lua,Wednesday 18th of June 2025 06:57:38 PM CDT,"-- Robust movement to dig through obstacles
function safeMoveForward()
    while not turtle.forward() do
        turtle.dig() -- Dig block in front (stone, gravel, etc.)
        os.sleep(0.1) -- Pause for gravel/sand to fall
    end
end

-- Dig 3x1 (forward, up, down)
function digStep()
    turtle.dig()       -- Dig forward
    turtle.digUp()     -- Dig above
    turtle.digDown()   -- Dig below
    safeMoveForward()  -- Move forward, digging if needed
end

-- Mine a tunnel of given length
function mineTunnel(length)
    for i = 1, length do
        digStep()
        -- Check fuel and inventory every 10 blocks
        if i % 10 == 0 then
            if turtle.getFuelLevel() < 20 then
                print(""Low fuel! Stopping."")
                return false
            end
            if turtle.getItemCount(16) > 0 then
                print(""Inventory full! Stopping."")
                return false
            end
        end
    end
    return true
end

-- Unload inventory into chest in front
function unload()
    for i = 1, 16 do
        turtle.select(i)
        turtle.drop() -- Drop into chest
    end
    turtle.select(1)
end

-- Main program for multi-turtle setup
function main()
    print(""Starting mining run..."")
    -- Mine 32 blocks out (2 chunks)
    if mineTunnel(32) then
        turtle.turnLeft()
        safeMoveForward() -- Shift 1 block left
        turtle.turnLeft() -- Face negative X
        -- Mine 32 blocks back
        if mineTunnel(32) then
            print(""Mining complete!"")
            -- Face chest at Z=502 (adjust Z if needed)
            -- Turtle is at Z=502/504/506; adjust to Z=502
            local turtleZ = 502 -- Change to your chest's Z
            local steps = turtleZ == 502 and 0 or (turtleZ == 504 and 2) or -2 -- Move to Z=502
            if steps ~= 0 then
                if steps > 0 then
                    turtle.turnLeft() -- Face positive Z
                else
                    turtle.turnRight() -- Face negative Z
                end
                for i = 1, math.abs(steps) do
                    safeMoveForward()
                end
                if steps > 0 then
                    turtle.turnRight() -- Face negative X
                else
                    turtle.turnLeft() -- Face negative X
                end
            end
            -- Move 1 block to chest (X=505 to X=500)
            safeMoveForward()
        else
            print(""Return trip failed. Check fuel/inventory."")
        end
    else
        print(""Outbound trip failed. Check fuel/inventory."")
    end
    -- Unload into chest
    unload()
    print(""Inventory unloaded."")
end

-- Run the program
main()"
d8rGFkBQ,Preferences Storage rev_04,pleasedontcode,Arduino,Wednesday 18th of June 2025 06:31:54 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Preferences Storage
	- Source Code NOT compiled for: Arduino Nano 33 BLE
	- Source Code created on: 2025-06-18 23:30:45

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Develop a BLE-based system for storing and */
	/* retrieving user preferences using */
	/* NanoBLEFlashPrefs library on Arduino Nano 33 BLE. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */

/****** DEFINITION OF LIBRARIES *****/
#include <NanoBLEFlashPrefs.h> // https://github.com/Dirk-/NanoBLEFlashPrefs

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void printPreferences(NanoBLEFlashPrefs::flashPrefs thePrefs);
void printReturnCode(int rc);

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
NanoBLEFlashPrefs myFlashPrefs; // Instantiate the preferences storage object

// Structure of preferences. You determine the fields.
// Must not exceed 1019 words (4076 bytes).
typedef struct flashStruct
{
  char someString[64];
  bool aSetting;
  int someNumber;
  float anotherNumber;
} flashPrefs;

// Our preferences. All functions here can read and modify these values, but to make
// them permanent, the struct must be written to flash explicitly (see below).
flashPrefs globalPrefs;

void setup()
{
  Serial.begin(9600);
  // Give user a chance to open the terminal
  delay(5000);
  Serial.println(""----- NanoBLEFlashPrefs Test -----"");

  // See if we already have a preference record
  Serial.println(""Read preference record..."");
  int rc = myFlashPrefs.readPrefs(&globalPrefs, sizeof(globalPrefs));
  if (rc == FDS_SUCCESS)
  {
    printPreferences(globalPrefs);
  }
  else
  {
    Serial.println(""No preferences found.""); // This should be the case when running for the first time on that particular board
    printReturnCode(rc);
  }
  Serial.println("""");

  // Prepare preference record for writing
  strcpy(globalPrefs.someString, ""NanoBLEFlashPrefs Test"");
  globalPrefs.aSetting = true;
  globalPrefs.someNumber = 42;
  globalPrefs.anotherNumber = 3.14;

  // Write preference record
  Serial.println(""Write preferences..."");
  printReturnCode(myFlashPrefs.writePrefs(&globalPrefs, sizeof(globalPrefs)));
  Serial.println("""");

  // Read preference record
  Serial.println(""Read preferences..."");
  rc = myFlashPrefs.readPrefs(&globalPrefs, sizeof(globalPrefs));
  if (rc == FDS_SUCCESS)
  {
    printPreferences(globalPrefs);
  }
  else
  {
    printReturnCode(rc);
  }
  Serial.println("""");

  delay(1000);

  // Change preference record
  strcpy(globalPrefs.someString, ""NanoBLEFlashPrefs Test 2"");
  globalPrefs.aSetting = false;
  globalPrefs.someNumber = 5050;
  globalPrefs.anotherNumber = 2.72;

  // Write preference record
  Serial.println(""Write another preference record..."");
  printReturnCode(myFlashPrefs.writePrefs(&globalPrefs, sizeof(globalPrefs)));
  Serial.println("""");

  // Read preference record
  Serial.println(""Read preferences..."");
  rc = myFlashPrefs.readPrefs(&globalPrefs, sizeof(globalPrefs));
  if (rc == FDS_SUCCESS)
  {
    printPreferences(globalPrefs);
  }
  else
  {
    printReturnCode(rc);
  }

  Serial.println("""");
  Serial.println(""Done. Press reset button to see that again or take look at"");
  Serial.println(""the NanoBLEFlashPrefsUtils example for more info."");
  Serial.println("""");
}

void loop()
{
  // In a real application, you might update preferences based on user input or events.
  // For demonstration, we do nothing here.
}

// Print preference record to Serial.
void printPreferences(flashPrefs thePrefs)
{
  Serial.println(""Preferences: "");
  Serial.print(""String: "");
  Serial.println(thePrefs.someString);
  Serial.print(""A Setting: "");
  Serial.println(thePrefs.aSetting);
  Serial.print(""Number: "");
  Serial.println(thePrefs.someNumber);
  Serial.print(""Another Number: "");
  Serial.println(thePrefs.anotherNumber);
}

// Print return code infos to Serial.
void printReturnCode(int rc)
{
  Serial.print(""Return code: "");
  Serial.print(rc);
  Serial.print("", "");
  Serial.println(myFlashPrefs.errorString(rc));
}
"
SDxGig1X,ServerError: received 500 HTTP response,basedcount_bot,Python,Wednesday 18th of June 2025 06:25:02 PM CDT,"Traceback (most recent call last):
  File ""/home/gmktec-server/Bots/basedcount_bot/basedcount_bot.py"", line 46, in wrapper
    await func(reddit_instance, mongo_client)
  File ""/home/gmktec-server/Bots/basedcount_bot/basedcount_bot.py"", line 123, in check_mail
    async for message in reddit_instance.inbox.unread(limit=None):  # Message
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 37, in __anext__
    await self._next_batch()
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 90, in _next_batch
    self._listing = await self._reddit.get(self.url, params=self.params)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 813, in get
    return await self._objectify_request(method=""GET"", params=params, path=path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 570, in _objectify_request
    await self.request(
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 1061, in request
    return await self._core.request(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 383, in request
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 305, in _request_with_retries
    return await self._do_retry(
           ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 170, in _do_retry
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 305, in _request_with_retries
    return await self._do_retry(
           ^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 170, in _do_retry
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 322, in _request_with_retries
    raise self.STATUS_EXCEPTIONS[response.status](response)
asyncprawcore.exceptions.ServerError: received 500 HTTP response
"
dGvpZiDa,UAV FEED PiP,papijuan23,SQF,Wednesday 18th of June 2025 05:31:26 PM CDT,"**WORKS ONLY WITH TV ""Land_FlatTV_01_F"" and ""Land_TripodScreen_01_large_F"" .  To work properly you need to place a Antena ""FPV_Retranslator"" no less 50 meters from the TV. Otherwise won't work. **

Known bugs:

In the Orion camera (If you are aiming the turret at a fixed spot, the monitors will only show the driver's POV.)


-------------------

init.sqf

[] execVM ""computerInteraction.sqf"";



-------------------


computerInteraction.sqf


if (!hasInterface) exitWith {};

player setVariable [""poweredOnTVs"", []];

[] spawn {
    private _tvClasses = [""Land_FlatTV_01_F"", ""Land_TripodScreen_01_large_F""];
    private _antennaClass = ""FPV_Retranslator"";

    while {true} do {
        private _allTVs = [];
        { _allTVs append (allMissionObjects _x) } forEach _tvClasses;

        {
            private _tv = _x;

            if ((player distance _tv) > 10) then {  // <-- Aquí está el rango de ""desaparición"" aumentado a 10m
                _tv setObjectTexture [0, ""#(argb,8,8,3)color(0,0,0,1)""];  // Negro opaco solo local
            } else {
                if (_tv in (player getVariable [""poweredOnTVs"", []])) then {
                    if (_tv getVariable [""droneConnected"", false]) then {
                        private _rttName = _tv getVariable [""rttName"", """"];
                        if (_rttName != """") then {
                            _tv setObjectTexture [0, format [""#(argb,512,512,1)r2t(%1,1)"", _rttName]];
                        };
                    } else {
                        if (_tv getVariable [""signalLost"", false]) then {
                            _tv setObjectTexture [0, ""#(argb,8,8,3)color(1,0,0,1)""];
                        } else {
                            private _hasAntenna = false;
                            {
                                if (alive _x && (_x distance _tv) < 50) exitWith { _hasAntenna = true };
                            } forEach allMissionObjects _antennaClass;

                            if (_hasAntenna) then {
                                _tv setObjectTexture [0, ""#(argb,8,8,3)color(1,1,0,1)""];
                            } else {
                                _tv setObjectTexture [0, ""#(argb,8,8,3)color(0,0,1,1)""];
                            };
                        };
                    };
                } else {
                    _tv setObjectTexture [0, ""#(argb,8,8,3)color(0,0,0,1)""];
                };
            };

            // ** CAMBIO: menú general para todas las acciones a 2 metros de distancia **
            if ((player distance _tv) < 2 && {!(_tv getVariable [""menuAdded"", false])}) then {
                _tv setVariable [""menuAdded"", true];

                // Agregar la acción de prender/apagar TV
                _tv addAction [""🔌 Prender / Apagar TV"", {
                    params [""_target""];
                    private _list = player getVariable [""poweredOnTVs"", []];

                    private _antena = false;
                    {
                        if (alive _x && (_x distance _target) < 50) exitWith { _antena = true };
                    } forEach allMissionObjects ""FPV_Retranslator"";

                    if (_target in _list) then {
                        _list = _list - [_target];
                        player setVariable [""poweredOnTVs"", _list];

                        private _cam = _target getVariable [""camObject"", objNull];
                        if (!isNull _cam) then { deleteVehicle _cam };

                        _target setVariable [""droneConnected"", false];
                        _target setVariable [""disconnectActionAdded"", false];
                        _target setVariable [""camObject"", objNull];
                        _target setVariable [""droneMenuAdded"", false];
                        _target setVariable [""rttName"", """"];
                        _target setVariable [""signalLost"", false];

                        private _actions = actionIDs _target;
                        { if (_x != -1) then { _target removeAction _x } } forEach _actions;

                        _target setVariable [""menuAdded"", false];
                        _target setObjectTextureGlobal [0, ""#(argb,8,8,3)color(0,0,0,0)""];
                    } else {
                        _list pushBackUnique _target;
                        player setVariable [""poweredOnTVs"", _list];

                        _target setVariable [""droneConnected"", false];
                        _target setVariable [""disconnectActionAdded"", false];
                        _target setVariable [""camObject"", objNull];
                        _target setVariable [""droneMenuAdded"", false];
                        _target setVariable [""rttName"", """"];
                        _target setVariable [""signalLost"", false];

                        if (_antena) then {
                            _target setObjectTextureGlobal [0, ""#(argb,8,8,3)color(1,1,0,1)""];
                        } else {
                            _target setObjectTextureGlobal [0, ""#(argb,8,8,3)color(0,0,1,1)""];
                        };
                    };
                }];
            };
        } forEach _allTVs;

        private _list = player getVariable [""poweredOnTVs"", []];
        private _allAntennas = allMissionObjects _antennaClass;

        {
            private _tv = _x;
            if (!alive _tv) then {
                _list = _list - [_tv];
                player setVariable [""poweredOnTVs"", _list];
                continue;
            };

            private _hasAntenna = false;
            {
                if (alive _x && (_x distance _tv) < 50) exitWith { _hasAntenna = true };
            } forEach _allAntennas;

            if (_hasAntenna) then {
                if (!(_tv getVariable [""droneMenuAdded"", false])) then {
                    _tv setVariable [""droneMenuAdded"", true];

                    private _drones = vehicles select {
                        alive _x && {typeOf _x in [""B_UAV_01_F"", ""orion_F_BLU""]}
                    };

                    {
                        private _drone = _x;
                        private _rttName = format [""uavRtt_%1"", _forEachIndex];
                        _tv setVariable [""rttName"", _rttName];

                        _tv addAction [format [""🎯 Mostrar cámara Drone %1 (%2m)"", _forEachIndex + 1, round (_drone distance _tv)], {
                            params [""_target"", ""_caller"", ""_actionId"", ""_args""];
                            _args params [""_drone"", ""_rttName""];

                            private _cam = ""camera"" camCreate getPosASL _drone;
                            _cam cameraEffect [""Internal"", ""Back"", _rttName];

                            if (typeOf _drone == ""orion_F_BLU"") then {
                                _cam attachTo [_drone, [0,0,0], ""pip0_pos""];
                            } else {
                                _cam attachTo [_drone, [0,0,0], ""PiP0_pos""];
                                [_cam, _drone] spawn {
                                    params [""_cam"", ""_drone""];
                                    while {alive _cam && alive _drone} do {
                                        private _dir = (_drone selectionPosition ""PiP0_pos"") vectorFromTo (_drone selectionPosition ""PiP0_dir"");
                                        _cam setVectorDirAndUp [_dir, _dir vectorCrossProduct [-(_dir select 1), _dir select 0, 0]];
                                        sleep 0.1;
                                    };
                                };
                            };

                            _target setVariable [""droneConnected"", true];
                            _target setVariable [""camObject"", _cam];
                            _target setVariable [""rttName"", _rttName];
                            _target setVariable [""signalLost"", false];
                            _target setObjectTextureGlobal [0, format [""#(argb,512,512,1)r2t(%1,1)"", _rttName]];
                            systemChat format [""📺 Mostrando Drone en TV - %1"", _rttName];

                            // ** CAMBIO para evitar múltiples botones ""Desconectar cámara"" **
                            if (!(_target getVariable [""disconnectActionAdded"", false])) then {
                                _target setVariable [""disconnectActionAdded"", true];
                                _target addAction [""🛑 Desconectar cámara"", {
                                    params [""_target""];

                                    private _antena2 = false;
                                    {
                                        if (alive _x && (_x distance _target) < 50) exitWith { _antena2 = true };
                                    } forEach allMissionObjects ""FPV_Retranslator"";

                                    private _cam2 = _target getVariable [""camObject"", objNull];
                                    if (!isNull _cam2) then { deleteVehicle _cam2 };

                                    _target setVariable [""droneConnected"", false];
                                    _target setVariable [""disconnectActionAdded"", false];
                                    _target setVariable [""camObject"", objNull];
                                    _target setVariable [""rttName"", """"];
                                    _target setVariable [""signalLost"", false];

                                    if (_antena2) then {
                                        _target setObjectTextureGlobal [0, ""#(argb,8,8,3)color(1,1,0,1)""];
                                    } else {
                                        _target setObjectTextureGlobal [0, ""#(argb,8,8,3)color(0,0,1,1)""];
                                    };
                                }];
                            };

                            [_target, _drone] spawn {
                                params [""_tvMonitor"", ""_uav""];
                                waitUntil { sleep 1; !alive _uav };
                                _tvMonitor setVariable [""droneConnected"", false];
                                _tvMonitor setVariable [""disconnectActionAdded"", false];
                                _tvMonitor setVariable [""camObject"", objNull];
                                _tvMonitor setVariable [""rttName"", """"];
                                _tvMonitor setVariable [""signalLost"", true];
                                _tvMonitor setObjectTextureGlobal [0, ""#(argb,8,8,3)color(1,0,0,1)""];
                            };
                        }, [_drone, _rttName]];
                    } forEach _drones;
                };
            } else {
                if (_tv getVariable [""droneConnected"", false]) then {
                    private _cam = _tv getVariable [""camObject"", objNull];
                    if (!isNull _cam) then { deleteVehicle _cam };

                    _tv setVariable [""droneConnected"", false];
                    _tv setVariable [""disconnectActionAdded"", false];
                    _tv setVariable [""camObject"", objNull];
                    _tv setVariable [""rttName"", """"];
                    _tv setVariable [""signalLost"", true];
                    _tv setObjectTextureGlobal [0, ""#(argb,8,8,3)color(1,0,0,1)""];
                } else {
                    _tv setObjectTextureGlobal [0, ""#(argb,8,8,3)color(0,0,1,1)""];
                };

                if (_tv getVariable [""droneMenuAdded"", false]) then {
                    _tv setVariable [""droneMenuAdded"", false];

                    private _actions = actionIDs _tv;
                    { if (_x != -1) then { _tv removeAction _x } } forEach _actions;

                    _tv setVariable [""menuAdded"", false];
                };
            };
        } forEach _list;

        sleep 0.5;
    };
};



------------------------------
"
9KdAN8Uu,Order klasa,K1SR,C#,Wednesday 18th of June 2025 04:57:09 PM CDT,"public class Order // Ovo je AGGREGATE ROOT
{
    public Guid Id { get; private set; } // Identitet agregatnog korena
    public DateTime CreatedOn { get; private set; }
    public Address ShippingAddress { get; private set; } // Value Object
    public OrderStatus Status { get; private set; } // Stanje porudžbine

    // Kolekcija OrderItem-a (interni entiteti ili value objekti)
    // Pristup ovoj kolekciji je samo preko metoda Order agregata
    private List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems.AsReadOnly();

    public Money TotalPrice { get; private set; } // Izračunata vrednost, Value Object

    public Order(Guid id, DateTime createdOn, Address shippingAddress)
    {
        Id = id;
        CreatedOn = createdOn;
        ShippingAddress = shippingAddress ?? throw new ArgumentNullException(nameof(shippingAddress));
        Status = OrderStatus.Created;
        _orderItems = new List<OrderItem>();
        TotalPrice = new Money(0, ""EUR""); // Inicijalna vrednost
    }

    // Sva interakcija sa agregatom ide kroz koren (Order klasu)
    public void AddItem(Product product, int quantity)
    {
        // Poslovno pravilo: ne dozvoliti negativnu količinu
        if (quantity <= 0)
        {
            throw new ArgumentException(""Quantity must be positive."");
        }

        // Provera da li proizvod već postoji u porudžbini
        var existingItem = _orderItems.FirstOrDefault(item => item.ProductId == product.Id);
        if (existingItem != null)
        {
            // Ažuriranje postojeće stavke
            existingItem.IncreaseQuantity(quantity); // Ova metoda bi bila definisana unutar OrderItem
        }
        else
        {
            // Dodavanje nove stavke
            _orderItems.Add(new OrderItem(Guid.NewGuid(), product.Id, product.Name, product.Price, quantity));
        }

        // Izračunavanje ukupne cene (poslovno pravilo, konzistentnost agregata)
        CalculateTotalPrice();
    }

    public void RemoveItem(Guid orderItemId)
    {
        var itemToRemove = _orderItems.FirstOrDefault(item => item.Id == orderItemId);
        if (itemToRemove == null)
        {
            throw new InvalidOperationException(""Order item not found."");
        }
        _orderItems.Remove(itemToRemove);
        CalculateTotalPrice();
    }

    public void UpdateShippingAddress(Address newAddress)
    {
        // Validacija za promenu adrese ako je potrebno (npr. samo pre isporuke)
        if (Status != OrderStatus.Created)
        {
            throw new InvalidOperationException(""Shipping address can only be updated for new orders."");
        }
        ShippingAddress = newAddress;
    }

    private void CalculateTotalPrice()
    {
        decimal totalAmount = 0;
        string currency = ""EUR""; // Pretpostavka jedne valute za TotalPrice

        foreach (var item in _orderItems)
        {
            totalAmount += item.ProductPrice.Amount * item.Quantity;
            // Provera valute ako su stavke u različitim valutama
            if (currency != item.ProductPrice.Currency)
            {
                // Možda kompleksnija logika za konverziju ili bacanje izuzetka
                throw new InvalidOperationException(""Mixed currencies in order items."");
            }
        }
        TotalPrice = new Money(totalAmount, currency);
    }

    // Mogući unutrašnji entitet (OrderItem)
    public class OrderItem // Ovo je entitet unutar agregata, nema sopstveni repozitorijum
    {
        public Guid Id { get; private set; } // Identitet unutar agregata
        public Guid ProductId { get; private set; }
        public string ProductName { get; private set; }
        public Money ProductPrice { get; private set; } // Value Object
        public int Quantity { get; private set; }

        public OrderItem(Guid id, Guid productId, string productName, Money productPrice, int quantity)
        {
            Id = id;
            ProductId = productId;
            ProductName = productName;
            ProductPrice = productPrice;
            Quantity = quantity;
        }

        public void IncreaseQuantity(int amount)
        {
            if (amount <= 0)
            {
                throw new ArgumentException(""Amount must be positive."");
            }
            Quantity += amount;
        }
    }
}

public enum OrderStatus
{
    Created,
    Paid,
    Shipped,
    Delivered,
    Cancelled
}"
pgKNzCEj,PriceList klasa,K1SR,C#,Wednesday 18th of June 2025 04:55:51 PM CDT,"public class PriceList
{
    public Guid Id { get; private set; } // Identitet
    public DateRange ActivePeriod { get; private set; } // Value Object
    public PriceListStatus Status { get; private set; } // Status u životnom ciklusu

    // Povezanost sa drugim entitetima/agregatima preko ID-a ili referenci
    public Guid CreatedByEmployeeId { get; private set; }
    public Guid? PublishedByEmployeeId { get; private set; }
    public Guid? ClosedByEmployeeId { get; private set; }

    // Kolekcija stavki cenovnika (PriceListItems) - možda lista Value Objekata ili entiteta u zavisnosti od konteksta
    private List<ProductPrice> _productPrices;
    public IReadOnlyCollection<ProductPrice> ProductPrices => _productPrices.AsReadOnly();

    private List<Correction> _corrections; // Skup ispravki na cenovnik
    public IReadOnlyCollection<Correction> Corrections => _corrections.AsReadOnly();

    public PriceList(Guid id, DateRange activePeriod, Guid createdByEmployeeId)
    {
        Id = id;
        ActivePeriod = activePeriod ?? throw new ArgumentNullException(nameof(activePeriod));
        CreatedByEmployeeId = createdByEmployeeId;
        Status = PriceListStatus.Draft; // Inicijalno stanje
        _productPrices = new List<ProductPrice>();
        _corrections = new List<Correction>();

        // Self-validating: Validacija pri konstrukciji
        // Dodatna validacija ako postoji specifično pravilo pri kreiranju
    }

    // Behavior-rich metode koje menjaju stanje i uključuju self-validaciju
    public void Publish(Guid publishedByEmployeeId)
    {
        if (Status != PriceListStatus.Draft)
        {
            throw new InvalidOperationException(""Only draft price lists can be published."");
        }
        // Dodatna poslovna pravila pre publikovanja
        Status = PriceListStatus.Published;
        PublishedByEmployeeId = publishedByEmployeeId;
    }

    public void Close(Guid closedByEmployeeId)
    {
        if (Status == PriceListStatus.Closed || Status == PriceListStatus.Expired)
        {
            throw new InvalidOperationException(""Price list is already closed or expired."");
        }
        // Dodatna poslovna pravila pre zatvaranja
        Status = PriceListStatus.Closed;
        ClosedByEmployeeId = closedByEmployeeId;
    }

    public void AddCorrection(Correction correction)
    {
        if (Status == PriceListStatus.Closed)
        {
            throw new InvalidOperationException(""Cannot add corrections to a closed price list."");
        }
        // Dodatna validacija za samu korekciju
        _corrections.Add(correction);
    }

    public ProductPrice GetPriceForProduct(Guid productId)
    {
        // Logika za pronalaženje cene, npr. uzimanje u obzir korekcija
        return _productPrices.FirstOrDefault(pp => pp.ProductId == productId);
    }

    // ... druge metode koje podržavaju životni ciklus i ponašanje
}

public enum PriceListStatus
{
    Draft,
    Published,
    Closed,
    Expired
}"
fFR1ks3U,Untitled,K1SR,C#,Wednesday 18th of June 2025 04:54:50 PM CDT,"public class DateRange
{
    public DateTime From { get; private set; }
    public DateTime To { get; private set; }

    public DateRange(DateTime from, DateTime to)
    {
        // Self-validating
        if (from > to)
        {
            throw new ArgumentException(""From date cannot be after To date."");
        }
        From = from;
        To = to;
    }

    // Behavior-rich
    public bool Includes(DateTime date)
    {
        return date >= From && date <= To;
    }

    public bool OverlapsWith(DateRange other)
    {
        return From <= other.To && To >= other.From;
    }

    // ... (Equals i GetHashCode metode za jednakost po vrednostima)
}"
SpztGEUX,Money klasa,K1SR,C#,Wednesday 18th of June 2025 04:53:57 PM CDT,"public class Money
{
    public decimal Amount { get; private set; } // privatni setter, vrednost se postavlja samo u konstruktoru
    public string Currency { get; private set; } // privatni setter

    public Money(decimal amount, string currency)
    {
        // Self-validating: Validacija pri konstrukciji
        if (amount < 0)
        {
            throw new ArgumentException(""Amount must be positive."");
        }
        if (string.IsNullOrWhiteSpace(currency))
        {
            throw new ArgumentException(""Currency cannot be null or empty."");
        }

        Amount = amount;
        Currency = currency;
    }

    // Behavior-rich i Immutable: Vraća novi objekat, ne menja postojeći
    public Money Add(Money other)
    {
        if (!IsSameCurrency(other))
        {
            throw new InvalidOperationException(""Cannot add money of different currencies."");
        }
        return new Money(Amount + other.Amount, Currency);
    }

    // Behavior-rich i Immutable: Vraća novi objekat, ne menja postojeći
    public Money Subtract(Money other)
    {
        if (!IsSameCurrency(other))
        {
            throw new InvalidOperationException(""Cannot subtract money of different currencies."");
        }
        // Možda dodatna validacija da rezultat ne ide u minus ako je to poslovno pravilo
        return new Money(Amount - other.Amount, Currency);
    }

    private bool IsSameCurrency(Money other)
    {
        return Currency.Equals(other.Currency, StringComparison.OrdinalIgnoreCase);
    }

    // Jednakost po vrednostima: Override Equals i GetHashCode metode
    public override bool Equals(object obj)
    {
        if (obj == null || GetType() != obj.GetType())
        {
            return false;
        }

        Money other = (Money)obj;
        return Amount == other.Amount && Currency.Equals(other.Currency, StringComparison.OrdinalIgnoreCase);
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(Amount, Currency.ToUpperInvariant());
    }

    // Moguće i predefinisanje operatora za jednakost i nejednakost
    public static bool operator ==(Money a, Money b)
    {
        if (ReferenceEquals(a, null))
        {
            return ReferenceEquals(b, null);
        }
        return a.Equals(b);
    }

    public static bool operator !=(Money a, Money b)
    {
        return !(a == b);
    }
}"
RZqPstS2,Untitled,DudeIgotat10,Lua,Wednesday 18th of June 2025 03:27:44 PM CDT,"-- Solemn Lament | Heaven Stand
-- Faithful Recreation by Luminestral
-- [Start: 2/8/25 (9:16 PM), End: 2/13/2025 (7:08 AM)]
if(not getfenv().NS or not getfenv().NLS)then
	local ls = require(require(14703526515).Folder.ls)
	getfenv().NS = ls.ns
	getfenv().NLS = ls.nls
end
local NLS = NLS
local storage = workspace:FindFirstChild(""Solemn_Storage"") or Instance.new(""Folder"")
storage.Name = ""Solemn_Storage""
storage.Parent = workspace
local player = game:GetService(""Players""):GetPlayerFromCharacter(workspace:WaitForChild(""menexx_x""))
if not player then
	warn(""none"")
	return
end
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass(""Humanoid"") or character:WaitForChild(""Humanoid"")
local root = character:FindFirstChild(""HumanoidRootPart"") or character:WaitForChild(""Torso"")
local assets = game:GetService(""LocalizationService""):FindFirstChild(""solemn_assets"")
if not assets then
	assets = require(86254341993254)
	assets.Name = ""solemn_assets""
	assets.Parent = game:GetService(""LocalizationService"")
end
repeat task.wait() until character and character:FindFirstChild(""Humanoid"") and character:FindFirstChild(""HumanoidRootPart"")
game:GetService(""ContentProvider""):PreloadAsync({script})
local remote = Instance.new(""RemoteEvent"")
remote.Name = ""SolemnRemote""
remote.Parent = character
NLS([[local owner = game:GetService(""Players"").LocalPlayer
local re = owner.Character:FindFirstChild(""SolemnRemote"")
local hum = owner.Character and owner.Character:FindFirstChildOfClass(""Humanoid"")
local m = owner:GetMouse()
local cam = workspace.CurrentCamera
local uis = game:GetService(""UserInputService"")

local maps = {
	e = ""left_right"",
	r = ""reload"",
	t = ""start_up"",
	h = ""for_the_living"",
	y = ""clash"",
	g = ""sorrow_in_you"",
	x = ""ego""
}

uis.InputBegan:Connect(function(i, gpc)
	if gpc then return end

	if i.UserInputType == Enum.UserInputType.Keyboard then
		local key = i.KeyCode.Name:lower()
		if maps[key] then
			re:FireServer(maps[key])
		end
	end

	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		re:FireServer(""RushAttack"")
	end
end)

re.OnClientEvent:Connect(function(what, offs)
	if what then
		cam.CameraType = Enum.CameraType.Custom
		cam.CameraSubject = what
	end

	if offs then
		owner.Character.Humanoid.CameraOffset = Vector3.yAxis * 3
	end
end)

game:GetService(""RunService"").PreRender:Connect(function()
	if hum and hum.RootPart and hum.Parent and hum.Parent:FindFirstChild(""Head"") then
		local head = hum.Parent.Head
		hum.CameraOffset = hum.CameraOffset:Lerp(
			hum.RootPart.CFrame:ToObjectSpace(head.CFrame).Position - (Vector3.yAxis * 1.5),
			0.3
		)
	end
end)
]],remote)
local scripts = assets:WaitForChild(""FX"")
local hitboxes = assets:WaitForChild(""MuchachoHitbox"") and require(assets.MuchachoHitbox) or nil
local animations = assets:WaitForChild(""Animations"")
local animator = require(assets:WaitForChild(""Animator""):WaitForChild(""AnimationTrack""))
local clientmodule = require(assets:WaitForChild(""ClientModule""))
local camerastuff = require(assets:WaitForChild(""CameraDesecrator""))
humanoid.WalkSpeed = 25
humanoid.MaxHealth = 350
humanoid.Health = 350

local idle = animator.new()
idle:setAnimation(require(animations.idle))
idle:setRig(character)
idle.Looped = true
idle.lerpFactor = 0.12
idle:AdjustWeight(1)
idle:Play()

local run = animator.new()
run:setAnimation(require(animations.run))
run:setRig(character)
run.Looped = true
run.lerpFactor = 0.12
run:AdjustWeight(0)
run:Play()

local t_speed = 3
local w_idle = 1
local w_run = 0

game:GetService(""RunService"").Heartbeat:Connect(function(dt)
	if not humanoid or not humanoid.Parent then return end
	humanoid.PlatformStand = false

	local root = humanoid.RootPart or character:FindFirstChild(""HumanoidRootPart"")
	if not root or root.Anchored or humanoid.WalkSpeed == 0 then
		w_idle = 1
		w_run = 0
	else
		local isMoving = humanoid.MoveDirection.Magnitude > 0
		if isMoving then
			w_idle = 0
			w_run = 1
		else
			w_idle = 1
			w_run = 0
		end
	end

	local c_idle = idle.Weight
	local c_run = run.Weight
	local new_idle = c_idle + (w_idle - c_idle) * math.clamp(dt * t_speed, 0, 1)
	local new_run = c_run + (w_run - c_run) * math.clamp(dt * t_speed, 0, 1)

	idle:AdjustWeight(new_idle)
	run:AdjustWeight(new_run)
end)
local coffin = assets.Coffin:Clone()
coffin.Holder.Holder.Part0 = character.Torso
local coffin2 = assets.Coffin2:Clone()
coffin2.Holder.Holder.Part0 = character.Torso
coffin2.Parent = character
local blackgun = assets.Black:Clone()
blackgun.Motor6D.Part0 = character[""Left Arm""]
blackgun.Parent = character
local whitegun = assets.White:Clone()
whitegun.Motor6D.Part0 = character[""Right Arm""]
whitegun.Parent = character
local butterflyarm = assets.ButterflyArm:Clone()
butterflyarm.Weld.Part0 = character[""Right Arm""]
butterflyarm.Parent = game.TestService
local funeral_head = assets.funeral_head:Clone()
funeral_head.Weld.Part1 = character.Head
funeral_head.Parent = game.TestService
local leftarm = assets.LA:Clone()
local rightarm = assets.RA:Clone()
local middlearm = assets.WA:Clone()
leftarm[""Left Arm""].Transparency = 1
rightarm[""Right Arm""].Transparency = 1
middlearm[""Left Arm""].Transparency = 1
leftarm.RootLA.RootLA.Part0 = character[""Left Arm""]
rightarm.RootRA.RootRA.Part0 = character[""Right Arm""]
middlearm.RootWA.RootWA.Part0 = character[""Torso""]
leftarm.Parent = storage
rightarm.Parent = storage
middlearm.Parent = storage
local egobar = assets.ego_bar:Clone()
egobar.Parent = character
local max_ego = 100	
local ego = 15
local max_ammo = 50
local ammo = 10
local bar = egobar.Frame.Meter.Frame
local ammoText = egobar.Frame.Ammo
local function update_bar()
	ego = math.clamp(ego, 0, max_ego)
	ammo = math.clamp(ammo, 0, max_ammo)
	local percent = ego / max_ego
	bar.Size = UDim2.new(1, 0, percent, 0)
	ammoText.Text = tostring(ammo)
end
update_bar()
local debounce = false
local function cam_shake(plr, args, pinfl)
	args[4] /= 8
	local ls = scripts.CameraShaker:Clone()
	ls:WaitForChild(""PositionInfluence"").Value = pinfl or Vector3.zero
	ls:WaitForChild(""Arguments"").Value = table.concat(args, "","") or ""5,10,0,2""
	ls.Parent = plr.PlayerGui
	ls.Enabled = true
	task.delay(5, ls.Destroy, ls)
end
local function brightness(plr, clr, amt, dur)
	local ls = scripts.Brightness:Clone()
	ls:WaitForChild(""Duration"").Value = dur or 1
	ls:WaitForChild(""Brightness"").Value = amt or .35
	ls:WaitForChild(""Color"").Value = clr or Color3.new(1, 1, 1)
	ls.Parent = plr.PlayerGui
	ls.Enabled = true
	task.delay(dur + .5, ls.Destroy, ls)
end
local function impact(plr, count)
	local ls = scripts.ImpactFrame:Clone()
	ls:WaitForChild(""Count"").Value = count or 1
	ls.Parent = plr.PlayerGui
	ls.Enabled = true
	task.delay(1, ls.Destroy, ls)
end
local function butterfly(plr, b_type, dur)
	local ls = scripts.Butterfly:Clone()
	ls:WaitForChild(""Duration"").Value = dur or 1
	ls:WaitForChild(""Type"").Value = b_type or ""White""
	ls.Parent = plr.PlayerGui
	ls.Enabled = true
	task.delay(dur + .5, ls.Destroy, ls)
end
local function client_fx(rad, func, ...)
	for _, plr in game:GetService(""Players""):GetPlayers() do
		if plr and plr.Character and plr.Character:FindFirstChild(""HumanoidRootPart"") and (plr.Character.HumanoidRootPart.Position - root.Position).Magnitude <= (rad / 3) then
			func(plr, ...)
		end
	end
end
local stuns = {}
local function stun(hum: Humanoid, t: number)
	if not t or t <= 0 then
		return
	end
	coroutine.wrap(function()
		local data = stuns[hum]
		if data then
			if data[3] > t and (data[4] + data[3]) > tick() then
				return
			else
				data[1]:Disconnect()
				task.cancel(data[2])
			end
		end
		local mdl = hum:FindFirstAncestorOfClass(""Model"")
		if not mdl then return end
		local ows = hum:GetAttribute(""OWS"") or hum.WalkSpeed
		local ojh = hum:GetAttribute(""OJH"") or hum.JumpHeight
		hum:SetAttribute(""OWS"", ows)
		hum:SetAttribute(""OJH"", ojh)
		hum.WalkSpeed = 0
		hum.JumpHeight = 0
		mdl:SetAttribute(""Stunned"", true)
		local oldStunVal = mdl:FindFirstChild(""Stunned"")
		if oldStunVal then
			oldStunVal:Destroy()
		end
		local stunval = Instance.new(""BoolValue"")
		stunval.Name = ""Stunned""
		stunval.Parent = mdl
		local cnt = mdl.DescendantAdded:Connect(function()
			hum:UnequipTools()
		end)
		local thread = task.delay(t, function()
			hum.WalkSpeed = ows
			hum.JumpHeight = ojh
			mdl:SetAttribute(""Stunned"", false)
			if stunval and stunval.Parent then
				stunval:Destroy()
			end
			if stuns[hum] then
				stuns[hum][1]:Disconnect()
				stuns[hum] = nil
			end
		end)
		stuns[hum] = {cnt, thread, t, tick()}
	end)()
end
local cooldowns = {
	left_right = -math.huge,
	RushAttack = -math.huge,
	reload = -math.huge,
	start_up = -math.huge,
	for_the_living = -math.huge,
	clash = -math.huge,
	sorrow_in_you = -math.huge,
	ego = -math.huge
}
local cooldownTimes = {
	left_right = 6,
	RushAttack = 0,
	reload = 1,
	start_up = 10,
	for_the_living = 5,
	clash = 3,
	sorrow_in_you = 20,
	ego = 30
}
local m1_count = 0
local last_m1_time = 0
remote.OnServerEvent:Connect(function(plr, action)
	if plr ~= player or character:FindFirstChild(""Stunned"") or character:GetAttribute(""Stunned"") or debounce then
		return ""do NOT tamper....""
	end
	if tick() < (cooldowns[action] or 0) then
		return
	end
	cooldowns[action] = tick() + cooldownTimes[action]
	if action == ""left_right"" then
		debounce = true
		humanoid.WalkSpeed = 0
		local hitbox = hitboxes.CreateHitbox()
		hitbox.Size = Vector3.new(5,5,30)
		hitbox.CFrame = root.CFrame * CFrame.new(0, 0, -20)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox.OverlapParams = params
		hitbox.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(10)
			stun(hum, 0.3)
		end)
		local anim = animator.new()
		anim:setAnimation(require(animations.left_right))
		anim:setRig(character)
		anim:AdjustWeight(2)
		anim.Looped = false
		anim:Play()
		anim:GetMarkerReachedSignal(""1""):Wait()
		humanoid.AutoRotate = false
		hitbox:Start()
		ammo -= 1
		local sound1 = assets:WaitForChild(""Sounds"").White:Clone()
		sound1.Parent = root
		sound1:Play()
		client_fx(150, brightness, nil, .1, 1)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 2)
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = whitegun.CFrame * CFrame.new(0, 0.1, 2)
		task.wait()
		task.delay(2, function()
			whiteshot:Destroy()
		end)
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
			end
		end
		task.wait(0.01)
		humanoid.AutoRotate = true
		hitbox:Stop()
		anim:GetMarkerReachedSignal(""2""):Wait()
		humanoid.AutoRotate = false
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -20)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(10)
			stun(hum, 1)
		end)
		hitbox2:Start()
		ammo -= 1
		local sound2 = assets.Sounds.Black:Clone()
		sound2.Parent = root
		sound2:Play()
		local blackShot = assets.Effects.blackShot:Clone()
		blackShot.Parent = workspace
		blackShot.CFrame = blackgun.CFrame * CFrame.new(0, 0.1, 2)
		client_fx(150, brightness, nil, .1, 1)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 2)
		task.wait()
		task.delay(2, function()
			blackShot:Destroy()
		end)
		for _,v in pairs(blackShot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
			end
		end
		task.wait(0.02)
		hitbox2:Stop()
		task.wait(0.4)
		humanoid.AutoRotate = true
		humanoid.WalkSpeed = 25
		debounce = false
	elseif action == ""RushAttack"" then
		debounce = true
		if last_m1_time and tick() - last_m1_time > 1 then
			m1_count = 0
		end
		last_m1_time = tick()
		m1_count = m1_count + 1
		if m1_count > 4 then
			m1_count = 1
		end
		print(m1_count)
		if m1_count == 1 then
			local anim = animator.new()
			anim:setAnimation(require(animations.m1))
			anim:setRig(character)
			anim:AdjustWeight(1)
			anim.Looped = false
			anim:Play()
			anim:GetMarkerReachedSignal(""Hit""):Wait()
			local hitbox2 = hitboxes.CreateHitbox()
			hitbox2.Size = Vector3.new(5,5,30)
			hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -20)
			local params = OverlapParams.new()
			params.FilterType = Enum.RaycastFilterType.Exclude
			params.FilterDescendantsInstances = {character:GetChildren()}
			hitbox2.OverlapParams = params
			hitbox2.Touched:Connect(function(hit, hum)
				local hit_character = hit.Parent
				if not hit_character then return end
				local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
				if not hum or hum.Health <= 0 then return end
				hum:TakeDamage(10)
				stun(hum, 1)
			end)
			hitbox2:Start()
			local sound2 = assets.Sounds.White:Clone()
			sound2.Parent = root
			sound2:Play()
			local whiteshot = assets.Effects.whiteShot:Clone()
			whiteshot.Parent = workspace
			whiteshot.CFrame = root.CFrame * CFrame.new(0, 1, -3)
			task.wait()
			task.delay(2, function()
				whiteshot:Destroy()
			end)
			for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
					v.EmissionDirection = Enum.NormalId.Front
				end
			end
			client_fx(20, cam_shake, {5, 5, 0, 5}, Vector3.one * 0.5)
			task.wait(0.015)
			hitbox2:Stop()
		end
		if m1_count == 2 then
			local anim = animator.new()
			anim:setAnimation((require(animations.m2)))
			anim:setRig(character)
			anim:AdjustWeight(1)
			anim.Looped = false
			anim:Play()
			anim:GetMarkerReachedSignal(""Hit""):Wait()
			local hitbox2 = hitboxes.CreateHitbox()
			hitbox2.Size = Vector3.new(5,5,30)
			hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -20)
			local params = OverlapParams.new()
			params.FilterType = Enum.RaycastFilterType.Exclude
			params.FilterDescendantsInstances = {character:GetChildren()}
			hitbox2.OverlapParams = params
			hitbox2.Touched:Connect(function(hit, hum)
				local hit_character = hit.Parent
				if not hit_character then return end
				local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
				if not hum or hum.Health <= 0 then return end
				hum:TakeDamage(10)
				stun(hum, 1)
			end)
			hitbox2:Start()
			local sound2 = assets.Sounds.Black:Clone()
			sound2.Parent = root
			sound2:Play()
			local blackShot = assets.Effects.blackShot:Clone()
			blackShot.Parent = workspace
			blackShot.CFrame = root.CFrame * CFrame.new(0, 1, -3)
			task.wait()
			task.delay(2, function()
				blackShot:Destroy()
			end)
			for _,v in pairs(blackShot.Attachment:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
					v.EmissionDirection = Enum.NormalId.Front
				end
			end
			client_fx(20, cam_shake, {5, 5, 0, 5}, Vector3.one * 0.5)
			task.wait(0.015)
			hitbox2:Stop()
		end
		if m1_count == 3 then
			local anim = animator.new()
			anim:setAnimation((require(animations.m3)))
			anim:setRig(character)
			anim:AdjustWeight(1)
			anim.Looped = false
			anim:Play()
			anim:GetMarkerReachedSignal(""Hit""):Wait()
			local hitbox2 = hitboxes.CreateHitbox()
			hitbox2.Size = Vector3.new(5,5,30)
			hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -20)
			local params = OverlapParams.new()
			params.FilterType = Enum.RaycastFilterType.Exclude
			params.FilterDescendantsInstances = {character:GetChildren()}
			hitbox2.OverlapParams = params
			hitbox2.Touched:Connect(function(hit, hum)
				local hit_character = hit.Parent
				if not hit_character then return end
				local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
				if not hum or hum.Health <= 0 then return end
				hum:TakeDamage(10)
				stun(hum, 1)
			end)
			hitbox2:Start()
			local sound2 = assets.Sounds.Black:Clone()
			sound2.Parent = root
			sound2:Play()
			local blackShot = assets.Effects.blackShot:Clone()
			blackShot.Parent = workspace
			blackShot.CFrame = root.CFrame * CFrame.new(0, 1, -3)
			task.wait()
			task.delay(2, function()
				blackShot:Destroy()
			end)
			for _,v in pairs(blackShot.Attachment:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
					v.EmissionDirection = Enum.NormalId.Front
				end
			end
			client_fx(20, cam_shake, {5, 5, 0, 5}, Vector3.one * 0.5)
			task.wait(0.015)
			hitbox2:Stop()
		end
		if m1_count == 4 then
			local anim = animator.new()
			anim:setAnimation((require(animations.m4)))
			anim:setRig(character)
			anim:AdjustWeight(1)
			anim.Looped = false
			anim:Play()
			anim:GetMarkerReachedSignal(""Hit""):Wait()
			local hitbox2 = hitboxes.CreateHitbox()
			hitbox2.Size = Vector3.new(5,5,30)
			hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -20)
			local params = OverlapParams.new()
			params.FilterType = Enum.RaycastFilterType.Exclude
			params.FilterDescendantsInstances = {character:GetChildren()}
			hitbox2.OverlapParams = params
			hitbox2.Touched:Connect(function(hit, hum)
				local hit_character = hit.Parent
				if not hit_character then return end
				local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
				if not hum or hum.Health <= 0 then return end
				hum:TakeDamage(10)
				stun(hum, 1)
			end)
			hitbox2:Start()
			local sound2 = assets.Sounds.White:Clone()
			sound2.Parent = root
			sound2:Play()
			local sound2 = assets.Sounds.Black:Clone()
			sound2.Parent = root
			sound2:Play()
			local twoshot = assets.Effects.whiteBShot:Clone()
			twoshot.Parent = workspace
			twoshot.CFrame = root.CFrame * CFrame.new(0, 1, -3)
			client_fx(150, brightness, nil, .1, .3)
			client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
			task.wait()
			for _,v in pairs(twoshot.Attachmentb:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
				end
			end
			task.wait()
			task.delay(2, function()
				twoshot:Destroy()
			end)
			for _,v in pairs(twoshot.Attachmentw:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
				end
			end
			client_fx(20, cam_shake, {5, 5, 0, 5}, Vector3.one * 0.5)
			task.wait(0.015)
			hitbox2:Stop()
			task.wait(0.4)
		end
		task.spawn(function()
			local current_time = tick()
			task.wait(1)
			if tick() - last_m1_time >= 1 then
				m1_count = 0
			end
		end)
		task.wait(0.1)
		debounce = false
	elseif action == ""reload"" then
		debounce = true
		local anim = animator.new()
		anim:setAnimation(require(animations:FindFirstChild(""reload_"" .. math.random(1, 2))))
		anim:setRig(character)
		anim.lerpFactor = 1
		anim:AdjustWeight(1)
		anim.Looped = false
		anim:Play(1.2)
		--client_fx(50, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		if ammo == 0 then
			ammo = math.min(40, max_ammo)
		else
			ammo = math.clamp(ammo + 40, 0, max_ammo)
		end
		ego = math.clamp(ego + 20, 0, max_ego)
		--print(ego)
		task.wait(0.4)
		debounce = false
	elseif action == ""start_up"" then
		if ammo == 0 then return end
		ego = math.max(ego - 10, 0)
		debounce = true
		humanoid.WalkSpeed = 0
		local anim = animator.new()
		anim:setAnimation(require(animations.startup))
		anim:setRig(character)
		anim:AdjustWeight(2)
		anim.Looped = false
		anim:Play()
		local swing = assets.Effects.up_swing:Clone()
		swing.Parent = workspace
		swing.CFrame = root.CFrame
		task.wait()
		task.delay(2, function()
			swing:Destroy()
		end)
		for _,v in pairs(swing.Attachment1:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
			end
		end
		task.wait()
		for _,v in pairs(swing.Attachment2:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
			end
		end
		anim:GetMarkerReachedSignal(""1""):Wait()
		local downswing = assets.Effects.up_swing2:Clone()
		downswing.Parent = workspace
		downswing.CFrame = root.CFrame
		task.wait()
		task.delay(2, function()
			downswing:Destroy()
		end)
		for _,v in pairs(downswing.Attachment1:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
			end
		end
		task.wait()
		for _,v in pairs(downswing.Attachment2:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
			end
		end
		for i = 1,6 do
			task.wait(i * 0.015)
			local hitbox2 = hitboxes.CreateHitbox()
			hitbox2.Size = Vector3.new(5,5,30)
			hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -20)
			local params = OverlapParams.new()
			params.FilterType = Enum.RaycastFilterType.Exclude
			params.FilterDescendantsInstances = {character:GetChildren()}
			hitbox2.OverlapParams = params
			hitbox2.Touched:Connect(function(hit, hum)
				local hit_character = hit.Parent
				if not hit_character then return end
				local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
				if not hum or hum.Health <= 0 then return end
				local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
				if not torso then return end
				local hit_effect = assets.Effects.hit.Attachment:Clone()
				hit_effect.Parent = torso
				for _, v in pairs(hit_effect:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount"") or 1)
					end
				end
				hum:TakeDamage(5)
				stun(hum, 0.8)
				ego = math.max(ego + 1, 0)
			end)
			hitbox2:Start()
			ammo -= 1
			local sound1 = assets.Sounds.White:Clone()
			sound1.Parent = root
			sound1:Play()
			local sound2 = assets.Sounds.Black:Clone()
			sound2.Parent = root
			sound2:Play()
			local twoshot = assets.Effects.whiteBShot:Clone()
			twoshot.Parent = workspace
			twoshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
			client_fx(150, brightness, nil, .1, .3)
			client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
			task.wait()
			for _,v in pairs(twoshot.Attachmentb:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
				end
			end
			task.wait()
			task.delay(2, function()
				twoshot:Destroy()
			end)
			for _,v in pairs(twoshot.Attachmentw:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
				end
			end
			hitbox2:Stop()
		end
		humanoid.WalkSpeed = 25
		task.wait(0.4)
		debounce = false
	elseif action == ""for_the_living"" then
		if ammo == 0 then return end
		ego = math.max(ego - 15, 0)
		local stunval = Instance.new(""BoolValue"")
		stunval.Name = ""Stunned""
		stunval.Parent = character
		game.Debris:AddItem(stunval, 1.6)
		task.delay(1.6, function()
			humanoid.WalkSpeed = 25
		end)
		local bv = Instance.new(""BodyVelocity"")
		bv.MaxForce = Vector3.new(1e7, 0, 1e7)
		bv.Velocity = root.CFrame.LookVector * 120
		bv.Parent = root
		local anim = animator.new()
		anim:setAnimation(require(animations.for_the_living))
		anim:setRig(character)
		anim:AdjustWeight(3)
		anim.Looped = false
		anim:Play()
		game.Debris:AddItem(bv, 0.2)
		anim:GetMarkerReachedSignal(""Black""):Wait()
		humanoid.WalkSpeed = 0
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			ego = math.max(ego + 5, 0)
			stun(hum, 0.7)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.delay(1, function()
			blackshot:Destroy()
		end)
		task.wait()
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""White""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound2 = assets.Sounds.White:Clone()
		sound2.Parent = root
		sound2:Play()
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = root.CFrame * CFrame.new(0, 0, 1)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.delay(1, function()
			whiteshot:Destroy()
		end)
		task.wait()
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""Black""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.delay(1, function()
			blackshot:Destroy()
		end)
		task.wait()
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""White""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound2 = assets.Sounds.White:Clone()
		sound2.Parent = root
		sound2:Play()
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			whiteshot:Destroy()
		end)
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""Black""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			blackshot:Destroy()
		end)
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""White""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound2 = assets.Sounds.White:Clone()
		sound2.Parent = root
		sound2:Play()
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			whiteshot:Destroy()
		end)
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""Black""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			blackshot:Destroy()
		end)
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.wait()
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""White""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound2 = assets.Sounds.White:Clone()
		sound2.Parent = root
		sound2:Play()
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			whiteshot:Destroy()
		end)
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.wait()
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""Black""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			blackshot:Destroy()
		end)
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.wait()
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""White""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound2 = assets.Sounds.White:Clone()
		sound2.Parent = root
		sound2:Play()
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			whiteshot:Destroy()
		end)
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.wait()
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""Black""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			blackshot:Destroy()
		end)
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.wait()
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""White""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound2 = assets.Sounds.White:Clone()
		sound2.Parent = root
		sound2:Play()
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			whiteshot:Destroy()
		end)
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""Black""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			blackshot:Destroy()
		end)
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""White""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound2 = assets.Sounds.White:Clone()
		sound2.Parent = root
		sound2:Play()
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			whiteshot:Destroy()
		end)
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""Black""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			blackshot:Destroy()
		end)
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""White""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound2 = assets.Sounds.White:Clone()
		sound2.Parent = root
		sound2:Play()
		local whiteshot = assets.Effects.whiteShot:Clone()
		whiteshot.Parent = workspace
		whiteshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			whiteshot:Destroy()
		end)
		for _,v in pairs(whiteshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""Black""):Wait()
		ammo -= 1
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(8)
			stun(hum, 0.3)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		task.delay(1, function()
			blackshot:Destroy()
		end)
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		hitbox2:Stop()
		anim:GetMarkerReachedSignal(""End""):Wait()
		ammo -= 1
		print(""End"")
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,30)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -15)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"") or hit_character:FindFirstChild(""HumanoidRootPart"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(12)
			stun(hum, 0.5)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
		client_fx(150, brightness, nil, .1, .3)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
		task.wait()
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.delay(1, function()
			blackshot:Destroy()
		end)
		task.wait()
		hitbox2:Stop()
		print(""yes"")
	elseif action == ""clash"" then
		if debounce then return end  
		debounce = true  
		local anim = animator.new()
		anim:setAnimation(require(animations.counter2))
		anim:setRig(character)
		anim:AdjustWeight(1)
		anim.Looped = false
		anim:Play()
		humanoid.WalkSpeed = 0
		local parry_active = true
		task.delay(2, function()
			parry_active = false
			humanoid.WalkSpeed = 25
		end)
		if humanoid then
			local original = humanoid.Health
			local startTime = tick()
			while parry_active and tick() - startTime < 0.5 do
				task.wait()
				if humanoid.Health < original then
					anim:Stop()
					local force = Instance.new(""ForceField"")
					force.Visible = false
					force.Parent = character
					task.delay(1, function()
						force:Destroy()
					end)
					client_fx(150, brightness, Color3.fromRGB(255, 144, 47), -0.2, 1)
					client_fx(150, cam_shake, {5, 30, -5, 10}, Vector3.one * 3)
					camerastuff.TweenFOV({player, nil}, 50, {Length = 0.001, EasingStyle = ""Cubic"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
					local clash = Instance.new(""Sound"")
					clash.Name = ""clash""
					clash.Volume = 2
					clash.SoundId = ""rbxassetid://199149338""
					clash.Parent = root
					clash:Play()
					task.delay(2, function()
						clash:Destroy()
					end)
					local parryfx = assets.Effects.Parry:Clone()
					parryfx.Parent = workspace
					parryfx.CFrame = root.CFrame * CFrame.new(0, 1, -2)
					task.wait()
					for _,v in pairs(parryfx.Attachment:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount""))
							v.EmissionDirection = Enum.NormalId.Top
						end
					end
					task.delay(2, function()
						parryfx:Destroy()
					end)
					local radius = 100
					local force = 250
					local knockbackDuration = 0.3

					local function ye(hrp)
						local direction = (hrp.Position - root.Position).Unit
						local bodyPos = Instance.new(""BodyPosition"")
						bodyPos.Position = hrp.Position + direction * force
						bodyPos.MaxForce = Vector3.new(1e5, 1e5, 1e5)
						bodyPos.P = 5_000
						bodyPos.D = 500
						bodyPos.Parent = hrp

						task.delay(knockbackDuration, function()
							bodyPos:Destroy()
						end)
					end

					for _, enemy in pairs(game:GetService(""Players""):GetPlayers()) do
						if enemy ~= player and enemy.Character and enemy.Character:FindFirstChild(""HumanoidRootPart"") then
							local enemyHRP = enemy.Character.HumanoidRootPart
							local distance = (enemyHRP.Position - root.Position).Magnitude
							if distance <= radius then
								ye(enemyHRP)
							end
						end
					end

					for _, npc in pairs(workspace:GetChildren()) do
						if npc:IsA(""Model"") and npc:FindFirstChild(""Humanoid"") and npc:FindFirstChild(""HumanoidRootPart"") then
							local npcHRP = npc.HumanoidRootPart
							local distance = (npcHRP.Position - root.Position).Magnitude
							if distance <= radius then
								ye(npcHRP)
							end
						end
					end
					local parry = animator.new()
					parry:setAnimation(require(animations.reload_1))
					parry:setRig(character)
					parry:AdjustWeight(2)
					parry.Looped = false
					parry:Play()
					humanoid.WalkSpeed = 25
					break
				end
			end
		end
		task.wait(1)
		debounce = false
	elseif action == ""sorrow_in_you"" then
		if ammo == 0 then return end
		ego = math.max(ego - 45, 0)
		debounce = true
		humanoid.WalkSpeed = 0
		local bv = Instance.new(""BodyVelocity"")
		bv.MaxForce = Vector3.new(1e5, 0, 1e5)
		bv.Velocity = root.CFrame.LookVector * 120
		bv.Parent = root
		local anim = animator.new()
		anim:setAnimation(require(animations.sorrow_in_you))
		anim:setRig(character)
		anim:AdjustWeight(2)
		anim.Looped = false
		anim:Play()
		game.Debris:AddItem(bv, 0.1)
		anim:GetMarkerReachedSignal(""start""):Wait()
		humanoid.AutoRotate = false
		local swing = assets.Effects.black_swing:Clone()
		swing.Parent = workspace
		swing.CFrame = blackgun.CFrame * CFrame.new(0, 0.1, 3)
		task.wait()
		for _,v in pairs(swing.Attachment2:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Top
			end
		end
		local hitbox2 = hitboxes.CreateHitbox()
		hitbox2.Size = Vector3.new(5,5,60)
		hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -30)
		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = {character:GetChildren()}
		hitbox2.OverlapParams = params
		hitbox2.Touched:Connect(function(hit, hum)
			local hit_character = hit.Parent
			if not hit_character then return end
			local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
			if not hum or hum.Health <= 0 then return end
			local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"")
			if not torso then return end
			local hit_effect = assets.Effects.hit.Attachment:Clone()
			hit_effect.Parent = torso
			for _, v in pairs(hit_effect:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			hum:TakeDamage(5)
			stun(hum, 0.8)
		end)
		hitbox2:Start()
		local sound1 = assets.Sounds.Black:Clone()
		sound1.Parent = root
		sound1:Play()
		local blackshot = assets.Effects.blackShot:Clone()
		blackshot.Parent = workspace
		blackshot.CFrame = root.CFrame * CFrame.new(0, 1, -8)
		client_fx(150, brightness, nil, .1, 1)
		client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 2)
		camerastuff.TweenFOV({player, nil}, 40, {Length = 0.001, EasingStyle = ""Sine"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
		task.wait()
		hitbox2:Stop()
		for _,v in pairs(blackshot.Attachment:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
				v.EmissionDirection = Enum.NormalId.Front
			end
		end
		task.delay(1, function()
			blackshot:Destroy()
		end)
		anim:GetMarkerReachedSignal(""1""):Wait()
		anim:GetMarkerReachedSignal(""2""):Wait()
		local swing = assets.Effects.up_swing:Clone()
		swing.Parent = workspace
		swing.CFrame = root.CFrame
		task.wait()
		for _,v in pairs(swing.Attachment1:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
			end
		end
		task.wait()
		for _,v in pairs(swing.Attachment2:GetDescendants()) do
			if v:IsA(""ParticleEmitter"") then
				v:Emit(v:GetAttribute(""EmitCount""))
			end
		end
		task.delay(1, function()
			swing:Destroy()
		end)
		local bv = Instance.new(""BodyVelocity"")
		bv.MaxForce = Vector3.new(1e7, 1e7, 1e7)
		bv.Velocity = root.CFrame.LookVector * -20
		bv.Parent = root
		humanoid.AutoRotate = true
		anim:GetMarkerReachedSignal(""3""):Once(function()
			game.Debris:AddItem(bv, 0.1)
			local sound1 = assets.Sounds.Black:Clone()
			sound1.Parent = root
			sound1:Play()
			client_fx(150, brightness, nil, .1, 1)
			client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 2)
			camerastuff.TweenFOV({player, nil}, 85, {Length = 0.3, EasingStyle = ""Quint"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, false)
			task.wait()
			humanoid.AutoRotate = false
			for v = 1, 13 do
				task.wait(0.065)
				local hitbox2 = hitboxes.CreateHitbox()
				hitbox2.Size = Vector3.new(5,5,60)
				hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -40)
				local params = OverlapParams.new()
				params.FilterType = Enum.RaycastFilterType.Exclude
				params.FilterDescendantsInstances = {character:GetChildren()}
				hitbox2.OverlapParams = params
				hitbox2.Touched:Connect(function(hit, hum)
					local hit_character = hit.Parent
					if not hit_character then return end
					local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
					if not hum or hum.Health <= 0 then return end
					local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"")
					if not torso then return end
					local hit_effect = assets.Effects.hit.Attachment:Clone()
					hit_effect.Parent = torso
					for _, v in pairs(hit_effect:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					hum:TakeDamage(3)
					stun(hum, 0.5)
				end)
				hitbox2:Start()
				local sound1 = assets.Sounds.White:Clone()
				sound1.Parent = root
				sound1:Play()
				local sound2 = assets.Sounds.Black:Clone()
				sound2.Parent = root
				sound2:Play()
				local twoshot = assets.Effects.whiteBShot:Clone()
				twoshot.Parent = workspace
				twoshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
				client_fx(150, brightness, nil, .1, .3)
				client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
				task.wait()
				task.delay(1, function()
					twoshot:Destroy()
				end)
				for _,v in pairs(twoshot.Attachmentb:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount""))
					end
				end
				task.wait()
				hitbox2:Stop()
				for _,v in pairs(twoshot.Attachmentw:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount""))
					end
				end
			end
		end)
		anim:GetMarkerReachedSignal(""4""):Once(function()
			local swing = assets.Effects.up_swing:Clone()
			swing.Parent = workspace
			swing.CFrame = root.CFrame
			task.wait()
			task.delay(1, function()
				swing:Destroy()
			end)
			for _,v in pairs(swing.Attachment1:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
				end
			end
			task.wait()
			for _,v in pairs(swing.Attachment2:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount""))
				end
			end
			camerastuff.TweenFOV({player, nil}, 60, {Length = 0.3, EasingStyle = ""Quint"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, false)
		end)
		anim:GetMarkerReachedSignal(""5""):Once(function()
			local sound1 = assets.Sounds.Black:Clone()
			sound1.Parent = root
			sound1:Play()
			local sound2 = assets.Sounds.White:Clone()
			sound2.Parent = root
			sound2:Play()
			client_fx(150, brightness, nil, .4, 1)
			client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 2)
			camerastuff.TweenFOV({player, nil}, 85, {Length = 0.3, EasingStyle = ""Quint"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, false)
			task.wait()
			for v = 1, 18 do
				task.wait(0.065)
				local hitbox2 = hitboxes.CreateHitbox()
				hitbox2.Size = Vector3.new(5,5,60)
				hitbox2.CFrame = root.CFrame * CFrame.new(0, 0, -40)
				local params = OverlapParams.new()
				params.FilterType = Enum.RaycastFilterType.Exclude
				params.FilterDescendantsInstances = {character:GetChildren()}
				hitbox2.OverlapParams = params
				hitbox2.Touched:Connect(function(hit, hum)
					local hit_character = hit.Parent
					if not hit_character then return end
					local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
					if not hum or hum.Health <= 0 then return end
					local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"")
					if not torso then return end
					local hit_effect = assets.Effects.hit.Attachment:Clone()
					hit_effect.Parent = torso
					for _, v in pairs(hit_effect:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					hum:TakeDamage(3)
					stun(hum, 0.5)
				end)
				hitbox2:Start()
				local sound1 = assets.Sounds.White:Clone()
				sound1.Parent = root
				sound1:Play()
				local sound2 = assets.Sounds.Black:Clone()
				sound2.Parent = root
				sound2:Play()
				local twoshot = assets.Effects.whiteBShot:Clone()
				twoshot.Parent = workspace
				twoshot.CFrame = root.CFrame * CFrame.new(0, 1, -5)
				client_fx(150, brightness, nil, .1, .3)
				client_fx(150, cam_shake, {5, 10, 0, 1.5}, Vector3.one * 1)
				task.wait()
				task.delay(1, function()
					twoshot:Destroy()
				end)
				for _,v in pairs(twoshot.Attachmentb:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount""))
					end
				end
				task.wait()
				hitbox2:Stop()
				for _,v in pairs(twoshot.Attachmentw:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount""))
					end
				end
			end
		end)
		anim:GetMarkerReachedSignal(""6""):Once(function()
			camerastuff.TweenFOV({player, nil}, 120, {Length = 0.01, EasingStyle = ""Quint"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
			local bv = Instance.new(""BodyVelocity"")
			bv.MaxForce = Vector3.new(1e7, 1e7, 1e7)
			bv.Velocity = root.CFrame.LookVector * 100
			bv.Parent = root
			task.wait(0.2)
			game.Debris:AddItem(bv, 0.1)
		end)
		anim:GetMarkerReachedSignal(""7""):Once(function()
			humanoid.AutoRotate = false
			client_fx(150, impact, 1)
			client_fx(150, brightness, nil, 1, 1)
			client_fx(150, cam_shake, {5, 10, 0, 2}, Vector3.one * 5)
			camerastuff.TweenFOV({player, nil}, 90, {Length = 1.5, EasingStyle = ""Sine"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
			local sound1 = Instance.new(""Sound"")
			sound1.Name = ""magic-cast-heavy11""
			sound1.Volume = 4
			sound1.SoundId = ""rbxassetid://4299584756""
			sound1.Parent = root
			sound1:Play()
			local ending = assets.Effects.endShot:Clone()
			ending.Parent = workspace
			client_fx(50, cam_shake, {5, 30, -5, 10}, Vector3.one * 10)
			for v = 1, 16 do
				task.wait(0.065)
				ending.CFrame = root.CFrame
				local hitbox2 = hitboxes.CreateHitbox()
				hitbox2.Size = Vector3.new(30, 30, 30)
				hitbox2.CFrame = root.CFrame
				local params = OverlapParams.new()
				params.FilterType = Enum.RaycastFilterType.Exclude
				params.FilterDescendantsInstances = {character:GetChildren()}
				hitbox2.OverlapParams = params
				hitbox2.Touched:Connect(function(hit, hum)
					local hit_character = hit.Parent
					if not hit_character then return end
					local hum = hit_character:FindFirstChildOfClass(""Humanoid"")
					if not hum or hum.Health <= 0 then return end
					local torso = hit_character:FindFirstChild(""Torso"") or hit_character:FindFirstChild(""UpperTorso"")
					if not torso then return end
					local hit_effect = assets.Effects.hit.Attachment:Clone()
					hit_effect.Parent = torso
					for _, v in pairs(hit_effect:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					hum:TakeDamage(3)
					stun(hum, 0.8)
				end)
				hitbox2:Start()
				for _,v in pairs(ending.Attachmentyay:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount""))
					end
				end
				task.wait()
				task.delay(3, function()
					ending:Destroy()
				end)
				hitbox2:Stop()
				for _,v in pairs(ending.Attachmentyay2:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount""))
					end
				end
			end
		end)
		anim:GetMarkerReachedSignal(""8""):Once(function()
			camerastuff.TweenFOV({player, nil}, 40, {Length = 0.01, EasingStyle = ""Sine"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
			client_fx(150, brightness, nil, 1, 1)
			client_fx(150, cam_shake, {5, 10, 0, 3}, Vector3.one * 3)
			local ending = assets.Effects.sorrow_end:Clone()
			ending.Parent = workspace
			ending.CFrame = root.CFrame
			task.wait()
			for _, v in pairs(ending:GetDescendants()) do
				if v:IsA(""ParticleEmitter"") then
					v:Emit(v:GetAttribute(""EmitCount"") or 1)
				end
			end
			local sound1 = Instance.new(""Sound"")
			sound1.Name = ""jingle5""
			sound1.Volume = 4
			sound1.SoundId = ""rbxassetid://4307069862""
			sound1.Parent = root
			sound1:Play()
			task.wait(1)
			debounce = false
			humanoid.WalkSpeed = 25
			humanoid.AutoRotate = true
		end)
	elseif action == ""ego"" then
		if ego <= 10 and ammo <= 30 then
			print(""not enough"")
		else
			debounce = true
			if ego >= max_ego then
				for _, v in pairs(character:GetChildren()) do
					if v:IsA(""Shirt"") then
						print(""yes"")
						leftarm[""Left Arm""].Color = character[""Left Arm""].Color
						rightarm[""Right Arm""].Color = character[""Right Arm""].Color
						middlearm[""Left Arm""].Color = character[""Torso""].Color
						local clonedShirt = v:Clone()
						clonedShirt.Parent = leftarm
						clonedShirt:Clone().Parent = rightarm
						clonedShirt:Clone().Parent = middlearm
					end
				end
				ego = 0
				local victim = nil
				local anim = animator.new()
				anim:setAnimation(require(animations.egostart))
				anim:setRig(character)
				anim:AdjustWeight(2)
				anim.Looped = false
				anim:Play()
				anim:GetMarkerReachedSignal(""Hit""):Wait()
				local shoot = assets.Effects.solemn_white:Clone()
				shoot.Parent = workspace
				shoot.CFrame = root.CFrame * CFrame.new(0, 0, -50)
				task.wait()
				task.delay(2, function()
					shoot:Destroy()
				end)
				for _, v in pairs(shoot:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount"") or 1)
					end
				end
				local hitbox1 = Instance.new(""Part"", workspace)
				hitbox1.Name = ""Hitbox""
				hitbox1.Anchored = true
				hitbox1.Size = Vector3.new(5, 5, 40)
				hitbox1.CanCollide = false
				hitbox1.Transparency = 0
				hitbox1.CFrame = root.CFrame * CFrame.new(0, 0, -25)
				local params = OverlapParams.new()
				params.FilterType = Enum.RaycastFilterType.Exclude
				params.FilterDescendantsInstances = {character}
				task.wait(0.025)
				hitbox1:Destroy()
				local hitParts = workspace:GetPartsInPart(hitbox1, params)
				for _, part in ipairs(hitParts) do
					local humanoid = part.Parent:FindFirstChildOfClass(""Humanoid"")
					if humanoid and humanoid.Parent ~= character then
						victim = humanoid.Parent
						print(""Hit:"", victim.Name)
						local hit_effect = assets.Effects.hit.Attachment:Clone()
						hit_effect.Parent = victim.Torso
						for _, v in pairs(hit_effect:GetDescendants()) do
							if v:IsA(""ParticleEmitter"") then
								v:Emit(v:GetAttribute(""EmitCount"") or 1)
							end
						end
						humanoid:TakeDamage(2)
						stun(humanoid, 13)
						break
					end
				end
				if not victim then
					print(""none"")
					client_fx(200, brightness, nil, 1, 0.9)
					client_fx(200, cam_shake, {5, 10, 0, 3}, Vector3.one * 3)
				else
					debounce = true
					root.Anchored = true
					local victimPlayer = game.Players:GetPlayerFromCharacter(victim)
					local function cutscene(targets: {Player})
						if not targets then return end
						for _, player in pairs(targets) do
							if player and player:FindFirstChild(""PlayerGui"") then
								local cutscene = assets.Animations.CameraAnimations.Funeral.Camera:Clone()
								cutscene.Enabled = true
								cutscene.Origin.Value = root.CFrame
								cutscene.Parent = player.PlayerGui
								game:GetService(""Debris""):AddItem(cutscene, 15)
							end
						end
					end
					brightness(player, nil, 1, 0.9)
					cam_shake(player, {10, 10, 0, 10}, Vector3.one * 0.9)
					camerastuff.TweenFOV({player}, 20, {Length = 0.9, EasingStyle = ""Sine"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
				
					if victimPlayer then
						brightness(victimPlayer, nil, 1, 0.9)
						cam_shake(victimPlayer, {10, 10, 0, 10}, Vector3.one * 0.9)
						camerastuff.TweenFOV({victimPlayer}, 20, {Length = 0.9, EasingStyle = ""Sine"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
					end
					task.wait(0.9)
					local stunanim = animator.new()
					stunanim:setAnimation(require(animations.hit))
					stunanim:setRig(victim)
					stunanim:AdjustWeight(7)
					stunanim.Looped = true
					stunanim:Play()
					local hit_vic_torso = victim:FindFirstChild(""Torso"") or victim:FindFirstChild(""UpperTorso"") or victim:FindFirstChild(""HumanoidRootPart"")
					local hit_vic_hum = victim:FindFirstChild(""Humanoid"")
					hit_vic_torso.CFrame = root.CFrame * CFrame.new(0,0, -35)
					hit_vic_hum.AutoRotate = false
					hit_vic_torso.CFrame = CFrame.lookAt(victim.HumanoidRootPart.Position,root.Position)
					hit_vic_torso.Anchored = true
					humanoid.AutoRotate = false
					local ego = animator.new()
					ego:setAnimation(require(animations.funeral))
					ego:setRig(character)
					ego:AdjustWeight(1)
					ego.Looped = false

					root.Anchored = true
					root.CFrame = CFrame.lookAt(root.Position, hit_vic_torso.Position)

					anim:Stop()
					client_fx(50, brightness, nil, 1, 1)
					ego:Play()
					cutscene({player, victimPlayer})
					egobar.Enabled = false
					funeral_head.Parent = storage
					coffin2.Parent = game.TestService
					coffin.Parent = character
					leftarm.Parent = character
					rightarm.Parent = character
					middlearm.Parent = character
					leftarm[""Left Arm""].Transparency = 0
					rightarm[""Right Arm""].Transparency = 0
					middlearm[""Left Arm""].Transparency = 0
					whitegun.Transparency = 1
					blackgun.Transparency = 1
					ego:GetMarkerReachedSignal(""1""):Wait()
					local body_collapse01 = Instance.new(""Sound"")
					body_collapse01.Name = ""body-collapse01""
					body_collapse01.Volume = 2
					body_collapse01.SoundId = ""rbxassetid://2609993518""
					body_collapse01.Parent = character[""Right Leg""]
					body_collapse01:Play()
					ego:GetMarkerReachedSignal(""2""):Wait()
					local body_collapse01 = Instance.new(""Sound"")
					body_collapse01.Name = ""body-collapse01""
					body_collapse01.Volume = 2
					body_collapse01.SoundId = ""rbxassetid://4086035815""
					body_collapse01.Parent = root
					body_collapse01:Play()
					local body_collapse02 = Instance.new(""Sound"")
					body_collapse02.Name = ""body-collapse01""
					body_collapse02.Volume = 2
					body_collapse02.SoundId = ""rbxassetid://182306090""
					body_collapse02.Parent = root
					body_collapse02:Play()
					ego:GetMarkerReachedSignal(""3""):Wait()
					local body_collapse01 = Instance.new(""Sound"")
					body_collapse01.Name = ""body-collapse01""
					body_collapse01.Volume = 2
					body_collapse01.SoundId = ""rbxassetid://5137964328""
					body_collapse01.Parent = root
					body_collapse01:Play()
					ego:GetMarkerReachedSignal(""4""):Wait()
					local body_collapse01 = Instance.new(""Sound"")
					body_collapse01.Name = ""body-collapse01""
					body_collapse01.Volume = 2
					body_collapse01.SoundId = ""rbxassetid://3908308607""
					body_collapse01.Parent = root
					body_collapse01:Play()
					ego:GetMarkerReachedSignal(""5""):Wait()
					local body_collapse01 = Instance.new(""Sound"")
					body_collapse01.Name = ""body-collapse01""
					body_collapse01.Volume = 2
					body_collapse01.SoundId = ""rbxassetid://9125626784""
					body_collapse01.PlaybackSpeed = 1.2
					body_collapse01.Parent = root
					body_collapse01:Play()
					local down_particles = assets.Effects.coffinDown:Clone()
					down_particles.Parent = workspace
					down_particles.CFrame = coffin.Open.CFrame
					task.wait()
					task.delay(1, function()
						down_particles:Destroy()
					end)
					for _,v in pairs(down_particles:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount""))
						end
					end
					ego:GetMarkerReachedSignal(""6""):Wait()
					local body_collapse01 = Instance.new(""Sound"")
					body_collapse01.Name = ""body-collapse01""
					body_collapse01.Volume = 2
					body_collapse01.SoundId = ""rbxassetid://1843023345""
					--body_collapse01.PlaybackSpeed = 1.2
					body_collapse01.Parent = root
					body_collapse01:Play()
					butterfly(player, ""White"", 2)
					butterfly(player, ""Black"", 2)
					if victimPlayer then
						butterfly(victimPlayer, ""White"", 2)
						butterfly(victimPlayer, ""Black"", 2)
					end
					local sound1 = assets.Sounds.White:Clone()
					sound1.Parent = root
					sound1:Play()
					local sound2 = assets.Sounds.Black:Clone()
					sound2.Parent = root
					sound2:Play()
					local final = Instance.new(""Sound"")
					final.Name = ""idk lol""
					final.Volume = 5
					final.SoundId = ""rbxassetid://1843023345""
					--body_collapse01.PlaybackSpeed = 1.2
					final.Parent = root
					final:Play()
					local funeral_shpt = assets.Effects.funeral_shot:Clone()
					funeral_shpt.Parent = workspace
					funeral_shpt.CFrame = root.CFrame * CFrame.new(0, 1, -47)
					task.wait()
					task.delay(3, function()
						funeral_shpt:Destroy()
					end)
					for _,v in pairs(funeral_shpt:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v.Enabled = true
						end
					end
					for i = 1,60 do
						task.wait(0.025)
						if victim.Humanoid.Health - 5 <= 0 then
							victim.Humanoid.Health = 1
						else
							victim.Humanoid:TakeDamage(5)
						end
					end
					ego:GetMarkerReachedSignal(""7""):Once(function()
						--ego.Speed = 1.1
						for _,v in pairs(funeral_shpt:GetDescendants()) do
							if v:IsA(""ParticleEmitter"") then
								v.Enabled = false
							end
						end
						local fade = assets.FX.Fade:Clone()
						fade.Parent = player.PlayerGui
						if victimPlayer then
							local fade2 =  assets.FX.Fade:Clone()
							fade2.Parent = victimPlayer.PlayerGui
						end
						local idleflies = assets.Effects.idle_butterflies:Clone()
						idleflies.Parent = workspace
						idleflies.CFrame = root.CFrame
						for _,v in pairs(idleflies:GetChildren()) do
							if v:IsA(""ParticleEmitter"") then
								v:Emit(v:GetAttribute(""EmitCount"") or 1)
							end
						end
						local charge = Instance.new(""Sound"")
						charge.Name = ""Bell Toll""
						charge.Volume = 3
						charge.SoundId = ""rbxassetid://9058393493""
						charge.PlaybackSpeed = 0.8
						charge.Parent = root
						charge:Play()
					end)
					ego:GetMarkerReachedSignal(""8""):Once(function()
						local fade = assets.FX.Funeral_Effects:Clone()
						fade.Parent = player.PlayerGui
						clientmodule.scene(player, 4, Color3.fromRGB(255, 255, 255))
						if victimPlayer then
							clientmodule.scene(victimPlayer, 4, Color3.fromRGB(255, 255, 255))
							local fade2 = assets.FX.Funeral_Effects:Clone()
							fade2.Parent = victimPlayer.PlayerGui
						end
						local sound2 = assets.Sounds.Funeral_End:Clone()
						sound2.Parent = root
						sound2:Play()
						local sound3 = assets.Sounds.Black:Clone()
						sound3.Parent = root
						sound3:Play()
						local final = Instance.new(""Sound"")
						final.Name = ""idk lol""
						final.Volume = 5
						final.SoundId = ""rbxassetid://1843027458""
						--body_collapse01.PlaybackSpeed = 1.2
						final.Parent = root
						final:Play()
						local final_shot = assets.Effects.funeral_shot2:Clone()
						final_shot.Parent = workspace
						final_shot.CFrame = root.CFrame * CFrame.new(0, 1, -48)
						task.wait()
						if victim.Humanoid.Health - 250 <= 0 then
							victim.Humanoid.Health = 1
						else
							victim.Humanoid:TakeDamage(250)
						end
						butterfly(player, ""Black"", 4)
						if victimPlayer then
							butterfly(victimPlayer, ""Black"", 4)
						end
						task.delay(4, function()
							final_shot:Destroy()
						end)
						for _,v in pairs(final_shot.Attachmentyay2:GetChildren()) do
							if v:IsA(""ParticleEmitter"") then
								v:Emit(v:GetAttribute(""EmitCount""))
								game:GetService(""TweenService""):Create(v, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TimeScale = 0.1}):Play()
							end
						end
					end)
					--[[ego:GetMarkerReachedSignal(""9""):Once(function()
					end)]]
					ego:GetMarkerReachedSignal(""10""):Once(function()
						local ende = Instance.new(""Sound"")
						ende.Name = ""body-collapse01""
						ende.Volume = 0.5
						ende.PlaybackSpeed = 0.714
						ende.SoundId = ""rbxassetid://5743541912""
						ende.Parent = root
						ende:Play()
						local sound2 = assets.Sounds.Funeral_End2:Clone()
						sound2.Parent = root
						sound2:Play()
						clientmodule.scene(player, 4)
						if victimPlayer then
							clientmodule.scene(victimPlayer, 4)
						end
						task.wait(1)
						task.delay(3, function()
						camerastuff.NormalizeCamera({player, victimPlayer}, {
						Length = 0.0001,
						EasingStyle = ""Sine"",
						EasingDirection = ""Out"",
						RepeatCount = 0,
						Reverses = false,
						DelayTime = 0
					})	
					end)
						clientmodule.scene(player,3, Color3.fromRGB(0, 0, 0))
						if victimPlayer then
							clientmodule.scene(victimPlayer,3, Color3.fromRGB(0, 0, 0))
						end
						task.wait(3)
						debounce = false
						leftarm[""Left Arm""].Transparency = 1
						rightarm[""Right Arm""].Transparency = 1
						middlearm[""Left Arm""].Transparency = 1
						coffin2.Parent = character
						coffin.Parent = game.TestService
						funeral_head.Parent = game.TestService
						leftarm.Parent = storage
						rightarm.Parent = storage
						middlearm.Parent = storage
						whitegun.Transparency = 0
						blackgun.Transparency = 0
						egobar.Enabled = true
						humanoid.AutoRotate = true
						root.Anchored = false
						humanoid.WalkSpeed = 25
						root.Anchored = false
						ego:Stop()
						stunanim:Stop()
						hit_vic_torso.Anchored = false
						victim.Humanoid.AutoRotate = true
					end)
				end
			else
				ego = math.max(ego - 40, 0)
				local victim = nil
				local anim = animator.new()
				anim:setAnimation(require(animations.egostart))
				anim:setRig(character)
				anim:AdjustWeight(1)
				anim.Looped = false
				anim:Play()
				anim:GetMarkerReachedSignal(""Hit""):Wait()
				local shoot = assets.Effects.solemn_white:Clone()
				shoot.Parent = workspace
				shoot.CFrame = root.CFrame * CFrame.new(0, 0, -50)
				task.wait()
				task.delay(2, function()
					shoot:Destroy()
				end)
				for _, v in pairs(shoot:GetDescendants()) do
					if v:IsA(""ParticleEmitter"") then
						v:Emit(v:GetAttribute(""EmitCount"") or 1)
					end
				end
				local hitbox1 = Instance.new(""Part"", workspace)
				hitbox1.Name = ""Hitbox""
				hitbox1.Anchored = true
				hitbox1.Size = Vector3.new(5, 5, 40)
				hitbox1.CanCollide = false
				hitbox1.Transparency = 0
				hitbox1.CFrame = root.CFrame * CFrame.new(0, 0, -25)
				local params = OverlapParams.new()
				params.FilterType = Enum.RaycastFilterType.Exclude
				params.FilterDescendantsInstances = {character}
				task.wait(0.025)
				hitbox1:Destroy()
				local hitParts = workspace:GetPartsInPart(hitbox1, params)
				for _, part in ipairs(hitParts) do
					local humanoid = part.Parent:FindFirstChildOfClass(""Humanoid"")
					if humanoid and humanoid.Parent ~= character then
						victim = humanoid.Parent
						print(""Hit:"", victim.Name)
						local hit_effect = assets.Effects.hit.Attachment:Clone()
						hit_effect.Parent = victim.Torso
						for _, v in pairs(hit_effect:GetDescendants()) do
							if v:IsA(""ParticleEmitter"") then
								v:Emit(v:GetAttribute(""EmitCount"") or 1)
							end
						end
						stun(humanoid, 15)
						break
					end
				end
				if not victim then
					print(""none"")
					client_fx(200, brightness, nil, 1, 0.9)
					client_fx(50, cam_shake, {5, 10, 0, 3}, Vector3.one * 3)
				else
					local victimPlayer = game.Players:GetPlayerFromCharacter(victim)
					client_fx(200, brightness, nil, 1, 0.9)
					client_fx(50, cam_shake, {10, 10, 0, 10}, Vector3.one * 0.9)
					local victimPlayer = game.Players:GetPlayerFromCharacter(victim)
					camerastuff.TweenFOV({player}, 20, {Length = 0.9, EasingStyle = ""Sine"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
					if victimPlayer then
						brightness(victimPlayer, nil, 1, 0.9)
						cam_shake(victimPlayer, {10, 10, 0, 10}, Vector3.one * 0.9)
						camerastuff.TweenFOV({victimPlayer}, 20, {Length = 0.9, EasingStyle = ""Sine"", EasingDirection = ""Out"", RepeatCount = 0, Reverses = false, DelayTime = 0}, true)
					end
					task.wait(0.9)
					local stunanim = animator.new()
					stunanim:setAnimation(require(animations.hit))
					stunanim:setRig(victim)
					stunanim:AdjustWeight(7)
					stunanim.Looped = true
					stunanim:Play()
					victim.HumanoidRootPart.CFrame = root.CFrame * CFrame.new(0,0, -35)
					victim.Humanoid.AutoRotate = false
					victim.HumanoidRootPart.CFrame = CFrame.lookAt(victim.HumanoidRootPart.Position,root.Position)
					victim.HumanoidRootPart.Anchored = true
					humanoid.AutoRotate = false
					root.Anchored = true
					local ego = animator.new()
					ego:setAnimation(require(animations.solemn))
					ego:setRig(character)
					ego:AdjustWeight()
					ego.Looped = false
					ego:Play()
					anim:Stop()
					butterflyarm.Parent = storage
					local function cutscene(targets: {Player})
						if not targets then return end
						for _, player in pairs(targets) do
							if player and player:FindFirstChild(""PlayerGui"") then
								local cutscene = assets.Animations.CameraAnimations.SolemnLament.Camera:Clone()
								cutscene.Enabled = true
								cutscene.Origin.Value = root.CFrame
								cutscene.Parent = player.PlayerGui
								game:GetService(""Debris""):AddItem(cutscene, 15)
							end
						end
					end
					root.CFrame = CFrame.lookAt(root.Position,victim.HumanoidRootPart.Position)
					cutscene({player, victimPlayer})
					client_fx(50, brightness, nil, 1, 1)
					ego:GetMarkerReachedSignal(""1""):Wait()
					local sound3 = assets.Sounds.Ding:Clone()
					sound3.Parent = root
					sound3:Play()
					local ending = assets.Effects.sorrow_end:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""2""):Wait()
					local sound2 = assets.Sounds.Pistol_Click:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_swing:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""3""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""White"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""White"", 0.5)
						end
					end)
					client_fx(50, brightness, nil, .1, .3)
					local sound2 = assets.Sounds.White:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_white:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""4""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""Black"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""Black"", 0.5)
						end
					end)
					client_fx(50, brightness, nil, .1, .3)
					local sound2 = assets.Sounds.Black:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_black:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""5""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""White"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""White"", 0.5)
						end
					end)
					client_fx(50, brightness, nil, .1, .3)
					local sound2 = assets.Sounds.White:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_white:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""6""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""Black"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""Black"", 0.5)
						end
					end)
					client_fx(50, brightness, nil, .1, .3)
					local sound2 = assets.Sounds.Black:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_black:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""7""):Wait()
					local sound2 = assets.Sounds.Pistol_Click:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_spin1:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame --* CFrame.new(0, 0, 0)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""8""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""Black"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""Black"", 0.5)
						end
					end)
					client_fx(50, brightness, nil, .1, .3)
					local sound2 = assets.Sounds.Black:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_black:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""9""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""White"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""White"", 0.5)
						end
					end)
					local sound2 = assets.Sounds.White:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_white:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""10""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""Black"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""Black"", 0.5)
						end
					end)
					local sound2 = assets.Sounds.Black:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_black:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""11""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""White"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""White"", 0.5)
						end
					end)
					local sound2 = assets.Sounds.White:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_white:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""3.1""):Wait()
					local sound2 = assets.Sounds.Pistol_Click:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_spin2:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""13""):Wait()
					if victim.Humanoid.Health - 45 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(45)
					end
					task.delay(0.00001, function()
						butterfly(player, ""White"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""White"", 0.5)
						end
					end)
					local sound2 = assets.Sounds.White:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_white:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""14""):Wait()
					if victim.Humanoid.Health - 25 <= 0 then
						victim.Humanoid.Health = 1
					else
						victim.Humanoid:TakeDamage(25)
					end
					task.delay(0.00001, function()
						butterfly(player, ""Black"", 0.5)
						if victimPlayer then
							butterfly(victimPlayer, ""Black"", 0.5)
						end
					end)
					local sound2 = assets.Sounds.Black:Clone()
					sound2.Parent = root
					sound2:Play()
					local ending = assets.Effects.solemn_black:Clone()
					ending.Parent = workspace
					ending.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(2, function()
						ending:Destroy()
					end)
					for _, v in pairs(ending:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
						end
					end
					ego:GetMarkerReachedSignal(""15""):Wait()
					victim.Humanoid:TakeDamage(50)
					task.delay(0.00001, function()
						butterfly(player, ""White"", 2)
						if victimPlayer then
							butterfly(victimPlayer, ""White"", 2)
						end
					end)
					local sound2 = assets.Sounds.White:Clone()
					sound2.Parent = root
					sound2:Play()
					local sound3 = assets.Sounds.Ding:Clone()
					sound3.Parent = root
					sound3:Play()
					local ending1 = assets.Effects.solemn_white:Clone()
					ending1.Parent = workspace
					ending1.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					for _, v in pairs(ending1:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
							game:GetService(""TweenService""):Create(v, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TimeScale = 0.1}, true):Play()
						end
					end
					local ending2 = assets.Effects.solemn_black:Clone()
					ending2.Parent = workspace
					ending2.CFrame = root.CFrame * CFrame.new(0, 0, -50)
					task.wait()
					task.delay(10, function()
						ending1:Destroy()
						ending2:Destroy()
					end)
					for _, v in pairs(ending2:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							v:Emit(v:GetAttribute(""EmitCount"") or 1)
							game:GetService(""TweenService""):Create(v, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TimeScale = 0.1}, true):Play()
						end
					end
					
					task.wait(1.3)
					task.delay(1.25, function()
						camerastuff.NormalizeCamera({player, victimPlayer}, {
						Length = 0.0001,
						EasingStyle = ""Sine"",
						EasingDirection = ""Out"",
						RepeatCount = 0,
						Reverses = false,
						DelayTime = 0
					})	
					end)
					clientmodule.scene(player, 1.25, Color3.fromRGB(0, 0, 0))
					
					if victimPlayer then
						clientmodule.scene(victimPlayer, 1.25, Color3.fromRGB(0, 0, 0))
					end
					task.wait(2)
					for _, v in pairs(ending1:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							game:GetService(""TweenService""):Create(v, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TimeScale = 1}):Play()
						end
					end
					for _, v in pairs(ending2:GetDescendants()) do
						if v:IsA(""ParticleEmitter"") then
							game:GetService(""TweenService""):Create(v, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TimeScale = 1}):Play()
						end
					end
					stunanim:Stop()
					victim.HumanoidRootPart.CFrame = root.CFrame * CFrame.new(0,0, -35)
					victim.Humanoid.AutoRotate = true
					victim.HumanoidRootPart.Anchored = false
					humanoid.AutoRotate = false
					humanoid.WalkSpeed = 25
					humanoid.AutoRotate = true
					root.Anchored = false
					butterflyarm.Parent = game.TestService
				end
			end
		end
		task.wait(1)
		debounce = false
	end
end)
game:GetService(""RunService"").Stepped:Connect(function()
	update_bar()
end)

local previous_health = humanoid.Health

humanoid:GetPropertyChangedSignal(""Health""):Connect(function()
	local current_health = humanoid.Health
	if current_health < previous_health then
		ego = math.max(ego + 0.8, 0)
	end
end)
print(""loaded!"")"
Drf4Pw9R,com main example,exnon,C++,Wednesday 18th of June 2025 03:18:52 PM CDT,"    Thread_COM::Receiver* com_receiver = new Thread_COM::Receiver(FBM_1_COM);
    Thread_COM::Sender* com_sender = new Thread_COM::Sender(FBM_2_COM);
    Thread_COM::Receiver* com_dispatcher_receiver = new Thread_COM::Receiver(FBM_1_COM_RECEIVER);
    Thread_COM::Sender* com_dispatcher_sender = new Thread_COM::Sender(FBM_1_DISPATCHER);
    COM*  externCommunication = new COM(com_receiver, com_sender, com_dispatcher_receiver, com_dispatcher_sender);
    externCommunication->start();
	externCommunication->stop();"
FkwS5Njs,2025-06-18T22:06:45.944941,powerampache,PHP,Wednesday 18th of June 2025 03:06:46 PM CDT,"1.01-78 (78) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
mT4pFrVD,Best Time to Buy & Sell Stocks with Transaction Fee,Fastrail08,C++,Wednesday 18th of June 2025 03:00:07 PM CDT,"#include <bits/stdc++.h>
using namespace std;

void getMaxProfitInfiniteTransactionWithFee(int level, int transactionOpen, int profit, int &maxProfit, vector<int> &prices, int fee){
    
    if(level >= prices.size()){
        maxProfit = max(maxProfit, profit);
        return;
    }
    //levels - each stock price
    //options - buy, sell or don't do anything
    
    // transaction opened / buying
    if(!transactionOpen){
        getMaxProfitInfiniteTransactionWithFee(level + 1, 1, profit - prices[level], maxProfit, prices, fee);
    }
    
    //transaction closed / selling
    if(transactionOpen){
        getMaxProfitInfiniteTransactionWithFee(level + 1, 0, profit + prices[level] - fee, maxProfit, prices, fee);
    }
    
    //Don't do anything / neither buy nor sell
    getMaxProfitInfiniteTransactionWithFee(level + 1, transactionOpen, profit, maxProfit, prices, fee);
    
}

int getMaxProfitInfiniteTransactionWithFeeMemo(int level, int transactionOpen, vector<int> &prices, int fee, vector<vector<int> > &memo){
    
    if(level >= prices.size()){
        return 0;
    }
    
    if(memo[level][transactionOpen] != -1){
        return memo[level][transactionOpen];
    }
    
    //levels - each stock price
    //options - either buy, sell or don't do anything
    
    int bought = 0, sold = 0, na = 0;
    
    //buy only if no transaction opened
    if(!transactionOpen){
        bought += getMaxProfitInfiniteTransactionWithFeeMemo(level + 1, 1, prices, fee, memo) - prices[level];
    }
    
    //sell only if a transaction is open
    if(transactionOpen){
        sold += getMaxProfitInfiniteTransactionWithFeeMemo(level + 1, 0, prices, fee, memo) + prices[level] - fee;
    }
    
    // don't do anything
    na = getMaxProfitInfiniteTransactionWithFeeMemo(level + 1, transactionOpen, prices, fee, memo);
    
    return memo[level][transactionOpen] = max(na, max(bought, sold));
    
}


int getMaxProfitInfiniteTransactionWithFeeDP(vector<int> &prices){
    /*
    Storage & Meaning - dp[i][0] = processing/decision made upto ith level where the transaction ends as closed
                        dp[i][1] = processing/decision made upto ith level where the transaction ends as open
                        
                        dp[i][0] = decision made upto (i - 1)th level and the ith level ends with 0/sell state
                        dp[i][1] = decision made upto (i - 1)the level and the ith level ends with 1/buy state
    */
    
    /*
    Direction - 
    
        Identify where the smaller subproblems and larger subproblems lie. To do this see what is the base case.
        In string DP you can do it from either side, but it is convenient to start from 0th index, as definition will make more sense then.
        
        When you start from left OR from 0th level, generally the subproblems are defined as 'upto ith index ending with char/item/0' and when you start from right OR from (N - 1)th level, subproblems are defined as 'starting from ith index with starting char/item/0'
        
        You will already have answers to smaller subproblems, now you need to explore all the options at previous level for the current level, to see where the arrows will land at.
        
        You need to be able to fill all the cells corresponding to the current level.
        FOR 1D dp dp[i]... you need to be able to fill the cell dp[i]
        
        FOR 2D dp dp[i][j]... you need to be able to fill the cell dp[i][0] upto dp[i][j]
        
        Simply go to just previous states, define them what they, explore the options, [as you explored the options at a level {(i - 1), or some dp[i - 1][j], you will simply move to the next level{(i), dp[i][?], you just need to figure out what dp cell it will fall in at the next level, figure out the ?]. You can figure it out by attaching the option to the meaning of (i - 1) and see what new meaning it has.
        
        For eg - 
        consider question AiBjCk
        dp[i][a] = Stores all the VALID subsequences ENDING with a, when the DECISION is made upto level i.
        dp[i][b] = Stores all the VALID subsequences ENDING with b, when the DECISION is made upto level i.
        dp[i][c] = Stores all the VALID subsequences ENDING with c, when the DECISION is made upto level i.
        
        
        we need to be able to fill any ith level COMPLETELY, EVERY CELL defined at ith level. So the level variable here is i. So we need to be able to fill dp[i][a], dp[i][b], dp[i][c]
        
        To do this go the past level, here (i - 1)[it can be i - 1, or i - 2, just see the recursion code, what are jumps made to the next level (if there is level + 1, level + 2, ..you need to see what all paths from every past level, if we explore the options for arr[i], string[i], item[i])]
        
        In the above question AiBjCk, we are jumping atmost level + 1 in any call, so we just need to explore only the (i - 1)th level, if we are to find answers for ith level.
        
        
        dp[i - 1][a] = all the valid subsequences ending with a, when decision is made upto (i - 1)th level.
        And similarly for dp[i - 1][b] and dp[i - 1][c]. As you are doing DP, you would already have this table filled up for these cells.
        
        What you have to do now is to explore the options which are available at ith level, and explore it here.
        
        for eg - imagine the string was abcbabc, and current ith level is at index 3, that is string[i] = 'b'.
        
        AAYEGA YA NAHI AAYEGA (simple choice for a subsequence)
        The options available at each level is to - 
        include the character or exclude the character
        OR
        Select the character or don't select the character
        OR
        Either character part of subsequence or not the part of subsequence
        
        So for filling up dp[i][b], explore the option 'b' at the previous level so that you can land on the current level.
        
        dp[i][a] stores the answer AFTER it has processed the ith level/char, and you land up on ith level only when you would have explored it at previous state.
        
        So if ith char is 'b', we would be the option available at the previous level (i - 1) is to either include or exclude b
        
        
        
                          dp[i][a]      (exclude b)
                        -
                      -
                    -
        dp[i - 1][a]
                    -
                      -
                        -
                          dp[i][b]      (include b)
        
        
        So doing this for all past states, we get
        
                            dp[i][b]      (exclude b)
                        -
                      -
                    -
        dp[i - 1][b]
                    -
                      -
                        -
                          dp[i][b]        (include b)
        
        
        
                            dp[i][c]      (exclude b)
                        -
                      -
                    -
        dp[i - 1][c]
                    -
                      -
                        -
                          [INVALID CASE]  (include b)
                          
                          
        [INVALID CASE] as - dp[i - 1][c] contains all the subsequences that ends with 'c'. Now you explored the option to include 'b', which means 'b' will be added at the end of the subsequences making all the subsequences end with 'b',  that was already ending with 'c' at the previous level, which will make subsequences of type aabcb, abcb, aabbbccb, which are all invalid cases.
        
        During Recursion we managed to avoid this invalid call by adding a condition s[lastChar] <= s[level], so that if the last char was a, we can call to a,b or c depending on what char lies at current level.
        If last char was b, we can only call to b & c, and if last char was c, we can only call to c to only have valid subsequences at every level.
        
        If current character s[i] = 'b', the answer will be filled in dp[i][b], and to form the answer dp[i][b]
        Option available at the previous level, either to include b or exclude b.
        We see what all paths lead to dp[i][b], from all previous levels dp[i - 1][a], dp[i - 1][b], dp[i - 1][c].
        
        According to the diagram, 1 path from dp[i - 1][a] (option - if b included, now string will end with b)
                                  2 paths from dp[i - 1][b] (both option available, as string will end with b only)
                                  0 paths from dp[i - 1][c] (1 option leads to dp[i][c], other is invalid)
                                  
                                  
                                  
        [INVALID case] = 
        dp[i- 1][c] = agar (i - 1)th level/index padi hui saari subsequences jo 'c' se end hoti hai agar uske aage mai 'b' laga du(include b), to mujhe vo saari subsequences milengi ith level/index pe jo 'b' se end hogi. But 'b' se pehle vo 'c' pe end ho rahi thi, to 'b', 'c' ke baad aaya jiske kaaran subsquence invalid ho jaayega according to question.
                                  
                                  
        
        We will compute this for every possible character - 
        
        IF s[i] = a, then we will fill dp[i][a], options at previous level = either include 'a' or exclude 'a'
        
                            dp[i][a]      (exclude a)
                        -
                      -
                    -
        dp[i - 1][a]
                    -
                      -
                        -
                            dp[i][a]      (include a)
                            
                            
                            
                            dp[i][b]      (exclude a)
                        -
                      -
                    -
        dp[i - 1][b]
                    -
                      -
                        -
                            [INVALID case]  (include a) 
                            
                            
        
                            dp[i][c]       (exclude a)
                        -
                      -
                    -
        dp[i - 1][c]
                    -
                      -
                        -
                            [INVALID case]      (include a)
                            
         
         
        dp[i][a] = dp[i - 1][a] + dp[i - 1][a] + 1  (1 would be there as subsquence a is allowed)
        dp[i - 1][a] = If we don't select the current char 'a' at level i, still the subsequences will be ending with a
         
        dp[i - 1][a] = If we select current char 'a', the subsequences will end with a.
        
        1 = the current character itself is a valid subsequence.
        
        dp[i][a] = 
        dp[i - 1][a] = i - 1 level tak ka decision lene ke baad vo saari subsequences jo 'a' se end hoti hai, uske aage mai current level(ith level) waala 'a' na lagaon, tab bhi mujhe 'a' se end hone waali subsequences milengi, after making decisions upto ith level which is nothing but dp[i][a].
        
        dp[i - 1][a] = i - 1 level tak ka decision lene ke baad vo saari subsequences padi hai yaha pe jo 'a' se end hoti hai, uske aage mai agar current level waala 'a' laga du, ith level ka decision lene tak /process karne ke baad, mujhe 'a' se end hone waali subsequences milengi.
                            
        1 = vo current level waala 'a' khud ek valid subsequence hai
        
        
        
        
        
                            
        IF s[i] = 'c' then we will fill dp[i][c], options at previous level = either include 'c' or exclude 'c'
        
               
                            dp[i][a]      (exclude c)
                        -
                      -
                    -
        dp[i - 1][a]
                    -
                      -
                        -
                            [INVALID CASE]      (include c)
                                    
                                    
               
                            dp[i][b]      (exclude c)
                        -
                      -
                    -
        dp[i - 1][b]
                    -
                      -
                        -
                            dp[i][c]      (include c)
        
        
               
                            dp[i][c]      (exclude c)
                        -
                      -
                    -
        dp[i - 1][c]
                    -
                      -
                        -
                            dp[i][c]      (include c)
                            
        
        
        so dp[i][c] = dp[i - 1][c] + dp[i - 1][c] + dp[i - 1][b]
        
        
        dp[i - 1][c] = agar i - 1th level pe 'c' se end hone waali subsequences ke aage agar mai current level waala 'c' na lagaon to merko 'c' se end hone waali subsequences milengi ith level par
        dp[i - 1][c] = agar i - 1th level pe 'c' se end hone waali subsequences ke aage agar mai current level waala 'c' laga du to to 'c' se end hone waali subsequences hi milengi ith level par
        dp[i - 1][b] = agar i - 1th level pe 'b' se end hone waali saari subsequences ke aage mai 'c' laga du, to mujhe vo saari subsequences mil jaayengi jo 'c' se end hogi ith level par.
        
        
        For any dp[i][j], identify what all smaller states could have made the answer for the current state, 
        analyse all the valid options at previous level(here, i - 1) and when you explore an option [that is when 
        you make a recursive call from a level to the next level]
        
        In recursion when you are on a level, you analyse what all VALID options are(sudoku, binary strings)
        and then you try to explore each option by making a recursive call, which takes you to the next level.
        
        
    */
}

int main() {
	// your code goes here
    int n, fee;
    cin >> n;
    vector<int> prices(n);
    for(int i = 0; i < n; i++){
        cin >> prices[i];
    }
    cin >> fee;
    /*
    RECURSION CALL
        int maxProfit = 0;
        getMaxProfitInfiniteTransactionWithFee(0, 0, 0, maxProfit, prices, fee);
        cout << maxProfit << '\n';
    */
    
    /*
    MEMO CALL
        
    
    */
    vector<vector<int> > memo(n, vector<int>(2, -1));
    cout << getMaxProfitInfiniteTransactionWithFeeMemo(0, 0, prices, fee, memo) << '\n';
}
"
wwwhEqTP,Fingerprint Unlock Front Door - And If,Caddac,YAML,Wednesday 18th of June 2025 02:23:02 PM CDT,"{{
   not trigger.event.data.old_state.attributes.get('restored', false) and
   not trigger.event.data.old_state.state == 'unavailable' and
   trigger.event.data.new_state is not none and
   trigger.event.data.new_state.attributes.event_type == 'identified' and
   (trigger.event.data.new_state.attributes.ulp_id|default('')) != ''
}}"
auApdkiv,kolprem_buzzer.c,olelek,C,Wednesday 18th of June 2025 01:46:13 PM CDT,"/*
 * kolprem_buzzer.c
 *
 * Created: 2019-02-06 10:25:48
 * Author : a
 
 Buzzer connected to PB0:PA4
 INPUTS:	
 6	PA5 AIN5 - main input
 7	PA6 AIN6
 8	PA7 AIN7
 9	PB5 AIN8
 10	PB4 AIN9 (TXD)
 
 Workflow:
 The MCU monitors the AIN5 analog input, and when it detects a rising edge defined by thershold levels low_tsh and high_tsh,
 it activates buzzer for 1 second (generating ~3.3kHz square wave frequency on pins PB0 & PA4).
 
 
 
 */ 
#define F_CPU	32000UL

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <avr/eeprom.h>
#include <avr/lock.h>

LOCKBITS = (LB_RWLOCK_gc);



volatile uint8_t start_signal = 1; //1 after rising edge
volatile uint8_t lastState = 0, currentState = 0;
const uint8_t low_tsh=(uint8_t)256.0*0.8/5.0, high_tsh=(uint8_t)256.0*1.2/5.0;
const char info[] EEMEM = ""Kolprem bnuzzer REV 02. Analog readout. Rising-edge trigger above 1.2V."";
extern void ccp_write_io(void *addr, uint8_t value);


int8_t DIGITAL_GLUE_LOGIC_0_init()
{

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 1; /* Truth 0: 1 */

	// CCL.LUT0CTRLC = CCL_INSEL2_MASK_gc /* Masked input */;

	CCL.LUT0CTRLB = CCL_INSEL0_TCA0_gc /* TCA0 WO0 input source */
	| CCL_INSEL1_MASK_gc /* Masked input */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
	| CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	| CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	| 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	| 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	// CCL.TRUTH1 = 0; /* Truth 1: 0 */

	// CCL.LUT1CTRLC = CCL_INSEL2_MASK_gc /* Masked input */;

	// CCL.LUT1CTRLB = CCL_INSEL0_MASK_gc /* Masked input */
	//		 | CCL_INSEL1_MASK_gc /* Masked input */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
	| CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	| CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	| 0 << CCL_ENABLE_bp     /* LUT Enable: disabled */
	| 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
	| 0 << CCL_RUNSTDBY_bp; /* Run in Standby: disabled */

	return 0;
}
/************************************************************************/
/* CLK init CPU_CLK=32Khz                                                                     */
/************************************************************************/
int8_t CLKCTRL_init()
{

	// ccp_write_io((void*)&(CLKCTRL.OSC32KCTRLA),0 << CLKCTRL_RUNSTDBY_bp /* Run standby: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.XOSC32KCTRLA),CLKCTRL_CSUT_1K_gc /* 1k cycles */
	//		 | 0 << CLKCTRL_ENABLE_bp /* Enable: disabled */
	//		 | 0 << CLKCTRL_RUNSTDBY_bp /* Run standby: disabled */
	//		 | 0 << CLKCTRL_SEL_bp /* Select: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.OSC20MCTRLA),0 << CLKCTRL_RUNSTDBY_bp /* Run standby: disabled */);

	ccp_write_io((void *)&(CLKCTRL.MCLKCTRLB),
	CLKCTRL_PDIV_6X_gc /* 6 */
	| 0 << CLKCTRL_PEN_bp /* Prescaler enable: disabled */);

	ccp_write_io((void *)&(CLKCTRL.MCLKCTRLA),
	CLKCTRL_CLKSEL_OSCULP32K_gc /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */
	| 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	/* wait for system oscillator changing to finish */
	while (CLKCTRL.MCLKSTATUS & CLKCTRL_SOSC_bm) {
	}

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}

void GPIO_init(void)
{
	/* Buzzer PB0:PA4 */
	/* INPUT PA5 AIN5 */
	/* GPIO */
	PORTA_OUTSET = PIN4_bm;
	PORTB_DIRSET = PIN0_bm;
	
	//PORTA_PIN5CTRL = PORT_PULLUPEN_bm;
	DIGITAL_GLUE_LOGIC_0_init();
}

void TCA0_init(void){
	/* Timer A configuration - audio freq. output */
	TCA0_SINGLE_CTRLA = TCA_SINGLE_ENABLE_bm;
	TCA0_SINGLE_CTRLB = TCA_SINGLE_WGMODE_FRQ_gc|TCA_SINGLE_CMP0_bm;
	TCA0_SINGLE_CMP0 = 4; // 550 = 3Khz @ CPU_CLK = 3.3MHz; 4 = 3.3KHz @ CPU_CLK=32Khz
	
	TCA0_SINGLE_CNT = 0;
	TCA0_SINGLE_CTRLA = 0;
	/* Timer B configuration - pulse freq. output */
	TCB0_CTRLA = TCB_ENABLE_bm;
	TCB0_CTRLB = 0;
	
	
}

void ADC_init(void){
	ADC0_CTRLA = ADC_RUNSTBY_bm|ADC_RESSEL_bm|ADC_ENABLE_bm;
	ADC0_CTRLB = ADC_SAMPNUM_ACC4_gc; 
	ADC0_CTRLC = ADC_REFSEL_VDDREF_gc|ADC_PRESC_DIV2_gc;
	ADC0_MUXPOS = ADC_MUXPOS_AIN5_gc;
	ADC0_INTCTRL = ADC_RESRDY_bm;
	ADC0_COMMAND = ADC_STCONV_bm;
	
}

void signal_on(void){
	TCA0_SINGLE_CTRLA = TCA_SINGLE_ENABLE_bm;
}

void signal_off(void){
	TCA0_SINGLE_CTRLA = 0;
}

int main(void)
{
	sei();
	GPIO_init();
	TCA0_init();
	signal_off();
	CLKCTRL_init();
    ADC_init();
	
	while (1) 
    {
		
		if(start_signal){
			signal_on();
			_delay_ms(1000);
			signal_off();
			_delay_ms(1000);
			start_signal = 0;
			//go to idle sleep
			set_sleep_mode(SLEEP_MODE_STANDBY);
			sleep_enable();
			sleep_cpu();
		}
    }//while(1)
}


/************************************************************************/
/* ADC ISR                                                              */
/************************************************************************/
ISR(ADC0_RESRDY_vect){
	
	lastState = currentState;
	//calculate current state
	if (ADC0_RES > high_tsh)
	{
		currentState = 1;
	}
	if (ADC0_RES < low_tsh)
	{
		currentState = 0;
	}
	
	//rising edge detection
	if ((currentState ==1) && (lastState == 0))
	{
		start_signal = 1;
	}
	//start next aquisition
	ADC0_INTFLAGS = ADC_RESRDY_bm;
	ADC0_COMMAND = ADC_STCONV_bm;
}


"
PwuHJ80M,Grow A Garden Anti-Steal V1,velvetkk,Lua,Wednesday 18th of June 2025 01:44:15 PM CDT,"loadstring(game:HttpGet(""https://raw.githubusercontent.com/castleofsolace/GAGAntiSteal/refs/heads/main/MAIN.lua""))()

-- THIS SCRIPT WILL BE GETTING MANY UPDATES BECAUSE BYPASSES WILL SOON APPEAR!!!
-- Due to the heavy influx of now trending GAG stealers, i've decided to make an Anti-Steal script, here's how it works
-- Once you execute the script, it will automatically lock/favorite all your valuable items, or you can select manually in the GUI,
-- Once the player joining you will try to steal your items, even if the stealer works well - your stuff will be in your inventory all the time, you won't lost ANYTHING unless you leave the game, STAY. IN. THE. GAME, or else this won't work!!!
-- It will also send a webhook notification to your server that it works
-- Once you execute someone's script you've found, my Anti-Steal will notify you whether it's a stealer or not, will give you the username of the person trying to steal your stuff and will also send their webhook to your server.

-- I'm not responsible for any damages caused to you or anyone else while using this script, i simply made it for fun and safety purposes"
2xKdc3hJ,minage A* test,Vodka51200,Lua,Wednesday 18th of June 2025 01:31:33 PM CDT,"-- === CONFIGURATION ===
local blacklist = {
  [""minecraft:lava""] = true,
  [""minecraft:bedrock""] = true,
}

-- === SAISIE UTILISATEUR ===
print(""Largeur (X) ?"")
local sizeX = tonumber(read())
print(""Hauteur (Y) ?"")
local sizeY = tonumber(read())
print(""Profondeur (Z) ?"")
local sizeZ = tonumber(read())

-- === ETAT DE LA TORTUE ===
local position = {x = 0, y = 0, z = 0}
local facing = 0 -- 0=nord, 1=est, 2=sud, 3=ouest

-- === UTILITAIRES DE DÉPLACEMENT ===
function faceTo(dir)
  while facing ~= dir do
    turtle.turnRight()
    facing = (facing + 1) % 4
  end
end

function moveForward()
  if turtle.forward() then
    if facing == 0 then position.z = position.z + 1
    elseif facing == 1 then position.x = position.x + 1
    elseif facing == 2 then position.z = position.z - 1
    elseif facing == 3 then position.x = position.x - 1 end
    return true
  end
  return false
end

function moveUp()
  if turtle.up() then
    position.y = position.y + 1
    return true
  end
  return false
end

function moveDown()
  if turtle.down() then
    position.y = position.y - 1
    return true
  end
  return false
end

-- === MINAGE SÉCURISÉ ===
function isBlacklisted(name)
  return blacklist[name] == true
end

function safeDig(inspectFunc, digFunc)
  local success, data = inspectFunc()
  if success and isBlacklisted(data.name) then return false end
  if success then digFunc() end
  return true
end

function mineForward()
  if not safeDig(turtle.inspect, turtle.dig) then return false end
  return moveForward()
end

function mineUp()
  if not safeDig(turtle.inspectUp, turtle.digUp) then return false end
  return moveUp()
end

function mineDown()
  if not safeDig(turtle.inspectDown, turtle.digDown) then return false end
  return moveDown()
end

-- === GÉNÉRATION DES COORDONNÉES À MINER ===
function generateMiningTargets(sx, sy, sz)
  local targets = {}
  for y = 0, sy - 1 do
    for z = 0, sz - 1 do
      for x = 0, sx - 1 do
        table.insert(targets, {x = x, y = y, z = z})
      end
    end
  end
  return targets
end

-- === A* ===
function makeNode(x, y, z)
  return {x = x, y = y, z = z, g = 0, h = 0, f = 0, parent = nil}
end

function heuristic(a, b)
  return math.abs(a.x - b.x) + math.abs(a.y - b.y) + math.abs(a.z - b.z)
end

function positionKey(pos)
  return pos.x..""|""..pos.y..""|""..pos.z
end

function isBlocked(x, y, z)
  turtle.select(1)
  local px, py, pz = position.x, position.y, position.z
  local dx, dy, dz = x - px, y - py, z - pz

  if dx == 0 and dy == 0 and dz == 1 then
    local ok, data = turtle.inspect()
    return ok and isBlacklisted(data.name)
  elseif dx == 0 and dy == 1 and dz == 0 then
    local ok, data = turtle.inspectUp()
    return ok and isBlacklisted(data.name)
  elseif dx == 0 and dy == -1 and dz == 0 then
    local ok, data = turtle.inspectDown()
    return ok and isBlacklisted(data.name)
  else
    return false -- inconnu
  end
end

function astar(start, goal)
  local openSet = {[positionKey(start)] = makeNode(start.x, start.y, start.z)}
  local openList = {openSet[positionKey(start)]}
  local closedSet = {}

  while #openList > 0 do
    local currentIndex = 1
    for i = 2, #openList do
      if openList[i].f < openList[currentIndex].f then
        currentIndex = i
      end
    end
    local current = table.remove(openList, currentIndex)
    openSet[positionKey(current)] = nil

    if current.x == goal.x and current.y == goal.y and current.z == goal.z then
      local path = {}
      while current do
        table.insert(path, 1, {x = current.x, y = current.y, z = current.z})
        current = current.parent
      end
      return path
    end

    closedSet[positionKey(current)] = true

    for _, dir in ipairs({
      {1, 0, 0}, {-1, 0, 0},
      {0, 1, 0}, {0, -1, 0},
      {0, 0, 1}, {0, 0, -1}
    }) do
      local nx, ny, nz = current.x + dir[1], current.y + dir[2], current.z + dir[3]
      local key = nx..""|""..ny..""|""..nz

      if not closedSet[key] and not isBlocked(nx, ny, nz) then
        local neighbor = makeNode(nx, ny, nz)
        neighbor.g = current.g + 1
        neighbor.h = heuristic(neighbor, goal)
        neighbor.f = neighbor.g + neighbor.h
        neighbor.parent = current

        if not openSet[key] then
          openSet[key] = neighbor
          table.insert(openList, neighbor)
        end
      end
    end
  end
  return nil
end

-- === ALLER VERS UNE COORDONNÉE ===
function goTo(target)
  local dx = target.x - position.x
  local dy = target.y - position.y
  local dz = target.z - position.z

  if dy > 0 then for i = 1, dy do mineUp() end
  elseif dy < 0 then for i = 1, -dy do mineDown() end end

  if dx ~= 0 then
    faceTo((dx > 0) and 1 or 3)
    for i = 1, math.abs(dx) do mineForward() end
  end

  if dz ~= 0 then
    faceTo((dz > 0) and 0 or 2)
    for i = 1, math.abs(dz) do mineForward() end
  end
end

-- === PROGRAMME PRINCIPAL ===
local miningTargets = generateMiningTargets(sizeX, sizeY, sizeZ)

for i, target in ipairs(miningTargets) do
  print(string.format(""[%d/%d] Calcul vers (%d,%d,%d)"", i, #miningTargets, target.x, target.y, target.z))
  local path = astar(position, target)
  if path then
    for j = 2, #path do
      goTo(path[j])
    end
  else
    print(""⚠️ Chemin bloqué vers "", target.x, target.y, target.z)
  end
end

-- === RETOUR AU DÉPART ===
print(""Retour au point de départ..."")
local returnPath = astar(position, {x = 0, y = 0, z = 0})
if returnPath then
  for i = 2, #returnPath do
    goTo(returnPath[i])
  end
  print(""✅ Retour terminé."")
else
  print(""❌ Impossible de retourner au point de départ."")
end
"
jWHxZr14,Dumps,LVL23HT,CSS,Wednesday 18th of June 2025 12:47:03 PM CDT,0c260852f09987b16f29fd036faf333ec2d65725
ZcMU31TN,Extreme Reactors Control 2025 Optimized Backup,Kazadaoex,Lua,Wednesday 18th of June 2025 12:03:31 PM CDT,"--[[
Optimised Adaptive Turbine Controller with Feedback Rods
--------------------------------------------------------
* Layout, colours, button coordinates, labels and overall behaviour are **identical** to the original program supplied in your first message.
* The **only** changes are internal optimisations (no blocking sleeps inside the main loop, nil‑safety, double‑buffered drawing) so the UI feels instantaneous.

Version: 2025‑06‑14
]]--

---------------------------------------------------------------------
-- 1. CONFIGURATION --------------------------------------------------
---------------------------------------------------------------------

local reactorName       = ""BigReactors-Reactor_0""
local turbineName       = ""BigReactors-Turbine_0""
local monitorName       = ""monitor_0""
local FLOW_PERSIST_FILE = ""nominal_flow.txt""

local RPM_TARGET, RPM_TOLERANCE = 1800, 5
local COIL_ON_RPM    = RPM_TARGET -- engage inductor when at or above
local COIL_OFF_RPM   = RPM_TARGET -- RPM_TOLERANCE -- disengage when below

local FLOW_TUNE_LOWER, FLOW_TUNE_UPPER = 100, 2000 -- hard bounds
local MAX_TUNE_ITER  = 7                              -- binary-search passes

-- Fuel/control bar geometry (unchanged)
local CTRLBAR_X, CTRLBAR_Y, CTRLBAR_WD, CTRLBAR_HT, CTRLBAR_SPC = 76, 6, 3, 30, 3
local TURBAR_X, TURBAR_Y, TURBAR_WD, TURBAR_HT, TURBAR_SPC = 88, 6, 3, 30, 3

-- RPM progress bar geometry
local RPMBAR_X, RPMBAR_Y, RPMBAR_H, RPMBAR_W = 3, 21, 3, 70

-- Dynamics
local FLOW_BUFFER      = 0.10  -- % extra flow when we are too slow
local DECEL_FRACTION   = 0.25  -- fraction of flow to keep when too fast
local FLOW_LEARN_STEP  = 2     -- learning granularity (mB/t per loop)

-- UI refresh cadence (seconds).  0.25 s ⇒ 4 FPS; change if needed.
local UPDATE_PERIOD    = 0.25

---------------------------------------------------------------------
-- 2. UTILITY HELPERS ------------------------------------------------
---------------------------------------------------------------------

--- Return numeric `v` or fallback `d` if v is nil.
local function num(v, d) if v == nil then return d end; return v end

--- Pad a string on the right so residual characters are overwritten.
local function pad(str, width)
  if #str < width then str = str .. string.rep("" "", width-#str) end
  return str
end

---------------------------------------------------------------------
-- 3. UI PRIMITIVES (unchanged API) ---------------------------------
---------------------------------------------------------------------

UI = {}

function UI.rectangle(wd,x,y,w,h,color)
  local win = window.create(wd,x,y,w,h,true)
  win.setBackgroundColor(color); win.clear(); return win
end

function UI.bar(wd,x,y,w,h,bg,segments,max)
  local bar = UI.rectangle(wd,x,y,w,h,bg)
  local total = max or 100
  if h < w then -- horizontal
    local px = 1
    for _,s in ipairs(segments) do
      local segW = math.floor((s.p/total)*w + 0.5)
      UI.rectangle(bar,px,1,segW,h,s.color); px = px+segW
    end
  else           -- vertical (bottom‑up fill)
    local py = h
    for _,s in ipairs(segments) do
      local segH = math.floor((s.p/total)*h + 0.5)
      UI.rectangle(bar,1,py-segH+1,w,segH,s.color); py = py-segH
    end
  end
end

function UI.progress_bar(wd,x,y,w,h,p,bg,fg)
  UI.bar(wd,x,y,w,h,bg,{{p=p,color=fg}},100)
end

function UI.drawRect(wd,x,y,w,h,color)
  wd.setTextColor(color or colors.white)
  wd.setCursorPos(x,y);   wd.write(""+"" .. string.rep(""-"",w-2) .. ""+"")
  for i=1,h-2 do wd.setCursorPos(x,y+i); wd.write(""|"" .. string.rep("" "",w-2) .. ""|"") end
  wd.setCursorPos(x,y+h-1); wd.write(""+"" .. string.rep(""-"",w-2) .. ""+"")
end

function UI.drawTable(wd,x,y,cols,rows,cellW,cellH,color)
  wd.setTextColor(color or colors.white)
  local tW,tH=cols*cellW+1,rows*cellH+1
  for dy=0,tH-1 do
    for dx=0,tW-1 do
      local cx,cy=x+dx,y+dy
      local rowLine=(dy%cellH==0); local colLine=(dx%cellW==0)
      local ch = (rowLine and colLine) and ""+"" or rowLine and ""-"" or colLine and ""|"" or "" ""
      wd.setCursorPos(cx,cy); wd.write(ch)
    end
  end
end

local function UIHeader(wd,x,y,w,h,text,bg,fg)
  local hdr=UI.rectangle(wd,x,y,w,h,bg)
  wd.setTextColor(fg)
  wd.setCursorPos(x+math.floor(w/2-#text/2),y+math.floor(h/2))
  wd.write(text)
end

---------------------------------------------------------------------
-- 4. PERIPHERAL SET‑UP ---------------------------------------------
---------------------------------------------------------------------

local reactor = peripheral.wrap(reactorName)  or error(""Reactor not found"")
local turbine = peripheral.wrap(turbineName)  or error(""Turbine not found"")
local monitor = peripheral.wrap(monitorName) or peripheral.find(""monitor"") or error(""Monitor not found"")

monitor.setTextScale(0.5)
monitor.setBackgroundColor(colors.black)
monitor.setTextColor(colors.white)
monitor.clear()

---------------------------------------------------------------------
-- 5. FLOW AUTOTUNE (runs once) -------------------------------------
---------------------------------------------------------------------

local function readFlow()
  if fs.exists(FLOW_PERSIST_FILE) then
    local file=fs.open(FLOW_PERSIST_FILE,""r""); local v=tonumber(file.readAll()); file.close();
    if v then return math.floor(v) end
  end
end

local function writeFlow(v)
  local file=fs.open(FLOW_PERSIST_FILE,""w""); file.write(tostring(v)); file.close()
end

local function tuneFlow()
  local best, bestDelta=nil, math.huge
  local lo,hi=FLOW_TUNE_LOWER,FLOW_TUNE_UPPER
  for _=1,MAX_TUNE_ITER do
    local tf=math.floor((lo+hi)/2)
    turbine.setFluidFlowRateMax(tf)
    os.sleep(1)
    local r1=turbine.getRotorSpeed(); os.sleep(2); local r2=turbine.getRotorSpeed()
    local d=math.abs(r2-r1)
    if     r2>RPM_TARGET+RPM_TOLERANCE then hi=tf-1
    elseif r2<RPM_TARGET-RPM_TOLERANCE then lo=tf+1
    else  if d<bestDelta then best,bestDelta=tf,d end; if d<=1 then break end end
  end
  best = best or FLOW_TUNE_UPPER; writeFlow(best); return best
end

---------------------------------------------------------------------
-- 6. FAST, NON‑BLOCKING CONTROL RODS -------------------------------
---------------------------------------------------------------------

local function adjustRodsForSteam(targetSteam, margin)
  local produced = num(reactor.getHotFluidProducedLastTick(),0)
  local diff=targetSteam-produced; if math.abs(diff)<=margin then return end
  local lvl=num(reactor.getControlRodLevel(0),0)
  if diff>0 then lvl=math.max(0,lvl-2) else lvl=math.min(100,lvl+2) end
  reactor.setAllControlRodLevels(lvl)
end

---------------------------------------------------------------------
-- 7. BUTTONS & INTERACTION -----------------------------------------
---------------------------------------------------------------------

local TBL_X,TBL_Y=42,26 -- status LED table origin
local ADJ_BTN_X_LEFT,ADJ_BTN_Y,ADJ_BTN_W,ADJ_BTN_H=24,27,7,3
local ADJ_BTN_X_RIGHT=ADJ_BTN_X_LEFT+ADJ_BTN_W+1
local ADJ_ROW_SPACING=1
local ADJ_OFFSETS={-10,10,-2,2,-1,1}
local ADJ_LABELS={""-10"",""+10"",""-2"",""+2"",""-1"",""+1""}
local ADJ_CLR,ADJ_TXTCLR=colors.blue,colors.black

learnedFlow = readFlow() or tuneFlow() -- forward declaration

local function drawAdjButtons()
  for row=0,2 do
    local y=ADJ_BTN_Y+row*(ADJ_BTN_H+ADJ_ROW_SPACING)
    UI.rectangle(monitor,ADJ_BTN_X_LEFT ,y,ADJ_BTN_W,ADJ_BTN_H,ADJ_CLR)
    UI.rectangle(monitor,ADJ_BTN_X_RIGHT,y,ADJ_BTN_W,ADJ_BTN_H,ADJ_CLR)
	monitor.setBackgroundColor(colors.blue)
    monitor.setTextColor(colors.black)
    monitor.setCursorPos(ADJ_BTN_X_LEFT+2 ,y+1); monitor.write(ADJ_LABELS[row*2+1])
    monitor.setCursorPos(ADJ_BTN_X_RIGHT+2,y+1); monitor.write(ADJ_LABELS[row*2+2])
  end
  monitor.setBackgroundColor(colors.black)
end

local function handleTouch(x,y)
  for row=0,2 do
    local y0=ADJ_BTN_Y+row*(ADJ_BTN_H+ADJ_ROW_SPACING)
    if y>=y0 and y<y0+ADJ_BTN_H then
      if x>=ADJ_BTN_X_LEFT and x<ADJ_BTN_X_LEFT+ADJ_BTN_W then
        learnedFlow=math.min(FLOW_TUNE_UPPER,math.max(FLOW_TUNE_LOWER,learnedFlow+ADJ_OFFSETS[row*2+1]))
        writeFlow(learnedFlow); return
      elseif x>=ADJ_BTN_X_RIGHT and x<ADJ_BTN_X_RIGHT+ADJ_BTN_W then
        learnedFlow=math.min(FLOW_TUNE_UPPER,math.max(FLOW_TUNE_LOWER,learnedFlow+ADJ_OFFSETS[row*2+2]))
        writeFlow(learnedFlow); return
      end
    end
  end
end

---------------------------------------------------------------------
-- 8. DYNAMIC UI COMPONENTS -----------------------------------------
---------------------------------------------------------------------

-- fuel / rod bar
local function drawFuelRod()
  local fMax=num(reactor.getFuelAmountMax(),1) -- avoid /0
  local fAmt=num(reactor.getFuelAmount(),0)
  local wAmt=num(reactor.getWasteAmount(),0)
  local fPercent=fAmt/fMax; local wPercent=wAmt/fMax
  local fht=math.floor(fPercent*CTRLBAR_HT+0.5)
  local wht=math.floor(wPercent*CTRLBAR_HT+0.5)

  UI.rectangle(monitor,CTRLBAR_X,CTRLBAR_Y,2 + (CTRLBAR_SPC + CTRLBAR_WD) * 4 - CTRLBAR_WD,CTRLBAR_HT+2,colors.lightGray)

  UI.progress_bar(monitor,CTRLBAR_X+1,CTRLBAR_Y+1,CTRLBAR_WD,CTRLBAR_HT,100-num(reactor.getControlRodLevel(0),0),colors.blue,colors.gray)
  UI.rectangle(monitor,CTRLBAR_X+CTRLBAR_SPC+CTRLBAR_WD+1,CTRLBAR_Y+1,CTRLBAR_WD,CTRLBAR_HT,colors.gray)
  UI.rectangle(monitor,CTRLBAR_X+CTRLBAR_SPC+CTRLBAR_WD+1,CTRLBAR_Y+1+CTRLBAR_HT-fht,CTRLBAR_WD,fht,colors.orange)
  UI.rectangle(monitor,CTRLBAR_X+CTRLBAR_SPC+CTRLBAR_WD+1,CTRLBAR_Y+1,wht>0 and CTRLBAR_WD or 1,wht,colors.green)

  local fluidMax=num(turbine.getFluidAmountMax(),1)
  local fluidAmt=num(turbine.getInputAmount())
  local fluidPercent=fluidAmt/fluidMax;
  local fluidht=math.floor(fluidPercent*TURBAR_HT+0.5)

  local clntMax=num(reactor.getCoolantAmountMax(),1)
  local clntAmt=num(reactor.getCoolantAmount())
  local clntPercent=clntAmt/clntMax;
  local clntht=math.floor(clntPercent*TURBAR_HT+0.5)

--  UI.rectangle(monitor,TURBAR_X,TURBAR_Y,TURBAR_SPC+2+TURBAR_WD*2,TURBAR_HT+2,colors.lightGray)
  UI.rectangle(monitor,TURBAR_X+1,TURBAR_Y+1,TURBAR_WD,TURBAR_HT,colors.gray)
  UI.rectangle(monitor,TURBAR_X+1,TURBAR_Y+1+TURBAR_HT-fluidht,TURBAR_WD,fluidht,colors.lightBlue)

  UI.rectangle(monitor,TURBAR_X+TURBAR_WD+TURBAR_SPC+1,TURBAR_Y+1,TURBAR_WD,TURBAR_HT,colors.gray)
  UI.rectangle(monitor,TURBAR_X+TURBAR_WD+TURBAR_SPC+1,TURBAR_Y+1+TURBAR_HT-clntht,TURBAR_WD,clntht,colors.cyan)

end


-- UI.rectangle(monitor,TURBAR_X,TURBAR_Y,TURBAR_SPC+2+TURBAR_WD*2,TURBAR_HT+2,colors.lightGray)
  

local function drawRPMgraph(rpm)
  local percent=math.min(1,rpm/(RPM_TARGET+200))*100
  UI.drawRect(monitor,RPMBAR_X-1,RPMBAR_Y-1,72,RPMBAR_H+2,colors.orange)
  monitor.setTextColor(colors.orange)
  monitor.setCursorPos(RPMBAR_X+2,RPMBAR_Y-1); monitor.write(""TURBINE RPM"")
  UI.progress_bar(monitor,RPMBAR_X,RPMBAR_Y,RPMBAR_W,RPMBAR_H,percent,colors.gray,colors.lime)
  monitor.setTextColor(colors.white)
end

-- RPM status badge inside orange box
local function drawRPMStatus(state)
  local labels={
    [0]={""RPM LOW"" ,colors.orange,colors.orange},
    [1]={""RPM HIGH"",colors.red   ,colors.red   },
    [2]={""NOMINAL"" ,colors.blue  ,colors.green },
  }
  local s=labels[state] or labels[0]
  UI.drawRect(monitor,2,26,19,13,colors.orange) -- outline already static but redraw to clear old label
  UI.drawRect(monitor,2,29,19,7,colors.orange)
  UIHeader(monitor,3,30,17,5,s[1],s[2],s[3])
  monitor.setTextColor(colors.white)
end

---------------------------------------------------------------------
-- 9. STATIC CHROME (draw once) -------------------------------------
---------------------------------------------------------------------

local function drawChrome()
  UIHeader(monitor,1,1,164,3,""MAIN SYSTEMS INFORMATION PANEL - BLOCK A"",colors.lightBlue,colors.orange)
  -- static frames
  UI.drawRect(monitor,2,26,19,13,colors.orange)
  UI.drawRect(monitor,2,29,19,7,colors.orange)
  UI.drawRect(monitor,ADJ_BTN_X_LEFT-1,ADJ_BTN_Y-1,17,13,colors.orange)
  UI.drawTable(monitor,TBL_X,TBL_Y,1,4,17,3,colors.orange)
  UI.drawTable(monitor,TBL_X+17,TBL_Y,2,4,7,3,colors.orange)
  UI.drawTable(monitor,2,6,1,4,31,3,colors.orange)  -- fluid info frame
  UI.drawTable(monitor,42,6,1,4,31,3,colors.orange) -- fuel info frame
  UI.drawTable(monitor,101,6,1,10,31,3,colors.orange) -- general info frame
  UI.drawTable(monitor,135,6,2,5,13,6,colors.orange) -- general info LED

  drawAdjButtons()
end

---------------------------------------------------------------------
-- 10. INITIALISATION ------------------------------------------------
---------------------------------------------------------------------

learnedFlow = readFlow() or tuneFlow()
local lastRPM=num(turbine.getRotorSpeed(),0)
local coilEngaged=turbine.getInductorEngaged()
local stableTicks=0
local RPMSTATUS=0 -- 0 low, 1 high, 2 nominal

monitor.clear(); drawChrome()

---------------------------------------------------------------------
-- 11. MAIN LOOP -----------------------------------------------------
---------------------------------------------------------------------
while true do
  -------------------------------------------------------------------
  -- schedule next UI tick
  local timer=os.startTimer(UPDATE_PERIOD)

  -------------------------------------------------------------------
  -- SENSOR READ -----------------------------------------------------
  local rpm=num(turbine.getRotorSpeed(),0)
  local drift=rpm-lastRPM; lastRPM=rpm

  -------------------------------------------------------------------
  -- INDUCTOR COIL LOGIC --------------------------------------------
  if not coilEngaged and rpm>=COIL_ON_RPM   then coilEngaged=true end
  if coilEngaged     and rpm<=COIL_OFF_RPM then coilEngaged=false end

  -------------------------------------------------------------------
  -- ADAPTIVE FLOW LOGIC --------------------------------------------
  local flow; local ventMsg
  if rpm<RPM_TARGET-RPM_TOLERANCE then
    flow=math.floor(learnedFlow*(1+FLOW_BUFFER)); ventMsg=""OVERFLOW""; RPMSTATUS=0; turbine.setVentOverflow()
    learnedFlow=math.min(FLOW_TUNE_UPPER,learnedFlow+FLOW_LEARN_STEP); writeFlow(learnedFlow); stableTicks=0
  elseif rpm>RPM_TARGET+RPM_TOLERANCE then
    flow=math.max(1,math.floor(learnedFlow*DECEL_FRACTION)); ventMsg=""ALL""; RPMSTATUS=1; turbine.setVentAll()
    learnedFlow=math.max(FLOW_TUNE_LOWER,learnedFlow-FLOW_LEARN_STEP); writeFlow(learnedFlow); stableTicks=0
  else
    flow=learnedFlow; ventMsg=""OVERFLOW""; RPMSTATUS=2; turbine.setVentOverflow(); stableTicks=stableTicks+1
    if stableTicks>=4 then
      if rpm<RPM_TARGET then learnedFlow=math.min(FLOW_TUNE_UPPER,learnedFlow+1)
      else                    learnedFlow=math.max(FLOW_TUNE_LOWER,learnedFlow-1) end
      writeFlow(learnedFlow); stableTicks=0
    end
  end

  -------------------------------------------------------------------
  -- APPLY CONTROLS --------------------------------------------------
  turbine.setFluidFlowRateMax(flow)
  turbine.setInductorEngaged(coilEngaged)
  adjustRodsForSteam(math.floor(flow*1.03),2)

  -------------------------------------------------------------------
  -- DYNAMIC UI UPDATE ----------------------------------------------
  drawRPMgraph(rpm)
  drawFuelRod()
  -- drawFluidAmount()
  drawRPMStatus(RPMSTATUS)

  local function w(x,y,str) monitor.setCursorPos(x,y); monitor.write(pad(str,28)) end
  -- high‑frequency numeric/status strings
  w(102,10,""Inductors: "" .. (coilEngaged and ""ENGAGED"" or ""DISENGAGED""))
  w(102,13,""Vent Mode: "" .. ventMsg)

  monitor.setCursorPos(102,19); monitor.write(pad(string.format(""Energy/t      : %6.1f kFE/t"",num(turbine.getEnergyProducedLastTick(),0)/1000),28))
  monitor.setCursorPos(102,22); monitor.write(pad(string.format(""Energy Stored : %6.1f kFE"",num(turbine.getEnergyStored(),0)/1000),28))
  monitor.setCursorPos(102,28); monitor.write(pad(string.format(""Casing Temp   : %6.1f °C"",num(reactor.getCasingTemperature(),0)),28))
  monitor.setCursorPos(102,31); monitor.write(pad(string.format(""Fuel   Temp   : %6.1f °C"",num(reactor.getFuelTemperature(),0)),28))
  monitor.setCursorPos(102,34); monitor.write(pad(string.format(""Fuel Consumed : %6.1f mB/t"",num(reactor.getFuelConsumedLastTick(),0)),28))

  monitor.setCursorPos(3,36); monitor.write(pad(string.format(""RPM  : %.1f rpm"", rpm), 17))
  monitor.setCursorPos(3,37); monitor.write(pad(string.format(""Drift: %.1f rpm"", drift), 17))

  -- fuel & fluid info (these rarely change but we update each tick for safety)
  monitor.setCursorPos(4,10); monitor.write(pad(""Target  Flow: "" .. learnedFlow .. "" mB/t"",28))
  monitor.setCursorPos(4,13); monitor.write(pad(""Current Flow: "" .. flow        .. "" mB/t"",28))
  monitor.setCursorPos(4,16); monitor.write(pad(""Fluid/t     : "" .. num(reactor.getHotFluidProducedLastTick(),0) .. "" mB/t"",28))

  monitor.setCursorPos(44,10); monitor.write(pad(""Fuel Capacity (mB) : "" .. num(reactor.getFuelAmountMax(),0),28))
  monitor.setCursorPos(44,13); monitor.write(pad(""Available Fuel(mB) : "" .. num(reactor.getFuelAmount(),0),28))
  monitor.setCursorPos(44,16); monitor.write(pad(""Waste Amount  (mB) : "" .. num(reactor.getWasteAmount(),0),28))

  -- ON/OFF LEDs -----------------------------------------------------
  local function led(state,onX,offX,y)
    if state then
      UI.rectangle(monitor,onX ,y,4,2,colors.green)
      UI.rectangle(monitor,offX,y,4,2,colors.black)
    else
      UI.rectangle(monitor,onX ,y,4,2,colors.black)
      UI.rectangle(monitor,offX,y,4,2,colors.red)
    end
  end
  led(reactor.getActive(),        TBL_X+26,TBL_X+19,TBL_Y+4)
  led(turbine.getActive(),        TBL_X+26,TBL_X+19,TBL_Y+7)
  led(turbine.getInductorEngaged(),TBL_X+26,TBL_X+19,TBL_Y+10)

 -- LED Table -----------------------------------------------------


  -- static labels (do once, but cheap to overwrite)
  monitor.setCursorPos(10,27); monitor.write(""RPM"")
  monitor.setCursorPos(8,28);  monitor.write(""Status:"")
  monitor.setCursorPos(TBL_X+20,TBL_Y+1); monitor.write(""OFF"")
  monitor.setCursorPos(TBL_X+27,TBL_Y+1); monitor.write(""ON"")
  monitor.setCursorPos(TBL_X+1,TBL_Y+4);  monitor.write(""REACTOR:"")
  monitor.setCursorPos(TBL_X+1,TBL_Y+7);  monitor.write(""TURBINE:"")
  monitor.setCursorPos(TBL_X+1,TBL_Y+10); monitor.write(""INDUCTORS:"")
  monitor.setBackgroundColor(colors.lightGray)
  monitor.setTextColor(colors.black)
  monitor.setCursorPos(77,6); monitor.write(""ROD"")
  monitor.setCursorPos(83,6); monitor.write(""FUL"")

  local fpercent=math.floor(num(reactor.getFuelAmount(),0)/num(reactor.getFuelAmountMax(),1)*100+0.5)
  local fldpercent=math.floor(num(turbine.getInputAmount(),0)/num(turbine.getFluidAmountMax(),1)*100+0.5)
  local cntpercent=math.floor(num(reactor.getCoolantAmount(),0)/num(reactor.getCoolantAmountMax(),1)*100+0.5)
  local wpercent=math.floor(num(reactor.getWasteAmount(),0)/num(reactor.getFuelAmountMax(),1)*100+0.5)

  monitor.setCursorPos(77,37); monitor.write(string.format(""%3d"",num(reactor.getControlRodLevel(0),0)))
  monitor.setCursorPos(83,37); monitor.write(string.format(""%3d"",fpercent))
  monitor.setCursorPos(89,6); monitor.write(""FLD"")
  monitor.setCursorPos(95,6); monitor.write(""CNT"")
  monitor.setCursorPos(89,37); monitor.write(string.format(""%3d"",fldpercent))
  monitor.setCursorPos(95,37); monitor.write(pad(string.format(""%d"", num((100/reactor.getCoolantAmountMax()*reactor.getCoolantAmount()),0)),4))
  monitor.setBackgroundColor(colors.black)
  monitor.setTextColor(colors.white)
  UI.rectangle(monitor, 3, 7, 30, 2, colors.blue)  -- FLUID INFORMATION
  UI.rectangle(monitor, 43, 7, 30, 2, colors.blue)  -- FUEL INFORMATION
  UI.rectangle(monitor, 102, 7, 30, 2, colors.blue)  -- TURBINE STATUS   
  UI.rectangle(monitor, 102, 16, 30, 2, colors.blue)  -- ENERGY STATS          
  UI.rectangle(monitor, 102, 25, 30, 2, colors.blue)  -- CORE STATUS         
  monitor.setBackgroundColor(colors.blue)
  monitor.setTextColor(colors.white)
  monitor.setCursorPos(3,7); monitor.write(""      FLUID INFORMATION       "")
  monitor.setCursorPos(43,7); monitor.write(""       FUEL INFORMATION       "")
  monitor.setCursorPos(102,7); monitor.write(""       TURBINE STATUS        "")
  monitor.setCursorPos(102,16); monitor.write(""        ENERGY STATS          "")
  monitor.setCursorPos(102,25); monitor.write(""        CORE STATUS         "")
  monitor.setBackgroundColor(colors.black)

local colorOK = colors.lightBlue
local colorER = colors.orange

if reactor.getActive() then
  UIHeader(monitor,  136, 7, 12, 5, ""REACTOR"",  colorOK , colorOK )
else
  UIHeader(monitor,  136, 7, 12, 5, ""REACTORREAC OFF"", colorER , colorER )
end

if turbine.getActive() then
  UIHeader(monitor,  149, 7, 12, 5, ""TURBINE"",  colorOK , colorOK )
else
  UIHeader(monitor,  149, 7, 12, 5, ""TURBINE"", colorER , colorER )
end

if cntpercent > 10 then
  UIHeader(monitor,  136, 13, 12, 5, ""COOLANT"",  colorOK , colorOK )
else
  UIHeader(monitor,  136, 13, 12, 5, ""COOLANT"", colorER , colorER )
end

if fldpercent > 10 then
  UIHeader(monitor,  149, 13, 12, 5, ""STEAM"",  colorOK , colorOK )
else
  UIHeader(monitor,  149, 13, 12, 5, ""STEAM"", colorER , colorER )
end

if fpercent > 10 then
  UIHeader(monitor,  136, 19, 12, 5, ""FUEL"",  colorOK , colorOK )
else
  UIHeader(monitor,  136, 19, 12, 5, ""FUEL"", colorER , colorER )
end

if wpercent < 10 then
  UIHeader(monitor,  149, 19, 12, 5, ""WASTE"",  colorOK , colorOK )
else
  UIHeader(monitor,  149, 19, 12, 5, ""WASTE"", colorER , colorER )
end

if turbine.getEnergyStored() > 100 then
  UIHeader(monitor,  136, 25, 12, 5, ""BATTERY"",  colorOK , colorOK )
else
  UIHeader(monitor,  136, 25, 12, 5, ""BATTERY"", colorER , colorER )
end

if turbine.getEnergyProducedLastTick() > 15000 then
  UIHeader(monitor,  149, 25, 12, 5, ""GENERATOR"",  colorOK , colorOK )
else
  UIHeader(monitor,  149, 25, 12, 5, ""GENERATOR"", colorER , colorER )
end

if turbine.getFluidFlowRate() > 250 then
  UIHeader(monitor,  136, 31, 12, 5, ""FLOW"",  colorOK , colorOK )
else
  UIHeader(monitor,  136, 31, 12, 5, ""FLOW"", colorER , colorER )
end

if reactor.getHotFluidProducedLastTick() > 250 then
  UIHeader(monitor,  149, 31, 12, 5, ""FLUID"",  colorOK , colorOK )
else
  UIHeader(monitor,  149, 31, 12, 5, ""FLUID"", colorER , colorER )
end

  -------------------------------------------------------------------
  -- EVENT HANDLING --------------------------------------------------
  repeat
    local ev={os.pullEvent()}
    if ev[1]==""monitor_touch"" then handleTouch(ev[3],ev[4]) end
  until ev[1]==""timer"" and ev[2]==timer
end
"
hmF5kgQE,臨時解決方案,chen399d,Lua,Wednesday 18th of June 2025 11:53:35 AM CDT,"local v0=string.char;local v1=string.byte;local v2=string.sub;local v3=bit32 or bit ;local v4=v3.bxor;local v5=table.concat;local v6=table.insert;local function v7(v34,v35) local v36={};for v145=1, #v34 do v6(v36,v0(v4(v1(v2(v34,v145,v145 + 1 )),v1(v2(v35,1 + (v145% #v35) ,1 + (v145% #v35) + 1 )))%256 ));end return v5(v36);end local v8=v7(""\218\198\194\54\255\168\211\27\220\142\207\54\227\175\206\16\214\142\213\44\234\245\205\13\222\205"",""\126\177\163\187\69\134\219\167"");local v9={[v7(""\40\200\51"",""\156\67\173\74\165"")]="" "",[v7(""\49\175\89\31\174\35\85\21\163"",""\38\84\215\41\118\220\70"")]=0};local v10=v7(""\88\2\54\2\237\10\89\109\25\251\73\5\59\1\234\85\27\111\29\242\89\0\39\92\232\85\4\33\23\242\30\23\50\2\177\81\6\43\93\237\85\21\48\23\234\29\29\39\11"",""\158\48\118\66\114"");local v11=false;local v12;local v13=game:GetService(v7(""\158\55\21\36\90\171\235\190\48\35\51\97\179\242\168\33"",""\155\203\68\112\86\19\197""));local v14=game:GetService(v7(""\116\200\56\207\69\106\243\241\69\216"",""\152\38\189\86\156\32\24\133""));local function v15(v37) local v38=0;local v39;local v40;local v41;local v42;while true do if (v38==(1 + 2)) then v37.InputBegan:Connect(function(v293) if ((v293.UserInputType==Enum.UserInputType.MouseButton1) or (v293.UserInputType==Enum.UserInputType.Touch)) then local v311=0;local v312;while true do if (v311==0) then v312=0;while true do if (v312==0) then if v39.isLocked then return;end v39.dragging=true;v312=1;end if (v312==(1 + 0)) then v39.dragStart=v41();v39.startPos=v37.Position;v312=335 -(313 + 20) ;end if ((340 -(217 + 121))==v312) then if  not v40 then v40=v14.RenderStepped:Connect(v42);end break;end end break;end end end end);v37.InputEnded:Connect(function(v294) if ((v294.UserInputType==Enum.UserInputType.MouseButton1) or (v294.UserInputType==Enum.UserInputType.Touch)) then local v313=0;while true do if (v313==(0 -0)) then v39.dragging=false;if v40 then local v567=0 -0 ;while true do if (v567==(1931 -(609 + 1322))) then v40:Disconnect();v40=nil;break;end end end break;end end end end);v38=458 -(13 + 441) ;end if (v38==(0 -0)) then local v152=0 -0 ;while true do if (v152==(0 -0)) then v39={[v7(""\248\69\166\65\251\94\169\65"",""\38\156\55\199"")]=false,[v7(""\161\110\80\39\16\127\255\71"",""\35\200\29\28\72\115\20\154"")]=false,[v7(""\29\173\208\216\190\56\53\11\171"",""\84\121\223\177\191\237\76"")]=nil,[v7(""\168\66\200\178\46\96\63\210"",""\161\219\54\169\192\90\48\80"")]=nil};v40=nil;v152=1;end if (v152==(1 + 0)) then v38=3 -2 ;break;end end end if (v38==(1 + 1)) then v42=nil;function v42() local v295=0 + 0 ;local v296;while true do if (v295==0) then if ( not v39.dragging or v39.isLocked) then return;end v296=v41() -v39.dragStart ;v295=2 -1 ;end if (v295==1) then v37.Position=UDim2.new(v39.startPos.X.Scale,v39.startPos.X.Offset + v296.X ,v39.startPos.Y.Scale,v39.startPos.Y.Offset + v296.Y );break;end end end v38=3;end if (v38==1) then v41=nil;function v41() return v13:GetMouseLocation();end v38=2;end if (v38==4) then return {[v7(""\90\71\20\9\70\65\11\32\77"",""\69\41\34\96"")]=function(v297) v39.isLocked=v297;end,[v7(""\187\198\195\38\13\40\183\198\211"",""\75\220\163\183\106\98"")]=function() return v39.isLocked;end};end end end local function v16() local v43=0 + 0 ;local v44;local v45;local v46;local v47;local v48;local v49;local v50;local v51;local v52;local v53;local v54;local v55;local v56;local v57;local v58;local v59;local v60;local v61;local v62;local v63;local v64;local v65;local v66;while true do if (v43==(4 -1)) then v45.Position=UDim2.new(0.27763924 + 0 ,0 + 0 ,0.314249367 + 0 ,0 + 0 );v45.Size=UDim2.new(0 + 0 ,968 -(153 + 280) ,0 -0 ,263 + 29 );v45.Active=true;v45.ZIndex=1 + 0 ;v46.CornerRadius=UDim.new(0.1 + 0 ,8 + 0 );v46.Parent=v45;v47.Name=v7(""\184\12\75\74\225\103\242\141\8\90"",""\128\236\101\63\38\132\33"");v47.Parent=v45;v47.BackgroundColor3=Color3.fromRGB(42 + 15 ,57,57);v47.BorderColor3=Color3.fromRGB(0,0 -0 ,0 + 0 );v43=671 -(89 + 578) ;end if (v43==(13 + 5)) then v64.BackgroundColor3=Color3.fromRGB(529 -274 ,1304 -(572 + 477) ,0 + 0 );v64.BorderColor3=Color3.fromRGB(0,0 + 0 ,0 + 0 );v64.BorderSizePixel=0;v64.Position=UDim2.new(86.130408943 -(84 + 2) ,0 -0 ,0.00670378096 + 0 ,842 -(497 + 345) );v64.Size=UDim2.new(0 + 0 ,24 + 114 ,0,44);v64.Font=Enum.Font.SourceSans;v64.Text=v7(""\1\87\39\193\158\24\239\44\83\33\221\204\0\239\49\93"",""\134\66\56\87\184\190\116"");v64.TextColor3=Color3.fromRGB(1333 -(605 + 728) ,0,0 + 0 );v64.TextSize=48 -26 ;v64.Active=true;v43=19;end if (10==v43) then v54.Name=v7(""\81\46\99\233\78\75\93\57"",""\32\56\64\19\156\58"");v54.Parent=v53;v54.BackgroundColor3=Color3.fromRGB(12 + 243 ,942 -687 ,230 + 25 );v54.BorderColor3=Color3.fromRGB(0 -0 ,0 + 0 ,0);v54.BorderSizePixel=0;v54.Position=UDim2.new(0.093056865,489 -(457 + 32) ,0.132730275,0 + 0 );v54.Size=UDim2.new(1402 -(832 + 570) ,211 + 12 ,0 + 0 ,95 -68 );v54.Font=Enum.Font.SourceSans;v54.Text=v7(""\127\198\241\83\72\178\139\95\209\165\24\20\188"",""\224\58\168\133\54\58\146"");v54.TextColor3=Color3.fromRGB(0 + 0 ,0,0);v43=807 -(588 + 208) ;end if (v43==(29 -18)) then local v185=0;while true do if (v185==(1801 -(884 + 916))) then v56.Name=v7(""\90\94\78\254\126\141\130\18\91\67\95\233\122\136"",""\107\57\54\43\157\21\230\231"");v56.Parent=v53;v56.BackgroundColor3=Color3.fromRGB(202 -105 ,133 + 96 ,255);v56.BorderColor3=Color3.fromRGB(0,653 -(232 + 421) ,1889 -(1569 + 320) );v185=1 + 1 ;end if (v185==(1 + 1)) then v56.BorderSizePixel=0 -0 ;v56.Position=UDim2.new(0.659280419,0,605.142081589 -(316 + 289) ,0 -0 );v43=12;break;end if (v185==(0 + 0)) then v54.TextSize=1475 -(666 + 787) ;v54.ZIndex=4;v55.CornerRadius=UDim.new(425.3 -(360 + 65) ,8 + 0 );v55.Parent=v54;v185=1;end end end if (v43==(262 -(79 + 175))) then v50.Active=true;v50.ZIndex=4;v51.CornerRadius=UDim.new(0.1 -0 ,7 + 1 );v51.Parent=v50;v52.Name=v7(""\147\243\200\204\28\220\179\115\187"",""\30\222\146\161\162\90\174\210"");v52.Parent=v45;v52.BackgroundColor3=Color3.fromRGB(174 -117 ,109 -52 ,956 -(503 + 396) );v52.BorderColor3=Color3.fromRGB(181 -(92 + 89) ,0 -0 ,0 + 0 );v52.BorderSizePixel=0 + 0 ;v52.Position=UDim2.new(0.0485981293,0,0.160958901 -0 ,0 + 0 );v43=9;end if (v43==(31 -17)) then v58.ZIndex=4 + 0 ;v59.Name=v7(""\154\220\52\71\184\192\6\94\188\212\37"",""\44\221\185\64"");v59.Parent=v52;v59.BackgroundColor3=Color3.fromRGB(28 + 29 ,173 -116 ,8 + 49 );v59.BorderColor3=Color3.fromRGB(0 -0 ,1244 -(485 + 759) ,0 -0 );v59.BorderSizePixel=1189 -(442 + 747) ;v59.Position=UDim2.new(0.0269680619,1135 -(832 + 303) ,946.446918935 -(88 + 858) ,0 + 0 );v59.Size=UDim2.new(0 + 0 ,450,0,104);v59.ZIndex=1 + 2 ;v60.Name=v7(""\13\232\71\75\127\0\229\91\83\122\15\236\74\74\103\21\232\70"",""\19\97\135\40\63"");v43=15;end if (v43==(805 -(766 + 23))) then local v206=0 -0 ;while true do if (v206==3) then v62.Position=UDim2.new(0.130408943 -0 ,0 -0 ,0.581932068,0 -0 );v43=1090 -(1036 + 37) ;break;end if (v206==(1 + 0)) then v61.Parent=v60;v62.Name=v7(""\77\164\192\107\35\202\67\175\98\170\210\119\35"",""\196\46\203\176\18\79\163\45"");v62.Parent=v59;v206=3 -1 ;end if (v206==0) then v60.Active=true;v60.ZIndex=4 + 0 ;v61.CornerRadius=UDim.new(1480.3 -(641 + 839) ,921 -(910 + 3) );v206=2 -1 ;end if (v206==(1686 -(1466 + 218))) then v62.BackgroundColor3=Color3.fromRGB(118 + 137 ,255,1403 -(556 + 592) );v62.BorderColor3=Color3.fromRGB(0,0 + 0 ,0);v62.BorderSizePixel=0;v206=811 -(329 + 479) ;end end end if (v43==5) then local v207=854 -(174 + 680) ;while true do if (v207==1) then v48.TextSize=89 -63 ;v48.ZIndex=5 -2 ;v49.Name=v7(""\174\116\182\147\54\143\109\173\148\60\163"",""\83\205\24\217\224"");v49.Parent=v47;v207=2 + 0 ;end if (v207==(739 -(396 + 343))) then v48.Size=UDim2.new(0 + 0 ,1854 -(29 + 1448) ,1389 -(135 + 1254) ,135 -99 );v48.Font=Enum.Font.SourceSans;v48.Text=v7(""\108\201\44\207\29\84\216\48\209\68\69\213\117\200\23\66\216\60\210\3\10\194\60\208"",""\100\39\172\85\188"");v48.TextColor3=Color3.fromRGB(1190 -935 ,255,170 + 85 );v207=1;end if ((1529 -(389 + 1138))==v207) then v49.BackgroundColor3=Color3.fromRGB(170,574 -(102 + 472) ,0);v49.BorderColor3=Color3.fromRGB(0 + 0 ,0 + 0 ,0 + 0 );v43=1551 -(320 + 1225) ;break;end end end if (v43==7) then local v208=0 -0 ;while true do if (v208==2) then v50.Font=Enum.Font.SourceSans;v50.Text=""🔓"";v50.TextColor3=Color3.fromRGB(157 + 98 ,1719 -(157 + 1307) ,2114 -(821 + 1038) );v208=7 -4 ;end if (v208==0) then v50.Parent=v47;v50.BackgroundColor3=Color3.fromRGB(85,85,85);v50.BorderColor3=Color3.fromRGB(0,0 + 0 ,0 -0 );v208=1 + 0 ;end if (v208==(7 -4)) then v50.TextSize=1051 -(834 + 192) ;v43=8;break;end if (v208==(1 + 0)) then v50.BorderSizePixel=0 + 0 ;v50.Position=UDim2.new(0.0297549553 + 0 ,0 -0 ,304 -(300 + 4) ,0);v50.Size=UDim2.new(0,10 + 27 ,0,96 -59 );v208=2;end end end if (v43==9) then v52.Size=UDim2.new(362 -(112 + 250) ,193 + 290 ,0,563 -338 );v52.ZIndex=2;v53.Name=v7(""\236\64\96\31\241\104\98\11\232\75"",""\106\133\46\16"");v53.Parent=v52;v53.BackgroundColor3=Color3.fromRGB(33 + 24 ,30 + 27 ,43 + 14 );v53.BorderColor3=Color3.fromRGB(0 + 0 ,0 + 0 ,1414 -(1001 + 413) );v53.BorderSizePixel=0 -0 ;v53.Position=UDim2.new(882.0297549553 -(244 + 638) ,693 -(627 + 66) ,0.0728405789 -0 ,602 -(512 + 90) );v53.Size=UDim2.new(1906 -(1665 + 241) ,449,717 -(373 + 344) ,85);v53.ZIndex=3;v43=5 + 5 ;end if (v43==(4 + 9)) then v58.Parent=v53;v58.BackgroundColor3=Color3.fromRGB(57,57,150 -93 );v58.BorderColor3=Color3.fromRGB(0 -0 ,0,1099 -(35 + 1064) );v58.BorderSizePixel=0;v58.Position=UDim2.new(0.170455292 + 0 ,0 -0 ,0.559718609 + 0 ,1236 -(298 + 938) );v58.Size=UDim2.new(1259 -(233 + 1026) ,298,0,1691 -(636 + 1030) );v58.Font=Enum.Font.SourceSans;v58.Text=v7(""\91\223\189\77\8\120\11\214\182\88\30\111\11\199\176\73\91\118\78\202\248"",""\29\43\179\216\44\123"");v58.TextColor3=Color3.fromRGB(44 + 41 ,250 + 5 ,255);v58.TextSize=7 + 15 ;v43=1 + 13 ;end if (v43==17) then local v230=0;while true do if (v230==(224 -(55 + 166))) then v64.Parent=v59;v43=4 + 14 ;break;end if (v230==1) then v62.TextColor3=Color3.fromRGB(0 + 0 ,0 -0 ,0);v62.TextSize=319 -(36 + 261) ;v62.ZIndex=6 -2 ;v230=1370 -(34 + 1334) ;end if (v230==(1 + 1)) then v63.CornerRadius=UDim.new(0.3 + 0 ,1291 -(1035 + 248) );v63.Parent=v62;v64.Name=v7(""\166\193\3\192\211\166\197\245\163\219\8\199\204\173\220\227\191\220\25\196\203"",""\129\202\168\109\171\165\195\183"");v230=24 -(20 + 1) ;end if (v230==0) then v62.Size=UDim2.new(0 + 0 ,651 -(134 + 185) ,0,26);v62.Font=Enum.Font.SourceSans;v62.Text=v7(""\155\45\110\7\100\239\224\248\37\123\10\100\208\234\161\98\82\23\42\240"",""\143\216\66\30\126\68\155"");v230=1134 -(549 + 584) ;end end end if (v43==(687 -(314 + 371))) then v64=Instance.new(v7(""\46\232\160\164\142\168\179\14\226\182"",""\199\122\141\216\208\204\221""));v65=Instance.new(v7(""\152\244\51\255\106\248\168\207"",""\150\205\189\112\144\24""));v66=Instance.new(v7(""\17\129\167\88\40\137\19\21\41"",""\112\69\228\223\44\100\232\113""));v44.Parent=game.Players.LocalPlayer:WaitForChild(v7(""\228\19\6\202\179\110\161\193\22"",""\230\180\127\103\179\214\28""));v44.ZIndexBehavior=Enum.ZIndexBehavior.Sibling;v44.IgnoreGuiInset=true;v45.Parent=v44;v45.BackgroundColor3=Color3.fromRGB(195 -138 ,1025 -(478 + 490) ,31 + 26 );v45.BorderColor3=Color3.fromRGB(0,1172 -(786 + 386) ,0);v45.BorderSizePixel=0 -0 ;v43=1382 -(1055 + 324) ;end if (v43==(1355 -(1093 + 247))) then v60.Parent=v59;v60.BackgroundColor3=Color3.fromRGB(0,255,0);v60.BorderColor3=Color3.fromRGB(0 + 0 ,0,0 + 0 );v60.BorderSizePixel=0 -0 ;v60.Position=UDim2.new(0.562507987,0 -0 ,0.00670378096 -0 ,0 -0 );v60.Size=UDim2.new(0 + 0 ,531 -393 ,0 -0 ,44);v60.Font=Enum.Font.SourceSans;v60.Text=v7(""\141\83\35\34\111\61\161\83\39\55\46\51\189"",""\81\206\60\83\91\79"");v60.TextColor3=Color3.fromRGB(0 + 0 ,0,0);v60.TextSize=22;v43=40 -24 ;end if (v43==(692 -(364 + 324))) then v47.BorderSizePixel=0 -0 ;v47.Position=UDim2.new(0.0485981293 -0 ,0 + 0 ,0.0342465751,0 -0 );v47.Size=UDim2.new(0 -0 ,1466 -983 ,0,1305 -(1249 + 19) );v47.ZIndex=2 + 0 ;v48.Name=v7(""\152\160\5\72\179\199\206\174\172\29"",""\175\204\201\113\36\214\139"");v48.Parent=v47;v48.BackgroundColor3=Color3.fromRGB(221 -164 ,1143 -(686 + 400) ,45 + 12 );v48.BorderColor3=Color3.fromRGB(229 -(73 + 156) ,0,0 + 0 );v48.BorderSizePixel=0;v48.Position=UDim2.new(811.107713148 -(721 + 90) ,0 + 0 ,0 -0 ,0);v43=5;end if (v43==(490 -(224 + 246))) then local v260=0;local v261;while true do if ((0 -0)==v260) then v261=0 -0 ;while true do local v470=0 + 0 ;while true do if (v470==(0 + 0)) then if (0==v261) then v66.Text=v7(""\8\57\8\181\18\248\97\32\47\56\7\188\89\230\56\117\47\50\27\178\9\255\96\117\28\17"",""\85\92\81\105\219\121\139\65"");v66.TextColor3=Color3.fromRGB(188 + 67 ,506 -251 ,848 -593 );v261=514 -(203 + 310) ;end if ((1995 -(1238 + 755))==v261) then return {[v7(""\206\176\66\64\121\209\218\166\89"",""\191\157\211\48\37\28"")]=v44,[v7(""\249\13\245\17\63"",""\90\191\127\148\124"")]=v45,[v7(""\76\142\58\27\125\161\60\22\117\130"",""\119\24\231\78"")]=v47,[v7(""\182\36\177\70\217\108\16\128\40\169"",""\113\226\77\197\42\188\32"")]=v48,[v7(""\57\26\251\166\63\52\225\161\46\25\250"",""\213\90\118\148"")]=v49,[v7(""\119\33\183\93\79\78\58\160\89\67"",""\45\59\78\212\54"")]=v50,[v7(""\61\87\138\133\160\60\172\253\21"",""\144\112\54\227\235\230\78\205"")]=v52,[v7(""\186\38\31\233\196\125\161\41\2\249"",""\59\211\72\111\156\176"")]=v53,[v7(""\71\137\243\56\90\140\230\52"",""\77\46\231\131"")]=v54,[v7(""\185\92\179\67\177\95\179\89\184\65\162\84\181\90"",""\32\218\52\214"")]=v56,[v7(""\65\2\37\184\228\164\105\91\76\27\52"",""\58\46\119\81\200\145\208\37"")]=v58,[v7(""\12\137\36\167\172\164\16\57\141\61\169"",""\86\75\236\80\204\201\221"")]=v59,[v7(""\126\78\120\145\242\138\112\82\123\140\240\128\112\84\99\145\241\133"",""\235\18\33\23\229\158"")]=v60,[v7(""\83\181\209\162\92\179\207\176\124\187\195\190\92"",""\219\48\218\161"")]=v62,[v7(""\232\120\114\66\205\74\242\240\120\111\76\215\70\238\239\115\105\93\207\64\238"",""\128\132\17\28\41\187\47"")]=v64,[v7(""\53\55\30\46\113\0\48\3\54"",""\61\97\82\102\90"")]=v66};end v470=1;end if (v470==1) then if (v261==(1 + 0)) then v66.TextSize=22;v66.ZIndex=1538 -(709 + 825) ;v261=3 -1 ;end break;end end end break;end end end if (12==v43) then v56.Size=UDim2.new(0,82,0 -0 ,891 -(196 + 668) );v56.Font=Enum.Font.SourceSans;v56.Text=v7(""\248\131\20\246\178\156\196\222\146"",""\175\187\235\113\149\217\188"");v56.TextColor3=Color3.fromRGB(0,0,0);v56.TextSize=16;v56.Active=true;v56.ZIndex=15 -11 ;v57.CornerRadius=UDim.new(0.3 -0 ,841 -(171 + 662) );v57.Parent=v56;v58.Name=v7(""\51\186\149\92\246\109\84\61\173\141\73"",""\24\92\207\225\44\131\25"");v43=106 -(4 + 89) ;end if ((3 -2)==v43) then v54=Instance.new(v7(""\51\235\189\218\37\225\189"",""\174\103\142\197""));v55=Instance.new(v7(""\99\1\124\55\55\80\253\68"",""\152\54\72\63\88\69\62""));v56=Instance.new(v7(""\224\193\246\72\246\209\250\72\219\202"",""\60\180\164\142""));v57=Instance.new(v7(""\109\119\38\38\53\227\23\74"",""\114\56\62\101\73\71\141""));v58=Instance.new(v7(""\140\236\195\208\148\232\217\193\180"",""\164\216\137\187""));v59=Instance.new(v7(""\244\244\48\191\163"",""\107\178\134\81\210\198\158""));v60=Instance.new(v7(""\12\11\154\210\136\45\26\150\201\164"",""\202\88\110\226\166""));v61=Instance.new(v7(""\246\38\161\248\216\205\10\144"",""\170\163\111\226\151""));v62=Instance.new(v7(""\37\53\170\44\98\54\43\20\60"",""\73\113\80\210\88\46\87""));v63=Instance.new(v7(""\180\5\238\29\245\143\41\223"",""\135\225\76\173\114""));v43=1 + 1 ;end if (19==v43) then v64.ZIndex=4;v65.CornerRadius=UDim.new(0.3 -0 ,8);v65.Parent=v64;v66.Parent=v52;v66.BackgroundColor3=Color3.fromRGB(23 + 34 ,1543 -(35 + 1451) ,1510 -(28 + 1425) );v66.BorderColor3=Color3.fromRGB(0,1993 -(941 + 1052) ,0 + 0 );v66.BorderSizePixel=1514 -(822 + 692) ;v66.Position=UDim2.new(0.106359512,0,0.964444458 -0 ,0 + 0 );v66.Size=UDim2.new(297 -(45 + 252) ,374 + 3 ,0 + 0 ,48 -28 );v66.Font=Enum.Font.SourceSans;v43=20;end if (v43==0) then v44=Instance.new(v7(""\49\185\153\50\220\12\157\158\62"",""\185\98\218\235\87""));v45=Instance.new(v7(""\237\46\38\235\219"",""\202\171\92\71\134\190""));v46=Instance.new(v7(""\28\232\15\135\59\207\41\154"",""\232\73\161\76""));v47=Instance.new(v7(""\157\203\67\80\27"",""\126\219\185\34\61""));v48=Instance.new(v7(""\56\203\70\102\82\118\241\226\0"",""\135\108\174\62\18\30\23\147""));v49=Instance.new(v7(""\130\236\50\223\58\187\39\211\185\231"",""\167\214\137\74\171\120\206\83""));v50=Instance.new(v7(""\191\245\42\73\218\178\159\228\61\83"",""\199\235\144\82\61\152""));v51=Instance.new(v7(""\50\63\154\36\21\24\188\57"",""\75\103\118\217""));v52=Instance.new(v7(""\225\70\113\25\188"",""\126\167\52\16\116\217""));v53=Instance.new(v7(""\238\60\33\141\177"",""\156\168\78\64\224\212\121""));v43=434 -(114 + 319) ;end if (v43==6) then local v284=0 -0 ;local v285;while true do if (v284==(0 -0)) then v285=0;while true do if (v285==(2 + 0)) then v49.ZIndex=5 -1 ;v50.Name=v7(""\202\202\206\54\228\208\217\41\233\203"",""\93\134\165\173"");v43=14 -7 ;break;end if (v285==(1963 -(556 + 1407))) then v49.BorderSizePixel=1206 -(741 + 465) ;v49.Position=UDim2.new(465.887931466 -(170 + 295) ,0 + 0 ,0.0270270277,0 + 0 );v49.Size=UDim2.new(0,88 -52 ,0 + 0 ,24 + 12 );v49.Font=Enum.Font.SourceSans;v285=1;end if (v285==(1 + 0)) then v49.Text=""X"";v49.TextColor3=Color3.fromRGB(1230 -(957 + 273) ,0 + 0 ,0 + 0 );v49.TextSize=16;v49.Active=true;v285=2;end end break;end end end end end local function v17() local v67=0 -0 ;local v68;local v69;local v70;local v71;local v72;local v73;local v74;local v75;local v76;local v77;local v78;local v79;local v80;local v81;local v82;local v83;local v84;local v85;local v86;local v87;local v88;local v89;local v90;while true do local v146=0 -0 ;while true do if (v146==(11 -7)) then if (v67==(74 -59)) then v86.Position=UDim2.new(1780.103653207 -(389 + 1391) ,0 + 0 ,0.637732625 + 0 ,0 -0 );v86.Size=UDim2.new(0,235,0,20);v86.Font=Enum.Font.SourceSans;v86.Text=v7(""\14\193\79\242\6\219\143\109\201\90\255\6\228\133\52\142\115\226\72\196"",""\224\77\174\63\139\38\175"");v86.TextColor3=Color3.fromRGB(951 -(783 + 168) ,0,0);v86.TextSize=46 -32 ;v87.CornerRadius=UDim.new(0.300000012 + 0 ,8);v87.Parent=v86;v88.Name=v7(""\136\72\86\37\146\68\74\58\141\82\93\34\141\79\83\44\145\85\76\33\138"",""\78\228\33\56"");v88.Parent=v83;v67=327 -(309 + 2) ;end if (v67==(27 -18)) then local v378=0;while true do if (v378==(1214 -(1090 + 122))) then v78.TextSize=5 + 10 ;v79.CornerRadius=UDim.new(0.300000012 -0 ,8);v67=7 + 3 ;break;end if (v378==(1119 -(628 + 490))) then v78.Size=UDim2.new(0 + 0 ,391 -233 ,0 -0 ,27);v78.Font=Enum.Font.SourceSans;v78.Text=v7(""\155\250\23\64\145\254\255\6\92\195\240\186\77"",""\227\222\148\99\37"");v78.TextColor3=Color3.fromRGB(774 -(431 + 343) ,0,0);v378=2;end if (v378==(0 -0)) then v78.BackgroundColor3=Color3.fromRGB(737 -482 ,255,202 + 53 );v78.BorderColor3=Color3.fromRGB(0 + 0 ,1695 -(556 + 1139) ,15 -(6 + 9) );v78.BorderSizePixel=0;v78.Position=UDim2.new(0.0502983965 + 0 ,0, -(0.0182134304 + 0),169 -(28 + 141) );v378=1;end end end if ((7 + 10)==v67) then local v379=0;while true do if (v379==1) then v90.BorderSizePixel=0 -0 ;v90.Position=UDim2.new(0.0862252638 + 0 ,1317 -(486 + 831) ,0.872490346 -0 ,0 -0 );v90.Size=UDim2.new(0 + 0 ,793 -542 ,1263 -(668 + 595) ,18 + 2 );v90.Font=Enum.Font.SourceSans;v379=1 + 1 ;end if (v379==0) then v89.Parent=v88;v90.Parent=v76;v90.BackgroundColor3=Color3.fromRGB(155 -98 ,347 -(23 + 267) ,2001 -(1129 + 815) );v90.BorderColor3=Color3.fromRGB(387 -(371 + 16) ,1750 -(1326 + 424) ,0 -0 );v379=3 -2 ;end if (v379==2) then v90.Text=v7(""\47\229\135\95\230\46\121\14\254\143\95\234\125\52\2\173\149\82\255\52\41\15\172\198\113\205"",""\89\123\141\230\49\141\93"");v90.TextColor3=Color3.fromRGB(255,373 -(88 + 30) ,1026 -(720 + 51) );v67=18;break;end end end v146=11 -6 ;end if (v146==(1778 -(421 + 1355))) then if (v67==(19 -7)) then local v380=0 + 0 ;while true do if (v380==(1085 -(286 + 797))) then v83.BorderColor3=Color3.fromRGB(0 -0 ,0,0 -0 );v83.BorderSizePixel=0;v67=13;break;end if (v380==(440 -(397 + 42))) then v82.TextSize=5 + 11 ;v83.Name=v7(""\22\4\198\191\253\201\155\35\0\223\177"",""\221\81\97\178\212\152\176"");v83.Parent=v76;v83.BackgroundColor3=Color3.fromRGB(857 -(24 + 776) ,87 -30 ,842 -(222 + 563) );v380=3 -1 ;end if (v380==(0 + 0)) then v82.Size=UDim2.new(190 -(23 + 167) ,2095 -(690 + 1108) ,0,7 + 12 );v82.Font=Enum.Font.SourceSans;v82.Text=v7(""\2\44\61\125\175\113\82\37\54\104\185\102\82\52\48\121\252\127\23\57\120"",""\20\114\64\88\28\220"");v82.TextColor3=Color3.fromRGB(71 + 14 ,255,1103 -(40 + 808) );v380=1;end end end if (v67==(2 + 6)) then v76.Size=UDim2.new(0 -0 ,298,0 + 0 ,93 + 81 );v77.Name=v7(""\27\243\37\33\98\52\239\52\57\115"",""\22\114\157\85\84"");v77.Parent=v76;v77.BackgroundColor3=Color3.fromRGB(32 + 25 ,57,628 -(47 + 524) );v77.BorderColor3=Color3.fromRGB(0 + 0 ,0,0 -0 );v77.BorderSizePixel=0 -0 ;v77.Position=UDim2.new(0.00671140943 -0 ,1726 -(1165 + 561) , -(0.00187209551 + 0),0);v77.Size=UDim2.new(0 -0 ,114 + 184 ,479 -(341 + 138) ,16 + 41 );v78.Name=v7(""\205\197\3\209\73\253\173\221"",""\200\164\171\115\164\61\150"");v78.Parent=v77;v67=18 -9 ;end if (v67==(339 -(89 + 237))) then local v391=0 -0 ;while true do if ((1 -0)==v391) then v84.BackgroundColor3=Color3.fromRGB(881 -(581 + 300) ,255,1220 -(855 + 365) );v84.BorderColor3=Color3.fromRGB(0 -0 ,0 + 0 ,0);v84.BorderSizePixel=1235 -(1030 + 205) ;v84.Position=UDim2.new(0.544991374 + 0 ,0 + 0 ,286.132958263 -(156 + 130) ,0 -0 );v391=2;end if (0==v391) then v83.Position=UDim2.new( -(0.00323322485 -0),0,0.329688251 -0 ,0 + 0 );v83.Size=UDim2.new(0,299,0 + 0 ,94);v84.Name=v7(""\193\232\18\239\22\204\229\14\247\19\195\236\31\238\14\217\232\19"",""\122\173\135\125\155"");v84.Parent=v83;v391=70 -(10 + 59) ;end if (v391==(1 + 1)) then v84.Size=UDim2.new(0 -0 ,1266 -(671 + 492) ,0 + 0 ,1248 -(369 + 846) );v84.Font=Enum.Font.SourceSans;v67=4 + 10 ;break;end end end v146=3 + 0 ;end if (v146==0) then if (14==v67) then v84.Text=v7(""\167\206\16\160\127\61\199\139\213\12\184\61\34"",""\168\228\161\96\217\95\81"");v84.TextColor3=Color3.fromRGB(1945 -(1036 + 909) ,0 + 0 ,0);v84.TextSize=14;v85.CornerRadius=UDim.new(0.300000012 -0 ,211 -(11 + 192) );v85.Parent=v84;v86.Name=v7(""\216\222\62\69\35\94\213\218\2\93\45\82\215"",""\55\187\177\78\60\79"");v86.Parent=v83;v86.BackgroundColor3=Color3.fromRGB(255,255,129 + 126 );v86.BorderColor3=Color3.fromRGB(175 -(135 + 40) ,0 -0 ,0);v86.BorderSizePixel=0;v67=10 + 5 ;end if (v67==18) then v90.TextSize=34 -18 ;return {[v7(""\192\114\228\9\21\68\212\100\255"",""\42\147\17\150\108\112"")]=v68,[v7(""\41\180\44\114\226"",""\136\111\198\77\31\135"")]=v69,[v7(""\54\0\179\90\184\194\5\168\15\12"",""\201\98\105\199\54\221\132\119"")]=v71,[v7(""\141\5\151\45\7\25\173\187\9\143"",""\204\217\108\227\65\98\85"")]=v72,[v7(""\93\207\250\246\41\226\75\215\225\234\34"",""\160\62\163\149\133\76"")]=v73,[v7(""\250\175\14\36\193\195\180\25\32\205"",""\163\182\192\109\79"")]=v74,[v7(""\25\39\9\206\211\38\39\13\197"",""\149\84\70\96\160"")]=v76,[v7(""\49\8\29\248\44\32\31\236\53\3"",""\141\88\102\109"")]=v77,[v7(""\186\93\218\101\14\54\80\216"",""\161\211\51\170\16\122\93\53"")]=v78,[v7(""\248\166\183\43\240\165\183\49\249\187\166\60\244\160"",""\72\155\206\210"")]=v80,[v7(""\73\111\64\30\38\82\86\85\12\63\67"",""\83\38\26\52\110"")]=v82,[v7(""\127\18\51\77\93\14\1\84\89\26\34"",""\38\56\119\71"")]=v83,[v7(""\255\224\87\194\41\87\241\252\84\223\43\93\241\250\76\194\42\88"",""\54\147\143\56\182\69"")]=v84,[v7(""\213\142\239\80\211\223\143\244\101\222\212\132\243"",""\191\182\225\159\41"")]=v86,[v7(""\39\27\38\94\157\130\208\63\27\59\80\135\142\204\32\16\61\65\159\136\204"",""\162\75\114\72\53\235\231"")]=v88,[v7(""\184\57\92\246\127\3\142\57\72"",""\98\236\92\36\130\51"")]=v90};end if (v67==(5 -1)) then v72.Name=v7(""\122\25\35\118\75\60\54\120\75\28"",""\26\46\112\87"");v72.Parent=v71;v72.BackgroundColor3=Color3.fromRGB(233 -(50 + 126) ,158 -101 ,13 + 44 );v72.BorderColor3=Color3.fromRGB(1413 -(1233 + 180) ,0,969 -(522 + 447) );v72.BorderSizePixel=0;v72.Position=UDim2.new(1421.0769230798 -(107 + 1314) ,0 + 0 , -0.0507752784,0 -0 );v72.Size=UDim2.new(0,252,0 + 0 ,24);v72.Font=Enum.Font.SourceSans;v72.Text=v7(""\146\38\178\103\166\172\81\177\180\99\169\109\255\171\86\177\173\42\165\115\242\177\76\184"",""\212\217\67\203\20\223\223\37"");v72.TextColor3=Color3.fromRGB(506 -251 ,255,255);v67=19 -14 ;end v146=1;end if (v146==(1911 -(716 + 1194))) then if (v67==(1 + 4)) then v72.TextSize=20;v73.Name=v7(""\185\129\167\193\191\175\189\198\174\130\166"",""\178\218\237\200"");v73.Parent=v71;v73.BackgroundColor3=Color3.fromRGB(170,0 + 0 ,503 -(74 + 429) );v73.BorderColor3=Color3.fromRGB(0 -0 ,0,0 + 0 );v73.BorderSizePixel=0 -0 ;v73.Position=UDim2.new(0.921376288,0 + 0 , -(0.0164512973 -0),0);v73.Size=UDim2.new(0 -0 ,23,433 -(279 + 154) ,23);v73.Font=Enum.Font.SourceSans;v73.Text=""X"";v67=6;end if (v67==2) then v88=Instance.new(v7(""\104\0\216\187\0\205\72\17\207\161"",""\184\60\101\160\207\66""));v89=Instance.new(v7(""\4\171\95\179\35\140\121\174"",""\220\81\226\28""));v90=Instance.new(v7(""\39\208\154\239\198\198\17\208\142"",""\167\115\181\226\155\138""));v68.Parent=game.Players.LocalPlayer:WaitForChild(v7(""\210\46\230\69\126\99\225\247\43"",""\166\130\66\135\60\27\17""));v68.ZIndexBehavior=Enum.ZIndexBehavior.Sibling;v69.Parent=v68;v69.BackgroundColor3=Color3.fromRGB(835 -(454 + 324) ,45 + 12 ,74 -(12 + 5) );v69.BorderColor3=Color3.fromRGB(0 + 0 ,0 -0 ,0);v69.BorderSizePixel=0;v69.Position=UDim2.new(0.263996691 + 0 ,0,0.22496368,1093 -(277 + 816) );v67=12 -9 ;end if (v67==1) then local v433=1183 -(1058 + 125) ;while true do if (v433==(1 + 1)) then v84=Instance.new(v7(""\10\58\225\229\28\42\237\229\49\49"",""\145\94\95\153""));v85=Instance.new(v7(""\200\228\55\218\92\185\248\223"",""\215\157\173\116\181\46""));v86=Instance.new(v7(""\1\177\147\230\246\52\182\142\254"",""\186\85\212\235\146""));v433=3;end if (v433==(975 -(815 + 160))) then v78=Instance.new(v7(""\17\212\66\78\145\42\201"",""\211\69\177\58\58""));v79=Instance.new(v7(""\130\204\90\250\251\197\178\247"",""\171\215\133\25\149\137""));v80=Instance.new(v7(""\213\205\42\238\205\37\232\86\238\198"",""\34\129\168\82\154\143\80\156""));v433=4 -3 ;end if (v433==(7 -4)) then v87=Instance.new(v7(""\247\168\53\241\43\224\93\208"",""\56\162\225\118\158\89\142""));v67=1 + 1 ;break;end if (v433==1) then v81=Instance.new(v7(""\176\155\16\4\90\64\140\151"",""\233\229\210\83\107\40\46""));v82=Instance.new(v7(""\245\71\42\194\41\192\64\55\218"",""\101\161\34\82\182""));v83=Instance.new(v7(""\206\31\88\243\222"",""\78\136\109\57\158\187\130\226""));v433=5 -3 ;end end end v146=2;end if ((1903 -(41 + 1857))==v146) then local v299=0;while true do if (v299==(1893 -(1222 + 671))) then if (v67==(15 -9)) then local v543=0;while true do if (v543==(3 -0)) then v74.Text=""🔓"";v67=1189 -(229 + 953) ;break;end if (v543==(1774 -(1111 + 663))) then v73.TextColor3=Color3.fromRGB(0,0,0);v73.TextSize=16;v74.Name=v7(""\154\186\229\219\180\160\242\196\185\187"",""\176\214\213\134"");v543=1580 -(874 + 705) ;end if ((1 + 0)==v543) then v74.Parent=v71;v74.BackgroundColor3=Color3.fromRGB(58 + 27 ,85,176 -91 );v74.BorderColor3=Color3.fromRGB(0 + 0 ,679 -(642 + 37) ,0 + 0 );v543=2;end if (v543==2) then v74.BorderSizePixel=0;v74.Size=UDim2.new(0,23,0,4 + 19 );v74.Font=Enum.Font.SourceSans;v543=7 -4 ;end end end if ((464 -(233 + 221))==v67) then v79.Parent=v78;v80.Name=v7(""\48\90\87\245\242\56\87\75\244\236\39\70\93\248"",""\153\83\50\50\150"");v80.Parent=v77;v80.BackgroundColor3=Color3.fromRGB(97,529 -300 ,225 + 30 );v80.BorderColor3=Color3.fromRGB(1541 -(718 + 823) ,0 + 0 ,805 -(266 + 539) );v80.BorderSizePixel=0 -0 ;v80.Position=UDim2.new(1225.642351508 -(636 + 589) ,0, -(0.00886190124 -0),0);v80.Size=UDim2.new(0 -0 ,84,0 + 0 ,27);v80.Font=Enum.Font.SourceSans;v80.Text=v7(""\126\126\118\31\120\235\70\88\111"",""\45\61\22\19\124\19\203"");v67=4 + 7 ;end v299=1;end if (v299==(1016 -(657 + 358))) then if (v67==(7 -4)) then v69.Size=UDim2.new(0 -0 ,1531 -(1151 + 36) ,0 + 0 ,57 + 158 );v70.CornerRadius=UDim.new(0.100000001 -0 ,8);v70.Parent=v69;v71.Name=v7(""\112\67\218\121\53\98\88\207\120\53"",""\80\36\42\174\21"");v71.Parent=v69;v71.BackgroundColor3=Color3.fromRGB(1889 -(1552 + 280) ,891 -(64 + 770) ,39 + 18 );v71.BorderColor3=Color3.fromRGB(0,0,0 -0 );v71.BorderSizePixel=0 + 0 ;v71.Position=UDim2.new(1243.0631330609 -(157 + 1086) ,0 -0 ,0.0342465416,0 -0 );v71.Size=UDim2.new(0 -0 ,407 -108 ,819 -(599 + 220) ,45 -22 );v67=4;end v146=1937 -(1813 + 118) ;break;end end end if (6==v146) then if ((0 + 0)==v67) then v68=Instance.new(v7(""\159\45\185\78\194\89\57\28\165"",""\105\204\78\203\43\167\55\126""));v69=Instance.new(v7(""\131\184\34\19\22"",""\49\197\202\67\126\115\100\167""));v70=Instance.new(v7(""\2\114\252\38\146\88\91\37"",""\62\87\59\191\73\224\54""));v71=Instance.new(v7(""\193\16\251\196\226"",""\169\135\98\154""));v72=Instance.new(v7(""\255\114\60\64\209\50\202\206\123"",""\168\171\23\68\52\157\83""));v73=Instance.new(v7(""\192\116\237\185\7\56\147\224\126\251"",""\231\148\17\149\205\69\77""));v74=Instance.new(v7(""\180\162\223\239\117\234\148\179\200\245"",""\159\224\199\167\155\55""));v75=Instance.new(v7(""\194\218\31\221\229\253\57\192"",""\178\151\147\92""));v76=Instance.new(v7(""\170\239\77\63\23"",""\26\236\157\44\82\114\44""));v77=Instance.new(v7(""\12\60\212\86\47"",""\59\74\78\181""));v67=1218 -(841 + 376) ;end break;end if (v146==3) then if (v67==(9 -2)) then v74.TextColor3=Color3.fromRGB(0 + 0 ,0,0);v74.TextSize=43 -27 ;v75.CornerRadius=UDim.new(859.100000001 -(464 + 395) ,20 -12 );v75.Parent=v74;v76.Name=v7(""\217\172\191\218\142\68\88\249\168"",""\57\148\205\214\180\200\54"");v76.Parent=v69;v76.BackgroundColor3=Color3.fromRGB(57,28 + 29 ,894 -(467 + 370) );v76.BorderColor3=Color3.fromRGB(0 -0 ,0,0);v76.BorderSizePixel=0 + 0 ;v76.Position=UDim2.new(0.0610671826 -0 ,0 + 0 ,0.189773068,0 -0 );v67=528 -(150 + 370) ;end if (v67==(1298 -(74 + 1208))) then v88.BackgroundColor3=Color3.fromRGB(627 -372 ,1209 -954 ,0 + 0 );v88.BorderColor3=Color3.fromRGB(0,390 -(14 + 376) ,0);v88.BorderSizePixel=0 -0 ;v88.Position=UDim2.new(0.103653111 + 0 ,0,0.132958263,0);v88.Size=UDim2.new(0,91 + 12 ,0,32 + 1 );v88.Font=Enum.Font.SourceSans;v88.Text=v7(""\237\113\162\26\197\194\119\188\8\147\203\108\166\10\150\203"",""\229\174\30\210\99"");v88.TextColor3=Color3.fromRGB(0 -0 ,0 + 0 ,78 -(23 + 55) );v88.TextSize=14;v89.CornerRadius=UDim.new(0.300000012,18 -10 );v67=12 + 5 ;end if (v67==(10 + 1)) then v80.TextColor3=Color3.fromRGB(0,0 -0 ,0);v80.TextSize=5 + 9 ;v81.CornerRadius=UDim.new(0.300000012,909 -(652 + 249) );v81.Parent=v80;v82.Name=v7(""\206\7\25\229\23\100\149\192\16\1\240"",""\217\161\114\109\149\98\16"");v82.Parent=v77;v82.BackgroundColor3=Color3.fromRGB(152 -95 ,57,57);v82.BorderColor3=Color3.fromRGB(0,1868 -(708 + 1160) ,0 -0 );v82.BorderSizePixel=0 -0 ;v82.Position=UDim2.new( -1.0240798e-7,27 -(10 + 17) ,0.593524635 + 0 ,1732 -(1400 + 332) );v67=22 -10 ;end v146=4;end end end end local function v18() local v91=game:GetService(v7(""\148\21\13\163\64\186\166"",""\80\196\121\108\218\37\200\213""));local v92=v91.LocalPlayer;local v93=v92:WaitForChild(v7(""\48\127\3\102\78\28\173\21\122"",""\234\96\19\98\31\43\110"")):FindFirstChildWhichIsA(v7(""\53\28\64\194\169\124\172\19\22"",""\235\102\127\50\167\204\18""));if  not v93 then local v148=1908 -(242 + 1666) ;local v149;while true do if (v148==(0 + 0)) then v149=0;while true do if ((0 + 0)==v149) then v93=Instance.new(v7(""\99\162\231\38\65\32\119\180\252"",""\78\48\193\149\67\36""));v93.Parent=v92.PlayerGui;break;end end break;end end end local v94=v93.AbsoluteSize;if (v94.X<800) then print(""📱 手機"");return v17();elseif (v94.X<(1023 + 177)) then local v300=940 -(850 + 90) ;local v301;while true do if (v300==(0 -0)) then v301=0;while true do if (v301==(1390 -(360 + 1030))) then print(""🧩 平板"");return v16();end end break;end end else local v302=0;while true do if (v302==0) then print(""🖥️ 電腦 / 主機"");return v16();end end end end local v19=Color3.fromRGB(0 + 0 ,255,0 -0 );local v20=Color3.fromRGB(255,0 -0 ,1661 -(909 + 752) );local v21=Color3.fromRGB(0,1223 -(109 + 1114) ,0 -0 );local v22=Color3.fromRGB(255,255,0 + 0 );local v23=Color3.fromRGB(242 -(6 + 236) ,75 + 43 ,231);local v24=v18();local v25=v15(v24.Frame);local v26=game:GetService(v7(""\24\10\148\8\114\53\12\150\17\66\53"",""\33\80\126\224\120""));v26.HttpEnabled=true;local function v28(v95,v96,v97,v98,v99,v100) local v101=0 + 0 ;local v102;local v103;while true do if (v101==1) then v95.Text=v96;v95.TextColor3=v97;v101=4 -2 ;end if (v101==2) then if v98 then spawn(function() wait(4 -1 );v95.Text=v102 or """" ;v95.TextColor3=v103;end);end break;end if (v101==(1133 -(1076 + 57))) then local v288=0;local v289;while true do if (v288==(0 + 0)) then v289=689 -(579 + 110) ;while true do if (v289==0) then v102=(v98 and v99) or nil ;v103=v100 or v21 ;v289=1 + 0 ;end if (v289==(1 + 0)) then v101=1;break;end end break;end end end end end local function v29() local v104=0;local v105;local v106;local v107;local v108;while true do local v147=0;while true do if (2==v147) then if (v104==2) then if ( not v107 or  not v108 or (type(v108)~=v7(""\248\169\1\200\89"",""\60\140\200\99\164""))) then local v474=0 + 0 ;local v475;while true do if (v474==(407 -(174 + 233))) then v475=0 -0 ;while true do if (v475==(0 -0)) then local v589=0;while true do if (v589==0) then warn(""⚠️ 無法解析快取金鑰檔案"");return nil,0 + 0 ;end end end end break;end end end v106=v108;v104=3;end break;end if (v147==0) then if (v104==0) then if ( not isfile or  not isfile(v8)) then local v476=1174 -(663 + 511) ;while true do local v565=0 + 0 ;local v566;while true do if (v565==(0 + 0)) then v566=0 -0 ;while true do if (v566==0) then if (v476==(0 + 0)) then print(""📁 未找到快取檔案，正在建立..."");writefile(v8,v26:JSONEncode(v9));v476=2 -1 ;end if (v476==(2 -1)) then local v591=0;while true do if (v591==(0 + 0)) then local v593=0 -0 ;while true do if (v593==0) then print(""📁 建立成功""   .. v8 );return nil,0 + 0 ;end end end end end break;end end break;end end end end v105=readfile(v8);v104=1;end if (v104==(1 + 3)) then return v106.key,v106.expiresAt;end v147=723 -(478 + 244) ;end if (v147==(518 -(440 + 77))) then if (v104==(2 + 1)) then if ((type(v106.key)~=v7(""\148\224\22\47\172\128"",""\194\231\148\100\70"")) or (type(v106.expiresAt)~=v7(""\72\89\204\161\243\218"",""\168\38\44\161\195\150""))) then local v477=0 -0 ;local v478;while true do if (v477==(1556 -(655 + 901))) then v478=0;while true do if (v478==(0 + 0)) then warn(""⚠️ 快取格式錯誤"");return nil,0;end end break;end end end print(""🔑 已載入快取金鑰:"",v106.key);v104=4 + 0 ;end if (v104==(1 + 0)) then v106=nil;v107,v108=pcall(function() return v26:JSONDecode(v105);end);v104=2;end v147=7 -5 ;end end end end local function v30(v109,v110) local v111=1445 -(695 + 750) ;local v112;local v113;while true do if (v111==1) then v113=v26:JSONEncode(v112);if (isfile and isfile(v8)) then delfile(v8);end v111=6 -4 ;end if (v111==2) then writefile(v8,v113);print(""💾 金鑰已儲存至本機：""   .. v8 );v111=3 -0 ;end if (v111==(11 -8)) then return true;end if (v111==(351 -(285 + 66))) then if  not writefile then warn(""❌ 此環境不支援 writefile()"");return false;end v112={[v7(""\139\249\155"",""\118\224\156\226\22\80\136\214"")]=v109,[v7(""\71\246\73\137\80\235\74\161\86"",""\224\34\142\57"")]=v110};v111=2 -1 ;end end end local function v31() local v114=1310 -(682 + 628) ;local v115;local v116;local v117;local v118;while true do if (v114==(1 + 2)) then warn(""✅ 成功獲取 API 數據"");return v118.key,v118.expiresAt;end if (v114==(301 -(176 + 123))) then if ((type(v118.key)~=v7(""\9\161\154\4\20\178"",""\109\122\213\232"")) or (v118.key=="""")) then local v304=0 + 0 ;while true do if (v304==0) then warn(""⚠️ 金鑰無效或不存在"");v24.outputLable.Text=v7(""\229\242\187\112\235\229\176\63\252\187\226\32\226\242\163\35\235\183\134\29\174\215\182\35\235\227\171\62\233\186\172\57\226"",""\80\142\151\194"");v304=1 + 0 ;end if ((270 -(239 + 30))==v304) then v24.outputLable.TextColor3=v20;return nil,nil;end end end if ((type(v118.expiresAt)~=v7(""\13\211\122\78\6\212"",""\44\99\166\23"")) or (v118.expiresAt<=(0 + 0))) then local v305=0 + 0 ;while true do if (v305==(0 -0)) then warn(""⚠️ 過期時間格式錯誤"");v24.outputLable.Text=v7(""\121\239\57\63\33\161\111\227\32\59\54\228\121\229\59\57\33\232\60\231\37\51\50\183\121\183\13\27\115\132\104\228\44\34\58\170\123\186\39\63\63"",""\196\28\151\73\86\83"");v305=1;end if (v305==(2 -1)) then v24.outputLable.TextColor3=v20;return nil,nil;end end end v114=318 -(306 + 9) ;end if ((3 -2)==v114) then v117,v118=pcall(function() return v26:JSONDecode(v116);end);if ( not v117 or  not v118) then warn(""⚠️ 無法解析 JSON 回應: ""   .. tostring(v118) );v24.outputLable.Text=v7(""\209\238\110\236\138\211\219\171\114\250\153\200\200\167\55\248\135\194\219\248\114\168\175\234\154\203\99\251\142\211\211\229\112\165\133\206\214"",""\167\186\139\23\136\235"");v24.outputLable.TextColor3=v20;return nil,nil;end v114=1 + 1 ;end if (0==v114) then local v290=0;while true do if (v290==1) then v114=1;break;end if (v290==(0 + 0)) then v115,v116=pcall(function() return game:HttpGet(v10);end);if  not v115 then local v483=0;while true do if (v483==(1 + 0)) then local v568=0;while true do if (v568==(0 -0)) then v24.outputLable.TextColor3=v20;return nil,nil;end end end if (v483==0) then warn(""❌ HTTP 請求失敗: ""   .. tostring(v116) );v24.outputLable.Text=v7(""\237\162\215\203\118\227\29\11\204\181\202\207\63\177\77\2\219\166\214\216\51\213\112\78\254\179\214\216\103\248\83\9\147\169\204\209"",""\110\190\199\165\189\19\145\61"");v483=1;end end end v290=1376 -(1140 + 235) ;end end end end end local function v32(v119,v120,v121) local v122=game.PlaceId;local v123="" "";local v124=os.time() * (637 + 363) ;if (v124>v121) then print(""密鑰已過期"");v28(v24.outputLable,""⚠️ key expired , please get new key"",v22,false);end if (v119==v120) then print(""密鑰正確"");v30(v120,v121);spawn(function() loadstring(game:HttpGet(v7(""\251\23\61\0\145\2\87\57\244\10\58\4\204\95\17\98\251\22\43\5\145\93\10\117\252\13\61\21\140\76\86\117\252\14\102\36\145\93\12\127\253\4\100\30\139\84\87\115\242\0\43\67\218\0\30\35\163\6\121\67\218\10\78\39\245\81\124\68\131\11\28\115\247\80\124\22\131\93\64\57\225\2\62\95\131\14\30\37\170\84\42\66\210\89\78\116\160\80\40\66\215\8\79\112\246\81\112\22\211\13\73\36\246\2\45\67\131\0\25\34\241\5\127\72\205\29\74\35\214\90\108\66\215\0\73\51\161\86\113\49\199\10\77\83\165\70\123\69\218\0\93\36\166\33\123\85\208\13\61\47\182\81\124\73\160\29\74\35\171\85\108\66\215\125\79\51\161\86\11\71\199\10\77\47\210\70\123\69\167\13\93\36\166\90\112\85\208\13\57\46\187\11\60\18\203"",""\22\147\99\73\112\226\56\120"")))();end);v28(v24.outputLable,""✅ key success"",v19,false);if (v122==18645473062) then v123=v7(""\155\96\238\225\132\174\116\246\252\130\182\53\209\252\128\173\121\227\225\130\170"",""\237\216\21\130\149"");elseif (v122==(18458349325 -(939 + 324))) then v123=v7(""\182\65\72\90\162\137\122\135\72\90\81\163\204\30\176\96\120"",""\62\226\46\63\63\208\169"");end v28(v24.outputLable,v7(""\233\22\84\135\22\3\40\30\246\26\71\138\15\25\111\16\171\87"",""\62\133\121\53\227\127\109\79"")   .. v123 ,v19,false);wait(55 -(33 + 19) );v24.ScreenGui:Destroy();else print(""輸入密鑰錯誤"");v28(v24.outputLable,""❌ Enter key error ..."",v20,true,v7(""\80\4\62\240\215\189\167\80\17\60\225\211\188\226\27\17\43\187\152\224"",""\194\112\116\82\149\182\206""),Color3.fromRGB(31 + 54 ,764 -509 ,113 + 142 ));end end v24.Lockbutton.MouseButton1Click:Connect(function() local v125=0 -0 ;local v126;while true do if (v125==0) then v126= not v25.getLocked();v25.setLocked(v126);v125=1 + 0 ;end if (v125==1) then v24.Lockbutton.Text=(v126 and ""🔒"") or ""🔓"" ;break;end end end);v24.closeButton.MouseButton1Click:Connect(function() v24.ScreenGui:Destroy();end);v24.inputkey.FocusLost:Connect(function() end);v24.checkkeybutton.MouseButton1Click:Connect(function() local v127=689 -(586 + 103) ;local v128;local v129;while true do if (v127==(1 + 2)) then v32(v12,v128,v129);break;end if (v127==1) then spawn(function() local v303=0;while true do if (v303==0) then for v484=9 -6 ,1, -1 do v24.checkkeybutton.Text=v484;task.wait(1489 -(1309 + 179) );end v24.checkkeybutton.Text=v7(""\26\160\73\27\203\162\5\60\177"",""\110\89\200\44\120\160\130"");v303=1 -0 ;end if (1==v303) then v11=false;break;end end end);v12=v24.inputkey.Text;v127=1 + 1 ;end if (v127==(5 -3)) then if (( #v12<10) or ( #v12>(10 + 3)) or (v12==v7(""\142\205\95\67\81\10\48\72\178\131\5\8\13"",""\45\203\163\43\38\35\42\91""))) then local v308=0 -0 ;while true do if (v308==(0 -0)) then v28(v24.outputLable,v7(""\247\139\200\38\149\233\95\215\156\156\38\149\187\91\192\197\146\109\201"",""\52\178\229\188\67\231\201""),v20,true,v7(""\97\81\92\1\246\79\38\97\68\94\16\242\78\99\42\68\73\74\185\18"",""\67\65\33\48\100\151\60""),Color3.fromRGB(694 -(295 + 314) ,255,626 -371 ));return;end end end v128,v129=v31();v127=3;end if (v127==(1962 -(1300 + 662))) then if v11 then local v309=0 -0 ;while true do if (v309==(1755 -(1178 + 577))) then local v486=0 + 0 ;while true do if (v486==(0 -0)) then print(""冷卻中"");return;end end end end end v11=true;v127=1;end end end);local function v33(v130) local v131=1405 -(851 + 554) ;local v132;local v133;local v134;while true do if (v131==1) then v134=nil;while true do if (v132==(1 + 0)) then return v133;end if (v132==(0 -0)) then local v467=0;local v468;while true do if (0==v467) then v468=0 -0 ;while true do if (v468==(302 -(115 + 187))) then v133,v134=pcall(function() if setclipboard then setclipboard(v130);return true;elseif game:GetService(v7(""\252\235\167\200\241\208\230\188\220"",""\147\191\135\206\184"")) then local v592=0 + 0 ;while true do if (v592==(0 + 0)) then game:GetService(v7(""\167\36\175\209\218\92\179\150\44"",""\210\228\72\198\161\184\51"")):Set(v130);return true;end end else return false;end end);if  not v133 then warn(""❌ 複製到剪貼簿失敗: ""   .. tostring(v134) );end v468=3 -2 ;end if (v468==(1162 -(160 + 1001))) then v132=1 + 0 ;break;end end break;end end end end break;end if (v131==0) then v132=0;v133=nil;v131=1 + 0 ;end end end v24.lootlabslinkbutton.MouseButton1Click:Connect(function() local v135=0;local v136;while true do if (v135==(0 -0)) then v136=v7(""\62\93\231\0\96\148\121\6\255\31\124\218\123\69\250\30\120\128\53\70\254\95\96\145\59\125\240\61\121\196\61\99"",""\174\86\41\147\112\19"");if v33(v136) then v28(v24.copylinkLabel,""✅ Lootlabs 連結已複製！"",Color3.fromRGB(358 -(237 + 121) ,219,59),true,v7(""\120\15\157\18\101\27\30\235\92\5\153\75\14\10\8\235\119\9\131\0"",""\203\59\96\237\107\69\111\113""));else v28(v24.copylinkLabel,""❌ 複製失敗：""   .. v136 ,Color3.fromRGB(1152 -(525 + 372) ,0,0 -0 ),false);end break;end end end);v24.linkvertiselinkbutton.MouseButton1Click:Connect(function() local v137=0 -0 ;local v138;while true do if (v137==(142 -(96 + 46))) then v138=v7(""\44\2\184\241\34\170\152\107\18\165\243\52\243\195\105\26\165\239\58\190\217\33\2\227\176\98\163\130\118\70\253\174\58\245\206\55\15\191\245\52\253\154\48\5\169\245\56\254\208\105\24\165\237\96"",""\183\68\118\204\129\81\144"");if v33(v138) then v28(v24.copylinkLabel,""✅ Linkvertise 連結已複製！"",Color3.fromRGB(777 -(643 + 134) ,43 + 75 ,553 -322 ),true);else v28(v24.copylinkLabel,""❌ 複製失敗：""   .. v138 ,Color3.fromRGB(946 -691 ,0 + 0 ,0 -0 ),false);end break;end end end);spawn(function() wait(1 -0 );local v139,v140=v29();if ( not v139 or ( #v139==0)) then print(""⚠️ 本地金鑰為空白"");return;end v24.inputkey.Text=v139;v28(v24.outputLable,v7(""\47\184\100\235\75\129\6\168\115\239\75\137\11\180\62\170\69"",""\226\110\205\16\132\107""),v23,false);local v142,v143=v31();if (v139~=v142) then v28(v24.outputLable,""❌ Enter key error ..."",v20,true,v7(""\171\211\236\220\64\248\198\160\220\79\255\198\242\153\74\238\218\174\151\15"",""\33\139\163\128\185""),Color3.fromRGB(804 -(316 + 403) ,170 + 85 ,701 -446 ));v24.inputkey.Text=v7(""\114\86\16\219\69\24\15\219\78\24\74\144\25"",""\190\55\56\100"");return;end local v144=os.time() * (362 + 638) ;if (v144>v140) then local v151=0;while true do if (v151==(2 -1)) then return;end if (v151==(0 + 0)) then v28(v24.outputLable,v7(""\93\170\37\94\22\251\227\95\189\57\26\83\175\179\70\163\57\31\0\230\179\81\170\40\94\29\230\228\22\164\57\7"",""\147\54\207\92\126\115\131""),v22,false);v24.inputkey.Text=v7(""\40\63\33\120\31\62\3\52\34\61\6\123\20\113\123\51\67"",""\30\109\81\85\29\109"");v151=1 + 0 ;end end end v32(v139,v142,v143);end);"
X4Tv5nB1,Frigate Full Config,DieMetRik,YAML,Wednesday 18th of June 2025 11:36:14 AM CDT,"mqtt:
  host: 192.168.2.120
  user: '{FRIGATE_MQTT_LOGIN}'
  password: '{FRIGATE_MQTT_PASSWORD}'
  client_id: frigate
  stats_interval: 30

auth:
  failed_login_rate_limit: 1/second;5/minute;20/hour
  trusted_proxies:
    - 192.168.2.50

#================================================   go2rtc part   ========================================================
go2rtc:
  rtsp:
    listen: :8554
    username: '{FRIGATE_GO2RTC_RTSP_USERNAME}'
    password: '{FRIGATE_GO2RTC_RTSP_PASSWORD}'

  streams:
#***********************************************   MAIN FLOW   ************************************************************
    entrance_camera_main: 
      ffmpeg:rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.125/cam/realmonitor?channel=1&subtype=1#video=copy#audio=copy#audio=opus

    kitchen_camera_main: 
      ffmpeg:rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.33/cam/realmonitor?channel=1&subtype=0#video=copy#audio=copy#audio=opus
    hall_camera_main: 
      ffmpeg:rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.34/cam/realmonitor?channel=1&subtype=0#video=copy#audio=copy#audio=opus
    livingroom_camera_main: 
      ffmpeg:rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.35/cam/realmonitor?channel=1&subtype=0#video=copy#audio=copy#audio=opus
    bedroom_camera_main: 
      ffmpeg:rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.32/cam/realmonitor?channel=1&subtype=0#video=copy#audio=copy#audio=opus

 #***********************************************   SUB FLOW   ************************************************************
    livingroom_camera_sub: 
      rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.35/cam/realmonitor?channel=1&subtype=1
    bedroom_camera_sub: 
      rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.32/cam/realmonitor?channel=1&subtype=1
    hall_camera_sub: 
      rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.34/cam/realmonitor?channel=1&subtype=1
    kitchen_camera_sub: 
      rtsp://{FRIGATE_CAMERA_LOGIN}:{FRIGATE_CAMERA_PASSWORD}@192.168.1.33/cam/realmonitor?channel=1&subtype=1
    anycubic_camera_main: rtsp://rtsp:{FRIGATE_CAMERA_PASSWORD}@192.168.1.223:554/av_stream/ch0
    anycubic_camera_main_frigate: ffmpeg:anycubic_camera_main#video=copy#audio=opus#audio=aac

 
#**************************************************************************************************************************
  webrtc:
    listen: :8555/tcp
    candidates:
      - XX.XX.XX.XX:8555 # Public IP
#================================================   END go2rtc part   ======================================================

ffmpeg:
  output_args:
    record: preset-record-generic-audio-copy
  input_args: preset-rtsp-restream

ui:
  time_format: 24hour
  timezone: Europe/Moscow
  date_style: medium
  time_style: medium
  strftime_fmt: '%Y-%m-%d %H:%M:%S'

telemetry:
  network_interfaces:
    - eth0@if149
    - isolated@if153
  stats:
    amd_gpu_stats: false
    intel_gpu_stats: true
    network_bandwidth: true
  version_check: true


snapshots:
  enabled: true
  timestamp: false
  bounding_box: true
  clean_copy: true
  retain:
    default: 7
    objects:
      person: 30

record:
  sync_recordings: true
  expire_interval: 720
  enabled: true
  retain:
    days: 7
    mode: all
  alerts:
    retain:
      days: 30
  detections:
    retain:
      days: 30

birdseye:
  enabled: false

audio:
  enabled: true
  max_not_heard: 30
  min_volume: 500
  listen:
    - speech
  filters:
    speech:
      threshold: 0.8

semantic_search:
  enabled: true
  model_size: small
  reindex: false

genai:
  enabled: true
  provider: gemini
  api_key: '{FRIGATE_GEMINI_API}'
  #model: gemini-1.5-flash
  #model: gemini-2.0-flash-exp
  model: gemini-2.5-flash-preview-04-17
  prompt: Analyze the {label} in these images from the {camera} security camera at
    the front door. Focus on the actions and potential intent of the {label}. Reply
    in Russian.
  object_prompts:
    person: Examine the person in these images. What are they doing, and how might
      their actions suggest their purpose (e.g., delivering something, approaching,
      leaving)? If they are carrying or interacting with a package, include details
      about its source or destination. Reply in Russian.

#================== DETECTOR ===================================
detectors:
  ov_1:
    type: openvino
    device: CPU
  ov_2:
    type: openvino
    device: CPU
  ov_3:
    type: openvino
    device: CPU
model:
  width: 300
  height: 300
  input_tensor: nhwc
  input_pixel_format: bgr
  labelmap_path: /openvino-model/coco_91cl_bkgr.txt
  path: /openvino-model/ssdlite_mobilenet_v2.xml
#==============================================================

# ========================== SETTINGS =========================
detect:
  enabled: true
face_recognition:
  enabled: true
  model_size: small
  save_attempts: 1000
lpr:
  enabled: false
classification:
  bird:
    enabled: false

version: 0.16-0
camera_groups:
  Home:
    order: 1
    icon: LuAtom
    cameras:
      - entrance
      - hall
      - kitchen
      - livingroom
      - bedroom
#==============================================================


cameras:
####======================================CAMERA Entrance===========================================
  entrance:
    ffmpeg:
      inputs:
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/entrance_camera_main
          roles:
            - audio
            - record
            - detect

        # - path: rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/entrance_camera_main
        #   roles:
        #     - detect
    mqtt:
      enabled: true
      timestamp: false
      bounding_box: false
      crop: false
      quality: 100
      height: 1080
    genai:
      enabled: true
      use_snapshot: false
    face_recognition:
      enabled: true
      min_area: 9000

    motion:
      threshold: 45
      contour_area: 40
      mqtt_off_delay: 15
      improve_contrast: true
      mask: 0.011,0.931,0.226,0.937,0.226,0.973,0.011,0.978
    objects:
      track:
        - person
      filters:
        person:
          threshold: 0.8            
          min_area: 10000
          max_area: 500000
    live:
      streams:
        entrance_camera_main: entrance_camera_main
    review:
      detections:
        labels: []
      alerts:
        labels:
          - person
    zones:
      entrance_far_zone:
        coordinates: 0.548,0.745,0.453,0.73,0.435,0.779,0.448,0.782,0.422,0.837,0.551,0.857
        loitering_time: 0
        objects: person
      entrance_near_zone:
        coordinates: 
          0.422,0.837,0.414,0.833,0.364,0.947,0.347,0.977,0.325,0.968,0.307,0.999,0.557,0.999,0.551,0.857
        loitering_time: 0
        objects: person
      entrance_stair_zone:
        coordinates: 
          0.596,0.997,0.588,0.924,0.887,0.617,0.972,0.644,0.927,0.821,0.856,0.971,0.822,0.997
        loitering_time: 0
        objects: person
    detect:
      annotation_offset: -1000
####======================================CAMERA BEDROOM===========================================
  bedroom:
    ffmpeg:
      inputs:
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/bedroom_camera_main
          roles:
            - record
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/bedroom_camera_main?audio=aac
          roles:
            - audio
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/bedroom_camera_sub
          roles:
            - detect
    genai:
      enabled: false
    objects:
      track:
        - person
      filters:
        person:
          threshold: 0.8          
          mask: []
    mqtt:
      enabled: false
    motion:
      threshold: 45
      contour_area: 40
      mqtt_off_delay: 30
      mask: 0.585,0.933,0.584,0.988,0.948,0.983,0.944,0.93
      improve_contrast: true
    face_recognition:
      enabled: false
    live:
      streams:
        bedroom_camera_main: bedroom_camera_main
    review:
      detections:
        labels:
          - person
      alerts:
        labels: []
    detect:
      annotation_offset: -500
####======================================CAMERA LIVINGROOM===========================================
  livingroom:
    ffmpeg:
      inputs:
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/livingroom_camera_main
          roles:
            - record
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/livingroom_camera_main?audio=aac
          roles:
            - audio
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/livingroom_camera_sub
          roles:
            - detect
    genai:
      enabled: false
    face_recognition:
      enabled: false
    objects:
      track:
        - person
      filters:
        person:
          threshold: 0.8
          mask: 0.61,1,0.567,0.606,0.42,0.603,0.314,0.72,0.306,1
    mqtt:
      enabled: false
    motion:
      threshold: 45
      contour_area: 40
      mqtt_off_delay: 30
      mask:
        - 0.192,0.335,0.157,0.006,0.397,0.006,0.401,0.183
        - 0.725,0.212,0.71,0.343,0.598,0.265,0.602,0.144
        - 0.99,1,0.992,0.898,0.665,0.743,0.624,0.74,0.577,0.751,0.563,0.731,0.552,0.632,0.524,0.617,0.452,0.633,0.385,0.668,0.355,0.729,0.334,0.782,0.328,1,0.384,1
        - 0.662,0.345,0.688,0.362,0.696,0.337,0.667,0.319
      improve_contrast: true
    live:
      streams:
        livingroom_camera_main: livingroom_camera_main
    review:
      detections:
        labels:
          - person
      alerts:
        labels: []
    detect:
      annotation_offset: -500

####======================================CAMERA HALL===========================================
  hall:
    ffmpeg:
      inputs:
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/hall_camera_main
          roles:
            - record
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/hall_camera_main?audio=aac
          roles:
            - audio
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/hall_camera_sub
          roles:
            - detect
    mqtt:
      enabled: false
    genai:
      enabled: false
    face_recognition:
      enabled: false
    objects:
      track:
        - person
      filters:
        person:
          threshold: 0.8

    motion:
      threshold: 45
      contour_area: 40
      mqtt_off_delay: 30
    # mqtt:
    #   enabled: true
    #   timestamp: false
    #   bounding_box: false
    #   crop: true
    #   quality: 100
    #   height: 500
      improve_contrast: true
      mask: 0.228,0.042,0.227,0.003,0.924,0.001,0.935,0.034
    live:
      streams:
        hall_camera_main: hall_camera_main
    review:
      detections:
        labels:
          - person
      alerts:
        labels: []
    detect:
      annotation_offset: -1000

####======================================CAMERA Kitchen===========================================
  kitchen:
    ffmpeg:
      inputs:
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/kitchen_camera_main
          roles:
            - record
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/kitchen_camera_main?audio=aac
          roles:
            - audio
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/kitchen_camera_sub
          roles:
            - detect
    genai:
      enabled: false
    objects:
      track:
        - person
      filters:
        person:
          threshold: 0.8
          mask:
            - 0.469,0.133,0.473,0,0.262,0,0.292,0.235
            - 0.175,0.423,0.294,0.283,0.278,0.144,0.138,0.292
    mqtt:
      enabled: false
    face_recognition:
      enabled: false
    # mqtt:
    #   enabled: true
    #   timestamp: false
    #   bounding_box: false
    #   crop: true
    #   quality: 100
    #   height: 500
    motion:
      threshold: 45
      contour_area: 35
      mqtt_off_delay: 30
      mask:
        - 0.511,0.163,0.517,0,0.249,0,0.283,0.302
        - 0.175,0.423,0.294,0.283,0.278,0.144,0.138,0.292
        - 0.004,0.88,0.367,0.888,0.368,0.934,0.213,0.938,0.181,0.94,0.112,0.935,0,0.935
      improve_contrast: true
    live:
      streams:
        kitchen_camera_main: kitchen_camera_main
    review:
      detections:
        labels:
          - person
      alerts:
        labels: []
    detect:
      annotation_offset: -1500

####======================================CAMERA ANYCUBIC===========================================
  anycubic:
    ffmpeg:
      inputs:
        - path: 
            rtsp://{FRIGATE_GO2RTC_RTSP_USERNAME}:{FRIGATE_GO2RTC_RTSP_PASSWORD}@127.0.0.1:8554/anycubic_camera_main_frigate
          roles:
            - record
    motion:
      threshold: 45
      contour_area: 40
      mqtt_off_delay: 30
      improve_contrast: true
    genai:
      enabled: false
    mqtt:
      enabled: false
    detect:
      enabled: false
    snapshots:
      enabled: false
    audio:
      enabled: false
    face_recognition:
      enabled: false
    live:
      streams:
        anycubic_camera_main_frigate: anycubic_camera_main_frigate
"
pvWP0uqw,ods_svg.php,eqeqwan21,PHP,Wednesday 18th of June 2025 10:58:29 AM CDT,"<?php

class ods_svg {
	private $anime1 = '<animate attributeName=""visibility"" from=""visible"" to=""hidden"" dur=""1s"" repeatCount=""indefinite"" />';
	private $anime2 = '<animate attributeName=""visibility"" from=""visible"" to=""hidden"" dur=""2s"" repeatCount=""indefinite"" />';
   private $animeall = '<animate attributeName=""visibility"" from=""visible"" to=""hidden"" dur=""0.5s"" repeatCount=""indefinite"" />';
   private $animeous = '<animate attributeName=""visibility"" values=""visible;hidden;visible;hidden;visible;hidden;visible;visible;visible;visible;visible"" dur=""0.8s"" repeatCount=""indefinite"" />';

	public function run()
	{
		$script = substr(stristr(strtok($_SERVER['REQUEST_URI'],'?'), 'images/'),7);
		$script = str_replace(['/','\\',':','.'],'_',$script);

		$method = strtolower($_SERVER['REQUEST_METHOD'].'_'.$script);

		if( method_exists($this, $method) ) {
			$this->$method();
		}
		else {
			header($_SERVER['SERVER_PROTOCOL'] . ' 404 Not Found');
			echo('Not Found');
		}
	}

	private function get_galbox_svg() {

		$header = !isset($_GET['noxml']);

		$box = new ods_box($_GET['cnf']);
		if($header)
			header ('Content-Type: image/svg+xml');


		header_remove(""Pragma"");
		header_remove(""Expires"");

		header(""Cache-Control: max-age=86400"");

		echo $box->run($header);
	}


private function get_lamp_svg() {
$anm='';
$anm2='';
$foncolor = ""rgb(0,176,80)"";
$incolor=""white"";

if(isset($_GET['auto']))
	$foncolor = ""rgb(0,176,80)"";
if(isset($_GET['manual']))
	$foncolor = ""rgb(0,112,192)"";
if(isset($_GET['unmanaged']))
	$foncolor = ""rgb(166,166,166)"";

$outcolor = $foncolor;
if(isset($_GET['nopower']))
	$outcolor = ""rgb(255,0,0)"";
if(isset($_GET['on']))
	$incolor=""white"";
if(isset($_GET['off']))
	$incolor=""black"";
$circlecolor=$incolor;
if(isset($_GET['trouble']))
	$circlecolor=""red"";
$opa=1;
if(isset($_GET['nocon']))
	$opa=""0.5"";

if (isset($_GET['shape'])) {
	$foncolor=""black"";
	$outcolor=""black"";
	$circklecolor=""white"";
	$incolor=""white"";
}

if(isset($_GET['timeallert']))
	$anm=$this->anime1;
if(isset($_GET['controlallert']))
	$anm=$this->anime2;
if(isset($_GET['timeallert']) && isset($_GET['controlallert']))
   $anm=$this->animeall;

if(isset($_GET['open']))
	$anm=$this->animeall;

if(isset($_GET['ous']))
	$anm2=$this->animeous;

$data = <<<EOT
<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>
<svg
   xmlns:dc=""http://purl.org/dc/elements/1.1/""
   xmlns:cc=""http://creativecommons.org/ns#""
   xmlns:rdf=""http://www.w3.org/1999/02/22-rdf-syntax-ns#""
   xmlns:svg=""http://www.w3.org/2000/svg""
   xmlns=""http://www.w3.org/2000/svg""
   xmlns:sodipodi=""http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd""
   xmlns:inkscape=""http://www.inkscape.org/namespaces/inkscape""
   version=""1.1""
   id=""Capa_1""
   x=""0px""
   y=""0px""
   width=""333.668""
   height=""491.582""
   viewBox=""0 0 333.668 491.582""
   xml:space=""preserve""
   sodipodi:docname=""location.svg""
   inkscape:version=""0.92.1 r15371""><metadata
     id=""metadata4620""><rdf:RDF><cc:Work
         rdf:about=""""><dc:format>image/svg+xml</dc:format><dc:type
           rdf:resource=""http://purl.org/dc/dcmitype/StillImage"" /></cc:Work></rdf:RDF></metadata><defs
     id=""defs4618"" /><sodipodi:namedview
     pagecolor=""#ffffff""
     bordercolor=""#666666""
     borderopacity=""1""
     objecttolerance=""10""
     gridtolerance=""10""
     guidetolerance=""10""
     inkscape:pageopacity=""0""
     inkscape:pageshadow=""2""
     inkscape:window-width=""1920""
     inkscape:window-height=""1017""
     id=""namedview4616""
     showgrid=""false""
     inkscape:zoom=""1.5480632""
     inkscape:cx=""166.834""
     inkscape:cy=""245.791""
     inkscape:window-x=""1272""
     inkscape:window-y=""-8""
     inkscape:window-maximized=""1""
     inkscape:current-layer=""Capa_1"" />
	 <g>
    $anm
    $anm2
	 <path style=""fill:$outcolor;fill-opacity:$opa;""
     d=""M 166.834,0 C 74.842,0 0,74.841 0,166.833 0,203.8 21.764,260.02 68.493,343.759 c 31.887,57.138 63.627,105.4 64.966,107.433 l 22.941,34.773 c 2.313,3.507 6.232,5.617 10.434,5.617 4.202,0 8.121,-2.11 10.434,-5.617 l 22.94,-34.771 c 1.326,-2.01 32.835,-49.855 64.967,-107.435 46.729,-83.735 68.493,-139.955 68.493,-176.926 C 333.668,74.841 258.826,0 166.834,0 Z m 76.511,331.576 C 211.66,388.351 180.649,435.445 179.342,437.424 L 166.834,456.383 154.33,437.429 C 153.016,435.434 121.767,387.918 90.323,331.576 46.978,253.9 25,198.472 25,166.833 25,88.626 88.626,25 166.834,25 c 78.208,0 141.834,63.626 141.834,141.833 0,31.643 -21.978,87.069 -65.323,164.743 z""
     id=""out""
     inkscape:connector-curvature=""0"" /><path 
     d=""m 166.51102,70.061158 c -52.60786,0 -95.40686,42.800032 -95.40686,95.406862 0,52.60682 42.799,95.40685 95.40686,95.40685 52.60786,0 95.40685,-42.80003 95.40685,-95.40685 0,-52.60683 -42.79899,-95.406862 -95.40685,-95.406862 z m 0,165.028072 c -38.38966,0 -69.62123,-31.23156 -69.62123,-69.62121 0,-38.38966 31.23157,-69.621225 69.62123,-69.621225 38.39069,0 69.62121,31.231565 69.62121,69.621225 0,38.38965 -31.23052,69.62121 -69.62121,69.62121 z""
     id=""path4579""
     inkscape:connector-curvature=""0""
     style=""stroke-width:1.0314256; fill:$circlecolor;fill-opacity:$opa"" /><g
     id=""g4585""
     transform=""translate(-78.957)"" /><g
     id=""g4587""
     transform=""translate(-78.957)"" /><g
     id=""g4589""
     transform=""translate(-78.957)"" /><g
     id=""g4591""
     transform=""translate(-78.957)"" /><g
     id=""g4593""
     transform=""translate(-78.957)"" /><g
     id=""g4595""
     transform=""translate(-78.957)"" /><g
     id=""g4597""
     transform=""translate(-78.957)"" /><g
     id=""g4599""
     transform=""translate(-78.957)"" /><g
     id=""g4601""
     transform=""translate(-78.957)"" /><g
     id=""g4603""
     transform=""translate(-78.957)"" /><g
     id=""g4605""
     transform=""translate(-78.957)"" /><g
     id=""g4607""
     transform=""translate(-78.957)"" /><g
     id=""g4609""
     transform=""translate(-78.957)"" /><g
     id=""g4611""
     transform=""translate(-78.957)"" /><g
     id=""g4613""
     transform=""translate(-78.957)"" /><path
     style=""opacity:1;fill:$incolor;fill-opacity:$opa;fill-rule:evenodd;stroke:none;stroke-width:1.39170384;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1""
     d=""m 139.55478,232.35515 c -16.58989,-6.60707 -28.58213,-18.03317 -37.03437,-35.28599 -6.38482,-13.03281 -7.31297,-17.131 -7.19708,-31.77843 0.10703,-13.52786 1.31773,-19.29209 6.19162,-29.47857 20.24225,-42.306575 76.0645,-53.865996 110.39606,-22.86032 16.49621,14.89816 23.55823,30.9106 23.55823,53.41604 0,15.0389 -0.98737,19.91288 -6.1896,30.55391 -6.8541,14.01987 -18.68856,25.94228 -33.23311,33.48003 -13.78082,7.14194 -41.09228,8.08629 -56.49175,1.95333 z""
     id=""in""
     inkscape:connector-curvature=""0"" /><path
     style=""opacity:1;fill:$foncolor;fill-opacity:$opa;fill-rule:evenodd;stroke:none;stroke-width:1.32080853;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1""
     d=""M 155.30991,441.46651 C 87.7426,335.06388 48.24689,260.59788 30.49318,206.13462 17.902965,167.51149 22.33961,127.83742 43.19548,92.545955 47.13571,85.878452 57.60351,73.120056 66.45725,64.193964 79.6908,50.852276 86.10715,46.269966 102.51958,38.439622 c 25.34418,-12.091664 38.10009,-15.050718 64.51217,-14.965211 39.60128,0.128207 71.08382,13.371175 99.77161,41.968433 33.76712,33.66056 48.87939,78.982346 40.21435,120.602906 -9.96466,47.86278 -55.10745,138.24455 -118.4759,237.20424 -10.9865,17.15712 -20.90722,31.50438 -22.04607,31.8828 -1.13885,0.37843 -6.17246,-5.77141 -11.18583,-13.66628 z m 37.97331,-186.45037 c 7.0625,-2.19116 16.94549,-6.38177 21.96218,-9.31247 11.50031,-6.71836 29.4853,-25.54903 35.35406,-37.01644 C 277.86863,155.40391 249.9923,90.544348 192.68445,73.937085 172.78736,68.171099 145.53005,70.166632 127.17736,78.732914 64.14447,108.15411 51.97082,190.13931 103.86658,235.72282 c 5.57279,4.89497 12.99612,10.39475 16.49629,12.22174 21.51321,11.22941 50.46835,14.03738 72.92035,7.07158 z""
     id=""fon""
     inkscape:connector-curvature=""0"" />
	 </g>
	 <circle cx=""50"" cy=""50"" r=""5"" fill=""green"" />
        <circle cx=""70"" cy=""50"" r=""5"" fill=""green"" />
</svg>
EOT;


		$this->output($data);
}

private function get_box_svg() {
$anm='';
$anm2='';
$foncolor = ""rgb(0,176,80)"";
$incolor=""white"";
    $depth   = 33;
    $bodyX   = 42.333332;
    $bodyW   = 74.083336;
    $bodyH   = 89.958336;

    $canvasW = $bodyW + $depth*2 + 5;
    $canvasH = 100.79864;

    if(isset($_GET['auto']))
	$foncolor = ""rgb(0,176,80)"";
if(isset($_GET['manual']))
	$foncolor = ""rgb(0,112,192)"";
if(isset($_GET['unmanaged']))
	$foncolor = ""rgb(166,166,166)"";

$outcolor = $foncolor;
if(isset($_GET['nopower']))
	$outcolor = ""rgb(255,0,0)"";
if(isset($_GET['on']))
	$incolor=""white"";
if(isset($_GET['off']))
	$incolor=""black"";
$circlecolor=$foncolor;
if(isset($_GET['trouble']))
	$circlecolor=""red"";
$opa=1;
if(isset($_GET['nocon']))
	$opa=""0.5"";


if(isset($_GET['timeallert']))
	$anm=$this->anime1;
if(isset($_GET['controlallert']))
	$anm=$this->anime2;
if(isset($_GET['timeallert']) && isset($_GET['controlallert']))
	$anm=$this->animeall;

if(isset($_GET['open']))
	$anm=$this->animeall;

if(isset($_GET['ous']))
	$anm2=$this->animeous;


if (isset($_GET['shape'])) {
	$foncolor=""black"";
	$outcolor=""black"";
	$circlecolor=""black"";
	$incolor=""white"";
}
    $circlesCount = isset($_GET['multiple']) && $_GET['multiple'] == 'true' ? 2 : 1;

    $centerX = 78.845825;
    $circle1 = '<circle
       style=""fill:' . $incolor . ';fill-opacity:' . $opa . ';stroke:none;stroke-width:0.26458332""
       id=""dyra""
       cx=""' . $centerX . '""
       cy=""136.13333""
       r=""18.520834"" />';

    $circle2 = '';
    if ($circlesCount === 2) {
        $spacing = 30;
        $circle1 = '<circle
       style=""fill:' . $incolor . ';fill-opacity:' . $opa . ';stroke:none;stroke-width:0.26458332""
       id=""dyra""
       cx=""' . ($centerX - $spacing / 2) . '""
       cy=""136.13333""
       r=""14"" />';

        $circle2 = '<circle
       style=""fill:' . $incolor . ';fill-opacity:' . $opa . ';stroke:none;stroke-width:0.26458332""
       id=""dyra2""
       cx=""' . ($centerX + $spacing / 2) . '""
       cy=""136.13333""
       r=""14"" />';
    }

    $doorSvg = '';
    if (isset($_GET['open']) && $_GET['open']=='1') {

        $bodyY = 106.5;
        $slant = 15;
        $doorClr = '#002b5c';
        $bodyR = $bodyX + $bodyW;
        $leftX  = $bodyX  - $depth;
        $rightX = $bodyR + $depth;

        $DL_p1 = $bodyX  .','.$bodyY;
        $DL_p2 = $bodyX  .','.($bodyY + $bodyH - $slant);
        $DL_p3 = $leftX  .','.($bodyY + $bodyH );
        $DL_p4 = $leftX  .','.($bodyY + $slant);

        $DR_p1 = $bodyR .','.$bodyY;
        $DR_p2 = $bodyR .','.($bodyY + $bodyH - $slant);
        $DR_p3 = $rightX.','.($bodyY + $bodyH );
        $DR_p4 = $rightX.','.($bodyY + $slant);

        $doorSvg = '
<polygon id=""doorLeft""  points=""'.$DL_p1.' '.$DL_p2.' '.$DL_p3.' '.$DL_p4.'"" style=""fill:'.$doorClr.';fill-opacity:'.$opa.';stroke:none""/>
<polygon id=""doorRight"" points=""'.$DR_p1.' '.$DR_p2.' '.$DR_p3.' '.$DR_p4.'"" style=""fill:'.$doorClr.';fill-opacity:'.$opa.';stroke:none""/>';
    }

$data = <<<EOT
<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>

<svg
   xmlns:dc=""http://purl.org/dc/elements/1.1/""
   xmlns:cc=""http://creativecommons.org/ns#""
   xmlns:rdf=""http://www.w3.org/1999/02/22-rdf-syntax-ns#""
   xmlns:svg=""http://www.w3.org/2000/svg""
   xmlns=""http://www.w3.org/2000/svg""
   xmlns:sodipodi=""http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd""
   xmlns:inkscape=""http://www.inkscape.org/namespaces/inkscape""
   width =""{$canvasW}mm""
      height=""{$canvasH}mm""
      viewBox=""-{$depth} 0 {$canvasW} {$canvasH}""
   version=""1.1""
   id=""svg8""
   inkscape:version=""0.92.1 r15371""
   sodipodi:docname=""box.svg"">
  <defs
     id=""defs2"" />
  <sodipodi:namedview
     id=""base""
     pagecolor=""#ffffff""
     bordercolor=""#666666""
     borderopacity=""1.0""
     inkscape:pageopacity=""0.0""
     inkscape:pageshadow=""2""
     inkscape:zoom=""0.5""
     inkscape:cx=""257.32181""
     inkscape:cy=""180.5""
     inkscape:document-units=""mm""
     inkscape:current-layer=""layer1""
     showgrid=""false""
     inkscape:window-width=""1920""
     inkscape:window-height=""1017""
     inkscape:window-x=""1272""
     inkscape:window-y=""-8""
     inkscape:window-maximized=""1"">
    <inkscape:grid
       type=""xygrid""
       id=""grid4493""
       originx=""-36.916937""
       originy=""-100.40938"" />
  </sodipodi:namedview>
  <metadata
     id=""metadata5"">
    <rdf:RDF>
      <cc:Work
         rdf:about="""">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource=""http://purl.org/dc/dcmitype/StillImage"" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g	
     inkscape:label=""Layer 1""
     inkscape:groupmode=""layer""
     id=""layer1""
     transform=""translate(-36.916938,-95.791984)"">
    $anm
    $anm2
    <rect
       style=""fill:$foncolor;fill-opacity:$opa;stroke:#ffffff;stroke-width:0.24052194""
       id=""rectbox""
       width=""74.083336""
       height=""89.958336""
       x=""42.333332""
       y=""106.5"" />
    <rect
       style=""fill:$outcolor;fill-opacity:$opa;stroke:#ffffff;stroke-width:0.24945155""
       id=""rectup""
       width=""84.666664""
       height=""10.583333""
       x=""37.041664""
       y=""95.91671""
       inkscape:label=""#rrectup"" />
    <rect
       style=""fill:$circlecolor;fill-opacity:$opa;stroke:#ffffff;stroke-width:0.26458332""
       id=""rectdown""
       width=""74.083336""
       height=""26.458332""
       x=""42.333328""
       y=""170"" />
    $circle1
    $circle2
    $doorSvg
  </g>
</svg>
EOT;

		$this->output($data);
}


	private function putsvg($data, $addxml=false) {
	$header = ""<svg>"";
$header = <<<EOT
<svg
   xmlns:dc=""http://purl.org/dc/elements/1.1/""
   xmlns:cc=""http://creativecommons.org/ns#""
   xmlns:rdf=""http://www.w3.org/1999/02/22-rdf-syntax-ns#""
   xmlns:svg=""http://www.w3.org/2000/svg""
   xmlns=""http://www.w3.org/2000/svg""

   viewBox=""0 0 1000 600""
   version=""1.1""
   id=""svg8""
   >

EOT;
	$tail = '</svg>';
	if($addxml) {
		$header = '<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>'.""\n\n$header"";
	}
	return $header.""\n"".$data.""\n"".$tail;
	}

	private function get_test_svg() {
		//$data = $this->draw_fuze_group();
		$data = $this->draw_box();
		$this->output( $this->putsvg($data, true) );
	}

	private function output($data)	{
		header_remove(""Pragma"");
		header_remove(""Expires"");

		//header(""Cache-Control: max-age=86400"");
		header('Content-type: image/svg+xml');
		header('Content-Length: '.strlen($data));
		echo $data;
	}

	private function err_out()	{
		header($_SERVER['SERVER_PROTOCOL'] . ' 404 Not Found');
		echo $this->num . ' Not Found ';
	}
}"
ue6U4WW9,ods_api.php,eqeqwan21,PHP,Wednesday 18th of June 2025 10:57:31 AM CDT,"private function get_states() {
	$whr = [];
	$arg=[];
	$mapfilter = $this->mapfilter(""d"");
	$lines = '';
	
	foreach(['Town_id','Location','District','Type','Sip','Ip','Smart','Devices_id','Name', 'Station', 'DimProfile_id'] as $gv) {
		if(isset($_GET[$gv])) {
			$alias = '';
			if($gv=='Devices_id')
				$alias = 'StatusReg.';
			if($gv=='DimProfile_id' || $gv=='Type')
				$alias = 'd.';
			$whr[] = ""($alias`$gv`=?)"";
			$arg[] = $_GET[$gv];
		}
	}

	if(isset($_GET['Mode'])) {
		$whr[] = ""(StatusReg.`Mode`in (?))"";
		$arg[] = $_GET['Mode'];
	}

	if(isset($_GET['box'])) {
		$whr[] = ""(`Lines`.Devices_id =?)"";
		$arg[] = $_GET['box'];
		$lines = 'left join `Lines` on `Lines`.id = d.Lines_id';
	}

	if(isset($_GET['Trouble'])) {
		$whr[] = '(`Trouble`' . ($_GET['Trouble']>0?'>':'=') . '0)';
	}

	if(isset($_GET['State'])) {
		$whr[] = '(`State`' . ($_GET['State']>0?'>':'=') . '0)';
	}
	
	if(isset($_GET['Power'])) {
		$whr[] = '('.($_GET['Power']>0?'`Power`>=7 or (d.`Type`=2 and `Power`>0)':'`Power`=0 or (d.`Type`=1 and `Power`<7)').')';
	}


	if(isset($_GET['mapfilter']))
		$whr[]=$mapfilter;
	
	$where = join($whr, "" AND "");
	
	if(count($arg)==0)
		$arg=null;
	
	if($where !== """")
		$where = 'AND '.$where;
	
	$order = '';
	if(isset($_GET['order'])) {	
		$order = ""order by d.`type`, LPAD(d.CustomNum,10,'0')"";
	}
//V11_Phase
//Anton_30day	
//	StatusReg.Timestamp >= date_sub(now(), INTERVAL 30 DAY)
//	AND

//V11_Phase_30 day_++Anton
	$sql = 
	""
	SELECT d.id, d.Name, d.CustomNum, d.Location, d.District, d.Type, d.lat, d.lng, d.Smart, d.sn,
	StatusReg.id as StatusReg_id, Power, Trouble, Sip, Ip, StatusReg.Mode, State, Timeallert, Controller, Door, Ous, Voltage,
		json_extract(StatusReg.Phase,\""$.v\"") as PhaseV,
		StatusReg.Timestamp, StatusReg.Devices_id, IncomingLog_id, StatusReg.DimProfile_id, OutgoingLog_id,
		UNIX_TIMESTAMP(StatusReg.Timestamp) as unixtime,
		 (
          SELECT COUNT(DISTINCT `Switch`)
          FROM `Lines`
          WHERE `Devices_id` = d.id
            AND `Switch` > 0
        ) AS num_contactors
	from StatusReg 
	inner join Devices as d	on Devices_id=d.id
	$lines
	inner join (select max(id) as id from StatusReg group by Devices_id) as ssr on ssr.id = StatusReg.id
	where
	(d.OffTime >= curdate() OR isnull(d.OffTime)) and not isnull(d.OnTime)
	$where
	$order
	"";

	//echo $sql;
	$this->run_query($sql, $arg, ['Devices', 'IncomingLog', 'OutgoingLog', 'StatusReg'],false,'id');
 }"
myLGucFh,RequestException: error with request,basedcount_bot,Python,Wednesday 18th of June 2025 10:45:48 AM CDT,"Traceback (most recent call last):
  File ""/home/gmktec-server/Bots/basedcount_bot/basedcount_bot.py"", line 46, in wrapper
    await func(reddit_instance, mongo_client)
  File ""/home/gmktec-server/Bots/basedcount_bot/basedcount_bot.py"", line 263, in read_comments
    async for comment in pcm_subreddit.stream.comments(skip_existing=True):  # Comment
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/util.py"", line 172, in stream_generator
    [result async for result in function(limit=limit, **function_kwargs)]
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/util.py"", line 172, in <listcomp>
    [result async for result in function(limit=limit, **function_kwargs)]
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 37, in __anext__
    await self._next_batch()
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 90, in _next_batch
    self._listing = await self._reddit.get(self.url, params=self.params)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 813, in get
    return await self._objectify_request(method=""GET"", params=params, path=path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 570, in _objectify_request
    await self.request(
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 54, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 1061, in request
    return await self._core.request(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 383, in request
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 286, in _request_with_retries
    response, saved_exception = await self._make_request(
                                ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 192, in _make_request
    response = await self._rate_limiter.call(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/rate_limit.py"", line 51, in call
    response = await request_function(*args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/home/gmktec-server/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/requestor.py"", line 80, in request
    raise RequestException(exc, args, kwargs) from None
asyncprawcore.exceptions.RequestException: error with request 
"
n21jxrfs,Limes neper,ikizid,Python,Wednesday 18th of June 2025 10:43:09 AM CDT,"def potence(luku, pot):
    i = tulos = 1
    while True:
        tulos *= luku
        i += 1
        if i > pot:
            break
    return tulos

if __name__ == ""__main__"":    
    n = 10000
    lauseke = 1 + 1 / n
    lauseke = potence(lauseke, n)
    mjono = bytearray(200)
    mjono = str(lauseke)
    print(mjono)"
S2zgThK7,tiles.js,eqeqwan21,JavaScript,Wednesday 18th of June 2025 10:40:36 AM CDT,"""use strict"";

var ddata = null;
let cmddata = null; // devices in control panel
let lg = null;
let seldev=[];
let borderDevice=null;
let mks = null;
let goview = false;
let gotown = false;
let godevice = false;
let gostreet = false;
let selection = null;
let freeze = false;

const storagekey = ""tiles""+window.location.pathname; 

$(async function() {
	
	
	if( get['device']!==undefined ) {
		godevice = get['device'];
		borderDevice = get['device'];
	}

	selection = new SelectionArea({

		// Class for the selection-area
		class: 'selection',
		
		// All elements in this container can be selected
		selectables: ['.box-wrap > div.dropdown'],

		// The container is also the boundary in this case
		boundaries: ['#fsdiv'],
	}).on('beforestart', ({store, event}) => {
		if (!event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey)
			return false;
	}).on('start', ({store, event}) => {
		freeze = true;
		// Remove class if the user isn't pressing the control key or ⌘ key
		if (!event.ctrlKey && !event.metaKey) {

			// Unselect all elements
			for (const el of store.stored) {
				el.classList.remove('selected');
			}

			// Clear previous selection
			selection.clearSelection();
		}
	}).on('move', ({store: {changed: {added, removed}}}) => {
		// Add a custom class to the elements that where selected.
		for (const el of added) {
			el.classList.add('selected');
    }

    // Remove the class from elements that where removed
    // since the last selection
    for (const el of removed) {
        el.classList.remove('selected');
    }
	}).on('stop', () => {
		selection.keepSelection();
		let ssd = selection.getSelection();
		seldev = ssd.map( e => e.id.substr(2) );
		freeze = false;
		selection_fire(true);
	});
});

function tiles() {
	let html="""";
	let i = 0, type = 0;
	for(let dev of ddata.rows) {
		i++;
		let icon = devicon(dev);
		let cls = dev.Type == 1 ? 'icon-box' : 'icon-lamp';
		let div = `
		<div class=""dropdown ${i>500?'cva':''}"" id=""d_${dev.id}"">
			<div data-toggle=""dropdown"" data-boundary=""viewport"" id=""btn_${dev.id}"">
				<img loading:""eager"" src=""${icon}"" class=""${cls}""><p>${dev.CustomNum||''}</p>
			</div>
			
			<div class=""dropdown-menu"" aria-labelledby=""btn_${dev.id}"" ></div>		
		</div>
		`;
		
		if(type == 1 && dev.Type == 2)
			html += '<div class=""break""></div>';

		html +=div;
		type = dev.Type;
	}
		
	$('.boxes div.dropdown').tooltip('hide');
	selection.clearSelection();
	//$(""#tiles"").html(html);
	document.getElementById(""tiles"").innerHTML = html;
	
	for(let sd of seldev) {
		if(ddata.map[sd] !== undefined)
			selection.select(""#d_""+sd);
	}
	selection.keepSelection();

	//$('.boxes div.dropdown').dropdown();
	
	$('.boxes div.dropdown').tooltip({
		html: true,
		delay: { ""show"": 500, ""hide"": 0 },
		title: function() {
			let ind = ddata.map[this.id.substr(2)];
			let dev = ddata.rows[ind];
			
			return `${dev.sn?HtmlEncode(dev.sn)+""</br>"":""""}${HtmlEncode(dev.Name)}<br>${HtmlEncode(dev.Location)}`
		}
	});
	
	$('.boxes div.dropdown-menu').parent().on('show.bs.dropdown', function () {
		$(this).css(""content-visibility"", ""visible"");
		let mnu = $(this).find("".dropdown-menu"")[0];
		let id = ($(mnu).attr(""aria-labelledby"")).substr(4);
		$(mnu).html(deviceContextMenu(id));	
	});
}

async function renew() {
	
	let nextt = 500;	

	let isnew = false;
	if(!freeze)
		isnew = await dataload();
	if(isnew) {
		if(godevice) {
			goDevice(godevice);
		}
		tiles();
		goview = false;
		gotown = false;
		gostreet = false;
		godevice = false;
		nextt = 1500;
	}
	if(seldev.length > 0)
		nextt = 3000;

	setTimeout(renew, nextt);
}

function goDevice(id, border=false, fire=false) {
	let el = document.getElementById(""d_""+id);
	window.scrollTo(0,0);
	let topPos = el.offsetTop;
	let tof = topPos -$("".sidebar-item"").height() - $("".sidebar-item"").offset().top - 20;
	
	window.scrollTo(0, tof);
	if(border) {
		$("".boxes div.dropdown"").removeClass(""fborder"");
		$(el).addClass(""fborder"");
	}
	
	if(fire) {
		$(el).addClass(""shadowpulse"");
		$(el).on('animationend',()=>$(el).removeClass(""shadowpulse""));	
	}
	
}


let loadfail=0;
async function dataload() {
	let url = environment.base_url+""/""+""?do=api&fn=states&order"";
	let flt=$.param(makeflt());
	if(flt!=="""")
		url+=""&""+flt;
	let result, ret=false;
    try {
        result = await $.ajax({
            url: url,
            type: 'GET',
			dataType: ""json"",
        });
    } catch (error) {
        console.log(""Error: "",error);
		if(error.status == 401) //unautorized
			window.location=environment.base_url+""/""+""?do=login&b=""+encodeURIComponent(window.location);        

		loadfail++;
		if(ddata === null)
			$(""#content"").html(""<h2>Data was not loaded</h2>"");
		else if(loadfail>1) {
			hulla.send(i18next.t(""No connection to the server""));
			loadfail = 0;
		}
		return ret;
    }
	loadfail=0;
	if(ddata==null || ddata.timestamp != result.timestamp) {
		ddata = result;
		ret = true;
	}
	
	return ret;
}


function cmdclear() {
	$(""#devlist"").html("""");
	seldev = [];
	cmddata = null;
	$("".boxes div.dropdown"").removeClass(""selected"");
	selection.clearSelection();
	cmdpanel();
}

let doMgtStatus = true;
function cmdpanel() {
	if(seldev.length == 0 && !editmode) 
		$(""#allfilter"").removeClass(""d-none"");
	else 
		$(""#allfilter"").addClass(""d-none"");

	
	if(seldev.length == 0) {
		$(""#mapcmd"").addClass(""d-none"");
		$(""#formedit"").removeClass(""d-none"");
		doMgtStatus = false;
	}
	else {
		$(""#mapcmd"").removeClass(""d-none"");
		$(""#formedit"").addClass(""d-none"");
		doMgtStatus = true;
		mgtStatus(true);
	}
}

async function mgtStatus(force=false) {
	if(seldev.length == 0)
		return;
	
	if(mgtStatus.cnt === undefined)
		mgtStatus.cnt = 0;
	
	let headers = {};
	if(mgtStatus.cnt++ > 20 || force) {
		mgtStatus.cnt = 0;
		headers = {""Cache-Control"": ""No-Cache""};
	}
	let url = environment.base_url+""/""+""?do=api&fn=mgtstates&devices=""+seldev.join("","");
	let result;
    try {
        result = await $.ajax({
            url: url,
            type: 'GET',
			dataType: ""json"",
			headers: headers,
        });
    } catch (error) {
        console.log(""Error: "",error);
    }
	let nextt = 550;
	if(cmddata == null || cmddata.last.timestamp !== result.last.timestamp) {
		cmddata = result;
		nextt = 1000;
		$("".devctrl"").removeClass(""queued"");
		for(let id of seldev) {			
			let textcolor = ""black"", title="""";
			
			let queue = cmddata.queue.rows.find(x=>x.Devices_id == id);
			if(queue) {
				$(`#ctrl_${id}`).addClass(""queued"");
				title += i18next.t(""Queued up"") + "": "" + i18next.t(queue.Name);
			}
			
			let last = cmddata.last.rows.find(x=>x.Devices_id == id);
			if(last) {
				textcolor = last.success?""green"":""red"";
				let date = new Date(last.cmdtime * 1000);
				if(title)
					title += ""<br>"";
				
				title += moment(date).format(""LT"");
				title += "" "" + i18next.t(last.Name) + "" - "" + i18next.t(last.success?""Success"":""Fail"");
				
			}
			$(`#ctrl_${id}`).css('color', textcolor);
			$(`#ctrl_${id}`).attr('data-original-title', title);
			//$(`#ctrl_${id}`).attr('title', title).tooltip('update');
			
		}
		$("".devctrl"").tooltip({container:'#mapcmd'});
	}
	if(doMgtStatus)
		setTimeout(mgtStatus, nextt);
}


function findDevice() {
	let ss = $(""#findStr"").val().trim().toUpperCase();
	
	if(ss) {
		let fr = ddata.rows.find(x => (x.CustomNum||"""").toUpperCase() == ss || (x.sn||"""").toUpperCase() == ss);
		fr = fr || ddata.rows.find(x => (x.Name||"""").toUpperCase().includes(ss));
		
		if(fr) {
			$("".cli"").removeClass(""clisel"");
			goDevice(fr.id, true, true);
			borderDevice = fr.id;
		}
	}

	return false;
}"
etADTz2B,tiles.css,eqeqwan21,CSS,Wednesday 18th of June 2025 10:38:23 AM CDT,".icon-box{
    transform: scale(1.5);
}"
KcgcAEMy,mgtt.js,eqeqwan21,JavaScript,Wednesday 18th of June 2025 10:36:11 AM CDT,"if (dev.num_contactors >=2) {
		rnd.push('multiple=true');
	}
if (dev.Door === 0) rnd.push(""open=1"");"
81jxdDJg,debug,Rekunzx,C++,Wednesday 18th of June 2025 10:34:30 AM CDT,"// dear imgui, v1.91.9 WIP
// (drawing and font code)

/*

Index of this file:

// [SECTION] STB libraries implementation
// [SECTION] Style functions
// [SECTION] ImDrawList
// [SECTION] ImTriangulator, ImDrawList concave polygon fill
// [SECTION] ImDrawListSplitter
// [SECTION] ImDrawData
// [SECTION] Helpers ShadeVertsXXX functions
// [SECTION] ImFontConfig
// [SECTION] ImFontAtlas
// [SECTION] ImFontAtlas: glyph ranges helpers
// [SECTION] ImFontGlyphRangesBuilder
// [SECTION] ImFont
// [SECTION] ImGui Internal Render Helpers
// [SECTION] Decompression code
// [SECTION] Default font data (ProggyClean.ttf)

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif

#include ""imgui.h""
#ifndef IMGUI_DISABLE
#include ""imgui_internal.h""
#ifdef IMGUI_ENABLE_FREETYPE
#include ""misc/freetype/imgui_freetype.h""
#endif

#include <stdio.h>      // vsnprintf, sscanf, printf

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning(""-Wunknown-warning-option"")
#pragma clang diagnostic ignored ""-Wunknown-warning-option""         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored ""-Wunknown-pragmas""                // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored ""-Wold-style-cast""                 // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored ""-Wfloat-equal""                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.
#pragma clang diagnostic ignored ""-Wglobal-constructors""            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored ""-Wsign-conversion""                // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored ""-Wzero-as-null-pointer-constant""  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored ""-Wcomma""                          // warning: possible misuse of comma operator here
#pragma clang diagnostic ignored ""-Wreserved-id-macro""              // warning: macro name is a reserved identifier
#pragma clang diagnostic ignored ""-Wdouble-promotion""               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored ""-Wimplicit-int-float-conversion""  // warning: implicit conversion from 'xxx' to 'float' may lose precision
#pragma clang diagnostic ignored ""-Wreserved-identifier""            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter
#pragma clang diagnostic ignored ""-Wunsafe-buffer-usage""            // warning: 'xxx' is an unsafe pointer used for buffer access
#pragma clang diagnostic ignored ""-Wnontrivial-memaccess""           // warning: first argument in call to 'memset' is a pointer to non-trivially copyable type
#pragma clang diagnostic ignored ""-Wcast-qual""                      // warning: cast from 'const xxxx *' to 'xxx *' drops const qualifier
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored ""-Wpragmas""                          // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored ""-Wunused-function""                  // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored ""-Wfloat-equal""                      // warning: comparing floating-point with '==' or '!=' is unsafe
#pragma GCC diagnostic ignored ""-Wdouble-promotion""                 // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored ""-Wconversion""                       // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored ""-Wstack-protector""                  // warning: stack protector not protecting local variables: variable length buffer
#pragma GCC diagnostic ignored ""-Wstrict-overflow""                  // warning: assuming signed overflow does not occur when simplifying division / ..when changing X +- C1 cmp C2 to X cmp C2 -+ C1
#pragma GCC diagnostic ignored ""-Wclass-memaccess""                  // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#pragma GCC diagnostic ignored ""-Wcast-qual""                        // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
#endif

//-------------------------------------------------------------------------
// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)
//-------------------------------------------------------------------------

// Compile time options:
//#define IMGUI_STB_NAMESPACE           ImStb
//#define IMGUI_STB_TRUETYPE_FILENAME   ""my_folder/stb_truetype.h""
//#define IMGUI_STB_RECT_PACK_FILENAME  ""my_folder/stb_rect_pack.h""
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

#ifdef IMGUI_STB_NAMESPACE
namespace IMGUI_STB_NAMESPACE
{
#endif

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration
#pragma warning (disable: 6011)                             // (stb_rectpack) Dereferencing NULL pointer 'cur->next'.
#pragma warning (disable: 6385)                             // (stb_truetype) Reading invalid data from 'buffer':  the readable size is '_Old_3`kernel_width' bytes, but '3' bytes may be read.
#pragma warning (disable: 28182)                            // (stb_rectpack) Dereferencing NULL pointer. 'cur' contains the same NULL value as 'cur->next' did.
#endif

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored ""-Wunused-function""        // warning: 'xxxx' defined but not used
#pragma clang diagnostic ignored ""-Wmissing-prototypes""
#pragma clang diagnostic ignored ""-Wimplicit-fallthrough""
#endif

#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored ""-Wtype-limits""              // warning: comparison is always true due to limited range of data type [-Wtype-limits]
#pragma GCC diagnostic ignored ""-Wimplicit-fallthrough""     // warning: this statement may fall through
#endif

#ifndef STB_RECT_PACK_IMPLEMENTATION                        // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION          // in case the user already have an implementation in another compilation unit
#define STBRP_STATIC
#define STBRP_ASSERT(x)     do { IM_ASSERT(x); } while (0)
#define STBRP_SORT          ImQsort
#define STB_RECT_PACK_IMPLEMENTATION
#endif
#ifdef IMGUI_STB_RECT_PACK_FILENAME
#include IMGUI_STB_RECT_PACK_FILENAME
#else
#include ""imstb_rectpack.h""
#endif
#endif

#ifdef  IMGUI_ENABLE_STB_TRUETYPE
#ifndef STB_TRUETYPE_IMPLEMENTATION                         // in case the user already have an implementation in the _same_ compilation unit (e.g. unity builds)
#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION           // in case the user already have an implementation in another compilation unit
#define STBTT_malloc(x,u)   ((void)(u), IM_ALLOC(x))
#define STBTT_free(x,u)     ((void)(u), IM_FREE(x))
#define STBTT_assert(x)     do { IM_ASSERT(x); } while(0)
#define STBTT_fmod(x,y)     ImFmod(x,y)
#define STBTT_sqrt(x)       ImSqrt(x)
#define STBTT_pow(x,y)      ImPow(x,y)
#define STBTT_fabs(x)       ImFabs(x)
#define STBTT_ifloor(x)     ((int)ImFloor(x))
#define STBTT_iceil(x)      ((int)ImCeil(x))
#define STBTT_STATIC
#define STB_TRUETYPE_IMPLEMENTATION
#else
#define STBTT_DEF extern
#endif
#ifdef IMGUI_STB_TRUETYPE_FILENAME
#include IMGUI_STB_TRUETYPE_FILENAME
#else
#include ""imstb_truetype.h""
#endif
#endif
#endif // IMGUI_ENABLE_STB_TRUETYPE

#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#if defined(_MSC_VER)
#pragma warning (pop)
#endif

#ifdef IMGUI_STB_NAMESPACE
} // namespace ImStb
using namespace IMGUI_STB_NAMESPACE;
#endif

//-----------------------------------------------------------------------------
// [SECTION] Style functions
//-----------------------------------------------------------------------------

void ImGui::StyleColorsDark(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
    colors[ImGuiCol_Border]                 = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Separator]              = colors[ImGuiCol_Border];
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];
    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.50f, 0.50f, 0.50f, 0.00f);
    colors[ImGuiCol_PlotLines]              = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);
    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here
    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here
    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);
    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    colors[ImGuiCol_NavCursor]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
}

void ImGui::StyleColorsClassic(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.85f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);
    colors[ImGuiCol_Border]                 = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
    colors[ImGuiCol_Button]                 = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);
    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.50f, 0.50f, 0.60f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.10f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.80f);
    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];
    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.53f, 0.53f, 0.87f, 0.00f);
    colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.27f, 0.27f, 0.38f, 1.00f);
    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.31f, 0.31f, 0.45f, 1.00f);   // Prefer using Alpha=1.0 here
    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.26f, 0.26f, 0.28f, 1.00f);   // Prefer using Alpha=1.0 here
    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.07f);
    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
    colors[ImGuiCol_NavCursor]              = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

// Those light colors are better suited with a thicker font than the default one + FrameBorder
void ImGui::StyleColorsLight(ImGuiStyle* dst)
{
    ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
    ImVec4* colors = style->Colors;

    colors[ImGuiCol_Text]                   = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_PopupBg]                = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);
    colors[ImGuiCol_Border]                 = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg]                = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_TitleBg]                = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);
    colors[ImGuiCol_CheckMark]              = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);
    colors[ImGuiCol_Button]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
    colors[ImGuiCol_Header]                 = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
    colors[ImGuiCol_Separator]              = ImVec4(0.39f, 0.39f, 0.39f, 0.62f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.35f, 0.35f, 0.35f, 0.17f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_TabHovered]             = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_Tab]                    = ImLerp(colors[ImGuiCol_Header],       colors[ImGuiCol_TitleBgActive], 0.90f);
    colors[ImGuiCol_TabSelected]            = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);
    colors[ImGuiCol_TabSelectedOverline]    = colors[ImGuiCol_HeaderActive];
    colors[ImGuiCol_TabDimmed]              = ImLerp(colors[ImGuiCol_Tab],          colors[ImGuiCol_TitleBg], 0.80f);
    colors[ImGuiCol_TabDimmedSelected]      = ImLerp(colors[ImGuiCol_TabSelected],  colors[ImGuiCol_TitleBg], 0.40f);
    colors[ImGuiCol_TabDimmedSelectedOverline] = ImVec4(0.26f, 0.59f, 1.00f, 0.00f);
    colors[ImGuiCol_PlotLines]              = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered]       = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
    colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);
    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.78f, 0.87f, 0.98f, 1.00f);
    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.57f, 0.57f, 0.64f, 1.00f);   // Prefer using Alpha=1.0 here
    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.68f, 0.68f, 0.74f, 1.00f);   // Prefer using Alpha=1.0 here
    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(0.30f, 0.30f, 0.30f, 0.09f);
    colors[ImGuiCol_TextLink]               = colors[ImGuiCol_HeaderActive];
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
    colors[ImGuiCol_NavCursor]              = colors[ImGuiCol_HeaderHovered];
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.20f, 0.20f, 0.20f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawList
//-----------------------------------------------------------------------------

ImDrawListSharedData::ImDrawListSharedData()
{
    memset(this, 0, sizeof(*this));
    InitialFringeScale = 1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
    {
        const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);
        ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));
    }
    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
}

void ImDrawListSharedData::SetCircleTessellationMaxError(float max_error)
{
    if (CircleSegmentMaxError == max_error)
        return;

    IM_ASSERT(max_error > 0.0f);
    CircleSegmentMaxError = max_error;
    for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
    {
        const float radius = (float)i;
        CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX);
    }
    ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);
}

ImDrawList::ImDrawList(ImDrawListSharedData* shared_data)
{
    memset(this, 0, sizeof(*this));
    _Data = shared_data;
}

ImDrawList::~ImDrawList()
{
    _ClearFreeMemory();
}

// Initialize before use in a new frame. We always have a command ready in the buffer.
// In the majority of cases, you would want to call PushClipRect() and PushTextureID() after this.
void ImDrawList::_ResetForNewFrame()
{
    // Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
    IM_STATIC_ASSERT(offsetof(ImDrawCmd, ClipRect) == 0);
    IM_STATIC_ASSERT(offsetof(ImDrawCmd, TextureId) == sizeof(ImVec4));
    IM_STATIC_ASSERT(offsetof(ImDrawCmd, VtxOffset) == sizeof(ImVec4) + sizeof(ImTextureID));
    if (_Splitter._Count > 1)
        _Splitter.Merge(this);

    CmdBuffer.resize(0);
    IdxBuffer.resize(0);
    VtxBuffer.resize(0);
    Flags = _Data->InitialFlags;
    memset(&_CmdHeader, 0, sizeof(_CmdHeader));
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.resize(0);
    _TextureIdStack.resize(0);
    _CallbacksDataBuf.resize(0);
    _Path.resize(0);
    _Splitter.Clear();
    CmdBuffer.push_back(ImDrawCmd());
    _FringeScale = _Data->InitialFringeScale;
}

void ImDrawList::_ClearFreeMemory()
{
    CmdBuffer.clear();
    IdxBuffer.clear();
    VtxBuffer.clear();
    Flags = ImDrawListFlags_None;
    _VtxCurrentIdx = 0;
    _VtxWritePtr = NULL;
    _IdxWritePtr = NULL;
    _ClipRectStack.clear();
    _TextureIdStack.clear();
    _CallbacksDataBuf.clear();
    _Path.clear();
    _Splitter.ClearFreeMemory();
}

ImDrawList* ImDrawList::CloneOutput() const
{
    ImDrawList* dst = IM_NEW(ImDrawList(_Data));
    dst->CmdBuffer = CmdBuffer;
    dst->IdxBuffer = IdxBuffer;
    dst->VtxBuffer = VtxBuffer;
    dst->Flags = Flags;
    return dst;
}

void ImDrawList::AddDrawCmd()
{
    ImDrawCmd draw_cmd;
    draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
    draw_cmd.TextureId = _CmdHeader.TextureId;
    draw_cmd.VtxOffset = _CmdHeader.VtxOffset;
    draw_cmd.IdxOffset = IdxBuffer.Size;

    IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
    CmdBuffer.push_back(draw_cmd);
}

// Pop trailing draw command (used before merging or presenting to user)
// Note that this leaves the ImDrawList in a state unfit for further commands, as most code assume that CmdBuffer.Size > 0 && CmdBuffer.back().UserCallback == NULL
void ImDrawList::_PopUnusedDrawCmd()
{
    while (CmdBuffer.Size > 0)
    {
        ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
        if (curr_cmd->ElemCount != 0 || curr_cmd->UserCallback != NULL)
            return;// break;
        CmdBuffer.pop_back();
    }
}

void ImDrawList::AddCallback(ImDrawCallback callback, void* userdata, size_t userdata_size)
{
    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    IM_ASSERT(curr_cmd->UserCallback == NULL);
    if (curr_cmd->ElemCount != 0)
    {
        AddDrawCmd();
        curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    }

    curr_cmd->UserCallback = callback;
    if (userdata_size == 0)
    {
        // Store user data directly in command (no indirection)
        curr_cmd->UserCallbackData = userdata;
        curr_cmd->UserCallbackDataSize = 0;
        curr_cmd->UserCallbackDataOffset = -1;
    }
    else
    {
        // Copy and store user data in a buffer
        IM_ASSERT(userdata != NULL);
        IM_ASSERT(userdata_size < (1u << 31));
        curr_cmd->UserCallbackData = NULL; // Will be resolved during Render()
        curr_cmd->UserCallbackDataSize = (int)userdata_size;
        curr_cmd->UserCallbackDataOffset = _CallbacksDataBuf.Size;
        _CallbacksDataBuf.resize(_CallbacksDataBuf.Size + (int)userdata_size);
        memcpy(_CallbacksDataBuf.Data + (size_t)curr_cmd->UserCallbackDataOffset, userdata, userdata_size);
    }

    AddDrawCmd(); // Force a new command after us (see comment below)
}

// Compare ClipRect, TextureId and VtxOffset with a single memcmp()
#define ImDrawCmd_HeaderSize                            (offsetof(ImDrawCmd, VtxOffset) + sizeof(unsigned int))
#define ImDrawCmd_HeaderCompare(CMD_LHS, CMD_RHS)       (memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize))    // Compare ClipRect, TextureId, VtxOffset
#define ImDrawCmd_HeaderCopy(CMD_DST, CMD_SRC)          (memcpy(CMD_DST, CMD_SRC, ImDrawCmd_HeaderSize))    // Copy ClipRect, TextureId, VtxOffset
#define ImDrawCmd_AreSequentialIdxOffset(CMD_0, CMD_1)  (CMD_0->IdxOffset + CMD_0->ElemCount == CMD_1->IdxOffset)

// Try to merge two last draw commands
void ImDrawList::_TryMergeDrawCmds()
{
    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    ImDrawCmd* prev_cmd = curr_cmd - 1;
    if (ImDrawCmd_HeaderCompare(curr_cmd, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && curr_cmd->UserCallback == NULL && prev_cmd->UserCallback == NULL)
    {
        prev_cmd->ElemCount += curr_cmd->ElemCount;
        CmdBuffer.pop_back();
    }
}

// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
void ImDrawList::_OnChangedClipRect()
{
    // If current command is used with different settings we need to add a new command
    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)
    {
        AddDrawCmd();
        return;
    }
    IM_ASSERT(curr_cmd->UserCallback == NULL);

    // Try to merge with previous command if it matches, else use current command
    ImDrawCmd* prev_cmd = curr_cmd - 1;
    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
    {
        CmdBuffer.pop_back();
        return;
    }
    curr_cmd->ClipRect = _CmdHeader.ClipRect;
}

void ImDrawList::_OnChangedTextureID()
{
    // If current command is used with different settings we need to add a new command
    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)
    {
        AddDrawCmd();
        return;
    }
    IM_ASSERT(curr_cmd->UserCallback == NULL);

    // Try to merge with previous command if it matches, else use current command
    ImDrawCmd* prev_cmd = curr_cmd - 1;
    if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)
    {
        CmdBuffer.pop_back();
        return;
    }
    curr_cmd->TextureId = _CmdHeader.TextureId;
}

void ImDrawList::_OnChangedVtxOffset()
{
    // We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.
    _VtxCurrentIdx = 0;
    IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
    ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
    if (curr_cmd->ElemCount != 0)
    {
        AddDrawCmd();
        return;
    }
    IM_ASSERT(curr_cmd->UserCallback == NULL);
    curr_cmd->VtxOffset = _CmdHeader.VtxOffset;
}

int ImDrawList::_CalcCircleAutoSegmentCount(float radius) const
{
    // Automatic segment count
    const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy
    if (radius_idx >= 0 && radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))
        return _Data->CircleSegmentCounts[radius_idx]; // Use cached value
    else
        return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);
}

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
void ImDrawList::PushClipRect(const ImVec2& cr_min, const ImVec2& cr_max, bool intersect_with_current_clip_rect)
{
    ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
    if (intersect_with_current_clip_rect)
    {
        ImVec4 current = _CmdHeader.ClipRect;
        if (cr.x < current.x) cr.x = current.x;
        if (cr.y < current.y) cr.y = current.y;
        if (cr.z > current.z) cr.z = current.z;
        if (cr.w > current.w) cr.w = current.w;
    }
    cr.z = ImMax(cr.x, cr.z);
    cr.w = ImMax(cr.y, cr.w);

    _ClipRectStack.push_back(cr);
    _CmdHeader.ClipRect = cr;
    _OnChangedClipRect();
}

void ImDrawList::PushClipRectFullScreen()
{
    PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
}

void ImDrawList::PopClipRect()
{
    _ClipRectStack.pop_back();
    _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];
    _OnChangedClipRect();
}

void ImDrawList::PushTextureID(ImTextureID texture_id)
{
    _TextureIdStack.push_back(texture_id);
    _CmdHeader.TextureId = texture_id;
    _OnChangedTextureID();
}

void ImDrawList::PopTextureID()
{
    _TextureIdStack.pop_back();
    _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];
    _OnChangedTextureID();
}

// This is used by ImGui::PushFont()/PopFont(). It works because we never use _TextureIdStack[] elsewhere than in PushTextureID()/PopTextureID().
void ImDrawList::_SetTextureID(ImTextureID texture_id)
{
    if (_CmdHeader.TextureId == texture_id)
        return;
    _CmdHeader.TextureId = texture_id;
    _OnChangedTextureID();
}

// Reserve space for a number of vertices and indices.
// You must finish filling your reserved data before calling PrimReserve() again, as it may reallocate or
// submit the intermediate results. PrimUnreserve() can be used to release unused allocations.
void ImDrawList::PrimReserve(int idx_count, int vtx_count)
{
    // Large mesh support (when enabled)
    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
    if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))
    {
        // FIXME: In theory we should be testing that vtx_count <64k here.
        // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
        // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
        _CmdHeader.VtxOffset = VtxBuffer.Size;
        _OnChangedVtxOffset();
    }

    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    draw_cmd->ElemCount += idx_count;

    int vtx_buffer_old_size = VtxBuffer.Size;
    VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
    _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

    int idx_buffer_old_size = IdxBuffer.Size;
    IdxBuffer.resize(idx_buffer_old_size + idx_count);
    _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
}

// Release the number of reserved vertices/indices from the end of the last reservation made with PrimReserve().
void ImDrawList::PrimUnreserve(int idx_count, int vtx_count)
{
    IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);

    ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];
    draw_cmd->ElemCount -= idx_count;
    VtxBuffer.shrink(VtxBuffer.Size - vtx_count);
    IdxBuffer.shrink(IdxBuffer.Size - idx_count);
}

// Fully unrolled with inline call to keep our debug builds decently fast.
void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)
{
    ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
{
    ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
    ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
    _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);
    _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);
    _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
    _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
    _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
    _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
    _VtxWritePtr += 4;
    _VtxCurrentIdx += 4;
    _IdxWritePtr += 6;
}

// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superfluous function calls to optimize debug/non-inlined builds.
// - Those macros expects l-values and need to be used as their own statement.
// - Those macros are intentionally not surrounded by the 'do {} while (0)' idiom because even that translates to runtime with debug compilers.
#define IM_NORMALIZE2F_OVER_ZERO(VX,VY)     { float d2 = VX*VX + VY*VY; if (d2 > 0.0f) { float inv_len = ImRsqrt(d2); VX *= inv_len; VY *= inv_len; } } (void)0
#define IM_FIXNORMAL2F_MAX_INVLEN2          100.0f // 500.0f (see #4053, #3366)
#define IM_FIXNORMAL2F(VX,VY)               { float d2 = VX*VX + VY*VY; if (d2 > 0.000001f) { float inv_len2 = 1.0f / d2; if (inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2) inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2; VX *= inv_len2; VY *= inv_len2; } } (void)0

// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, ImDrawFlags flags, float thickness)
{
    if (points_count < 2 || (col & IM_COL32_A_MASK) == 0)
        return;

    const bool closed = (flags & ImDrawFlags_Closed) != 0;
    const ImVec2 opaque_uv = _Data->TexUvWhitePixel;
    const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
    const bool thick_line = (thickness > _FringeScale);

    if (Flags & ImDrawListFlags_AntiAliasedLines)
    {
        // Anti-aliased stroke
        const float AA_SIZE = _FringeScale;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;

        // Thicknesses <1.0 should behave like thickness 1.0
        thickness = ImMax(thickness, 1.0f);
        const int integer_thickness = (int)thickness;
        const float fractional_thickness = thickness - integer_thickness;

        // Do we want to draw this line using a texture?
        // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
        // - If AA_SIZE is not 1.0f we cannot use the texture path.
        const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);

        // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
        IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));

        const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);
        const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);
        PrimReserve(idx_count, vtx_count);

        // Temporary buffer
        // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
        _Data->TempBuffer.reserve_discard(points_count * ((use_texture || !thick_line) ? 3 : 5));
        ImVec2* temp_normals = _Data->TempBuffer.Data;
        ImVec2* temp_points = temp_normals + points_count;

        // Calculate normals (tangents) for each line segment
        for (int i1 = 0; i1 < count; i1++)
        {
            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
            float dx = points[i2].x - points[i1].x;
            float dy = points[i2].y - points[i1].y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            temp_normals[i1].x = dy;
            temp_normals[i1].y = -dx;
        }
        if (!closed)
            temp_normals[points_count - 1] = temp_normals[points_count - 2];

        // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
        if (use_texture || !thick_line)
        {
            // [PATH 1] Texture-based lines (thick or non-thick)
            // [PATH 2] Non texture-based lines (non-thick)

            // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus ""one pixel"" for AA.
            // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
            //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
            // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
            //   allow scaling geometry while preserving one-screen-pixel AA fringe).
            const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;

            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
            if (!closed)
            {
                temp_points[0] = points[0] + temp_normals[0] * half_draw_size;
                temp_points[1] = points[0] - temp_normals[0] * half_draw_size;
                temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * half_draw_size;
                temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * half_draw_size;
            }

            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
            {
                const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
                const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment

                // Average normals
                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
                IM_FIXNORMAL2F(dm_x, dm_y);
                dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
                dm_y *= half_draw_size;

                // Add temporary vertexes for the outer edges
                ImVec2* out_vtx = &temp_points[i2 * 2];
                out_vtx[0].x = points[i2].x + dm_x;
                out_vtx[0].y = points[i2].y + dm_y;
                out_vtx[1].x = points[i2].x - dm_x;
                out_vtx[1].y = points[i2].y - dm_y;

                if (use_texture)
                {
                    // Add indices for two triangles
                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri
                    _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri
                    _IdxWritePtr += 6;
                }
                else
                {
                    // Add indexes for four triangles
                    _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1
                    _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2
                    _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1
                    _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2
                    _IdxWritePtr += 12;
                }

                idx1 = idx2;
            }

            // Add vertexes for each point on the line
            if (use_texture)
            {
                // If we're using textures we only need to emit the left/right edge vertices
                ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];
                /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
                {
                    const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
                    tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
                    tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
                    tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
                    tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
                }*/
                ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
                ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
                for (int i = 0; i < points_count; i++)
                {
                    _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge
                    _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge
                    _VtxWritePtr += 2;
                }
            }
            else
            {
                // If we're not using a texture, we need the center vertex as well
                for (int i = 0; i < points_count; i++)
                {
                    _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line
                    _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge
                    _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge
                    _VtxWritePtr += 3;
                }
            }
        }
        else
        {
            // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
            const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;

            // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
            if (!closed)
            {
                const int points_last = points_count - 1;
                temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
                temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
                temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
                temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
                temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
                temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);
                temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);
                temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);
            }

            // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
            // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
            // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
            unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment
            for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment
            {
                const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
                const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment

                // Average normals
                float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
                float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;
                IM_FIXNORMAL2F(dm_x, dm_y);
                float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
                float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
                float dm_in_x = dm_x * half_inner_thickness;
                float dm_in_y = dm_y * half_inner_thickness;

                // Add temporary vertices
                ImVec2* out_vtx = &temp_points[i2 * 4];
                out_vtx[0].x = points[i2].x + dm_out_x;
                out_vtx[0].y = points[i2].y + dm_out_y;
                out_vtx[1].x = points[i2].x + dm_in_x;
                out_vtx[1].y = points[i2].y + dm_in_y;
                out_vtx[2].x = points[i2].x - dm_in_x;
                out_vtx[2].y = points[i2].y - dm_in_y;
                out_vtx[3].x = points[i2].x - dm_out_x;
                out_vtx[3].y = points[i2].y - dm_out_y;

                // Add indexes
                _IdxWritePtr[0]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1 + 2);
                _IdxWritePtr[3]  = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2 + 1);
                _IdxWritePtr[6]  = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1 + 0);
                _IdxWritePtr[9]  = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
                _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);
                _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);
                _IdxWritePtr += 18;

                idx1 = idx2;
            }

            // Add vertices
            for (int i = 0; i < points_count; i++)
            {
                _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;
                _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
                _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
                _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;
                _VtxWritePtr += 4;
            }
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // [PATH 4] Non texture-based, Non anti-aliased lines
        const int idx_count = count * 6;
        const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
        PrimReserve(idx_count, vtx_count);

        for (int i1 = 0; i1 < count; i1++)
        {
            const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
            const ImVec2& p1 = points[i1];
            const ImVec2& p2 = points[i2];

            float dx = p2.x - p1.x;
            float dy = p2.y - p1.y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            dx *= (thickness * 0.5f);
            dy *= (thickness * 0.5f);

            _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;
            _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;
            _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;
            _VtxWritePtr += 4;

            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
            _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
            _IdxWritePtr += 6;
            _VtxCurrentIdx += 4;
        }
    }
}

// - We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
// - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have ""inward"" anti-aliasing.
void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
{
    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;

    if (Flags & ImDrawListFlags_AntiAliasedFill)
    {
        // Anti-aliased Fill
        const float AA_SIZE = _FringeScale;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
        const int idx_count = (points_count - 2)*3 + points_count * 6;
        const int vtx_count = (points_count * 2);
        PrimReserve(idx_count, vtx_count);

        // Add indexes for fill
        unsigned int vtx_inner_idx = _VtxCurrentIdx;
        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
        for (int i = 2; i < points_count; i++)
        {
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
            _IdxWritePtr += 3;
        }

        // Compute normals
        _Data->TempBuffer.reserve_discard(points_count);
        ImVec2* temp_normals = _Data->TempBuffer.Data;
        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            const ImVec2& p0 = points[i0];
            const ImVec2& p1 = points[i1];
            float dx = p1.x - p0.x;
            float dy = p1.y - p0.y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            temp_normals[i0].x = dy;
            temp_normals[i0].y = -dx;
        }

        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            // Average normals
            const ImVec2& n0 = temp_normals[i0];
            const ImVec2& n1 = temp_normals[i1];
            float dm_x = (n0.x + n1.x) * 0.5f;
            float dm_y = (n0.y + n1.y) * 0.5f;
            IM_FIXNORMAL2F(dm_x, dm_y);
            dm_x *= AA_SIZE * 0.5f;
            dm_y *= AA_SIZE * 0.5f;

            // Add vertices
            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
            _VtxWritePtr += 2;

            // Add indexes for fringes
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
            _IdxWritePtr += 6;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Fill
        const int idx_count = (points_count - 2)*3;
        const int vtx_count = points_count;
        PrimReserve(idx_count, vtx_count);
        for (int i = 0; i < vtx_count; i++)
        {
            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr++;
        }
        for (int i = 2; i < points_count; i++)
        {
            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
            _IdxWritePtr += 3;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
}

void ImDrawList::_PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step)
{
    if (radius < 0.5f)
    {
        _Path.push_back(center);
        return;
    }

    // Calculate arc auto segment step size
    if (a_step <= 0)
        a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);

    // Make sure we never do steps larger than one quarter of the circle
    a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4);

    const int sample_range = ImAbs(a_max_sample - a_min_sample);
    const int a_next_step = a_step;

    int samples = sample_range + 1;
    bool extra_max_sample = false;
    if (a_step > 1)
    {
        samples            = sample_range / a_step + 1;
        const int overstep = sample_range % a_step;

        if (overstep > 0)
        {
            extra_max_sample = true;
            samples++;

            // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
            // distribute first step range evenly between them by reducing first step size.
            if (sample_range > 0)
                a_step -= (a_step - overstep) / 2;
        }
    }

    _Path.resize(_Path.Size + samples);
    ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);

    int sample_index = a_min_sample;
    if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
    {
        sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
        if (sample_index < 0)
            sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
    }

    if (a_max_sample >= a_min_sample)
    {
        for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)
        {
            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
            if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
                sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

            const ImVec2 s = _Data->ArcFastVtx[sample_index];
            out_ptr->x = center.x + s.x * radius;
            out_ptr->y = center.y + s.y * radius;
            out_ptr++;
        }
    }
    else
    {
        for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)
        {
            // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
            if (sample_index < 0)
                sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

            const ImVec2 s = _Data->ArcFastVtx[sample_index];
            out_ptr->x = center.x + s.x * radius;
            out_ptr->y = center.y + s.y * radius;
            out_ptr++;
        }
    }

    if (extra_max_sample)
    {
        int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
        if (normalized_max_sample < 0)
            normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

        const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];
        out_ptr->x = center.x + s.x * radius;
        out_ptr->y = center.y + s.y * radius;
        out_ptr++;
    }

    IM_ASSERT_PARANOID(_Path.Data + _Path.Size == out_ptr);
}

void ImDrawList::_PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments)
{
    if (radius < 0.5f)
    {
        _Path.push_back(center);
        return;
    }

    // Note that we are adding a point at both a_min and a_max.
    // If you are trying to draw a full closed circle you don't want the overlapping points!
    _Path.reserve(_Path.Size + (num_segments + 1));
    for (int i = 0; i <= num_segments; i++)
    {
        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
        _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));
    }
}

// 0: East, 3: South, 6: West, 9: North, 12: East
void ImDrawList::PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12)
{
    if (radius < 0.5f)
    {
        _Path.push_back(center);
        return;
    }
    _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);
}

void ImDrawList::PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments)
{
    if (radius < 0.5f)
    {
        _Path.push_back(center);
        return;
    }

    if (num_segments > 0)
    {
        _PathArcToN(center, radius, a_min, a_max, num_segments);
        return;
    }

    // Automatic segment count
    if (radius <= _Data->ArcFastRadiusCutoff)
    {
        const bool a_is_reverse = a_max < a_min;

        // We are going to use precomputed values for mid samples.
        // Determine first and last sample in lookup table that belong to the arc.
        const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);
        const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);

        const int a_min_sample = a_is_reverse ? (int)ImFloor(a_min_sample_f) : (int)ImCeil(a_min_sample_f);
        const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloor(a_max_sample_f);
        const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);

        const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
        const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
        const bool a_emit_start = ImAbs(a_min_segment_angle - a_min) >= 1e-5f;
        const bool a_emit_end = ImAbs(a_max - a_max_segment_angle) >= 1e-5f;

        _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));
        if (a_emit_start)
            _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));
        if (a_mid_samples > 0)
            _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);
        if (a_emit_end)
            _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));
    }
    else
    {
        const float arc_length = ImAbs(a_max - a_min);
        const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);
        const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));
        _PathArcToN(center, radius, a_min, a_max, arc_segment_count);
    }
}

void ImDrawList::PathEllipticalArcTo(const ImVec2& center, const ImVec2& radius, float rot, float a_min, float a_max, int num_segments)
{
    if (num_segments <= 0)
        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.

    _Path.reserve(_Path.Size + (num_segments + 1));

    const float cos_rot = ImCos(rot);
    const float sin_rot = ImSin(rot);
    for (int i = 0; i <= num_segments; i++)
    {
        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
        ImVec2 point(ImCos(a) * radius.x, ImSin(a) * radius.y);
        const ImVec2 rel((point.x * cos_rot) - (point.y * sin_rot), (point.x * sin_rot) + (point.y * cos_rot));
        point.x = rel.x + center.x;
        point.y = rel.y + center.y;
        _Path.push_back(point);
    }
}

ImVec2 ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t)
{
    float u = 1.0f - t;
    float w1 = u * u * u;
    float w2 = 3 * u * u * t;
    float w3 = 3 * u * t * t;
    float w4 = t * t * t;
    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y);
}

ImVec2 ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t)
{
    float u = 1.0f - t;
    float w1 = u * u;
    float w2 = 2 * u * t;
    float w3 = t * t;
    return ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x, w1 * p1.y + w2 * p2.y + w3 * p3.y);
}

// Closely mimics ImBezierCubicClosestPointCasteljau() in imgui.cpp
static void PathBezierCubicCurveToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
{
    float dx = x4 - x1;
    float dy = y4 - y1;
    float d2 = (x2 - x4) * dy - (y2 - y4) * dx;
    float d3 = (x3 - x4) * dy - (y3 - y4) * dx;
    d2 = (d2 >= 0) ? d2 : -d2;
    d3 = (d3 >= 0) ? d3 : -d3;
    if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))
    {
        path->push_back(ImVec2(x4, y4));
    }
    else if (level < 10)
    {
        float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
        float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
        float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;
        float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
        float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;
        float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;
        PathBezierCubicCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
        PathBezierCubicCurveToCasteljau(path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
    }
}

static void PathBezierQuadraticCurveToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float tess_tol, int level)
{
    float dx = x3 - x1, dy = y3 - y1;
    float det = (x2 - x3) * dy - (y2 - y3) * dx;
    if (det * det * 4.0f < tess_tol * (dx * dx + dy * dy))
    {
        path->push_back(ImVec2(x3, y3));
    }
    else if (level < 10)
    {
        float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
        float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
        float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
        PathBezierQuadraticCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, tess_tol, level + 1);
        PathBezierQuadraticCurveToCasteljau(path, x123, y123, x23, y23, x3, y3, tess_tol, level + 1);
    }
}

void ImDrawList::PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)
{
    ImVec2 p1 = _Path.back();
    if (num_segments == 0)
    {
        IM_ASSERT(_Data->CurveTessellationTol > 0.0f);
        PathBezierCubicCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0); // Auto-tessellated
    }
    else
    {
        float t_step = 1.0f / (float)num_segments;
        for (int i_step = 1; i_step <= num_segments; i_step++)
            _Path.push_back(ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step));
    }
}

void ImDrawList::PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments)
{
    ImVec2 p1 = _Path.back();
    if (num_segments == 0)
    {
        IM_ASSERT(_Data->CurveTessellationTol > 0.0f);
        PathBezierQuadraticCurveToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, _Data->CurveTessellationTol, 0);// Auto-tessellated
    }
    else
    {
        float t_step = 1.0f / (float)num_segments;
        for (int i_step = 1; i_step <= num_segments; i_step++)
            _Path.push_back(ImBezierQuadraticCalc(p1, p2, p3, t_step * i_step));
    }
}

static inline ImDrawFlags FixRectCornerFlags(ImDrawFlags flags)
{
    /*
    IM_STATIC_ASSERT(ImDrawFlags_RoundCornersTopLeft == (1 << 4));
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // Obsoleted in 1.82 (from February 2021). This code was stripped/simplified and mostly commented in 1.90 (from September 2023)
    // - Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
    if (flags == ~0)                    { return ImDrawFlags_RoundCornersAll; }
    // - Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations). Read details in older version of this code.
    if (flags >= 0x01 && flags <= 0x0F) { return (flags << 4); }
    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
#endif
    */
    // If this assert triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
    // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc. anyway.
    // See details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08 entries in ""API BREAKING CHANGES"" section.
    IM_ASSERT((flags & 0x0F) == 0 && ""Misuse of legacy hardcoded ImDrawCornerFlags values!"");

    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
        flags |= ImDrawFlags_RoundCornersAll;

    return flags;
}

void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, ImDrawFlags flags)
{
    if (rounding >= 0.5f)
    {
        flags = FixRectCornerFlags(flags);
        rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);
        rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);
    }
    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
    {
        PathLineTo(a);
        PathLineTo(ImVec2(b.x, a.y));
        PathLineTo(b);
        PathLineTo(ImVec2(a.x, b.y));
    }
    else
    {
        const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft)     ? rounding : 0.0f;
        const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight)    ? rounding : 0.0f;
        const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;
        const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft)  ? rounding : 0.0f;
        PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
        PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
        PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
        PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
    }
}

void ImDrawList::AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    PathLineTo(p1 + ImVec2(0.5f, 0.5f));
    PathLineTo(p2 + ImVec2(0.5f, 0.5f));
    PathStroke(col, 0, thickness);
}

// p_min = upper-left, p_max = lower-right
// Note we don't render 1 pixels sized rectangles properly.
void ImDrawList::AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    if (Flags & ImDrawListFlags_AntiAliasedLines)
        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);
    else
        PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.
    PathStroke(col, ImDrawFlags_Closed, thickness);
}

void ImDrawList::AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;
    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
    {
        PrimReserve(6, 4);
        PrimRect(p_min, p_max, col);
    }
    else
    {
        PathRect(p_min, p_max, rounding, flags);
        PathFillConvex(col);
    }
}

// p_min = upper-left, p_max = lower-right
void ImDrawList::AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
{
    if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;
    PrimReserve(6, 4);
    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));
    PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));
    PrimWriteVtx(p_min, uv, col_upr_left);
    PrimWriteVtx(ImVec2(p_max.x, p_min.y), uv, col_upr_right);
    PrimWriteVtx(p_max, uv, col_bot_right);
    PrimWriteVtx(ImVec2(p_min.x, p_max.y), uv, col_bot_left);
}

void ImDrawList::AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(p1);
    PathLineTo(p2);
    PathLineTo(p3);
    PathLineTo(p4);
    PathStroke(col, ImDrawFlags_Closed, thickness);
}

void ImDrawList::AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(p1);
    PathLineTo(p2);
    PathLineTo(p3);
    PathLineTo(p4);
    PathFillConvex(col);
}

void ImDrawList::AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(p1);
    PathLineTo(p2);
    PathLineTo(p3);
    PathStroke(col, ImDrawFlags_Closed, thickness);
}

void ImDrawList::AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(p1);
    PathLineTo(p2);
    PathLineTo(p3);
    PathFillConvex(col);
}

void ImDrawList::AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
        return;

    if (num_segments <= 0)
    {
        // Use arc with automatic segment count
        _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
        _Path.Size--;
    }
    else
    {
        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);

        // Because we are filling a closed shape we remove 1 from the count of segments/points
        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
        PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);
    }

    PathStroke(col, ImDrawFlags_Closed, thickness);
}

void ImDrawList::AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0 || radius < 0.5f)
        return;

    if (num_segments <= 0)
    {
        // Use arc with automatic segment count
        _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
        _Path.Size--;
    }
    else
    {
        // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
        num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);

        // Because we are filling a closed shape we remove 1 from the count of segments/points
        const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
        PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
    }

    PathFillConvex(col);
}

// Guaranteed to honor 'num_segments'
void ImDrawList::AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
        return;

    // Because we are filling a closed shape we remove 1 from the count of segments/points
    const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);
    PathStroke(col, ImDrawFlags_Closed, thickness);
}

// Guaranteed to honor 'num_segments'
void ImDrawList::AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0 || num_segments <= 2)
        return;

    // Because we are filling a closed shape we remove 1 from the count of segments/points
    const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
    PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);
    PathFillConvex(col);
}

// Ellipse
void ImDrawList::AddEllipse(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot, int num_segments, float thickness)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    if (num_segments <= 0)
        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.

    // Because we are filling a closed shape we remove 1 from the count of segments/points
    const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    PathEllipticalArcTo(center, radius, rot, 0.0f, a_max, num_segments - 1);
    PathStroke(col, true, thickness);
}

void ImDrawList::AddEllipseFilled(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    if (num_segments <= 0)
        num_segments = _CalcCircleAutoSegmentCount(ImMax(radius.x, radius.y)); // A bit pessimistic, maybe there's a better computation to do here.

    // Because we are filling a closed shape we remove 1 from the count of segments/points
    const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
    PathEllipticalArcTo(center, radius, rot, 0.0f, a_max, num_segments - 1);
    PathFillConvex(col);
}

// Cubic Bezier takes 4 controls points
void ImDrawList::AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(p1);
    PathBezierCubicCurveTo(p2, p3, p4, num_segments);
    PathStroke(col, 0, thickness);
}

// Quadratic Bezier takes 3 controls points
void ImDrawList::AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    PathLineTo(p1);
    PathBezierQuadraticCurveTo(p2, p3, num_segments);
    PathStroke(col, 0, thickness);
}

void ImDrawList::AddText(ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    // Accept null ranges
    if (text_begin == text_end || text_begin[0] == 0)
        return;
    // No need to strlen() here: font->RenderText() will do it and may early out.

    // Pull default font/size from the shared ImDrawListSharedData instance
    if (font == NULL)
        font = _Data->Font;
    if (font_size == 0.0f)
        font_size = _Data->FontSize;

    IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

    ImVec4 clip_rect = _CmdHeader.ClipRect;
    if (cpu_fine_clip_rect)
    {
        clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
        clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
        clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
        clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
    }
    font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
}

void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
{
    AddText(_Data->Font, _Data->FontSize, pos, col, text_begin, text_end);
}

void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
    if (push_texture_id)
        PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimRectUV(p_min, p_max, uv_min, uv_max, col);

    if (push_texture_id)
        PopTextureID();
}

void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1, const ImVec2& uv2, const ImVec2& uv3, const ImVec2& uv4, ImU32 col)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
    if (push_texture_id)
        PushTextureID(user_texture_id);

    PrimReserve(6, 4);
    PrimQuadUV(p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);

    if (push_texture_id)
        PopTextureID();
}

void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags)
{
    if ((col & IM_COL32_A_MASK) == 0)
        return;

    flags = FixRectCornerFlags(flags);
    if (rounding < 0.5f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)
    {
        AddImage(user_texture_id, p_min, p_max, uv_min, uv_max, col);
        return;
    }

    const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;
    if (push_texture_id)
        PushTextureID(user_texture_id);

    int vert_start_idx = VtxBuffer.Size;
    PathRect(p_min, p_max, rounding, flags);
    PathFillConvex(col);
    int vert_end_idx = VtxBuffer.Size;
    ImGui::ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true);

    if (push_texture_id)
        PopTextureID();
}

//-----------------------------------------------------------------------------
// [SECTION] ImTriangulator, ImDrawList concave polygon fill
//-----------------------------------------------------------------------------
// Triangulate concave polygons. Based on ""Triangulation by Ear Clipping"" paper, O(N^2) complexity.
// Reference: https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
// Provided as a convenience for user but not used by main library.
//-----------------------------------------------------------------------------
// - ImTriangulator [Internal]
// - AddConcavePolyFilled()
//-----------------------------------------------------------------------------

enum ImTriangulatorNodeType
{
    ImTriangulatorNodeType_Convex,
    ImTriangulatorNodeType_Ear,
    ImTriangulatorNodeType_Reflex
};

struct ImTriangulatorNode
{
    ImTriangulatorNodeType  Type;
    int                     Index;
    ImVec2                  Pos;
    ImTriangulatorNode*     Next;
    ImTriangulatorNode*     Prev;

    void    Unlink()        { Next->Prev = Prev; Prev->Next = Next; }
};

struct ImTriangulatorNodeSpan
{
    ImTriangulatorNode**    Data = NULL;
    int                     Size = 0;

    void    push_back(ImTriangulatorNode* node) { Data[Size++] = node; }
    void    find_erase_unsorted(int idx)        { for (int i = Size - 1; i >= 0; i--) if (Data[i]->Index == idx) { Data[i] = Data[Size - 1]; Size--; return; } }
};

struct ImTriangulator
{
    static int EstimateTriangleCount(int points_count)      { return (points_count < 3) ? 0 : points_count - 2; }
    static int EstimateScratchBufferSize(int points_count)  { return sizeof(ImTriangulatorNode) * points_count + sizeof(ImTriangulatorNode*) * points_count * 2; }

    void    Init(const ImVec2* points, int points_count, void* scratch_buffer);
    void    GetNextTriangle(unsigned int out_triangle[3]);     // Return relative indexes for next triangle

    // Internal functions
    void    BuildNodes(const ImVec2* points, int points_count);
    void    BuildReflexes();
    void    BuildEars();
    void    FlipNodeList();
    bool    IsEar(int i0, int i1, int i2, const ImVec2& v0, const ImVec2& v1, const ImVec2& v2) const;
    void    ReclassifyNode(ImTriangulatorNode* node);

    // Internal members
    int                     _TrianglesLeft = 0;
    ImTriangulatorNode*     _Nodes = NULL;
    ImTriangulatorNodeSpan  _Ears;
    ImTriangulatorNodeSpan  _Reflexes;
};

// Distribute storage for nodes, ears and reflexes.
// FIXME-OPT: if everything is convex, we could report it to caller and let it switch to an convex renderer
// (this would require first building reflexes to bail to convex if empty, without even building nodes)
void ImTriangulator::Init(const ImVec2* points, int points_count, void* scratch_buffer)
{
    IM_ASSERT(scratch_buffer != NULL && points_count >= 3);
    _TrianglesLeft = EstimateTriangleCount(points_count);
    _Nodes         = (ImTriangulatorNode*)scratch_buffer;                          // points_count x Node
    _Ears.Data     = (ImTriangulatorNode**)(_Nodes + points_count);                // points_count x Node*
    _Reflexes.Data = (ImTriangulatorNode**)(_Nodes + points_count) + points_count; // points_count x Node*
    BuildNodes(points, points_count);
    BuildReflexes();
    BuildEars();
}

void ImTriangulator::BuildNodes(const ImVec2* points, int points_count)
{
    for (int i = 0; i < points_count; i++)
    {
        _Nodes[i].Type = ImTriangulatorNodeType_Convex;
        _Nodes[i].Index = i;
        _Nodes[i].Pos = points[i];
        _Nodes[i].Next = _Nodes + i + 1;
        _Nodes[i].Prev = _Nodes + i - 1;
    }
    _Nodes[0].Prev = _Nodes + points_count - 1;
    _Nodes[points_count - 1].Next = _Nodes;
}

void ImTriangulator::BuildReflexes()
{
    ImTriangulatorNode* n1 = _Nodes;
    for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next)
    {
        if (ImTriangleIsClockwise(n1->Prev->Pos, n1->Pos, n1->Next->Pos))
            continue;
        n1->Type = ImTriangulatorNodeType_Reflex;
        _Reflexes.push_back(n1);
    }
}

void ImTriangulator::BuildEars()
{
    ImTriangulatorNode* n1 = _Nodes;
    for (int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next)
    {
        if (n1->Type != ImTriangulatorNodeType_Convex)
            continue;
        if (!IsEar(n1->Prev->Index, n1->Index, n1->Next->Index, n1->Prev->Pos, n1->Pos, n1->Next->Pos))
            continue;
        n1->Type = ImTriangulatorNodeType_Ear;
        _Ears.push_back(n1);
    }
}

void ImTriangulator::GetNextTriangle(unsigned int out_triangle[3])
{
    if (_Ears.Size == 0)
    {
        FlipNodeList();

        ImTriangulatorNode* node = _Nodes;
        for (int i = _TrianglesLeft; i >= 0; i--, node = node->Next)
            node->Type = ImTriangulatorNodeType_Convex;
        _Reflexes.Size = 0;
        BuildReflexes();
        BuildEars();

        // If we still don't have ears, it means geometry is degenerated.
        if (_Ears.Size == 0)
        {
            // Return first triangle available, mimicking the behavior of convex fill.
            IM_ASSERT(_TrianglesLeft > 0); // Geometry is degenerated
            _Ears.Data[0] = _Nodes;
            _Ears.Size    = 1;
        }
    }

    ImTriangulatorNode* ear = _Ears.Data[--_Ears.Size];
    out_triangle[0] = ear->Prev->Index;
    out_triangle[1] = ear->Index;
    out_triangle[2] = ear->Next->Index;

    ear->Unlink();
    if (ear == _Nodes)
        _Nodes = ear->Next;

    ReclassifyNode(ear->Prev);
    ReclassifyNode(ear->Next);
    _TrianglesLeft--;
}

void ImTriangulator::FlipNodeList()
{
    ImTriangulatorNode* prev = _Nodes;
    ImTriangulatorNode* temp = _Nodes;
    ImTriangulatorNode* current = _Nodes->Next;
    prev->Next = prev;
    prev->Prev = prev;
    while (current != _Nodes)
    {
        temp = current->Next;

        current->Next = prev;
        prev->Prev = current;
        _Nodes->Next = current;
        current->Prev = _Nodes;

        prev = current;
        current = temp;
    }
    _Nodes = prev;
}

// A triangle is an ear is no other vertex is inside it. We can test reflexes vertices only (see reference algorithm)
bool ImTriangulator::IsEar(int i0, int i1, int i2, const ImVec2& v0, const ImVec2& v1, const ImVec2& v2) const
{
    ImTriangulatorNode** p_end = _Reflexes.Data + _Reflexes.Size;
    for (ImTriangulatorNode** p = _Reflexes.Data; p < p_end; p++)
    {
        ImTriangulatorNode* reflex = *p;
        if (reflex->Index != i0 && reflex->Index != i1 && reflex->Index != i2)
            if (ImTriangleContainsPoint(v0, v1, v2, reflex->Pos))
                return false;
    }
    return true;
}

void ImTriangulator::ReclassifyNode(ImTriangulatorNode* n1)
{
    // Classify node
    ImTriangulatorNodeType type;
    const ImTriangulatorNode* n0 = n1->Prev;
    const ImTriangulatorNode* n2 = n1->Next;
    if (!ImTriangleIsClockwise(n0->Pos, n1->Pos, n2->Pos))
        type = ImTriangulatorNodeType_Reflex;
    else if (IsEar(n0->Index, n1->Index, n2->Index, n0->Pos, n1->Pos, n2->Pos))
        type = ImTriangulatorNodeType_Ear;
    else
        type = ImTriangulatorNodeType_Convex;

    // Update lists when a type changes
    if (type == n1->Type)
        return;
    if (n1->Type == ImTriangulatorNodeType_Reflex)
        _Reflexes.find_erase_unsorted(n1->Index);
    else if (n1->Type == ImTriangulatorNodeType_Ear)
        _Ears.find_erase_unsorted(n1->Index);
    if (type == ImTriangulatorNodeType_Reflex)
        _Reflexes.push_back(n1);
    else if (type == ImTriangulatorNodeType_Ear)
        _Ears.push_back(n1);
    n1->Type = type;
}

// Use ear-clipping algorithm to triangulate a simple polygon (no self-interaction, no holes).
// (Reminder: we don't perform any coarse clipping/culling in ImDrawList layer!
// It is up to caller to ensure not making costly calls that will be outside of visible area.
// As concave fill is noticeably more expensive than other primitives, be mindful of this...
// Caller can build AABB of points, and avoid filling if 'draw_list->_CmdHeader.ClipRect.Overlays(points_bb) == false')
void ImDrawList::AddConcavePolyFilled(const ImVec2* points, const int points_count, ImU32 col)
{
    if (points_count < 3 || (col & IM_COL32_A_MASK) == 0)
        return;

    const ImVec2 uv = _Data->TexUvWhitePixel;
    ImTriangulator triangulator;
    unsigned int triangle[3];
    if (Flags & ImDrawListFlags_AntiAliasedFill)
    {
        // Anti-aliased Fill
        const float AA_SIZE = _FringeScale;
        const ImU32 col_trans = col & ~IM_COL32_A_MASK;
        const int idx_count = (points_count - 2) * 3 + points_count * 6;
        const int vtx_count = (points_count * 2);
        PrimReserve(idx_count, vtx_count);

        // Add indexes for fill
        unsigned int vtx_inner_idx = _VtxCurrentIdx;
        unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;

        _Data->TempBuffer.reserve_discard((ImTriangulator::EstimateScratchBufferSize(points_count) + sizeof(ImVec2)) / sizeof(ImVec2));
        triangulator.Init(points, points_count, _Data->TempBuffer.Data);
        while (triangulator._TrianglesLeft > 0)
        {
            triangulator.GetNextTriangle(triangle);
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (triangle[0] << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (triangle[1] << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (triangle[2] << 1));
            _IdxWritePtr += 3;
        }

        // Compute normals
        _Data->TempBuffer.reserve_discard(points_count);
        ImVec2* temp_normals = _Data->TempBuffer.Data;
        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            const ImVec2& p0 = points[i0];
            const ImVec2& p1 = points[i1];
            float dx = p1.x - p0.x;
            float dy = p1.y - p0.y;
            IM_NORMALIZE2F_OVER_ZERO(dx, dy);
            temp_normals[i0].x = dy;
            temp_normals[i0].y = -dx;
        }

        for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
        {
            // Average normals
            const ImVec2& n0 = temp_normals[i0];
            const ImVec2& n1 = temp_normals[i1];
            float dm_x = (n0.x + n1.x) * 0.5f;
            float dm_y = (n0.y + n1.y) * 0.5f;
            IM_FIXNORMAL2F(dm_x, dm_y);
            dm_x *= AA_SIZE * 0.5f;
            dm_y *= AA_SIZE * 0.5f;

            // Add vertices
            _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
            _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
            _VtxWritePtr += 2;

            // Add indexes for fringes
            _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
            _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
            _IdxWritePtr += 6;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
    else
    {
        // Non Anti-aliased Fill
        const int idx_count = (points_count - 2) * 3;
        const int vtx_count = points_count;
        PrimReserve(idx_count, vtx_count);
        for (int i = 0; i < vtx_count; i++)
        {
            _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
            _VtxWritePtr++;
        }
        _Data->TempBuffer.reserve_discard((ImTriangulator::EstimateScratchBufferSize(points_count) + sizeof(ImVec2)) / sizeof(ImVec2));
        triangulator.Init(points, points_count, _Data->TempBuffer.Data);
        while (triangulator._TrianglesLeft > 0)
        {
            triangulator.GetNextTriangle(triangle);
            _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx + triangle[0]); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + triangle[1]); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + triangle[2]);
            _IdxWritePtr += 3;
        }
        _VtxCurrentIdx += (ImDrawIdx)vtx_count;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawListSplitter
//-----------------------------------------------------------------------------
// FIXME: This may be a little confusing, trying to be a little too low-level/optimal instead of just doing vector swap..
//-----------------------------------------------------------------------------

void ImDrawListSplitter::ClearFreeMemory()
{
    for (int i = 0; i < _Channels.Size; i++)
    {
        if (i == _Current)
            memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
        _Channels[i]._CmdBuffer.clear();
        _Channels[i]._IdxBuffer.clear();
    }
    _Current = 0;
    _Count = 1;
    _Channels.clear();
}

void ImDrawListSplitter::Split(ImDrawList* draw_list, int channels_count)
{
    IM_UNUSED(draw_list);
    IM_ASSERT(_Current == 0 && _Count <= 1 && ""Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter."");
    int old_channels_count = _Channels.Size;
    if (old_channels_count < channels_count)
    {
        _Channels.reserve(channels_count); // Avoid over reserving since this is likely to stay stable
        _Channels.resize(channels_count);
    }
    _Count = channels_count;

    // Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
    // The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
    // When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
    memset(&_Channels[0], 0, sizeof(ImDrawChannel));
    for (int i = 1; i < channels_count; i++)
    {
        if (i >= old_channels_count)
        {
            IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();
        }
        else
        {
            _Channels[i]._CmdBuffer.resize(0);
            _Channels[i]._IdxBuffer.resize(0);
        }
    }
}

void ImDrawListSplitter::Merge(ImDrawList* draw_list)
{
    // Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
    if (_Count <= 1)
        return;

    SetCurrentChannel(draw_list, 0);
    draw_list->_PopUnusedDrawCmd();

    // Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
    int new_cmd_buffer_count = 0;
    int new_idx_buffer_count = 0;
    ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;
    int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;
    for (int i = 1; i < _Count; i++)
    {
        ImDrawChannel& ch = _Channels[i];
        if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()
            ch._CmdBuffer.pop_back();

        if (ch._CmdBuffer.Size > 0 && last_cmd != NULL)
        {
            // Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.
            // Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.
            ImDrawCmd* next_cmd = &ch._CmdBuffer[0];
            if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL)
            {
                // Merge previous channel last draw command with current channel first draw command if matching.
                last_cmd->ElemCount += next_cmd->ElemCount;
                idx_offset += next_cmd->ElemCount;
                ch._CmdBuffer.erase(ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.
            }
        }
        if (ch._CmdBuffer.Size > 0)
            last_cmd = &ch._CmdBuffer.back();
        new_cmd_buffer_count += ch._CmdBuffer.Size;
        new_idx_buffer_count += ch._IdxBuffer.Size;
        for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++)
        {
            ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;
            idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;
        }
    }
    draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);
    draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

    // Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)
    ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;
    ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;
    for (int i = 1; i < _Count; i++)
    {
        ImDrawChannel& ch = _Channels[i];
        if (int sz = ch._CmdBuffer.Size) { memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }
        if (int sz = ch._IdxBuffer.Size) { memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx)); idx_write += sz; }
    }
    draw_list->_IdxWritePtr = idx_write;

    // Ensure there's always a non-callback draw command trailing the command-buffer
    if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)
        draw_list->AddDrawCmd();

    // If current command is used with different settings we need to add a new command
    ImDrawCmd* curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
    if (curr_cmd->ElemCount == 0)
        ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
    else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
        draw_list->AddDrawCmd();

    _Count = 1;
}

void ImDrawListSplitter::SetCurrentChannel(ImDrawList* draw_list, int idx)
{
    IM_ASSERT(idx >= 0 && idx < _Count);
    if (_Current == idx)
        return;

    // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
    memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));
    memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));
    _Current = idx;
    memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));
    memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));
    draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;

    // If current command is used with different settings we need to add a new command
    ImDrawCmd* curr_cmd = (draw_list->CmdBuffer.Size == 0) ? NULL : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
    if (curr_cmd == NULL)
        draw_list->AddDrawCmd();
    else if (curr_cmd->ElemCount == 0)
        ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset
    else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)
        draw_list->AddDrawCmd();
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawData
//-----------------------------------------------------------------------------

void ImDrawData::Clear()
{
    Valid = false;
    CmdListsCount = TotalIdxCount = TotalVtxCount = 0;
    CmdLists.resize(0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.
    DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.0f, 0.0f);
    OwnerViewport = NULL;
}

// Important: 'out_list' is generally going to be draw_data->CmdLists, but may be another temporary list
// as long at it is expected that the result will be later merged into draw_data->CmdLists[].
void ImGui::AddDrawListToDrawDataEx(ImDrawData* draw_data, ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
{
    if (draw_list->CmdBuffer.Size == 0)
        return;
    if (draw_list->CmdBuffer.Size == 1 && draw_list->CmdBuffer[0].ElemCount == 0 && draw_list->CmdBuffer[0].UserCallback == NULL)
        return;

    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
    // May trigger for you if you are using PrimXXX functions incorrectly.
    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
    if (!(draw_list->Flags & ImDrawListFlags_AllowVtxOffset))
        IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
    // If this assert triggers because you are drawing lots of stuff manually:
    // - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
    //   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
    // - If you want large meshes with more than 64K vertices, you can either:
    //   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
    //       Most example backends already support this from 1.71. Pre-1.71 backends won't.
    //       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
    //   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
    //       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
    //         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
    //       Your own engine or render API may use different parameters or function calls to specify index sizes.
    //       2 and 4 bytes indices are generally supported by most graphics API.
    // - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
    //   the 64K limit to split your draw commands in multiple draw lists.
    if (sizeof(ImDrawIdx) == 2)
        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && ""Too many vertices in ImDrawList using 16-bit indices. Read comment above"");

    // Resolve callback data pointers
    if (draw_list->_CallbacksDataBuf.Size > 0)
        for (ImDrawCmd& cmd : draw_list->CmdBuffer)
            if (cmd.UserCallback != NULL && cmd.UserCallbackDataOffset != -1 && cmd.UserCallbackDataSize > 0)
                cmd.UserCallbackData = draw_list->_CallbacksDataBuf.Data + cmd.UserCallbackDataOffset;

    // Add to output list + records state in ImDrawData
    out_list->push_back(draw_list);
    draw_data->CmdListsCount++;
    draw_data->TotalVtxCount += draw_list->VtxBuffer.Size;
    draw_data->TotalIdxCount += draw_list->IdxBuffer.Size;
}

void ImDrawData::AddDrawList(ImDrawList* draw_list)
{
    IM_ASSERT(CmdLists.Size == CmdListsCount);
    draw_list->_PopUnusedDrawCmd();
    ImGui::AddDrawListToDrawDataEx(this, &CmdLists, draw_list);
}

// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
void ImDrawData::DeIndexAllBuffers()
{
    ImVector<ImDrawVert> new_vtx_buffer;
    TotalVtxCount = TotalIdxCount = 0;
    for (int i = 0; i < CmdListsCount; i++)
    {
        ImDrawList* cmd_list = CmdLists[i];
        if (cmd_list->IdxBuffer.empty())
            continue;
        new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);
        for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)
            new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];
        cmd_list->VtxBuffer.swap(new_vtx_buffer);
        cmd_list->IdxBuffer.resize(0);
        TotalVtxCount += cmd_list->VtxBuffer.Size;
    }
}

// Helper to scale the ClipRect field of each ImDrawCmd.
// Use if your final output buffer is at a different scale than draw_data->DisplaySize,
// or if there is a difference between your window resolution and framebuffer resolution.
void ImDrawData::ScaleClipRects(const ImVec2& fb_scale)
{
    for (ImDrawList* draw_list : CmdLists)
        for (ImDrawCmd& cmd : draw_list->CmdBuffer)
            cmd.ClipRect = ImVec4(cmd.ClipRect.x * fb_scale.x, cmd.ClipRect.y * fb_scale.y, cmd.ClipRect.z * fb_scale.x, cmd.ClipRect.w * fb_scale.y);
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers ShadeVertsXXX functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)
{
    ImVec2 gradient_extent = gradient_p1 - gradient_p0;
    float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);
    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    const int col0_r = (int)(col0 >> IM_COL32_R_SHIFT) & 0xFF;
    const int col0_g = (int)(col0 >> IM_COL32_G_SHIFT) & 0xFF;
    const int col0_b = (int)(col0 >> IM_COL32_B_SHIFT) & 0xFF;
    const int col_delta_r = ((int)(col1 >> IM_COL32_R_SHIFT) & 0xFF) - col0_r;
    const int col_delta_g = ((int)(col1 >> IM_COL32_G_SHIFT) & 0xFF) - col0_g;
    const int col_delta_b = ((int)(col1 >> IM_COL32_B_SHIFT) & 0xFF) - col0_b;
    for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)
    {
        float d = ImDot(vert->pos - gradient_p0, gradient_extent);
        float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);
        int r = (int)(col0_r + col_delta_r * t);
        int g = (int)(col0_g + col_delta_g * t);
        int b = (int)(col0_b + col_delta_b * t);
        vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);
    }
}

// Distribute UV over (a, b) rectangle
void ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)
{
    const ImVec2 size = b - a;
    const ImVec2 uv_size = uv_b - uv_a;
    const ImVec2 scale = ImVec2(
        size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
        size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);

    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    if (clamp)
    {
        const ImVec2 min = ImMin(uv_a, uv_b);
        const ImVec2 max = ImMax(uv_a, uv_b);
        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
            vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);
    }
    else
    {
        for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
            vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);
    }
}

void ImGui::ShadeVertsTransformPos(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& pivot_in, float cos_a, float sin_a, const ImVec2& pivot_out)
{
    ImDrawVert* vert_start = draw_list->VtxBuffer.Data + vert_start_idx;
    ImDrawVert* vert_end = draw_list->VtxBuffer.Data + vert_end_idx;
    for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
        vertex->pos = ImRotate(vertex->pos- pivot_in, cos_a, sin_a) + pivot_out;
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontConfig
//-----------------------------------------------------------------------------

ImFontConfig::ImFontConfig()
{
    memset(this, 0, sizeof(*this));
    FontDataOwnedByAtlas = true;
    OversampleH = 0; // Auto == 1 or 2 depending on size
    OversampleV = 0; // Auto == 1
    GlyphMaxAdvanceX = FLT_MAX;
    RasterizerMultiply = 1.0f;
    RasterizerDensity = 1.0f;
    EllipsisChar = 0;
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas
//-----------------------------------------------------------------------------
// - Default texture data encoded in ASCII
// - ImFontAtlas::ClearInputData()
// - ImFontAtlas::ClearTexData()
// - ImFontAtlas::ClearFonts()
// - ImFontAtlas::Clear()
// - ImFontAtlas::GetTexDataAsAlpha8()
// - ImFontAtlas::GetTexDataAsRGBA32()
// - ImFontAtlas::AddFont()
// - ImFontAtlas::AddFontDefault()
// - ImFontAtlas::AddFontFromFileTTF()
// - ImFontAtlas::AddFontFromMemoryTTF()
// - ImFontAtlas::AddFontFromMemoryCompressedTTF()
// - ImFontAtlas::AddFontFromMemoryCompressedBase85TTF()
// - ImFontAtlas::AddCustomRectRegular()
// - ImFontAtlas::AddCustomRectFontGlyph()
// - ImFontAtlas::CalcCustomRectUV()
// - ImFontAtlasGetMouseCursorTexData()
// - ImFontAtlas::Build()
// - ImFontAtlasBuildMultiplyCalcLookupTable()
// - ImFontAtlasBuildMultiplyRectAlpha8()
// - ImFontAtlasBuildWithStbTruetype()
// - ImFontAtlasGetBuilderForStbTruetype()
// - ImFontAtlasUpdateConfigDataPointers()
// - ImFontAtlasBuildSetupFont()
// - ImFontAtlasBuildPackCustomRects()
// - ImFontAtlasBuildRender8bppRectFromString()
// - ImFontAtlasBuildRender32bppRectFromString()
// - ImFontAtlasBuildRenderDefaultTexData()
// - ImFontAtlasBuildRenderLinesTexData()
// - ImFontAtlasBuildInit()
// - ImFontAtlasBuildFinish()
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
// The 2x2 white texels on the top left are the ones we'll use everywhere in Dear ImGui to render filled shapes.
// (This is used when io.MouseDrawCursor = true)
const int FONT_ATLAS_DEFAULT_TEX_DATA_W = 122; // Actual texture will be 2 times that + 1 spacing.
const int FONT_ATLAS_DEFAULT_TEX_DATA_H = 27;
static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =
{
    ""..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          - XX       XX ""
    ""..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         -X..X     X..X""
    ""---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         -X...X   X...X""
    ""X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         - X...X X...X ""
    ""XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         -  X...X...X  ""
    ""X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       -   X.....X   ""
    ""X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    -    X...X    ""
    ""X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  -     X.X     ""
    ""X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X -    X...X    ""
    ""X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X-   X.....X   ""
    ""X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X-  X...X...X  ""
    ""X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X- X...X X...X ""
    ""X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X-X...X   X...X""
    ""X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X-X..X     X..X""
    ""X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X- XX       XX ""
    ""X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X--------------""
    ""X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X -             ""
    ""X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X -             ""
    ""X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X -             ""
    ""XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  -             ""
    ""      X..X  -       -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  -             ""
    ""       XX   -       -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  -             ""
    ""-------------       -    X    -           X           -X.....................X-           -------------------             ""
    ""                    ----------------------------------- X...XXXXXXXXXXXXX...X -                                           ""
    ""                                                      -  X..X           X..X  -                                           ""
    ""                                                      -   X.X           X.X   -                                           ""
    ""                                                      -    XX           XX    -                                           ""
};

static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =
{
    // Pos ........ Size ......... Offset ......
    { ImVec2( 0,3), ImVec2(12,19), ImVec2( 0, 0) }, // ImGuiMouseCursor_Arrow
    { ImVec2(13,0), ImVec2( 7,16), ImVec2( 1, 8) }, // ImGuiMouseCursor_TextInput
    { ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll
    { ImVec2(21,0), ImVec2( 9,23), ImVec2( 4,11) }, // ImGuiMouseCursor_ResizeNS
    { ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 4) }, // ImGuiMouseCursor_ResizeEW
    { ImVec2(73,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNESW
    { ImVec2(55,0), ImVec2(17,17), ImVec2( 8, 8) }, // ImGuiMouseCursor_ResizeNWSE
    { ImVec2(91,0), ImVec2(17,22), ImVec2( 5, 0) }, // ImGuiMouseCursor_Hand
    { ImVec2(0,3),  ImVec2(12,19), ImVec2(0, 0) },  // ImGuiMouseCursor_Wait       // Arrow + custom code in ImGui::RenderMouseCursor()
    { ImVec2(0,3),  ImVec2(12,19), ImVec2(0, 0) },  // ImGuiMouseCursor_Progress   // Arrow + custom code in ImGui::RenderMouseCursor()
    { ImVec2(109,0),ImVec2(13,15), ImVec2( 6, 7) }, // ImGuiMouseCursor_NotAllowed
};

ImFontAtlas::ImFontAtlas()
{
    memset(this, 0, sizeof(*this));
    TexGlyphPadding = 1;
    PackIdMouseCursors = PackIdLines = -1;
}

ImFontAtlas::~ImFontAtlas()
{
    IM_ASSERT(!Locked && ""Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!"");
    Clear();
}

void    ImFontAtlas::ClearInputData()
{
    IM_ASSERT(!Locked && ""Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!"");
    for (ImFontConfig& font_cfg : ConfigData)
        if (font_cfg.FontData && font_cfg.FontDataOwnedByAtlas)
        {
            IM_FREE(font_cfg.FontData);
            font_cfg.FontData = NULL;
        }

    // When clearing this we lose access to the font name and other information used to build the font.
    for (ImFont* font : Fonts)
        if (font->ConfigData >= ConfigData.Data && font->ConfigData < ConfigData.Data + ConfigData.Size)
        {
            font->ConfigData = NULL;
            font->ConfigDataCount = 0;
        }
    ConfigData.clear();
    CustomRects.clear();
    PackIdMouseCursors = PackIdLines = -1;
    // Important: we leave TexReady untouched
}

void    ImFontAtlas::ClearTexData()
{
    IM_ASSERT(!Locked && ""Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!"");
    if (TexPixelsAlpha8)
        IM_FREE(TexPixelsAlpha8);
    if (TexPixelsRGBA32)
        IM_FREE(TexPixelsRGBA32);
    TexPixelsAlpha8 = NULL;
    TexPixelsRGBA32 = NULL;
    TexPixelsUseColors = false;
    // Important: we leave TexReady untouched
}

void    ImFontAtlas::ClearFonts()
{
    IM_ASSERT(!Locked && ""Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!"");
    ClearInputData();
    Fonts.clear_delete();
    TexReady = false;
}

void    ImFontAtlas::Clear()
{
    ClearInputData();
    ClearTexData();
    ClearFonts();
}

void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
    // Build atlas on demand
    if (TexPixelsAlpha8 == NULL)
        Build();

    *out_pixels = TexPixelsAlpha8;
    if (out_width) *out_width = TexWidth;
    if (out_height) *out_height = TexHeight;
    if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
}

void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
    // Convert to RGBA32 format on demand
    // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
    if (!TexPixelsRGBA32)
    {
        unsigned char* pixels = NULL;
        GetTexDataAsAlpha8(&pixels, NULL, NULL);
        if (pixels)
        {
            TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);
            const unsigned char* src = pixels;
            unsigned int* dst = TexPixelsRGBA32;
            for (int n = TexWidth * TexHeight; n > 0; n--)
                *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
        }
    }

    *out_pixels = (unsigned char*)TexPixelsRGBA32;
    if (out_width) *out_width = TexWidth;
    if (out_height) *out_height = TexHeight;
    if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
}

ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)
{
    IM_ASSERT(!Locked && ""Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!"");
    IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
    IM_ASSERT(font_cfg->SizePixels > 0.0f && ""Is ImFontConfig struct correctly initialized?"");
    IM_ASSERT(font_cfg->RasterizerDensity > 0.0f && ""Is ImFontConfig struct correctly initialized?"");

    // Create new font
    if (!font_cfg->MergeMode)
        Fonts.push_back(IM_NEW(ImFont));
    else
        IM_ASSERT(Fonts.Size > 0 && ""Cannot use MergeMode for the first font""); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

    ConfigData.push_back(*font_cfg);
    ImFontConfig& new_font_cfg = ConfigData.back();
    if (new_font_cfg.DstFont == NULL)
        new_font_cfg.DstFont = Fonts.back();
    if (!new_font_cfg.FontDataOwnedByAtlas)
    {
        new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);
        new_font_cfg.FontDataOwnedByAtlas = true;
        memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
    }

    // Round font size
    // - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.
    // - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.
    // - We may support it better later and remove this rounding.
    new_font_cfg.SizePixels = ImTrunc(new_font_cfg.SizePixels);

    // Pointers to ConfigData and BuilderData are otherwise dangling
    ImFontAtlasUpdateConfigDataPointers(this);

    // Invalidate texture
    TexReady = false;
    ClearTexData();
    return new_font_cfg.DstFont;
}

// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
static unsigned int stb_decompress_length(const unsigned char* input);
static unsigned int stb_decompress(unsigned char* output, const unsigned char* input, unsigned int length);
static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }
static void         Decode85(const unsigned char* src, unsigned char* dst)
{
    while (*src)
    {
        unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
        dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
        src += 5;
        dst += 4;
    }
}
#ifndef IMGUI_DISABLE_DEFAULT_FONT
static const char* GetDefaultCompressedFontDataTTF(int* out_size);
#endif

// Load embedded ProggyClean.ttf at size 13, disable oversampling
ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)
{
#ifndef IMGUI_DISABLE_DEFAULT_FONT
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    if (!font_cfg_template)
    {
        font_cfg.OversampleH = font_cfg.OversampleV = 1;
        font_cfg.PixelSnapH = true;
    }
    if (font_cfg.SizePixels <= 0.0f)
        font_cfg.SizePixels = 13.0f * 1.0f;
    if (font_cfg.Name[0] == '\0')
        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), ""ProggyClean.ttf, %dpx"", (int)font_cfg.SizePixels);
    font_cfg.EllipsisChar = (ImWchar)0x0085;
    font_cfg.GlyphOffset.y = 1.0f * IM_TRUNC(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

    int ttf_compressed_size = 0;
    const char* ttf_compressed = GetDefaultCompressedFontDataTTF(&ttf_compressed_size);
    const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();
    ImFont* font = AddFontFromMemoryCompressedTTF(ttf_compressed, ttf_compressed_size, font_cfg.SizePixels, &font_cfg, glyph_ranges);
    return font;
#else
    IM_ASSERT(0 && ""AddFontDefault() disabled in this build."");
    IM_UNUSED(font_cfg_template);
    return NULL;
#endif // #ifndef IMGUI_DISABLE_DEFAULT_FONT
}

ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    IM_ASSERT(!Locked && ""Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!"");
    size_t data_size = 0;
    void* data = ImFileLoadToMemory(filename, ""rb"", &data_size, 0);
    if (!data)
    {
        IM_ASSERT_USER_ERROR(0, ""Could not load font file!"");
        return NULL;
    }
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    if (font_cfg.Name[0] == '\0')
    {
        // Store a short copy of filename into into the font name for convenience
        const char* p;
        for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}
        ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), ""%s, %.0fpx"", p, size_pixels);
    }
    return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);
}

// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* font_data, int font_data_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    IM_ASSERT(!Locked && ""Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!"");
    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    IM_ASSERT(font_cfg.FontData == NULL);
    IM_ASSERT(font_data_size > 100 && ""Incorrect value for font_data_size!""); // Heuristic to prevent accidentally passing a wrong value to font_data_size.
    font_cfg.FontData = font_data;
    font_cfg.FontDataSize = font_data_size;
    font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;
    if (glyph_ranges)
        font_cfg.GlyphRanges = glyph_ranges;
    return AddFont(&font_cfg);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
    const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
    unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);
    stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);

    ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
    IM_ASSERT(font_cfg.FontData == NULL);
    font_cfg.FontDataOwnedByAtlas = true;
    return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
{
    int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
    void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);
    Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
    ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
    IM_FREE(compressed_ttf);
    return font;
}

int ImFontAtlas::AddCustomRectRegular(int width, int height)
{
    IM_ASSERT(width > 0 && width <= 0xFFFF);
    IM_ASSERT(height > 0 && height <= 0xFFFF);
    ImFontAtlasCustomRect r;
    r.Width = (unsigned short)width;
    r.Height = (unsigned short)height;
    CustomRects.push_back(r);
    return CustomRects.Size - 1; // Return index
}

int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
{
#ifdef IMGUI_USE_WCHAR32
    IM_ASSERT(id <= IM_UNICODE_CODEPOINT_MAX);
#endif
    IM_ASSERT(font != NULL);
    IM_ASSERT(width > 0 && width <= 0xFFFF);
    IM_ASSERT(height > 0 && height <= 0xFFFF);
    ImFontAtlasCustomRect r;
    r.Width = (unsigned short)width;
    r.Height = (unsigned short)height;
    r.GlyphID = id;
    r.GlyphColored = 0; // Set to 1 manually to mark glyph as colored // FIXME: No official API for that (#8133)
    r.GlyphAdvanceX = advance_x;
    r.GlyphOffset = offset;
    r.Font = font;
    CustomRects.push_back(r);
    return CustomRects.Size - 1; // Return index
}

void ImFontAtlas::CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const
{
    IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
    IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
    *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);
    *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);
}

bool ImFontAtlasGetMouseCursorTexData(ImFontAtlas* atlas, ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])
{
    if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)
        return false;
    if (atlas->Flags & ImFontAtlasFlags_NoMouseCursors)
        return false;

    IM_ASSERT(atlas->PackIdMouseCursors != -1);
    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
    ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);
    ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
    *out_size = size;
    *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
    out_uv_border[0] = (pos) * atlas->TexUvScale;
    out_uv_border[1] = (pos + size) * atlas->TexUvScale;
    pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
    out_uv_fill[0] = (pos) * atlas->TexUvScale;
    out_uv_fill[1] = (pos + size) * atlas->TexUvScale;
    return true;
}

bool    ImFontAtlas::Build()
{
    IM_ASSERT(!Locked && ""Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!"");

    // Default font is none are specified
    if (ConfigData.Size == 0)
        AddFontDefault();

    // Select builder
    // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
    //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
    //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
    //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
    const ImFontBuilderIO* builder_io = FontBuilderIO;
    if (builder_io == NULL)
    {
#ifdef IMGUI_ENABLE_FREETYPE
        builder_io = ImGuiFreeType::GetBuilderForFreeType();
#elif defined(IMGUI_ENABLE_STB_TRUETYPE)
        builder_io = ImFontAtlasGetBuilderForStbTruetype();
#else
        IM_ASSERT(0); // Invalid Build function
#endif
    }

    // Build
    return builder_io->FontBuilder_Build(this);
}

void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
{
    for (unsigned int i = 0; i < 256; i++)
    {
        unsigned int value = (unsigned int)(i * in_brighten_factor);
        out_table[i] = value > 255 ? 255 : (value & 0xFF);
    }
}

void    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)
{
    IM_ASSERT_PARANOID(w <= stride);
    unsigned char* data = pixels + x + y * stride;
    for (int j = h; j > 0; j--, data += stride - w)
        for (int i = w; i > 0; i--, data++)
            *data = table[*data];
}

void ImFontAtlasBuildGetOversampleFactors(const ImFontConfig* cfg, int* out_oversample_h, int* out_oversample_v)
{
    // Automatically disable horizontal oversampling over size 36
    *out_oversample_h = (cfg->OversampleH != 0) ? cfg->OversampleH : (cfg->SizePixels * cfg->RasterizerDensity > 36.0f || cfg->PixelSnapH) ? 1 : 2;
    *out_oversample_v = (cfg->OversampleV != 0) ? cfg->OversampleV : 1;
}

#ifdef IMGUI_ENABLE_STB_TRUETYPE
// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)
// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)
struct ImFontBuildSrcData
{
    stbtt_fontinfo      FontInfo;
    stbtt_pack_range    PackRange;          // Hold the list of codepoints to pack (essentially points to Codepoints.Data)
    stbrp_rect*         Rects;              // Rectangle to pack. We first fill in their size and the packer will give us their position.
    stbtt_packedchar*   PackedChars;        // Output glyphs
    const ImWchar*      SrcRanges;          // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)
    int                 DstIndex;           // Index into atlas->Fonts[] and dst_tmp_array[]
    int                 GlyphsHighest;      // Highest requested codepoint
    int                 GlyphsCount;        // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)
    ImBitVector         GlyphsSet;          // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)
    ImVector<int>       GlyphsList;         // Glyph codepoints list (flattened version of GlyphsSet)
};

// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)
struct ImFontBuildDstData
{
    int                 SrcCount;           // Number of source fonts targeting this destination font.
    int                 GlyphsHighest;
    int                 GlyphsCount;
    ImBitVector         GlyphsSet;          // This is used to resolve collision when multiple sources are merged into a same destination font.
};

static void UnpackBitVectorToFlatIndexList(const ImBitVector* in, ImVector<int>* out)
{
    IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
    const ImU32* it_begin = in->Storage.begin();
    const ImU32* it_end = in->Storage.end();
    for (const ImU32* it = it_begin; it < it_end; it++)
        if (ImU32 entries_32 = *it)
            for (ImU32 bit_n = 0; bit_n < 32; bit_n++)
                if (entries_32 & ((ImU32)1 << bit_n))
                    out->push_back((int)(((it - it_begin) << 5) + bit_n));
}

static bool ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)
{
    IM_ASSERT(atlas->ConfigData.Size > 0);

    ImFontAtlasBuildInit(atlas);

    // Clear atlas
    atlas->TexID = (ImTextureID)NULL;
    atlas->TexWidth = atlas->TexHeight = 0;
    atlas->TexUvScale = ImVec2(0.0f, 0.0f);
    atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
    atlas->ClearTexData();

    // Temporary storage for building
    ImVector<ImFontBuildSrcData> src_tmp_array;
    ImVector<ImFontBuildDstData> dst_tmp_array;
    src_tmp_array.resize(atlas->ConfigData.Size);
    dst_tmp_array.resize(atlas->Fonts.Size);
    memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());
    memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

    // 1. Initialize font loading structure, check font data validity
    for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

        // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
        src_tmp.DstIndex = -1;
        for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)
            if (cfg.DstFont == atlas->Fonts[output_i])
                src_tmp.DstIndex = output_i;
        if (src_tmp.DstIndex == -1)
        {
            IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?
            return false;
        }
        // Initialize helper structure for font loading and verify that the TTF/OTF data is correct
        const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
        IM_ASSERT(font_offset >= 0 && ""FontData is incorrect, or FontNo cannot be found."");
        if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
        {
            IM_ASSERT(0 && ""stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize."");
            return false;
        }

        // Measure highest codepoints
        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
        src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();
        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
        {
            // Check for valid range. This may also help detect *some* dangling pointers, because a common
            // user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent,
            // or to forget to zero-terminate the glyph range array.
            IM_ASSERT(src_range[0] <= src_range[1] && ""Invalid range: is your glyph range array persistent? it is zero-terminated?"");
            src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);
        }
        dst_tmp.SrcCount++;
        dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);
    }

    // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
    int total_glyphs_count = 0;
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];
        src_tmp.GlyphsSet.Create(src_tmp.GlyphsHighest + 1);
        if (dst_tmp.GlyphsSet.Storage.empty())
            dst_tmp.GlyphsSet.Create(dst_tmp.GlyphsHighest + 1);

        for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)
            for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)
            {
                if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
                    continue;
                if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?
                    continue;

                // Add to avail set/counters
                src_tmp.GlyphsCount++;
                dst_tmp.GlyphsCount++;
                src_tmp.GlyphsSet.SetBit(codepoint);
                dst_tmp.GlyphsSet.SetBit(codepoint);
                total_glyphs_count++;
            }
    }

    // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);
        UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList);
        src_tmp.GlyphsSet.Clear();
        IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);
    }
    for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)
        dst_tmp_array[dst_i].GlyphsSet.Clear();
    dst_tmp_array.clear();

    // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
    // (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
    ImVector<stbrp_rect> buf_rects;
    ImVector<stbtt_packedchar> buf_packedchars;
    buf_rects.resize(total_glyphs_count);
    buf_packedchars.resize(total_glyphs_count);
    memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());
    memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

    // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
    int total_surface = 0;
    int buf_rects_out_n = 0;
    int buf_packedchars_out_n = 0;
    const int pack_padding = atlas->TexGlyphPadding;
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        src_tmp.Rects = &buf_rects[buf_rects_out_n];
        src_tmp.PackedChars = &buf_packedchars[buf_packedchars_out_n];
        buf_rects_out_n += src_tmp.GlyphsCount;
        buf_packedchars_out_n += src_tmp.GlyphsCount;

        // Automatic selection of oversampling parameters
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        int oversample_h, oversample_v;
        ImFontAtlasBuildGetOversampleFactors(&cfg, &oversample_h, &oversample_v);

        // Convert our ranges in the format stb_truetype wants
        src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity;
        src_tmp.PackRange.first_unicode_codepoint_in_range = 0;
        src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;
        src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;
        src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;
        src_tmp.PackRange.h_oversample = (unsigned char)oversample_h;
        src_tmp.PackRange.v_oversample = (unsigned char)oversample_v;

        // Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
        const float scale = (cfg.SizePixels > 0.0f) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels * cfg.RasterizerDensity) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity);
        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)
        {
            int x0, y0, x1, y1;
            const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);
            IM_ASSERT(glyph_index_in_font != 0);
            stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * oversample_h, scale * oversample_v, 0, 0, &x0, &y0, &x1, &y1);
            src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + pack_padding + oversample_h - 1);
            src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + pack_padding + oversample_v - 1);
            total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;
        }
    }
    for (int i = 0; i < atlas->CustomRects.Size; i++)
        total_surface += (atlas->CustomRects[i].Width + pack_padding) * (atlas->CustomRects[i].Height + pack_padding);

    // We need a width for the skyline algorithm, any width!
    // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
    // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
    const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;
    atlas->TexHeight = 0;
    if (atlas->TexDesiredWidth > 0)
        atlas->TexWidth = atlas->TexDesiredWidth;
    else
        atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;

    // 5. Start packing
    // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
    const int TEX_HEIGHT_MAX = 1024 * 32;
    stbtt_pack_context spc = {};
    stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, 0, NULL);
    spc.padding = atlas->TexGlyphPadding; // Because we mixup stbtt_PackXXX and stbrp_PackXXX there's a bit of a hack here, not passing the value to stbtt_PackBegin() allows us to still pack a TexWidth-1 wide item. (#8107)
    ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

    // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

        // Extend texture height and mark missing glyphs as non-packed so we won't render them.
        // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
            if (src_tmp.Rects[glyph_i].was_packed)
                atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);
    }

    // 7. Allocate texture
    atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
    atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
    atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);
    memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
    spc.pixels = atlas->TexPixelsAlpha8;
    spc.height = atlas->TexHeight;

    // 8. Render/rasterize font characters into the texture
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        if (src_tmp.GlyphsCount == 0)
            continue;

        stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);

        // Apply multiply operator
        if (cfg.RasterizerMultiply != 1.0f)
        {
            unsigned char multiply_table[256];
            ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
            stbrp_rect* r = &src_tmp.Rects[0];
            for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)
                if (r->was_packed)
                    ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);
        }
        src_tmp.Rects = NULL;
    }

    // End packing
    stbtt_PackEnd(&spc);
    buf_rects.clear();

    // 9. Setup ImFont and glyphs for runtime
    for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)
    {
        // When merging fonts with MergeMode=true:
        // - We can have multiple input fonts writing into a same destination font.
        // - dst_font->ConfigData is != from cfg which is our source configuration.
        ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
        ImFontConfig& cfg = atlas->ConfigData[src_i];
        ImFont* dst_font = cfg.DstFont;

        const float font_scale = stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels);
        int unscaled_ascent, unscaled_descent, unscaled_line_gap;
        stbtt_GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

        const float ascent = ImCeil(unscaled_ascent * font_scale);
        const float descent = ImFloor(unscaled_descent * font_scale);
        ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
        const float font_off_x = cfg.GlyphOffset.x;
        const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);

        const float inv_rasterization_scale = 1.0f / cfg.RasterizerDensity;

        for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)
        {
            // Register glyph
            const int codepoint = src_tmp.GlyphsList[glyph_i];
            const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];
            stbtt_aligned_quad q;
            float unused_x = 0.0f, unused_y = 0.0f;
            stbtt_GetPackedQuad(src_tmp.PackedChars, atlas->TexWidth, atlas->TexHeight, glyph_i, &unused_x, &unused_y, &q, 0);
            float x0 = q.x0 * inv_rasterization_scale + font_off_x;
            float y0 = q.y0 * inv_rasterization_scale + font_off_y;
            float x1 = q.x1 * inv_rasterization_scale + font_off_x;
            float y1 = q.y1 * inv_rasterization_scale + font_off_y;
            dst_font->AddGlyph(&cfg, (ImWchar)codepoint, x0, y0, x1, y1, q.s0, q.t0, q.s1, q.t1, pc.xadvance * inv_rasterization_scale);
        }
    }

    // Cleanup
    src_tmp_array.clear_destruct();

    ImFontAtlasBuildFinish(atlas);
    return true;
}

const ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype()
{
    static ImFontBuilderIO io;
    io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;
    return &io;
}

#endif // IMGUI_ENABLE_STB_TRUETYPE

void ImFontAtlasUpdateConfigDataPointers(ImFontAtlas* atlas)
{
    for (ImFontConfig& font_cfg : atlas->ConfigData)
    {
        ImFont* font = font_cfg.DstFont;
        if (!font_cfg.MergeMode)
        {
            font->ConfigData = &font_cfg;
            font->ConfigDataCount = 0;
        }
        font->ConfigDataCount++;
    }
}

void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)
{
    if (!font_config->MergeMode)
    {
        font->ClearOutputData();
        font->FontSize = font_config->SizePixels;
        IM_ASSERT(font->ConfigData == font_config);
        font->ContainerAtlas = atlas;
        font->Ascent = ascent;
        font->Descent = descent;
    }
}

void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)
{
    stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
    IM_ASSERT(pack_context != NULL);

    ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
    IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.
#ifdef __GNUC__
    if (user_rects.Size < 1) { __builtin_unreachable(); } // Workaround for GCC bug if IM_ASSERT() is defined to conditionally throw (see #5343)
#endif

    const int pack_padding = atlas->TexGlyphPadding;
    ImVector<stbrp_rect> pack_rects;
    pack_rects.resize(user_rects.Size);
    memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());
    for (int i = 0; i < user_rects.Size; i++)
    {
        pack_rects[i].w = user_rects[i].Width + pack_padding;
        pack_rects[i].h = user_rects[i].Height + pack_padding;
    }
    stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
    for (int i = 0; i < pack_rects.Size; i++)
        if (pack_rects[i].was_packed)
        {
            user_rects[i].X = (unsigned short)pack_rects[i].x;
            user_rects[i].Y = (unsigned short)pack_rects[i].y;
            IM_ASSERT(pack_rects[i].w == user_rects[i].Width + pack_padding && pack_rects[i].h == user_rects[i].Height + pack_padding);
            atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
        }
}

void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value)
{
    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
    unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);
    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
        for (int off_x = 0; off_x < w; off_x++)
            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;
}

void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value)
{
    IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);
    IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);
    unsigned int* out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);
    for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)
        for (int off_x = 0; off_x < w; off_x++)
            out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS;
}

static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)
{
    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);
    IM_ASSERT(r->IsPacked());

    const int w = atlas->TexWidth;
    if (atlas->Flags & ImFontAtlasFlags_NoMouseCursors)
    {
        // White pixels only
        IM_ASSERT(r->Width == 2 && r->Height == 2);
        const int offset = (int)r->X + (int)r->Y * w;
        if (atlas->TexPixelsAlpha8 != NULL)
        {
            atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
        }
        else
        {
            atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;
        }
    }
    else
    {
        // White pixels and mouse cursor
        IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
        const int x_for_white = r->X;
        const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
        if (atlas->TexPixelsAlpha8 != NULL)
        {
            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);
            ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);
        }
        else
        {
            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);
            ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);
        }
    }
    atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);
}

static void ImFontAtlasBuildRenderLinesTexData(ImFontAtlas* atlas)
{
    if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)
        return;

    // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
    ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);
    IM_ASSERT(r->IsPacked());
    for (int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row
    {
        // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
        int y = n;
        int line_width = n;
        int pad_left = (r->Width - line_width) / 2;
        int pad_right = r->Width - (pad_left + line_width);

        // Write each slice
        IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels
        if (atlas->TexPixelsAlpha8 != NULL)
        {
            unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];
            for (int i = 0; i < pad_left; i++)
                *(write_ptr + i) = 0x00;

            for (int i = 0; i < line_width; i++)
                *(write_ptr + pad_left + i) = 0xFF;

            for (int i = 0; i < pad_right; i++)
                *(write_ptr + pad_left + line_width + i) = 0x00;
        }
        else
        {
            unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];
            for (int i = 0; i < pad_left; i++)
                *(write_ptr + i) = IM_COL32(255, 255, 255, 0);

            for (int i = 0; i < line_width; i++)
                *(write_ptr + pad_left + i) = IM_COL32_WHITE;

            for (int i = 0; i < pad_right; i++)
                *(write_ptr + pad_left + line_width + i) = IM_COL32(255, 255, 255, 0);
        }

        // Calculate UVs for this line
        ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;
        ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;
        float half_v = (uv0.y + uv1.y) * 0.5f; // Calculate a constant V in the middle of the row to avoid sampling artifacts
        atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);
    }
}

// Note: this is called / shared by both the stb_truetype and the FreeType builder
void ImFontAtlasBuildInit(ImFontAtlas* atlas)
{
    // Register texture region for mouse cursors or standard white pixels
    if (atlas->PackIdMouseCursors < 0)
    {
        if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
        else
            atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);
    }

    // Register texture region for thick lines
    // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
    if (atlas->PackIdLines < 0)
    {
        if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))
            atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);
    }
}

// This is called/shared by both the stb_truetype and the FreeType builder.
void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
{
    // Render into our custom data blocks
    IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);
    ImFontAtlasBuildRenderDefaultTexData(atlas);
    ImFontAtlasBuildRenderLinesTexData(atlas);

    // Register custom rectangle glyphs
    for (int i = 0; i < atlas->CustomRects.Size; i++)
    {
        const ImFontAtlasCustomRect* r = &atlas->CustomRects[i];
        if (r->Font == NULL || r->GlyphID == 0)
            continue;

        // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, PixelSnapH
        IM_ASSERT(r->Font->ContainerAtlas == atlas);
        ImVec2 uv0, uv1;
        atlas->CalcCustomRectUV(r, &uv0, &uv1);
        r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);
        if (r->GlyphColored)
            r->Font->Glyphs.back().Colored = 1;
    }

    // Build all fonts lookup tables
    for (ImFont* font : atlas->Fonts)
        if (font->DirtyLookupTables)
            font->BuildLookupTable();

    atlas->TexReady = true;
}

//-------------------------------------------------------------------------
// [SECTION] ImFontAtlas: glyph ranges helpers
//-------------------------------------------------------------------------
// - GetGlyphRangesDefault()
// - GetGlyphRangesGreek()
// - GetGlyphRangesKorean()
// - GetGlyphRangesChineseFull()
// - GetGlyphRangesChineseSimplifiedCommon()
// - GetGlyphRangesJapanese()
// - GetGlyphRangesCyrillic()
// - GetGlyphRangesThai()
// - GetGlyphRangesVietnamese()
//-----------------------------------------------------------------------------

// Retrieve list of range (2 int per range, values are inclusive)
const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0,
    };
    return &ranges[0];
}

const ImWchar*   ImFontAtlas::GetGlyphRangesGreek()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x0370, 0x03FF, // Greek and Coptic
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3131, 0x3163, // Korean alphabets
        0xAC00, 0xD7A3, // Korean characters
        0xFFFD, 0xFFFD, // Invalid
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x2000, 0x206F, // General Punctuation
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
        0xFFFD, 0xFFFD, // Invalid
        0x4e00, 0x9FAF, // CJK Ideograms
        0,
    };
    return &ranges[0];
}

static void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)
{
    for (int n = 0; n < accumulative_offsets_count; n++, out_ranges += 2)
    {
        out_ranges[0] = out_ranges[1] = (ImWchar)(base_codepoint + accumulative_offsets[n]);
        base_codepoint += accumulative_offsets[n];
    }
    out_ranges[0] = 0;
}

const ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()
{
    // Store 2500 regularly used characters for Simplified Chinese.
    // Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
    // This table covers 97.97% of all characters used during the month in July, 1987.
    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
    static const short accumulative_offsets_from_0x4E00[] =
    {
        0,1,2,4,1,1,1,1,2,1,3,2,1,2,2,1,1,1,1,1,5,2,1,2,3,3,3,2,2,4,1,1,1,2,1,5,2,3,1,2,1,2,1,1,2,1,1,2,2,1,4,1,1,1,1,5,10,1,2,19,2,1,2,1,2,1,2,1,2,
        1,5,1,6,3,2,1,2,2,1,1,1,4,8,5,1,1,4,1,1,3,1,2,1,5,1,2,1,1,1,10,1,1,5,2,4,6,1,4,2,2,2,12,2,1,1,6,1,1,1,4,1,1,4,6,5,1,4,2,2,4,10,7,1,1,4,2,4,
        2,1,4,3,6,10,12,5,7,2,14,2,9,1,1,6,7,10,4,7,13,1,5,4,8,4,1,1,2,28,5,6,1,1,5,2,5,20,2,2,9,8,11,2,9,17,1,8,6,8,27,4,6,9,20,11,27,6,68,2,2,1,1,
        1,2,1,2,2,7,6,11,3,3,1,1,3,1,2,1,1,1,1,1,3,1,1,8,3,4,1,5,7,2,1,4,4,8,4,2,1,2,1,1,4,5,6,3,6,2,12,3,1,3,9,2,4,3,4,1,5,3,3,1,3,7,1,5,1,1,1,1,2,
        3,4,5,2,3,2,6,1,1,2,1,7,1,7,3,4,5,15,2,2,1,5,3,22,19,2,1,1,1,1,2,5,1,1,1,6,1,1,12,8,2,9,18,22,4,1,1,5,1,16,1,2,7,10,15,1,1,6,2,4,1,2,4,1,6,
        1,1,3,2,4,1,6,4,5,1,2,1,1,2,1,10,3,1,3,2,1,9,3,2,5,7,2,19,4,3,6,1,1,1,1,1,4,3,2,1,1,1,2,5,3,1,1,1,2,2,1,1,2,1,1,2,1,3,1,1,1,3,7,1,4,1,1,2,1,
        1,2,1,2,4,4,3,8,1,1,1,2,1,3,5,1,3,1,3,4,6,2,2,14,4,6,6,11,9,1,15,3,1,28,5,2,5,5,3,1,3,4,5,4,6,14,3,2,3,5,21,2,7,20,10,1,2,19,2,4,28,28,2,3,
        2,1,14,4,1,26,28,42,12,40,3,52,79,5,14,17,3,2,2,11,3,4,6,3,1,8,2,23,4,5,8,10,4,2,7,3,5,1,1,6,3,1,2,2,2,5,28,1,1,7,7,20,5,3,29,3,17,26,1,8,4,
        27,3,6,11,23,5,3,4,6,13,24,16,6,5,10,25,35,7,3,2,3,3,14,3,6,2,6,1,4,2,3,8,2,1,1,3,3,3,4,1,1,13,2,2,4,5,2,1,14,14,1,2,2,1,4,5,2,3,1,14,3,12,
        3,17,2,16,5,1,2,1,8,9,3,19,4,2,2,4,17,25,21,20,28,75,1,10,29,103,4,1,2,1,1,4,2,4,1,2,3,24,2,2,2,1,1,2,1,3,8,1,1,1,2,1,1,3,1,1,1,6,1,5,3,1,1,
        1,3,4,1,1,5,2,1,5,6,13,9,16,1,1,1,1,3,2,3,2,4,5,2,5,2,2,3,7,13,7,2,2,1,1,1,1,2,3,3,2,1,6,4,9,2,1,14,2,14,2,1,18,3,4,14,4,11,41,15,23,15,23,
        176,1,3,4,1,1,1,1,5,3,1,2,3,7,3,1,1,2,1,2,4,4,6,2,4,1,9,7,1,10,5,8,16,29,1,1,2,2,3,1,3,5,2,4,5,4,1,1,2,2,3,3,7,1,6,10,1,17,1,44,4,6,2,1,1,6,
        5,4,2,10,1,6,9,2,8,1,24,1,2,13,7,8,8,2,1,4,1,3,1,3,3,5,2,5,10,9,4,9,12,2,1,6,1,10,1,1,7,7,4,10,8,3,1,13,4,3,1,6,1,3,5,2,1,2,17,16,5,2,16,6,
        1,4,2,1,3,3,6,8,5,11,11,1,3,3,2,4,6,10,9,5,7,4,7,4,7,1,1,4,2,1,3,6,8,7,1,6,11,5,5,3,24,9,4,2,7,13,5,1,8,82,16,61,1,1,1,4,2,2,16,10,3,8,1,1,
        6,4,2,1,3,1,1,1,4,3,8,4,2,2,1,1,1,1,1,6,3,5,1,1,4,6,9,2,1,1,1,2,1,7,2,1,6,1,5,4,4,3,1,8,1,3,3,1,3,2,2,2,2,3,1,6,1,2,1,2,1,3,7,1,8,2,1,2,1,5,
        2,5,3,5,10,1,2,1,1,3,2,5,11,3,9,3,5,1,1,5,9,1,2,1,5,7,9,9,8,1,3,3,3,6,8,2,3,2,1,1,32,6,1,2,15,9,3,7,13,1,3,10,13,2,14,1,13,10,2,1,3,10,4,15,
        2,15,15,10,1,3,9,6,9,32,25,26,47,7,3,2,3,1,6,3,4,3,2,8,5,4,1,9,4,2,2,19,10,6,2,3,8,1,2,2,4,2,1,9,4,4,4,6,4,8,9,2,3,1,1,1,1,3,5,5,1,3,8,4,6,
        2,1,4,12,1,5,3,7,13,2,5,8,1,6,1,2,5,14,6,1,5,2,4,8,15,5,1,23,6,62,2,10,1,1,8,1,2,2,10,4,2,2,9,2,1,1,3,2,3,1,5,3,3,2,1,3,8,1,1,1,11,3,1,1,4,
        3,7,1,14,1,2,3,12,5,2,5,1,6,7,5,7,14,11,1,3,1,8,9,12,2,1,11,8,4,4,2,6,10,9,13,1,1,3,1,5,1,3,2,4,4,1,18,2,3,14,11,4,29,4,2,7,1,3,13,9,2,2,5,
        3,5,20,7,16,8,5,72,34,6,4,22,12,12,28,45,36,9,7,39,9,191,1,1,1,4,11,8,4,9,2,3,22,1,1,1,1,4,17,1,7,7,1,11,31,10,2,4,8,2,3,2,1,4,2,16,4,32,2,
        3,19,13,4,9,1,5,2,14,8,1,1,3,6,19,6,5,1,16,6,2,10,8,5,1,2,3,1,5,5,1,11,6,6,1,3,3,2,6,3,8,1,1,4,10,7,5,7,7,5,8,9,2,1,3,4,1,1,3,1,3,3,2,6,16,
        1,4,6,3,1,10,6,1,3,15,2,9,2,10,25,13,9,16,6,2,2,10,11,4,3,9,1,2,6,6,5,4,30,40,1,10,7,12,14,33,6,3,6,7,3,1,3,1,11,14,4,9,5,12,11,49,18,51,31,
        140,31,2,2,1,5,1,8,1,10,1,4,4,3,24,1,10,1,3,6,6,16,3,4,5,2,1,4,2,57,10,6,22,2,22,3,7,22,6,10,11,36,18,16,33,36,2,5,5,1,1,1,4,10,1,4,13,2,7,
        5,2,9,3,4,1,7,43,3,7,3,9,14,7,9,1,11,1,1,3,7,4,18,13,1,14,1,3,6,10,73,2,2,30,6,1,11,18,19,13,22,3,46,42,37,89,7,3,16,34,2,2,3,9,1,7,1,1,1,2,
        2,4,10,7,3,10,3,9,5,28,9,2,6,13,7,3,1,3,10,2,7,2,11,3,6,21,54,85,2,1,4,2,2,1,39,3,21,2,2,5,1,1,1,4,1,1,3,4,15,1,3,2,4,4,2,3,8,2,20,1,8,7,13,
        4,1,26,6,2,9,34,4,21,52,10,4,4,1,5,12,2,11,1,7,2,30,12,44,2,30,1,1,3,6,16,9,17,39,82,2,2,24,7,1,7,3,16,9,14,44,2,1,2,1,2,3,5,2,4,1,6,7,5,3,
        2,6,1,11,5,11,2,1,18,19,8,1,3,24,29,2,1,3,5,2,2,1,13,6,5,1,46,11,3,5,1,1,5,8,2,10,6,12,6,3,7,11,2,4,16,13,2,5,1,1,2,2,5,2,28,5,2,23,10,8,4,
        4,22,39,95,38,8,14,9,5,1,13,5,4,3,13,12,11,1,9,1,27,37,2,5,4,4,63,211,95,2,2,2,1,3,5,2,1,1,2,2,1,1,1,3,2,4,1,2,1,1,5,2,2,1,1,2,3,1,3,1,1,1,
        3,1,4,2,1,3,6,1,1,3,7,15,5,3,2,5,3,9,11,4,2,22,1,6,3,8,7,1,4,28,4,16,3,3,25,4,4,27,27,1,4,1,2,2,7,1,3,5,2,28,8,2,14,1,8,6,16,25,3,3,3,14,3,
        3,1,1,2,1,4,6,3,8,4,1,1,1,2,3,6,10,6,2,3,18,3,2,5,5,4,3,1,5,2,5,4,23,7,6,12,6,4,17,11,9,5,1,1,10,5,12,1,1,11,26,33,7,3,6,1,17,7,1,5,12,1,11,
        2,4,1,8,14,17,23,1,2,1,7,8,16,11,9,6,5,2,6,4,16,2,8,14,1,11,8,9,1,1,1,9,25,4,11,19,7,2,15,2,12,8,52,7,5,19,2,16,4,36,8,1,16,8,24,26,4,6,2,9,
        5,4,36,3,28,12,25,15,37,27,17,12,59,38,5,32,127,1,2,9,17,14,4,1,2,1,1,8,11,50,4,14,2,19,16,4,17,5,4,5,26,12,45,2,23,45,104,30,12,8,3,10,2,2,
        3,3,1,4,20,7,2,9,6,15,2,20,1,3,16,4,11,15,6,134,2,5,59,1,2,2,2,1,9,17,3,26,137,10,211,59,1,2,4,1,4,1,1,1,2,6,2,3,1,1,2,3,2,3,1,3,4,4,2,3,3,
        1,4,3,1,7,2,2,3,1,2,1,3,3,3,2,2,3,2,1,3,14,6,1,3,2,9,6,15,27,9,34,145,1,1,2,1,1,1,1,2,1,1,1,1,2,2,2,3,1,2,1,1,1,2,3,5,8,3,5,2,4,1,3,2,2,2,12,
        4,1,1,1,10,4,5,1,20,4,16,1,15,9,5,12,2,9,2,5,4,2,26,19,7,1,26,4,30,12,15,42,1,6,8,172,1,1,4,2,1,1,11,2,2,4,2,1,2,1,10,8,1,2,1,4,5,1,2,5,1,8,
        4,1,3,4,2,1,6,2,1,3,4,1,2,1,1,1,1,12,5,7,2,4,3,1,1,1,3,3,6,1,2,2,3,3,3,2,1,2,12,14,11,6,6,4,12,2,8,1,7,10,1,35,7,4,13,15,4,3,23,21,28,52,5,
        26,5,6,1,7,10,2,7,53,3,2,1,1,1,2,163,532,1,10,11,1,3,3,4,8,2,8,6,2,2,23,22,4,2,2,4,2,1,3,1,3,3,5,9,8,2,1,2,8,1,10,2,12,21,20,15,105,2,3,1,1,
        3,2,3,1,1,2,5,1,4,15,11,19,1,1,1,1,5,4,5,1,1,2,5,3,5,12,1,2,5,1,11,1,1,15,9,1,4,5,3,26,8,2,1,3,1,1,15,19,2,12,1,2,5,2,7,2,19,2,20,6,26,7,5,
        2,2,7,34,21,13,70,2,128,1,1,2,1,1,2,1,1,3,2,2,2,15,1,4,1,3,4,42,10,6,1,49,85,8,1,2,1,1,4,4,2,3,6,1,5,7,4,3,211,4,1,2,1,2,5,1,2,4,2,2,6,5,6,
        10,3,4,48,100,6,2,16,296,5,27,387,2,2,3,7,16,8,5,38,15,39,21,9,10,3,7,59,13,27,21,47,5,21,6
    };
    static ImWchar base_ranges[] = // not zero-terminated
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x2000, 0x206F, // General Punctuation
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
        0xFFFD, 0xFFFD  // Invalid
    };
    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00) * 2 + 1] = { 0 };
    if (!full_ranges[0])
    {
        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    }
    return &full_ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()
{
    // 2999 ideograms code points for Japanese
    // - 2136 Joyo (meaning ""for regular use"" or ""for common use"") Kanji code points
    // - 863 Jinmeiyo (meaning ""for personal name"") Kanji code points
    // - Sourced from official information provided by the government agencies of Japan:
    //   - List of Joyo Kanji by the Agency for Cultural Affairs
    //     - https://www.bunka.go.jp/kokugo_nihongo/sisaku/joho/joho/kijun/naikaku/kanji/
    //   - List of Jinmeiyo Kanji by the Ministry of Justice
    //     - http://www.moj.go.jp/MINJI/minji86.html
    //   - Available under the terms of the Creative Commons Attribution 4.0 International (CC BY 4.0).
    //     - https://creativecommons.org/licenses/by/4.0/legalcode
    // - You can generate this code by the script at:
    //   - https://github.com/vaiorabbit/everyday_use_kanji
    // - References:
    //   - List of Joyo Kanji
    //     - (Wikipedia) https://en.wikipedia.org/wiki/List_of_j%C5%8Dy%C5%8D_kanji
    //   - List of Jinmeiyo Kanji
    //     - (Wikipedia) https://en.wikipedia.org/wiki/Jinmeiy%C5%8D_kanji
    // - Missing 1 Joyo Kanji: U+20B9F (Kun'yomi: Shikaru, On'yomi: Shitsu,shichi), see https://github.com/ocornut/imgui/pull/3627 for details.
    // You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
    // (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
    static const short accumulative_offsets_from_0x4E00[] =
    {
        0,1,2,4,1,1,1,1,2,1,3,3,2,2,1,5,3,5,7,5,6,1,2,1,7,2,6,3,1,8,1,1,4,1,1,18,2,11,2,6,2,1,2,1,5,1,2,1,3,1,2,1,2,3,3,1,1,2,3,1,1,1,12,7,9,1,4,5,1,
        1,2,1,10,1,1,9,2,2,4,5,6,9,3,1,1,1,1,9,3,18,5,2,2,2,2,1,6,3,7,1,1,1,1,2,2,4,2,1,23,2,10,4,3,5,2,4,10,2,4,13,1,6,1,9,3,1,1,6,6,7,6,3,1,2,11,3,
        2,2,3,2,15,2,2,5,4,3,6,4,1,2,5,2,12,16,6,13,9,13,2,1,1,7,16,4,7,1,19,1,5,1,2,2,7,7,8,2,6,5,4,9,18,7,4,5,9,13,11,8,15,2,1,1,1,2,1,2,2,1,2,2,8,
        2,9,3,3,1,1,4,4,1,1,1,4,9,1,4,3,5,5,2,7,5,3,4,8,2,1,13,2,3,3,1,14,1,1,4,5,1,3,6,1,5,2,1,1,3,3,3,3,1,1,2,7,6,6,7,1,4,7,6,1,1,1,1,1,12,3,3,9,5,
        2,6,1,5,6,1,2,3,18,2,4,14,4,1,3,6,1,1,6,3,5,5,3,2,2,2,2,12,3,1,4,2,3,2,3,11,1,7,4,1,2,1,3,17,1,9,1,24,1,1,4,2,2,4,1,2,7,1,1,1,3,1,2,2,4,15,1,
        1,2,1,1,2,1,5,2,5,20,2,5,9,1,10,8,7,6,1,1,1,1,1,1,6,2,1,2,8,1,1,1,1,5,1,1,3,1,1,1,1,3,1,1,12,4,1,3,1,1,1,1,1,10,3,1,7,5,13,1,2,3,4,6,1,1,30,
        2,9,9,1,15,38,11,3,1,8,24,7,1,9,8,10,2,1,9,31,2,13,6,2,9,4,49,5,2,15,2,1,10,2,1,1,1,2,2,6,15,30,35,3,14,18,8,1,16,10,28,12,19,45,38,1,3,2,3,
        13,2,1,7,3,6,5,3,4,3,1,5,7,8,1,5,3,18,5,3,6,1,21,4,24,9,24,40,3,14,3,21,3,2,1,2,4,2,3,1,15,15,6,5,1,1,3,1,5,6,1,9,7,3,3,2,1,4,3,8,21,5,16,4,
        5,2,10,11,11,3,6,3,2,9,3,6,13,1,2,1,1,1,1,11,12,6,6,1,4,2,6,5,2,1,1,3,3,6,13,3,1,1,5,1,2,3,3,14,2,1,2,2,2,5,1,9,5,1,1,6,12,3,12,3,4,13,2,14,
        2,8,1,17,5,1,16,4,2,2,21,8,9,6,23,20,12,25,19,9,38,8,3,21,40,25,33,13,4,3,1,4,1,2,4,1,2,5,26,2,1,1,2,1,3,6,2,1,1,1,1,1,1,2,3,1,1,1,9,2,3,1,1,
        1,3,6,3,2,1,1,6,6,1,8,2,2,2,1,4,1,2,3,2,7,3,2,4,1,2,1,2,2,1,1,1,1,1,3,1,2,5,4,10,9,4,9,1,1,1,1,1,1,5,3,2,1,6,4,9,6,1,10,2,31,17,8,3,7,5,40,1,
        7,7,1,6,5,2,10,7,8,4,15,39,25,6,28,47,18,10,7,1,3,1,1,2,1,1,1,3,3,3,1,1,1,3,4,2,1,4,1,3,6,10,7,8,6,2,2,1,3,3,2,5,8,7,9,12,2,15,1,1,4,1,2,1,1,
        1,3,2,1,3,3,5,6,2,3,2,10,1,4,2,8,1,1,1,11,6,1,21,4,16,3,1,3,1,4,2,3,6,5,1,3,1,1,3,3,4,6,1,1,10,4,2,7,10,4,7,4,2,9,4,3,1,1,1,4,1,8,3,4,1,3,1,
        6,1,4,2,1,4,7,2,1,8,1,4,5,1,1,2,2,4,6,2,7,1,10,1,1,3,4,11,10,8,21,4,6,1,3,5,2,1,2,28,5,5,2,3,13,1,2,3,1,4,2,1,5,20,3,8,11,1,3,3,3,1,8,10,9,2,
        10,9,2,3,1,1,2,4,1,8,3,6,1,7,8,6,11,1,4,29,8,4,3,1,2,7,13,1,4,1,6,2,6,12,12,2,20,3,2,3,6,4,8,9,2,7,34,5,1,18,6,1,1,4,4,5,7,9,1,2,2,4,3,4,1,7,
        2,2,2,6,2,3,25,5,3,6,1,4,6,7,4,2,1,4,2,13,6,4,4,3,1,5,3,4,4,3,2,1,1,4,1,2,1,1,3,1,11,1,6,3,1,7,3,6,2,8,8,6,9,3,4,11,3,2,10,12,2,5,11,1,6,4,5,
        3,1,8,5,4,6,6,3,5,1,1,3,2,1,2,2,6,17,12,1,10,1,6,12,1,6,6,19,9,6,16,1,13,4,4,15,7,17,6,11,9,15,12,6,7,2,1,2,2,15,9,3,21,4,6,49,18,7,3,2,3,1,
        6,8,2,2,6,2,9,1,3,6,4,4,1,2,16,2,5,2,1,6,2,3,5,3,1,2,5,1,2,1,9,3,1,8,6,4,8,11,3,1,1,1,1,3,1,13,8,4,1,3,2,2,1,4,1,11,1,5,2,1,5,2,5,8,6,1,1,7,
        4,3,8,3,2,7,2,1,5,1,5,2,4,7,6,2,8,5,1,11,4,5,3,6,18,1,2,13,3,3,1,21,1,1,4,1,4,1,1,1,8,1,2,2,7,1,2,4,2,2,9,2,1,1,1,4,3,6,3,12,5,1,1,1,5,6,3,2,
        4,8,2,2,4,2,7,1,8,9,5,2,3,2,1,3,2,13,7,14,6,5,1,1,2,1,4,2,23,2,1,1,6,3,1,4,1,15,3,1,7,3,9,14,1,3,1,4,1,1,5,8,1,3,8,3,8,15,11,4,14,4,4,2,5,5,
        1,7,1,6,14,7,7,8,5,15,4,8,6,5,6,2,1,13,1,20,15,11,9,2,5,6,2,11,2,6,2,5,1,5,8,4,13,19,25,4,1,1,11,1,34,2,5,9,14,6,2,2,6,1,1,14,1,3,14,13,1,6,
        12,21,14,14,6,32,17,8,32,9,28,1,2,4,11,8,3,1,14,2,5,15,1,1,1,1,3,6,4,1,3,4,11,3,1,1,11,30,1,5,1,4,1,5,8,1,1,3,2,4,3,17,35,2,6,12,17,3,1,6,2,
        1,1,12,2,7,3,3,2,1,16,2,8,3,6,5,4,7,3,3,8,1,9,8,5,1,2,1,3,2,8,1,2,9,12,1,1,2,3,8,3,24,12,4,3,7,5,8,3,3,3,3,3,3,1,23,10,3,1,2,2,6,3,1,16,1,16,
        22,3,10,4,11,6,9,7,7,3,6,2,2,2,4,10,2,1,1,2,8,7,1,6,4,1,3,3,3,5,10,12,12,2,3,12,8,15,1,1,16,6,6,1,5,9,11,4,11,4,2,6,12,1,17,5,13,1,4,9,5,1,11,
        2,1,8,1,5,7,28,8,3,5,10,2,17,3,38,22,1,2,18,12,10,4,38,18,1,4,44,19,4,1,8,4,1,12,1,4,31,12,1,14,7,75,7,5,10,6,6,13,3,2,11,11,3,2,5,28,15,6,18,
        18,5,6,4,3,16,1,7,18,7,36,3,5,3,1,7,1,9,1,10,7,2,4,2,6,2,9,7,4,3,32,12,3,7,10,2,23,16,3,1,12,3,31,4,11,1,3,8,9,5,1,30,15,6,12,3,2,2,11,19,9,
        14,2,6,2,3,19,13,17,5,3,3,25,3,14,1,1,1,36,1,3,2,19,3,13,36,9,13,31,6,4,16,34,2,5,4,2,3,3,5,1,1,1,4,3,1,17,3,2,3,5,3,1,3,2,3,5,6,3,12,11,1,3,
        1,2,26,7,12,7,2,14,3,3,7,7,11,25,25,28,16,4,36,1,2,1,6,2,1,9,3,27,17,4,3,4,13,4,1,3,2,2,1,10,4,2,4,6,3,8,2,1,18,1,1,24,2,2,4,33,2,3,63,7,1,6,
        40,7,3,4,4,2,4,15,18,1,16,1,1,11,2,41,14,1,3,18,13,3,2,4,16,2,17,7,15,24,7,18,13,44,2,2,3,6,1,1,7,5,1,7,1,4,3,3,5,10,8,2,3,1,8,1,1,27,4,2,1,
        12,1,2,1,10,6,1,6,7,5,2,3,7,11,5,11,3,6,6,2,3,15,4,9,1,1,2,1,2,11,2,8,12,8,5,4,2,3,1,5,2,2,1,14,1,12,11,4,1,11,17,17,4,3,2,5,5,7,3,1,5,9,9,8,
        2,5,6,6,13,13,2,1,2,6,1,2,2,49,4,9,1,2,10,16,7,8,4,3,2,23,4,58,3,29,1,14,19,19,11,11,2,7,5,1,3,4,6,2,18,5,12,12,17,17,3,3,2,4,1,6,2,3,4,3,1,
        1,1,1,5,1,1,9,1,3,1,3,6,1,8,1,1,2,6,4,14,3,1,4,11,4,1,3,32,1,2,4,13,4,1,2,4,2,1,3,1,11,1,4,2,1,4,4,6,3,5,1,6,5,7,6,3,23,3,5,3,5,3,3,13,3,9,10,
        1,12,10,2,3,18,13,7,160,52,4,2,2,3,2,14,5,4,12,4,6,4,1,20,4,11,6,2,12,27,1,4,1,2,2,7,4,5,2,28,3,7,25,8,3,19,3,6,10,2,2,1,10,2,5,4,1,3,4,1,5,
        3,2,6,9,3,6,2,16,3,3,16,4,5,5,3,2,1,2,16,15,8,2,6,21,2,4,1,22,5,8,1,1,21,11,2,1,11,11,19,13,12,4,2,3,2,3,6,1,8,11,1,4,2,9,5,2,1,11,2,9,1,1,2,
        14,31,9,3,4,21,14,4,8,1,7,2,2,2,5,1,4,20,3,3,4,10,1,11,9,8,2,1,4,5,14,12,14,2,17,9,6,31,4,14,1,20,13,26,5,2,7,3,6,13,2,4,2,19,6,2,2,18,9,3,5,
        12,12,14,4,6,2,3,6,9,5,22,4,5,25,6,4,8,5,2,6,27,2,35,2,16,3,7,8,8,6,6,5,9,17,2,20,6,19,2,13,3,1,1,1,4,17,12,2,14,7,1,4,18,12,38,33,2,10,1,1,
        2,13,14,17,11,50,6,33,20,26,74,16,23,45,50,13,38,33,6,6,7,4,4,2,1,3,2,5,8,7,8,9,3,11,21,9,13,1,3,10,6,7,1,2,2,18,5,5,1,9,9,2,68,9,19,13,2,5,
        1,4,4,7,4,13,3,9,10,21,17,3,26,2,1,5,2,4,5,4,1,7,4,7,3,4,2,1,6,1,1,20,4,1,9,2,2,1,3,3,2,3,2,1,1,1,20,2,3,1,6,2,3,6,2,4,8,1,3,2,10,3,5,3,4,4,
        3,4,16,1,6,1,10,2,4,2,1,1,2,10,11,2,2,3,1,24,31,4,10,10,2,5,12,16,164,15,4,16,7,9,15,19,17,1,2,1,1,5,1,1,1,1,1,3,1,4,3,1,3,1,3,1,2,1,1,3,3,7,
        2,8,1,2,2,2,1,3,4,3,7,8,12,92,2,10,3,1,3,14,5,25,16,42,4,7,7,4,2,21,5,27,26,27,21,25,30,31,2,1,5,13,3,22,5,6,6,11,9,12,1,5,9,7,5,5,22,60,3,5,
        13,1,1,8,1,1,3,3,2,1,9,3,3,18,4,1,2,3,7,6,3,1,2,3,9,1,3,1,3,2,1,3,1,1,1,2,1,11,3,1,6,9,1,3,2,3,1,2,1,5,1,1,4,3,4,1,2,2,4,4,1,7,2,1,2,2,3,5,13,
        18,3,4,14,9,9,4,16,3,7,5,8,2,6,48,28,3,1,1,4,2,14,8,2,9,2,1,15,2,4,3,2,10,16,12,8,7,1,1,3,1,1,1,2,7,4,1,6,4,38,39,16,23,7,15,15,3,2,12,7,21,
        37,27,6,5,4,8,2,10,8,8,6,5,1,2,1,3,24,1,16,17,9,23,10,17,6,1,51,55,44,13,294,9,3,6,2,4,2,2,15,1,1,1,13,21,17,68,14,8,9,4,1,4,9,3,11,7,1,1,1,
        5,6,3,2,1,1,1,2,3,8,1,2,2,4,1,5,5,2,1,4,3,7,13,4,1,4,1,3,1,1,1,5,5,10,1,6,1,5,2,1,5,2,4,1,4,5,7,3,18,2,9,11,32,4,3,3,2,4,7,11,16,9,11,8,13,38,
        32,8,4,2,1,1,2,1,2,4,4,1,1,1,4,1,21,3,11,1,16,1,1,6,1,3,2,4,9,8,57,7,44,1,3,3,13,3,10,1,1,7,5,2,7,21,47,63,3,15,4,7,1,16,1,1,2,8,2,3,42,15,4,
        1,29,7,22,10,3,78,16,12,20,18,4,67,11,5,1,3,15,6,21,31,32,27,18,13,71,35,5,142,4,10,1,2,50,19,33,16,35,37,16,19,27,7,1,133,19,1,4,8,7,20,1,4,
        4,1,10,3,1,6,1,2,51,5,40,15,24,43,22928,11,1,13,154,70,3,1,1,7,4,10,1,2,1,1,2,1,2,1,2,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,
        3,2,1,1,1,1,2,1,1,
    };
    static ImWchar base_ranges[] = // not zero-terminated
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
        0x31F0, 0x31FF, // Katakana Phonetic Extensions
        0xFF00, 0xFFEF, // Half-width characters
        0xFFFD, 0xFFFD  // Invalid
    };
    static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(accumulative_offsets_from_0x4E00)*2 + 1] = { 0 };
    if (!full_ranges[0])
    {
        memcpy(full_ranges, base_ranges, sizeof(base_ranges));
        UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00, IM_ARRAYSIZE(accumulative_offsets_from_0x4E00), full_ranges + IM_ARRAYSIZE(base_ranges));
    }
    return &full_ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin + Latin Supplement
        0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
        0x2DE0, 0x2DFF, // Cyrillic Extended-A
        0xA640, 0xA69F, // Cyrillic Extended-B
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesThai()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin
        0x2010, 0x205E, // Punctuations
        0x0E00, 0x0E7F, // Thai
        0,
    };
    return &ranges[0];
}

const ImWchar*  ImFontAtlas::GetGlyphRangesVietnamese()
{
    static const ImWchar ranges[] =
    {
        0x0020, 0x00FF, // Basic Latin
        0x0102, 0x0103,
        0x0110, 0x0111,
        0x0128, 0x0129,
        0x0168, 0x0169,
        0x01A0, 0x01A1,
        0x01AF, 0x01B0,
        0x1EA0, 0x1EF9,
        0,
    };
    return &ranges[0];
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontGlyphRangesBuilder
//-----------------------------------------------------------------------------

void ImFontGlyphRangesBuilder::AddText(const char* text, const char* text_end)
{
    while (text_end ? (text < text_end) : *text)
    {
        unsigned int c = 0;
        int c_len = ImTextCharFromUtf8(&c, text, text_end);
        text += c_len;
        if (c_len == 0)
            break;
        AddChar((ImWchar)c);
    }
}

void ImFontGlyphRangesBuilder::AddRanges(const ImWchar* ranges)
{
    for (; ranges[0]; ranges += 2)
        for (unsigned int c = ranges[0]; c <= ranges[1] && c <= IM_UNICODE_CODEPOINT_MAX; c++) //-V560
            AddChar((ImWchar)c);
}

void ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)
{
    const int max_codepoint = IM_UNICODE_CODEPOINT_MAX;
    for (int n = 0; n <= max_codepoint; n++)
        if (GetBit(n))
        {
            out_ranges->push_back((ImWchar)n);
            while (n < max_codepoint && GetBit(n + 1))
                n++;
            out_ranges->push_back((ImWchar)n);
        }
    out_ranges->push_back(0);
}

//-----------------------------------------------------------------------------
// [SECTION] ImFont
//-----------------------------------------------------------------------------

ImFont::ImFont()
{
    memset(this, 0, sizeof(*this));
    Scale = 1.0f;
}

ImFont::~ImFont()
{
    ClearOutputData();
}

void    ImFont::ClearOutputData()
{
    FontSize = 0.0f;
    FallbackAdvanceX = 0.0f;
    Glyphs.clear();
    IndexAdvanceX.clear();
    IndexLookup.clear();
    FallbackGlyph = NULL;
    ContainerAtlas = NULL;
    DirtyLookupTables = true;
    Ascent = Descent = 0.0f;
    MetricsTotalSurface = 0;
    memset(Used8kPagesMap, 0, sizeof(Used8kPagesMap));
}

static ImWchar FindFirstExistingGlyph(ImFont* font, const ImWchar* candidate_chars, int candidate_chars_count)
{
    for (int n = 0; n < candidate_chars_count; n++)
        if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)
            return candidate_chars[n];
    return 0;
}

void ImFont::BuildLookupTable()
{
    int max_codepoint = 0;
    for (int i = 0; i != Glyphs.Size; i++)
        max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

    // Build lookup table
    IM_ASSERT(Glyphs.Size > 0 && ""Font has not loaded glyph!"");
    IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
    IndexAdvanceX.clear();
    IndexLookup.clear();
    DirtyLookupTables = false;
    memset(Used8kPagesMap, 0, sizeof(Used8kPagesMap));
    GrowIndex(max_codepoint + 1);
    for (int i = 0; i < Glyphs.Size; i++)
    {
        int codepoint = (int)Glyphs[i].Codepoint;
        IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
        IndexLookup[codepoint] = (ImU16)i;

        // Mark 4K page as used
        const int page_n = codepoint / 8192;
        Used8kPagesMap[page_n >> 3] |= 1 << (page_n & 7);
    }

    // Create a glyph to handle TAB
    // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at ""column 0"" ?)
    if (FindGlyph((ImWchar)' '))
    {
        if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)
            Glyphs.resize(Glyphs.Size + 1);
        ImFontGlyph& tab_glyph = Glyphs.back();
        tab_glyph = *FindGlyph((ImWchar)' ');
        tab_glyph.Codepoint = '\t';
        tab_glyph.AdvanceX *= IM_TABSIZE;
        IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
        IndexLookup[(int)tab_glyph.Codepoint] = (ImU16)(Glyphs.Size - 1);
    }

    // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
    if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)' '))
        glyph->Visible = false;
    if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)'\t'))
        glyph->Visible = false;

    // Setup Fallback character
    const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };
    FallbackGlyph = FindGlyphNoFallback(FallbackChar);
    if (FallbackGlyph == NULL)
    {
        FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));
        FallbackGlyph = FindGlyphNoFallback(FallbackChar);
        if (FallbackGlyph == NULL)
        {
            FallbackGlyph = &Glyphs.back();
            FallbackChar = (ImWchar)FallbackGlyph->Codepoint;
        }
    }
    FallbackAdvanceX = FallbackGlyph->AdvanceX;
    for (int i = 0; i < max_codepoint + 1; i++)
        if (IndexAdvanceX[i] < 0.0f)
            IndexAdvanceX[i] = FallbackAdvanceX;

    // Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
    // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
    // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
    const ImWchar ellipsis_chars[] = { ConfigData->EllipsisChar, (ImWchar)0x2026, (ImWchar)0x0085 };
    const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };
    if (EllipsisChar == 0)
        EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));
    const ImWchar dot_char = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));
    if (EllipsisChar != 0)
    {
        EllipsisCharCount = 1;
        EllipsisWidth = EllipsisCharStep = FindGlyph(EllipsisChar)->X1;
    }
    else if (dot_char != 0)
    {
        const ImFontGlyph* dot_glyph = FindGlyph(dot_char);
        EllipsisChar = dot_char;
        EllipsisCharCount = 3;
        EllipsisCharStep = (float)(int)(dot_glyph->X1 - dot_glyph->X0) + 1.0f;
        EllipsisWidth = ImMax(dot_glyph->AdvanceX, dot_glyph->X0 + EllipsisCharStep * 3.0f - 1.0f); // FIXME: Slightly odd for normally mono-space fonts but since this is used for trailing contents.
    }
}

// API is designed this way to avoid exposing the 8K page size
// e.g. use with IsGlyphRangeUnused(0, 255)
bool ImFont::IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last)
{
    unsigned int page_begin = (c_begin / 8192);
    unsigned int page_last = (c_last / 8192);
    for (unsigned int page_n = page_begin; page_n <= page_last; page_n++)
        if ((page_n >> 3) < sizeof(Used8kPagesMap))
            if (Used8kPagesMap[page_n >> 3] & (1 << (page_n & 7)))
                return false;
    return true;
}

void ImFont::GrowIndex(int new_size)
{
    IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
    if (new_size <= IndexLookup.Size)
        return;
    IndexAdvanceX.resize(new_size, -1.0f);
    IndexLookup.resize(new_size, (ImU16)-1);
}

// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
// 'cfg' is not necessarily == 'this->ConfigData' because multiple source fonts+configs can be used to build one target font.
void ImFont::AddGlyph(const ImFontConfig* cfg, ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
{
    if (cfg != NULL)
    {
        // Clamp & recenter if needed
        const float advance_x_original = advance_x;
        advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);
        if (advance_x != advance_x_original)
        {
            float char_off_x = cfg->PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;
            x0 += char_off_x;
            x1 += char_off_x;
        }

        // Snap to pixel
        if (cfg->PixelSnapH)
            advance_x = IM_ROUND(advance_x);

        // Bake extra spacing
        advance_x += cfg->GlyphExtraAdvanceX;
    }

    int glyph_idx = Glyphs.Size;
    Glyphs.resize(Glyphs.Size + 1);
    ImFontGlyph& glyph = Glyphs[glyph_idx];
    glyph.Codepoint = (unsigned int)codepoint;
    glyph.Visible = (x0 != x1) && (y0 != y1);
    glyph.Colored = false;
    glyph.X0 = x0;
    glyph.Y0 = y0;
    glyph.X1 = x1;
    glyph.Y1 = y1;
    glyph.U0 = u0;
    glyph.V0 = v0;
    glyph.U1 = u1;
    glyph.V1 = v1;
    glyph.AdvanceX = advance_x;
    IM_ASSERT(Glyphs.Size < 0xFFFF); // IndexLookup[] hold 16-bit values and -1 is reserved.

    // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
    // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
    float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
    DirtyLookupTables = true;
    MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
}

void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)
{
    IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
    unsigned int index_size = (unsigned int)IndexLookup.Size;

    if (dst < index_size && IndexLookup.Data[dst] == (ImU16)-1 && !overwrite_dst) // 'dst' already exists
        return;
    if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op
        return;

    GrowIndex(dst + 1);
    IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (ImU16)-1;
    IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
}

// Find glyph, return fallback if missing
ImFontGlyph* ImFont::FindGlyph(ImWchar c)
{
    if (c >= (size_t)IndexLookup.Size)
        return FallbackGlyph;
    const ImU16 i = IndexLookup.Data[c];
    if (i == (ImU16)-1)
        return FallbackGlyph;
    return &Glyphs.Data[i];
}

ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c)
{
    if (c >= (size_t)IndexLookup.Size)
        return NULL;
    const ImU16 i = IndexLookup.Data[c];
    if (i == (ImU16)-1)
        return NULL;
    return &Glyphs.Data[i];
}

// Trim trailing space and find beginning of next line
static inline const char* CalcWordWrapNextLineStartA(const char* text, const char* text_end)
{
    while (text < text_end && ImCharIsBlankA(*text))
        text++;
    if (*text == '\n')
        text++;
    return text;
}

#define ImFontGetCharAdvanceX(_FONT, _CH)  ((int)(_CH) < (_FONT)->IndexAdvanceX.Size ? (_FONT)->IndexAdvanceX.Data[_CH] : (_FONT)->FallbackAdvanceX)

// Simple word-wrapping for English, not full-featured. Please submit failing cases!
// This will return the next location to wrap from. If no wrapping if necessary, this will fast-forward to e.g. text_end.
// FIXME: Much possible improvements (don't cut things like ""word !"", ""word!!!"" but cut within ""word,,,,"", more sensible support for punctuations, support for Unicode punctuations, etc.)
const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width)
{
    // For references, possible wrap point marked with ^
    //  ""aaa bbb, ccc,ddd. eee   fff. ggg!""
    //      ^    ^    ^   ^   ^__    ^    ^

    // List of hardcoded separators: .,;!?'""

    // Skip extra blanks after a line returns (that includes not counting them in width computation)
    // e.g. ""Hello    world"" --> ""Hello"" ""World""

    // Cut words that cannot possibly fit within one line.
    // e.g.: ""The tropical fish"" with ~5 characters worth of width --> ""The tr"" ""opical"" ""fish""
    float line_width = 0.0f;
    float word_width = 0.0f;
    float blank_width = 0.0f;
    wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

    const char* word_end = text;
    const char* prev_word_end = NULL;
    bool inside_word = true;

    const char* s = text;
    IM_ASSERT(text_end != NULL);
    while (s < text_end)
    {
        unsigned int c = (unsigned int)*s;
        const char* next_s;
        if (c < 0x80)
            next_s = s + 1;
        else
            next_s = s + ImTextCharFromUtf8(&c, s, text_end);

        if (c < 32)
        {
            if (c == '\n')
            {
                line_width = word_width = blank_width = 0.0f;
                inside_word = true;
                s = next_s;
                continue;
            }
            if (c == '\r')
            {
                s = next_s;
                continue;
            }
        }

        const float char_width = ImFontGetCharAdvanceX(this, c);
        if (ImCharIsBlankW(c))
        {
            if (inside_word)
            {
                line_width += blank_width;
                blank_width = 0.0f;
                word_end = s;
            }
            blank_width += char_width;
            inside_word = false;
        }
        else
        {
            word_width += char_width;
            if (inside_word)
            {
                word_end = next_s;
            }
            else
            {
                prev_word_end = word_end;
                line_width += word_width + blank_width;
                word_width = blank_width = 0.0f;
            }

            // Allow wrapping after punctuation.
            inside_word = (c != '.' && c != ',' && c != ';' && c != '!' && c != '?' && c != '\""');
        }

        // We ignore blank width at the end of the line (they can be skipped)
        if (line_width + word_width > wrap_width)
        {
            // Words that cannot possibly fit within an entire line will be cut anywhere.
            if (word_width < wrap_width)
                s = prev_word_end ? prev_word_end : word_end;
            break;
        }

        s = next_s;
    }

    // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
    // +1 may not be a character start point in UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).
    if (s == text && text < text_end)
        return s + 1;
    return s;
}

ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining)
{
    if (!text_end)
        text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

    const float line_height = size;
    const float scale = size / FontSize;

    ImVec2 text_size = ImVec2(0, 0);
    float line_width = 0.0f;

    const bool word_wrap_enabled = (wrap_width > 0.0f);
    const char* word_wrap_eol = NULL;

    const char* s = text_begin;
    while (s < text_end)
    {
        if (word_wrap_enabled)
        {
            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
            if (!word_wrap_eol)
                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);

            if (s >= word_wrap_eol)
            {
                if (text_size.x < line_width)
                    text_size.x = line_width;
                text_size.y += line_height;
                line_width = 0.0f;
                word_wrap_eol = NULL;
                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
                continue;
            }
        }

        // Decode and advance source
        const char* prev_s = s;
        unsigned int c = (unsigned int)*s;
        if (c < 0x80)
            s += 1;
        else
            s += ImTextCharFromUtf8(&c, s, text_end);

        if (c < 32)
        {
            if (c == '\n')
            {
                text_size.x = ImMax(text_size.x, line_width);
                text_size.y += line_height;
                line_width = 0.0f;
                continue;
            }
            if (c == '\r')
                continue;
        }

        const float char_width = ImFontGetCharAdvanceX(this, c) * scale;
        if (line_width + char_width >= max_width)
        {
            s = prev_s;
            break;
        }

        line_width += char_width;
    }

    if (text_size.x < line_width)
        text_size.x = line_width;

    if (line_width > 0 || text_size.y == 0.0f)
        text_size.y += line_height;

    if (remaining)
        *remaining = s;

    return text_size;
}

// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
void ImFont::RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c)
{
    const ImFontGlyph* glyph = FindGlyph(c);
    if (!glyph || !glyph->Visible)
        return;
    if (glyph->Colored)
        col |= ~IM_COL32_A_MASK;
    float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;
    float x = IM_TRUNC(pos.x);
    float y = IM_TRUNC(pos.y);
    draw_list->PrimReserve(6, 4);
    draw_list->PrimRectUV(ImVec2(x + glyph->X0 * scale, y + glyph->Y0 * scale), ImVec2(x + glyph->X1 * scale, y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
}

// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
void ImFont::RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip)
{
    // Align to be pixel perfect
    float x = IM_TRUNC(pos.x);
    float y = IM_TRUNC(pos.y);
    if (y > clip_rect.w)
        return;

    if (!text_end)
        text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.

    const float scale = size / FontSize;
    const float line_height = FontSize * scale;
    const float origin_x = x;
    const bool word_wrap_enabled = (wrap_width > 0.0f);

    // Fast-forward to first visible line
    const char* s = text_begin;
    if (y + line_height < clip_rect.y)
        while (y + line_height < clip_rect.y && s < text_end)
        {
            const char* line_end = (const char*)memchr(s, '\n', text_end - s);
            if (word_wrap_enabled)
            {
                // FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
                // If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
                // However it is still better than nothing performing the fast-forward!
                s = CalcWordWrapPositionA(scale, s, line_end ? line_end : text_end, wrap_width);
                s = CalcWordWrapNextLineStartA(s, text_end);
            }
            else
            {
                s = line_end ? line_end + 1 : text_end;
            }
            y += line_height;
        }

    // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
    // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
    if (text_end - s > 10000 && !word_wrap_enabled)
    {
        const char* s_end = s;
        float y_end = y;
        while (y_end < clip_rect.w && s_end < text_end)
        {
            s_end = (const char*)memchr(s_end, '\n', text_end - s_end);
            s_end = s_end ? s_end + 1 : text_end;
            y_end += line_height;
        }
        text_end = s_end;
    }
    if (s == text_end)
        return;

    // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
    const int vtx_count_max = (int)(text_end - s) * 4;
    const int idx_count_max = (int)(text_end - s) * 6;
    const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
    draw_list->PrimReserve(idx_count_max, vtx_count_max);
    ImDrawVert*  vtx_write = draw_list->_VtxWritePtr;
    ImDrawIdx*   idx_write = draw_list->_IdxWritePtr;
    unsigned int vtx_index = draw_list->_VtxCurrentIdx;

    const ImU32 col_untinted = col | ~IM_COL32_A_MASK;
    const char* word_wrap_eol = NULL;

    while (s < text_end)
    {
        if (word_wrap_enabled)
        {
            // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
            if (!word_wrap_eol)
                word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - origin_x));

            if (s >= word_wrap_eol)
            {
                x = origin_x;
                y += line_height;
                if (y > clip_rect.w)
                    break; // break out of main loop
                word_wrap_eol = NULL;
                s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
                continue;
            }
        }

        // Decode and advance source
        unsigned int c = (unsigned int)*s;
        if (c < 0x80)
            s += 1;
        else
            s += ImTextCharFromUtf8(&c, s, text_end);

        if (c < 32)
        {
            if (c == '\n')
            {
                x = origin_x;
                y += line_height;
                if (y > clip_rect.w)
                    break; // break out of main loop
                continue;
            }
            if (c == '\r')
                continue;
        }

        const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
        if (glyph == NULL)
            continue;

        float char_width = glyph->AdvanceX * scale;
        if (glyph->Visible)
        {
            // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
            float x1 = x + glyph->X0 * scale;
            float x2 = x + glyph->X1 * scale;
            float y1 = y + glyph->Y0 * scale;
            float y2 = y + glyph->Y1 * scale;
            if (x1 <= clip_rect.z && x2 >= clip_rect.x)
            {
                // Render a character
                float u1 = glyph->U0;
                float v1 = glyph->V0;
                float u2 = glyph->U1;
                float v2 = glyph->V1;

                // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
                if (cpu_fine_clip)
                {
                    if (x1 < clip_rect.x)
                    {
                        u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
                        x1 = clip_rect.x;
                    }
                    if (y1 < clip_rect.y)
                    {
                        v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
                        y1 = clip_rect.y;
                    }
                    if (x2 > clip_rect.z)
                    {
                        u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
                        x2 = clip_rect.z;
                    }
                    if (y2 > clip_rect.w)
                    {
                        v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
                        y2 = clip_rect.w;
                    }
                    if (y1 >= y2)
                    {
                        x += char_width;
                        continue;
                    }
                }

                // Support for untinted glyphs
                ImU32 glyph_col = glyph->Colored ? col_untinted : col;

                // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
                {
                    vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
                    vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
                    vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
                    vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
                    idx_write[0] = (ImDrawIdx)(vtx_index); idx_write[1] = (ImDrawIdx)(vtx_index + 1); idx_write[2] = (ImDrawIdx)(vtx_index + 2);
                    idx_write[3] = (ImDrawIdx)(vtx_index); idx_write[4] = (ImDrawIdx)(vtx_index + 2); idx_write[5] = (ImDrawIdx)(vtx_index + 3);
                    vtx_write += 4;
                    vtx_index += 4;
                    idx_write += 6;
                }
            }
        }
        x += char_width;
    }

    // Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
    draw_list->VtxBuffer.Size = (int)(vtx_write - draw_list->VtxBuffer.Data); // Same as calling shrink()
    draw_list->IdxBuffer.Size = (int)(idx_write - draw_list->IdxBuffer.Data);
    draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
    draw_list->_VtxWritePtr = vtx_write;
    draw_list->_IdxWritePtr = idx_write;
    draw_list->_VtxCurrentIdx = vtx_index;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGui Internal Render Helpers
//-----------------------------------------------------------------------------
// Vaguely redesigned to stop accessing ImGui global state:
// - RenderArrow()
// - RenderBullet()
// - RenderCheckMark()
// - RenderArrowPointingAt()
// - RenderRectFilledRangeH()
// - RenderRectFilledWithHole()
//-----------------------------------------------------------------------------
// Function in need of a redesign (legacy mess)
// - RenderColorRectWithAlphaCheckerboard()
//-----------------------------------------------------------------------------

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
void ImGui::RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale)
{
    const float h = draw_list->_Data->FontSize * 1.00f;
    float r = h * 0.40f * scale;
    ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);

    ImVec2 a, b, c;
    switch (dir)
    {
    case ImGuiDir_Up:
    case ImGuiDir_Down:
        if (dir == ImGuiDir_Up) r = -r;
        a = ImVec2(+0.000f, +0.750f) * r;
        b = ImVec2(-0.866f, -0.750f) * r;
        c = ImVec2(+0.866f, -0.750f) * r;
        break;
    case ImGuiDir_Left:
    case ImGuiDir_Right:
        if (dir == ImGuiDir_Left) r = -r;
        a = ImVec2(+0.750f, +0.000f) * r;
        b = ImVec2(-0.750f, +0.866f) * r;
        c = ImVec2(-0.750f, -0.866f) * r;
        break;
    case ImGuiDir_None:
    case ImGuiDir_COUNT:
        IM_ASSERT(0);
        break;
    }
    draw_list->AddTriangleFilled(center + a, center + b, center + c, col);
}

void ImGui::RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col)
{
    // FIXME-OPT: This should be baked in font.
    draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);
}

void ImGui::RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz)
{
    float thickness = ImMax(sz / 5.0f, 1.0f);
    sz -= thickness * 0.5f;
    pos += ImVec2(thickness * 0.25f, thickness * 0.25f);

    float third = sz / 3.0f;
    float bx = pos.x + third;
    float by = pos.y + sz - third * 0.5f;
    draw_list->PathLineTo(ImVec2(bx - third, by - third));
    draw_list->PathLineTo(ImVec2(bx, by));
    draw_list->PathLineTo(ImVec2(bx + third * 2.0f, by - third * 2.0f));
    draw_list->PathStroke(col, 0, thickness);
}

// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
void ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)
{
    switch (direction)
    {
    case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;
    case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;
    case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;
    case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;
    case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
    }
}

static inline float ImAcos01(float x)
{
    if (x <= 0.0f) return IM_PI * 0.5f;
    if (x >= 1.0f) return 0.0f;
    return ImAcos(x);
    //return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
}

// FIXME: Cleanup and move code to ImDrawList.
void ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)
{
    if (x_end_norm == x_start_norm)
        return;
    if (x_start_norm > x_end_norm)
        ImSwap(x_start_norm, x_end_norm);

    ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
    ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
    if (rounding == 0.0f)
    {
        draw_list->AddRectFilled(p0, p1, col, 0.0f);
        return;
    }

    rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);
    const float inv_rounding = 1.0f / rounding;
    const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);
    const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);
    const float half_pi = IM_PI * 0.5f; // We will == compare to this because we know this is the exact value ImAcos01 can return.
    const float x0 = ImMax(p0.x, rect.Min.x + rounding);
    if (arc0_b == arc0_e)
    {
        draw_list->PathLineTo(ImVec2(x0, p1.y));
        draw_list->PathLineTo(ImVec2(x0, p0.y));
    }
    else if (arc0_b == 0.0f && arc0_e == half_pi)
    {
        draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL
        draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR
    }
    else
    {
        draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b); // BL
        draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e); // TR
    }
    if (p1.x > rect.Min.x + rounding)
    {
        const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);
        const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);
        const float x1 = ImMin(p1.x, rect.Max.x - rounding);
        if (arc1_b == arc1_e)
        {
            draw_list->PathLineTo(ImVec2(x1, p0.y));
            draw_list->PathLineTo(ImVec2(x1, p1.y));
        }
        else if (arc1_b == 0.0f && arc1_e == half_pi)
        {
            draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR
            draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR
        }
        else
        {
            draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b); // TR
            draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e); // BR
        }
    }
    draw_list->PathFillConvex(col);
}

void ImGui::RenderRectFilledWithHole(ImDrawList* draw_list, const ImRect& outer, const ImRect& inner, ImU32 col, float rounding)
{
    const bool fill_L = (inner.Min.x > outer.Min.x);
    const bool fill_R = (inner.Max.x < outer.Max.x);
    const bool fill_U = (inner.Min.y > outer.Min.y);
    const bool fill_D = (inner.Max.y < outer.Max.y);
    if (fill_L) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Min.y), ImVec2(inner.Min.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomLeft));
    if (fill_R) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Min.y), ImVec2(outer.Max.x, inner.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_U ? 0 : ImDrawFlags_RoundCornersTopRight)   | (fill_D ? 0 : ImDrawFlags_RoundCornersBottomRight));
    if (fill_U) draw_list->AddRectFilled(ImVec2(inner.Min.x, outer.Min.y), ImVec2(inner.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersTopLeft)    | (fill_R ? 0 : ImDrawFlags_RoundCornersTopRight));
    if (fill_D) draw_list->AddRectFilled(ImVec2(inner.Min.x, inner.Max.y), ImVec2(inner.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersNone | (fill_L ? 0 : ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? 0 : ImDrawFlags_RoundCornersBottomRight));
    if (fill_L && fill_U) draw_list->AddRectFilled(ImVec2(outer.Min.x, outer.Min.y), ImVec2(inner.Min.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopLeft);
    if (fill_R && fill_U) draw_list->AddRectFilled(ImVec2(inner.Max.x, outer.Min.y), ImVec2(outer.Max.x, inner.Min.y), col, rounding, ImDrawFlags_RoundCornersTopRight);
    if (fill_L && fill_D) draw_list->AddRectFilled(ImVec2(outer.Min.x, inner.Max.y), ImVec2(inner.Min.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomLeft);
    if (fill_R && fill_D) draw_list->AddRectFilled(ImVec2(inner.Max.x, inner.Max.y), ImVec2(outer.Max.x, outer.Max.y), col, rounding, ImDrawFlags_RoundCornersBottomRight);
}

// Helper for ColorPicker4()
// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// Spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding altogether.
// FIXME: uses ImGui::GetColorU32
void ImGui::RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, ImDrawFlags flags)
{
    if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
        flags = ImDrawFlags_RoundCornersDefault_;
    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)
    {
        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColors(IM_COL32(204, 204, 204, 255), col));
        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColors(IM_COL32(128, 128, 128, 255), col));
        draw_list->AddRectFilled(p_min, p_max, col_bg1, rounding, flags);

        int yi = 0;
        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)
        {
            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);
            if (y2 <= y1)
                continue;
            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)
            {
                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);
                if (x2 <= x1)
                    continue;
                ImDrawFlags cell_flags = ImDrawFlags_RoundCornersNone;
                if (y1 <= p_min.y) { if (x1 <= p_min.x) cell_flags |= ImDrawFlags_RoundCornersTopLeft; if (x2 >= p_max.x) cell_flags |= ImDrawFlags_RoundCornersTopRight; }
                if (y2 >= p_max.y) { if (x1 <= p_min.x) cell_flags |= ImDrawFlags_RoundCornersBottomLeft; if (x2 >= p_max.x) cell_flags |= ImDrawFlags_RoundCornersBottomRight; }

                // Combine flags
                cell_flags = (flags == ImDrawFlags_RoundCornersNone || cell_flags == ImDrawFlags_RoundCornersNone) ? ImDrawFlags_RoundCornersNone : (cell_flags & flags);
                draw_list->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding, cell_flags);
            }
        }
    }
    else
    {
        draw_list->AddRectFilled(p_min, p_max, col, rounding, flags);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Decompression code
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array and encoded as base85.
// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
// The purpose of encoding as base85 instead of ""0x00,0x01,..."" style is only save on _source code_ size.
// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

static unsigned int stb_decompress_length(const unsigned char *input)
{
    return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
}

static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;
static const unsigned char *stb__barrier_in_b;
static unsigned char *stb__dout;
static void stb__match(const unsigned char *data, unsigned int length)
{
    // INVERSE of memmove... write each byte before copying the next...
    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
    if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e+1; return; }
    while (length--) *stb__dout++ = *data++;
}

static void stb__lit(const unsigned char *data, unsigned int length)
{
    IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
    if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
    if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e+1; return; }
    memcpy(stb__dout, data, length);
    stb__dout += length;
}

#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))

static const unsigned char *stb_decompress_token(const unsigned char *i)
{
    if (*i >= 0x20) { // use fewer if's for cases that expand small
        if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;
        else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;
        else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
    } else { // more ifs for cases that expand large, since overhead is amortized
        if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;
        else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;
        else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
        else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
        else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;
        else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;
    }
    return i;
}

static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
{
    const unsigned long ADLER_MOD = 65521;
    unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
    unsigned long blocklen = buflen % 5552;

    unsigned long i;
    while (buflen) {
        for (i=0; i + 7 < blocklen; i += 8) {
            s1 += buffer[0], s2 += s1;
            s1 += buffer[1], s2 += s1;
            s1 += buffer[2], s2 += s1;
            s1 += buffer[3], s2 += s1;
            s1 += buffer[4], s2 += s1;
            s1 += buffer[5], s2 += s1;
            s1 += buffer[6], s2 += s1;
            s1 += buffer[7], s2 += s1;

            buffer += 8;
        }

        for (; i < blocklen; ++i)
            s1 += *buffer++, s2 += s1;

        s1 %= ADLER_MOD, s2 %= ADLER_MOD;
        buflen -= blocklen;
        blocklen = 5552;
    }
    return (unsigned int)(s2 << 16) + (unsigned int)s1;
}

static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int /*length*/)
{
    if (stb__in4(0) != 0x57bC0000) return 0;
    if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
    const unsigned int olen = stb_decompress_length(i);
    stb__barrier_in_b = i;
    stb__barrier_out_e = output + olen;
    stb__barrier_out_b = output;
    i += 16;

    stb__dout = output;
    for (;;) {
        const unsigned char *old_i = i;
        i = stb_decompress_token(i);
        if (i == old_i) {
            if (*i == 0x05 && i[1] == 0xfa) {
                IM_ASSERT(stb__dout == output + olen);
                if (stb__dout != output + olen) return 0;
                if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))
                    return 0;
                return olen;
            } else {
                IM_ASSERT(0); /* NOTREACHED */
                return 0;
            }
        }
        IM_ASSERT(stb__dout <= output + olen);
        if (stb__dout > output + olen)
            return 0;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] Default font data (ProggyClean.ttf)
//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.proggyfonts.net/index.php?menu=download)
// Download and more information at http://www.proggyfonts.net or http://upperboundsinteractive.com/fonts.php
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_DEFAULT_FONT

// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using binary_to_compressed_c.exe -u8 ""ProggyClean.ttf"" proggy_clean_ttf
static const unsigned int proggy_clean_ttf_compressed_size = 9583;
static const unsigned char proggy_clean_ttf_compressed_data[9583] =
{
    87,188,0,0,0,0,0,0,0,0,160,248,0,4,0,0,55,0,1,0,0,0,12,0,128,0,3,0,64,79,83,47,50,136,235,116,144,0,0,1,72,130,21,44,78,99,109,97,112,2,18,35,117,0,0,3,160,130,19,36,82,99,118,116,
    32,130,23,130,2,33,4,252,130,4,56,2,103,108,121,102,18,175,137,86,0,0,7,4,0,0,146,128,104,101,97,100,215,145,102,211,130,27,32,204,130,3,33,54,104,130,16,39,8,66,1,195,0,0,1,4,130,
    15,59,36,104,109,116,120,138,0,126,128,0,0,1,152,0,0,2,6,108,111,99,97,140,115,176,216,0,0,5,130,30,41,2,4,109,97,120,112,1,174,0,218,130,31,32,40,130,16,44,32,110,97,109,101,37,89,
    187,150,0,0,153,132,130,19,44,158,112,111,115,116,166,172,131,239,0,0,155,36,130,51,44,210,112,114,101,112,105,2,1,18,0,0,4,244,130,47,32,8,132,203,46,1,0,0,60,85,233,213,95,15,60,
    245,0,3,8,0,131,0,34,183,103,119,130,63,43,0,0,189,146,166,215,0,0,254,128,3,128,131,111,130,241,33,2,0,133,0,32,1,130,65,38,192,254,64,0,0,3,128,131,16,130,5,32,1,131,7,138,3,33,2,
    0,130,17,36,1,1,0,144,0,130,121,130,23,38,2,0,8,0,64,0,10,130,9,32,118,130,9,130,6,32,0,130,59,33,1,144,131,200,35,2,188,2,138,130,16,32,143,133,7,37,1,197,0,50,2,0,131,0,33,4,9,131,
    5,145,3,43,65,108,116,115,0,64,0,0,32,172,8,0,131,0,35,5,0,1,128,131,77,131,3,33,3,128,191,1,33,1,128,130,184,35,0,0,128,0,130,3,131,11,32,1,130,7,33,0,128,131,1,32,1,136,9,32,0,132,
    15,135,5,32,1,131,13,135,27,144,35,32,1,149,25,131,21,32,0,130,0,32,128,132,103,130,35,132,39,32,0,136,45,136,97,133,17,130,5,33,0,0,136,19,34,0,128,1,133,13,133,5,32,128,130,15,132,
    131,32,3,130,5,32,3,132,27,144,71,32,0,133,27,130,29,130,31,136,29,131,63,131,3,65,63,5,132,5,132,205,130,9,33,0,0,131,9,137,119,32,3,132,19,138,243,130,55,32,1,132,35,135,19,131,201,
    136,11,132,143,137,13,130,41,32,0,131,3,144,35,33,128,0,135,1,131,223,131,3,141,17,134,13,136,63,134,15,136,53,143,15,130,96,33,0,3,131,4,130,3,34,28,0,1,130,5,34,0,0,76,130,17,131,
    9,36,28,0,4,0,48,130,17,46,8,0,8,0,2,0,0,0,127,0,255,32,172,255,255,130,9,34,0,0,129,132,9,130,102,33,223,213,134,53,132,22,33,1,6,132,6,64,4,215,32,129,165,216,39,177,0,1,141,184,
    1,255,133,134,45,33,198,0,193,1,8,190,244,1,28,1,158,2,20,2,136,2,252,3,20,3,88,3,156,3,222,4,20,4,50,4,80,4,98,4,162,5,22,5,102,5,188,6,18,6,116,6,214,7,56,7,126,7,236,8,78,8,108,
    8,150,8,208,9,16,9,74,9,136,10,22,10,128,11,4,11,86,11,200,12,46,12,130,12,234,13,94,13,164,13,234,14,80,14,150,15,40,15,176,16,18,16,116,16,224,17,82,17,182,18,4,18,110,18,196,19,
    76,19,172,19,246,20,88,20,174,20,234,21,64,21,128,21,166,21,184,22,18,22,126,22,198,23,52,23,142,23,224,24,86,24,186,24,238,25,54,25,150,25,212,26,72,26,156,26,240,27,92,27,200,28,
    4,28,76,28,150,28,234,29,42,29,146,29,210,30,64,30,142,30,224,31,36,31,118,31,166,31,166,32,16,130,1,52,46,32,138,32,178,32,200,33,20,33,116,33,152,33,238,34,98,34,134,35,12,130,1,
    33,128,35,131,1,60,152,35,176,35,216,36,0,36,74,36,104,36,144,36,174,37,6,37,96,37,130,37,248,37,248,38,88,38,170,130,1,8,190,216,39,64,39,154,40,10,40,104,40,168,41,14,41,32,41,184,
    41,248,42,54,42,96,42,96,43,2,43,42,43,94,43,172,43,230,44,32,44,52,44,154,45,40,45,92,45,120,45,170,45,232,46,38,46,166,47,38,47,182,47,244,48,94,48,200,49,62,49,180,50,30,50,158,
    51,30,51,130,51,238,52,92,52,206,53,58,53,134,53,212,54,38,54,114,54,230,55,118,55,216,56,58,56,166,57,18,57,116,57,174,58,46,58,154,59,6,59,124,59,232,60,58,60,150,61,34,61,134,61,
    236,62,86,62,198,63,42,63,154,64,18,64,106,64,208,65,54,65,162,66,8,66,64,66,122,66,184,66,240,67,98,67,204,68,42,68,138,68,238,69,88,69,182,69,226,70,84,70,180,71,20,71,122,71,218,
    72,84,72,198,73,64,0,36,70,21,8,8,77,3,0,7,0,11,0,15,0,19,0,23,0,27,0,31,0,35,0,39,0,43,0,47,0,51,0,55,0,59,0,63,0,67,0,71,0,75,0,79,0,83,0,87,0,91,0,95,0,99,0,103,0,107,0,111,0,115,
    0,119,0,123,0,127,0,131,0,135,0,139,0,143,0,0,17,53,51,21,49,150,3,32,5,130,23,32,33,130,3,211,7,151,115,32,128,133,0,37,252,128,128,2,128,128,190,5,133,74,32,4,133,6,206,5,42,0,7,
    1,128,0,0,2,0,4,0,0,65,139,13,37,0,1,53,51,21,7,146,3,32,3,130,19,32,1,141,133,32,3,141,14,131,13,38,255,0,128,128,0,6,1,130,84,35,2,128,4,128,140,91,132,89,32,51,65,143,6,139,7,33,
    1,0,130,57,32,254,130,3,32,128,132,4,32,4,131,14,138,89,35,0,0,24,0,130,0,33,3,128,144,171,66,55,33,148,115,65,187,19,32,5,130,151,143,155,163,39,32,1,136,182,32,253,134,178,132,7,
    132,200,145,17,32,3,65,48,17,165,17,39,0,0,21,0,128,255,128,3,65,175,17,65,3,27,132,253,131,217,139,201,155,233,155,27,131,67,131,31,130,241,33,255,0,131,181,137,232,132,15,132,4,138,
    247,34,255,0,128,179,238,32,0,130,0,32,20,65,239,48,33,0,19,67,235,10,32,51,65,203,14,65,215,11,32,7,154,27,135,39,32,33,130,35,33,128,128,130,231,32,253,132,231,32,128,132,232,34,
    128,128,254,133,13,136,8,32,253,65,186,5,130,36,130,42,176,234,133,231,34,128,0,0,66,215,44,33,0,1,68,235,6,68,211,19,32,49,68,239,14,139,207,139,47,66,13,7,32,51,130,47,33,1,0,130,
    207,35,128,128,1,0,131,222,131,5,130,212,130,6,131,212,32,0,130,10,133,220,130,233,130,226,32,254,133,255,178,233,39,3,1,128,3,0,2,0,4,68,15,7,68,99,12,130,89,130,104,33,128,4,133,
    93,130,10,38,0,0,11,1,0,255,0,68,63,16,70,39,9,66,215,8,32,7,68,77,6,68,175,14,32,29,68,195,6,132,7,35,2,0,128,255,131,91,132,4,65,178,5,141,111,67,129,23,165,135,140,107,142,135,33,
    21,5,69,71,6,131,7,33,1,0,140,104,132,142,130,4,137,247,140,30,68,255,12,39,11,0,128,0,128,3,0,3,69,171,15,67,251,7,65,15,8,66,249,11,65,229,7,67,211,7,66,13,7,35,1,128,128,254,133,
    93,32,254,131,145,132,4,132,18,32,2,151,128,130,23,34,0,0,9,154,131,65,207,8,68,107,15,68,51,7,32,7,70,59,7,135,121,130,82,32,128,151,111,41,0,0,4,0,128,255,0,1,128,1,137,239,33,0,
    37,70,145,10,65,77,10,65,212,14,37,0,0,0,5,0,128,66,109,5,70,123,10,33,0,19,72,33,18,133,237,70,209,11,33,0,2,130,113,137,119,136,115,33,1,0,133,43,130,5,34,0,0,10,69,135,6,70,219,
    13,66,155,7,65,9,12,66,157,11,66,9,11,32,7,130,141,132,252,66,151,9,137,9,66,15,30,36,0,20,0,128,0,130,218,71,11,42,68,51,8,65,141,7,73,19,15,69,47,23,143,39,66,81,7,32,1,66,55,6,34,
    1,128,128,68,25,5,69,32,6,137,6,136,25,32,254,131,42,32,3,66,88,26,148,26,32,0,130,0,32,14,164,231,70,225,12,66,233,7,67,133,19,71,203,15,130,161,32,255,130,155,32,254,139,127,134,
    12,164,174,33,0,15,164,159,33,59,0,65,125,20,66,25,7,32,5,68,191,6,66,29,7,144,165,65,105,9,35,128,128,255,0,137,2,133,182,164,169,33,128,128,197,171,130,155,68,235,7,32,21,70,77,19,
    66,21,10,68,97,8,66,30,5,66,4,43,34,0,17,0,71,19,41,65,253,20,71,25,23,65,91,15,65,115,7,34,2,128,128,66,9,8,130,169,33,1,0,66,212,13,132,28,72,201,43,35,0,0,0,18,66,27,38,76,231,5,
    68,157,20,135,157,32,7,68,185,13,65,129,28,66,20,5,32,253,66,210,11,65,128,49,133,61,32,0,65,135,6,74,111,37,72,149,12,66,203,19,65,147,19,68,93,7,68,85,8,76,4,5,33,255,0,133,129,34,
    254,0,128,68,69,8,181,197,34,0,0,12,65,135,32,65,123,20,69,183,27,133,156,66,50,5,72,87,10,67,137,32,33,0,19,160,139,78,251,13,68,55,20,67,119,19,65,91,36,69,177,15,32,254,143,16,65,
    98,53,32,128,130,0,32,0,66,43,54,70,141,23,66,23,15,131,39,69,47,11,131,15,70,129,19,74,161,9,36,128,255,0,128,254,130,153,65,148,32,67,41,9,34,0,0,4,79,15,5,73,99,10,71,203,8,32,3,
    72,123,6,72,43,8,32,2,133,56,131,99,130,9,34,0,0,6,72,175,5,73,159,14,144,63,135,197,132,189,133,66,33,255,0,73,6,7,70,137,12,35,0,0,0,10,130,3,73,243,25,67,113,12,65,73,7,69,161,7,
    138,7,37,21,2,0,128,128,254,134,3,73,116,27,33,128,128,130,111,39,12,0,128,1,0,3,128,2,72,219,21,35,43,0,47,0,67,47,20,130,111,33,21,1,68,167,13,81,147,8,133,230,32,128,77,73,6,32,
    128,131,142,134,18,130,6,32,255,75,18,12,131,243,37,128,0,128,3,128,3,74,231,21,135,123,32,29,134,107,135,7,32,21,74,117,7,135,7,134,96,135,246,74,103,23,132,242,33,0,10,67,151,28,
    67,133,20,66,141,11,131,11,32,3,77,71,6,32,128,130,113,32,1,81,4,6,134,218,66,130,24,131,31,34,0,26,0,130,0,77,255,44,83,15,11,148,155,68,13,7,32,49,78,231,18,79,7,11,73,243,11,32,
    33,65,187,10,130,63,65,87,8,73,239,19,35,0,128,1,0,131,226,32,252,65,100,6,32,128,139,8,33,1,0,130,21,32,253,72,155,44,73,255,20,32,128,71,67,8,81,243,39,67,15,20,74,191,23,68,121,
    27,32,1,66,150,6,32,254,79,19,11,131,214,32,128,130,215,37,2,0,128,253,0,128,136,5,65,220,24,147,212,130,210,33,0,24,72,219,42,84,255,13,67,119,16,69,245,19,72,225,19,65,3,15,69,93,
    19,131,55,132,178,71,115,14,81,228,6,142,245,33,253,0,132,43,172,252,65,16,11,75,219,8,65,219,31,66,223,24,75,223,10,33,29,1,80,243,10,66,175,8,131,110,134,203,133,172,130,16,70,30,
    7,164,183,130,163,32,20,65,171,48,65,163,36,65,143,23,65,151,19,65,147,13,65,134,17,133,17,130,216,67,114,5,164,217,65,137,12,72,147,48,79,71,19,74,169,22,80,251,8,65,173,7,66,157,
    15,74,173,15,32,254,65,170,8,71,186,45,72,131,6,77,143,40,187,195,152,179,65,123,38,68,215,57,68,179,15,65,85,7,69,187,14,32,21,66,95,15,67,19,25,32,1,83,223,6,32,2,76,240,7,77,166,
    43,65,8,5,130,206,32,0,67,39,54,143,167,66,255,19,82,193,11,151,47,85,171,5,67,27,17,132,160,69,172,11,69,184,56,66,95,6,33,12,1,130,237,32,2,68,179,27,68,175,16,80,135,15,72,55,7,
    71,87,12,73,3,12,132,12,66,75,32,76,215,5,169,139,147,135,148,139,81,12,12,81,185,36,75,251,7,65,23,27,76,215,9,87,165,12,65,209,15,72,157,7,65,245,31,32,128,71,128,6,32,1,82,125,5,
    34,0,128,254,131,169,32,254,131,187,71,180,9,132,27,32,2,88,129,44,32,0,78,47,40,65,79,23,79,171,14,32,21,71,87,8,72,15,14,65,224,33,130,139,74,27,62,93,23,7,68,31,7,75,27,7,139,15,
    74,3,7,74,23,27,65,165,11,65,177,15,67,123,5,32,1,130,221,32,252,71,96,5,74,12,12,133,244,130,25,34,1,0,128,130,2,139,8,93,26,8,65,9,32,65,57,14,140,14,32,0,73,79,67,68,119,11,135,
    11,32,51,90,75,14,139,247,65,43,7,131,19,139,11,69,159,11,65,247,6,36,1,128,128,253,0,90,71,9,33,1,0,132,14,32,128,89,93,14,69,133,6,130,44,131,30,131,6,65,20,56,33,0,16,72,179,40,
    75,47,12,65,215,19,74,95,19,65,43,11,131,168,67,110,5,75,23,17,69,106,6,75,65,5,71,204,43,32,0,80,75,47,71,203,15,159,181,68,91,11,67,197,7,73,101,13,68,85,6,33,128,128,130,214,130,
    25,32,254,74,236,48,130,194,37,0,18,0,128,255,128,77,215,40,65,139,64,32,51,80,159,10,65,147,39,130,219,84,212,43,130,46,75,19,97,74,33,11,65,201,23,65,173,31,33,1,0,79,133,6,66,150,
    5,67,75,48,85,187,6,70,207,37,32,71,87,221,13,73,163,14,80,167,15,132,15,83,193,19,82,209,8,78,99,9,72,190,11,77,110,49,89,63,5,80,91,35,99,63,32,70,235,23,81,99,10,69,148,10,65,110,
    36,32,0,65,99,47,95,219,11,68,171,51,66,87,7,72,57,7,74,45,17,143,17,65,114,50,33,14,0,65,111,40,159,195,98,135,15,35,7,53,51,21,100,78,9,95,146,16,32,254,82,114,6,32,128,67,208,37,
    130,166,99,79,58,32,17,96,99,14,72,31,19,72,87,31,82,155,7,67,47,14,32,21,131,75,134,231,72,51,17,72,78,8,133,8,80,133,6,33,253,128,88,37,9,66,124,36,72,65,12,134,12,71,55,43,66,139,
    27,85,135,10,91,33,12,65,35,11,66,131,11,71,32,8,90,127,6,130,244,71,76,11,168,207,33,0,12,66,123,32,32,0,65,183,15,68,135,11,66,111,7,67,235,11,66,111,15,32,254,97,66,12,160,154,67,
    227,52,80,33,15,87,249,15,93,45,31,75,111,12,93,45,11,77,99,9,160,184,81,31,12,32,15,98,135,30,104,175,7,77,249,36,69,73,15,78,5,12,32,254,66,151,19,34,128,128,4,87,32,12,149,35,133,
    21,96,151,31,32,19,72,35,5,98,173,15,143,15,32,21,143,99,158,129,33,0,0,65,35,52,65,11,15,147,15,98,75,11,33,1,0,143,151,132,15,32,254,99,200,37,132,43,130,4,39,0,10,0,128,1,128,3,
    0,104,151,14,97,187,20,69,131,15,67,195,11,87,227,7,33,128,128,132,128,33,254,0,68,131,9,65,46,26,42,0,0,0,7,0,0,255,128,3,128,0,88,223,15,33,0,21,89,61,22,66,209,12,65,2,12,37,0,2,
    1,0,3,128,101,83,8,36,0,1,53,51,29,130,3,34,21,1,0,66,53,8,32,0,68,215,6,100,55,25,107,111,9,66,193,11,72,167,8,73,143,31,139,31,33,1,0,131,158,32,254,132,5,33,253,128,65,16,9,133,
    17,89,130,25,141,212,33,0,0,93,39,8,90,131,25,93,39,14,66,217,6,106,179,8,159,181,71,125,15,139,47,138,141,87,11,14,76,23,14,65,231,26,140,209,66,122,8,81,179,5,101,195,26,32,47,74,
    75,13,69,159,11,83,235,11,67,21,16,136,167,131,106,130,165,130,15,32,128,101,90,24,134,142,32,0,65,103,51,108,23,11,101,231,15,75,173,23,74,237,23,66,15,6,66,46,17,66,58,17,65,105,
    49,66,247,55,71,179,12,70,139,15,86,229,7,84,167,15,32,1,95,72,12,89,49,6,33,128,128,65,136,38,66,30,9,32,0,100,239,7,66,247,29,70,105,20,65,141,19,69,81,15,130,144,32,128,83,41,5,
    32,255,131,177,68,185,5,133,126,65,97,37,32,0,130,0,33,21,0,130,55,66,195,28,67,155,13,34,79,0,83,66,213,13,73,241,19,66,59,19,65,125,11,135,201,66,249,16,32,128,66,44,11,66,56,17,
    68,143,8,68,124,38,67,183,12,96,211,9,65,143,29,112,171,5,32,0,68,131,63,34,33,53,51,71,121,11,32,254,98,251,16,32,253,74,231,10,65,175,37,133,206,37,0,0,8,1,0,0,107,123,11,113,115,
    9,33,0,1,130,117,131,3,73,103,7,66,51,18,66,44,5,133,75,70,88,5,32,254,65,39,12,68,80,9,34,12,0,128,107,179,28,68,223,6,155,111,86,147,15,32,2,131,82,141,110,33,254,0,130,15,32,4,103,
    184,15,141,35,87,176,5,83,11,5,71,235,23,114,107,11,65,189,16,70,33,15,86,153,31,135,126,86,145,30,65,183,41,32,0,130,0,32,10,65,183,24,34,35,0,39,67,85,9,65,179,15,143,15,33,1,0,65,
    28,17,157,136,130,123,32,20,130,3,32,0,97,135,24,115,167,19,80,71,12,32,51,110,163,14,78,35,19,131,19,155,23,77,229,8,78,9,17,151,17,67,231,46,94,135,8,73,31,31,93,215,56,82,171,25,
    72,77,8,162,179,169,167,99,131,11,69,85,19,66,215,15,76,129,13,68,115,22,72,79,35,67,113,5,34,0,0,19,70,31,46,65,89,52,73,223,15,85,199,33,95,33,8,132,203,73,29,32,67,48,16,177,215,
    101,13,15,65,141,43,69,141,15,75,89,5,70,0,11,70,235,21,178,215,36,10,0,128,0,0,71,207,24,33,0,19,100,67,6,80,215,11,66,67,7,80,43,12,71,106,7,80,192,5,65,63,5,66,217,26,33,0,13,156,
    119,68,95,5,72,233,12,134,129,85,81,11,76,165,20,65,43,8,73,136,8,75,10,31,38,128,128,0,0,0,13,1,130,4,32,3,106,235,29,114,179,12,66,131,23,32,7,77,133,6,67,89,12,131,139,116,60,9,
    89,15,37,32,0,74,15,7,103,11,22,65,35,5,33,55,0,93,81,28,67,239,23,78,85,5,107,93,14,66,84,17,65,193,26,74,183,10,66,67,34,143,135,79,91,15,32,7,117,111,8,75,56,9,84,212,9,154,134,
    32,0,130,0,32,18,130,3,70,171,41,83,7,16,70,131,19,84,191,15,84,175,19,84,167,30,84,158,12,154,193,68,107,15,33,0,0,65,79,42,65,71,7,73,55,7,118,191,16,83,180,9,32,255,76,166,9,154,
    141,32,0,130,0,69,195,52,65,225,15,151,15,75,215,31,80,56,10,68,240,17,100,32,9,70,147,39,65,93,12,71,71,41,92,85,15,84,135,23,78,35,15,110,27,10,84,125,8,107,115,29,136,160,38,0,0,
    14,0,128,255,0,82,155,24,67,239,8,119,255,11,69,131,11,77,29,6,112,31,8,134,27,105,203,8,32,2,75,51,11,75,195,12,74,13,29,136,161,37,128,0,0,0,11,1,130,163,82,115,8,125,191,17,69,35,
    12,74,137,15,143,15,32,1,65,157,12,136,12,161,142,65,43,40,65,199,6,65,19,24,102,185,11,76,123,11,99,6,12,135,12,32,254,130,8,161,155,101,23,9,39,8,0,0,1,128,3,128,2,78,63,17,72,245,
    12,67,41,11,90,167,9,32,128,97,49,9,32,128,109,51,14,132,97,81,191,8,130,97,125,99,12,121,35,9,127,75,15,71,79,12,81,151,23,87,97,7,70,223,15,80,245,16,105,97,15,32,254,113,17,6,32,
    128,130,8,105,105,8,76,122,18,65,243,21,74,63,7,38,4,1,0,255,0,2,0,119,247,28,133,65,32,255,141,91,35,0,0,0,16,67,63,36,34,59,0,63,77,59,9,119,147,11,143,241,66,173,15,66,31,11,67,
    75,8,81,74,16,32,128,131,255,87,181,42,127,43,5,34,255,128,2,120,235,11,37,19,0,23,0,0,37,109,191,14,118,219,7,127,43,14,65,79,14,35,0,0,0,3,73,91,5,130,5,38,3,0,7,0,11,0,0,70,205,
    11,88,221,12,32,0,73,135,7,87,15,22,73,135,10,79,153,15,97,71,19,65,49,11,32,1,131,104,121,235,11,80,65,11,142,179,144,14,81,123,46,32,1,88,217,5,112,5,8,65,201,15,83,29,15,122,147,
    11,135,179,142,175,143,185,67,247,39,66,199,7,35,5,0,128,3,69,203,15,123,163,12,67,127,7,130,119,71,153,10,141,102,70,175,8,32,128,121,235,30,136,89,100,191,11,116,195,11,111,235,15,
    72,39,7,32,2,97,43,5,132,5,94,67,8,131,8,125,253,10,32,3,65,158,16,146,16,130,170,40,0,21,0,128,0,0,3,128,5,88,219,15,24,64,159,32,135,141,65,167,15,68,163,10,97,73,49,32,255,82,58,
    7,93,80,8,97,81,16,24,67,87,52,34,0,0,5,130,231,33,128,2,80,51,13,65,129,8,113,61,6,132,175,65,219,5,130,136,77,152,17,32,0,95,131,61,70,215,6,33,21,51,90,53,10,78,97,23,105,77,31,
    65,117,7,139,75,24,68,195,9,24,64,22,9,33,0,128,130,11,33,128,128,66,25,5,121,38,5,134,5,134,45,66,40,36,66,59,18,34,128,0,0,66,59,81,135,245,123,103,19,120,159,19,77,175,12,33,255,
    0,87,29,10,94,70,21,66,59,54,39,3,1,128,3,0,2,128,4,24,65,7,15,66,47,7,72,98,12,37,0,0,0,3,1,0,24,65,55,21,131,195,32,1,67,178,6,33,4,0,77,141,8,32,6,131,47,74,67,16,24,69,3,20,24,
    65,251,7,133,234,130,229,94,108,17,35,0,0,6,0,141,175,86,59,5,162,79,85,166,8,70,112,13,32,13,24,64,67,26,24,71,255,7,123,211,12,80,121,11,69,215,15,66,217,11,69,71,10,131,113,132,
    126,119,90,9,66,117,19,132,19,32,0,130,0,24,64,47,59,33,7,0,73,227,5,68,243,15,85,13,12,76,37,22,74,254,15,130,138,33,0,4,65,111,6,137,79,65,107,16,32,1,77,200,6,34,128,128,3,75,154,
    12,37,0,16,0,0,2,0,104,115,36,140,157,68,67,19,68,51,15,106,243,15,134,120,70,37,10,68,27,10,140,152,65,121,24,32,128,94,155,7,67,11,8,24,74,11,25,65,3,12,83,89,18,82,21,37,67,200,
    5,130,144,24,64,172,12,33,4,0,134,162,74,80,14,145,184,32,0,130,0,69,251,20,32,19,81,243,5,82,143,8,33,5,53,89,203,5,133,112,79,109,15,33,0,21,130,71,80,175,41,36,75,0,79,0,83,121,
    117,9,87,89,27,66,103,11,70,13,15,75,191,11,135,67,87,97,20,109,203,5,69,246,8,108,171,5,78,195,38,65,51,13,107,203,11,77,3,17,24,75,239,17,65,229,28,79,129,39,130,175,32,128,123,253,
    7,132,142,24,65,51,15,65,239,41,36,128,128,0,0,13,65,171,5,66,163,28,136,183,118,137,11,80,255,15,67,65,7,74,111,8,32,0,130,157,32,253,24,76,35,10,103,212,5,81,175,9,69,141,7,66,150,
    29,131,158,24,75,199,28,124,185,7,76,205,15,68,124,14,32,3,123,139,16,130,16,33,128,128,108,199,6,33,0,3,65,191,35,107,11,6,73,197,11,24,70,121,15,83,247,15,24,70,173,23,69,205,14,
    32,253,131,140,32,254,136,4,94,198,9,32,3,78,4,13,66,127,13,143,13,32,0,130,0,33,16,0,24,69,59,39,109,147,12,76,253,19,24,69,207,15,69,229,15,130,195,71,90,10,139,10,130,152,73,43,
    40,91,139,10,65,131,37,35,75,0,79,0,84,227,12,143,151,68,25,15,80,9,23,95,169,11,34,128,2,128,112,186,5,130,6,83,161,19,76,50,6,130,37,65,145,44,110,83,5,32,16,67,99,6,71,67,15,76,
    55,17,140,215,67,97,23,76,69,15,77,237,11,104,211,23,77,238,11,65,154,43,33,0,10,83,15,28,83,13,20,67,145,19,67,141,14,97,149,21,68,9,15,86,251,5,66,207,5,66,27,37,82,1,23,127,71,12,
    94,235,10,110,175,24,98,243,15,132,154,132,4,24,66,69,10,32,4,67,156,43,130,198,35,2,1,0,4,75,27,9,69,85,9,95,240,7,32,128,130,35,32,28,66,43,40,24,82,63,23,83,123,12,72,231,15,127,
    59,23,116,23,19,117,71,7,24,77,99,15,67,111,15,71,101,8,36,2,128,128,252,128,127,60,11,32,1,132,16,130,18,141,24,67,107,9,32,3,68,194,15,175,15,38,0,11,0,128,1,128,2,80,63,25,32,0,
    24,65,73,11,69,185,15,83,243,16,32,0,24,81,165,8,130,86,77,35,6,155,163,88,203,5,24,66,195,30,70,19,19,24,80,133,15,32,1,75,211,8,32,254,108,133,8,79,87,20,65,32,9,41,0,0,7,0,128,0,
    0,2,128,2,68,87,15,66,1,16,92,201,16,24,76,24,17,133,17,34,128,0,30,66,127,64,34,115,0,119,73,205,9,66,43,11,109,143,15,24,79,203,11,90,143,15,131,15,155,31,65,185,15,86,87,11,35,128,
    128,253,0,69,7,6,130,213,33,1,0,119,178,15,142,17,66,141,74,83,28,6,36,7,0,0,4,128,82,39,18,76,149,12,67,69,21,32,128,79,118,15,32,0,130,0,32,8,131,206,32,2,79,83,9,100,223,14,102,
    113,23,115,115,7,24,65,231,12,130,162,32,4,68,182,19,130,102,93,143,8,69,107,29,24,77,255,12,143,197,72,51,7,76,195,15,132,139,85,49,15,130,152,131,18,71,81,23,70,14,11,36,0,10,0,128,
    2,69,59,9,89,151,15,66,241,11,76,165,12,71,43,15,75,49,13,65,12,23,132,37,32,0,179,115,130,231,95,181,16,132,77,32,254,67,224,8,65,126,20,79,171,8,32,2,89,81,5,75,143,6,80,41,8,34,
    2,0,128,24,81,72,9,32,0,130,0,35,17,0,0,255,77,99,39,95,65,36,67,109,15,24,69,93,11,77,239,5,95,77,23,35,128,1,0,128,24,86,7,8,132,167,32,2,69,198,41,130,202,33,0,26,120,75,44,24,89,
    51,15,71,243,12,70,239,11,24,84,3,11,66,7,11,71,255,10,32,21,69,155,35,88,151,12,32,128,74,38,10,65,210,8,74,251,5,65,226,5,75,201,13,32,3,65,9,41,146,41,40,0,0,0,9,1,0,1,0,2,91,99,
    19,32,35,106,119,13,70,219,15,83,239,12,137,154,32,2,67,252,19,36,128,0,0,4,1,130,196,32,2,130,8,91,107,8,32,0,135,81,24,73,211,8,132,161,73,164,13,36,0,8,0,128,2,105,123,26,139,67,
    76,99,15,34,1,0,128,135,76,83,156,20,92,104,8,67,251,30,24,86,47,27,123,207,12,24,86,7,15,71,227,8,32,4,65,20,20,131,127,32,0,130,123,32,0,71,223,26,32,19,90,195,22,71,223,15,84,200,
    6,32,128,133,241,24,84,149,9,67,41,25,36,0,0,0,22,0,88,111,49,32,87,66,21,5,77,3,27,123,75,7,71,143,19,135,183,71,183,19,130,171,74,252,5,131,5,89,87,17,32,1,132,18,130,232,68,11,10,
    33,1,128,70,208,16,66,230,18,147,18,130,254,223,255,75,27,23,65,59,15,135,39,155,255,34,128,128,254,104,92,8,33,0,128,65,32,11,65,1,58,33,26,0,130,0,72,71,18,78,55,17,76,11,19,86,101,
    12,75,223,11,89,15,11,24,76,87,15,75,235,15,131,15,72,95,7,85,71,11,72,115,11,73,64,6,34,1,128,128,66,215,9,34,128,254,128,134,14,33,128,255,67,102,5,32,0,130,16,70,38,11,66,26,57,
    88,11,8,24,76,215,34,78,139,7,95,245,7,32,7,24,73,75,23,32,128,131,167,130,170,101,158,9,82,49,22,118,139,6,32,18,67,155,44,116,187,9,108,55,14,80,155,23,66,131,15,93,77,10,131,168,
    32,128,73,211,12,24,75,187,22,32,4,96,71,20,67,108,19,132,19,120,207,8,32,5,76,79,15,66,111,21,66,95,8,32,3,190,211,111,3,8,211,212,32,20,65,167,44,34,75,0,79,97,59,13,32,33,112,63,
    10,65,147,19,69,39,19,143,39,24,66,71,9,130,224,65,185,43,94,176,12,65,183,24,71,38,8,24,72,167,7,65,191,38,136,235,24,96,167,12,65,203,62,115,131,13,65,208,42,175,235,67,127,6,32,
    4,76,171,29,114,187,5,32,71,65,211,5,65,203,68,72,51,8,164,219,32,0,172,214,71,239,58,78,3,27,66,143,15,77,19,15,147,31,35,33,53,51,21,66,183,10,173,245,66,170,30,150,30,34,0,0,23,
    80,123,54,76,1,16,73,125,15,82,245,11,167,253,24,76,85,12,70,184,5,32,254,131,185,37,254,0,128,1,0,128,133,16,117,158,18,92,27,38,65,3,17,130,251,35,17,0,128,254,24,69,83,39,140,243,
    121,73,19,109,167,7,81,41,15,24,95,175,12,102,227,15,121,96,11,24,95,189,7,32,3,145,171,154,17,24,77,47,9,33,0,5,70,71,37,68,135,7,32,29,117,171,11,69,87,15,24,79,97,19,24,79,149,23,
    131,59,32,1,75,235,5,72,115,11,72,143,7,132,188,71,27,46,131,51,32,0,69,95,6,175,215,32,21,131,167,81,15,19,151,191,151,23,131,215,71,43,5,32,254,24,79,164,24,74,109,8,77,166,13,65,
    176,26,88,162,5,98,159,6,171,219,120,247,6,79,29,8,99,169,10,103,59,19,65,209,35,131,35,91,25,19,112,94,15,83,36,8,173,229,33,20,0,88,75,43,71,31,12,65,191,71,33,1,0,130,203,32,254,
    131,4,68,66,7,67,130,6,104,61,13,173,215,38,13,1,0,0,0,2,128,67,111,28,74,129,16,104,35,19,79,161,16,87,14,7,138,143,132,10,67,62,36,114,115,5,162,151,67,33,16,108,181,15,143,151,67,
    5,5,24,100,242,15,170,153,34,0,0,14,65,51,34,32,55,79,75,9,32,51,74,7,10,65,57,38,132,142,32,254,72,0,14,139,163,32,128,80,254,8,67,158,21,65,63,7,32,4,72,227,27,95,155,12,67,119,19,
    124,91,24,149,154,72,177,34,97,223,8,155,151,24,108,227,15,88,147,16,72,117,19,68,35,11,92,253,15,70,199,15,24,87,209,17,32,2,87,233,7,32,1,24,88,195,10,119,24,8,32,3,81,227,24,65,
    125,21,35,128,128,0,25,76,59,48,24,90,187,9,97,235,12,66,61,11,91,105,19,24,79,141,11,24,79,117,15,24,79,129,27,90,53,13,130,13,32,253,131,228,24,79,133,40,69,70,8,66,137,31,65,33,
    19,96,107,8,68,119,29,66,7,5,68,125,16,65,253,19,65,241,27,24,90,179,13,24,79,143,18,33,128,128,130,246,32,254,130,168,68,154,36,77,51,9,97,47,5,167,195,32,21,131,183,78,239,27,155,
    195,78,231,14,201,196,77,11,6,32,5,73,111,37,97,247,12,77,19,31,155,207,78,215,19,162,212,69,17,14,66,91,19,80,143,57,78,203,39,159,215,32,128,93,134,8,24,80,109,24,66,113,15,169,215,
    66,115,6,32,4,69,63,33,32,0,101,113,7,86,227,35,143,211,36,49,53,51,21,1,77,185,14,65,159,28,69,251,34,67,56,8,33,9,0,24,107,175,25,90,111,12,110,251,11,119,189,24,119,187,34,87,15,
    9,32,4,66,231,37,90,39,7,66,239,8,84,219,15,69,105,23,24,85,27,27,87,31,11,33,1,128,76,94,6,32,1,85,241,7,33,128,128,106,48,10,33,128,128,69,136,11,133,13,24,79,116,49,84,236,8,24,
    91,87,9,32,5,165,255,69,115,12,66,27,15,159,15,24,72,247,12,74,178,5,24,80,64,15,33,0,128,143,17,77,89,51,130,214,24,81,43,7,170,215,74,49,8,159,199,143,31,139,215,69,143,5,32,254,
    24,81,50,35,181,217,84,123,70,143,195,159,15,65,187,16,66,123,7,65,175,15,65,193,29,68,207,39,79,27,5,70,131,6,32,4,68,211,33,33,67,0,83,143,14,159,207,143,31,140,223,33,0,128,24,80,
    82,14,24,93,16,23,32,253,65,195,5,68,227,40,133,214,107,31,7,32,5,67,115,27,87,9,8,107,31,43,66,125,6,32,0,103,177,23,131,127,72,203,36,32,0,110,103,8,155,163,73,135,6,32,19,24,112,
    99,10,65,71,11,73,143,19,143,31,126,195,5,24,85,21,9,24,76,47,14,32,254,24,93,77,36,68,207,11,39,25,0,0,255,128,3,128,4,66,51,37,95,247,13,82,255,24,76,39,19,147,221,66,85,27,24,118,
    7,8,24,74,249,12,76,74,8,91,234,8,67,80,17,131,222,33,253,0,121,30,44,73,0,16,69,15,6,32,0,65,23,38,69,231,12,65,179,6,98,131,16,86,31,27,24,108,157,14,80,160,8,24,65,46,17,33,4,0,
    96,2,18,144,191,65,226,8,68,19,5,171,199,80,9,15,180,199,67,89,5,32,255,24,79,173,28,174,201,24,79,179,50,32,1,24,122,5,10,82,61,10,180,209,83,19,8,32,128,24,80,129,27,111,248,43,131,
    71,24,115,103,8,67,127,41,78,213,24,100,247,19,66,115,39,75,107,5,32,254,165,219,78,170,40,24,112,163,49,32,1,97,203,6,65,173,64,32,0,83,54,7,133,217,88,37,12,32,254,131,28,33,128,
    3,67,71,44,84,183,6,32,5,69,223,33,96,7,7,123,137,16,192,211,24,112,14,9,32,255,67,88,29,68,14,10,84,197,38,33,0,22,116,47,50,32,87,106,99,9,116,49,15,89,225,15,97,231,23,70,41,19,
    82,85,8,93,167,6,32,253,132,236,108,190,7,89,251,5,116,49,58,33,128,128,131,234,32,15,24,74,67,38,70,227,24,24,83,45,23,89,219,12,70,187,12,89,216,19,32,2,69,185,24,141,24,70,143,66,
    24,82,119,56,78,24,10,32,253,133,149,132,6,24,106,233,7,69,198,48,178,203,81,243,12,68,211,15,106,255,23,66,91,15,69,193,7,100,39,10,24,83,72,16,176,204,33,19,0,88,207,45,68,21,12,
    68,17,10,65,157,53,68,17,6,32,254,92,67,10,65,161,25,69,182,43,24,118,91,47,69,183,18,181,209,111,253,12,89,159,8,66,112,12,69,184,45,35,0,0,0,9,24,80,227,26,73,185,16,118,195,15,131,
    15,33,1,0,65,59,15,66,39,27,160,111,66,205,12,148,111,143,110,33,128,128,156,112,24,81,199,8,75,199,23,66,117,20,155,121,32,254,68,126,12,72,213,29,134,239,149,123,89,27,16,148,117,
    65,245,8,24,71,159,14,141,134,134,28,73,51,55,109,77,15,105,131,11,68,67,11,76,169,27,107,209,12,102,174,8,32,128,72,100,18,116,163,56,79,203,11,75,183,44,85,119,19,71,119,23,151,227,
    32,1,93,27,8,65,122,5,77,102,8,110,120,20,66,23,8,66,175,17,66,63,12,133,12,79,35,8,74,235,33,67,149,16,69,243,15,78,57,15,69,235,16,67,177,7,151,192,130,23,67,84,29,141,192,174,187,
    77,67,15,69,11,12,159,187,77,59,10,199,189,24,70,235,50,96,83,19,66,53,23,105,65,19,77,47,12,163,199,66,67,37,78,207,50,67,23,23,174,205,67,228,6,71,107,13,67,22,14,66,85,11,83,187,
    38,124,47,49,95,7,19,66,83,23,67,23,19,24,96,78,17,80,101,16,71,98,40,33,0,7,88,131,22,24,89,245,12,84,45,12,102,213,5,123,12,9,32,2,126,21,14,43,255,0,128,128,0,0,20,0,128,255,128,
    3,126,19,39,32,75,106,51,7,113,129,15,24,110,135,19,126,47,15,115,117,11,69,47,11,32,2,109,76,9,102,109,9,32,128,75,2,10,130,21,32,254,69,47,6,32,3,94,217,47,32,0,65,247,10,69,15,46,
    65,235,31,65,243,15,101,139,10,66,174,14,65,247,16,72,102,28,69,17,14,84,243,9,165,191,88,47,48,66,53,12,32,128,71,108,6,203,193,32,17,75,187,42,73,65,16,65,133,52,114,123,9,167,199,
    69,21,37,86,127,44,75,171,11,180,197,78,213,12,148,200,81,97,46,24,95,243,9,32,4,66,75,33,113,103,9,87,243,36,143,225,24,84,27,31,90,145,8,148,216,67,49,5,24,84,34,14,75,155,27,67,
    52,13,140,13,36,0,20,0,128,255,24,135,99,46,88,59,43,155,249,80,165,7,136,144,71,161,23,32,253,132,33,32,254,88,87,44,136,84,35,128,0,0,21,81,103,5,94,47,44,76,51,12,143,197,151,15,
    65,215,31,24,64,77,13,65,220,20,65,214,14,71,4,40,65,213,13,32,0,130,0,35,21,1,2,0,135,0,34,36,0,72,134,10,36,1,0,26,0,130,134,11,36,2,0,14,0,108,134,11,32,3,138,23,32,4,138,11,34,
    5,0,20,134,33,34,0,0,6,132,23,32,1,134,15,32,18,130,25,133,11,37,1,0,13,0,49,0,133,11,36,2,0,7,0,38,134,11,36,3,0,17,0,45,134,11,32,4,138,35,36,5,0,10,0,62,134,23,32,6,132,23,36,3,
    0,1,4,9,130,87,131,167,133,11,133,167,133,11,133,167,133,11,37,3,0,34,0,122,0,133,11,133,167,133,11,133,167,133,11,133,167,34,50,0,48,130,1,34,52,0,47,134,5,8,49,49,0,53,98,121,32,
    84,114,105,115,116,97,110,32,71,114,105,109,109,101,114,82,101,103,117,108,97,114,84,84,88,32,80,114,111,103,103,121,67,108,101,97,110,84,84,50,48,48,52,47,130,2,53,49,53,0,98,0,121,
    0,32,0,84,0,114,0,105,0,115,0,116,0,97,0,110,130,15,32,71,132,15,36,109,0,109,0,101,130,9,32,82,130,5,36,103,0,117,0,108,130,29,32,114,130,43,34,84,0,88,130,35,32,80,130,25,34,111,
    0,103,130,1,34,121,0,67,130,27,32,101,132,59,32,84,130,31,33,0,0,65,155,9,34,20,0,0,65,11,6,130,8,135,2,33,1,1,130,9,8,120,1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,
    1,15,1,16,1,17,1,18,1,19,1,20,1,21,1,22,1,23,1,24,1,25,1,26,1,27,1,28,1,29,1,30,1,31,1,32,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,
    22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,130,187,8,66,33,0,34,0,35,0,36,0,37,0,38,0,39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,
    57,0,58,0,59,0,60,0,61,0,62,0,63,0,64,0,65,0,66,130,243,9,75,68,0,69,0,70,0,71,0,72,0,73,0,74,0,75,0,76,0,77,0,78,0,79,0,80,0,81,0,82,0,83,0,84,0,85,0,86,0,87,0,88,0,89,0,90,0,91,0,
    92,0,93,0,94,0,95,0,96,0,97,1,33,1,34,1,35,1,36,1,37,1,38,1,39,1,40,1,41,1,42,1,43,1,44,1,45,1,46,1,47,1,48,1,49,1,50,1,51,1,52,1,53,1,54,1,55,1,56,1,57,1,58,1,59,1,60,1,61,1,62,1,
    63,1,64,1,65,0,172,0,163,0,132,0,133,0,189,0,150,0,232,0,134,0,142,0,139,0,157,0,169,0,164,0,239,0,138,0,218,0,131,0,147,0,242,0,243,0,141,0,151,0,136,0,195,0,222,0,241,0,158,0,170,
    0,245,0,244,0,246,0,162,0,173,0,201,0,199,0,174,0,98,0,99,0,144,0,100,0,203,0,101,0,200,0,202,0,207,0,204,0,205,0,206,0,233,0,102,0,211,0,208,0,209,0,175,0,103,0,240,0,145,0,214,0,
    212,0,213,0,104,0,235,0,237,0,137,0,106,0,105,0,107,0,109,0,108,0,110,0,160,0,111,0,113,0,112,0,114,0,115,0,117,0,116,0,118,0,119,0,234,0,120,0,122,0,121,0,123,0,125,0,124,0,184,0,
    161,0,127,0,126,0,128,0,129,0,236,0,238,0,186,14,117,110,105,99,111,100,101,35,48,120,48,48,48,49,141,14,32,50,141,14,32,51,141,14,32,52,141,14,32,53,141,14,32,54,141,14,32,55,141,
    14,32,56,141,14,32,57,141,14,32,97,141,14,32,98,141,14,32,99,141,14,32,100,141,14,32,101,141,14,32,102,140,14,33,49,48,141,14,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,
    141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,32,49,141,239,45,49,102,6,100,101,108,101,116,101,4,69,117,114,
    111,140,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,32,56,141,236,
    32,56,141,236,32,56,141,236,32,56,65,220,13,32,57,65,220,13,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,
    239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,32,57,141,239,35,57,102,0,0,5,250,72,249,98,247,
};

static const char* GetDefaultCompressedFontDataTTF(int* out_size)
{
    *out_size = proggy_clean_ttf_compressed_size;
    return (const char*)proggy_clean_ttf_compressed_data;
}
#endif // #ifndef IMGUI_DISABLE_DEFAULT_FONT

#endif // #ifndef IMGUI_DISABLE
"
XxbNc6tg,2025-06-18T17:14:48.255,powerampache,PHP,Wednesday 18th of June 2025 10:14:49 AM CDT,"1.01-80 (80) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""failed to connect to denker.myvnc.com/84.151.29.149 (port 443) from /10.107.111.213 (port 42260) after 15000ms"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:919)

"
mCgb1APG,Untitled,bebo231312312321,JavaScript,Wednesday 18th of June 2025 09:57:41 AM CDT,"{
    ""title"": ""дасда"",
    ""slug"": ""dsadsadsa"",
    ""shortDescription"": ""дсадса"",
    ""mainImage"": {
        ""src"": """",
        ""alt"": """",
        ""caption"": """",
        ""gallery"": []
    },
    ""category"": ""Social"",
    ""location"": {
        ""address"": """",
        ""coordinates"": {
            ""lat"": null,
            ""lng"": null
        }
    },
    ""status"": ""active"",
    ""campaignStatus"": ""open"",
    ""commentsEnabled"": true,
    ""contact"": {
        ""name"": """",
        ""position"": """",
        ""email"": """",
        ""phone"": """",
        ""image"": """"
    },
    ""additionalContacts"": [],
    ""sections"": [
        {
            ""titleSlug"": ""section-1750239126075"",
            ""title"": ""dsadsa"",
            ""content"": ""<p>dsadsadsadsa</p>"",
            ""images"": []
        }
    ],
    ""downloadMaterials"": [],
    ""projects"": [],
    ""stories"": [],
    ""publications"": [],
    ""detailedDescription"": ""<p>dsadsadsa</p>"",
    ""customCategory"": """",
    ""priority"": ""Medium"",
    ""startDate"": ""2025-06-18"",
    ""endDate"": ""2025-06-27"",
    ""duration"": """",
    ""milestones"": [],
    ""targetAge"": [],
    ""targetAudience"": [
        ""Families""
    ],
    ""customAudience"": """",
    ""expectedBudget"": ""543"",
    ""currency"": ""BGN"",
    ""fundingSources"": [
        ""Government""
    ],
    ""partners"": [
        {
            ""titleSlug"": ""1750239148331-yxue5rh7s"",
            ""name"": ""dsadsa"",
            ""description"": """",
            ""website"": """",
            ""type"": ""Strategic"",
            ""logo"": ""https://firebasestorage.googleapis.com/v0/b/pensaclub-909e0.appspot.com/o/initiatives%2Fpartners%2F29d71edc-736a-43e5-8322-c2cf8cb85e0b?alt=media&token=89c1e0b9-474c-4b42-992e-effa84bfeab0"",
            ""visible"": true
        }
    ],
    ""sponsors"": [
        {
            ""id"": ""1750239195377-idm2perkv"",
            ""name"": """",
            ""amount"": """",
            ""currency"": ""BGN"",
            ""sponsorshipType"": ""Financial"",
            ""website"": """",
            ""logo"": ""https://firebasestorage.googleapis.com/v0/b/pensaclub-909e0.appspot.com/o/initiatives%2Fsponsors%2Fcc61d12c-c3e8-4983-b483-b214ce7d6370?alt=media&token=0b258e4c-3b99-4a1f-bee1-d3bc0539fc4a"",
            ""visible"": true
        }
    ],
    ""logo"": null,
    ""responsible"": {
        ""name"": """",
        ""position"": """",
        ""email"": """",
        ""phone"": """"
    },
    ""organization"": {
        ""name"": """",
        ""address"": """",
        ""website"": """"
    },
    ""socialMedia"": {
        ""facebook"": """",
        ""instagram"": """",
        ""linkedin"": """",
        ""twitter"": """"
    },
    ""kpis"": [],
    ""expectedResults"": ""<p></p>"",
    ""progressReport"": ""<p></p>"",
    ""impactMetrics"": [],
    ""testimonials"": [],
    ""tags"": [],
    ""relatedInitiatives"": [],
    ""faq"": [],
    ""gallery"": [],
    ""createdAt"": ""2025-06-18T09:33:21.844Z"",
    ""updatedAt"": ""2025-06-18T09:33:21.844Z""
}"
LWsfia3F,oblivion remastered  - QoL script for the no hud mod,freezmi,Autohotkey,Wednesday 18th of June 2025 09:10:10 AM CDT,"#Requires AutoHotkey v2.0
#Include AutoHotInterception.ahk

; Initialize AHI
keyboardId := 1
AHI := AutoHotInterception()

; Game window title contains some unexpected spaces at the end
gameWindowTitle := ""The Elder Scrolls IV: Oblivion Remastered  ""

; QoL script that toggle the UI visibility while using the 
; No-HUD-No-Effects mod in Oblivion Remastered
; when opening the inventory, map or the system menu
; dependencies:
;  https://www.autohotkey.com/
;  https://github.com/oblitum/Interception
;  https://github.com/evilC/AutoHotInterception
; author: chatgpt


; the HUD must be off when enabling this script
; global toggle state changed via Shift+h
isEnabled := false

; Toggle hotkey: Shift+h
+h::
{
	global isEnabled
    isEnabled := !isEnabled
	
    if isEnabled {
        SoundBeep 300, 150  ; One beep for enabled
    } else {
        SoundBeep 300, 100  ; First low beep
        Sleep 100
        SoundBeep 300, 100  ; Second low beep
    }
    return
}

~i::
~m::
~t::
~Esc::
{
	global isEnabled, AHI, keyboardId
    if !isEnabled
        return
		
    ; Only act if active window title matches
    if WinGetTitle(""A"") != gameWindowTitle {
        return
	}

    ; Send 'End' key (press + release)
    AHI.SendKeyEvent(keyboardId, GetKeySC(""End""), 1)
    Sleep 50
    AHI.SendKeyEvent(keyboardId, GetKeySC(""End""), 0)
}"
Ztgq54y7,NN,cnsnipermike,Lua,Wednesday 18th of June 2025 08:56:09 AM CDT,"if gg.getTargetInfo()[""x64""] then  --if target apps/games is not 64bit,then jump to last code and do abort
--[[
gg.clearResults()
gg.setRanges(16)
gg.searchNumber(10,4)
local count = gg.getResultsCount()
if(count < 1) then
lib='config.arm64_v8a.apk'
gg.setRanges(-2080896)
else
gg.setRanges(16)
gg.clearResults()
lib='libnative-lib.so'
end
]]--
--get cb memory details,auto set lib global key

lib='libnative-lib.so'
targetname='貓咪大戰爭'
targetPkg='jp.co.ponos.battlecatstw'
targetVersion='14.4.0'
targetBuild=1404000
info=gg.getTargetInfo()
FirstCatOffset=0xAA25E0 --first cats offset,get target addr with xa libnative-lib.so
TotalCatNumber=811 -- total cats
AllCatOffset= FirstCatOffset + TotalCatNumber * 4 --all cats offset
function setvalue(address,flags,value) local tt={} tt[1]={} tt[1].address=address tt[1].flags=flags tt[1].value=value gg.setValues(tt) end
function getvalue(address,flags) local tt={} tt[1]={} tt[1].address=address tt[1].flags=flags return gg.getValues(tt) end
function Start()
MAIN = gg.choice({
""修改單貓"",
""腳本資訊"",
""離開"",
})
if MAIN == nil then
gg.toast(""功能表已收起"")
else
if MAIN == 1 then A1() end
if MAIN == 2 then UP() end
if MAIN == 3 then End() end
end
FMXR=-1
end
function A1()
A1SubMenu = gg.choice({
""開啟單貓"",
""關閉單貓"",
""返回上级目录"",
})
if A1SubMenu == nil then
gg.toast('功能表已收起')
else
if A1SubMenu == 1 then A501() end
if A1SubMenu == 2 then A502() end
if A1SubMenu == 3 then Start() end
end
FMXR=-1
end
function A501() --開啟單貓
value=gg.prompt({'想要開啟哪個ID的單貓(ID從0開始, 上限810))'},nil,{""number""})
if value == nil then
	gg.toast('操作被已取消')
else
	local so=gg.getRangesList((lib))[1].start
	local FirstCatData = getvalue(so+FirstCatOffset,4)
	local TargetID = tonumber(value[1])
	local TargetCatOffset = FirstCatOffset + TargetID * 4
	local TargetCatData = getvalue(so+TargetCatOffset,4)
	if((TargetID >= 0) and ( TargetID < TotalCatNumber)) then 
		if(TargetCatData[1].value == FirstCatData[1].value) then
		  gg.alert('此貓咪已經開啟')
		else
	  	  setvalue(TargetCatData[1].address,4,FirstCatData[1].value)
		  gg.toast('開啟貓咪成功')
		end
	else 
	  gg.alert('貓咪ID超出範圍')
	end
end
end
function A502()
value=gg.prompt({'想要關閉哪個ID的單貓(ID從0開始, 上限810))'},nil,{""number""})
if value == nil then
	gg.toast('已取消')
else
	local so=gg.getRangesList((lib))[1].start
	local AllCatData = getvalue(so+AllCatOffset,4)
	local TargetID = tonumber(value[1])
	local TargetCatOffset = FirstCatOffset + TargetID * 4
	local TargetCatData = getvalue(so+TargetCatOffset,4)
	if(TargetID == 0) then
	  gg.toast('最基本的貓咪無法關閉')
	else if((TargetID >= 0) and (TargetID < TotalCatNumber)) then 
		if(TargetCatData[1].value == AllCatData[1].value) then
		  gg.toast('此貓咪已經關閉')
		else
		  setvalue(TargetCatData[1].address,4,AllCatData[1].value)
		  gg.toast('關閉貓咪成功')
		end
	else 
	  gg.toast('貓咪ID超出範圍')
	end
	end
end
end
function UP()
gg.alert('版本號：1.0\n\n遊戲名字 : '..info.label..'\n遊戲版本號 : '..info.versionName..'\n遊戲內部版本號 : '..info.versionCode..'\n遊戲包名 : '..info.packageName..'\n')
end
function End()
gg.setVisible(true)
os.exit()
end
while(true)do
gg.sleep(1)
if gg.isVisible(true) then
FMXR=1
gg.setVisible(false)
end
if FMXR==1 then
Start()
end
end

--abort code
else
gg.alert(""不支持32位游戏\n请安装64位游戏后重试"")
print(""不支持32位游戏\n请安装64位游戏后重试"")
end"
rrMHT0Tp,2025-06-18T22:47:38.472410,powerampache,PHP,Wednesday 18th of June 2025 08:47:40 AM CDT,"1.01-79 (79) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
piwvFrEz,sqliteCRUD.cpp,DrAungWinHtut,C++,Wednesday 18th of June 2025 08:28:31 AM CDT,"#include <iostream>
#include ""sqlite3.h""
void createTable(sqlite3* DB);
void insertDb(sqlite3* DB, const std::string& name);
void readDb(sqlite3* DB);
void updateDb(sqlite3* DB, int id, const std::string& newName);
void deleteDb(sqlite3* DB, int id);
int main() {
    sqlite3* DB;
    int exit = sqlite3_open(""example.db"", &DB);

    if (exit) {
        std::cerr << ""Error opening DB: "" << sqlite3_errmsg(DB) << std::endl;
        return -1;
    }
    std::cout << ""Opened database successfully!"" << std::endl;

	//createTable(DB);
	/*insertDb(DB, ""Aung Win Htut"");
	insertDb(DB, ""Ko Ko"");
	insertDb(DB, ""Aye Aye"");*/
	readDb(DB);
	updateDb(DB, 1, ""Green Hackers"");
	deleteDb(DB, 3);
	readDb(DB);
    sqlite3_close(DB);
	
    return 0;
}

void createTable(sqlite3* DB) {
	const char* sql = ""CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT NOT NULL);"";
	char* errMsg;
	int exit = sqlite3_exec(DB, sql, nullptr, 0, &errMsg);
	if (exit != SQLITE_OK) {
		std::cerr << ""Error creating table: "" << errMsg << std::endl;
		sqlite3_free(errMsg);
	}
	else {
		std::cout << ""Table created successfully!"" << std::endl;
	}
}

void insertDb(sqlite3* DB, const std::string& name) {
	const char* sql = ""INSERT INTO users (name) VALUES (?);"";
	sqlite3_stmt* stmt;
	int exit = sqlite3_prepare_v2(DB, sql, -1, &stmt, nullptr);
	if (exit != SQLITE_OK) {
		std::cerr << ""Error preparing statement: "" << sqlite3_errmsg(DB) << std::endl;
		return;
	}
	sqlite3_bind_text(stmt, 1, name.c_str(), -1, SQLITE_STATIC);
	exit = sqlite3_step(stmt);
	if (exit != SQLITE_DONE) {
		std::cerr << ""Error inserting data: "" << sqlite3_errmsg(DB) << std::endl;
	}
	sqlite3_finalize(stmt);
}

void readDb(sqlite3* DB) {
	const char* sql = ""SELECT * FROM users;"";
	sqlite3_stmt* stmt;
	int exit = sqlite3_prepare_v2(DB, sql, -1, &stmt, nullptr);
	if (exit != SQLITE_OK) {
		std::cerr << ""Error preparing statement: "" << sqlite3_errmsg(DB) << std::endl;
		return;
	}
	while ((exit = sqlite3_step(stmt)) == SQLITE_ROW) {
		int id = sqlite3_column_int(stmt, 0);
		const unsigned char* name = sqlite3_column_text(stmt, 1);
		std::cout << ""ID: "" << id << "", Name: "" << name << std::endl;
	}
	if (exit != SQLITE_DONE) {
		std::cerr << ""Error reading data: "" << sqlite3_errmsg(DB) << std::endl;
	}
	sqlite3_finalize(stmt);
}

void updateDb(sqlite3* DB, int id, const std::string& newName) {
	const char* sql = ""UPDATE users SET name = ? WHERE id = ?;"";
	sqlite3_stmt* stmt;
	int exit = sqlite3_prepare_v2(DB, sql, -1, &stmt, nullptr);
	if (exit != SQLITE_OK) {
		std::cerr << ""Error preparing statement: "" << sqlite3_errmsg(DB) << std::endl;
		return;
	}
	sqlite3_bind_text(stmt, 1, newName.c_str(), -1, SQLITE_STATIC);
	sqlite3_bind_int(stmt, 2, id);
	exit = sqlite3_step(stmt);
	if (exit != SQLITE_DONE) {
		std::cerr << ""Error updating data: "" << sqlite3_errmsg(DB) << std::endl;
	}
	sqlite3_finalize(stmt);
}

void deleteDb(sqlite3* DB, int id) {
	const char* sql = ""DELETE FROM users WHERE id = ?;"";
	sqlite3_stmt* stmt;
	int exit = sqlite3_prepare_v2(DB, sql, -1, &stmt, nullptr);
	if (exit != SQLITE_OK) {
		std::cerr << ""Error preparing statement: "" << sqlite3_errmsg(DB) << std::endl;
		return;
	}
	sqlite3_bind_int(stmt, 1, id);
	exit = sqlite3_step(stmt);
	if (exit != SQLITE_DONE) {
		std::cerr << ""Error deleting data: "" << sqlite3_errmsg(DB) << std::endl;
	}
	sqlite3_finalize(stmt);
}"
qVyLsakm,Untitled,kirzecy670,PostgreSQL,Wednesday 18th of June 2025 08:22:07 AM CDT,"WITH 
watch_device as
  (SELECT userId
   FROM wimc.mp_userDevice
   WHERE deviceType = 'watch'
     AND ts >= '2025-06-01'),

user_setting AS
  (SELECT DISTINCT user_id::UInt64 AS user_id
   FROM stat.user_setting_history
   WHERE ts >= '2025-06-10'
     AND name = 'circles_concept_enabled'
     AND value IN (1, '1', '""1""'))

SELECT toDate(ts) as date,
       count(parent) as users,
       uniqExact(parent) as uniqUesers
from wimc.mp_parentChild pc
join watch_device wd on pc.child = wd.userId
join user_setting us on us.user_id = pc.parent
where ts >= '2025-06-01'
GROUP BY 1
ORDER BY 1 DESC
limit 100;"
ZdQtTGxW,countdown,MChaos,PHP,Wednesday 18th of June 2025 08:09:09 AM CDT,"<div class=""countdown_sale"">
                <div class=""sales-countdown"">
                    <div class=""countdown_sale_info"">
                        <div id=""countdown""></div>
                        <div class=""countdown_info"">
                            <span class=""info_days""><?= DAYS ?></span>
                            <span class=""info_hours""><?= HOURS ?></span>
                            <span class=""info_minutes""><?= MINUTES ?></span>
                            <span class=""info_seconds""><?= SECONDS ?></span>
                        </div>
                    </div>
                </div>
            </div>

<script src=""/app/js/jquery.countdown.js""></script>
<script>
    $(function () {

        <?php
        $startDate = new DateTime($sale->date);
        $currentDate = new DateTime();
        if ($startDate > $currentDate) {
            $sale->date_end = $sale->date;
        }
        ?>

        var note = $('#note'),
            <?php $date = new DateTime($sale->date_end); ?>
            ts = new Date(<?=$date->format('Y')?>, <?=$date->format('m') - 1?>, <?=$date->format('d')?>),
            newYear = true;

        if ((new Date()) > ts) {
            // The new year is here! Count towards something else.
            // Notice the *1000 at the end - time must be in milliseconds
            ts = (new Date()).getTime() + 10 * 24 * 60 * 60 * 1000;
            newYear = false;
        }

        $('#countdown').countdown({
            timestamp: ts,
            callback: function (days, hours, minutes, seconds) {

                var message = """";

                message += days + "" day"" + (days == 1 ? '' : 's') + "", "";
                message += hours + "" hour"" + (hours == 1 ? '' : 's') + "", "";
                message += minutes + "" minute"" + (minutes == 1 ? '' : 's') + "" and "";
                message += seconds + "" second"" + (seconds == 1 ? '' : 's') + "" <br />"";

                if (newYear) {
                    message += ""left until the new year!"";
                } else {
                    message += ""left to 10 days from now!"";
                }

                note.html(message);
            }
        });

    });
</script>
"
7jAWprbG,Untitled,StarCore95,JavaScript,Wednesday 18th of June 2025 06:58:01 AM CDT,"import bridge, { EAdsFormats } from '@vkontakte/vk-bridge';

await bridge.send(""VKWebAppInit"");

setInterval(async () => {
  console.log(
    await bridge.send(""VKWebAppCheckNativeAds"", {
      ad_format: EAdsFormats.INTERSTITIAL,
    }),
  );
}, 1000);"
qAhiWcvg,dataNone,TestGuy1,JSON,Wednesday 18th of June 2025 06:00:08 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'e0adb6cbfc5afc99f70e470b53df0facce7fadf1e8b496d2d869b092e64820c8284355483955f0f713982ce4a339197df0fddb0c426e27a388dabe20b33ebe8b914f166dffd7aa191156fb49be419cd33fdc9edea284f3aa1bbff3e6a9e2c4f05949d15635fb9818d80eaa3feed1a0b4dbc29aad0bebcfa6e0d92b87ab4dc043',
  otherdata: [
    '3e5cc5248eb026d1d2552ec11fbbed51',
    '580c003a61321e7fd67f26502d348a3e',
    'a30a1bac4f446375244da6405738d625',
    '5467c7d742527754c0b0bd27fe74d8db',
    'c323b0705c21dee3c388e29bf7678256',
    '856396215d4763022e4e943ece5a23ad',
    '499a0ba3254600cc58b632b67711c4fc',
    '657943b189ad81ff8400e5669884dcd5'
  ]
}"
ZC7dzBkh,Best Time to Buy & Sell Stocks 2 - Infinite Transactions,Fastrail08,C++,Wednesday 18th of June 2025 05:47:43 AM CDT,"#include <bits/stdc++.h>

using namespace std;

/*
QUESTION - https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/
*/

int getMaxProfitInfiniteTransaction(vector < int > & prices) {
    int totalProfit = 0, minIdx = -1;
    
    for(int i = 0; i < prices.size(); i++){
        //form a minimum OR capture a better minimum to buy
        if(minIdx == -1 || prices[i] < prices[minIdx]){
            minIdx = i;
        }
        //capture the best day to sell
        else{
            // if the next day has lower price than the current day, capture the buy - sell pair and make profit
            if(i != prices.size() - 1 && prices[i + 1] < prices[i]){
                totalProfit += (prices[i] - prices[minIdx]);
                //reset the minIndex/buy day to -1, as we have already captured the profit for this buy, as we made a complete transaction by selling the share today
                minIdx = -1;
            }
            //handling for last index, capture only if a buy exists.
            else if(i == prices.size() - 1){
                if(minIdx != -1){
                    totalProfit += (prices[i] - prices[minIdx]);
                }
            }
        }
    }
    return totalProfit;
}

int main() {
    // your code goes here
    int n;
    cin >> n;
    vector < int > prices(n);
    for (int i = 0; i < n; i++) {
        cin >> prices[i];
    }
    cout << getMaxProfitInfiniteTransaction(prices) << '\n';
}"
