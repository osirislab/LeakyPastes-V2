id,title,username,language,date,content
L3Mab1Gt,music,BETAlwrd,JavaScript,Tuesday 17th of June 2025 01:06:37 AM CDT,"function startBot(token) {
  const client = new Client({
    intents: [
      GatewayIntentBits.Guilds,
      GatewayIntentBits.GuildMessages,
      GatewayIntentBits.GuildVoiceStates,
      GatewayIntentBits.MessageContent
    ],
    partials: [Partials.Channel]
  });

  client.botData = { token };
  bots.push(client);

  client.distube = new DisTube(client, {
    emitNewSongOnly: true,
    plugins: [

      new YtDlpPlugin({ update: true })
    ]
  });

  client.once(Events.ClientReady, async () => {
    const setup = getSetupData(client.user.username);
    if (!setup?.roomId) return;

    for (const [, guild] of client.guilds.cache) {
      const channel = guild.channels.cache.get(setup.roomId);
      if (channel) await joinVoiceChannel(client, channel);
    }
    console.log(`âœ… Bot started: ${client.user.tag}`);
  });

  client.on(Events.VoiceStateUpdate, async (oldState, newState) => {
    const setup = getSetupData(client.user.username);
    if (!setup?.roomId) return;

    const botId = client.user.id;
    const leftVC = oldState.channelId && !newState.channelId && oldState.id === botId;
    if (leftVC) {
      const key = `${botId}-${oldState.guild.id}`;
      if (rejoinLocks.has(key)) return;
      rejoinLocks.add(key);
      setTimeout(() => rejoinLocks.delete(key), 150);

      const channel = oldState.guild.channels.cache.get(setup.roomId);
      if (channel?.joinable) {
        try {
          await joinVoiceChannel(client, channel);
          console.log(`ğŸ” ${client.user.username} rejoined`);
        } catch (e) {
          console.error(e);
        }
      }
    }
  });
    client.login(token).catch(err => {
    console.error(`âŒ Failed to login with token: ${token.slice(0, 10)}...`, err.message);
  });
}

function loadTokens() {
  if (!fs.existsSync(token_file_)) return [];
  try {
    const data = fs.readFileSync(token_file_, 'utf-8');
    return JSON.parse(data);
  } catch (err) {
    console.error(""Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© tokens.json:"", err);
    return [];
  }
}

function saveTokens(tokens) {
  try {
    fs.writeFileSync(token_file_, JSON.stringify(tokens, null, 2));
  } catch (err) {
    console.error(""Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­ÙØ¸ tokens.json:"", err);
  }
}
function saveSetupData(botName, channelId, newName) {
  const data = fs.existsSync(setupDataPath) ? JSON.parse(fs.readFileSync(setupDataPath)) : {};
  data[botName] = { roomId: channelId, name: newName };
  fs.writeFileSync(setupDataPath, JSON.stringify(data, null, 2));
}

function getSetupData(botName) {
  if (!fs.existsSync(setupDataPath)) return null;
  const data = JSON.parse(fs.readFileSync(setupDataPath));
  return data[botName];
}

async function searchYouTube(query) {
  if (cache.has(query)) return cache.get(query);
  try {
    const { data } = await axios.get(""https://www.googleapis.com/youtube/v3/search"", {
      params: {
        part: ""snippet"",
        type: ""video"",
        q: query,
        key: yt_api,
        maxResults: 1
      }
    });
    const video = data.items?.[0];
    const url = video ? `https://www.youtube.com/watch?v=${video.id.videoId}` : null;
    if (url) cache.set(query, url);
    return url;
  } catch (err) {
    console.error(""YouTube Search API Error:"", err.response?.data || err);
    return null;
  }
}

async function joinVoiceChannel(client, channel) {
  if (!channel?.joinable) return;
  if (client.distube.voices.get(channel.guild.id)) return;

  try {
    await client.distube.voices.join(channel);
    console.log(`âœ… ${client.user.username} joined ${channel.id}`);
  } catch (err) {
    console.warn(`âŒ ${client.user.username} failed to join ${channel.id}:`, err.message);
  }
}

config.bots.forEach((botData, index) => {
  setTimeout(() => {
    const client = new Client({
      intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.MessageContent
      ],
      partials: [Partials.Channel]
    });

    client.botData = botData;

    client.distube = new DisTube(client, {
      emitNewSongOnly: true,
      plugins: [

        new YtDlpPlugin({ update: true })
      ]
    });

    client.once(Events.ClientReady, async () => {
      const setup = getSetupData(client.user.username);
      if (!setup?.roomId) return;

      for (const [, guild] of client.guilds.cache) {
        const channel = guild.channels.cache.get(setup.roomId);
        if (channel) await joinVoiceChannel(client, channel);
      }
    });

    client.on(Events.VoiceStateUpdate, async (oldState, newState) => {
      const setup = getSetupData(client.user.username);
      if (!setup?.roomId) return;

      const botId = client.user.id;
      const leftVC = oldState.channelId && !newState.channelId && oldState.id === botId;
      if (leftVC) {
        const key = `${botId}-${oldState.guild.id}`;
        if (rejoinLocks.has(key)) return;
        rejoinLocks.add(key);
        setTimeout(() => rejoinLocks.delete(key), 150);

        const channel = oldState.guild.channels.cache.get(setup.roomId);
        if (channel?.joinable) {
          try {
            await joinVoiceChannel(client, channel);
            console.log(`ğŸ” ${client.user.username} rejoined`);
          } catch (e) {
            console.error(e);
          }
        }
      }
    });


    client.distube.on(""playSong"", async (queue, song) => {
      const embed = new EmbedBuilder()
        .setTitle(""Now playing"")
        .setDescription(`**[${song.name}](${song.url})**`)
        .setThumbnail(song.thumbnail)
        .addFields(
          { name: ""Author"", value: song.uploader?.name || ""Unknown"", inline: true },
          { name: ""Duration"", value: song.formattedDuration || ""--:--"", inline: true }
        )
        .setColor(""Red"");
      const controls = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId(""loop"").setStyle(ButtonStyle.Secondary).setEmoji(""<:loop_arqet:1382208868352004218>""),
        new ButtonBuilder().setCustomId(""music_down"").setStyle(ButtonStyle.Secondary).setEmoji(""<:down_arqet:1382208866246332526>""),
        new ButtonBuilder().setCustomId(""stop"").setStyle(ButtonStyle.Secondary).setEmoji(""<:stop_arqet:1382208861162831994>""),
        new ButtonBuilder().setCustomId(""music_up"").setStyle(ButtonStyle.Secondary).setEmoji(""<:up_arqet:1382208863893327942>""),
        new ButtonBuilder().setCustomId(""skip"").setStyle(ButtonStyle.Secondary).setEmoji(""<:skip_arqet:1382213952196575282>""));
      const msg = await queue.textChannel.send({ content:""**â†¯ Playing**: \`""+song.name+""\` - (\`""+song.formattedDuration+""\`)"", components: [controls] });
    });
  
    client.on(Events.InteractionCreate, async (interaction) => {
      if (!interaction.isButton()) return;
      const queue = client.distube.getQueue(interaction);
      const memberVC = interaction.member.voice?.channelId;
      const botVC = interaction.guild.members.me.voice?.channelId;
  
      if (!queue || memberVC !== botVC) {
        return interaction.reply({ content: ""ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† ÙÙŠ Ù†ÙØ³ Ø±ÙˆÙ… Ø§Ù„Ø¨ÙˆØª Ù„Ù„ØªØ­ÙƒÙ…."", ephemeral: true });
      }
  
      try {
        switch (interaction.customId) {
              case ""play"":if (!args[0]) return message.reply(""â— You need to provide a song name or URL."");
              distube.play(voiceChannel, args.join("" ""), { textChannel: message.channel, member: message.member });break;
              case ""pause"":if (!queue.paused) queue.pause();break;
              case ""resume"":if (queue.paused) queue.resume();break;
              case ""skip"":if (queue.songs.length > 1) queue.skip();break;
              case ""stop"":queue.stop(); break;
              case ""loop"":queue.setRepeatMode(queue.repeatMode === 0 ? 1 : 0);break;
              case ""loopqueue"":queue.setRepeatMode(queue.repeatMode === 2 ? 0 : 2);break;
              //case ""volume"":const vol = parseInt(args[0]);if (isNaN(vol) || vol < 0 || vol > 150) return message.reply(""ğŸ“¢ Volume must be between 0 and 150."");queue.setVolume(vol);break;
              case ""music_down"": {if (!queue) return interaction.reply({ content: ""âŒ No music playing."", ephemeral: true });
              const vol = Math.max(0, queue.volume - 20);queue.setVolume(vol);await interaction.reply({ content: `ğŸ”‰ Volume decreased to **${vol}%**`, ephemeral: true });break;}
              case ""music_up"": {if (!queue) return interaction.reply({ content: ""âŒ No music playing."", ephemeral: true });
              const vol = Math.min(100, queue.volume + 20);queue.setVolume(vol);await interaction.reply({ content: `ğŸ”Š Volume increased to **${vol}%**`, ephemeral: true });break;}
              case ""seek"":const time = parseInt(args[0]);if (isNaN(time)) return message.reply(""â© Provide time in seconds to seek."");queue.seek(time);break;
              case ""shuffle"":queue.shuffle();break;
              case ""autoplay"":queue.toggleAutoplay();break;
              case ""nowplaying"":const song = queue.songs[0];message.reply(`ğŸ¶ Now Playing: **${song.name}** - \`${song.formattedDuration}\``);break;
              case ""queue"":if (!queue || !queue.songs.length) return message.reply(""ğŸ“­ The queue is empty."");const q = queue.songs
              .map((song, i) => `${i === 0 ? ""**â–¶ï¸"" : `${i + 1}.`} ${song.name}** - \`${song.formattedDuration}\``).join(""\n"");message.reply(`ğŸ§ **Queue List:**\n${q}`);break;
              case ""remove"":const index = parseInt(args[0]);if (isNaN(index) || index < 1 || index >= queue.songs.length)return message.reply(""âŒ Invalid song number."");
              const removed = queue.songs.splice(index, 1);message.reply(`ğŸ—‘ï¸ Removed: **${removed[0].name}**`);break;default:message.reply(""Unknown"");break;
        }
        await interaction.deferUpdate();
      } catch (e) {
        console.error(""Interaction error:"", e);
        interaction.reply({ content: ""Ø­Ø¯Ø« Ø®Ø·Ø£."", ephemeral: true });
      }
    });

const client_1 = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
  ],
});

const owners = new Set();
owners.add([""159824469899214848""]);
client_1.on(Events.MessageCreate, async (message) => {
  if (!message.guild || message.author.bot) return;

  const args = message.content.trim().split(/ +/);
  const commandText = args[0]?.toLowerCase();
  if ([""restart"", ""add"", ""addown""].includes(commandText)) {
    if (!owners.has(message.author.id)) {
      return message.react(""âŒ"");
    }
  }


  if (commandText === ""add"") {
      if (args.length < 2) return message.react(""âŒ"");
    
      let config = {};
      let tokens = [];
    
      try {
        const data = fs.readFileSync('./config.json', 'utf8');
        config = JSON.parse(data);
        tokens = Array.isArray(config.tokens) ? config.tokens : [];
      } catch (error) {
        console.log(""Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© config.json:"", error);
      }
    
      const newTokens = args.slice(1);
      const existingTokens = tokens.map(t => t.token);
      const duplicateTokens = newTokens.filter(t => existingTokens.includes(t));
    
      if (duplicateTokens.length > 0) {
        return message.reply(`**âŒ Ø¨Ø¹Ø¶ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„**\n\`${duplicateTokens.join('\n')}\``)
          .then(msg => setTimeout(() => { msg.delete(); message.delete(); }, 5000));
      }
    
      newTokens.forEach(t => tokens.push({ token: t }));
      config.tokens = tokens;
    
      try {
        fs.writeFileSync('./config.json', JSON.stringify(config, null, 2));
        message.reply(`âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª:\n\`${newTokens.join('\n')}\``)
          .then(msg => setTimeout(() => { msg.delete(); message.delete(); }, 5000));
      } catch (e) {
        console.error(""Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª:"", e);
        message.react(""âŒ"");
      }
    
      return;
    }
    

  if (commandText === ""addown"") {
    const userId = args[1]?.replace(/<@!?(\d+)>/, ""$1"");
    if (!userId) return message.reply(""âŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ù…Ù†Ø´Ù†Ù‡."");
    if (userId === ""159824469899214848"") return message.react(""âŒ"");
    if (owners.has(userId)) return message.react(""âŒ"");

    owners.add(userId);
    message.react(""âœ…"");
    return;
  }
});
    client_1.login(config.main_bot);

    client.on(Events.MessageCreate, async (message) => {
      if (!message.guild || message.author.bot) return;
      const args = message.content.trim().split(/ +/);
      const commandText = args[0]?.toLowerCase();
      const query = args.slice(1).join("" "");
      const vc = message.member.voice.channel;
      const setup = getSetupData(client.user.username);
      const allowedRoom = setup?.roomId;
      const queue = client.distube.getQueue(message);

    if (message.mentions.has(client.user)) {
      const cmd = args[1]?.toLowerCase();
      const imgURL = message.attachments.first()?.url || args[2];

      if (cmd === ""setup"") {
        if (!vc) return message.react(""âŒ"");
        try {
          await client.user.setUsername(vc.name);
          saveSetupData(client.user.username, vc.id, vc.name);
          await client.distube.voices.join(vc);
          await message.react(""âœ…"");
          setTimeout(() => {
            client.user.setUsername(client.botData.name).catch(() => {});
          }, 86400000);
        } catch (e) {
          console.error(""Setup error:"", e);
          message.react(""âŒ"");
        }
      }

      if (cmd === ""sa"" && imgURL) {
        try {
          await client.user.setAvatar(imgURL);
          message.react(""âœ…"");
        } catch (e) {
          console.error(""Avatar error:"", e);
          message.react(""âŒ"");
        }
      }

      if (cmd === ""sb"" && imgURL) {
        try {
          await client.user.setBanner(imgURL);
          message.react(""âœ…"");
        } catch (e) {
          console.error(""Banner error:"", e);
          message.react(""âŒ"");
        }
      }
      if (cmd === ""sn"" && args.length) {
        try {
          await client.user.setUsername(args.join("" ""));
          message.react(""âœ…"");
        } catch (e) {
          console.error(""Username error:"", e);
          message.react(""âŒ"");
        }
      }
    }  
      if (!vc || vc.id !== allowedRoom) return;
  
      if ([""Ø´"", ""Ø´ØºÙ„""].includes(commandText) && query) {
        let url = query;
        try {
          await client.distube.play(vc, query, { textChannel: message.channel, member: message.member });
        } catch (err) {
          console.warn(""DisTube play failed, trying YouTube API fallback"");
          url = await searchYouTube(query);
          if (!url) return message.react(""âŒ"");
          try {
            await client.distube.play(vc, url, { textChannel: message.channel, member: message.member });
          } catch (e) {
            console.error(""Play error after fallback:"", e);
            message.react(""âŒ"");
          }
        }
      }
  
      if ([""ÙˆÙ‚Ù"", ""Ø§ÙŠÙ‚Ø§Ù""].includes(commandText)) {
        if (queue) queue.stop(), message.react(""<:stop_arqet:1382208861162831994>"");
        else message.react(""âŒ"");
      }
  
      if ([""Ø³ÙƒØ¨"", ""ØªØ®Ø·ÙŠ""].includes(commandText)) {
        if (queue?.songs.length > 1) queue.skip(), message.react(""<:skip_arqet:1382213952196575282>"");
        else message.react(""âŒ"");
      }
  
      if ([""Ù‚Ø§Ø¦Ù…Ø©"", ""list"", ""queue""].includes(commandText)) {
      if (!queue?.songs.length) return message.react(""âŒ"");const list = queue.songs.map((s, i) => `${i === 0 ? ""ğŸ”Š"" : `${i + 1}.`} ${s.name} - \`${s.formattedDuration}\``).join(""\n"");message.reply(`ğŸ¶ **Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ´ØºÙŠÙ„:**\n${list}`);}
      if ([""ÙˆÙ‚Ù‘Ù"", ""Ø¨ÙˆØ²"", ""ØªÙˆÙ‚ÙŠÙ"", ""Ø§ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª"", ""pause""].includes(commandText)) {if (queue && !queue.paused) queue.pause(), message.react(""<:stop_arqet:1382208861162831994>"");else message.react(""âŒ"");}
      if ([""ÙƒÙ…Ù„"", ""Ø§Ø³ØªØ¦Ù†Ø§Ù"", ""resume""].includes(commandText)) {if (queue?.paused) queue.resume(), message.react(""<:start_arqet:1382208858692255854>"");else message.react(""âŒ"");}
      if ([""ØµÙˆØª"", ""vol"", ""volume""].includes(commandText)) {
        const vol = parseInt(args[1]);
        if (isNaN(vol) || vol < 0 || vol > 100) return message.reply(""âŒ Ø§ÙƒØªØ¨ Ø±Ù‚Ù… Ø¨ÙŠÙ† 0 Ùˆ 100"");
        queue.setVolume(vol);
        return message.reply(`ğŸ”Š ØªÙ… Ø¶Ø¨Ø· Ø§Ù„ØµÙˆØª Ø¹Ù„Ù‰ ${vol}%`);
      }
      
      if ([""ØªÙƒØ±Ø§Ø±"", ""loop""].includes(commandText)) {
      if (queue) {const mode = queue.repeatMode === 0 ? 1 : queue.repeatMode === 1 ? 2 : 0;queue.setRepeatMode(mode); message.react([""<:loop_arqet:1382208868352004218>"", ""<:loop_arqet:1382208868352004218>"", ""<:loop_arqet:1382208868352004218>""][mode]);} else message.react(""âŒ"");
      }
      
      if ([""Ø¹Ø´ÙˆØ§Ø¦ÙŠ"", ""shuffle""].includes(commandText)) {
        if (queue) queue.shuffle(), message.react(""ğŸ”€"");
        else message.react(""âŒ"");
      }
      
      if ([""Ø§Ø²Ø§Ù„Ø©"", ""remove""].includes(commandText)) {
        const index = parseInt(args[1]);
        if (!queue || isNaN(index) || index <= 0 || index >= queue.songs.length) {
          return message.reply(""âŒ Ø±Ù‚Ù… ØºÙŠØ± ØµØ­ÙŠØ­ Ø£Ùˆ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ø§Ø¦Ù…Ø©"");
        }
        queue.songs.splice(index, 1);
        message.reply(`ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø±Ù‚Ù… ${index}`);
      }
      
      if ([""Ø§Ù„Ø§Ù†"", ""now"", ""np"", ""nowplaying""].includes(commandText)) {
        if (!queue?.songs.length) return message.react(""âŒ"");
        const song = queue.songs[0];
        const nowPlaying = `ğŸµ **Ø§Ù„Ø¢Ù†:** [${song.name}](${song.url}) - \`${song.formattedDuration}\``;
        message.reply(nowPlaying);
      }
      
      if ([""Ø§ÙˆØ§Ù…Ø±"", ""help"", ""commands""].includes(commandText)) {
        const helpText = `**Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ÙŠÙˆØ²Ùƒ:**\n` +
          `â€¢ ØªØ´ØºÙŠÙ„: Ø´, Ø´ØºÙ„ <ÙƒÙ„Ù…Ø© Ø£Ùˆ Ø±Ø§Ø¨Ø·>\n` +
          `â€¢ Ø¥ÙŠÙ‚Ø§Ù: ÙˆÙ‚Ù, Ø§ÙŠÙ‚Ø§Ù\n` +
          `â€¢ ØªØ®Ø·ÙŠ: Ø³ÙƒØ¨, ØªØ®Ø·ÙŠ\n` +
          `â€¢ Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª: ÙˆÙ‚Ù‘Ù, Ø¨ÙˆØ²\n` +
          `â€¢ Ø§Ø³ØªØ¦Ù†Ø§Ù: ÙƒÙ…Ù„\n` +
          `â€¢ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ´ØºÙŠÙ„: Ù‚Ø§Ø¦Ù…Ø©, list\n` +
          `â€¢ ØªÙƒØ±Ø§Ø±: ØªÙƒØ±Ø§Ø±\n` +
          `â€¢ Ø§Ù„ØµÙˆØª: ØµÙˆØª <0-100>\n` +
          `â€¢ Ø¹Ø´ÙˆØ§Ø¦ÙŠ: Ø¹Ø´ÙˆØ§Ø¦ÙŠ\n` +
          `â€¢ Ø§Ù„Ø¢Ù†: Ø§Ù„Ø§Ù†, now\n` +
          `â€¢ Ø§Ø²Ø§Ù„Ø©: Ø§Ø²Ø§Ù„Ø© <Ø±Ù‚Ù…>`;
        message.reply(helpText);
      }
      
    });

    
    client.on(""error"", error => {
      if (error.message?.includes(""Cannot connect to the voice channel after 30 seconds"")) return;
      const name = client?.user?.username || ""Unknown"";
      console.error(`[${name}] Uncaught Error:`, error);
    });
    const name_1 = client?.user?.username || ""Unknown"";
    process.on(""unhandledRejection"", () => console.error());
    process.on(""uncaughtException"", (err) => console.error(`[${name_1}] Uncaught Exception:`, err));
    process.on(""uncaughtExceptionMonitor"", (err) => console.warn(`[${name_1}] Exception Monitor:`, err));

    client.login(botData.token);
    bots.push(client);
  }, index * 50);
});
const admin = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

admin.on(Events.MessageCreate, async (message) => {
  if (!message.guild || message.author.bot) return;
  const args = message.content.trim().split(/ +/);
  const command = args[0]?.toLowerCase();

  if (!owners.has(message.author.id)) return;

  if (command === ""addtoken"") {
    const newToken = args[1];
    if (!newToken) return message.reply(""ex: addtoken [token_bot]"");
    const tokens = loadTokens();
    if (tokens.includes(newToken)) return message.react(""âŒ"");
    tokens.push(newToken);
    saveTokens(tokens);
    startBot(newToken);
    message.react(""âœ…"");
  }

  const failedTokens =[];
  if (command === ""info-tokens"") {
      const descriptionLines = [];

      bots.forEach(bot => {
        const nameTag = bot.user?.tag || ""Unknown#0000"";
        const _1 = bot.user?.id || ""1"";
        const tokenPreview = bot.token?.slice(0, 10) || ""??????????"";
        descriptionLines.push(
          `[${nameTag}](https://discord.com/oauth2/authorize?client_id=${_1}&permissions=0&integration_type=0&scope=bot) [token: ${tokenPreview}...]`
        );
      });
      
      if (failedTokens.length > 0) {
        failedTokens.forEach(t => {
          descriptionLines.push(`[FAILED] [token: ${t.slice(0, 10)}...] âŒ`);
        });
      }
      
      
      const MAX_LENGTH = 4000;
      const embeds = [];
      let lines = [];
      let length = 0;
      
      for (const line of descriptionLines) {
        const lineLength = line.length + 1;
        if (length + lineLength > MAX_LENGTH) {
          embeds.push(
            new EmbedBuilder()
              .setTitle(""Ø­Ø§Ù„Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª"")
              .setDescription(lines.join(""\n""))
              .setColor(""Blue"")
          );
          lines = [];
          length = 0;
        }
      
        lines.push(line);
        length += lineLength;
      }
      
      if (lines.length > 0) {
        embeds.push(
          new EmbedBuilder()
            .setTitle(""Ø­Ø§Ù„Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª"")
            .setDescription(lines.join(""\n""))
            .setColor(""Blue"")
        );
      }
      
      
      for (const embed of embeds) {
        await message.channel.send({ embeds: [embed] });
      }
 }

    
    
});"
dgsCE6gr,admin music,BETAlwrd,JavaScript,Tuesday 17th of June 2025 01:03:33 AM CDT,"const admin = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

admin.on(Events.MessageCreate, async (message) => {
  if (!message.guild || message.author.bot) return;
  const args = message.content.trim().split(/ +/);
  const command = args[0]?.toLowerCase();

  if (!owners.has(message.author.id)) return;

  if (command === ""addtoken"") {
    const newToken = args[1];
    if (!newToken) return message.reply(""ex: addtoken [token_bot]"");
    const tokens = loadTokens();
    if (tokens.includes(newToken)) return message.react(""âŒ"");
    tokens.push(newToken);
    saveTokens(tokens);
    startBot(newToken);
    message.react(""âœ…"");
  }

  const failedTokens =[];
  if (command === ""info-tokens"") {
      const descriptionLines = [];

      bots.forEach(bot => {
        const nameTag = bot.user?.tag || ""Unknown#0000"";
        const _1 = bot.user?.id || ""1"";
        const tokenPreview = bot.token?.slice(0, 10) || ""??????????"";
        descriptionLines.push(
          `[${nameTag}](https://discord.com/oauth2/authorize?client_id=${_1}&permissions=0&integration_type=0&scope=bot) [token: ${tokenPreview}...]`
        );
      });
      
      if (failedTokens.length > 0) {
        failedTokens.forEach(t => {
          descriptionLines.push(`[FAILED] [token: ${t.slice(0, 10)}...] âŒ`);
        });
      }
      
      
      const MAX_LENGTH = 4000;
      const embeds = [];
      let lines = [];
      let length = 0;
      
      for (const line of descriptionLines) {
        const lineLength = line.length + 1;
        if (length + lineLength > MAX_LENGTH) {
          embeds.push(
            new EmbedBuilder()
              .setTitle(""Ø­Ø§Ù„Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª"")
              .setDescription(lines.join(""\n""))
              .setColor(""Blue"")
          );
          lines = [];
          length = 0;
        }
      
        lines.push(line);
        length += lineLength;
      }
      
      if (lines.length > 0) {
        embeds.push(
          new EmbedBuilder()
            .setTitle(""Ø­Ø§Ù„Ø© Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª"")
            .setDescription(lines.join(""\n""))
            .setColor(""Blue"")
        );
      }
      
      
      for (const embed of embeds) {
        await message.channel.send({ embeds: [embed] });
      }
 }

    
    
});

admin.login(config.main_bot);"
3vsBnqVc,Untitled,kuznetsov420,JSON,Tuesday 17th of June 2025 12:50:35 AM CDT,"{
  ""rdapConformance"": [
    ""rdap_level_0"",
    ""icann_rdap_response_profile_0"",
    ""icann_rdap_technical_implementation_guide_0""
  ],
  ""objectClassName"": ""domain"",
  ""entities"": [
    {
      ""objectClassName"": ""entity"",
      ""entities"": [
        {
          ""objectClassName"": ""entity"",
          ""roles"": [
            ""abuse""
          ],
          ""status"": [
            ""active""
          ],
          ""vcardArray"": [
            ""vcard"",
            [
              [
                ""version"",
                {},
                ""text"",
                ""4.0""
              ],
              [
                ""fn"",
                {},
                ""text"",
                ""Abuse Team""
              ],
              [
                ""tel"",
                {
                  ""type"": [
                    ""voice""
                  ]
                },
                ""uri"",
                ""tel:+1.4153197517""
              ],
              [
                ""email"",
                {},
                ""text"",
                ""registrar-abuse@cloudflare.com""
              ]
            ]
          ]
        }
      ],
      ""handle"": ""1910"",
      ""links"": [
        {
          ""href"": ""https://pubapi.registry.google/rdap/entity/1910"",
          ""rel"": ""self"",
          ""type"": ""application/rdap+json""
        }
      ],
      ""publicIds"": [
        {
          ""identifier"": ""1910"",
          ""type"": ""IANA Registrar ID""
        }
      ],
      ""remarks"": [
        {
          ""description"": [
            ""Summary data only. For complete data, send a specific query for the object.""
          ],
          ""title"": ""Incomplete Data"",
          ""type"": ""object truncated due to unexplainable reasons""
        }
      ],
      ""roles"": [
        ""registrar""
      ],
      ""vcardArray"": [
        ""vcard"",
        [
          [
            ""version"",
            {},
            ""text"",
            ""4.0""
          ],
          [
            ""fn"",
            {},
            ""text"",
            ""CloudFlare, Inc.""
          ]
        ]
      ]
    },
    {
      ""objectClassName"": ""entity"",
      ""handle"": """",
      ""remarks"": [
        {
          ""description"": [
            ""Some of the data in this object has been removed."",
            ""Contact personal data is visible only to the owning registrar.""
          ],
          ""links"": [
            {
              ""href"": ""https://github.com/google/nomulus/blob/master/docs/rdap.md#authentication"",
              ""rel"": ""alternate"",
              ""type"": ""text/html""
            }
          ],
          ""title"": ""REDACTED FOR PRIVACY"",
          ""type"": ""object redacted due to authorization""
        },
        {
          ""description"": [
            ""Please query the RDDS service of the Registrar of Record identifies in this output for information on how to contact the Registrant of the queried domain name.""
          ],
          ""title"": ""EMAIL REDACTED FOR PRIVACY"",
          ""type"": ""object redacted due to authorization""
        }
      ],
      ""roles"": [
        ""administrative""
      ],
      ""vcardArray"": [
        ""vcard"",
        [
          [
            ""version"",
            {},
            ""text"",
            ""4.0""
          ],
          [
            ""fn"",
            {},
            ""text"",
            """"
          ]
        ]
      ]
    },
    {
      ""objectClassName"": ""entity"",
      ""handle"": """",
      ""remarks"": [
        {
          ""description"": [
            ""Some of the data in this object has been removed."",
            ""Contact personal data is visible only to the owning registrar.""
          ],
          ""links"": [
            {
              ""href"": ""https://github.com/google/nomulus/blob/master/docs/rdap.md#authentication"",
              ""rel"": ""alternate"",
              ""type"": ""text/html""
            }
          ],
          ""title"": ""REDACTED FOR PRIVACY"",
          ""type"": ""object redacted due to authorization""
        },
        {
          ""description"": [
            ""Please query the RDDS service of the Registrar of Record identifies in this output for information on how to contact the Registrant of the queried domain name.""
          ],
          ""title"": ""EMAIL REDACTED FOR PRIVACY"",
          ""type"": ""object redacted due to authorization""
        }
      ],
      ""roles"": [
        ""billing""
      ],
      ""vcardArray"": [
        ""vcard"",
        [
          [
            ""version"",
            {},
            ""text"",
            ""4.0""
          ],
          [
            ""fn"",
            {},
            ""text"",
            """"
          ]
        ]
      ]
    },
    {
      ""objectClassName"": ""entity"",
      ""handle"": """",
      ""remarks"": [
        {
          ""description"": [
            ""Some of the data in this object has been removed."",
            ""Contact personal data is visible only to the owning registrar.""
          ],
          ""links"": [
            {
              ""href"": ""https://github.com/google/nomulus/blob/master/docs/rdap.md#authentication"",
              ""rel"": ""alternate"",
              ""type"": ""text/html""
            }
          ],
          ""title"": ""REDACTED FOR PRIVACY"",
          ""type"": ""object redacted due to authorization""
        },
        {
          ""description"": [
            ""Please query the RDDS service of the Registrar of Record identifies in this output for information on how to contact the Registrant of the queried domain name.""
          ],
          ""title"": ""EMAIL REDACTED FOR PRIVACY"",
          ""type"": ""object redacted due to authorization""
        }
      ],
      ""roles"": [
        ""technical""
      ],
      ""vcardArray"": [
        ""vcard"",
        [
          [
            ""version"",
            {},
            ""text"",
            ""4.0""
          ],
          [
            ""fn"",
            {},
            ""text"",
            """"
          ]
        ]
      ]
    },
    {
      ""objectClassName"": ""entity"",
      ""handle"": """",
      ""remarks"": [
        {
          ""description"": [
            ""Some of the data in this object has been removed."",
            ""Contact personal data is visible only to the owning registrar.""
          ],
          ""links"": [
            {
              ""href"": ""https://github.com/google/nomulus/blob/master/docs/rdap.md#authentication"",
              ""rel"": ""alternate"",
              ""type"": ""text/html""
            }
          ],
          ""title"": ""REDACTED FOR PRIVACY"",
          ""type"": ""object redacted due to authorization""
        },
        {
          ""description"": [
            ""Please query the RDDS service of the Registrar of Record identifies in this output for information on how to contact the Registrant of the queried domain name.""
          ],
          ""title"": ""EMAIL REDACTED FOR PRIVACY"",
          ""type"": ""object redacted due to authorization""
        }
      ],
      ""roles"": [
        ""registrant""
      ],
      ""vcardArray"": [
        ""vcard"",
        [
          [
            ""version"",
            {},
            ""text"",
            ""4.0""
          ],
          [
            ""fn"",
            {},
            ""text"",
            """"
          ]
        ]
      ]
    }
  ],
  ""events"": [
    {
      ""eventAction"": ""registration"",
      ""eventActor"": ""cloudflare"",
      ""eventDate"": ""2025-06-17T00:30:49.504Z""
    },
    {
      ""eventAction"": ""expiration"",
      ""eventDate"": ""2026-06-17T00:30:49.504Z""
    },
    {
      ""eventAction"": ""last update of RDAP database"",
      ""eventDate"": ""2025-06-17T05:47:14.459Z""
    },
    {
      ""eventAction"": ""last changed"",
      ""eventDate"": ""2025-06-17T00:35:55.528Z""
    }
  ],
  ""handle"": ""E0F48848A-APP"",
  ""ldhName"": ""stoickr.app"",
  ""links"": [
    {
      ""href"": ""https://pubapi.registry.google/rdap/domain/stoickr.app"",
      ""rel"": ""self"",
      ""type"": ""application/rdap+json""
    },
    {
      ""href"": ""https://rdap.cloudflare.com/rdap/v1/domain/stoickr.app"",
      ""rel"": ""related"",
      ""type"": ""application/rdap+json""
    }
  ],
  ""nameservers"": [
    {
      ""objectClassName"": ""nameserver"",
      ""handle"": ""2EF7ED1_SOY-GOOGLE"",
      ""ldhName"": ""nelly.ns.cloudflare.com"",
      ""links"": [
        {
          ""href"": ""https://pubapi.registry.google/rdap/nameserver/nelly.ns.cloudflare.com"",
          ""rel"": ""self"",
          ""type"": ""application/rdap+json""
        }
      ],
      ""remarks"": [
        {
          ""description"": [
            ""Summary data only. For complete data, send a specific query for the object.""
          ],
          ""title"": ""Incomplete Data"",
          ""type"": ""object truncated due to unexplainable reasons""
        }
      ]
    },
    {
      ""objectClassName"": ""nameserver"",
      ""handle"": ""4CC5522_SOY-GOOGLE"",
      ""ldhName"": ""oswald.ns.cloudflare.com"",
      ""links"": [
        {
          ""href"": ""https://pubapi.registry.google/rdap/nameserver/oswald.ns.cloudflare.com"",
          ""rel"": ""self"",
          ""type"": ""application/rdap+json""
        }
      ],
      ""remarks"": [
        {
          ""description"": [
            ""Summary data only. For complete data, send a specific query for the object.""
          ],
          ""title"": ""Incomplete Data"",
          ""type"": ""object truncated due to unexplainable reasons""
        }
      ]
    }
  ],
  ""secureDNS"": {
    ""delegationSigned"": false,
    ""zoneSigned"": true
  },
  ""status"": [
    ""add period"",
    ""client transfer prohibited""
  ],
  ""notices"": [
    {
      ""description"": [
        ""By querying our Domain Database as part of the RDAP pilot program (RDAP Domain Database), you are agreeing to comply with these terms and acknowledging that your information will be used in accordance with Charleston Road Registry's Privacy Policy (https://www.registry.google/about/privacy.html), so please read the terms and Privacy Policy carefully."",
        ""Any information provided is 'as is' without any guarantee of accuracy."",
        ""Please do not misuse the RDAP Domain Database. It is intended solely for query-based access on an experimental basis and should not be used for or relied upon for any other purpose."",
        ""Don't use the RDAP Domain Database to allow, enable, or otherwise support the transmission of mass unsolicited, commercial advertising or solicitations."",
        ""Don't access our RDAP Domain Database through the use of high volume, automated electronic processes that send queries or data to the systems of Charleston Road Registry or any ICANN-accredited registrar."",
        ""You may only use the information contained in the RDAP Domain Database for lawful purposes."",
        ""Do not compile, repackage, disseminate, or otherwise use the information contained in the RDAP Domain Database in its entirety, or in any substantial portion, without our prior written permission."",
        ""We may retain certain details about queries to our RDAP Domain Database for the purposes of detecting and preventing misuse."",
        ""We reserve the right to restrict or deny your access to the RDAP Domain Database if we suspect that you have failed to comply with these terms."",
        ""We reserve the right to modify or discontinue our participation in the RDAP pilot program and suspend or terminate access to the RDAP Domain Database at any time and for any reason in our sole discretion."",
        ""Reminder that underlying Registrant data may be requested via ICANN's RDRS service (https://rdrs.icann.org/)."",
        ""We reserve the right to modify this agreement at any time."",
        """"
      ],
      ""links"": [
        {
          ""href"": ""https://pubapi.registry.google/rdap/help/tos"",
          ""rel"": ""self"",
          ""type"": ""application/rdap+json""
        },
        {
          ""href"": ""https://www.registry.google/policies/rdap-terms/"",
          ""rel"": ""alternate"",
          ""type"": ""text/html""
        }
      ],
      ""title"": ""RDAP Terms of Service""
    },
    {
      ""description"": [
        ""This response conforms to the RDAP Operational Profile for gTLD Registries and Registrars version 1.0""
      ]
    },
    {
      ""description"": [
        ""For more information on domain status codes, please visit https://icann.org/epp""
      ],
      ""links"": [
        {
          ""href"": ""https://icann.org/epp"",
          ""rel"": ""alternate"",
          ""type"": ""text/html""
        }
      ],
      ""title"": ""Status Codes""
    },
    {
      ""description"": [
        ""URL of the ICANN RDDS Inaccuracy Complaint Form: https://icann.org/wicf""
      ],
      ""links"": [
        {
          ""href"": ""https://icann.org/wicf"",
          ""rel"": ""alternate"",
          ""type"": ""text/html""
        }
      ],
      ""title"": ""RDDS Inaccuracy Complaint Form""
    }
  ]
}"
tKgyhd1B,APK STRATEGI 5,Hackdicecode,C++,Tuesday 17th of June 2025 12:46:23 AM CDT,"basebet = 0.1
minbet = 0.1
basech = 10
recoverCh = 47
target = 1
stopLoss = -10
maxBet = 5
lossCount = 0
lossLimit = 3
inRecovery = false

chance = basech
nextbet = basebet

function dobet()
    if profit >= target or profit <= stopLoss then stop() end

    if win then
        lossCount = 0
        if inRecovery then
            inRecovery = false
            nextbet = basebet
            chance = basech
        end
    else
        lossCount = lossCount + 1
    end

    if lossCount >= lossLimit then
        inRecovery = true
    end

    if inRecovery then
        chance = recoverCh
        nextbet = previousbet * 2
        if nextbet > maxBet then nextbet = maxBet end
    else
        chance = basech
        nextbet = basebet
    end

    bethigh = math.random(2) == 1
end"
RDtpNpfA,Dumps,LVL23HT,CSS,Monday 16th of June 2025 11:35:38 PM CDT,Seess
kH2MHEqh,Harvard - Cardiff University (ITS),swardiantara,XML,Monday 16th of June 2025 10:32:34 PM CDT,"<?xml version=""1.0"" encoding=""utf-8""?>
<style xmlns=""http://purl.org/net/xbiblio/csl"" class=""in-text"" version=""1.0"" demote-non-dropping-particle=""sort-only"">
  <info>
    <title>Cardiff University - Harvard (ITS)</title>
    <id>http://www.zotero.org/styles/cardiff-university-harvard</id>
    <link href=""http://www.zotero.org/styles/cardiff-university-harvard"" rel=""self""/>
    <link href=""https://xerte.cardiff.ac.uk/play_4191"" rel=""documentation""/>
    <link href=""https://xerte.cardiff.ac.uk/play_4069"" rel=""documentation""/>
    <link href=""https://github.com/citation-style-language/styles/pull/3676#issuecomment-420542651"" rel=""documentation""/>
    <author>
      <name>Zoe Young</name>
      <email>youngz@cardiff.ac.uk</email>
    </author>
    <author>
      <name>Lewys Peters</name>
    </author>
    <contributor>
      <name>Patrick O'Brien</name>
    </contributor>
    <category citation-format=""author-date""/>
    <summary>The Harvard author-date style - adapted for Cardiff University</summary>
    <updated>2025-05-18T00:55:38+00:00</updated>
    <rights license=""http://creativecommons.org/licenses/by-sa/3.0/"">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights>
  </info>
  <macro name=""editor"">
    <names variable=""editor"" delimiter="", "">
      <name name-as-sort-order=""all"" and=""text"" sort-separator="", "" initialize-with="". "" delimiter="", ""/>
      <label form=""short"" prefix="" ""/>
    </names>
  </macro>
  <macro name=""author"">
    <names variable=""author"">
      <name name-as-sort-order=""all"" and=""text"" sort-separator="", "" initialize-with=""."" delimiter-precedes-last=""never"" delimiter="", ""/>
      <label form=""short"" prefix="" ""/>
      <substitute>
        <names variable=""editor""/>
        <choose>
          <if type=""article-newspaper article-magazine"" match=""any"">
            <text variable=""container-title""/>
          </if>
          <else>
            <text macro=""title""/>
          </else>
        </choose>
      </substitute>
    </names>
  </macro>
  <macro name=""author-short"">
    <names variable=""author"">
      <name form=""short"" and=""text"" delimiter="", "" et-al-min=""3"" et-al-use-first=""1"" delimiter-precedes-last=""never"" initialize-with="". ""/>
      <et-al font-style=""italic""/>
      <substitute>
        <names variable=""editor""/>
        <names variable=""translator""/>
        <choose>
          <if type=""article-newspaper article-magazine"" match=""any"">
            <text variable=""container-title"" text-case=""title"" font-style=""italic""/>
          </if>
          <else>
            <text macro=""title""/>
          </else>
        </choose>
      </substitute>
    </names>
  </macro>
  <macro name=""access"">
    <choose>
      <if variable=""URL"" match=""all"">
        <group delimiter="" "">
          <group delimiter="": "">
            <text term=""available at"" text-case=""capitalize-first""/>
            <text variable=""URL""/>
          </group>
          <group prefix=""["" suffix=""]"" delimiter="": "">
            <text term=""accessed"" text-case=""capitalize-first""/>
            <date variable=""accessed"">
              <date-part name=""day"" suffix="" ""/>
              <date-part name=""month"" suffix="" ""/>
              <date-part name=""year""/>
            </date>
          </group>
        </group>
      </if>
      <else-if match=""all"" variable=""DOI"">
        <text variable=""DOI"" prefix=""doi: ""/>
      </else-if>
    </choose>
  </macro>
  <macro name=""title"">
    <choose>
      <if type=""bill book graphic legal_case legislation motion_picture report song thesis patent post post-weblog webpage"" match=""any"">
        <text variable=""title"" font-style=""italic""/>
      </if>
      <else>
        <text variable=""title"" suffix="".""/>
      </else>
    </choose>
  </macro>
  <macro name=""publisher"">
    <group delimiter="": "" suffix="""">
      <text variable=""publisher-place""/>
      <text variable=""publisher""/>
    </group>
  </macro>
  <macro name=""year-date"">
    <choose>
      <if variable=""issued"">
        <date variable=""issued"">
          <date-part name=""year""/>
        </date>
        <text variable=""year-suffix""/>
      </if>
      <else>
        <text term=""no date"" prefix=""["" suffix=""]""/>
        <text variable=""year-suffix"" prefix=""["" suffix=""]""/>
      </else>
    </choose>
  </macro>
  <macro name=""published-date"">
    <choose>
      <if type=""article-newspaper article-magazine speech"" match=""any"">
        <date variable=""issued"">
          <date-part name=""day"" prefix="" "" suffix="" ""/>
          <date-part name=""month"" form=""long""/>
        </date>
      </if>
    </choose>
  </macro>
  <macro name=""edition"">
    <choose>
      <if is-numeric=""edition"">
        <group delimiter="" "">
          <number variable=""edition"" form=""ordinal""/>
          <text term=""edition"" form=""short""/>
        </group>
      </if>
      <else>
        <text variable=""edition"" suffix="".""/>
      </else>
    </choose>
  </macro>
  <macro name=""pages"">
    <group>
      <label variable=""page"" form=""short"" suffix="" ""/>
      <text variable=""page""/>
    </group>
    <choose>
      <if type=""article article-journal article-magazine article-newspaper book review review-book report"" match=""any""/>
    </choose>
  </macro>
  <macro name=""bill-detail"">
    <choose>
      <if type=""bill legislation"" match=""any"">
        <group>
          <text variable=""section""/>
          <text variable=""volume""/>
        </group>
      </if>
    </choose>
  </macro>
  <macro name=""patent"">
    <text variable=""number"" suffix="" [Patent].""/>
  </macro>
  <citation et-al-min=""3"" et-al-use-first=""1"" et-al-subsequent-min=""3"" et-al-subsequent-use-first=""1"" disambiguate-add-year-suffix=""true"">
    <sort>
      <key macro=""year-date""/>
      <key variable=""author""/>
    </sort>
    <layout prefix=""("" suffix="")"" delimiter=""; "">
      <group delimiter="", "">
        <group delimiter="", "">
          <text macro=""author-short""/>
          <text macro=""year-date""/>
        </group>
        <group>
          <label variable=""locator"" form=""short""/>
          <text variable=""locator""/>
        </group>
      </group>
    </layout>
  </citation>
  <bibliography et-al-min=""50"" et-al-use-first=""1"" hanging-indent=""false"">
    <sort>
      <key macro=""author""/>
      <key macro=""year-date""/>
      <key variable=""title""/>
    </sort>
    <layout>
      <group delimiter="". "">
        <text macro=""author""/>
        <text macro=""year-date""/>
        <choose>
          <if type=""bill book graphic legal_case legislation motion_picture report song entry-encyclopedia entry-dictionary"" match=""any"">
            <group delimiter="". "" suffix=""."">
              <text macro=""title""/>
              <text macro=""edition""/>
              <text macro=""editor""/>
              <text macro=""publisher""/>
              <text macro=""bill-detail""/>
              <text macro=""pages""/>
            </group>
          </if>
          <else-if type=""chapter paper-conference"" match=""any"">
            <group delimiter="". "" suffix=""."">
              <text macro=""title""/>
              <group prefix="" "" delimiter="" "">
                <text term=""in"" text-case=""capitalize-first"" suffix="":""/>
                <text macro=""editor""/>
                <text variable=""container-title"" font-style=""italic"" suffix="".""/>
                <text variable=""collection-title"" suffix="".""/>
              </group>
              <group prefix="" "" delimiter="" "">
                <text macro=""edition""/>
                <group suffix="""" delimiter="", "">
                  <date form=""text"" variable=""event-date""/>
                  <text macro=""publisher""/>
                  <text macro=""pages""/>
                </group>
              </group>
            </group>
          </else-if>
          <else-if type=""thesis"">
            <group delimiter="". "" suffix=""."">
              <text macro=""title""/>
              <text macro=""edition""/>
              <group prefix="" "" delimiter="", "">
                <text variable=""genre""/>
                <text macro=""publisher""/>
              </group>
            </group>
          </else-if>
          <else-if type=""webpage post post-weblog"" match=""any"">
            <group delimiter="". "" suffix=""."">
              <text macro=""title""/>
            </group>
          </else-if>
          <else-if type=""patent"" match=""any"">
            <group delimiter="" "" suffix=""."">
              <text macro=""title""/>
              <text macro=""patent""/>
            </group>
          </else-if>
          <else>
            <group delimiter="". "" suffix=""."">
              <group>
                <text macro=""title""/>
                <text macro=""editor"" prefix="" ""/>
              </group>
              <group delimiter="", "">
                <group delimiter="" "">
                  <text variable=""container-title"" font-style=""italic""/>
                  <group>
                    <text variable=""volume""/>
                    <text variable=""issue"" prefix=""("" suffix="")""/>
                  </group>
                </group>
                <text macro=""pages""/>
              </group>
            </group>
          </else>
        </choose>
      </group>
      <group suffix=""."">
        <text macro=""published-date""/>
        <text prefix="". "" macro=""access"" suffix="".""/>
      </group>
    </layout>
  </bibliography>
</style>
"
TbYazYQ9,TABLA DEPARTAMENTO [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:21:21 PM CDT,"-- TABLA DEPARTAMENTO
CREATE PROCEDURE inserta_departamento
    @codi_depa int,
    @nombre nvarchar(30)
AS
BEGIN
    INSERT INTO DEPARTAMENTO (codi_depa, nombre)
    VALUES (@codi_depa, @nombre)
END
-- *******************************************************
CREATE PROCEDURE actualiza_departamento
    @codi_depa int,
    @nombre nvarchar(30)
AS
BEGIN
    UPDATE DEPARTAMENTO
    SET nombre = @nombre
    WHERE codi_depa = @codi_depa
END
-- *******************************************************
CREATE PROCEDURE elimina_departamento
    @codi_depa int
AS
BEGIN
    DELETE FROM DEPARTAMENTO
    WHERE codi_depa = @codi_depa
END
-- *******************************************************
CREATE PROCEDURE consulta_departamento
    @codi_depa int,
    @nombre nvarchar(30) OUTPUT
AS
BEGIN
    SELECT @nombre = nombre
    FROM DEPARTAMENTO
    WHERE codi_depa = @codi_depa
END"
BSqeGPHC,TABLA CARGO INTERNACIONAL [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:20:05 PM CDT,"-- TABLA CARGO INTERNACIONAL
CREATE PROCEDURE inserta_cargo_internacional
    @codi_carg int,
    @descripcion nvarchar(40)
AS
BEGIN
    INSERT INTO CARGO_INTERNACIONAL (codi_carg, descripcion)
    VALUES (@codi_carg, @descripcion)
END
-- *******************************************************
CREATE PROCEDURE actualiza_cargo_internacional
    @codi_carg int,
    @descripcion nvarchar(40)
AS
BEGIN
    UPDATE CARGO_INTERNACIONAL
    SET descripcion = @descripcion
    WHERE codi_carg = @codi_carg
END
-- *******************************************************
CREATE PROCEDURE elimina_cargo_internacional
    @codi_carg int
AS
BEGIN
    DELETE FROM CARGO_INTERNACIONAL
    WHERE codi_carg = @codi_carg
END
-- *******************************************************
CREATE PROCEDURE consulta_cargo_internacional
    @codi_carg int,
    @descripcion nvarchar(40) OUTPUT
AS
BEGIN
    SELECT @descripcion = descripcion
    FROM CARGO_INTERNACIONAL
    WHERE codi_carg = @codi_carg
END"
UKENUriX,TABLA ORDEN [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:18:36 PM CDT,"-- TABLA ORDEN
CREATE PROCEDURE inserta_orden
    @codi_orde int,
    @codi_clie int,
    @codi_empl int,
    @fecha_orde datetime,
    @fecha_envi datetime,
    @fecha_desp datetime,
    @direccion nvarchar(60),
    @ciudad nvarchar(15),
    @region nvarchar(15),
    @cod_postal nvarchar(10),
    @pais nvarchar(15)
AS
BEGIN
    INSERT INTO ORDEN (codi_orde, codi_clie, codi_empl, fecha_orde, fecha_envi, fecha_desp,
                       direccion, ciudad, region, cod_postal, pais)
    VALUES (@codi_orde, @codi_clie, @codi_empl, @fecha_orde, @fecha_envi, @fecha_desp,
            @direccion, @ciudad, @region, @cod_postal, @pais)
END
-- *******************************************************
CREATE PROCEDURE actualiza_orden
    @codi_orde int,
    @codi_clie int,
    @codi_empl int,
    @fecha_orde datetime,
    @fecha_envi datetime,
    @fecha_desp datetime,
    @direccion nvarchar(60),
    @ciudad nvarchar(15),
    @region nvarchar(15),
    @cod_postal nvarchar(10),
    @pais nvarchar(15)
AS
BEGIN
    UPDATE ORDEN
    SET 
        codi_clie = @codi_clie,
        codi_empl = @codi_empl,
        fecha_orde = @fecha_orde,
        fecha_envi = @fecha_envi,
        fecha_desp = @fecha_desp,
        direccion = @direccion,
        ciudad = @ciudad,
        region = @region,
        cod_postal = @cod_postal,
        pais = @pais
    WHERE codi_orde = @codi_orde
END
-- *******************************************************
CREATE PROCEDURE elimina_orden
    @codi_orde int
AS
BEGIN
    DELETE FROM ORDEN
    WHERE codi_orde = @codi_orde
END
-- *******************************************************
CREATE PROCEDURE consulta_orden
    @codi_orde int,
    @codi_clie int OUTPUT,
    @codi_empl int OUTPUT,
    @fecha_orde datetime OUTPUT,
    @fecha_envi datetime OUTPUT,
    @fecha_desp datetime OUTPUT,
    @direccion nvarchar(60) OUTPUT,
    @ciudad nvarchar(15) OUTPUT,
    @region nvarchar(15) OUTPUT,
    @cod_postal nvarchar(10) OUTPUT,
    @pais nvarchar(15) OUTPUT
AS
BEGIN
    SELECT 
        @codi_clie = codi_clie,
        @codi_empl = codi_empl,
        @fecha_orde = fecha_orde,
        @fecha_envi = fecha_envi,
        @fecha_desp = fecha_desp,
        @direccion = direccion,
        @ciudad = ciudad,
        @region = region,
        @cod_postal = cod_postal,
        @pais = pais
    FROM ORDEN
    WHERE codi_orde = @codi_orde
END"
T8a3xJuN,TABLA DETALLE ORDEN [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:17:06 PM CDT,"-- TABLA DETALLE ORDEN
CREATE PROCEDURE inserta_detalle_orden
    @codi_orde int,
    @codi_prod int,
    @preciouni money,
    @cantidad smallint,
    @descue real
AS
BEGIN
    INSERT INTO DETALLE_ORDEN (codi_orde, codi_prod, preciouni, cantidad, descue)
    VALUES (@codi_orde, @codi_prod, @preciouni, @cantidad, @descue)
END
-- *******************************************************
CREATE PROCEDURE actualiza_detalle_orden
    @codi_orde int,
    @codi_prod int,
    @preciouni money,
    @cantidad smallint,
    @descue real
AS
BEGIN
    UPDATE DETALLE_ORDEN
    SET 
        preciouni = @preciouni,
        cantidad = @cantidad,
        descue = @descue
    WHERE codi_orde = @codi_orde AND codi_prod = @codi_prod
END
-- *******************************************************
CREATE PROCEDURE elimina_detalle_orden
    @codi_orde int,
    @codi_prod int
AS
BEGIN
    DELETE FROM DETALLE_ORDEN
    WHERE codi_orde = @codi_orde AND codi_prod = @codi_prod
END
-- *******************************************************
CREATE PROCEDURE consulta_detalle_orden
    @codi_orde int,
    @codi_prod int,
    @preciouni money OUTPUT,
    @cantidad smallint OUTPUT,
    @descue real OUTPUT
AS
BEGIN
    SELECT 
        @preciouni = preciouni,
        @cantidad = cantidad,
        @descue = descue
    FROM DETALLE_ORDEN
    WHERE codi_orde = @codi_orde AND codi_prod = @codi_prod
END"
C4ni1QcS,TABLA CATEGORIA [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:15:36 PM CDT,"-- TABLA CATEGORIA
CREATE PROCEDURE inserta_categoria
    @codi_cate int,
    @nombre nvarchar(15),
    @descripcion nvarchar(20)
AS
BEGIN
    INSERT INTO CATEGORIA (codi_cate, nombre, descripcion)
    VALUES (@codi_cate, @nombre, @descripcion)
END
-- *******************************************************
CREATE PROCEDURE actualiza_categoria
    @codi_cate int,
    @nombre nvarchar(15),
    @descripcion nvarchar(20)
AS
BEGIN
    UPDATE CATEGORIA
    SET 
        nombre = @nombre,
        descripcion = @descripcion
    WHERE codi_cate = @codi_cate
END
-- *******************************************************
CREATE PROCEDURE elimina_categoria
    @codi_cate int
AS
BEGIN
    DELETE FROM CATEGORIA
    WHERE codi_cate = @codi_cate
END
-- *******************************************************
CREATE PROCEDURE consulta_categoria
    @codi_cate int,
    @nombre nvarchar(15) OUTPUT,
    @descripcion nvarchar(20) OUTPUT
AS
BEGIN
    SELECT 
        @nombre = nombre,
        @descripcion = descripcion
    FROM CATEGORIA
    WHERE codi_cate = @codi_cate
END"
h8uddTw8,TABLA PRODUCTO [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:11:12 PM CDT,"-- TABLA PRODUCTO
CREATE PROCEDURE inserta_producto
    @codi_prod int,
    @nombre nvarchar(40),
    @codi_prov int,
    @codi_cate int,
    @cant_unid nvarchar(20),
    @prec_unit money,
    @existencia char(10),
    @unid_orde char(10),
    @descontinuado bit
AS
BEGIN
    INSERT INTO PRODUCTO (codi_prod, nombre, codi_prov, codi_cate, cant_unid, prec_unit, existencia, unid_orde, descontinuado)
    VALUES (@codi_prod, @nombre, @codi_prov, @codi_cate, @cant_unid, @prec_unit, @existencia, @unid_orde, @descontinuado)
END
-- *******************************************************
CREATE PROCEDURE actualiza_producto
    @codi_prod int,
    @nombre nvarchar(40),
    @codi_prov int,
    @codi_cate int,
    @cant_unid nvarchar(20),
    @prec_unit money,
    @existencia char(10),
    @unid_orde char(10),
    @descontinuado bit
AS
BEGIN
    UPDATE PRODUCTO
    SET 
        nombre = @nombre,
        codi_prov = @codi_prov,
        codi_cate = @codi_cate,
        cant_unid = @cant_unid,
        prec_unit = @prec_unit,
        existencia = @existencia,
        unid_orde = @unid_orde,
        descontinuado = @descontinuado
    WHERE codi_prod = @codi_prod
END
-- *******************************************************
CREATE PROCEDURE elimina_producto
    @codi_prod int
AS
BEGIN
    DELETE FROM PRODUCTO
    WHERE codi_prod = @codi_prod
END
-- *******************************************************
CREATE PROCEDURE consulta_producto
    @codi_prod int,
    @nombre nvarchar(40) OUTPUT,
    @codi_prov int OUTPUT,
    @codi_cate int OUTPUT,
    @cant_unid nvarchar(20) OUTPUT,
    @prec_unit money OUTPUT,
    @existencia char(10) OUTPUT,
    @unid_orde char(10) OUTPUT,
    @descontinuado bit OUTPUT
AS
BEGIN
    SELECT 
        @nombre = nombre,
        @codi_prov = codi_prov,
        @codi_cate = codi_cate,
        @cant_unid = cant_unid,
        @prec_unit = prec_unit,
        @existencia = existencia,
        @unid_orde = unid_orde,
        @descontinuado = descontinuado
    FROM PRODUCTO
    WHERE codi_prod = @codi_prod
END"
3svRsUBU,TABLA EMPLEADO [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:09:33 PM CDT,"-- TABLA EMPLEADO
CREATE PROCEDURE inserta_empleado
    @codi_empl int,
    @nombre nvarchar(30),
    @apellido nvarchar(30),
    @cargo_trabajo nvarchar(30),
    @titulo nvarchar(30),
    @fecha_nacimiento datetime,
    @fecha_ingreso datetime,
    @direccion nvarchar(60),
    @ciudad nvarchar(15),
    @region nvarchar(15),
    @codigo_postal nvarchar(10),
    @pais nvarchar(15),
    @telefono nvarchar(20),
    @foto image,
    @reporta_a int,
    @codi_depa int
AS
BEGIN
    INSERT INTO EMPLEADO (codi_empl, nombre, apellido, cargo_trabajo, titulo, fecha_nacimiento, fecha_ingreso,
                          direccion, ciudad, region, codigo_postal, pais, telefono, foto, reporta_a, codi_depa)
    VALUES (@codi_empl, @nombre, @apellido, @cargo_trabajo, @titulo, @fecha_nacimiento, @fecha_ingreso,
            @direccion, @ciudad, @region, @codigo_postal, @pais, @telefono, @foto, @reporta_a, @codi_depa)
END
-- *******************************************************
CREATE PROCEDURE actualiza_empleado
    @codi_empl int,
    @nombre nvarchar(30),
    @apellido nvarchar(30),
    @cargo_trabajo nvarchar(30),
    @titulo nvarchar(30),
    @fecha_nacimiento datetime,
    @fecha_ingreso datetime,
    @direccion nvarchar(60),
    @ciudad nvarchar(15),
    @region nvarchar(15),
    @codigo_postal nvarchar(10),
    @pais nvarchar(15),
    @telefono nvarchar(20),
    @foto image,
    @reporta_a int,
    @codi_depa int
AS
BEGIN
    UPDATE EMPLEADO
    SET 
        nombre = @nombre,
        apellido = @apellido,
        cargo_trabajo = @cargo_trabajo,
        titulo = @titulo,
        fecha_nacimiento = @fecha_nacimiento,
        fecha_ingreso = @fecha_ingreso,
        direccion = @direccion,
        ciudad = @ciudad,
        region = @region,
        codigo_postal = @codigo_postal,
        pais = @pais,
        telefono = @telefono,
        foto = @foto,
        reporta_a = @reporta_a,
        codi_depa = @codi_depa
    WHERE codi_empl = @codi_empl
END
-- *******************************************************
CREATE PROCEDURE elimina_empleado
    @codi_empl int
AS
BEGIN
    DELETE FROM EMPLEADO
    WHERE codi_empl = @codi_empl
END
-- *******************************************************
CREATE PROCEDURE consulta_empleado
    @codi_empl int,
    @nombre nvarchar(30) OUTPUT,
    @apellido nvarchar(30) OUTPUT,
    @cargo_trabajo nvarchar(30) OUTPUT,
    @titulo nvarchar(30) OUTPUT,
    @fecha_nacimiento datetime OUTPUT,
    @fecha_ingreso datetime OUTPUT,
    @direccion nvarchar(60) OUTPUT,
    @ciudad nvarchar(15) OUTPUT,
    @region nvarchar(15) OUTPUT,
    @codigo_postal nvarchar(10) OUTPUT,
    @pais nvarchar(15) OUTPUT,
    @telefono nvarchar(20) OUTPUT,
    @foto image OUTPUT,
    @reporta_a int OUTPUT,
    @codi_depa int OUTPUT
AS
BEGIN
    SELECT 
        @nombre = nombre,
        @apellido = apellido,
        @cargo_trabajo = cargo_trabajo,
        @titulo = titulo,
        @fecha_nacimiento = fecha_nacimiento,
        @fecha_ingreso = fecha_ingreso,
        @direccion = direccion,
        @ciudad = ciudad,
        @region = region,
        @codigo_postal = codigo_postal,
        @pais = pais,
        @telefono = telefono,
        @foto = foto,
        @reporta_a = reporta_a,
        @codi_depa = codi_depa
    FROM EMPLEADO
    WHERE codi_empl = @codi_empl
END"
jTe4CGiu,TABLA CLIENTE [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:06:03 PM CDT,"-- TABLA CLIENTE
CREATE PROCEDURE inserta_cliente
    @codi_clie nchar(5),
    @nomb_empr nvarchar(30),
    @contacto nvarchar(30),
    @cargo_contacto nvarchar(30),
    @direccion nvarchar(60),
    @ciudad nvarchar(15),
    @codigo_postal nvarchar(10),
    @pais nvarchar(15),
    @telefono nvarchar(12),
    @fax nvarchar(12)
AS
BEGIN
    INSERT INTO CLIENTE(codi_clie, nomb_empr, contacto, cargo_contacto, direccion, ciudad, codigo_postal, pais, telefono, fax)
    VALUES(@codi_clie, @nomb_empr, @contacto, @cargo_contacto, @direccion, @ciudad, @codigo_postal, @pais, @telefono, @fax)
END
-- *******************************************************
CREATE PROCEDURE actualiza_cliente
    @codi_clie nchar(5),
    @nomb_empr nvarchar(30),
    @contacto nvarchar(30),
    @cargo_contacto nvarchar(30),
    @direccion nvarchar(60),
    @ciudad nvarchar(15),
    @codigo_postal nvarchar(10),
    @pais nvarchar(15),
    @telefono nvarchar(12),
    @fax nvarchar(12)
AS
BEGIN
    UPDATE CLIENTE
    SET 
        nomb_empr = @nomb_empr,
        contacto = @contacto,
        cargo_contacto = @cargo_contacto,
        direccion = @direccion,
        ciudad = @ciudad,
        codigo_postal = @codigo_postal,
        pais = @pais,
        telefono = @telefono,
        fax = @fax
    WHERE codi_clie = @codi_clie
END
-- *******************************************************
CREATE PROCEDURE elimina_cliente
    @codi_clie nchar(5)
AS
BEGIN
    DELETE FROM CLIENTE
    WHERE codi_clie = @codi_clie
END
-- *******************************************************
CREATE PROCEDURE consulta_cliente
    @codi_clie nchar(5),
    @nomb_empr nvarchar(30) OUTPUT,
    @contacto nvarchar(30) OUTPUT,
    @cargo_contacto nvarchar(30) OUTPUT,
    @direccion nvarchar(60) OUTPUT,
    @ciudad nvarchar(15) OUTPUT,
    @codigo_postal nvarchar(10) OUTPUT,
    @pais nvarchar(15) OUTPUT,
    @telefono nvarchar(12) OUTPUT,
    @fax nvarchar(12) OUTPUT
AS
BEGIN
    SELECT 
        @nomb_empr = nomb_empr,
        @contacto = contacto,
        @cargo_contacto = cargo_contacto,
        @direccion = direccion,
        @ciudad = ciudad,
        @codigo_postal = codigo_postal,
        @pais = pais,
        @telefono = telefono,
        @fax = fax
    FROM CLIENTE
    WHERE codi_clie = @codi_clie
END"
4FuT3AAe,TABLA PROVEEDOR [SSMS],Diego1764,MySQL,Monday 16th of June 2025 10:02:51 PM CDT,"-- TABLA PROVEEDOR
CREATE PROCEDURE inserta_proveedor
    -- @codi_prov int,
    @nomb_empr nvarchar(40),
    @nomb_conta nvarchar(30),
    @carg_conta nvarchar(30),
    @direccion nvarchar(40),
    @cuidad nvarchar (15),
    @pais nvarchar (15),
    @telefono nvarchar (12),
    @fax nvarchar(12)
AS
BEGIN
    DECLARE @ln_codi_prov int;

    SELECT @ln_codi_prov = ISNULL(MAX(codi_prov), 0) + 1 
    FROM PROVEEDOR;

    INSERT INTO PROVEEDOR([codi_prov], [nomb_empr], [nomb_conta], [carg_conta], [direccion], [ciudad], [pais], [telefono], [fax])
    VALUES(@ln_codi_prov, @nomb_empr, @nomb_conta, @carg_conta, @direccion, @cuidad, @pais, @telefono, @fax)
END
-- *******************************************************
CREATE PROCEDURE elimina_proveedor
    @codi_prov int
AS
BEGIN
    DELETE 
    FROM PROVEEDOR
    WHERE codi_prov = @codi_prov
END
-- *******************************************************
CREATE PROCEDURE consulta_proveedor
    @codi_prov INT,
    @nomb_empr nvarchar(40) OUTPUT,
    @nomb_conta nvarchar(30) OUTPUT,
    @carg_conta nvarchar(30) OUTPUT,
    @direccion nvarchar(40) OUTPUT,
    @cuidad nvarchar(15) OUTPUT,
    @pais nvarchar(15) OUTPUT,
    @telefono nvarchar(12) OUTPUT,
    @fax nvarchar(12) OUTPUT
AS
BEGIN
    SELECT 
        @nomb_empr = nomb_empr,
        @nomb_conta = nomb_conta,
        @carg_conta = carg_conta,
        @direccion = direccion,
        @cuidad = ciudad,
        @pais = pais,
        @telefono = telefono,
        @fax = fax
    FROM PROVEEDOR
    WHERE codi_prov = @codi_prov
END
-- *******************************************************
CREATE PROCEDURE actualiza_proveedor
    @codi_prov int,
    @nomb_empr nvarchar(40),
    @nomb_conta nvarchar(30),
    @carg_conta nvarchar(30),
    @direccion nvarchar(40),
    @cuidad nvarchar(15),
    @pais nvarchar(15),
    @telefono nvarchar(12),
    @fax nvarchar(12)
AS
BEGIN
    UPDATE PROVEEDOR
    SET 
        nomb_empr = @nomb_empr,
        nomb_conta = @nomb_conta,
        carg_conta = @carg_conta,
        direccion = @direccion,
        ciudad = @cuidad,
        pais = @pais,
        telefono = @telefono,
        fax = @fax
    WHERE codi_prov = @codi_prov
END"
QrvfsXea,Untitled,pwtenny,Java,Monday 16th of June 2025 07:47:55 PM CDT,"import javax.swing.*;
import java.awt.*;
import java.time.ZonedDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import javax.swing.border.EmptyBorder;

public class TimeDisplayApp extends JFrame {

    private JLabel telAvivTimeLabel;
    private JLabel tehranTimeLabel;

    public TimeDisplayApp() {
        // Set the native Windows look and feel
        try {
            UIManager.setLookAndFeel(""com.sun.java.swing.plaf.windows.WindowsLookAndFeel"");
        }
        catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException e) {
            e.printStackTrace();
            // Fallback to default if Windows look and feel is not available
        }

        setTitle(""World Clocks"");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(300, 150);
        setLocationRelativeTo(null); // Center the window

        // Create a panel with a GridLayout for the labels
        JPanel panel = new JPanel(new GridLayout(2, 1));
        panel.setBorder(new EmptyBorder(10, 10, 10, 10)); // Add some padding

        telAvivTimeLabel = new JLabel();
        tehranTimeLabel = new JLabel();

        // Set font for better readability
        Font font = new Font(""SansSerif"", Font.BOLD, 24);
        telAvivTimeLabel.setFont(font);
        tehranTimeLabel.setFont(font);

        // Center the text in the labels
        telAvivTimeLabel.setHorizontalAlignment(SwingConstants.CENTER);
        tehranTimeLabel.setHorizontalAlignment(SwingConstants.CENTER);

        panel.add(telAvivTimeLabel);
        panel.add(tehranTimeLabel);

        add(panel);

        // Timer to update the time every second
        Timer timer = new Timer(1000, e -> updateTimes());
        timer.start();

        // Initial update
        updateTimes();
    }

    private void updateTimes() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(""hh:mm:ss a"");

        // Tel Aviv time
        ZoneId telAvivZone = ZoneId.of(""Asia/Jerusalem"");
        ZonedDateTime telAvivDateTime = ZonedDateTime.now(telAvivZone);
        telAvivTimeLabel.setText(""Tel Aviv: "" + telAvivDateTime.format(formatter));

        // Tehran time
        ZoneId tehranZone = ZoneId.of(""Asia/Tehran"");
        ZonedDateTime tehranDateTime = ZonedDateTime.now(tehranZone);
        tehranTimeLabel.setText(""Tehran: "" + tehranDateTime.format(formatter));
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            new TimeDisplayApp().setVisible(true);
        });
    }
}"
MaWSLKaz,Untitled,pwtenny,C++,Monday 16th of June 2025 07:47:25 PM CDT,"#include <windows.h> // Required for Windows API
#include <string>      // For std::string
#include <chrono>      // For time operations
#include <thread>      // For std::this_thread::sleep_for
#include <ctime>       // For time_t, tm, gmtime
#include <iomanip>     // For std::put_time

// Global handles for the time labels
HWND hTelAvivTimeLabel;
HWND hTehranTimeLabel;

// Window procedure function (callback for window messages)
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_CREATE:
        {
            // Create static text controls (labels)
            hTelAvivTimeLabel = CreateWindowEx(
                0, ""STATIC"", ""Tel Aviv: Loading..."",
                WS_CHILD | WS_VISIBLE | SS_CENTER,
                10, 10, 260, 30, // x, y, width, height
                hwnd, (HMENU)1001, GetModuleHandle(NULL), NULL);

            hTehranTimeLabel = CreateWindowEx(
                0, ""STATIC"", ""Tehran: Loading..."",
                WS_CHILD | WS_VISIBLE | SS_CENTER,
                10, 50, 260, 30, // x, y, width, height
                hwnd, (HMENU)1002, GetModuleHandle(NULL), NULL);

            // Set font for better readability
            HFONT hFont = CreateFont(
                24, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
                DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, ""SansSerif"");

            SendMessage(hTelAvivTimeLabel, WM_SETFONT, (WPARAM)hFont, TRUE);
            SendMessage(hTehranTimeLabel, WM_SETFONT, (WPARAM)hFont, TRUE);

            break;
        }
        case WM_TIMER:
        {
            if (wParam == 1) // Our timer ID
            {
                // Update times
                SYSTEMTIME stLocal;
                GetLocalTime(&stLocal); // Get local time

                // Tel Aviv (GMT+3 or GMT+2 depending on DST, assuming GMT+3 for simplicity,
                // you'd need a more robust time zone library for exact DST handling)
                // For simplicity, we'll assume a fixed offset.
                // A robust solution would use a library like Howard Hinnant's date library or ICU.
                // For this example, we'll calculate approximate offsets.

                // Get current UTC time
                SYSTEMTIME stUTC;
                GetSystemTime(&stUTC);

                // Convert SYSTEMTIME to file time for easier arithmetic
                FILETIME ftUTC, ftTelAviv, ftTehran;
                SystemTimeToFileTime(&stUTC, &ftUTC);

                // Define time zone offsets in 100-nanosecond intervals (1 hour = 3600 * 10^7 = 36,000,000,000)
                // Tel Aviv: UTC+3 (during summer), UTC+2 (during winter) - Let's use a fixed +3 for this example.
                // Tehran: UTC+3:30

                // For simplicity and without a complex timezone library, we'll rely on
                // getting UTC time and applying a fixed offset.
                // The correct way would involve Windows API functions like TzSpecificLocalTimeToSystemTime
                // or a comprehensive timezone library.

                // Using standard C++ time functions for simplicity, which requires knowing the current offset from UTC.
                // A better solution for real-world applications would be to use a robust date/time library
                // that handles time zones and DST correctly (e.g., ICU, or Howard Hinnant's date library).

                // Let's approximate by getting current local time and adjusting.
                // This is a simplification and not perfectly accurate for all timezone/DST scenarios.

                // For a truly accurate solution for time zones in C++, you would need
                // to use a dedicated library like Howard Hinnant's ""date"" library or ICU.
                // The Windows API itself has functions for time zone conversion, but they are
                // more involved than a simple offset.

                // For this example, we'll demonstrate using `_tzset` and `_ftime_s` for basic timezone awareness,
                // but this is highly platform-specific (Microsoft Visual C++ runtime).
                // A portable C++ solution would use `std::chrono` and a timezone library.

                // Let's use `std::chrono` for basic time, but truly complex timezones are hard without a library.
                auto now = std::chrono::system_clock::now();

                // Tel Aviv: Approx UTC+3:00 (Israel Standard Time / Israel Daylight Time)
                // Tehran: Approx UTC+3:30 (Iran Standard Time / Iran Daylight Time)

                // The following time zone calculations are *approximations* and
                // do not account for Daylight Saving Time rules for each specific region.
                // For accurate real-world applications, use a robust time zone library.

                // Convert to time_t for easier manipulation (seconds since epoch)
                time_t currentTime_t = std::chrono::system_clock::to_time_t(now);

                // Tel Aviv Time (approx. UTC+3, assuming it's summer for simplicity)
                // This is a direct offset. For proper DST, you'd need a robust library.
                time_t telAvivTime_t = currentTime_t + (3 * 3600); // +3 hours
                struct tm telAvivTm;
                gmtime_s(&telAvivTm, &telAvivTime_t); // Use gmtime_s for thread safety

                char telAvivBuffer[64];
                strftime(telAvivBuffer, sizeof(telAvivBuffer), ""Tel Aviv: %I:%M:%S %p"", &telAvivTm);
                SetWindowText(hTelAvivTimeLabel, telAvivBuffer);

                // Tehran Time (approx. UTC+3:30)
                time_t tehranTime_t = currentTime_t + (3 * 3600) + (30 * 60); // +3 hours 30 minutes
                struct tm tehranTm;
                gmtime_s(&tehranTm, &tehranTime_t); // Use gmtime_s for thread safety

                char tehranBuffer[64];
                strftime(tehranBuffer, sizeof(tehranBuffer), ""Tehran: %I:%M:%S %p"", &tehranTm);
                SetWindowText(hTehranTimeLabel, tehranBuffer);
            }
            break;
        }
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;

        case WM_DESTROY:
            KillTimer(hwnd, 1); // Stop the timer
            PostQuitMessage(0);
            break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

// Entry point for the Windows application
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    // Register the window class
    WNDCLASSEX wc = {0};
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); // Standard window background
    wc.lpszClassName = ""TimeDisplayAppClass"";
    RegisterClassEx(&wc);

    // Create the window
    HWND hwnd = CreateWindowEx(
        0, ""TimeDisplayAppClass"", ""World Clocks (C++)"",
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        CW_USEDEFAULT, CW_USEDEFAULT, 300, 150, // x, y, width, height
        NULL, NULL, hInstance, NULL);

    if (hwnd == NULL)
    {
        return 0;
    }

    // Set a timer to update the time every second
    SetTimer(hwnd, 1, 1000, NULL); // Timer ID 1, interval 1000ms

    // Initial update
    SendMessage(hwnd, WM_TIMER, 1, 0);

    // Message loop
    MSG msg = {0};
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}"
zKNLyvG7,2025-06-15_stats.json,rdp_snitch,JSON,Monday 16th of June 2025 07:18:14 PM CDT,"{
  ""ip"": {
    ""24.173.30.170"": 18870,
    ""167.172.131.118"": 12975,
    ""80.66.79.30"": 14457,
    ""139.59.97.137"": 2733,
    ""64.64.112.155"": 9966,
    ""209.97.152.8"": 618,
    ""178.128.21.189"": 4272,
    ""45.79.168.199"": 12,
    ""45.79.73.71"": 3,
    ""157.230.86.112"": 3,
    ""5.135.169.222"": 3,
    ""190.85.239.111"": 3,
    ""96.51.53.164"": 6,
    ""147.185.132.21"": 9,
    ""103.15.222.151"": 6,
    ""2.57.121.247"": 6,
    ""165.227.207.152"": 3,
    ""194.165.16.161"": 6,
    ""87.106.235.201"": 3,
    ""141.98.80.148"": 9,
    ""92.63.197.23"": 18,
    ""198.235.24.177"": 9,
    ""91.238.181.94"": 6,
    ""197.145.218.12"": 30,
    ""185.196.220.41"": 18,
    ""181.30.39.44"": 6,
    ""205.210.31.111"": 9,
    ""143.110.220.53"": 3,
    ""197.210.194.240"": 3,
    ""31.222.238.98"": 9,
    ""185.156.73.154"": 6,
    ""147.185.132.60"": 9,
    ""64.64.112.133"": 588
  },
  ""asn"": {
    ""AS11427"": 18870,
    ""AS14061"": 20607,
    ""AS60602"": 14457,
    ""AS137409"": 10554,
    ""AS63949"": 15,
    ""AS16276"": 3,
    ""AS14080"": 3,
    ""AS6327"": 6,
    ""AS396982"": 36,
    ""AS149137"": 6,
    ""AS47890"": 6,
    ""AS48721"": 6,
    ""AS8560"": 3,
    ""AS43350"": 9,
    ""AS210848"": 24,
    ""AS49434"": 6,
    ""AS36884"": 30,
    ""AS213438"": 18,
    ""AS7303"": 6,
    ""AS29465"": 3,
    ""AS44477"": 9
  },
  ""isp"": {
    ""Charter Communications Inc"": 18870,
    ""DigitalOcean, LLC"": 17874,
    ""HYPER-HOSTING"": 14457,
    ""DIGITALOCEAN"": 2733,
    ""GSL Networks Pty LTD"": 10554,
    ""Akamai Technologies, Inc."": 15,
    ""OVH SAS"": 3,
    ""Telmex Colombia S.A."": 3,
    ""Shaw Communications Inc."": 6,
    ""Google LLC"": 36,
    ""TAN Thanh AN International Trade Development Company Limited"": 6,
    ""Unmanaged LTD"": 6,
    ""Flyservers S.A."": 6,
    ""IONOS SE ber.de"": 3,
    ""NForce Entertainment B.V."": 9,
    ""Telkom Internet LTD"": 18,
    ""Datacenter location PAR1 France"": 6,
    ""Wana Corporate"": 30,
    ""ColocaTel Inc."": 18,
    ""Telecom Argentina S.A"": 6,
    ""MTN NIGERIA Communication limited"": 3,
    ""PQ HOSTING PLUS S.R.L."": 9,
    ""OOO SibirInvest"": 6
  },
  ""org"": {
    ""Spectrum"": 18870,
    ""DigitalOcean, LLC"": 16335,
    ""Unknown"": 14487,
    ""LogicWeb Inc"": 10554,
    ""Digitalocean"": 4272,
    ""Linode"": 15,
    ""OVH BV"": 3,
    ""Telmex Colombia S.A"": 3,
    ""Shaw Communications Inc"": 6,
    ""Palo Alto Networks, Inc"": 36,
    ""TANTHANHAN"": 6,
    ""Unmanaged LTD"": 6,
    ""Flyservers S.A"": 6,
    ""IONOS SE"": 3,
    ""Cloud CDN"": 9,
    ""Korotkij Denis Aleksandrovich"": 18,
    ""ThinkTech Technology Industrial CO. Limited"": 6,
    ""Colocatel Inc"": 18,
    ""Fibertel"": 6,
    ""MTN Nigeria"": 3,
    ""PQ HOSTING PLUS S.R.L"": 9,
    ""IP Kiktev Nikolay Vladimirovich"": 6
  },
  ""regionName"": {
    ""Texas"": 18870,
    ""New Jersey"": 13611,
    ""Chi\u0219in\u0103u Municipality"": 14457,
    ""South West"": 7005,
    ""Dhaka Division"": 10554,
    ""California"": 39,
    ""South Holland"": 3,
    ""Bogota D.C."": 3,
    ""Alberta"": 6,
    ""Hanoi"": 6,
    ""England"": 6,
    ""Kaunas"": 6,
    ""State of Berlin"": 3,
    ""North Holland"": 33,
    ""\u00cele-de-France"": 6,
    ""Guelmim-Oued Noun"": 30,
    ""Virginia"": 18,
    ""Buenos Aires"": 6,
    ""Ontario"": 3,
    ""Lagos"": 3,
    ""Drenthe"": 9
  },
  ""country"": {
    ""United States"": 32538,
    ""Moldova"": 14457,
    ""Singapore"": 7005,
    ""Bangladesh"": 10554,
    ""The Netherlands"": 45,
    ""Colombia"": 3,
    ""Canada"": 9,
    ""Vietnam"": 6,
    ""United Kingdom"": 6,
    ""Lithuania"": 6,
    ""Germany"": 3,
    ""France"": 6,
    ""Morocco"": 30,
    ""Argentina"": 6,
    ""Nigeria"": 3
  },
  ""account"": {
    ""hello"": 64548,
    ""ujwbhviu"": 12,
    ""beio"": 6,
    ""Unknown"": 3,
    ""EzNwRAaHD"": 3,
    ""ibMIVa"": 3,
    ""mAAbpJ"": 3,
    ""Administr"": 39,
    ""Test"": 15,
    ""gOPqHSWcK"": 3,
    ""aItDSj"": 3,
    ""MiyxaI"": 3,
    ""Domain"": 18,
    ""KuEsjCcLW"": 3,
    ""nfpQPF"": 3,
    ""QvyPYh"": 3,
    ""rnpUqqiPB"": 3,
    ""bomLZY"": 3,
    ""uEstPc"": 3
  },
  ""keyboard"": {
    ""Unknown"": 64677
  },
  ""client_build"": {
    ""Unknown"": 64677
  },
  ""client_name"": {
    ""Unknown"": 64677
  },
  ""ip_type"": {
    ""Unknown"": 18954,
    ""hosting"": 35124,
    ""proxy"": 10554,
    ""hosting & proxy"": 12,
    ""mobile"": 30,
    ""mobile & hosting"": 3
  }
}"
sgBktnev,2025-06-15_stats.json,rdp_snitch,JSON,Monday 16th of June 2025 07:16:09 PM CDT,"{
  ""ip"": {
    ""24.173.30.170"": 18868,
    ""167.172.131.118"": 12975,
    ""80.66.79.30"": 14457,
    ""139.59.97.137"": 2733,
    ""64.64.112.155"": 9966,
    ""209.97.152.8"": 618,
    ""178.128.21.189"": 4272,
    ""45.79.168.199"": 12,
    ""45.79.73.71"": 3,
    ""157.230.86.112"": 3,
    ""5.135.169.222"": 3,
    ""190.85.239.111"": 3,
    ""96.51.53.164"": 6,
    ""147.185.132.21"": 9,
    ""103.15.222.151"": 6,
    ""2.57.121.247"": 6,
    ""165.227.207.152"": 3,
    ""194.165.16.161"": 6,
    ""87.106.235.201"": 3,
    ""141.98.80.148"": 9,
    ""92.63.197.23"": 18,
    ""198.235.24.177"": 9,
    ""91.238.181.94"": 6,
    ""197.145.218.12"": 30,
    ""185.196.220.41"": 18,
    ""181.30.39.44"": 6,
    ""205.210.31.111"": 9,
    ""143.110.220.53"": 3,
    ""197.210.194.240"": 3,
    ""31.222.238.98"": 9,
    ""185.156.73.154"": 6,
    ""147.185.132.60"": 9,
    ""64.64.112.133"": 588
  },
  ""asn"": {
    ""AS11427"": 18868,
    ""AS14061"": 20607,
    ""AS60602"": 14457,
    ""AS137409"": 10554,
    ""AS63949"": 15,
    ""AS16276"": 3,
    ""AS14080"": 3,
    ""AS6327"": 6,
    ""AS396982"": 36,
    ""AS149137"": 6,
    ""AS47890"": 6,
    ""AS48721"": 6,
    ""AS8560"": 3,
    ""AS43350"": 9,
    ""AS210848"": 24,
    ""AS49434"": 6,
    ""AS36884"": 30,
    ""AS213438"": 18,
    ""AS7303"": 6,
    ""AS29465"": 3,
    ""AS44477"": 9
  },
  ""isp"": {
    ""Charter Communications Inc"": 18868,
    ""DigitalOcean, LLC"": 17874,
    ""HYPER-HOSTING"": 14457,
    ""DIGITALOCEAN"": 2733,
    ""GSL Networks Pty LTD"": 10554,
    ""Akamai Technologies, Inc."": 15,
    ""OVH SAS"": 3,
    ""Telmex Colombia S.A."": 3,
    ""Shaw Communications Inc."": 6,
    ""Google LLC"": 36,
    ""TAN Thanh AN International Trade Development Company Limited"": 6,
    ""Unmanaged LTD"": 6,
    ""Flyservers S.A."": 6,
    ""IONOS SE ber.de"": 3,
    ""NForce Entertainment B.V."": 9,
    ""Telkom Internet LTD"": 18,
    ""Datacenter location PAR1 France"": 6,
    ""Wana Corporate"": 30,
    ""ColocaTel Inc."": 18,
    ""Telecom Argentina S.A"": 6,
    ""MTN NIGERIA Communication limited"": 3,
    ""PQ HOSTING PLUS S.R.L."": 9,
    ""OOO SibirInvest"": 6
  },
  ""org"": {
    ""Spectrum"": 18868,
    ""DigitalOcean, LLC"": 16335,
    ""Unknown"": 14487,
    ""LogicWeb Inc"": 10554,
    ""Digitalocean"": 4272,
    ""Linode"": 15,
    ""OVH BV"": 3,
    ""Telmex Colombia S.A"": 3,
    ""Shaw Communications Inc"": 6,
    ""Palo Alto Networks, Inc"": 36,
    ""TANTHANHAN"": 6,
    ""Unmanaged LTD"": 6,
    ""Flyservers S.A"": 6,
    ""IONOS SE"": 3,
    ""Cloud CDN"": 9,
    ""Korotkij Denis Aleksandrovich"": 18,
    ""ThinkTech Technology Industrial CO. Limited"": 6,
    ""Colocatel Inc"": 18,
    ""Fibertel"": 6,
    ""MTN Nigeria"": 3,
    ""PQ HOSTING PLUS S.R.L"": 9,
    ""IP Kiktev Nikolay Vladimirovich"": 6
  },
  ""regionName"": {
    ""Texas"": 18868,
    ""New Jersey"": 13611,
    ""Chi\u0219in\u0103u Municipality"": 14457,
    ""South West"": 7005,
    ""Dhaka Division"": 10554,
    ""California"": 39,
    ""South Holland"": 3,
    ""Bogota D.C."": 3,
    ""Alberta"": 6,
    ""Hanoi"": 6,
    ""England"": 6,
    ""Kaunas"": 6,
    ""State of Berlin"": 3,
    ""North Holland"": 33,
    ""\u00cele-de-France"": 6,
    ""Guelmim-Oued Noun"": 30,
    ""Virginia"": 18,
    ""Buenos Aires"": 6,
    ""Ontario"": 3,
    ""Lagos"": 3,
    ""Drenthe"": 9
  },
  ""country"": {
    ""United States"": 32536,
    ""Moldova"": 14457,
    ""Singapore"": 7005,
    ""Bangladesh"": 10554,
    ""The Netherlands"": 45,
    ""Colombia"": 3,
    ""Canada"": 9,
    ""Vietnam"": 6,
    ""United Kingdom"": 6,
    ""Lithuania"": 6,
    ""Germany"": 3,
    ""France"": 6,
    ""Morocco"": 30,
    ""Argentina"": 6,
    ""Nigeria"": 3
  },
  ""account"": {
    ""hello"": 64546,
    ""ujwbhviu"": 12,
    ""beio"": 6,
    ""Unknown"": 3,
    ""EzNwRAaHD"": 3,
    ""ibMIVa"": 3,
    ""mAAbpJ"": 3,
    ""Administr"": 39,
    ""Test"": 15,
    ""gOPqHSWcK"": 3,
    ""aItDSj"": 3,
    ""MiyxaI"": 3,
    ""Domain"": 18,
    ""KuEsjCcLW"": 3,
    ""nfpQPF"": 3,
    ""QvyPYh"": 3,
    ""rnpUqqiPB"": 3,
    ""bomLZY"": 3,
    ""uEstPc"": 3
  },
  ""keyboard"": {
    ""Unknown"": 64675
  },
  ""client_build"": {
    ""Unknown"": 64675
  },
  ""client_name"": {
    ""Unknown"": 64675
  },
  ""ip_type"": {
    ""Unknown"": 18952,
    ""hosting"": 35124,
    ""proxy"": 10554,
    ""hosting & proxy"": 12,
    ""mobile"": 30,
    ""mobile & hosting"": 3
  }
}"
c6SBTrmH,2025-06-15_stats.json,rdp_snitch,JSON,Monday 16th of June 2025 07:15:10 PM CDT,"{
  ""ip"": {
    ""24.173.30.170"": 18866,
    ""167.172.131.118"": 12975,
    ""80.66.79.30"": 14457,
    ""139.59.97.137"": 2733,
    ""64.64.112.155"": 9966,
    ""209.97.152.8"": 618,
    ""178.128.21.189"": 4272,
    ""45.79.168.199"": 12,
    ""45.79.73.71"": 3,
    ""157.230.86.112"": 3,
    ""5.135.169.222"": 3,
    ""190.85.239.111"": 3,
    ""96.51.53.164"": 6,
    ""147.185.132.21"": 9,
    ""103.15.222.151"": 6,
    ""2.57.121.247"": 6,
    ""165.227.207.152"": 3,
    ""194.165.16.161"": 6,
    ""87.106.235.201"": 3,
    ""141.98.80.148"": 9,
    ""92.63.197.23"": 18,
    ""198.235.24.177"": 9,
    ""91.238.181.94"": 6,
    ""197.145.218.12"": 30,
    ""185.196.220.41"": 18,
    ""181.30.39.44"": 6,
    ""205.210.31.111"": 9,
    ""143.110.220.53"": 3,
    ""197.210.194.240"": 3,
    ""31.222.238.98"": 9,
    ""185.156.73.154"": 6,
    ""147.185.132.60"": 9,
    ""64.64.112.133"": 588
  },
  ""asn"": {
    ""AS11427"": 18866,
    ""AS14061"": 20607,
    ""AS60602"": 14457,
    ""AS137409"": 10554,
    ""AS63949"": 15,
    ""AS16276"": 3,
    ""AS14080"": 3,
    ""AS6327"": 6,
    ""AS396982"": 36,
    ""AS149137"": 6,
    ""AS47890"": 6,
    ""AS48721"": 6,
    ""AS8560"": 3,
    ""AS43350"": 9,
    ""AS210848"": 24,
    ""AS49434"": 6,
    ""AS36884"": 30,
    ""AS213438"": 18,
    ""AS7303"": 6,
    ""AS29465"": 3,
    ""AS44477"": 9
  },
  ""isp"": {
    ""Charter Communications Inc"": 18866,
    ""DigitalOcean, LLC"": 17874,
    ""HYPER-HOSTING"": 14457,
    ""DIGITALOCEAN"": 2733,
    ""GSL Networks Pty LTD"": 10554,
    ""Akamai Technologies, Inc."": 15,
    ""OVH SAS"": 3,
    ""Telmex Colombia S.A."": 3,
    ""Shaw Communications Inc."": 6,
    ""Google LLC"": 36,
    ""TAN Thanh AN International Trade Development Company Limited"": 6,
    ""Unmanaged LTD"": 6,
    ""Flyservers S.A."": 6,
    ""IONOS SE ber.de"": 3,
    ""NForce Entertainment B.V."": 9,
    ""Telkom Internet LTD"": 18,
    ""Datacenter location PAR1 France"": 6,
    ""Wana Corporate"": 30,
    ""ColocaTel Inc."": 18,
    ""Telecom Argentina S.A"": 6,
    ""MTN NIGERIA Communication limited"": 3,
    ""PQ HOSTING PLUS S.R.L."": 9,
    ""OOO SibirInvest"": 6
  },
  ""org"": {
    ""Spectrum"": 18866,
    ""DigitalOcean, LLC"": 16335,
    ""Unknown"": 14487,
    ""LogicWeb Inc"": 10554,
    ""Digitalocean"": 4272,
    ""Linode"": 15,
    ""OVH BV"": 3,
    ""Telmex Colombia S.A"": 3,
    ""Shaw Communications Inc"": 6,
    ""Palo Alto Networks, Inc"": 36,
    ""TANTHANHAN"": 6,
    ""Unmanaged LTD"": 6,
    ""Flyservers S.A"": 6,
    ""IONOS SE"": 3,
    ""Cloud CDN"": 9,
    ""Korotkij Denis Aleksandrovich"": 18,
    ""ThinkTech Technology Industrial CO. Limited"": 6,
    ""Colocatel Inc"": 18,
    ""Fibertel"": 6,
    ""MTN Nigeria"": 3,
    ""PQ HOSTING PLUS S.R.L"": 9,
    ""IP Kiktev Nikolay Vladimirovich"": 6
  },
  ""regionName"": {
    ""Texas"": 18866,
    ""New Jersey"": 13611,
    ""Chi\u0219in\u0103u Municipality"": 14457,
    ""South West"": 7005,
    ""Dhaka Division"": 10554,
    ""California"": 39,
    ""South Holland"": 3,
    ""Bogota D.C."": 3,
    ""Alberta"": 6,
    ""Hanoi"": 6,
    ""England"": 6,
    ""Kaunas"": 6,
    ""State of Berlin"": 3,
    ""North Holland"": 33,
    ""\u00cele-de-France"": 6,
    ""Guelmim-Oued Noun"": 30,
    ""Virginia"": 18,
    ""Buenos Aires"": 6,
    ""Ontario"": 3,
    ""Lagos"": 3,
    ""Drenthe"": 9
  },
  ""country"": {
    ""United States"": 32534,
    ""Moldova"": 14457,
    ""Singapore"": 7005,
    ""Bangladesh"": 10554,
    ""The Netherlands"": 45,
    ""Colombia"": 3,
    ""Canada"": 9,
    ""Vietnam"": 6,
    ""United Kingdom"": 6,
    ""Lithuania"": 6,
    ""Germany"": 3,
    ""France"": 6,
    ""Morocco"": 30,
    ""Argentina"": 6,
    ""Nigeria"": 3
  },
  ""account"": {
    ""hello"": 64544,
    ""ujwbhviu"": 12,
    ""beio"": 6,
    ""Unknown"": 3,
    ""EzNwRAaHD"": 3,
    ""ibMIVa"": 3,
    ""mAAbpJ"": 3,
    ""Administr"": 39,
    ""Test"": 15,
    ""gOPqHSWcK"": 3,
    ""aItDSj"": 3,
    ""MiyxaI"": 3,
    ""Domain"": 18,
    ""KuEsjCcLW"": 3,
    ""nfpQPF"": 3,
    ""QvyPYh"": 3,
    ""rnpUqqiPB"": 3,
    ""bomLZY"": 3,
    ""uEstPc"": 3
  },
  ""keyboard"": {
    ""Unknown"": 64673
  },
  ""client_build"": {
    ""Unknown"": 64673
  },
  ""client_name"": {
    ""Unknown"": 64673
  },
  ""ip_type"": {
    ""Unknown"": 18950,
    ""hosting"": 35124,
    ""proxy"": 10554,
    ""hosting & proxy"": 12,
    ""mobile"": 30,
    ""mobile & hosting"": 3
  }
}"
yX853XnW,Emoji Fusion,Salagata,JavaScript,Monday 16th of June 2025 05:41:53 PM CDT,// TODO start
Bn0yRa4G,JSON Travel Advisories,yannisk2008,JSON,Monday 16th of June 2025 05:41:14 PM CDT,"{
   ""advisoriesCanada"":[
      {
         ""Country"":""Canada"",
         ""Advisory Level"":1,
         ""Safety Index"":73,
         ""Headline"":""Exercise Normal Precautions"",
         ""Description"":""Exercise Normal Precautions in Canada.""
      }
   ],
   ""advisoriesUSA"":[
      {
         ""Country"":""United States Of America"",
         ""Advisory Level"":1,
         ""Safety Index"":64,
         ""Headline"":""Exercise Normal Precautions."",
         ""Description"":""Exercise Normal Precautions in United States Of America.""
      }
   ],
   ""advisoriesMexico"":[
      {
         ""Country"":""Mexico"",
         ""Advisory Level"":2,
         ""Safety Index"":37,
         ""Headline"":""Exercise Increased Caution."",
         ""Description"":""Exercise Increased Caution in Mexico due to violent crime."",
         ""Region Risks"":""Reconsider travel to: Chiapas, Guerrero, Guanajuato,  Michoacan, North-western Durango, Sonora, Tamapulicas, Zacatecas due to violant crime and unpredictible security situation.""
      }
   ],
   ""advisoriesCuba"":[
      {
         ""Country"":""Cuba"",
         ""Advisory Level"":2,
         ""Safety Index"":39,
         ""Headline"":""Exercise Increased Caution"",
         ""Description"":""Exercise increased caution in Cuba due to crime and prolonged power outages:""
      }
   ],
   ""advisoriesHonduras"":[
      {
         ""Country"":""Honduras"",
         ""Advisory Level"":3,
         ""Safety Index"":28,
         ""Headline"":""Reconsider Travel"",
         ""Description"":""Reconsider travel to Honduras due to crime."",
         ""Region Risks"":""Do not travel to: Gracias a Dios Department due to crime."",
         ""More Info"":""Violent crime such as homocide, armed robbery, and kidnapping remains common in Honduras. Violent gang activity, such as extortion, violent street crime, rape, narcotics, and human trafficking, is widespread""
      }
   ],
   ""advisoriesNicaragua"":[
      {
         ""Country"":""Nicaragua"",
         ""Advisory Level"":4,
         ""Safety Index"":18,
         ""Headline"":""Do not travel, unless is essential"",
         ""Description"":""Do not travel to Nicaragua, unless is essential due to: arbitrary enforcement of laws, the risk of wrongful detention, and limited healthcare availability."",
         ""More Info"":""The Government of Nicaragua has subjected U.S. citizens to arbitrary entry and exit bans, expulsions, arrests, revocations of Nicaraguan citizenship, and other actions. The Government of Nicaragua may\nArbitrarily deny entry or re-entry to Nicaragua or departure from Nicaragua to U.S. citizens and Nicaraguan citizens. This includes entry by air or land. Travel refunds are NOT provided in these cases. Denials and exit bans can occur for political reasons. This includes perceived support for or association with those the government disfavors. The government is not required to provide a basis for its denial.\nSearch personal phones, computers, social media accounts, and documents for anti-government content, limit photography, seize personal devices, target individuals for political reasons, regardless of nationality. These can include former allies, political activists, business representatives, religious and charity groups, clergy, missionaries, human rights advocates, civil society leaders, academics, and journalists, target pro-democracy advocates and their family members.\nConfiscate privately-owned land, residences, financial assets, or personal property. They may do this without warning or due process, and arbitrarily detain, accuse, and charge individuals with terrorism, money laundering, or organized crime offenses. They may do this without fair or transparent processes.""
      }
   ],
   ""advisoriesGuatemala"":[
      {
         ""Country"":""Guatemala"",
         ""Advisory Level"":2,
         ""Safety Index"":41,
         ""Headline"":""Exercise Increased Caution"",
         ""Description"":""Exercise Increased Caution in Guatemala due to the threat of violent crime."",
         ""Region Risks"":""Reconsider travel to border areas between Guatemala and Chiapas State in Mexico due to organised crime and drug-related violence."",
         ""More Info"":""Violent crime, including murder, carjacking and kidnapping, is common. Risks increase at night. Take extra care after dark. Only use ATMs during daylight.Border crossings have a high crime rate. Only cross during daylight hours. Allow enough time to reach a major city before dark. Criminals target travellers at the airport and driving to hotels. Use only pre-paid or radio taxis. Don't use taxis on the street or use taxi stands. Always keep vehicle windows and doors locked, even when moving. Guatemala has 4 active volcanoes. Know where your nearest shelter is. Know how to protect yourself in the event of an eruption. If you climb a volcano, use experienced guides and follow local advice.""
      }
   ],
   ""advisoriesHaiti"":[
      {
         ""Country"":""Haiti"",
         ""Advisory Level"":5,
         ""Safety Index"":6,
         ""Headline"":""Do not travel"",
         ""Description"":""Do not travel to Haiti due to gang violance, kidnapping, limited healthcare, and civil unrest"",
         ""More Info"":""Since March of 2024, Haiti has been under a state of emergency. Firearms are common in that country. Do not travel to Haiti for any reason""
      }
   ],
   ""advisoriesPanama"":[
      {
         ""Country"":""Panama"",
         ""Advisory Level"":2,
         ""Safety Index"":37,
         ""Headline"":""Exercise increased caution"",
         ""Description"":""Exercise increased caution in Panama due to crime and civil unrest"",
         ""Region Risks"":""Do not travel to: Mosquito Golf due to drug trafficking and other illegal activity, and Darien Region due to criminal activity and human traficking.""
      }
   ],
   ""advisoriesJamaica"":[
      {
         ""Country"":""Jamaica"",
         ""Advisory Level"":2,
         ""Safety Index"":31,
         ""Headline"":""Exercise Increased Caution"",
         ""Description"":""Exercise increased caution in Jamaica due to the risk of violent crime.""
      }
   ],
   ""advisoriesElSalvador"":[
      {
         ""Country"":""El Salvador"",
         ""Advisory Level"":2,
         ""Safety Index"":49,
         ""Headline"":""Exercise Increased Caution"",
         ""Description"":""Exercise increased caution in Jamaica due to the risk of violent crime.""
      }
   ],
   ""advisoriesCostaRica"":[
      {
         ""Country"":""Costa Rica"",
         ""Advisory Level"":1,
         ""Safety Index"":55,
         ""Headline"":""Exercise Normal Precautions"",
         ""Description"":""Exercise normal precautions in Costa Rica.""
      }
   ],
   ""advisoriesBelize"":[
      {
         ""Country"":""Belize"",
         ""Advisory Level"":2,
         ""Safety Index"":36,
         ""Headline"":""Exercise Increased Caution"",
         ""Description"":""Exercise increased caution in Belize due to crime."",
         ""Region Risks"":""Reconsider travel to Belize City due to gang violence.""
      }
   ],
   ""advisoriesDominicanRepublic"":[
      {
         ""Country"":""Dominican Republic"",
         ""Advisory Level"":2,
         ""Safety Index"":49,
         ""Headline"":""Exercise Increased Caution"",
         ""Description"":""Exercise increased caution in Dominican Republic due to crime."",
         ""More Info"":""If you travel to the Dominican Republic, note that crime is a concern throughout the country. They include, sexual assault, homocide, and robbery.""
      }
   ],
   ""advisoriesBahamas"":[
      {
         ""Country"":""Bahamas"",
         ""Advisory Level"":2,
         ""Safety Index"":44,
         ""Headline"":""Exercise Increased Caution"",
         ""Description"":""Exercise increased caution in the Bahamas due to crime and the risk of shark attack at the coastlines."",
         ""More info"":""Beach info: There has been shark attacks recently occurring on the region. Serious injuries and deaths have occurred.Boating there is not properly regulated. Injuries and death have occurred there.""
      }
   ],
   ""advisoriesArgentina"":[
      {
         ""Country"":""Argentina"",
         ""Advisory Level"":1,
         ""Safety Index"":63,
         ""Headline"":""Exercise Normal Precautions"",
         ""Description"":""Exercise normal precautions in Argentina.""
      }
   ],
   ""advisoriesPeru"":[
      {
         ""Country"":""Peru"",
         ""Advisory Level"":2,
         ""Safety Index"":39,
         ""Headline"":""Exercise Increased Caution"",
         ""Description"":""Exercise increased caution in Peru  due to crime, and possible kidnappings."",
         ""Region Risks"":""Do not travel to: The border area with Colombia for any reason, and The Valley of the ApurÃ­mac, Ene, and Mantaro Rivers (VRAEM) includes areas within the Departments of Ayacucho, Cusco, Huancavelica, and JunÃ­n""
      }
   ],
   ""advisoriesColombia"":[
      {
         ""Country"":""Colombia"",
         ""Advisory Level"":3,
         ""Safety Index"":21,
         ""Headline"":""Reconsider Travel"",
         ""Description"":""Reconsider travel to Colombia due to civil unrest, crime, and kidnapping."",
         ""Region Risks"":""Do not travel to: Arauca, Cauca (excluding PopayÃ¡n), and Norte de Santander departments due to crime and terrorism. Do not travel to the border with Venezuela for any reason due to crime, kidnapping, conflict between armed groups, and the risk of detention.""
      }
   ],
   ""advisoriesSuriname"":[
      {
         ""Country"":""Suriname"",
         ""Advisory Level"":1,
         ""Safety Index"":65,
         ""Headline"":""Exercise Normal Precautions"",
         ""Description"":""Exercise normal precautions in Suriname.""
      }
   ],
   ""advisoriesVenezuela"":[
      {
         ""Country"":""Venezuela"",
         ""Advisory Level"":5,
         ""Safety Index"":4,
         ""Headline"":""Do not travel"",
         ""Description"":""Do not travel to Venezuela due to wrongful detention, terrorism, serious crime rates, civil unrest, kidnapping, carjackings, arbitrary of enforcement of local laws, and very poor health infastructure"",
         ""More info"":""Crime rates increase significantly after dark in major cities. Wrongful detentions pose a serious risk in Venezuela. The U.S. Government has no way to contact its citizens detained in Venezuela. Violent crimes are common in Venezuela, especially at night.\n Travel between Caracas and SimÃ³n BolÃ­var International Airport is very dangerous. Violent crime is common inside the facilities. Do not travel to Venezuela for any reason.""
      }
   ]
}
"
mRfA3aUm,2025-06-16T23:10:55.445911,powerampache,PHP,Monday 16th of June 2025 04:10:54 PM CDT,"1.01-80 (80) - DB: 83
retrofit2.HttpException: HTTP 404 { ""exception"" : ""Connection reset"" }
	at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)
	at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)
	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:529)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1156)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:651)
	at java.lang.Thread.run(Thread.java:1119)

"
zhR46LYS,Definitive Minecraft Linux Deployment & Automated Maintenance,KC9UZR,Bash,Monday 16th of June 2025 03:58:13 PM CDT,"#!/bin/bash

# --- Configuration ---
SERVER_DIR=""$HOME/minecraft_server""
BACKUP_DIR=""$HOME/minecraft_backups""
MEMORY=""4G""
SERVER_JAR_NAME=""paper.jar""
SCREEN_NAME=""mc_server""

# --- Globals ---
JAVA_EXECUTABLE=""""
CURL_USER_AGENT=""Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0""

# --- Colors ---
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; CYAN='\033[0;36m'; NC='\033[0m'

# --- Helper Functions ---
print_info() { echo -e ""${BLUE}[INFO]${NC} $1""; }
print_success() { echo -e ""${GREEN}[SUCCESS]${NC} $1""; }
print_warning() { echo -e ""${YELLOW}[WARNING]${NC} $1""; }
print_error() { echo -e ""${RED}[ERROR]${NC} $1""; }

# --- CORE SYSTEM FUNCTIONS ---

download_file() {
    local url=""$1""
    local output_path=""$2""
    local curl_output; curl_output=$(curl --user-agent ""$CURL_USER_AGENT"" -L -o ""$output_path"" --fail --show-error ""$url"" 2>&1)
    if [ $? -ne 0 ]; then
        print_error ""Download failed for: $url""; print_warning ""Curl Error: $curl_output""; return 1
    fi
    return 0
}

run_system_diagnostics() {
    for pkg in curl wget jq screen nano; do
        if ! command -v ""$pkg"" &> /dev/null; then print_error ""Required command '$pkg' is not installed. Please run 'sudo apt-get install $pkg'""; exit 1; fi
    done
}

install_and_find_java() {
    if [ -z ""$JAVA_EXECUTABLE"" ] || [ ! -f ""$JAVA_EXECUTABLE"" ]; then
        print_info ""Ensuring Java 21 is installed...""; sudo apt-get update -y >/dev/null 2>&1
        if ! sudo apt-get install -y openjdk-21-jre-headless >/dev/null 2>&1; then print_error ""Failed to install Java 21.""; exit 1; fi
        local discovered_path; discovered_path=$(dpkg -L openjdk-21-jre-headless | grep '/bin/java$' | head -n 1)
        if [ -n ""$discovered_path"" ] && [ -f ""$discovered_path"" ]; then
            JAVA_EXECUTABLE=""$discovered_path""; print_success ""Java 21 executable located.""
        else
            print_error ""Java installed, but executable could not be located.""; exit 1
        fi
    fi
}

# --- SOFTWARE INSTALLATION FUNCTIONS ---

update_paper() {
    if is_server_running; then print_error ""Server is running! Stop it before updating.""; return; fi
    print_info ""Checking for PaperMC updates...""; mkdir -p ""$SERVER_DIR""
    local latest_version; latest_version=$(curl -sfL ""$CURL_USER_AGENT"" https://api.papermc.io/v2/projects/paper | jq -r '.versions[-1]')
    local version_url=""https://api.papermc.io/v2/projects/paper/versions/${latest_version}""
    local latest_build; latest_build=$(curl -sfL ""$CURL_USER_AGENT"" ""$version_url"" | jq -r '.builds[-1]')
    local build_url=""${version_url}/builds/${latest_build}""
    local jar_name; jar_name=$(curl -sfL ""$CURL_USER_AGENT"" ""$build_url"" | jq -r '.downloads.application.name')
    if download_file ""${build_url}/downloads/${jar_name}"" ""$SERVER_DIR/$SERVER_JAR_NAME""; then
        print_success ""PaperMC is up to date.""
    else
        print_error ""Could not update PaperMC.""; return 1
    fi
}

update_geyser() {
    if is_server_running; then print_error ""Server is running! Stop it before updating.""; return; fi
    print_info ""Updating Geyser & Floodgate with verification...""; local PLUGINS_DIR=""${SERVER_DIR}/plugins""; mkdir -p ""$PLUGINS_DIR""
    
    # Geyser (GitHub API is primary for stability)
    print_info ""Downloading latest Geyser...""
    local geyser_url; geyser_url=$(curl -sfL ""$CURL_USER_AGENT"" ""https://api.github.com/repos/GeyserMC/Geyser/releases/latest"" | jq -r '.assets[] | select(.name | contains(""Geyser-Spigot"")) | .browser_download_url')
    download_file ""$geyser_url"" ""${PLUGINS_DIR}/Geyser-Spigot.jar""
    if [ -f ""${PLUGINS_DIR}/Geyser-Spigot.jar"" ]; then print_success ""Geyser download successful and verified.""; else print_error ""Geyser download failed verification.""; fi

    # Floodgate (GitHub API is primary for stability)
    print_info ""Downloading latest Floodgate...""
    local floodgate_url; floodgate_url=$(curl -sfL ""$CURL_USER_AGENT"" ""https://api.github.com/repos/GeyserMC/Floodgate/releases/latest"" | jq -r '.assets[] | select(.name | contains(""floodgate-spigot"")) | .browser_download_url')
    download_file ""$floodgate_url"" ""${PLUGINS_DIR}/floodgate-spigot.jar""
    if [ -f ""${PLUGINS_DIR}/floodgate-spigot.jar"" ]; then print_success ""Floodgate download successful and verified.""; else print_error ""Floodgate download failed verification.""; fi
}

# --- New Interactive Plugin Installer ---
install_plugins_interactive() {
    if is_server_running; then print_error ""Server is running! Stop it before installing plugins.""; return; fi
    local PLUGINS_DIR=""${SERVER_DIR}/plugins""; mkdir -p ""$PLUGINS_DIR""
    
    declare -A plugins=(
        [""EssentialsX""]=""https://ci.essentialsx.net/job/EssentialsX/lastSuccessfulBuild/artifact/target/EssentialsX.jar""
        [""EssentialsX Spawn""]=""https://ci.essentialsx.net/job/EssentialsX/lastSuccessfulBuild/artifact/target/EssentialsXSpawn.jar""
        [""EssentialsX Chat""]=""https://ci.essentialsx.net/job/EssentialsX/lastSuccessfulBuild/artifact/target/EssentialsXChat.jar""
        [""LuckPerms""]=""https://api.luckperms.net/v2/downloader""
        [""WorldEdit""]=""https://api.modrinth.com/v2/project/worldedit/version?loaders=%5B%22paper%22%5D""
        [""WorldGuard""]=""https://api.modrinth.com/v2/project/worldguard/version?loaders=%5B%22paper%22%5D""
        [""CoreProtect""]=""https://api.github.com/repos/PlayPro/CoreProtect/releases/latest""
        [""ProtocolLib""]=""https://api.github.com/repos/dmulloy2/ProtocolLib/releases/latest""
        [""ViaVersion""]=""https://ci.viaversion.com/job/ViaVersion/lastSuccessfulBuild/api/json""
        [""ViaBackwards""]=""https://ci.viaversion.com/job/ViaBackwards/lastSuccessfulBuild/api/json""
        [""Vault""]=""https://api.github.com/repos/MilkBowl/Vault/releases/latest""
        [""Dynmap""]=""https://api.modrinth.com/v2/project/dynmap/version?loaders=%5B%22paper%22%5D""
        [""ChestShop""]=""https://api.github.com/repos/ChestShop-authors/ChestShop-3/releases/latest""
        [""GriefPrevention""]=""https://api.github.com/repos/TechFortress/GriefPrevention/releases/latest""
        [""spark""]=""https://api.github.com/repos/lucko/spark/releases/latest""
        [""Chunky""]=""https://api.modrinth.com/v2/project/chunky/version?loaders=%5B%22paper%22%5D""
        [""GSit""]=""https://api.github.com/repos/Gecolay/GSit/releases/latest""
        [""SimpleTPA""]=""https://api.github.com/repos/imDalton/SimpleTPA/releases/latest""
        [""PlayerWarps""]=""https://api.modrinth.com/v2/project/playerwarps/version?loaders=%5B%22paper%22%5D""
        [""ImageMaps""]=""https://api.modrinth.com/v2/project/imagemaps/version?loaders=%5B%22paper%22%5D""
    )
    local plugin_names=(""${!plugins[@]}""); local selections=()

    while true; do
        clear; echo -e ""${CYAN}--- Interactive Plugin Installer ---${NC}""
        echo ""Enter a number to select/deselect a plugin. Select 'Done' when finished.""
        
        for i in ""${!plugin_names[@]}""; do
            local name=""${plugin_names[$i]}""; local installed_mark=""""
            for s in ""${selections[@]}""; do if [[ ""$s"" == ""$name"" ]]; then installed_mark=""${GREEN} [Selected]${NC}""; fi; done
            printf ""  %-2s. %-20s %s\n"" ""$((i+1))"" ""$name"" ""$installed_mark""
        done
        echo -e ""\n  ${GREEN}d. Done Installing${NC}""
        echo -e ""  ${RED}c. Cancel${NC}""
        read -p ""Your choice: "" choice

        case ""$choice"" in
            d|D) break;;
            c|C) selections=(); break;;
            *)
                if [[ ""$choice"" =~ ^[0-9]+$ ]] && [ ""$choice"" -ge 1 ] && [ ""$choice"" -le ""${#plugin_names[@]}"" ]; then
                    local selected_name=""${plugin_names[$((choice-1))]}""; local found=0
                    for i in ""${!selections[@]}""; do
                        if [[ ""${selections[$i]}"" == ""$selected_name"" ]]; then
                            unset 'selections[i]'; found=1; break
                        fi
                    done
                    if [ $found -eq 0 ]; then selections+=(""$selected_name""); fi
                else
                    print_warning ""Invalid input. Please try again.""; sleep 1
                fi
                ;;
        esac
    done
    
    if [ ${#selections[@]} -gt 0 ]; then
        print_info ""Installing selected plugins...""
        for name in ""${selections[@]}""; do
            local api_url=""${plugins[$name]}""; local download_url=""""
            print_info ""Fetching ${name}...""
            if [[ ""$api_url"" == *modrinth.com* ]]; then
                download_url=$(curl -sfL ""$CURL_USER_AGENT"" ""$api_url"" | jq -r '.[0].files[0].url')
            elif [[ ""$api_url"" == *luckperms.net* ]]; then
                download_url=$(curl -sfL ""$CURL_USER_AGENT"" ""$api_url"" | jq -r '.bukkit.url')
            elif [[ ""$api_url"" == *viaversion.com* ]]; then
                local filename=$(curl -sfL ""$CURL_USER_AGENT"" ""$api_url"" | jq -r '.artifacts[0].fileName')
                download_url=""${api_url//\/api\/json/}/artifact/build/libs/$filename""
            elif [[ ""$api_url"" == *essentialsx.net* ]]; then
                download_url=""$api_url"" # Direct download link
            elif [[ ""$api_url"" == *github.com* ]]; then
                download_url=$(curl -sfL ""$CURL_USER_AGENT"" ""$api_url"" | jq -r '.assets[] | select(.name | endswith("".jar"")) | .browser_download_url' | head -n 1)
            fi
            
            if [ -n ""$download_url"" ]; then
                local filename; filename=$(basename ""$download_url""); filename=""${filename// /_}"" # Sanitize filename
                download_file ""$download_url"" ""${PLUGINS_DIR}/${name}.jar""
            else
                print_error ""Could not determine download URL for ${name} from API.""
            fi
        done
        print_success ""Plugin installation complete.""
    fi
}

install_server() {
    print_info ""Starting new Minecraft Server installation...""; install_and_find_java
    mkdir -p ""$SERVER_DIR""; cd ""$SERVER_DIR"" || exit
    update_paper || exit 1
    
    print_info ""Starting server once to generate eula.txt...""
    ""$JAVA_EXECUTABLE"" -Xmx1024M -Xms1024M -jar ""$SERVER_JAR_NAME"" nogui > /dev/null 2>&1
    if [ ! -f ""eula.txt"" ]; then print_error ""EULA file not created.""; exit 1; fi
    sed -i 's/eula=false/eula=true/g' eula.txt
    print_success ""EULA accepted. Server is ready.""
    print_warning ""Use the menu to install plugins and Geyser as needed.""
}

uninstall_script() {
    print_error ""!!! DANGER ZONE - UNINSTALL !!!""; print_warning ""This option will permanently delete the following:""
    echo -e ""  - Server Directory:  ${RED}${SERVER_DIR}${NC}\n  - Backups Directory: ${RED}${BACKUP_DIR}${NC}\n  - This Script:       ${RED}$(realpath ""$0"")${NC}""
    read -p ""Type 'uninstall' to confirm: "" confirm
    if [[ ""$confirm"" != ""uninstall"" ]]; then print_info ""Uninstall cancelled.""; return; fi
    print_info ""Proceeding with uninstallation...""; if is_server_running; then stop_server; fi
    print_info ""Deleting server directory...""; rm -rf ""$SERVER_DIR""
    print_info ""Deleting backups directory...""; rm -rf ""$BACKUP_DIR""
    print_success ""Uninstallation complete. This script will now delete itself.""; echo ""Goodbye!""; rm -- ""$0""; exit 0
}

# --- MENU-DRIVEN FUNCTIONS ---
is_server_running() { screen -list | grep -q ""$SCREEN_NAME""; }
start_server() { if is_server_running; then print_warning ""Already running.""; return; fi; if [ ! -f ""$SERVER_DIR/$SERVER_JAR_NAME"" ]; then print_error ""Not installed!""; return; fi; install_and_find_java; cd ""$SERVER_DIR"" || exit; print_info ""Starting server...""; screen -dmS ""$SCREEN_NAME"" ""$JAVA_EXECUTABLE"" -Xms${MEMORY} -Xmx${MEMORY} -jar ""$SERVER_JAR_NAME"" nogui; sleep 2; if is_server_running; then print_success ""Server started.""; else print_error ""Server failed to start.""; fi; }
stop_server() { if ! is_server_running; then print_warning ""Not running.""; return; fi; screen -S ""$SCREEN_NAME"" -p 0 -X stuff ""stop\n""; print_info ""Waiting for shutdown...""; count=0; while is_server_running; do sleep 1; count=$((count+1)); if [ $count -gt 20 ]; then print_warning ""Server not responding.""; break; fi; done; if ! is_server_running; then print_success ""Server stopped.""; fi; }
console() { if ! is_server_running; then print_warning ""Not running.""; return; fi; print_info ""Attaching. To exit: ${CYAN}Ctrl+A then D${NC}.""; sleep 1; screen -r ""$SCREEN_NAME""; }
backup_server() { if is_server_running; then read -p ""$(echo -e ${YELLOW}""Stop server for a safe backup? (y/n): ""${NC})"" c; if [[ ""$c"" =~ ^[Yy]$ ]]; then stop_server; fi; fi; print_info ""Creating backup...""; mkdir -p ""$BACKUP_DIR""; TIMESTAMP=$(date +""%Y-%m-%d_%H-%M-%S""); tar -czf ""${BACKUP_DIR}/backup_${TIMESTAMP}.tar.gz"" -C ""$SERVER_DIR"" .; print_success ""Backup created in ${BACKUP_DIR}""; }
edit_properties() { if [ -f ""$SERVER_DIR/server.properties"" ]; then nano ""$SERVER_DIR/server.properties""; else print_error ""server.properties not found!""; fi; }
view_log() { if [ -f ""$SERVER_DIR/logs/latest.log"" ]; then print_info ""Live log. Press Ctrl+C to exit.""; tail -f ""$SERVER_DIR/logs/latest.log""; else print_error ""latest.log not found!""; fi; }

main_menu() {
    while true; do
        clear
        echo -e ""${CYAN}================================================${NC}""
        echo -e ""${YELLOW}      Minecraft Server Manager (Definitive)     ${NC}""
        echo -e ""${CYAN}================================================${NC}""
        echo -e ""Status: $(if is_server_running; then echo -e ""${GREEN}RUNNING${NC}""; else echo -e ""${RED}STOPPED${NC}""; fi)""
        echo -e ""\n  --- Server Control ---""
        echo -e ""  ${GREEN}1.${NC} Start Server         ${BLUE}2.${NC} View Console""
        echo -e ""  ${RED}3.${NC} Stop Server          ${BLUE}4.${NC} View Live Log""
        echo -e ""\n  --- Software Management ---""
        echo -e ""  ${CYAN}5.${NC} Update Paper Jar""
        echo -e ""  ${CYAN}6.${NC} Install Popular Plugins (Interactive Menu)""
        echo -e ""  ${CYAN}7.${NC} Install/Update Geyser & Floodgate""
        echo -e ""\n  --- File Management & Uninstallation ---""
        echo -e ""  ${YELLOW}8.${NC} Edit server.properties   ${YELLOW}9.${NC} Create Backup""
        echo -e ""  ${BLUE}10.${NC} Clean Install Server    ${RED}11.${NC} UNINSTALL EVERYTHING""
        echo -e ""  ${RED}12.${NC} Exit\n""
        read -p ""Enter your choice [1-12]: "" choice

        case $choice in
            1) start_server;; 2) console;; 3) stop_server;; 4) view_log;;
            5) update_paper;; 6) install_plugins_interactive;; 7) update_geyser;;
            8) edit_properties;; 9) backup_server;;
            10) read -p ""$(echo -e ${RED}""This will DELETE the current server. Are you sure? (y/n): ""${NC})"" c; if [[ ""$c"" =~ ^[Yy]$ ]]; then rm -rf ""$SERVER_DIR""; install_server; fi;;
            11) uninstall_script;;
            12) if is_server_running; then print_warning ""Stop server before exiting.""; else break; fi;;
            *) print_warning ""Invalid option."";;
        esac
        if [[ ""$choice"" != ""11"" ]]; then echo -e ""\n${YELLOW}Press [Enter] to return to the menu...${NC}""; read -p """"; fi
    done
    print_success ""Goodbye!""
}

# --- Script Entry Point ---
if [[ $EUID -eq 0 ]]; then print_error ""This script must not be run as root.""; exit 1; fi
run_system_diagnostics
main_menu"
13miPPW8,Untitled,3th1ca14aX0r,JSON,Monday 16th of June 2025 03:52:24 PM CDT,"{""lang"": ""Rust"", ""source_code"": ""use std::{\n    io::{self, BufRead},\n    str::FromStr,\n};\n\nstruct LineBuf(String);\n\nimpl LineBuf {\n    fn new() -> Self {\n        Self(String::new())\n    }\n\n    #[allow(dead_code)]\n    fn get(&self) -> &String {\n        &self.0\n    }\n\n    fn offer(&mut self) -> &mut String {\n        self.0.clear();\n        &mut self.0\n    }\n\n    fn parse_item<T>(s: &str) -> JoyResult<T>\n    where\n        T: FromStr,\n    {\n        s.parse().or_else(|_| Err(JoyError::ParseError))\n    }\n\n    #[allow(dead_code)]\n    fn parse<T>(&self) -> JoyResult<T>\n    where\n        T: FromStr,\n    {\n        Self::parse_item(self.0.trim())\n    }\n\n    #[allow(dead_code)]\n    fn parse2<T1, T2>(&self) -> JoyResult<(T1, T2)>\n    where\n        T1: FromStr,\n        T2: FromStr,\n    {\n        let mut it = self.0.split_whitespace();\n        let a = Self::parse_item(it.next().ok_or(JoyError::LineItemExhausted)?)?;\n        let b = Self::parse_item(it.next().ok_or(JoyError::LineItemExhausted)?)?;\n        Ok((a, b))\n    }\n\n    #[allow(dead_code)]\n    fn parse_vec<T>(&self) -> JoyResult<Vec<T>>\n    where\n        T: FromStr,\n    {\n        self.0\n            .split_whitespace()\n            .map(|s| s.parse().or(Err(JoyError::ParseError)))\n            .collect()\n    }\n}\n\n#[derive(Debug)]\nenum JoyError {\n    IOError(io::Error),\n    LineItemExhausted,\n    ParseError,\n}\n\ntype JoyResult<T> = Result<T, JoyError>;\n\nimpl std::convert::From<io::Error> for JoyError {\n    fn from(err: io::Error) -> Self {\n        Self::IOError(err)\n    }\n}\n\nfn main() -> JoyResult<()> {\n    let mut buf = LineBuf::new();\n    let stdin = io::stdin();\n    let mut stdin = stdin.lock();\n\n    stdin.read_line(buf.offer())?;\n    let t: usize = buf.parse()?;\n\n    for _ in 0..t {\n        stdin.read_line(buf.offer())?;\n        let (h, n): (i32, usize) = buf.parse2()?;\n\n        stdin.read_line(buf.offer())?;\n\n        let mut q: Vec<i32> = buf.parse_vec()?;\n        q.push(0);\n\n        assert_eq!(q.len(), n + 1);\n        assert_eq!(q[0], h);\n\n        // println!(\""{:?}\"", q);\n\n        let mut i = 0;\n        let mut c = 0;\n        while i < n - 1 {\n            let now = q[i + 1] + 1;\n            if q[i + 2] == now - 2 {\n                i += 2;\n            } else {\n                // println!(\""q[i] = {}\"", q[i]);\n                c += 1;\n                i += 1;\n            }\n        }\n\n        println!(\""{}\"", c);\n    }\n\n    Ok(())\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": true, ""code_uid"": ""91c173e6f252216b1c96d13ead8ba5a5"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""use std::{\n    io::{self, BufRead},\n    str::FromStr,\n};\n\nstruct LineBuf(String);\n\nimpl LineBuf {\n    fn new() -> Self {\n        Self(String::new())\n    }\n\n    #[allow(dead_code)]\n    fn get(&self) -> &String {\n        &self.0\n    }\n\n    fn offer(&mut self) -> &mut String {\n        self.0.clear();\n        &mut self.0\n    }\n\n    fn parse_item<T>(s: &str) -> JoyResult<T>\n    where\n        T: FromStr,\n    {\n        s.parse().or_else(|_| Err(JoyError::ParseError))\n    }\n\n    #[allow(dead_code)]\n    fn parse<T>(&self) -> JoyResult<T>\n    where\n        T: FromStr,\n    {\n        Self::parse_item(self.0.trim())\n    }\n\n    #[allow(dead_code)]\n    fn parse2<T1, T2>(&self) -> JoyResult<(T1, T2)>\n    where\n        T1: FromStr,\n        T2: FromStr,\n    {\n        let mut it = self.0.split_whitespace();\n        let a = Self::parse_item(it.next().ok_or(JoyError::LineItemExhausted)?)?;\n        let b = Self::parse_item(it.next().ok_or(JoyError::LineItemExhausted)?)?;\n        Ok((a, b))\n    }\n\n    #[allow(dead_code)]\n    fn parse_vec<T>(&self) -> JoyResult<Vec<T>>\n    where\n        T: FromStr,\n    {\n        self.0\n            .split_whitespace()\n            .map(|s| s.parse().or(Err(JoyError::ParseError)))\n            .collect()\n    }\n}\n\n#[derive(Debug)]\nenum JoyError {\n    IOError(io::Error),\n    LineItemExhausted,\n    ParseError,\n}\n\ntype JoyResult<T> = Result<T, JoyError>;\n\nimpl std::convert::From<io::Error> for JoyError {\n    fn from(err: io::Error) -> Self {\n        JoyError::IOError(err)\n    }\n}\n\nfn main() -> JoyResult<()> {\n    let mut buf = LineBuf::new();\n    let stdin = io::stdin();\n    let mut stdin = stdin.lock();\n\n    stdin.read_line(buf.offer())?;\n    let t: usize = buf.parse()?;\n\n    for _ in 0..t {\n        stdin.read_line(buf.offer())?;\n        let (h, n): (i32, usize) = buf.parse2()?;\n\n        stdin.read_line(buf.offer())?;\n\n        let mut q: Vec<i32> = buf.parse_vec()?;\n        q.push(0);\n\n        assert_eq!(q.len(), n + 1);\n        assert_eq!(q[0], h);\n\n        // println!(\""{:?}\"", q);\n\n        let mut i = 0;\n        let mut c = 0;\n        while i < n - 1 {\n            let now = q[i + 1] + 1;\n            if q[i + 2] == now - 2 {\n                i += 2;\n            } else {\n                // println!(\""q[i] = {}\"", q[i]);\n                c += 1;\n                i += 1;\n            }\n        }\n\n        println!(\""{}\"", c);\n    }\n\n    Ok(())\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""70789e739b58d8e093081e204f804983"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\""cannot parse `{}` as a char\"", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \""cannot parse `{}` as {}\"" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \"" Converts 1-origin integer into 0-origin when read from stdin.\"" ] # [ doc = \""\"" ] # [ doc = \"" # Example\"" ] # [ doc = \""\"" ] # [ doc = \"" ```no_run\"" ] # [ doc = \"" # #[macro_use] extern crate atcoder_snippets;\"" ] # [ doc = \"" # use atcoder_snippets::read::*;\"" ] # [ doc = \"" // Stdin: \\\""1\\\""\"" ] # [ doc = \"" read!(a = usize_);\"" ] # [ doc = \"" assert_eq!(a, 0);\"" ] # [ doc = \"" ```\"" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \""line `{}` has {} words, expected {}\"",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \""line `{}` has {} words, expected multiple of {}\"" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \""word {}\"" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \""words {}-{}\"" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \""{} of line `{}`: {}\"" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \""line `{}` has {} words, expected at least {}\"" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \""\"" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \""line `{}` has {} words, expected at least {}\"" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \""\"" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 x4 , T3 x3 , T2 x2 , T1 x1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U => std :: collections :: VecDeque < U >, std :: collections :: VecDeque < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BTreeSet < U >, std :: collections :: BTreeSet < U :: Output > ) ;\nreadable_collection ! ( U : Ord => std :: collections :: BinaryHeap < U >, std :: collections :: BinaryHeap < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\""read from stdin failed\"");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \""read from stdin failed\"" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\""read from stdin failed\"");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \""expected reading {} lines, but only {} lines are read\"",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \""read from stdin failed\"" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub struct SliceGroupBy<'a, T: 'a, K: Eq, F: Fn(&T) -> K> {\n    key_fn: F,\n    rest: &'a [T],\n}\nimpl<'a, T, K: Eq, F: Fn(&T) -> K> Iterator for SliceGroupBy<'a, T, K, F> {\n    type Item = (K, &'a [T]);\n    fn next(&mut self) -> Option<(K, &'a [T])> {\n        if self.rest.is_empty() {\n            return None;\n        }\n        let key = (self.key_fn)(&self.rest[0]);\n        let mut end = 1;\n        while end < self.rest.len() && (self.key_fn)(&self.rest[end]) == key {\n            end += 1;\n        }\n        let (left, right) = self.rest.split_at(end);\n        self.rest = right;\n        Some((key, left))\n    }\n}\npub struct SplitByGap<'a, T: 'a, F: Fn(&T, &T) -> bool> {\n    gap_fn: F,\n    rest: &'a [T],\n}\nimpl<'a, T, F: Fn(&T, &T) -> bool> Iterator for SplitByGap<'a, T, F> {\n    type Item = &'a [T];\n    fn next(&mut self) -> Option<&'a [T]> {\n        if self.rest.is_empty() {\n            return None;\n        }\n        let mut r = 1;\n        while r < self.rest.len() && !(self.gap_fn)(&self.rest[r - 1], &self.rest[r]) {\n            r += 1;\n        }\n        let (result, rest) = self.rest.split_at(r);\n        self.rest = rest;\n        Some(result)\n    }\n}\npub struct Permutations<'a, T: 'a> {\n    items: &'a [T],\n    indices: Option<Vec<usize>>,\n    is_first: bool,\n}\nimpl<'a, T: 'a> Iterator for Permutations<'a, T> {\n    type Item = Vec<&'a T>;\n    fn next(&mut self) -> Option<Vec<&'a T>> {\n        if !self.is_first {\n            let indices_opt = self.indices.take();\n            if let Some(indices) = indices_opt {\n                self.indices = next_permutation(indices);\n            }\n        } else {\n            self.is_first = false;\n        }\n        self.indices\n            .as_ref()\n            .map(|indices| indices.into_iter().map(|&i| &self.items[i]).collect())\n    }\n}\nfn next_permutation(mut indices: Vec<usize>) -> Option<Vec<usize>> {\n    (0..indices.len().saturating_sub(1))\n        .rev()\n        .find(|&left| indices[left] < indices[left + 1])\n        .map(|left| {\n            let right = (0..indices.len())\n                .rev()\n                .find(|&right| indices[left] < indices[right])\n                .unwrap();\n            indices.swap(left, right);\n            indices[left + 1..].reverse();\n            indices\n        })\n}\nfn count_inversions_sub<T: Clone + Ord>(seq: &[T]) -> (Vec<T>, usize) {\n    if seq.len() <= 1 {\n        (seq.to_vec(), 0)\n    } else {\n        let mid = seq.len() / 2;\n        let (sub1, inv1) = count_inversions_sub(&seq[..mid]);\n        let (sub2, inv2) = count_inversions_sub(&seq[mid..]);\n        let mut sorted = Vec::new();\n        let (mut i1, mut i2) = (0, 0);\n        let mut inv = 0;\n        loop {\n            match (sub1.get(i1), sub2.get(i2)) {\n                (Some(x1), Some(x2)) => {\n                    if x1 <= x2 {\n                        sorted.push(x1.clone());\n                        i1 += 1;\n                    } else {\n                        inv += sub1.len() - i1;\n                        sorted.push(x2.clone());\n                        i2 += 1;\n                    }\n                }\n                (Some(_), None) => {\n                    sorted.extend(sub1[i1..].iter().cloned());\n                    break;\n                }\n                (None, Some(_)) => {\n                    sorted.extend(sub2[i2..].iter().cloned());\n                    break;\n                }\n                (None, None) => break,\n            }\n        }\n        (sorted, inv + inv1 + inv2)\n    }\n}\npub trait SliceExt<T> {\n    fn group_by<K: Eq, F: Fn(&T) -> K>(&self, key_fn: F) -> SliceGroupBy<T, K, F>;\n    fn split_by_gap<F: Fn(&T, &T) -> bool>(&self, gap_fn: F) -> SplitByGap<T, F>;\n    fn permutations(&self) -> Permutations<T>;\n    fn count_inversions(&self) -> usize\n    where\n        T: Clone + Ord;\n}\nimpl<T> SliceExt<T> for [T] {\n    fn group_by<K: Eq, F: Fn(&T) -> K>(&self, key_fn: F) -> SliceGroupBy<T, K, F> {\n        SliceGroupBy {\n            key_fn: key_fn,\n            rest: self,\n        }\n    }\n    fn split_by_gap<F: Fn(&T, &T) -> bool>(&self, gap_fn: F) -> SplitByGap<T, F> {\n        SplitByGap {\n            gap_fn: gap_fn,\n            rest: self,\n        }\n    }\n    fn permutations(&self) -> Permutations<T> {\n        let indices = if self.is_empty() {\n            None\n        } else {\n            Some((0..self.len()).collect())\n        };\n        Permutations {\n            items: self,\n            indices: indices,\n            is_first: true,\n        }\n    }\n    fn count_inversions(&self) -> usize\n    where\n        T: Clone + Ord,\n    {\n        count_inversions_sub(self).1\n    }\n}\npub trait SliceOfVecsExt<T> {\n    fn transpose_clone(&self) -> Option<Vec<Vec<T>>>\n    where\n        T: Clone;\n}\nimpl<T> SliceOfVecsExt<T> for [Vec<T>] {\n    fn transpose_clone(&self) -> Option<Vec<Vec<T>>>\n    where\n        T: Clone,\n    {\n        if self.iter().any(|row| row.is_empty()) {\n            return None;\n        }\n        if self.windows(2).any(|rows| rows[0].len() < rows[1].len()) {\n            return None;\n        }\n        let mut result = Vec::new();\n        let n = self.get(0).map_or(0, |first| first.len());\n        for i in 0..n {\n            let mut result_row = Vec::new();\n            for j in 0..self.len() {\n                if self[j].len() <= i {\n                    break;\n                }\n                result_row.push(self[j][i].clone());\n            }\n            result.push(result_row);\n        }\n        Some(result)\n    }\n}\n\nfn main() {\n    read!(query_count = usize);\n    for _ in 0..query_count {\n        read!();\n        read!(mut ps = Vec<u32>);\n        ps.reverse();\n        ps.pop();\n        let ans = ps.split_by_gap(|&a, &b| b - a > 1)\n            .filter(|s| s[0] != 1 && s.len() % 2 == 1)\n            .count();\n        println!(\""{}\"", ans);\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""5f6895157f8c0c699e27ff089d147113"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""// ---------- begin scannner ----------\n#[allow(dead_code)]\nmod scanner {\n    use std::str::FromStr;\n    use std::str::SplitWhitespace;\n    use std::io::Read;\n    use std;\n    pub struct Scanner<'a> {\n        it: SplitWhitespace<'a>\n    }\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a String) -> Scanner<'a> {\n            Scanner {\n                it: s.split_whitespace()\n            }\n        }\n        pub fn next<T: FromStr>(&mut self) -> T {\n            match self.it.next().unwrap().parse::<T>() {\n                Ok(v) => v,\n                _ => panic!(\""Scanner error\"")\n            }\n        }\n        pub fn next_chars(&mut self) -> Vec<char> {\n            self.next::<String>().chars().collect()\n        }\n    }\n    pub fn read_string() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n}\n// ---------- end scannner ----------\n\nuse std::io::Write;\n\nfn main() {\n    let sc = scanner::read_string();\n    let mut sc = scanner::Scanner::new(&sc);\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    run(&mut sc, &mut out);\n}\n\nfn run(sc: &mut scanner::Scanner, out: &mut std::io::BufWriter<std::io::StdoutLock>) {\n    let q: usize = sc.next();\n    for _ in 0..q {\n        let _h: u32 = sc.next();\n        let n: usize = sc.next();\n        let mut p: Vec<u32> = (0..n).map(|_| sc.next()).collect();\n        p.push(0);\n        p.push(0);\n        let mut ans = 0;\n        let mut i = 0;\n        while i < n {\n            p[i] = p[i + 1] + 1;\n            if i + 2 < p.len() && p[i + 2] + 1 >= p[i + 1] {\n                i += 2;\n            } else {\n                i += 1;\n                ans += 1;\n            }\n        }\n        writeln!(out, \""{}\"", ans).ok();\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""355e27b87e816fa74f612387d7eb121f"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[macro_export]\nmacro_rules ! dvec { ( $ t : expr ; $ len : expr ) => { vec ! [ $ t ; $ len ] } ; ( $ t : expr ; $ len : expr , $ ( $ rest : expr ) ,* ) => { vec ! [ dvec ! ( $ t ; $ ( $ rest ) ,* ) ; $ len ] } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \"" = {:?}, \"" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \"" = {:?}, \"" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\""solve\"".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    input!{\n        new_stdin_parser = parser,\n        q: usize\n    }\n    for _ in 0..q {\n        input!{\n            parser = parser,\n            h: usize, n: usize,\n            x: [usize; n],\n        }\n        let mut sl = skiplist::Skiplist::new();\n        for xi in x {\n            sl.insert(xi);\n        }\n        let mut n_magic = 0;\n        let mut cur = h;\n        while cur > 2 {\n            let mut it = sl.le_iter(&(cur-1));\n            if let Some(next1) = it.next() {\n                if cur-next1==1 { // fall\n                    if let Some(next2) = it.next() {\n                        if cur-next2 > 2 {\n                            n_magic += 1;\n                            let magic = cur-2;\n                            sl.remove(&cur);\n                            sl.remove(&next1);\n                            sl.insert(magic);\n                            cur = magic;\n                        }\n                        else {\n                            sl.remove(&cur);\n                            sl.remove(&next1);\n                            cur = next2;\n                        }\n                    }\n                    else {\n                        n_magic += 1;\n                        let magic = cur-2;\n                        sl.remove(&cur);\n                        sl.remove(&next1);\n                        sl.insert(magic);\n                        cur = magic;\n                    }\n                } \n                else {\n                    sl.remove(&cur);\n                    sl.insert(cur-1);\n                    cur = cur-1;\n                }\n            }\n            else {\n                sl.remove(&cur);\n                sl.insert(cur-1);\n                cur = cur-1;\n            }\n        }\n        println!(\""{}\"", n_magic);\n    }\n}\nmod skiplist {\n    use std;\n    use std::cell::{Cell, RefCell};\n    use std::collections::{BTreeMap, BTreeSet};\n    use std::fmt;\n    use std::rc::Rc;\n    struct RandGen {\n        x: u64,\n    }\n    impl RandGen {\n        fn new(seed: u64) -> RandGen {\n            RandGen { x: seed }\n        }\n        fn next(&mut self) -> u64 {\n            const a: u64 = 1103515245;\n            const b: u64 = 12345;\n            const m: u64 = 1 << 32;\n            self.x = (a * self.x + b) % m;\n            self.x\n        }\n    }\n    pub struct Skiplist<T> {\n        max_height: Option<usize>,\n        left_sentinel: Rc<RefCell<SkipNode<T>>>,\n        right_sentinel: Rc<RefCell<SkipNode<T>>>,\n        rand_gen: RandGen,\n        traverse_stat: Cell<usize>,\n        connect_stat: Cell<usize>,\n    }\n    impl Skiplist<usize> {\n        fn print_graph(&self) {\n            for level in (0..self.height()).rev() {\n                let mut line = vec![];\n                let mut cur = self.left_sentinel.clone();\n                loop {\n                    let next0 = cur.borrow().next[level].clone();\n                    let next = next0.unwrap().clone();\n                    if next.borrow().value.is_none() {\n                        break;\n                    } else {\n                        cur = next.clone();\n                        let v = cur.borrow().value.clone().unwrap();\n                        line.push(v);\n                    }\n                }\n                let mut ss = vec![];\n                for x in line {\n                    while ss.len() < x {\n                        ss.push(\""--\"".to_string());\n                    }\n                    ss.push(format!(\""{:>02}\"", x));\n                }\n                println!(\""{}\"", ss.connect(\"",\""));\n            }\n            println!(\""\"");\n        }\n    }\n    impl<T> Skiplist<T>\n    where\n        T: std::cmp::Ord + fmt::Debug + Clone,\n    {\n        pub fn new() -> Skiplist<T> {\n            let left_sentinel = Rc::new(RefCell::new(SkipNode::sentinel()));\n            let right_sentinel = Rc::new(RefCell::new(SkipNode::sentinel()));\n            let sentinel_height = left_sentinel.borrow().height();\n            for level in 0..sentinel_height {\n                left_sentinel.borrow_mut().next[level] = Some(right_sentinel.clone());\n                right_sentinel.borrow_mut().prev[level] = Some(left_sentinel.clone());\n            }\n            Skiplist {\n                max_height: None,\n                left_sentinel: left_sentinel,\n                right_sentinel: right_sentinel,\n                rand_gen: RandGen::new(0),\n                traverse_stat: Cell::new(0),\n                connect_stat: Cell::new(0),\n            }\n        }\n        fn height(&self) -> usize {\n            self.max_height.unwrap_or(33)\n        }\n        fn pick_height(&mut self) -> usize {\n            let z = self.rand_gen.next();\n            let mut k = 0;\n            let mut m = 1;\n            while z & m != 0 {\n                k += 1;\n                m <<= 1;\n            }\n            k + 1\n        }\n        pub fn insert(&mut self, x: T) -> bool {\n            let mut paths = self.traverse(&x);\n            if !paths.is_empty() {\n                let next0 = paths[0].borrow().next[0].clone();\n                let next = next0.unwrap();\n                let found = next.borrow().value.as_ref() == Some(&x);\n                if found {\n                    return false;\n                }\n            }\n            let new_height = self.pick_height();\n            self.max_height = Some(std::cmp::max(self.max_height.unwrap_or(0), new_height));\n            while paths.len() < new_height {\n                paths.push(self.left_sentinel.clone());\n            }\n            let new_node = Rc::new(RefCell::new(SkipNode::new(x, new_height)));\n            for level in 0..new_height {\n                let prev = &paths[level];\n                self.connect_stat.set(self.connect_stat.get() + 1);\n                SkipNode::connect(prev, &new_node, level);\n            }\n            true\n        }\n        fn find_node(&self, x: &T) -> Option<Rc<RefCell<SkipNode<T>>>> {\n            let paths = self.traverse(x);\n            if paths.is_empty() {\n                return None;\n            }\n            let next0 = paths[0].borrow().next[0].clone();\n            let next = next0.unwrap();\n            if next.borrow().value.as_ref() == Some(x) {\n                Some(next)\n            } else {\n                None\n            }\n        }\n        pub fn find(&self, x: &T) -> bool {\n            self.find_node(x).is_some()\n        }\n        pub fn reset_stat(&self) {\n            self.traverse_stat.set(0);\n            self.connect_stat.set(0);\n        }\n        pub fn show_stat(&self) {\n            println!(\""traverse: {}\"", self.traverse_stat.get());\n            println!(\""connect: {}\"", self.connect_stat.get());\n        }\n        fn traverse(&self, x: &T) -> Vec<Rc<RefCell<SkipNode<T>>>> {\n            if self.height() == 0 {\n                return vec![];\n            }\n            let mut cur = self.left_sentinel.clone();\n            let mut acc = vec![self.left_sentinel.clone(); self.height()];\n            let mut level = self.height() - 1;\n            loop {\n                if level == 0 {\n                    loop {\n                        acc[level] = cur.clone();\n                        let next0 = cur.borrow().next[level].clone();\n                        let next = next0.unwrap();\n                        if next.borrow().value.is_none()\n                            || next.borrow().value.as_ref().unwrap() >= x\n                        {\n                            break;\n                        } else {\n                            cur = next.clone();\n                            self.traverse_stat.set(self.traverse_stat.get() + 1);\n                        }\n                    }\n                    break;\n                }\n                let next0 = cur.borrow().next[level].clone();\n                let next = next0.unwrap();\n                if next.borrow().value.is_none() || next.borrow().value.as_ref().unwrap() >= x {\n                    acc[level] = cur.clone();\n                    level -= 1;\n                    continue;\n                } else {\n                    cur = next;\n                    self.traverse_stat.set(self.traverse_stat.get() + 1);\n                }\n            }\n            acc\n        }\n        fn traverse_rev(&self, x: &T) -> Vec<Rc<RefCell<SkipNode<T>>>> {\n            if self.height() == 0 {\n                return vec![];\n            }\n            let mut cur = self.right_sentinel.clone();\n            let mut acc = vec![self.right_sentinel.clone(); self.height()];\n            let mut level = self.height() - 1;\n            loop {\n                if level == 0 {\n                    loop {\n                        acc[level] = cur.clone();\n                        let next = cur.borrow().prev[level].clone().unwrap();\n                        if next.borrow().value.is_none()\n                            || next.borrow().value.as_ref().unwrap() <= x\n                        {\n                            break;\n                        } else {\n                            cur = next.clone();\n                        }\n                    }\n                    break;\n                }\n                let next = cur.borrow().prev[level].clone().unwrap();\n                if next.borrow().value.is_none() || next.borrow().value.as_ref().unwrap() <= x {\n                    acc[level] = cur.clone();\n                    level -= 1;\n                    continue;\n                } else {\n                    cur = next;\n                }\n            }\n            acc\n        }\n        pub fn remove(&mut self, x: &T) -> bool {\n            let node = self.find_node(x);\n            if node.is_none() {\n                return false;\n            }\n            let node = node.unwrap();\n            node.borrow_mut().remove();\n            true\n        }\n        #[doc = \""iterator in range [x,]\""]\n        pub fn ge_iter(&self, x: &T) -> Range<T> {\n            let f = self.traverse(x)[0].clone();\n            Range {\n                forward: true,\n                f: f,\n                b: self.right_sentinel.clone(),\n            }\n        }\n        #[doc = \""iterator in range [,x]\""]\n        pub fn le_iter(&self, x: &T) -> Range<T> {\n            let b = self.traverse_rev(x)[0].clone();\n            Range {\n                forward: false,\n                f: self.left_sentinel.clone(),\n                b: b,\n            }\n        }\n        #[doc = \""iterator in range [..]\""]\n        pub fn iter(&self) -> Range<T> {\n            Range {\n                forward: true,\n                f: self.left_sentinel.clone(),\n                b: self.right_sentinel.clone(),\n            }\n        }\n    }\n    pub struct Range<T> {\n        forward: bool,\n        f: Rc<RefCell<SkipNode<T>>>,\n        b: Rc<RefCell<SkipNode<T>>>,\n    }\n    impl<T: Clone> Iterator for Range<T> {\n        type Item = T;\n        fn next(&mut self) -> Option<Self::Item> {\n            let next0 = if self.forward {\n                self.f.borrow().next[0].clone()\n            } else {\n                self.b.borrow().prev[0].clone()\n            };\n            if next0.is_none() {\n                return None;\n            }\n            let next = next0.unwrap();\n            if self.forward {\n                self.f = next;\n                self.f.borrow().value.clone()\n            } else {\n                self.b = next;\n                self.b.borrow().value.clone()\n            }\n        }\n    }\n    impl<T: Clone> DoubleEndedIterator for Range<T> {\n        fn next_back(&mut self) -> Option<Self::Item> {\n            let next0 = if self.forward {\n                self.b.borrow().prev[0].clone()\n            } else {\n                self.f.borrow().next[0].clone()\n            };\n            if next0.is_none() {\n                return None;\n            }\n            let next = next0.unwrap();\n            if self.forward {\n                self.b = next;\n                self.b.borrow().value.clone()\n            } else {\n                self.f = next;\n                self.f.borrow().value.clone()\n            }\n        }\n    }\n    impl<T> fmt::Debug for Skiplist<T>\n    where\n        T: fmt::Debug + Clone + std::cmp::Ord,\n    {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            let v: Vec<T> = self.iter().collect();\n            writeln!(f, \""{:?}\"", v);\n            Ok(())\n        }\n    }\n    struct SkipNode<T> {\n        value: Option<T>,\n        prev: Vec<Option<Rc<RefCell<SkipNode<T>>>>>,\n        next: Vec<Option<Rc<RefCell<SkipNode<T>>>>>,\n    }\n    impl<T> fmt::Debug for SkipNode<T>\n    where\n        T: fmt::Debug + std::cmp::Ord,\n    {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            writeln!(f, \""{:?}, {:?}\"", self.value, self.height());\n            Ok(())\n        }\n    }\n    impl<T> SkipNode<T>\n    where\n        T: std::cmp::Ord + fmt::Debug,\n    {\n        fn sentinel() -> SkipNode<T> {\n            SkipNode {\n                value: None,\n                prev: vec![None; 33],\n                next: vec![None; 33],\n            }\n        }\n        fn new(value: T, height: usize) -> SkipNode<T> {\n            SkipNode {\n                value: Some(value),\n                prev: vec![None; height],\n                next: vec![None; height],\n            }\n        }\n        fn height(&self) -> usize {\n            self.next.len()\n        }\n        fn remove(&mut self) {\n            for level in 0..self.height() {\n                let prev_node = self.prev[level].clone().unwrap();\n                let next_node = self.next[level].clone().unwrap();\n                next_node.borrow_mut().prev[level] = Some(prev_node.clone());\n                prev_node.borrow_mut().next[level] = Some(next_node.clone());\n            }\n        }\n        fn connect(x: &Rc<RefCell<Self>>, y: &Rc<RefCell<Self>>, level: usize) {\n            let x_next = x.borrow().next[level].clone().unwrap();\n            x.borrow_mut().next[level] = Some(y.clone());\n            y.borrow_mut().prev[level] = Some(x.clone());\n            y.borrow_mut().next[level] = Some(x_next.clone());\n            x_next.borrow_mut().prev[level] = Some(y.clone());\n        }\n    }\n    #[test]\n    fn test_iter() {\n        let mut sl = Skiplist::new();\n        for i in 1..6 {\n            sl.insert(i);\n        }\n        for x in sl.iter() {\n            println!(\""{}\"", x);\n        }\n        for x in sl.ge_iter(&2) {\n            println!(\""{}\"", x);\n        }\n        for x in sl.le_iter(&2) {\n            println!(\""{}\"", x);\n        }\n    }\n    #[test]\n    fn test_pick_height() {\n        let mut sl = Skiplist::<i64>::new();\n        let mut cnt = vec![0; 60];\n        for _ in 0..1_000 {\n            cnt[sl.pick_height()] += 1;\n        }\n        println!(\""{:?}\"", cnt);\n    }\n    #[test]\n    fn test_insert() {\n        let mut s = Skiplist::new();\n        assert_eq!(s.find(&10), false);\n        s.insert(10);\n        assert_eq!(s.find(&8), false);\n        assert_eq!(s.find(&10), true);\n    }\n    #[test]\n    fn test_debug0() {\n        let mut s = Skiplist::new();\n        let mut data = vec![920, 265, 659];\n        for x in data {\n            s.insert(x);\n            assert!(s.find(&x));\n        }\n        s.insert(660);\n        dbg!(&s);\n        assert!(s.find(&660));\n    }\n    #[test]\n    fn test_debug1() {\n        let mut s = Skiplist::new();\n        s.insert(0);\n        assert!(s.find(&0));\n        s.insert(5);\n        assert!(s.find(&5));\n    }\n    #[test]\n    fn test_debug2() {\n        let mut s = Skiplist::new();\n        s.insert(0);\n        s.insert(5);\n        s.print_graph();\n        s.insert(9);\n        s.print_graph();\n        assert_eq!(s.find(&5), true);\n        s.remove(&4);\n        assert_eq!(s.find(&5), true);\n        s.remove(&5);\n        s.print_graph();\n        assert_eq!(s.find(&5), false);\n        s.remove(&9);\n        s.print_graph();\n        assert_eq!(s.find(&9), false);\n        assert_eq!(s.find(&0), true);\n    }\n    #[test]\n    fn test_compare_reference_insert_and_find() {\n        use rand::{Rng, SeedableRng, StdRng};\n        let mut rng = StdRng::from_seed(&[3, 2, 1]);\n        let mut ts = BTreeSet::new();\n        let mut sl = Skiplist::new();\n        let size = 10000;\n        let mut data1 = vec![];\n        for _ in 0..size {\n            let x = rng.next_u64() % size;\n            data1.push(x as usize);\n        }\n        let mut data2 = vec![];\n        for _ in 0..size {\n            let x = rng.next_u64() % size;\n            data2.push(x as usize);\n        }\n        let mut data3 = vec![];\n        for _ in 0..size {\n            let x = rng.next_u64() % size;\n            data3.push(x as usize);\n        }\n        println!(\""insert and find phase\"");\n        for x in data1 {\n            ts.insert(x);\n            sl.insert(x);\n            assert_eq!(sl.find(&x), ts.contains(&x));\n        }\n        sl.print_graph();\n        println!(\""find phase\"");\n        for x in data2 {\n            assert_eq!(sl.find(&x), ts.contains(&x));\n        }\n        println!(\""remove phase\"");\n        for x in data3 {\n            assert_eq!(sl.remove(&x), ts.remove(&x));\n            assert_eq!(sl.find(&x), ts.contains(&x));\n        }\n    }\n    #[test]\n    fn test_skiplist_stat() {\n        use rand::{Rng, SeedableRng, StdRng};\n        let size = 1000;\n        let mut rng = StdRng::from_seed(&[3, 2, 1]);\n        let mut s = Skiplist::new();\n        println!(\""insert\"");\n        for _ in 0..size {\n            s.insert(rng.next_u64());\n        }\n        s.show_stat();\n        s.reset_stat();\n        println!(\""connect\"");\n        for _ in 0..size {\n            s.find(&rng.next_u64());\n        }\n        s.show_stat();\n    }\n    #[bench]\n    fn bench_skiplist_insert_random(b: &mut test::Bencher) {\n        use rand::{Rng, SeedableRng, StdRng};\n        let size = 10000;\n        let mut s = Skiplist::new();\n        let mut rng = StdRng::from_seed(&[3, 2, 1]);\n        b.iter(|| {\n            for _ in 0..size {\n                s.insert(rng.next_u64());\n            }\n        });\n    }\n    #[bench]\n    fn bench_skiplist_find_random(b: &mut test::Bencher) {\n        use rand::{Rng, SeedableRng, StdRng};\n        let size = 10000;\n        let mut s = Skiplist::new();\n        let mut rng = StdRng::from_seed(&[3, 2, 1]);\n        for _ in 0..size {\n            s.insert(rng.next_u64());\n        }\n        b.iter(|| {\n            for _ in 0..size {\n                s.find(&rng.next_u64());\n            }\n        });\n    }\n    #[bench]\n    fn bench_skiplist_insert_forward(b: &mut test::Bencher) {\n        let mut s = Skiplist::new();\n        let size = 10000;\n        let mut data = vec![];\n        for i in 0..size {\n            data.push(i);\n        }\n        b.iter(|| {\n            for &x in &data {\n                s.insert(x);\n            }\n        });\n    }\n    #[bench]\n    fn bench_skiplist_insert_reverse(b: &mut test::Bencher) {\n        let mut s = Skiplist::new();\n        let size = 10000;\n        let mut data = vec![];\n        for i in 0..size {\n            data.push(i);\n        }\n        data.reverse();\n        b.iter(|| {\n            for &x in &data {\n                s.insert(x);\n            }\n        });\n    }\n    #[bench]\n    fn bench_skiplist_connect_simple(b: &mut test::Bencher) {\n        let left = Rc::new(RefCell::new(SkipNode::new(0, 2)));\n        let right = Rc::new(RefCell::new(SkipNode::new(10000000, 2)));\n        for l in 0..2 {\n            left.borrow_mut().next[l] = Some(right.clone());\n            right.borrow_mut().prev[l] = Some(left.clone());\n        }\n        let mut data = vec![];\n        for i in 0..10000 {\n            let n = Rc::new(RefCell::new(SkipNode::new(i + 1, 2)));\n            data.push(n)\n        }\n        b.iter(|| {\n            for n in &data {\n                for l in 0..2 {\n                    SkipNode::connect(&left, n, l);\n                }\n            }\n        })\n    }\n    #[bench]\n    fn bench_skiplist_connect_random(b: &mut test::Bencher) {\n        use rand::{Rng, SeedableRng, StdRng};\n        let mut rng = StdRng::from_seed(&[3, 2, 1]);\n        let left = Rc::new(RefCell::new(SkipNode::new(0, 2)));\n        let right = Rc::new(RefCell::new(SkipNode::new(10000000, 2)));\n        for l in 0..2 {\n            left.borrow_mut().next[l] = Some(right.clone());\n            right.borrow_mut().prev[l] = Some(left.clone());\n        }\n        let mut prev_cands = vec![left.clone()];\n        let mut data = vec![];\n        for i in 0..10000 {\n            let n = Rc::new(RefCell::new(SkipNode::new(i + 1, 2)));\n            let i = rng.next_u64() as usize % prev_cands.len();\n            let prev = prev_cands[i].clone();\n            data.push((prev, n.clone()));\n            prev_cands.push(n.clone());\n        }\n        b.iter(|| {\n            for (prev, n) in &data {\n                for l in 0..2 {\n                    SkipNode::connect(&prev, &n, l);\n                }\n            }\n        })\n    }\n    #[bench]\n    fn bench_skiplist_alloc_new_node(b: &mut test::Bencher) {\n        b.iter(|| {\n            for _ in 0..10000 {\n                Rc::new(RefCell::new(SkipNode::new(0, 2)));\n            }\n        })\n    }\n    #[bench]\n    fn bench_skiplist_pick_height(b: &mut test::Bencher) {\n        let mut sl = Skiplist::<i64>::new();\n        b.iter(|| {\n            for _ in 0..10000 {\n                sl.pick_height();\n            }\n        })\n    }\n    #[bench]\n    fn bench_btree_insert_random(b: &mut test::Bencher) {\n        use rand::{Rng, SeedableRng, StdRng};\n        let size = 10000;\n        let mut s = BTreeSet::new();\n        let mut rng = StdRng::from_seed(&[3, 2, 1]);\n        b.iter(|| {\n            for _ in 0..size {\n                s.insert(rng.next_u64());\n            }\n        });\n    }\n    #[bench]\n    fn bench_btree_find_random(b: &mut test::Bencher) {\n        use rand::{Rng, SeedableRng, StdRng};\n        let size = 10000;\n        let mut s = BTreeSet::new();\n        let mut rng = StdRng::from_seed(&[3, 2, 1]);\n        for _ in 0..size {\n            s.insert(rng.next_u64());\n        }\n        b.iter(|| {\n            for _ in 0..size {\n                s.contains(&rng.next_u64());\n            }\n        });\n    }\n    use std::collections::HashMap;\n    pub struct Multiset<T> {\n        sl: Skiplist<T>,\n        counting: HashMap<T, usize>,\n    }\n    impl<T> Multiset<T>\n    where\n        T: Ord + fmt::Debug + Clone + std::hash::Hash,\n    {\n        pub fn new() -> Multiset<T> {\n            Multiset {\n                sl: Skiplist::new(),\n                counting: HashMap::new(),\n            }\n        }\n        pub fn insert(&mut self, x: T) {\n            self.sl.insert(x.clone());\n            *self.counting.entry(x).or_insert(0) += 1;\n        }\n        pub fn counting(&self, x: &T) -> usize {\n            self.counting.get(x).cloned().unwrap_or(0)\n        }\n        pub fn remove(&mut self, x: &T) -> bool {\n            let cnt = self.counting(x);\n            if cnt == 0 {\n                return false;\n            }\n            if cnt >= 2 {\n                *self.counting.get_mut(x).unwrap() -= 1;\n            } else if cnt == 1 {\n                self.counting.remove(x);\n                self.sl.remove(x);\n            }\n            return true;\n        }\n        pub fn unwrap(&self) -> &Skiplist<T> {\n            &self.sl\n        }\n    }\n    #[test]\n    fn test_multiset() {\n        let mut s = Multiset::new();\n        assert_eq!(s.counting(&1), 0);\n        s.insert(1);\n        assert_eq!(s.counting(&1), 1);\n        s.insert(1);\n        assert_eq!(s.counting(&1), 2);\n        assert!(s.remove(&1));\n        assert_eq!(s.unwrap().ge_iter(&1).next().unwrap(), 1);\n        assert_eq!(s.counting(&1), 1);\n        assert!(s.remove(&1));\n        assert_eq!(s.counting(&1), 0);\n        assert_eq!(s.unwrap().ge_iter(&1).next(), None);\n    }\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""e05ec0a3265586a6789d2d46f8e0f61e"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[macro_export]\nmacro_rules ! chmax { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: max ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! chmin { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: min ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! max { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: max ( $ x , max ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! min { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: min ( $ x , min ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! dvec { ( $ t : expr ; $ len : expr ) => { vec ! [ $ t ; $ len ] } ; ( $ t : expr ; $ len : expr , $ ( $ rest : expr ) ,* ) => { vec ! [ dvec ! ( $ t ; $ ( $ rest ) ,* ) ; $ len ] } ; }\n#[doc = \"" main\""]\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \"" = {:?}, \"" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\""solve\"".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    input!{\n        new_stdin_parser = parser,\n        q:usize,\n    }\n    for _ in 0..q {\n        input!{\n            parser = parser,\n            h:usize,n:usize,\n            p:[usize;n],\n        }\n        let mut state = vec![false; h+1];\n        for pi in p {\n            state[pi] = true;\n        }\n        let mut magic = 0;\n        let mut cur = h;\n        while cur > 2 {\n            assert!(state[cur]);\n\n            let jump1 = cur-1;\n            let jump2 = cur-2;\n            // 2jump case\n            if state[jump1] && state[jump2] {\n                cur = jump2;\n            }\n            else if !state[jump1] {\n                state[jump1] = true;\n                cur = jump1;\n            }\n            else {\n                magic += 1;\n                state[jump2] = true;\n                cur = jump2;\n            }\n        }\n        println!(\""{}\"",magic);\n    }\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""b3249dddb57f553525d6b858ab92ce28"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[macro_export]\nmacro_rules ! chmax { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: max ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! chmin { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: min ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! max { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: max ( $ x , max ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! min { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: min ( $ x , min ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! dvec { ( $ t : expr ; $ len : expr ) => { vec ! [ $ t ; $ len ] } ; ( $ t : expr ; $ len : expr , $ ( $ rest : expr ) ,* ) => { vec ! [ dvec ! ( $ t ; $ ( $ rest ) ,* ) ; $ len ] } ; }\n#[doc = \"" main\""]\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \"" = {:?}, \"" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\""solve\"".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    input!{\n        new_stdin_parser = parser,\n        q:usize,\n    }\n    for _ in 0..q {\n        input!{\n            parser = parser,\n            h:usize,n:usize,\n            p:[usize;n],\n        }\n        let mut state = HashSet::new();\n        for pi in p {\n            state.insert(pi);\n        }\n        let mut magic = 0;\n        let mut cur = h;\n        while cur > 2 {\n            assert!(state.contains(&cur));\n\n            let jump1 = cur-1;\n            let jump2 = cur-2;\n            // 2jump case\n            if state.contains(&jump1) && state.contains(&jump2) {\n                state.remove(&cur);\n                state.remove(&jump1);\n                cur = jump2;\n            }\n            else if !state.contains(&jump1) {\n                state.remove(&cur);\n                state.insert(jump1);\n                cur = jump1;\n            }\n            else {\n                magic += 1;\n                state.remove(&cur);\n                state.remove(&jump1);\n                state.insert(jump2); // magic\n                cur = jump2;\n            }\n        }\n        writeln!(out,\""{}\"",magic);\n    }\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""50f2554e9f0a95b376b645f7649cb31a"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[macro_export]\nmacro_rules ! chmax { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: max ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! chmin { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: min ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! max { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: max ( $ x , max ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! min { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: min ( $ x , min ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! dvec { ( $ t : expr ; $ len : expr ) => { vec ! [ $ t ; $ len ] } ; ( $ t : expr ; $ len : expr , $ ( $ rest : expr ) ,* ) => { vec ! [ dvec ! ( $ t ; $ ( $ rest ) ,* ) ; $ len ] } ; }\n#[doc = \"" main\""]\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \"" = {:?}, \"" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\""solve\"".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    input!{\n        new_stdin_parser = parser,\n        q:usize,\n    }\n    for _ in 0..q {\n        input!{\n            parser = parser,\n            h:usize,n:usize,\n            p:[usize;n],\n        }\n        let mut state = vec![false; h+1];\n        for pi in p {\n            state[pi] = true;\n        }\n        let mut magic = 0;\n        let mut cur = h;\n        while cur > 2 {\n            assert!(state[cur]);\n\n            let jump1 = cur-1;\n            let jump2 = cur-2;\n            // 2jump case\n            if state[jump1] && state[jump2] {\n                cur = jump2;\n            }\n            else if !state[jump1] {\n                state[jump1] = true;\n                cur = jump1;\n            }\n            else {\n                magic += 1;\n                state[jump2] = true;\n                cur = jump2;\n            }\n        }\n        writeln!(out,\""{}\"",magic);\n    }\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""19419ef1b8b2bad1daa96817856656ea"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[macro_export]\nmacro_rules ! chmax { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: max ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! chmin { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: min ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! max { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: max ( $ x , max ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! min { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: min ( $ x , min ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! dvec { ( $ t : expr ; $ len : expr ) => { vec ! [ $ t ; $ len ] } ; ( $ t : expr ; $ len : expr , $ ( $ rest : expr ) ,* ) => { vec ! [ dvec ! ( $ t ; $ ( $ rest ) ,* ) ; $ len ] } ; }\n#[doc = \"" main\""]\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \"" = {:?}, \"" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \"" https://github.com/hatoo/competitive-rust-snippets\""]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\""solve\"".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    input!{\n        new_stdin_parser = parser,\n        q:usize,\n    }\n    for _ in 0..q {\n        input!{\n            parser = parser,\n            h:usize,n:usize,\n            P:[usize;n],\n        }\n        let mut P = P;\n        P.push(0);\n        let mut state = HashSet::new();\n        for &Pi in &P {\n            state.insert(Pi);\n        }\n        let mut magic = 0;\n        let mut cur = h;\n        while cur > 2 {\n            assert!(state.contains(&cur));\n\n            let jump1 = cur-1;\n            let jump2 = cur-2;\n            // 2jump case\n            if state.contains(&jump1) && state.contains(&jump2) {\n                state.remove(&cur);\n                state.remove(&jump1);\n                cur = jump2;\n            }\n            else if !state.contains(&jump1) {\n                let bs = BinarySearch {\n                    lower: 0,\n                    upper: (n-1) as i64,\n                    p: |i:i64| {\n                        let i = i as usize;\n                        P[i] < cur\n                    },\n                };\n                let r = bs.lower_bound() as usize;\n                state.remove(&cur);\n                cur = P[r] + 1;\n                state.insert(cur);\n            }\n            else {\n                magic += 1;\n                state.remove(&cur);\n                state.remove(&jump1);\n                state.insert(jump2); // magic\n                cur = jump2;\n            }\n            // dbg!(cur);\n        }\n        // println!(\""{}\"",magic);\n        writeln!(out,\""{}\"",magic);\n    }\n}\n\n#[doc = \""lower,upper are inclusive range\""]\npub struct BinarySearch<F> {\n    pub p: F,\n    pub lower: i64,\n    pub upper: i64,\n}\nimpl<F: Fn(i64) -> bool> BinarySearch<F> {\n    #[doc = \""O(log(upper-lower))\""]\n    pub fn lower_bound(&self) -> i64 {\n        let lower = self.lower;\n        let upper = self.upper;\n        assert!(lower <= upper);\n        let mut lb = lower - 1;\n        let mut ub = upper + 1;\n        while ub - lb > 1 {\n            let mid = (lb + ub) / 2;\n            if (self.p)(mid) {\n                ub = mid;\n            } else {\n                lb = mid;\n            }\n        }\n        let latter = ub;\n        latter\n    }\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""3d16e1247c3d3b72aaa241055c123a56"", ""src_uid"": ""d0c50562764f2008045fe57e5da5de1c"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""mod union_find {\n    pub struct UF {\n        p: Vec<i32>,\n    }\n    #[allow(dead_code)]\n    impl UF {\n        pub fn new(n: usize) -> UF {\n            UF {p: vec![-1; n] }\n        }\n        pub fn root(&mut self, mut x: usize) -> usize {\n            while self.p[x] >= 0 {\n                x = self.p[x] as usize;\n            }\n            x\n        }\n        pub fn same(&mut self, x: usize, y: usize) -> bool {\n            self.root(x) == self.root(y)\n        }\n        pub fn unite(&mut self, mut x: usize, mut y: usize) {\n            x = self.root(x);\n            y = self.root(y);\n            if x == y {\n                return;\n            }\n            if self.p[x] > self.p[y] {\n                std::mem::swap(&mut x, &mut y);\n            }\n            self.p[x] += self.p[y];\n            self.p[y] = x as i32;\n        }\n        pub fn get_size(&mut self, x: usize) -> usize {\n            let r = self.root(x);\n            (-self.p[r]) as usize\n        }\n    }\n}\n//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n// \u3053\u3053\u307e\u3067\n\nfn run() {\n    input! {\n        n: usize,\n        m: usize,\n        a: [u64; n],\n        e: [(usize, usize, u64); m],\n    }\n    let mut k = 0;\n    let mut a: Vec<(u64, usize)> = a.into_iter().map(|x| {k += 1; (x, k)}).collect();\n    a.sort();\n    let mut e: Vec<(u64, usize, usize)> = e.into_iter().map(|(a, b, w)| (w, a, b)).collect();\n    let (c, x) = a[0];\n    for &(w, v) in a[1..].iter() {\n        e.push((c + w, x, v));\n    }\n    e.sort();\n    let mut u = union_find::UF::new(n + 1);\n    let mut cost = 0;\n    for (c, a, b) in e {\n        if !u.same(a, b) {\n            u.unite(a, b);\n            cost += c;\n        }\n    }\n    println!(\""{}\"", cost);\n}\n\nfn main() {\n    run();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""f9842aa8632955e94473a732792a682b"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        m: usize,\n        a: [i64; n],\n        xyw: [(usize1, usize1, i64); m],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (x, y, w) in xyw {\n        g[x].push((y, w));\n        g[y].push((x, w));\n    }\n    let mut amin = (1 << 50, n);\n    for i in 0 .. n { amin = min(amin, (a[i], i)); }\n    // Prim\n    let mut tot = 0;\n    let (added, init) = amin;\n    let mut used = vec![false; n];\n    used[init] = true;\n    let mut que = BinaryHeap::new();\n    for i in 0 .. n {\n        if init != i {\n            que.push(Reverse((a[i] + added, i)));\n        }\n    }\n    for &(w, cost) in g[init].iter() {\n        que.push(Reverse((cost, w)));\n    }\n    while let Some(Reverse((cost, v))) = que.pop() {\n        if used[v] { continue; }\n        tot += cost;\n        used[v] = true;\n        for &(w, cost) in g[v].iter() {\n            que.push(Reverse((cost, w)));\n        }\n    }\n    puts!(\""{}\\n\"", tot)\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""b16b7d0fe6e78d2642950b033861c461"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#[allow(unused_imports)]\nuse std::cmp::{min,max};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap,BTreeSet};\n#[allow(unused_imports)]\nuse std::ops::*;\n#[allow(unused_imports)]\nuse std::collections::BinaryHeap;\n\n#[allow(unused_macros)]\nmacro_rules! ite {\n    ($c:expr, $t:expr, $f:expr) => {{\n        if $c { $t } else { $f }\n    }};\n}\n\n// ref: tanakh <https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8>\n// diff: using Parser\n#[macro_export]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut parser = Parser::from_str($s);\n        input_inner!{parser, $($r)*}\n    };\n    (parser = $parser:ident, $($r:tt)*) => {\n        input_inner!{$parser, $($r)*}\n    };\n    (new_stdin_parser = $parser:ident, $($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let reader = std::io::BufReader::new(stdin.lock());\n        let mut $parser = Parser::new(reader);\n        input_inner!{$parser, $($r)*}\n    };\n    ($($r:tt)*) => {\n        input!{new_stdin_parser = parser, $($r)*}\n    };\n}\n\n#[macro_export]\nmacro_rules! input_inner {\n    ($parser:ident) => {};\n    ($parser:ident, ) => {};\n    ($parser:ident, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($parser, $t);\n        input_inner!{$parser $($r)*}\n    };\n}\n\n#[macro_export]\nmacro_rules! read_value {\n    ($parser:ident, ( $($t:tt),* )) => {\n        ( $(read_value!($parser, $t)),* )\n    };\n    ($parser:ident, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($parser, $t)).collect::<Vec<_>>()\n    };\n    ($parser:ident, chars) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, usize1) => {\n        read_value!($parser, usize) - 1\n    };\n    ($parser:ident, $t:ty) => {\n        $parser.next::<$t>().expect(\""Parse error\"")\n    };\n}\n\nfn main() {\n    input! {\n        n: usize,\n        m: usize,\n        xs: [i64; n],\n        es: [(usize1, usize1, i64); m]\n    }\n    let mut offers = vec![BinaryHeap::new(); n];\n    for &(x,y,w) in &es {\n        offers[x].push((-w,y));\n        offers[y].push((-w,x));\n    }\n    let mut used = vec![false; n];\n\n    let first = 0;\n\n    used[first] = true;\n    let mut used_count = 1;\n    let mut unused_heap = BinaryHeap::new();\n    for i in 0..n {\n        unused_heap.push((-xs[i], i));\n    }\n\n    let mut left_offers = BinaryHeap::new();\n    let mut left_min = xs[first];\n    left_offers.append(&mut offers[first]);\n\n    let mut res = 0;\n    while used_count < n {\n        while let Some((nw, next)) = left_offers.pop() {\n            if ! used[next] {\n                left_offers.push((nw, next));\n                break;\n            }\n        }\n        while let Some((nw, v)) = unused_heap.pop() {\n            if ! used[v] {\n                unused_heap.push((nw, v));\n                break;\n            }\n        }\n        let mut min_next = None;\n        let mut min_cost = None;\n        if let Some(&(nw, next)) = left_offers.peek() {\n            let t = -nw;\n            if min_cost.is_none() || min_cost.unwrap() > t {\n                min_cost = Some(t);\n                min_next = Some(next);\n            }\n        }\n        if let Some(&(nw, next)) = unused_heap.peek() {\n            let t = left_min + -nw;\n            if min_cost.is_none() || min_cost.unwrap() > t {\n                min_cost = Some(t);\n                min_next = Some(next);\n            }\n        }\n\n        left_offers.append(&mut offers[min_next.unwrap()]);\n        left_min = min(left_min, xs[min_next.unwrap()]);\n        res += min_cost.unwrap();\n        used[min_next.unwrap()] = true;\n\n        used_count += 1;\n    }\n    println!(\""{}\"", res);\n}\n\nuse std::io::BufRead;\nuse std::io;\nuse std::str;\n\n// ref: tatsuya6502 <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e>\n// ref: wariuni <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e#comment-7040a5ae96305e884eb9>\n// diff: using std::io::BufRead::fill_buf()\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\n\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\n\nimpl<R:BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len,complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                (len, buf2[len-1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T:str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            }\n            else {\n                self.update_buf();\n            }\n        }\n    }\n}\n\nuse std::fmt::Display;\n#[allow(dead_code)]\nfn write_vec<T: Display>(xs: &Vec<T>) {\n    if xs.len() == 0 {\n        println!();\n        return;\n    }\n    print!(\""{}\"", xs[0]);\n    for i in 1..xs.len() {\n        print!(\"" {}\"", xs[i]);\n    }\n    println!();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""fdbf3a62685242bd099d947dddc8cddf"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_variables)]\n#![allow(unused_must_use)]\n#![allow(unused_imports)]\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::io::{self, prelude::*};\nuse std::cmp::{min,max};\nuse std::cmp::Reverse;\n\n\n\n\nfn collapse(x: &usize, uf: &mut Vec<usize>) {\n    let mut xs = vec![];\n    let mut y = *x;\n\n    while uf[y] != y {\n       xs.push(y);\n       y = uf[y];\n    }\n\n    for i in 0..xs.len() {\n        uf[xs[i]] = y;\n    }\n}\n\nfn solve<R: BufRead, W: Write>(mut input: FastInput<R>, mut w: W) {\n    let n: usize = input.token();\n    let m: usize = input.token();\n\n    let mut vs = vec![];\n    let mut uf = vec![];\n    let mut components = n;\n\n    for i in 0..n {\n        let ai: i64 = input.token();\n        vs.push((ai, i));\n        uf.push(i);\n    }\n\n    vs.sort();\n\n\n    let mut es = vec![];\n\n    for i in 0..m {\n        let a: usize = input.token();\n        let b: usize = input.token();\n        let w: i64 = input.token();\n        es.push((w, a - 1, b - 1));\n    }\n\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..es.len() {\n        heap.push(Reverse((es[i].0, es[i].1, es[i].2)));\n    }\n\n    for i in 1..n {\n        heap.push(Reverse((vs[0].0 + vs[i].0, vs[i].1, vs[0].1)));\n    }\n\n    let mut total_cost: i64 = 0;\n\n    while let Some(Reverse((v, x, y))) = heap.pop() {\n        // println!(\""Processing {}-{} ({})\"", x, y, v);\n        collapse(&x, &mut uf);\n        collapse(&y, &mut uf);\n        if uf[y] == uf[x] {\n            // println!(\""skip\"");\n            continue;\n        }\n        /*\n        for i in 0..n {\n            print!(\""({} -> {})\"", i, uf[i]);\n        }\n        println!(\""\"");\n        */\n        let z = uf[y];\n        uf[z] = uf[x];\n        uf[z] = uf[x];\n        components -= 1;\n        total_cost += v as i64;\n        \n        if components == 1 {\n            break;\n        }\n    }\n\n    write!(w, \""{}\\n\"", total_cost);\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let input = FastInput::from(stdin.lock());\n    let writer = io::BufWriter::new(stdout.lock());\n    solve(input, writer);\n}\n\ntrait TokenStream<T> {\n    fn token(&mut self) -> T;\n}\n\nstruct FastInput<R> {\n    stdin: R,\n    pos: usize,\n}\n\nimpl<R: BufRead> From<R> for FastInput<R> {\n    fn from(r: R) -> Self {\n        FastInput { stdin: r, pos: 0 }\n    }\n}\n\nimpl<R: BufRead> TokenStream<u8> for FastInput<R> {\n    fn token(&mut self) -> u8 {\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                while self.pos < buf.len() {\n                    self.pos += 1;\n                    if buf[self.pos - 1] > 32 {\n                        return buf[self.pos - 1];\n                    }\n                }\n                if self.pos == 0 {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nimpl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {\n    fn token(&mut self) -> Vec<u8> {\n        let mut ans = Vec::new();\n        let mut parse_token = false;\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                if !parse_token {\n                    while self.pos < buf.len() && buf[self.pos] <= 32 {\n                        self.pos += 1;\n                    }\n                }\n                while self.pos < buf.len() && buf[self.pos] > 32 {\n                    parse_token = true;\n                    ans.push(buf[self.pos]);\n                    self.pos += 1;\n                }\n                if self.pos != buf.len() || self.pos == 0 {\n                    return ans;\n                }\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nmacro_rules! impl_token_stream {\n    ($($t:ident),+) => {$(\n        impl<R: BufRead> TokenStream<$t> for FastInput<R> {\n           fn token(&mut self) -> $t {\n                let mut ans = 0;\n                let mut parse_token = false;\n                loop {\n                    if let Ok(buf) = self.stdin.fill_buf() {\n                        if !parse_token {\n                            while self.pos < buf.len() && buf[self.pos] <= 32 {\n                                self.pos += 1;\n                            }\n                        }\n                        while self.pos < buf.len() && buf[self.pos] > 32 {\n                            parse_token = true;\n                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;\n                            self.pos += 1;\n                        }\n                        if self.pos != buf.len() || self.pos == 0 {\n                            return ans;\n                        }\n                    }\n                    self.stdin.consume(self.pos);\n                    self.pos = 0;\n                }\n           }\n        }\n    )+}\n}\n\nimpl_token_stream!(usize);\nimpl_token_stream!(i64);\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""b9c5cbd0fe408301cbd316e9aacf92aa"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_variables)]\n#![allow(unused_must_use)]\n#![allow(unused_imports)]\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::io::{self, prelude::*};\nuse std::cmp::{min,max};\nuse std::cmp::Reverse;\n\n\n\n#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]\nenum Edge {\n    Normal,\n    Offer,\n} \n\nfn collapse(x: &usize, uf: &mut Vec<usize>) {\n    let mut xs = vec![];\n    let mut y = *x;\n\n    while uf[y] != y {\n       xs.push(y);\n       y = uf[y];\n    }\n\n    for i in 0..xs.len() {\n        uf[xs[i]] = y;\n    }\n}\n\nfn solve<R: BufRead, W: Write>(mut input: FastInput<R>, mut w: W) {\n    let n: usize = input.token();\n    let m: usize = input.token();\n\n    let mut vs = vec![];\n    let mut uf = vec![];\n    let mut indexes = HashMap::new();\n    let mut components = n;\n\n    for i in 0..n {\n        let ai: usize = input.token();\n        vs.push((ai, i));\n        uf.push(i);\n    }\n\n    vs.sort();\n\n    for i in 0..n {\n        indexes.insert(vs[i].1, i);\n    }\n\n    let mut es = vec![];\n\n    for i in 0..m {\n        let a: usize = input.token();\n        let b: usize = input.token();\n        let w: usize = input.token();\n        if vs[indexes[&(a - 1)]].0 + vs[indexes[&(b - 1)]].0 > w {\n            es.push((w, a - 1, b - 1));\n        }\n    }\n\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..es.len() {\n        heap.push(Reverse((es[i].0, es[i].1, es[i].2, Edge::Offer)));\n    }\n\n    for i in 1..n {\n        heap.push(Reverse((vs[0].0 + vs[i].0, vs[i].1, vs[0].1, Edge::Normal)));\n    }\n\n    let mut total_cost = 0;\n\n    while let Some(Reverse((v, x, y, t))) = heap.pop() {\n        // println!(\""Processing {}-{} ({}, {:?})\"", x, y, v, t);\n        collapse(&x, &mut uf);\n        collapse(&y, &mut uf);\n        if uf[y] == uf[x] {\n            // println!(\""skip\"");\n            continue;\n        }\n        /*\n        for i in 0..n {\n            print!(\""({} -> {})\"", i, uf[i]);\n        }\n        println!(\""\"");\n        */\n        let z = uf[y];\n        uf[z] = uf[x];\n        components -= 1;\n        total_cost += v;\n        \n        if components == 1 {\n            break;\n        }\n\n        if t == Edge::Normal {\n            let mut new_y = vs[indexes[&y] + 1].1;\n            if new_y == x {\n                new_y = vs[indexes[&y] + 2].1;\n            }\n            let new_v = vs[indexes[&new_y]].0 + vs[indexes[&x]].0;\n            // println!(\""Add {}-{}, {}\"", x,y,v);\n            heap.push(Reverse((new_v, x, new_y, Edge::Normal)));\n        }\n    }\n\n    write!(w, \""{}\\n\"", total_cost);\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let input = FastInput::from(stdin.lock());\n    let writer = io::BufWriter::new(stdout.lock());\n    solve(input, writer);\n}\n\ntrait TokenStream<T> {\n    fn token(&mut self) -> T;\n}\n\nstruct FastInput<R> {\n    stdin: R,\n    pos: usize,\n}\n\nimpl<R: BufRead> From<R> for FastInput<R> {\n    fn from(r: R) -> Self {\n        FastInput { stdin: r, pos: 0 }\n    }\n}\n\nimpl<R: BufRead> TokenStream<u8> for FastInput<R> {\n    fn token(&mut self) -> u8 {\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                while self.pos < buf.len() {\n                    self.pos += 1;\n                    if buf[self.pos - 1] > 32 {\n                        return buf[self.pos - 1];\n                    }\n                }\n                if self.pos == 0 {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nimpl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {\n    fn token(&mut self) -> Vec<u8> {\n        let mut ans = Vec::new();\n        let mut parse_token = false;\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                if !parse_token {\n                    while self.pos < buf.len() && buf[self.pos] <= 32 {\n                        self.pos += 1;\n                    }\n                }\n                while self.pos < buf.len() && buf[self.pos] > 32 {\n                    parse_token = true;\n                    ans.push(buf[self.pos]);\n                    self.pos += 1;\n                }\n                if self.pos != buf.len() || self.pos == 0 {\n                    return ans;\n                }\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nmacro_rules! impl_token_stream {\n    ($($t:ident),+) => {$(\n        impl<R: BufRead> TokenStream<$t> for FastInput<R> {\n           fn token(&mut self) -> $t {\n                let mut ans = 0;\n                let mut parse_token = false;\n                loop {\n                    if let Ok(buf) = self.stdin.fill_buf() {\n                        if !parse_token {\n                            while self.pos < buf.len() && buf[self.pos] <= 32 {\n                                self.pos += 1;\n                            }\n                        }\n                        while self.pos < buf.len() && buf[self.pos] > 32 {\n                            parse_token = true;\n                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;\n                            self.pos += 1;\n                        }\n                        if self.pos != buf.len() || self.pos == 0 {\n                            return ans;\n                        }\n                    }\n                    self.stdin.consume(self.pos);\n                    self.pos = 0;\n                }\n           }\n        }\n    )+}\n}\n\nimpl_token_stream!(usize);\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""debfc82b21595e9df45a98e9516ab86f"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_variables)]\n#![allow(unused_must_use)]\n#![allow(unused_imports)]\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::io::{self, prelude::*};\nuse std::cmp::{min,max};\nuse std::cmp::Reverse;\n\n\n\n#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]\nenum Edge {\n    Normal,\n    Offer,\n} \n\nfn collapse(x: &usize, uf: &mut Vec<usize>) {\n    let mut xs = vec![];\n    let mut y = *x;\n\n    while uf[y] != y {\n       xs.push(y);\n       y = uf[y];\n    }\n\n    for i in 0..xs.len() {\n        uf[xs[i]] = y;\n    }\n}\n\nfn solve<R: BufRead, W: Write>(mut input: FastInput<R>, mut w: W) {\n    let n: usize = input.token();\n    let m: usize = input.token();\n\n    let mut vs = vec![];\n    let mut uf = vec![];\n    let mut indexes = HashMap::new();\n    let mut components = n;\n\n    for i in 0..n {\n        let ai: usize = input.token();\n        vs.push((ai, i));\n        uf.push(i);\n    }\n\n    vs.sort();\n\n    for i in 0..n {\n        indexes.insert(vs[i].1, i);\n    }\n\n    let mut es = vec![];\n\n    for i in 0..m {\n        let a: usize = input.token();\n        let b: usize = input.token();\n        let w: usize = input.token();\n        if vs[indexes[&(a - 1)]].0 + vs[indexes[&(b - 1)]].0 > w {\n            es.push((w, a - 1, b - 1));\n        }\n    }\n\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..es.len() {\n        heap.push(Reverse((es[i].0, es[i].1, es[i].2, Edge::Offer)));\n    }\n\n    for i in 1..n {\n        heap.push(Reverse((vs[0].0 + vs[i].0, vs[i].1, vs[0].1, Edge::Normal)));\n    }\n\n    let mut total_cost = 0;\n\n    while let Some(Reverse((v, x, y, t))) = heap.pop() {\n        // println!(\""Processing {}-{} ({}, {:?})\"", x, y, v, t);\n        collapse(&x, &mut uf);\n        collapse(&y, &mut uf);\n        if uf[y] == uf[x] {\n            // println!(\""skip\"");\n            continue;\n        }\n        /*\n        for i in 0..n {\n            print!(\""({} -> {})\"", i, uf[i]);\n        }\n        println!(\""\"");\n        */\n        let z = uf[y];\n        uf[z] = uf[x];\n        components -= 1;\n        total_cost += v;\n        \n        if components == 1 {\n            break;\n        }\n\n        if t == Edge::Normal {\n            let mut new_y = vs[indexes[&y] + 1].1;\n            if new_y == x {\n                new_y += 1;\n            }\n            let new_v = vs[indexes[&new_y]].0 + vs[indexes[&x]].0;\n            heap.push(Reverse((new_v, x, new_y, Edge::Normal)));\n        }\n    }\n\n    write!(w, \""{}\\n\"", total_cost);\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let input = FastInput::from(stdin.lock());\n    let writer = io::BufWriter::new(stdout.lock());\n    solve(input, writer);\n}\n\ntrait TokenStream<T> {\n    fn token(&mut self) -> T;\n}\n\nstruct FastInput<R> {\n    stdin: R,\n    pos: usize,\n}\n\nimpl<R: BufRead> From<R> for FastInput<R> {\n    fn from(r: R) -> Self {\n        FastInput { stdin: r, pos: 0 }\n    }\n}\n\nimpl<R: BufRead> TokenStream<u8> for FastInput<R> {\n    fn token(&mut self) -> u8 {\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                while self.pos < buf.len() {\n                    self.pos += 1;\n                    if buf[self.pos - 1] > 32 {\n                        return buf[self.pos - 1];\n                    }\n                }\n                if self.pos == 0 {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nimpl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {\n    fn token(&mut self) -> Vec<u8> {\n        let mut ans = Vec::new();\n        let mut parse_token = false;\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                if !parse_token {\n                    while self.pos < buf.len() && buf[self.pos] <= 32 {\n                        self.pos += 1;\n                    }\n                }\n                while self.pos < buf.len() && buf[self.pos] > 32 {\n                    parse_token = true;\n                    ans.push(buf[self.pos]);\n                    self.pos += 1;\n                }\n                if self.pos != buf.len() || self.pos == 0 {\n                    return ans;\n                }\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nmacro_rules! impl_token_stream {\n    ($($t:ident),+) => {$(\n        impl<R: BufRead> TokenStream<$t> for FastInput<R> {\n           fn token(&mut self) -> $t {\n                let mut ans = 0;\n                let mut parse_token = false;\n                loop {\n                    if let Ok(buf) = self.stdin.fill_buf() {\n                        if !parse_token {\n                            while self.pos < buf.len() && buf[self.pos] <= 32 {\n                                self.pos += 1;\n                            }\n                        }\n                        while self.pos < buf.len() && buf[self.pos] > 32 {\n                            parse_token = true;\n                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;\n                            self.pos += 1;\n                        }\n                        if self.pos != buf.len() || self.pos == 0 {\n                            return ans;\n                        }\n                    }\n                    self.stdin.consume(self.pos);\n                    self.pos = 0;\n                }\n           }\n        }\n    )+}\n}\n\nimpl_token_stream!(usize);\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""7436893ea0f98234e2478703c923ad36"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_variables)]\n#![allow(unused_must_use)]\n#![allow(unused_imports)]\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::io::{self, prelude::*};\nuse std::cmp::{min,max};\nuse std::cmp::Reverse;\n\n\n\n\nfn collapse(x: &usize, uf: &mut Vec<usize>) {\n    let mut xs = vec![];\n    let mut y = *x;\n\n    while uf[y] != y {\n       xs.push(y);\n       y = uf[y];\n    }\n\n    for i in 0..xs.len() {\n        uf[xs[i]] = y;\n    }\n}\n\nfn solve<R: BufRead, W: Write>(mut input: FastInput<R>, mut w: W) {\n    let n: usize = input.token();\n    let m: usize = input.token();\n\n    let mut vs = vec![];\n    let mut uf = vec![];\n    let mut components = n;\n\n    for i in 0..n {\n        let ai: usize = input.token();\n        vs.push((ai, i));\n        uf.push(i);\n    }\n\n    vs.sort();\n\n    let mut es = vec![];\n\n    for i in 0..m {\n        let a: usize = input.token();\n        let b: usize = input.token();\n        let w: usize = input.token();\n    }\n\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..es.len() {\n        heap.push(Reverse((es[i].0, es[i].1, es[i].2)));\n    }\n\n    for i in 1..n {\n        heap.push(Reverse((vs[0].0 + vs[i].0, vs[i].1, vs[0].1)));\n    }\n\n    let mut total_cost = 0;\n\n    while let Some(Reverse((v, x, y))) = heap.pop() {\n        // println!(\""Processing {}-{} ({})\"", x, y, v);\n        collapse(&x, &mut uf);\n        collapse(&y, &mut uf);\n        if uf[y] == uf[x] {\n            // println!(\""skip\"");\n            continue;\n        }\n        /*\n        for i in 0..n {\n            print!(\""({} -> {})\"", i, uf[i]);\n        }\n        println!(\""\"");\n        */\n        let z = uf[y];\n        uf[z] = uf[x];\n        uf[y] = uf[x];\n        components -= 1;\n        total_cost += v;\n        \n        if components == 1 {\n            break;\n        }\n    }\n\n    write!(w, \""{}\\n\"", total_cost);\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let input = FastInput::from(stdin.lock());\n    let writer = io::BufWriter::new(stdout.lock());\n    solve(input, writer);\n}\n\ntrait TokenStream<T> {\n    fn token(&mut self) -> T;\n}\n\nstruct FastInput<R> {\n    stdin: R,\n    pos: usize,\n}\n\nimpl<R: BufRead> From<R> for FastInput<R> {\n    fn from(r: R) -> Self {\n        FastInput { stdin: r, pos: 0 }\n    }\n}\n\nimpl<R: BufRead> TokenStream<u8> for FastInput<R> {\n    fn token(&mut self) -> u8 {\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                while self.pos < buf.len() {\n                    self.pos += 1;\n                    if buf[self.pos - 1] > 32 {\n                        return buf[self.pos - 1];\n                    }\n                }\n                if self.pos == 0 {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nimpl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {\n    fn token(&mut self) -> Vec<u8> {\n        let mut ans = Vec::new();\n        let mut parse_token = false;\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                if !parse_token {\n                    while self.pos < buf.len() && buf[self.pos] <= 32 {\n                        self.pos += 1;\n                    }\n                }\n                while self.pos < buf.len() && buf[self.pos] > 32 {\n                    parse_token = true;\n                    ans.push(buf[self.pos]);\n                    self.pos += 1;\n                }\n                if self.pos != buf.len() || self.pos == 0 {\n                    return ans;\n                }\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nmacro_rules! impl_token_stream {\n    ($($t:ident),+) => {$(\n        impl<R: BufRead> TokenStream<$t> for FastInput<R> {\n           fn token(&mut self) -> $t {\n                let mut ans = 0;\n                let mut parse_token = false;\n                loop {\n                    if let Ok(buf) = self.stdin.fill_buf() {\n                        if !parse_token {\n                            while self.pos < buf.len() && buf[self.pos] <= 32 {\n                                self.pos += 1;\n                            }\n                        }\n                        while self.pos < buf.len() && buf[self.pos] > 32 {\n                            parse_token = true;\n                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;\n                            self.pos += 1;\n                        }\n                        if self.pos != buf.len() || self.pos == 0 {\n                            return ans;\n                        }\n                    }\n                    self.stdin.consume(self.pos);\n                    self.pos = 0;\n                }\n           }\n        }\n    )+}\n}\n\nimpl_token_stream!(usize);\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": true, ""code_uid"": ""774ae6f349debd587b6ab33372181ab6"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_variables)]\n#![allow(unused_must_use)]\n#![allow(unused_imports)]\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::io::{self, prelude::*};\nuse std::cmp::{min,max};\nuse std::cmp::Reverse;\n\n\n\n#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]\nenum Edge {\n    Normal,\n    Offer,\n} \n\nfn collapse(x: &usize, uf: &mut Vec<usize>) {\n    let mut xs = vec![];\n    let mut y = *x;\n\n    while uf[y] != y {\n       xs.push(y);\n       y = uf[y];\n    }\n\n    for i in 0..xs.len() {\n        uf[xs[i]] = y;\n    }\n}\n\nfn solve<R: BufRead, W: Write>(mut input: FastInput<R>, mut w: W) {\n    let n: usize = input.token();\n    let m: usize = input.token();\n\n    let mut vs = vec![];\n    let mut uf = vec![];\n    let mut indexes = HashMap::new();\n    let mut components = n;\n\n    for i in 0..n {\n        let ai: usize = input.token();\n        vs.push((ai, i));\n        uf.push(i);\n    }\n\n    vs.sort();\n\n    for i in 0..n {\n        indexes.insert(vs[i].1, i);\n    }\n\n    let mut es = vec![];\n\n    for i in 0..m {\n        let a: usize = input.token();\n        let b: usize = input.token();\n        let w: usize = input.token();\n        if vs[indexes[&(a - 1)]].0 + vs[indexes[&(b - 1)]].0 > w {\n            es.push((w, a - 1, b - 1));\n        }\n    }\n\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..es.len() {\n        heap.push(Reverse((es[i].0, es[i].1, es[i].2, Edge::Offer)));\n    }\n\n    for i in 1..n {\n        heap.push(Reverse((vs[0].0 + vs[i].0 , vs[i].1, vs[0].1, Edge::Normal)));\n    }\n\n    let mut total_cost = 0;\n\n    while let Some(Reverse((v, x, y, t))) = heap.pop() {\n        // println!(\""Processing {}-{} ({}, {:?})\"", x, y, v, t);\n        collapse(&x, &mut uf);\n        collapse(&y, &mut uf);\n        if uf[y] == uf[x] {\n            continue;\n        }\n        uf[y] = min(uf[x], uf[y]);\n        uf[x] = min(uf[x], uf[y]);\n        components -= 1;\n        total_cost += v;\n        \n        if components == 1 {\n            break;\n        }\n\n        if t == Edge::Normal {\n            let new_y = vs[indexes[&y] + 1].1;\n            let new_v = vs[indexes[&new_y]].0 + vs[indexes[&x]].0;\n            // println!(\""New y is {}, new value is {}\"", new_y, new_v);\n            heap.push(Reverse((new_v, x, new_y, Edge::Normal)));\n        }\n    }\n\n    write!(w, \""{}\\n\"", total_cost);\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let input = FastInput::from(stdin.lock());\n    let writer = io::BufWriter::new(stdout.lock());\n    solve(input, writer);\n}\n\ntrait TokenStream<T> {\n    fn token(&mut self) -> T;\n}\n\nstruct FastInput<R> {\n    stdin: R,\n    pos: usize,\n}\n\nimpl<R: BufRead> From<R> for FastInput<R> {\n    fn from(r: R) -> Self {\n        FastInput { stdin: r, pos: 0 }\n    }\n}\n\nimpl<R: BufRead> TokenStream<u8> for FastInput<R> {\n    fn token(&mut self) -> u8 {\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                while self.pos < buf.len() {\n                    self.pos += 1;\n                    if buf[self.pos - 1] > 32 {\n                        return buf[self.pos - 1];\n                    }\n                }\n                if self.pos == 0 {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nimpl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {\n    fn token(&mut self) -> Vec<u8> {\n        let mut ans = Vec::new();\n        let mut parse_token = false;\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                if !parse_token {\n                    while self.pos < buf.len() && buf[self.pos] <= 32 {\n                        self.pos += 1;\n                    }\n                }\n                while self.pos < buf.len() && buf[self.pos] > 32 {\n                    parse_token = true;\n                    ans.push(buf[self.pos]);\n                    self.pos += 1;\n                }\n                if self.pos != buf.len() || self.pos == 0 {\n                    return ans;\n                }\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nmacro_rules! impl_token_stream {\n    ($($t:ident),+) => {$(\n        impl<R: BufRead> TokenStream<$t> for FastInput<R> {\n           fn token(&mut self) -> $t {\n                let mut ans = 0;\n                let mut parse_token = false;\n                loop {\n                    if let Ok(buf) = self.stdin.fill_buf() {\n                        if !parse_token {\n                            while self.pos < buf.len() && buf[self.pos] <= 32 {\n                                self.pos += 1;\n                            }\n                        }\n                        while self.pos < buf.len() && buf[self.pos] > 32 {\n                            parse_token = true;\n                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;\n                            self.pos += 1;\n                        }\n                        if self.pos != buf.len() || self.pos == 0 {\n                            return ans;\n                        }\n                    }\n                    self.stdin.consume(self.pos);\n                    self.pos = 0;\n                }\n           }\n        }\n    )+}\n}\n\nimpl_token_stream!(usize);\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""6001af463b447143b982d72e3cf895e5"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_variables)]\n#![allow(unused_must_use)]\n#![allow(unused_imports)]\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::io::{self, prelude::*};\nuse std::cmp::{min,max};\nuse std::cmp::Reverse;\n\n\n\n\nfn collapse(x: &usize, uf: &mut Vec<usize>) {\n    let mut xs = vec![];\n    let mut y = *x;\n\n    while uf[y] != y {\n       xs.push(y);\n       y = uf[y];\n    }\n\n    for i in 0..xs.len() {\n        uf[xs[i]] = y;\n    }\n}\n\nfn solve<R: BufRead, W: Write>(mut input: FastInput<R>, mut w: W) {\n    let n: usize = input.token();\n    let m: usize = input.token();\n\n    let mut vs = vec![];\n    let mut uf = vec![];\n    let mut components = n;\n\n    for i in 0..n {\n        let ai: usize = input.token();\n        vs.push((ai, i));\n        uf.push(i);\n    }\n\n    vs.sort();\n\n\n    let mut es = vec![];\n\n    for i in 0..m {\n        let a: usize = input.token();\n        let b: usize = input.token();\n        let w: usize = input.token();\n        es.push((w, a - 1, b - 1));\n    }\n\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..es.len() {\n        heap.push(Reverse((es[i].0, es[i].1, es[i].2)));\n    }\n\n    for i in 1..n {\n        heap.push(Reverse((vs[0].0 + vs[i].0, vs[i].1, vs[0].1)));\n    }\n\n    let mut total_cost = 0;\n\n    while let Some(Reverse((v, x, y))) = heap.pop() {\n        // println!(\""Processing {}-{} ({})\"", x, y, v);\n        collapse(&x, &mut uf);\n        collapse(&y, &mut uf);\n        if uf[y] == uf[x] {\n            // println!(\""skip\"");\n            continue;\n        }\n        /*\n        for i in 0..n {\n            print!(\""({} -> {})\"", i, uf[i]);\n        }\n        println!(\""\"");\n        */\n        let z = uf[y];\n        uf[z] = uf[x];\n        uf[y] = uf[x];\n        components -= 1;\n        total_cost += v;\n        \n        if components == 1 {\n            break;\n        }\n    }\n\n    write!(w, \""{}\\n\"", total_cost);\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let input = FastInput::from(stdin.lock());\n    let writer = io::BufWriter::new(stdout.lock());\n    solve(input, writer);\n}\n\ntrait TokenStream<T> {\n    fn token(&mut self) -> T;\n}\n\nstruct FastInput<R> {\n    stdin: R,\n    pos: usize,\n}\n\nimpl<R: BufRead> From<R> for FastInput<R> {\n    fn from(r: R) -> Self {\n        FastInput { stdin: r, pos: 0 }\n    }\n}\n\nimpl<R: BufRead> TokenStream<u8> for FastInput<R> {\n    fn token(&mut self) -> u8 {\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                while self.pos < buf.len() {\n                    self.pos += 1;\n                    if buf[self.pos - 1] > 32 {\n                        return buf[self.pos - 1];\n                    }\n                }\n                if self.pos == 0 {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nimpl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {\n    fn token(&mut self) -> Vec<u8> {\n        let mut ans = Vec::new();\n        let mut parse_token = false;\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                if !parse_token {\n                    while self.pos < buf.len() && buf[self.pos] <= 32 {\n                        self.pos += 1;\n                    }\n                }\n                while self.pos < buf.len() && buf[self.pos] > 32 {\n                    parse_token = true;\n                    ans.push(buf[self.pos]);\n                    self.pos += 1;\n                }\n                if self.pos != buf.len() || self.pos == 0 {\n                    return ans;\n                }\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nmacro_rules! impl_token_stream {\n    ($($t:ident),+) => {$(\n        impl<R: BufRead> TokenStream<$t> for FastInput<R> {\n           fn token(&mut self) -> $t {\n                let mut ans = 0;\n                let mut parse_token = false;\n                loop {\n                    if let Ok(buf) = self.stdin.fill_buf() {\n                        if !parse_token {\n                            while self.pos < buf.len() && buf[self.pos] <= 32 {\n                                self.pos += 1;\n                            }\n                        }\n                        while self.pos < buf.len() && buf[self.pos] > 32 {\n                            parse_token = true;\n                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;\n                            self.pos += 1;\n                        }\n                        if self.pos != buf.len() || self.pos == 0 {\n                            return ans;\n                        }\n                    }\n                    self.stdin.consume(self.pos);\n                    self.pos = 0;\n                }\n           }\n        }\n    )+}\n}\n\nimpl_token_stream!(usize);\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""a357270b40a9dc77497979ce6049a1f0"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_variables)]\n#![allow(unused_must_use)]\n#![allow(unused_imports)]\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::io::{self, prelude::*};\nuse std::cmp::{min,max};\nuse std::cmp::Reverse;\n\n\n\n\nfn collapse(x: &usize, uf: &mut Vec<usize>) {\n    let mut xs = vec![];\n    let mut y = *x;\n\n    while uf[y] != y {\n       xs.push(y);\n       y = uf[y];\n    }\n\n    for i in 0..xs.len() {\n        uf[xs[i]] = y;\n    }\n}\n\nfn solve<R: BufRead, W: Write>(mut input: FastInput<R>, mut w: W) {\n    let n: usize = input.token();\n    let m: usize = input.token();\n\n    let mut vs = vec![];\n    let mut uf = vec![];\n    let mut components = n;\n\n    for i in 0..n {\n        let ai: usize = input.token();\n        vs.push((ai, i));\n        uf.push(i);\n    }\n\n    vs.sort();\n\n\n    let mut es = vec![];\n\n    for i in 0..m {\n        let a: usize = input.token();\n        let b: usize = input.token();\n        let w: usize = input.token();\n        es.push((w, a - 1, b - 1));\n    }\n\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..es.len() {\n        heap.push(Reverse((es[i].0, es[i].1, es[i].2)));\n    }\n\n    for i in 1..n {\n        heap.push(Reverse((vs[0].0 + vs[i].0, vs[i].1, vs[0].1)));\n    }\n\n    let mut total_cost: i64 = 0;\n\n    while let Some(Reverse((v, x, y))) = heap.pop() {\n        // println!(\""Processing {}-{} ({})\"", x, y, v);\n        collapse(&x, &mut uf);\n        collapse(&y, &mut uf);\n        if uf[y] == uf[x] {\n            // println!(\""skip\"");\n            continue;\n        }\n        /*\n        for i in 0..n {\n            print!(\""({} -> {})\"", i, uf[i]);\n        }\n        println!(\""\"");\n        */\n        let z = uf[y];\n        uf[z] = uf[x];\n        uf[z] = uf[x];\n        components -= 1;\n        total_cost += v as i64;\n        \n        if components == 1 {\n            break;\n        }\n    }\n\n    write!(w, \""{}\\n\"", total_cost);\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let input = FastInput::from(stdin.lock());\n    let writer = io::BufWriter::new(stdout.lock());\n    solve(input, writer);\n}\n\ntrait TokenStream<T> {\n    fn token(&mut self) -> T;\n}\n\nstruct FastInput<R> {\n    stdin: R,\n    pos: usize,\n}\n\nimpl<R: BufRead> From<R> for FastInput<R> {\n    fn from(r: R) -> Self {\n        FastInput { stdin: r, pos: 0 }\n    }\n}\n\nimpl<R: BufRead> TokenStream<u8> for FastInput<R> {\n    fn token(&mut self) -> u8 {\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                while self.pos < buf.len() {\n                    self.pos += 1;\n                    if buf[self.pos - 1] > 32 {\n                        return buf[self.pos - 1];\n                    }\n                }\n                if self.pos == 0 {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nimpl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {\n    fn token(&mut self) -> Vec<u8> {\n        let mut ans = Vec::new();\n        let mut parse_token = false;\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                if !parse_token {\n                    while self.pos < buf.len() && buf[self.pos] <= 32 {\n                        self.pos += 1;\n                    }\n                }\n                while self.pos < buf.len() && buf[self.pos] > 32 {\n                    parse_token = true;\n                    ans.push(buf[self.pos]);\n                    self.pos += 1;\n                }\n                if self.pos != buf.len() || self.pos == 0 {\n                    return ans;\n                }\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nmacro_rules! impl_token_stream {\n    ($($t:ident),+) => {$(\n        impl<R: BufRead> TokenStream<$t> for FastInput<R> {\n           fn token(&mut self) -> $t {\n                let mut ans = 0;\n                let mut parse_token = false;\n                loop {\n                    if let Ok(buf) = self.stdin.fill_buf() {\n                        if !parse_token {\n                            while self.pos < buf.len() && buf[self.pos] <= 32 {\n                                self.pos += 1;\n                            }\n                        }\n                        while self.pos < buf.len() && buf[self.pos] > 32 {\n                            parse_token = true;\n                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;\n                            self.pos += 1;\n                        }\n                        if self.pos != buf.len() || self.pos == 0 {\n                            return ans;\n                        }\n                    }\n                    self.stdin.consume(self.pos);\n                    self.pos = 0;\n                }\n           }\n        }\n    )+}\n}\n\nimpl_token_stream!(usize);\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""bc9ed7e6f30546f73d1d231d0980f44b"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_variables)]\n#![allow(unused_must_use)]\n#![allow(unused_imports)]\nuse std::collections::BinaryHeap;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::io::{self, prelude::*};\nuse std::cmp::{min,max};\nuse std::cmp::Reverse;\n\n\n\n\nfn collapse(x: &usize, uf: &mut Vec<usize>) {\n    let mut xs = vec![];\n    let mut y = *x;\n\n    while uf[y] != y {\n       xs.push(y);\n       y = uf[y];\n    }\n\n    for i in 0..xs.len() {\n        uf[xs[i]] = y;\n    }\n}\n\nfn solve<R: BufRead, W: Write>(mut input: FastInput<R>, mut w: W) {\n    let n: usize = input.token();\n    let m: usize = input.token();\n\n    let mut vs = vec![];\n    let mut uf = vec![];\n    let mut indexes = HashMap::new();\n    let mut components = n;\n\n    for i in 0..n {\n        let ai: usize = input.token();\n        vs.push((ai, i));\n        uf.push(i);\n    }\n\n    vs.sort();\n\n    for i in 0..n {\n        indexes.insert(vs[i].1, i);\n    }\n\n    let mut es = vec![];\n\n    for i in 0..m {\n        let a: usize = input.token();\n        let b: usize = input.token();\n        let w: usize = input.token();\n        if vs[indexes[&(a - 1)]].0 + vs[indexes[&(b - 1)]].0 > w {\n            es.push((w, a - 1, b - 1));\n        }\n    }\n\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..es.len() {\n        heap.push(Reverse((es[i].0, es[i].1, es[i].2)));\n    }\n\n    for i in 1..n {\n        heap.push(Reverse((vs[0].0 + vs[i].0, vs[i].1, vs[0].1)));\n    }\n\n    let mut total_cost = 0;\n\n    while let Some(Reverse((v, x, y))) = heap.pop() {\n        // println!(\""Processing {}-{} ({})\"", x, y, v);\n        collapse(&x, &mut uf);\n        collapse(&y, &mut uf);\n        if uf[y] == uf[x] {\n            // println!(\""skip\"");\n            continue;\n        }\n        /*\n        for i in 0..n {\n            print!(\""({} -> {})\"", i, uf[i]);\n        }\n        println!(\""\"");\n        */\n        let z = uf[y];\n        uf[z] = uf[x];\n        components -= 1;\n        total_cost += v;\n        \n        if components == 1 {\n            break;\n        }\n    }\n\n    write!(w, \""{}\\n\"", total_cost);\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let stdout = io::stdout();\n    let input = FastInput::from(stdin.lock());\n    let writer = io::BufWriter::new(stdout.lock());\n    solve(input, writer);\n}\n\ntrait TokenStream<T> {\n    fn token(&mut self) -> T;\n}\n\nstruct FastInput<R> {\n    stdin: R,\n    pos: usize,\n}\n\nimpl<R: BufRead> From<R> for FastInput<R> {\n    fn from(r: R) -> Self {\n        FastInput { stdin: r, pos: 0 }\n    }\n}\n\nimpl<R: BufRead> TokenStream<u8> for FastInput<R> {\n    fn token(&mut self) -> u8 {\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                while self.pos < buf.len() {\n                    self.pos += 1;\n                    if buf[self.pos - 1] > 32 {\n                        return buf[self.pos - 1];\n                    }\n                }\n                if self.pos == 0 {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nimpl<R: BufRead> TokenStream<Vec<u8>> for FastInput<R> {\n    fn token(&mut self) -> Vec<u8> {\n        let mut ans = Vec::new();\n        let mut parse_token = false;\n        loop {\n            if let Ok(buf) = self.stdin.fill_buf() {\n                if !parse_token {\n                    while self.pos < buf.len() && buf[self.pos] <= 32 {\n                        self.pos += 1;\n                    }\n                }\n                while self.pos < buf.len() && buf[self.pos] > 32 {\n                    parse_token = true;\n                    ans.push(buf[self.pos]);\n                    self.pos += 1;\n                }\n                if self.pos != buf.len() || self.pos == 0 {\n                    return ans;\n                }\n            }\n            self.stdin.consume(self.pos);\n            self.pos = 0;\n        }\n    }\n}\n\nmacro_rules! impl_token_stream {\n    ($($t:ident),+) => {$(\n        impl<R: BufRead> TokenStream<$t> for FastInput<R> {\n           fn token(&mut self) -> $t {\n                let mut ans = 0;\n                let mut parse_token = false;\n                loop {\n                    if let Ok(buf) = self.stdin.fill_buf() {\n                        if !parse_token {\n                            while self.pos < buf.len() && buf[self.pos] <= 32 {\n                                self.pos += 1;\n                            }\n                        }\n                        while self.pos < buf.len() && buf[self.pos] > 32 {\n                            parse_token = true;\n                            ans = ans * 10 + (buf[self.pos] - b'0') as $t;\n                            self.pos += 1;\n                        }\n                        if self.pos != buf.len() || self.pos == 0 {\n                            return ans;\n                        }\n                    }\n                    self.stdin.consume(self.pos);\n                    self.pos = 0;\n                }\n           }\n        }\n    )+}\n}\n\nimpl_token_stream!(usize);\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""30031a2d79e2be68fcee9570a0bca6dd"", ""src_uid"": ""e52ec2fa5bcf5d2027d57b0694b4e15a"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#[allow(unused_imports)]\nuse std::cmp::{min,max};\n//const INF: i32 = 0x3f3f3f3f;\n\nstruct Scanner {\n    buffer: std::collections::VecDeque<String>\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            buffer: std::collections::VecDeque::new()\n        }\n    }\n\n    fn next<T: std::str::FromStr>(&mut self) -> T {\n        while self.buffer.is_empty() {\n            let mut input = String::new();\n            std::io::stdin().read_line(&mut input).ok();\n            self.buffer = input.split_whitespace()\n                .map(ToString::to_string).collect();\n        }\n        let front = self.buffer.pop_front().unwrap();\n        front.parse::<T>().ok().unwrap()\n    }\n}\n\n/// Data structure for Knuth-Morris-Pratt string matching against a pattern.\npub struct Matcher<'a> {\n    /// The string pattern to search for.\n    pub pattern: &'a [i32],\n    /// KMP match failure automaton. fail[i] is the length of the longest\n    /// proper prefix-suffix of pattern[0...i].\n    pub fail: Vec<usize>,\n}\n\nimpl<'a> Matcher<'a> {\n    /// Precomputes the automaton that allows linear-time string matching.\n    ///\n    /// # Panics\n    ///\n    /// Panics if pattern is empty.\n    pub fn new(pattern: &'a [i32]) -> Self {\n        let mut fail = Vec::with_capacity(pattern.len());\n        fail.push(0);\n        let mut len = 0;\n        for &ch in &pattern[1..] {\n            while len > 0 && pattern[len] != ch {\n                len = fail[len - 1];\n            }\n            if pattern[len] == ch {\n                len += 1;\n            }\n            fail.push(len);\n        }\n        Self { pattern, fail }\n    }\n\n    /// KMP algorithm, sets matches[i] = length of longest prefix of pattern\n    /// matching a suffix of text[0...i].\n    pub fn kmp_match(&self, text: &[i32]) -> bool {\n        let mut len = 0;\n        for &ch in text {\n            if len == self.pattern.len() {\n                len = self.fail[len - 1];\n            }\n            while len > 0 && self.pattern[len] != ch {\n                len = self.fail[len - 1];\n            }\n            if self.pattern[len] == ch {\n                len += 1;\n            }\n            if len == self.pattern.len() {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nfn main1() {\n    let mut scan = Scanner::new();\n    let n = scan.next::<i32>();\n    let m = scan.next::<usize>();\n    let mut adj = vec![vec![]; n as usize];\n    for _ in 0..m {\n        let a = scan.next::<i32>() - 1;\n        let b = scan.next::<i32>() - 1;\n        adj[a as usize].push((b - a + n) % n);\n        adj[b as usize].push((a - b + n) % n);\n    }\n    \n    let mut pat = vec![];\n    for mut jumps in adj {\n        pat.push(0);\n        jumps.sort_unstable();\n        pat.extend(jumps);\n    }\n    let mut pat2 = pat.clone();\n    pat2.extend(pat.clone());\n    pat2.pop();\n    \n    let symmetric = Matcher::new(&pat).kmp_match(&pat2[1..]);\n    if symmetric {\n        print!(\""Yes\"");\n    } else {\n        print!(\""No\"");\n    }\n}\n\nfn main() {\n    std::thread::Builder::new().stack_size(50 << 20)\n        .spawn(main1).unwrap().join().unwrap();\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""597f36f07770c326e1493fb84eac1c1a"", ""src_uid"": ""dd7a7a4e5feb50ab6abb93d90c559c2b"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Read, BufWriter, Write};\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst INF: i64 = 1 << 53;\n\nfn solve() {\n    let n = get();\n    let mut a: Vec<i64> = (0 .. n).map(|_| get()).collect();\n    a.insert(0, -INF);\n    a.push(-INF);\n    let mut dp = vec![vec![vec![INF; n + 1]; n + 1]; 2];\n    dp[0][0][0] = 0;\n    for i in 1 .. n + 1 {\n        let cost =\n            max(0, a[i - 1] - a[i] + 1) + max(0, a[i + 1] - a[i] + 1);\n        let cost2 = if i >= 2 {\n            -max(0, a[i - 1] - a[i - 2] + 1) + max(0, a[i - 1] - min(a[i], a[i - 2]) + 1) + max(0, a[i + 1] - a[i] + 1)\n        } else {\n            INF\n        };\n        for j in 0 .. n + 1 {\n            dp[0][i][j] = min(dp[0][i][j], min(dp[0][i - 1][j], dp[1][i - 1][j]));\n            if j > 0 {\n                dp[1][i][j] = min(dp[1][i][j], dp[0][i - 1][j - 1] + cost);\n                if i >= 2 {\n                    dp[1][i][j] = min(dp[1][i][j], dp[1][i - 2][j - 1] + cost2);\n                }\n            }\n        }\n    }\n    let mut ans = vec![INF; n + 1];\n    for i in 0 .. n + 1 {\n        ans[i] = min(dp[0][n][i], dp[1][n][i]);\n    }\n    let stdout = std::io::stdout();\n    let mut stdout = BufWriter::new(stdout.lock());\n    for i in 1 .. (n + 1) / 2 + 1 {\n        write!(stdout, \""{}{}\"", ans[i], if i == (n + 1) / 2 { \""\\n\"" } else { \"" \"" }).unwrap();\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""f9038f5d60c3531ce8031537d3614ac2"", ""src_uid"": ""9534b468bfb6126fc16b896532ced8c5"", ""difficulty"": 1900}
{""lang"": ""Rust"", ""source_code"": ""pub fn read_num() -> Vec<i32> {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n\n    line.split_whitespace()\n        .map(|s| s.parse().unwrap())\n        .collect()\n }\n\nfn main() {\n\tlet mut line = String::new();\n\n    let nk = read_num();\n\tlet mut arr = read_num();\n\n\tarr.sort();\n\tarr.truncate(nk[1] as usize);\n\t\n\tlet ans: i32 = arr.iter().sum();\n\n\tprintln!(\""{}\"", ans);\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""207738b355eb44b08f0c2d06dab83aec"", ""src_uid"": ""5097e92916e49cdc6fb4953b864186db"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(non_snake_case)]\n#![allow(non_shorthand_field_patterns)]\n\nuse std::cmp::{max, min, Ordering};\nuse std::collections::*;\nuse std::fmt::{Debug, Formatter};\nuse std::io::*;\nuse std::ops::*;\nuse std::rc::Rc;\nuse std::*;\n\n// -----------------------------------------------\n// Framework\n// -----------------------------------------------\n\n#[allow(unused_macros)]\nmacro_rules! read {\n    ([$t:ty] ; $n:expr) =>\n        ((0..$n).map(|_| read!([$t])).collect::<Vec<_>>());\n    ($($t:ty),+ ; $n:expr) =>\n        ((0..$n).map(|_| read!($($t),+)).collect::<Vec<_>>());\n    ([$t:ty]) =>\n        (rl().split_whitespace().map(|w| w.parse().unwrap()).collect::<Vec<$t>>());\n    ($t:ty) =>\n        (rl().parse::<$t>().unwrap());\n    ($($t:ty),*) => {{\n        let buf = rl();\n        let mut w = buf.split_whitespace();\n        ($(w.next().unwrap().parse::<$t>().unwrap()),*)\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($arg:expr),*) => {\n        #[cfg(debug_assertions)]\n        {\n            let entries = [$(&stringify!([$arg]:), &$arg as &Debug),*];\n            stderr().write_fmt(format_args!(\""{:#?}\\n\"", entries)).unwrap();\n        }\n    };\n}\n\n#[allow(dead_code)]\nfn rl() -> String {\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf).unwrap();\n    buf.trim_right().to_owned()\n}\n\ntrait IteratorExt: Iterator + Sized {\n    fn vec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\nimpl<T: Iterator> IteratorExt for T {}\n\n// -----------------------------------------------\n// Solution\n// -----------------------------------------------\n\n#[derive(Clone, Copy, Debug)]\nstruct Query {\n    t: usize,\n    x: usize,\n    y: usize,\n}\n\n// \u5ea7\u6a19\u5727\u7e2e\u5f8c\u306e\u6570\u5217\u306e\u5024\u306e\u6700\u5927\u5024\nconst N: usize = 200000;\n\n// \u30d0\u30b1\u30c3\u30c8\u306e\u30b5\u30a4\u30ba (~~ N^(2/3))\nconst SZ: usize = 2100;\n\n// \u30d0\u30b1\u30c3\u30c8\u6570\u306e\u6700\u5927\u5024 (>= N/SZ)\nconst B: usize = 60;\n\nstruct Solver {\n    /// \u66f4\u65b0\u30af\u30a8\u30ea\u30fc\u3092t\u500b\u5b9f\u884c\u3057\u305f\u5f8c\u306e\u533a\u9593 [x, y] \u306e mex \u3092\u7b54\u3048\u308b\u30af\u30a8\u30ea\u30fc\n    mex_query: Vec<Query>,\n    /// t\u756a\u76ee\u306e\u8981\u7d20\u3092x\u304b\u3089y\u306b\u5909\u66f4\u3059\u308b\u30af\u30a8\u30ea\u30fc\n    ch_query: Vec<Query>,\n    /// T\u500b\u306e\u30af\u30a8\u30ea\u30fc\u306e\u5b9f\u884c\u5f8c\u306b\u304a\u3051\u308b\u533a\u9593 [L, R] \u306b\u6ce8\u76ee\u3057\u3066\u3044\u308b\u3053\u3068\u3092\u8868\u3059\u3002\n    T: isize,\n    L: isize,\n    R: isize,\n    /// ct[a] = \u6570\u5024 a \u304c\u73fe\u5728\u306e\u533a\u9593\u306b\u73fe\u308c\u308b\u56de\u6570\n    ct: Vec<usize>,\n    /// sz[k] = \u73fe\u5728\u306e\u533a\u9593\u306b\u304a\u3044\u3066\u3001\u3061\u3087\u3046\u3069 k \u56de\u51fa\u73fe\u3059\u308b\u6570\u5024\u306e\u500b\u6570\n    sz: Vec<i32>,\n    /// \u73fe\u5728\u306e(T\u500b\u306e\u30af\u30a8\u30ea\u30fc\u306e\u5b9f\u884c\u5f8c\u306e)\u6570\u5217\n    a: Vec<usize>,\n    mx: Vec<Vec<HashSet<(usize, usize)>>>,\n}\n\nimpl Solver {\n    pub fn new() -> Solver {\n        Solver {\n            mex_query: Vec::new(),\n            ch_query: Vec::new(),\n            ct: vec![0; N],\n            sz: vec![0; N],\n            a: Vec::new(),\n            L: 0,\n            R: -1,\n            T: -1,\n            mx: vec![vec![HashSet::new(); B]; B],\n        }\n    }\n\n    // R += 1\n    pub fn pr(&mut self) {\n        self.R += 1;\n        let R = self.R as usize;\n\n        // \u533a\u9593\u306b\u8ffd\u52a0\u3055\u308c\u308b\u8981\u7d20\n        let a = self.a[R];\n\n        // \u66f4\u65b0\u524d\u306b\u3001a \u304c\u533a\u9593\u5185\u306b\u51fa\u73fe\u3057\u3066\u3044\u305f\u56de\u6570\n        let k = self.ct[a];\n\n        // a \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u306f1\u56de\u5897\u3048\u308b\u3002\n        self.ct[a] += 1;\n\n        // \u300ck \u56de\u51fa\u73fe\u3059\u308b\u6570\u5024\u300d\u306f a \u304c\u6d88\u3048\u30661\u6e1b\u308a\u3001(k + 1) \u56de\u3003\u306fa\u304c\u52a0\u308f\u3063\u30661\u5897\u3048\u308b\u3002\n        self.sz[k] -= 1;\n        self.sz[k + 1] += 1;\n    }\n\n    // \u4e0a\u3068\u540c\u69d8\u3002a\u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u306f\u6e1b\u308b\u3002\n    pub fn pl(&mut self) {\n        let a = self.a[self.L as usize];\n\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] -= 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.L += 1;\n    }\n\n    pub fn mr(&mut self) {\n        assert!(self.R >= 0);\n        let R = self.R as usize;\n\n        let a = self.a[R];\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] -= 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.R -= 1;\n    }\n\n    pub fn ml(&mut self) {\n        assert!(self.L >= 1);\n\n        let a = self.a[self.L as usize];\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] += 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.L -= 1;\n    }\n\n    fn update(&mut self, i: usize, x: usize, y: usize) {\n        // i \u756a\u76ee\u306e\u8981\u7d20\u3092 x \u304b\u3089 y\u306b\u5909\u66f4\u3059\u308b\n        assert!(self.a[i] == x);\n\n        if self.in_focus(i) {\n            // x \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u304c\u6e1b\u308b\n            let a = self.a[i];\n            self.sz[self.ct[a]] -= 1;\n            self.ct[a] -= 1;\n            self.sz[self.ct[a]] += 1;\n        }\n\n        self.a[i] = y;\n\n        if self.in_focus(i) {\n            // y \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u304c\u6e1b\u308b\n            let a = self.a[i];\n            self.sz[self.ct[a]] -= 1;\n            self.ct[a] += 1;\n            self.sz[self.ct[a]] += 1;\n        }\n    }\n\n    // T += 1\n    pub fn pt(&mut self) {\n        self.T += 1;\n        let Query { t: i, x, y } = self.ch_query[self.T as usize];\n        self.update(i, x, y);\n    }\n\n    /// T -= 1\n    pub fn mt(&mut self) {\n        let Query { t: i, x, y } = self.ch_query[self.T as usize];\n        self.update(i, y, x);\n        self.T -= 1;\n    }\n\n    /// \u6307\u5b9a\u3055\u308c\u305f\u4f4d\u7f6e\u304c\u73fe\u5728\u306e\u533a\u9593\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u304b\uff1f\n    pub fn in_focus(&self, i: usize) -> bool {\n        self.L <= i as isize && i as isize <= self.R\n    }\n\n    /// \u73fe\u5728\u306e\u533a\u9593\u306e mex \u3092\u8a08\u7b97\u3059\u308b\u3002O(\u221aN)\n    pub fn mex(&self) -> usize {\n        let mut k = 1;\n        loop {\n            if self.sz[k] == 0 {\n                return k;\n            }\n            k += 1;\n        }\n    }\n\n    pub fn entry_point(mut self) {\n        let (_, QN) = read!(usize, usize);\n        let A = read![[i64]];\n        let Q = read![i32, i64, i64; QN];\n\n        let mut compressor = HashMap::with_capacity(N);\n        let mut sigma = |a: i64| {\n            let m = compressor.len();\n            let e = compressor.entry(a).or_insert(m);\n            *e\n        };\n\n        let A = A.iter().map(|&a| sigma(a)).vec();\n        self.a = A.clone();\n        let mut TA = A;\n\n        for i in 0..QN {\n            let (t, l, r) = Q[i];\n\n            if t == 1 {\n                let l = (l - 1) as usize;\n                let r = (r - 1) as usize;\n\n                self.mex_query.push(Query {\n                    t: self.ch_query.len(),\n                    x: l,\n                    y: r,\n                });\n            } else {\n                let l = (l - 1) as usize;\n                let (x, y) = (TA[l], sigma(r));\n                self.ch_query.push(Query {\n                    t: l as usize,\n                    x: x,\n                    y: y,\n                });\n                TA[l] = y;\n            }\n        }\n\n        // \u30d6\u30ed\u30c3\u30af\u3054\u3068\u306b\u30af\u30a8\u30ea\u30fc\u3092\u5206\u985e\n        let M = self.mex_query.len();\n        for qi in 0..M {\n            let Query { t, x, y } = self.mex_query[qi];\n            let (i, j) = (t / SZ, x / SZ);\n            self.mx[i][j].insert((y, qi));\n        }\n\n        let mut answers = vec![0; M];\n\n        for i in 0..B {\n            for j in 0..B {\n                let mx = std::mem::replace(&mut self.mx[i][j], HashSet::default());\n                for (_, qi) in mx {\n                    let Query { t, x: l, y: r } = self.mex_query[qi];\n\n                    // (T, L, R) \u3092\u4e0e\u3048\u3089\u308c\u305f (t, l, r) \u306b\u8fd1\u3065\u3051\u3066\u3044\u304f\u3002\n\n                    while self.R < r as isize {\n                        self.pr();\n                    }\n                    while self.R > r as isize {\n                        self.mr();\n                    }\n                    while self.L < l as isize {\n                        self.pl();\n                    }\n                    while self.L > l as isize {\n                        self.ml();\n                    }\n                    while ((self.T + 1) as usize) < t {\n                        self.pt();\n                    }\n                    while ((self.T + 1) as usize) > t {\n                        self.mt();\n                    }\n\n                    // assert!(\n                    //     (self.T + 1) as usize == t && self.L == l as isize && self.R == r as isize\n                    // );\n\n                    // debug!(self.T, self.L, self.R, &self.ct[0..5], &self.sz[0..5]);\n\n                    answers[qi] = self.mex();\n                }\n            }\n        }\n\n        for mex in answers {\n            println!(\""{}\"", mex);\n        }\n    }\n}\n\npub fn main() {\n    Solver::new().entry_point();\n}\n\n// problem\n// http://codeforces.com/contest/940/problem/F\n\n// ref [CF 940 F - Machine Learning - \u88cf\u7d19](http://imulan.hatenablog.jp/entry/2018/03/22/182619)\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""4ec9cbc2054331f42603b48f1cff01dc"", ""src_uid"": ""eb6362941b5186d20721c99fb4808d52"", ""difficulty"": 2600}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(non_snake_case)]\n#![allow(non_shorthand_field_patterns)]\n\nuse std::cmp::{max, min, Ordering};\nuse std::collections::*;\nuse std::fmt::{Debug, Formatter};\nuse std::io::*;\nuse std::ops::*;\nuse std::rc::Rc;\nuse std::*;\n\n// -----------------------------------------------\n// Framework\n// -----------------------------------------------\n\n#[allow(unused_macros)]\nmacro_rules! read {\n    ([$t:ty] ; $n:expr) =>\n        ((0..$n).map(|_| read!([$t])).collect::<Vec<_>>());\n    ($($t:ty),+ ; $n:expr) =>\n        ((0..$n).map(|_| read!($($t),+)).collect::<Vec<_>>());\n    ([$t:ty]) =>\n        (rl().split_whitespace().map(|w| w.parse().unwrap()).collect::<Vec<$t>>());\n    ($t:ty) =>\n        (rl().parse::<$t>().unwrap());\n    ($($t:ty),*) => {{\n        let buf = rl();\n        let mut w = buf.split_whitespace();\n        ($(w.next().unwrap().parse::<$t>().unwrap()),*)\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($arg:expr),*) => {\n        #[cfg(debug_assertions)]\n        {\n            let entries = [$(&stringify!([$arg]:), &$arg as &Debug),*];\n            stderr().write_fmt(format_args!(\""{:#?}\\n\"", entries)).unwrap();\n        }\n    };\n}\n\n#[allow(dead_code)]\nfn rl() -> String {\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf).unwrap();\n    buf.trim_right().to_owned()\n}\n\ntrait IteratorExt: Iterator + Sized {\n    fn vec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\nimpl<T: Iterator> IteratorExt for T {}\n\n// -----------------------------------------------\n// Solution\n// -----------------------------------------------\n\n#[derive(Clone, Copy, Debug)]\nstruct Query {\n    t: usize,\n    x: usize,\n    y: usize,\n}\n\n// \u5ea7\u6a19\u5727\u7e2e\u5f8c\u306e\u6570\u5217\u306e\u5024\u306e\u6700\u5927\u5024\nconst N: usize = 200000;\n\n// \u30d0\u30b1\u30c3\u30c8\u306e\u30b5\u30a4\u30ba (~~ N^(2/3))\nconst SZ: usize = 2100;\n\n// \u30d0\u30b1\u30c3\u30c8\u6570\u306e\u6700\u5927\u5024 (>= N/SZ)\nconst B: usize = 60;\n\nstruct Solver {\n    /// \u66f4\u65b0\u30af\u30a8\u30ea\u30fc\u3092t\u500b\u5b9f\u884c\u3057\u305f\u5f8c\u306e\u533a\u9593 [x, y] \u306e mex \u3092\u7b54\u3048\u308b\u30af\u30a8\u30ea\u30fc\n    mex_query: Vec<Query>,\n    /// t\u756a\u76ee\u306e\u8981\u7d20\u3092x\u304b\u3089y\u306b\u5909\u66f4\u3059\u308b\u30af\u30a8\u30ea\u30fc\n    ch_query: Vec<Query>,\n    /// T\u500b\u306e\u30af\u30a8\u30ea\u30fc\u306e\u5b9f\u884c\u5f8c\u306b\u304a\u3051\u308b\u533a\u9593 [L, R] \u306b\u6ce8\u76ee\u3057\u3066\u3044\u308b\u3053\u3068\u3092\u8868\u3059\u3002\n    T: isize,\n    L: isize,\n    R: isize,\n    /// ct[a] = \u6570\u5024 a \u304c\u73fe\u5728\u306e\u533a\u9593\u306b\u73fe\u308c\u308b\u56de\u6570\n    ct: Vec<usize>,\n    /// sz[k] = \u73fe\u5728\u306e\u533a\u9593\u306b\u304a\u3044\u3066\u3001\u3061\u3087\u3046\u3069 k \u56de\u51fa\u73fe\u3059\u308b\u6570\u5024\u306e\u500b\u6570\n    sz: Vec<i32>,\n    /// \u73fe\u5728\u306e(T\u500b\u306e\u30af\u30a8\u30ea\u30fc\u306e\u5b9f\u884c\u5f8c\u306e)\u6570\u5217\n    a: Vec<usize>,\n    mx: Vec<Vec<Vec<(usize, usize)>>>,\n}\n\nimpl Solver {\n    pub fn new() -> Solver {\n        Solver {\n            mex_query: Vec::new(),\n            ch_query: Vec::new(),\n            ct: vec![0; N],\n            sz: vec![0; N],\n            a: Vec::new(),\n            L: 0,\n            R: -1,\n            T: -1,\n            mx: vec![vec![Vec::new(); B]; B],\n        }\n    }\n\n    fn inspect(&self) {\n        let M = 10;\n        debug!(self.T, self.L, self.R, &self.ct[0..M], &self.sz[0..M]);\n    }\n\n    // R += 1\n    pub fn pr(&mut self) {\n        // self.inspect();\n\n        self.R += 1;\n        let R = self.R as usize;\n\n        // \u533a\u9593\u306b\u8ffd\u52a0\u3055\u308c\u308b\u8981\u7d20\n        let a = self.a[R];\n\n        // \u66f4\u65b0\u524d\u306b\u3001a \u304c\u533a\u9593\u5185\u306b\u51fa\u73fe\u3057\u3066\u3044\u305f\u56de\u6570\n        let k = self.ct[a];\n\n        // a \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u306f1\u56de\u5897\u3048\u308b\u3002\n        self.ct[a] += 1;\n\n        // \u300ck \u56de\u51fa\u73fe\u3059\u308b\u6570\u5024\u300d\u306f a \u304c\u6d88\u3048\u30661\u6e1b\u308a\u3001(k + 1) \u56de\u3003\u306fa\u304c\u52a0\u308f\u3063\u30661\u5897\u3048\u308b\u3002\n        self.sz[k] -= 1;\n        self.sz[k + 1] += 1;\n    }\n\n    // \u4e0a\u3068\u540c\u69d8\u3002a\u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u306f\u6e1b\u308b\u3002\n    pub fn pl(&mut self) {\n        // self.inspect();\n        let a = self.a[self.L as usize];\n\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] -= 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.L += 1;\n    }\n\n    pub fn mr(&mut self) {\n        // self.inspect();\n        assert!(self.R >= 0);\n        let R = self.R as usize;\n\n        let a = self.a[R];\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] -= 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.R -= 1;\n    }\n\n    pub fn ml(&mut self) {\n        // self.inspect();\n        assert!(self.L >= 1);\n        self.L -= 1;\n\n        let a = self.a[self.L as usize];\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] += 1;\n        self.sz[self.ct[a]] += 1;\n    }\n\n    fn update(&mut self, i: usize, x: usize, y: usize) {\n        // i \u756a\u76ee\u306e\u8981\u7d20\u3092 x \u304b\u3089 y\u306b\u5909\u66f4\u3059\u308b\n        assert!(self.a[i] == x);\n\n        if self.in_focus(i) {\n            // x \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u304c\u6e1b\u308b\n            let a = self.a[i];\n            self.sz[self.ct[a]] -= 1;\n            self.ct[a] -= 1;\n            self.sz[self.ct[a]] += 1;\n        }\n\n        self.a[i] = y;\n\n        if self.in_focus(i) {\n            // y \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u304c\u6e1b\u308b\n            let a = self.a[i];\n            self.sz[self.ct[a]] -= 1;\n            self.ct[a] += 1;\n            self.sz[self.ct[a]] += 1;\n        }\n    }\n\n    // T += 1\n    pub fn pt(&mut self) {\n        // self.inspect();\n        self.T += 1;\n        let Query { t: i, x, y } = self.ch_query[self.T as usize];\n        self.update(i, x, y);\n    }\n\n    /// T -= 1\n    pub fn mt(&mut self) {\n        // self.inspect();\n        let Query { t: i, x, y } = self.ch_query[self.T as usize];\n        self.update(i, y, x);\n        self.T -= 1;\n    }\n\n    /// \u6307\u5b9a\u3055\u308c\u305f\u4f4d\u7f6e\u304c\u73fe\u5728\u306e\u533a\u9593\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u304b\uff1f\n    pub fn in_focus(&self, i: usize) -> bool {\n        self.L <= i as isize && i as isize <= self.R\n    }\n\n    /// \u73fe\u5728\u306e\u533a\u9593\u306e mex \u3092\u8a08\u7b97\u3059\u308b\u3002O(\u221aN)\n    pub fn mex(&self) -> usize {\n        let mut k = 1;\n        loop {\n            if self.sz[k] == 0 {\n                return k;\n            }\n            k += 1;\n        }\n    }\n\n    pub fn entry_point(mut self, A: Vec<i64>, Q: Vec<(i32, i64, i64)>) -> Vec<usize> {\n        let mut compressor = BTreeMap::new();\n        let mut sigma = |a: i64| {\n            let m = compressor.len();\n            let e = compressor.entry(a).or_insert(m);\n            *e\n        };\n\n        let A = A.iter().map(|&a| sigma(a)).vec();\n        self.a = A.clone();\n        let mut TA = A;\n\n        for i in 0..Q.len() {\n            let (t, l, r) = Q[i];\n\n            if t == 1 {\n                let l = (l - 1) as usize;\n                let r = (r - 1) as usize;\n\n                self.mex_query.push(Query {\n                    t: self.ch_query.len(),\n                    x: l,\n                    y: r,\n                });\n            } else {\n                let l = (l - 1) as usize;\n                let (x, y) = (TA[l], sigma(r));\n                self.ch_query.push(Query {\n                    t: l as usize,\n                    x: x,\n                    y: y,\n                });\n                TA[l] = y;\n            }\n        }\n\n        // \u30d6\u30ed\u30c3\u30af\u3054\u3068\u306b\u30af\u30a8\u30ea\u30fc\u3092\u5206\u985e\n        // \u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u3092SZ\u3068\u3059\u308b\u3068\u3001\u5404\u30d6\u30ed\u30c3\u30af\u306b\u304a\u3044\u3066 t,l \u306f O(SZ) \u3057\u304b\u5909\u5316\u3057\u306a\u3044\u3053\u3068\u306b\u3067\u304d\u308b\u3002\n        // \u30d6\u30ed\u30c3\u30af\u5185\u306e\u30af\u30a8\u30ea\u30fc\u3092 r \u306b\u3064\u3044\u3066\u30bd\u30fc\u30c8\u3059\u308c\u3070 r \u306f\u5358\u8abf\u5897\u52a0\u3059\u308b\u306e\u3067\u30011\u30d6\u30ed\u30c3\u30af\u3042\u305f\u308a O(N/SZ) \u6642\u9593\u304b\u304b\u308b\u3002\n\n        let M = self.mex_query.len();\n        for qi in 0..M {\n            let Query { t, x, y } = self.mex_query[qi];\n            let (i, j) = (t / SZ, x / SZ);\n            self.mx[i][j].push((y, qi));\n        }\n\n        let mut answers = vec![0; M];\n\n        for vs in std::mem::replace(&mut self.mx, Vec::default()) {\n            for mut ws in vs {\n                ws.sort();\n\n                for (_, qi) in ws {\n                    let Query { t, x: l, y: r } = self.mex_query[qi];\n\n                    // (T, L, R) \u3092\u4e0e\u3048\u3089\u308c\u305f (t, l, r) \u306b\u8fd1\u3065\u3051\u3066\u3044\u304f\u3002\n                    // L \u304c R \u3092\u8ffd\u3044\u8d8a\u3055\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f\u3002\n\n                    while self.L > l as isize {\n                        self.ml();\n                    }\n                    while self.R < r as isize {\n                        self.pr();\n                    }\n                    while self.L < l as isize {\n                        self.pl();\n                    }\n                    while self.R > r as isize {\n                        self.mr();\n                    }\n                    while ((self.T + 1) as usize) < t {\n                        self.pt();\n                    }\n                    while ((self.T + 1) as usize) > t {\n                        self.mt();\n                    }\n\n                    // assert!(\n                    //     (self.T + 1) as usize == t && self.L == l as isize && self.R == r as isize\n                    // );\n\n                    // debug!(self.T, self.L, self.R, &self.ct[0..5], &self.sz[0..5]);\n\n                    answers[qi] = self.mex();\n                }\n            }\n        }\n\n        answers\n    }\n}\n\npub fn main() {\n    let (_, QN) = read!(usize, usize);\n    let A = read![[i64]];\n    let Q = read![i32, i64, i64; QN];\n\n    let answers = Solver::new().entry_point(A, Q);\n    for mex in answers {\n        println!(\""{}\"", mex);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sample1() {\n        let A = vec![1, 2, 3, 1, 1, 2, 2, 2, 9, 9];\n        let Q = vec![(1, 1, 1), (1, 2, 8), (2, 7, 1), (1, 2, 8)];\n        let answer = Solver::new().entry_point(A, Q);\n        assert_eq!(answer, vec![2, 3, 2]);\n    }\n\n    #[test]\n    fn test() {\n        let M = 100;\n        let QN = 10;\n        let A = (0..N).map(|i| (i * i * i % 17 + 1) as i64).vec();\n        let Q = (0..QN)\n            .map(|i| {\n                let l = (i * i * i % M) as i64;\n                let r = (l + (M - l) / 2) as i64;\n                let t = (i % 2) as i32;\n                (t + 1, l + 1, r + 1)\n            })\n            .vec();\n\n        let answer = Solver::new().entry_point(A, Q);\n        assert_eq!(answer, vec![1, 1, 3, 4, 4]);\n    }\n}\n\n// problem\n// http://codeforces.com/contest/940/problem/F\n\n// ref [CF 940 F - Machine Learning - \u88cf\u7d19](http://imulan.hatenablog.jp/entry/2018/03/22/182619)\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""a32865b069a3287a4c21dcad61842052"", ""src_uid"": ""eb6362941b5186d20721c99fb4808d52"", ""difficulty"": 2600}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(non_snake_case)]\n#![allow(non_shorthand_field_patterns)]\n\nuse std::cmp::{max, min, Ordering};\nuse std::collections::*;\nuse std::fmt::{Debug, Formatter};\nuse std::io::*;\nuse std::ops::*;\nuse std::rc::Rc;\nuse std::*;\n\n// -----------------------------------------------\n// Framework\n// -----------------------------------------------\n\n#[allow(unused_macros)]\nmacro_rules! read {\n    ([$t:ty] ; $n:expr) =>\n        ((0..$n).map(|_| read!([$t])).collect::<Vec<_>>());\n    ($($t:ty),+ ; $n:expr) =>\n        ((0..$n).map(|_| read!($($t),+)).collect::<Vec<_>>());\n    ([$t:ty]) =>\n        (rl().split_whitespace().map(|w| w.parse().unwrap()).collect::<Vec<$t>>());\n    ($t:ty) =>\n        (rl().parse::<$t>().unwrap());\n    ($($t:ty),*) => {{\n        let buf = rl();\n        let mut w = buf.split_whitespace();\n        ($(w.next().unwrap().parse::<$t>().unwrap()),*)\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($arg:expr),*) => {\n        #[cfg(debug_assertions)]\n        {\n            let entries = [$(&stringify!([$arg]:), &$arg as &Debug),*];\n            stderr().write_fmt(format_args!(\""{:#?}\\n\"", entries)).unwrap();\n        }\n    };\n}\n\n#[allow(dead_code)]\nfn rl() -> String {\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf).unwrap();\n    buf.trim_right().to_owned()\n}\n\ntrait IteratorExt: Iterator + Sized {\n    fn vec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\nimpl<T: Iterator> IteratorExt for T {}\n\n// -----------------------------------------------\n// Solution\n// -----------------------------------------------\n\n// ref [CF 940 F - Machine Learning - \u88cf\u7d19](http://imulan.hatenablog.jp/entry/2018/03/22/182619)\n\n#[derive(Clone, Copy, Debug)]\nstruct Query {\n    t: usize,\n    x: usize,\n    y: usize,\n}\n\n// \u5ea7\u6a19\u5727\u7e2e\u5f8c\u306e\u6570\u5217\u306e\u5024\u306e\u6700\u5927\u5024\nconst N: usize = 200000;\n\n// \u30d0\u30b1\u30c3\u30c8\u306e\u30b5\u30a4\u30ba (~~ N^(2/3))\nconst SZ: usize = 2100;\n\n// \u30d0\u30b1\u30c3\u30c8\u6570\u306e\u6700\u5927\u5024 (>= N/SZ)\nconst B: usize = 60;\n\nstruct Solver {\n    /// \u66f4\u65b0\u30af\u30a8\u30ea\u30fc\u3092t\u500b\u5b9f\u884c\u3057\u305f\u5f8c\u306e\u533a\u9593 [x, y] \u306e mex \u3092\u7b54\u3048\u308b\u30af\u30a8\u30ea\u30fc\n    mex_query: Vec<Query>,\n    /// t\u756a\u76ee\u306e\u8981\u7d20\u3092x\u304b\u3089y\u306b\u5909\u66f4\u3059\u308b\u30af\u30a8\u30ea\u30fc\n    ch_query: Vec<Query>,\n    /// T\u500b\u306e\u30af\u30a8\u30ea\u30fc\u306e\u5b9f\u884c\u5f8c\u306b\u304a\u3051\u308b\u533a\u9593 [L, R] \u306b\u6ce8\u76ee\u3057\u3066\u3044\u308b\u3053\u3068\u3092\u8868\u3059\u3002\n    T: isize,\n    L: usize,\n    R: isize,\n    /// ct[a] = \u6570\u5024 a \u304c\u73fe\u5728\u306e\u533a\u9593\u306b\u73fe\u308c\u308b\u56de\u6570\n    ct: Vec<usize>,\n    /// sz[k] = \u73fe\u5728\u306e\u533a\u9593\u306b\u304a\u3044\u3066\u3001\u3061\u3087\u3046\u3069 k \u56de\u51fa\u73fe\u3059\u308b\u6570\u5024\u306e\u500b\u6570\n    sz: Vec<usize>,\n    /// \u73fe\u5728\u306e(T\u500b\u306e\u30af\u30a8\u30ea\u30fc\u306e\u5b9f\u884c\u5f8c\u306e)\u6570\u5217\n    a: Vec<usize>,\n    mx: Vec<Vec<HashSet<(usize, usize)>>>,\n}\n\nimpl Solver {\n    pub fn new() -> Solver {\n        let mut solver = Solver {\n            mex_query: Vec::new(),\n            ch_query: Vec::new(),\n            ct: vec![0; N],\n            sz: vec![0; N],\n            a: Vec::new(),\n            L: 0,\n            R: -1,\n            T: -1,\n            mx: vec![vec![HashSet::new(); B]; B],\n        };\n        solver.sz[0] = std::usize::MAX / 2;\n        solver\n    }\n\n    // R += 1\n    pub fn pr(&mut self) {\n        self.R += 1;\n        let R = self.R as usize;\n\n        // \u533a\u9593\u306b\u8ffd\u52a0\u3055\u308c\u308b\u8981\u7d20\n        let a = self.a[R];\n\n        // \u66f4\u65b0\u524d\u306b\u3001a \u304c\u533a\u9593\u5185\u306b\u51fa\u73fe\u3057\u3066\u3044\u305f\u56de\u6570\n        let k = self.ct[a];\n\n        // a \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u306f1\u56de\u5897\u3048\u308b\u3002\n        self.ct[a] += 1;\n\n        // \u300ck \u56de\u51fa\u73fe\u3059\u308b\u6570\u5024\u300d\u306f a \u304c\u6d88\u3048\u30661\u6e1b\u308a\u3001(k + 1) \u56de\u3003\u306fa\u304c\u52a0\u308f\u3063\u30661\u5897\u3048\u308b\u3002\n        self.sz[k] -= 1;\n        self.sz[k + 1] += 1;\n    }\n\n    // \u4e0a\u3068\u540c\u69d8\u3002a\u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u306f\u6e1b\u308b\u3002\n    pub fn pl(&mut self) {\n        let a = self.a[self.L];\n\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] -= 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.L += 1;\n    }\n\n    pub fn mr(&mut self) {\n        assert!(self.R >= 0);\n        let R = self.R as usize;\n\n        let a = self.a[R];\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] -= 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.R -= 1;\n    }\n\n    pub fn ml(&mut self) {\n        assert!(self.L >= 1);\n\n        let a = self.a[self.L];\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] += 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.L -= 1;\n    }\n\n    fn update(&mut self, i: usize, x: usize, y: usize) {\n        // i \u756a\u76ee\u306e\u8981\u7d20\u3092 x \u304b\u3089 y\u306b\u5909\u66f4\u3059\u308b\n        assert!(self.a[i] == x);\n\n        if self.in_focus(i) {\n            // x \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u304c\u6e1b\u308b\n            let a = self.a[i];\n            self.sz[self.ct[a]] -= 1;\n            self.ct[a] -= 1;\n            self.sz[self.ct[a]] += 1;\n        }\n\n        self.a[i] = y;\n\n        if self.in_focus(i) {\n            // y \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u304c\u6e1b\u308b\n            let a = self.a[i];\n            self.sz[self.ct[a]] -= 1;\n            self.ct[a] += 1;\n            self.sz[self.ct[a]] += 1;\n        }\n    }\n\n    // T += 1\n    pub fn pt(&mut self) {\n        self.T += 1;\n        let Query { t: i, x: x, y: y } = self.ch_query[self.T as usize];\n        self.update(i, x, y);\n    }\n\n    /// T -= 1\n    pub fn mt(&mut self) {\n        let Query { t: i, x: x, y: y } = self.ch_query[self.T as usize];\n        self.update(i, y, x);\n        self.T -= 1;\n    }\n\n    /// \u6307\u5b9a\u3055\u308c\u305f\u4f4d\u7f6e\u304c\u73fe\u5728\u306e\u533a\u9593\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u304b\uff1f\n    pub fn in_focus(&self, i: usize) -> bool {\n        self.L <= i && i as isize <= self.R\n    }\n\n    /// \u73fe\u5728\u306e\u533a\u9593\u306e mex \u3092\u8a08\u7b97\u3059\u308b\u3002O(\u221aN)\n    pub fn mex(&self) -> usize {\n        let mut k = 1;\n        loop {\n            if self.sz[k] == 0 {\n                return k;\n            }\n            k += 1;\n        }\n    }\n\n    pub fn entry_point(mut self) {\n        let (_, QN) = read!(usize, usize);\n        let A = read![[i64]];\n        let Q = read![i32, i64, i64; QN];\n\n        let mut compressor = HashMap::with_capacity(N);\n        let mut sigma = |a: i64| {\n            let m = compressor.len();\n            let e = compressor.entry(a).or_insert(m);\n            *e\n        };\n\n        let A = A.iter().map(|&a| sigma(a)).vec();\n        self.a = A.clone();\n        let mut TA = A;\n\n        for i in 0..QN {\n            let (t, l, r) = Q[i];\n\n            if t == 1 {\n                let l = (l - 1) as usize;\n                let r = (r - 1) as usize;\n\n                self.mex_query.push(Query {\n                    t: self.ch_query.len(),\n                    x: l,\n                    y: r,\n                });\n            } else {\n                let l = (l - 1) as usize;\n                let (x, y) = (TA[l], sigma(r));\n                self.ch_query.push(Query {\n                    t: l as usize,\n                    x: x,\n                    y: y,\n                });\n                TA[l] = y;\n            }\n        }\n\n        // \u30d6\u30ed\u30c3\u30af\u3054\u3068\u306b\u30af\u30a8\u30ea\u30fc\u3092\u5206\u985e\n        let M = self.mex_query.len();\n        for qi in 0..M {\n            let Query { t: t, x: x, y: y } = self.mex_query[qi];\n            let (i, j) = (t / SZ, x / SZ);\n            self.mx[i][j].insert((y, qi));\n        }\n\n        let mut answers = vec![0; M];\n\n        for i in 0..B {\n            for j in 0..B {\n                let mx = std::mem::replace(&mut self.mx[i][j], HashSet::default());\n                for (_, qi) in mx {\n                    let Query { t: t, x: l, y: r } = self.mex_query[qi];\n\n                    // (T, L, R) \u3092\u4e0e\u3048\u3089\u308c\u305f (t, l, r) \u306b\u8fd1\u3065\u3051\u3066\u3044\u304f\u3002\n\n                    while self.R < r as isize {\n                        self.pr();\n                    }\n                    while self.R > r as isize {\n                        self.mr();\n                    }\n                    while self.L < l {\n                        self.pl();\n                    }\n                    while self.L > l {\n                        self.ml();\n                    }\n                    while ((self.T + 1) as usize) < t {\n                        self.pt();\n                    }\n                    while ((self.T + 1) as usize) > t {\n                        self.mt();\n                    }\n\n                    assert!((self.T + 1) as usize == t && self.L == l && self.R as usize == r);\n\n                    // debug!(self.T, self.L, self.R, &self.ct[0..5], &self.sz[0..5]);\n\n                    answers[qi] = self.mex();\n                }\n            }\n        }\n\n        for mex in answers {\n            println!(\""{}\"", mex);\n        }\n    }\n}\n\npub fn main() {\n    Solver::new().entry_point();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""53042937dfaf3136becbc8647d26d46a"", ""src_uid"": ""eb6362941b5186d20721c99fb4808d52"", ""difficulty"": 2600}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(non_snake_case)]\n#![allow(non_shorthand_field_patterns)]\n\nuse std::cmp::{max, min, Ordering};\nuse std::collections::*;\nuse std::fmt::{Debug, Formatter};\nuse std::io::*;\nuse std::ops::*;\nuse std::rc::Rc;\nuse std::*;\n\n// -----------------------------------------------\n// Framework\n// -----------------------------------------------\n\n#[allow(unused_macros)]\nmacro_rules! read {\n    ([$t:ty] ; $n:expr) =>\n        ((0..$n).map(|_| read!([$t])).collect::<Vec<_>>());\n    ($($t:ty),+ ; $n:expr) =>\n        ((0..$n).map(|_| read!($($t),+)).collect::<Vec<_>>());\n    ([$t:ty]) =>\n        (rl().split_whitespace().map(|w| w.parse().unwrap()).collect::<Vec<$t>>());\n    ($t:ty) =>\n        (rl().parse::<$t>().unwrap());\n    ($($t:ty),*) => {{\n        let buf = rl();\n        let mut w = buf.split_whitespace();\n        ($(w.next().unwrap().parse::<$t>().unwrap()),*)\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($arg:expr),*) => {\n        #[cfg(debug_assertions)]\n        {\n            let entries = [$(&stringify!([$arg]:), &$arg as &Debug),*];\n            stderr().write_fmt(format_args!(\""{:#?}\\n\"", entries)).unwrap();\n        }\n    };\n}\n\n#[allow(dead_code)]\nfn rl() -> String {\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf).unwrap();\n    buf.trim_right().to_owned()\n}\n\ntrait IteratorExt: Iterator + Sized {\n    fn vec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\nimpl<T: Iterator> IteratorExt for T {}\n\n// -----------------------------------------------\n// Solution\n// -----------------------------------------------\n\n#[derive(Clone, Copy, Debug)]\nstruct Query {\n    t: usize,\n    x: usize,\n    y: usize,\n}\n\n// \u5ea7\u6a19\u5727\u7e2e\u5f8c\u306e\u6570\u5217\u306e\u5024\u306e\u6700\u5927\u5024\nconst N: usize = 200000;\n\n// \u30d0\u30b1\u30c3\u30c8\u306e\u30b5\u30a4\u30ba (~~ N^(2/3))\nconst SZ: usize = 2100;\n\n// \u30d0\u30b1\u30c3\u30c8\u6570\u306e\u6700\u5927\u5024 (>= N/SZ)\nconst B: usize = 60;\n\nstruct Solver {\n    /// \u66f4\u65b0\u30af\u30a8\u30ea\u30fc\u3092t\u500b\u5b9f\u884c\u3057\u305f\u5f8c\u306e\u533a\u9593 [x, y] \u306e mex \u3092\u7b54\u3048\u308b\u30af\u30a8\u30ea\u30fc\n    mex_query: Vec<Query>,\n    /// t\u756a\u76ee\u306e\u8981\u7d20\u3092x\u304b\u3089y\u306b\u5909\u66f4\u3059\u308b\u30af\u30a8\u30ea\u30fc\n    ch_query: Vec<Query>,\n    /// T\u500b\u306e\u30af\u30a8\u30ea\u30fc\u306e\u5b9f\u884c\u5f8c\u306b\u304a\u3051\u308b\u533a\u9593 [L, R] \u306b\u6ce8\u76ee\u3057\u3066\u3044\u308b\u3053\u3068\u3092\u8868\u3059\u3002\n    T: isize,\n    L: isize,\n    R: isize,\n    /// ct[a] = \u6570\u5024 a \u304c\u73fe\u5728\u306e\u533a\u9593\u306b\u73fe\u308c\u308b\u56de\u6570\n    ct: Vec<usize>,\n    /// sz[k] = \u73fe\u5728\u306e\u533a\u9593\u306b\u304a\u3044\u3066\u3001\u3061\u3087\u3046\u3069 k \u56de\u51fa\u73fe\u3059\u308b\u6570\u5024\u306e\u500b\u6570\n    sz: Vec<i32>,\n    /// \u73fe\u5728\u306e(T\u500b\u306e\u30af\u30a8\u30ea\u30fc\u306e\u5b9f\u884c\u5f8c\u306e)\u6570\u5217\n    a: Vec<usize>,\n    mx: Vec<Vec<HashSet<(usize, usize)>>>,\n}\n\nimpl Solver {\n    pub fn new() -> Solver {\n        Solver {\n            mex_query: Vec::new(),\n            ch_query: Vec::new(),\n            ct: vec![0; N],\n            sz: vec![0; N],\n            a: Vec::new(),\n            L: 0,\n            R: -1,\n            T: -1,\n            mx: vec![vec![HashSet::new(); B]; B],\n        }\n    }\n\n    fn inspect(&self) {\n        let M = 10;\n        debug!(self.T, self.L, self.R, &self.ct[0..M], &self.sz[0..M]);\n    }\n\n    // R += 1\n    pub fn pr(&mut self) {\n        // self.inspect();\n\n        self.R += 1;\n        let R = self.R as usize;\n\n        // \u533a\u9593\u306b\u8ffd\u52a0\u3055\u308c\u308b\u8981\u7d20\n        let a = self.a[R];\n\n        // \u66f4\u65b0\u524d\u306b\u3001a \u304c\u533a\u9593\u5185\u306b\u51fa\u73fe\u3057\u3066\u3044\u305f\u56de\u6570\n        let k = self.ct[a];\n\n        // a \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u306f1\u56de\u5897\u3048\u308b\u3002\n        self.ct[a] += 1;\n\n        // \u300ck \u56de\u51fa\u73fe\u3059\u308b\u6570\u5024\u300d\u306f a \u304c\u6d88\u3048\u30661\u6e1b\u308a\u3001(k + 1) \u56de\u3003\u306fa\u304c\u52a0\u308f\u3063\u30661\u5897\u3048\u308b\u3002\n        self.sz[k] -= 1;\n        self.sz[k + 1] += 1;\n    }\n\n    // \u4e0a\u3068\u540c\u69d8\u3002a\u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u306f\u6e1b\u308b\u3002\n    pub fn pl(&mut self) {\n        // self.inspect();\n        let a = self.a[self.L as usize];\n\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] -= 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.L += 1;\n    }\n\n    pub fn mr(&mut self) {\n        // self.inspect();\n        assert!(self.R >= 0);\n        let R = self.R as usize;\n\n        let a = self.a[R];\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] -= 1;\n        self.sz[self.ct[a]] += 1;\n\n        self.R -= 1;\n    }\n\n    pub fn ml(&mut self) {\n        // self.inspect();\n        assert!(self.L >= 1);\n        self.L -= 1;\n\n        let a = self.a[self.L as usize];\n        self.sz[self.ct[a]] -= 1;\n        self.ct[a] += 1;\n        self.sz[self.ct[a]] += 1;\n    }\n\n    fn update(&mut self, i: usize, x: usize, y: usize) {\n        // i \u756a\u76ee\u306e\u8981\u7d20\u3092 x \u304b\u3089 y\u306b\u5909\u66f4\u3059\u308b\n        assert!(self.a[i] == x);\n\n        if self.in_focus(i) {\n            // x \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u304c\u6e1b\u308b\n            let a = self.a[i];\n            self.sz[self.ct[a]] -= 1;\n            self.ct[a] -= 1;\n            self.sz[self.ct[a]] += 1;\n        }\n\n        self.a[i] = y;\n\n        if self.in_focus(i) {\n            // y \u306e\u51fa\u73fe\u3059\u308b\u56de\u6570\u304c\u6e1b\u308b\n            let a = self.a[i];\n            self.sz[self.ct[a]] -= 1;\n            self.ct[a] += 1;\n            self.sz[self.ct[a]] += 1;\n        }\n    }\n\n    // T += 1\n    pub fn pt(&mut self) {\n        // self.inspect();\n        self.T += 1;\n        let Query { t: i, x, y } = self.ch_query[self.T as usize];\n        self.update(i, x, y);\n    }\n\n    /// T -= 1\n    pub fn mt(&mut self) {\n        // self.inspect();\n        let Query { t: i, x, y } = self.ch_query[self.T as usize];\n        self.update(i, y, x);\n        self.T -= 1;\n    }\n\n    /// \u6307\u5b9a\u3055\u308c\u305f\u4f4d\u7f6e\u304c\u73fe\u5728\u306e\u533a\u9593\u306b\u542b\u307e\u308c\u3066\u3044\u308b\u304b\uff1f\n    pub fn in_focus(&self, i: usize) -> bool {\n        self.L <= i as isize && i as isize <= self.R\n    }\n\n    /// \u73fe\u5728\u306e\u533a\u9593\u306e mex \u3092\u8a08\u7b97\u3059\u308b\u3002O(\u221aN)\n    pub fn mex(&self) -> usize {\n        let mut k = 1;\n        loop {\n            if self.sz[k] == 0 {\n                return k;\n            }\n            k += 1;\n        }\n    }\n\n    pub fn entry_point(mut self, A: Vec<i64>, Q: Vec<(i32, i64, i64)>) -> Vec<usize> {\n        let mut compressor = HashMap::with_capacity(N);\n        let mut sigma = |a: i64| {\n            let m = compressor.len();\n            let e = compressor.entry(a).or_insert(m);\n            *e\n        };\n\n        let A = A.iter().map(|&a| sigma(a)).vec();\n        self.a = A.clone();\n        let mut TA = A;\n\n        for i in 0..Q.len() {\n            let (t, l, r) = Q[i];\n\n            if t == 1 {\n                let l = (l - 1) as usize;\n                let r = (r - 1) as usize;\n\n                self.mex_query.push(Query {\n                    t: self.ch_query.len(),\n                    x: l,\n                    y: r,\n                });\n            } else {\n                let l = (l - 1) as usize;\n                let (x, y) = (TA[l], sigma(r));\n                self.ch_query.push(Query {\n                    t: l as usize,\n                    x: x,\n                    y: y,\n                });\n                TA[l] = y;\n            }\n        }\n\n        // \u30d6\u30ed\u30c3\u30af\u3054\u3068\u306b\u30af\u30a8\u30ea\u30fc\u3092\u5206\u985e\n        let M = self.mex_query.len();\n        for qi in 0..M {\n            let Query { t, x, y } = self.mex_query[qi];\n            let (i, j) = (t / SZ, x / SZ);\n            self.mx[i][j].insert((y, qi));\n        }\n\n        let mut answers = vec![0; M];\n\n        for i in 0..B {\n            for j in 0..B {\n                let mx = std::mem::replace(&mut self.mx[i][j], HashSet::default());\n                for (_, qi) in mx {\n                    let Query { t, x: l, y: r } = self.mex_query[qi];\n\n                    // (T, L, R) \u3092\u4e0e\u3048\u3089\u308c\u305f (t, l, r) \u306b\u8fd1\u3065\u3051\u3066\u3044\u304f\u3002\n\n                    while self.L > l as isize {\n                        self.ml();\n                    }\n                    while self.R < r as isize {\n                        self.pr();\n                    }\n                    while self.L < l as isize {\n                        self.pl();\n                    }\n                    while self.R > r as isize {\n                        self.mr();\n                    }\n                    while ((self.T + 1) as usize) < t {\n                        self.pt();\n                    }\n                    while ((self.T + 1) as usize) > t {\n                        self.mt();\n                    }\n\n                    // assert!(\n                    //     (self.T + 1) as usize == t && self.L == l as isize && self.R == r as isize\n                    // );\n\n                    // debug!(self.T, self.L, self.R, &self.ct[0..5], &self.sz[0..5]);\n\n                    answers[qi] = self.mex();\n                }\n            }\n        }\n\n        answers\n    }\n}\n\npub fn main() {\n    let (_, QN) = read!(usize, usize);\n    let A = read![[i64]];\n    let Q = read![i32, i64, i64; QN];\n\n    let answers = Solver::new().entry_point(A, Q);\n    for mex in answers {\n        println!(\""{}\"", mex);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_sample1() {\n        let M = 10;\n        let QN = 4;\n        let A = vec![1, 2, 3, 1, 1, 2, 2, 2, 9, 9];\n        let Q = vec![(1, 1, 1), (1, 2, 8), (2, 7, 1), (1, 2, 8)];\n        let answer = Solver::new().entry_point(A, Q);\n        assert_eq!(answer, vec![2, 3, 2]);\n    }\n\n    #[test]\n    fn test() {\n        let M = 100;\n        let QN = 10;\n        let A = (0..N).map(|i| (i * i * i % 17 + 1) as i64).vec();\n        let Q = (0..QN)\n            .map(|i| {\n                let l = (i * i * i % M) as i64;\n                let r = (l + (M - l) / 2) as i64;\n                let t = (i % 2) as i32;\n                (t + 1, l + 1, r + 1)\n            })\n            .vec();\n\n        let answer = Solver::new().entry_point(A, Q);\n        assert_eq!(answer, vec![]);\n    }\n}\n\n// problem\n// http://codeforces.com/contest/940/problem/F\n\n// ref [CF 940 F - Machine Learning - \u88cf\u7d19](http://imulan.hatenablog.jp/entry/2018/03/22/182619)\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""7ecc0a9b8ce26b7eb92f7fd1dc8658c1"", ""src_uid"": ""eb6362941b5186d20721c99fb4808d52"", ""difficulty"": 2600}
{""lang"": ""Rust"", ""source_code"": ""//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n//\n\n// \u6642\u7a7a\u9593Mo\n// \u5e45N, \u6c42\u5024X, \u66f4\u65b0Y \u3068\u7f6e\u304f\n// \u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u3092B\u3068\u3057\u305f\u3068\u304d\u306e\u8a08\u7b97\u91cf\u306f\uff1f\n//\n// 1/2 \u3068\u304b\u7121\u8996\u3057\u3066\n//\n// \u66f4\u65b0\u56de\u6570: (N / B) ^ 2 * Y\n// \u30dd\u30a4\u30f3\u30bf\u3092\u52d5\u304b\u3059\u56de\u6570 X * B\n//\n// \u521d\u671f\u5316\u306e\u8a08\u7b97\u91cf\u3082\u3044\u308b\uff1f (N / B) ^ 2 * N\n// dF/dB = X - (1 / 2) * (N^2 * Y + N^3) / B^3\n//       = (2 * X * B^3 - (N^2 * Y + N^3)) / B^3\n// 2\u306e\u9805\u3092\u7121\u8996\u3057\u3066\uff1f\n// B = ((N^2 * Y + N^3) / X) ^ (2 / 3)\n// X = Y = Q\n// B = (N^2 + N^3 / Q) ^ (2 / 3)\n\nuse std::io::Write;\n\nstruct State {\n    cnt: Vec<usize>,\n    elem: Vec<usize>,\n    mex: usize,\n}\n\nimpl State {\n    fn new(n: usize) -> Self {\n        let mut state = State {\n            cnt: vec![0; n + 1],\n            elem: vec![0; n + 1],\n            mex: 0,\n        };\n        state.init();\n        state\n    }\n    fn init(&mut self) {\n        let len = self.cnt.len();\n        self.cnt.clear();\n        self.cnt.resize(len, 0);\n        self.elem.clear();\n        self.elem.resize(len, 0);\n        self.elem[0] = len;\n        self.mex = 1;\n    }\n    fn insert(&mut self, x: usize) {\n        let c = &mut self.cnt[x];\n        self.elem[*c] -= 1;\n        *c += 1;\n        self.elem[*c] += 1;\n        let p = &mut self.mex;\n        if self.elem[*c - 1] == 0 && *c - 1 < *p {\n            *p = *c - 1;\n        } else if *c == *p {\n            *p += 1;\n        }\n    }\n    fn delete(&mut self, x: usize) {\n        let c = &mut self.cnt[x];\n        self.elem[*c] -= 1;\n        *c -= 1;\n        self.elem[*c] += 1;\n        let p = &mut self.mex;\n        if self.elem[*c + 1] == 0 && *c + 1 < *p {\n            *p = *c + 1;\n        } else if *c == *p {\n            *p += 1;\n        }\n    }\n    fn find(&self) -> usize {\n        self.mex\n    }\n}\n\nfn run() {\n    input! {\n        n: usize,\n        q: usize,\n        a: [usize; n],\n        ask: [(u8, usize1, usize); q],\n    }\n    let mut z = a.clone();\n    for &(_, _, x) in ask.iter().filter(|p| p.0 == 2) {\n        z.push(x);\n    }\n    z.sort();\n    z.dedup();\n    let mut a = a;\n    for a in a.iter_mut() {\n        *a = z.binary_search(a).unwrap();\n    }\n    let mut ask = ask;\n    for p in ask.iter_mut().filter(|p| p.0 == 2) {\n        p.2 = z.binary_search(&p.2).unwrap();\n    }\n    let batch = {\n        1000\n        /*\n        let n = n as f64;\n        let q = q as f64;\n        (n.powi(2) + n.powi(3) / q).cbrt().powi(2) as usize\n        */\n    };\n    let mut update = vec![];\n    let mut query = vec![vec![vec![]; n / batch + 1]; n / batch + 1];\n    for (i, (op, a, b)) in ask.into_iter().enumerate() {\n        if op == 1 {\n            query[a / batch][b / batch].push((a, b, i));\n        } else {\n            update.push((a, b, i));\n        }\n    }\n    let mut ans = vec![0; q];\n    let mut state = State::new(z.len() + n);\n    for (i, q) in query.iter().enumerate() {\n        for q in q.iter() {\n            if q.is_empty() {\n                continue;\n            }\n            state.init();\n            let mut a = a.clone();\n            let mut x = i * batch;\n            let mut y = i * batch;\n            let mut z = 0;\n            for &(l, r, k) in q.iter() {\n                while z < update.len() && update[z].2 < k {\n                    let p = update[z].0;\n                    let v = update[z].1;\n                    if x <= p && p < y {\n                        state.delete(a[p]);\n                        state.insert(v);\n                    }\n                    a[p] = v;\n                    z += 1;\n                }\n                while l < x {\n                    x -= 1;\n                    state.insert(a[x]);\n                }\n                while y < r {\n                    state.insert(a[y]);\n                    y += 1;\n                }\n                while x < l {\n                    state.delete(a[x]);\n                    x += 1;\n                }\n                while r < y {\n                    y -= 1;\n                    state.delete(a[y]);\n                }\n                ans[k] = state.find();\n            }\n        }\n    }\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for a in ans {\n        if a > 0 {\n            writeln!(out, \""{}\"", a).ok();\n        }\n    }\n}\n\nfn main() {\n    run();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""93a973a1160160130a4a351b36fa2ce0"", ""src_uid"": ""eb6362941b5186d20721c99fb4808d52"", ""difficulty"": 2600}
{""lang"": ""Rust"", ""source_code"": ""//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n//\n\n// \u6642\u7a7a\u9593Mo\n// \u5e45N, \u6c42\u5024X, \u66f4\u65b0Y \u3068\u7f6e\u304f\n// \u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u3092B\u3068\u3057\u305f\u3068\u304d\u306e\u8a08\u7b97\u91cf\u306f\uff1f\n//\n// 1/2 \u3068\u304b\u7121\u8996\u3057\u3066\n//\n// \u66f4\u65b0\u56de\u6570: (N / B) ^ 2 * Y\n// \u30dd\u30a4\u30f3\u30bf\u3092\u52d5\u304b\u3059\u56de\u6570 X * B\n//\n// \u521d\u671f\u5316\u306e\u8a08\u7b97\u91cf\u3082\u3044\u308b\uff1f (N / B) ^ 2 * N\n// dF/dB = X - (1 / 2) * (N^2 * Y + N^3) / B^3\n//       = (2 * X * B^3 - (N^2 * Y + N^3)) / B^3\n// 2\u306e\u9805\u3092\u7121\u8996\u3057\u3066\uff1f\n// B = ((N^2 * Y + N^3) / X) ^ (2 / 3)\n// X = Y = Q\n// B = (N^2 + N^3 / Q) ^ (2 / 3)\n\nuse std::io::Write;\n\nstruct State {\n    cnt: Vec<usize>,\n    elem: Vec<usize>,\n    mex: usize,\n}\n\nimpl State {\n    fn new(n: usize) -> Self {\n        let mut state = State {\n            cnt: vec![0; n + 1],\n            elem: vec![0; n + 1],\n            mex: 0,\n        };\n        state.init();\n        state\n    }\n    fn init(&mut self) {\n        let len = self.cnt.len();\n        self.cnt.clear();\n        self.cnt.resize(len, 0);\n        self.elem.clear();\n        self.elem.resize(len, 0);\n        self.elem[0] = len;\n        self.mex = 1;\n    }\n    fn insert(&mut self, x: usize) {\n        let c = &mut self.cnt[x];\n        self.elem[*c] -= 1;\n        *c += 1;\n        self.elem[*c] += 1;\n        let p = &mut self.mex;\n        if self.elem[*c - 1] == 0 && *c - 1 < *p {\n            *p = *c - 1;\n        }\n        while self.elem[*p] > 0 {\n            *p += 1;\n        }\n    }\n    fn delete(&mut self, x: usize) {\n        let c = &mut self.cnt[x];\n        self.elem[*c] -= 1;\n        *c -= 1;\n        self.elem[*c] += 1;\n        let p = &mut self.mex;\n        if self.elem[*c + 1] == 0 && *c + 1 < *p {\n            *p = *c + 1;\n        }\n        while self.elem[*p] > 0 {\n            *p += 1;\n        }\n    }\n    fn find(&self) -> usize {\n        self.mex\n    }\n}\n\nfn run() {\n    input! {\n        n: usize,\n        q: usize,\n        a: [usize; n],\n        ask: [(u8, usize1, usize); q],\n    }\n    let mut z = a.clone();\n    for &(_, _, x) in ask.iter().filter(|p| p.0 == 2) {\n        z.push(x);\n    }\n    z.sort();\n    z.dedup();\n    let mut a = a;\n    for a in a.iter_mut() {\n        *a = z.binary_search(a).unwrap();\n    }\n    let mut ask = ask;\n    for p in ask.iter_mut().filter(|p| p.0 == 2) {\n        p.2 = z.binary_search(&p.2).unwrap();\n    }\n    let batch = {\n        let n = n as f64;\n        (n.powi(2) * 8.0).cbrt().ceil() as usize\n    };\n    let mut update = vec![];\n    let mut query = vec![vec![vec![]; n / batch + 1]; n / batch + 1];\n    for (i, (op, a, b)) in ask.into_iter().enumerate() {\n        if op == 1 {\n            query[a / batch][b / batch].push((a, b, i));\n        } else {\n            update.push((a, b, i));\n        }\n    }\n    let mut ans = vec![0; q];\n    let mut state = State::new(z.len() + n);\n    for (i, q) in query.iter().enumerate() {\n        for q in q.iter() {\n            if q.is_empty() {\n                continue;\n            }\n            state.init();\n            let mut a = a.clone();\n            let mut x = i * batch;\n            let mut y = i * batch;\n            let mut z = 0;\n            for &(l, r, k) in q.iter() {\n                while z < update.len() && update[z].2 < k {\n                    let p = update[z].0;\n                    let v = update[z].1;\n                    if x <= p && p < y {\n                        state.delete(a[p]);\n                        state.insert(v);\n                    }\n                    a[p] = v;\n                    z += 1;\n                }\n                while l < x {\n                    x -= 1;\n                    state.insert(a[x]);\n                }\n                while y < r {\n                    state.insert(a[y]);\n                    y += 1;\n                }\n                while x < l {\n                    state.delete(a[x]);\n                    x += 1;\n                }\n                while r < y {\n                    y -= 1;\n                    state.delete(a[y]);\n                }\n                ans[k] = state.find();\n            }\n        }\n    }\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for a in ans {\n        if a > 0 {\n            writeln!(out, \""{}\"", a).ok();\n        }\n    }\n}\n\nfn main() {\n    run();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""89fa5b8e8b4d76ecf2c4367f51dd58db"", ""src_uid"": ""eb6362941b5186d20721c99fb4808d52"", ""difficulty"": 2600}
{""lang"": ""Rust"", ""source_code"": ""//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n//\n\n// \u6642\u7a7a\u9593Mo\n// \u5e45N, \u6c42\u5024X, \u66f4\u65b0Y \u3068\u7f6e\u304f\n// \u30d6\u30ed\u30c3\u30af\u30b5\u30a4\u30ba\u3092B\u3068\u3057\u305f\u3068\u304d\u306e\u8a08\u7b97\u91cf\u306f\uff1f\n//\n// 1/2 \u3068\u304b\u7121\u8996\u3057\u3066\n//\n// \u66f4\u65b0\u56de\u6570: (N / B) ^ 2 * Y\n// \u30dd\u30a4\u30f3\u30bf\u3092\u52d5\u304b\u3059\u56de\u6570 X * B\n//\n// \u521d\u671f\u5316\u306e\u8a08\u7b97\u91cf\u3082\u3044\u308b\uff1f (N / B) ^ 2 * N\n// dF/dB = X - (1 / 2) * (N^2 * Y + N^3) / B^3\n//       = (2 * X * B^3 - (N^2 * Y + N^3)) / B^3\n// 2\u306e\u9805\u3092\u7121\u8996\u3057\u3066\uff1f\n// B = ((N^2 * Y + N^3) / X) ^ (2 / 3)\n// X = Y = Q\n// B = (N^2 + N^3 / Q) ^ (2 / 3)\n\nuse std::io::Write;\n\nstruct State {\n    cnt: Vec<usize>,\n    elem: Vec<usize>,\n    mex: usize,\n}\n\nimpl State {\n    fn new(n: usize) -> Self {\n        let mut state = State {\n            cnt: vec![0; n + 1],\n            elem: vec![0; n + 1],\n            mex: 0,\n        };\n        state.init();\n        state\n    }\n    fn init(&mut self) {\n        let len = self.cnt.len();\n        self.cnt.clear();\n        self.cnt.resize(len, 0);\n        self.elem.clear();\n        self.elem.resize(len, 0);\n        self.elem[0] = len;\n        self.mex = 1;\n    }\n    fn insert(&mut self, x: usize) {\n        let c = &mut self.cnt[x];\n        self.elem[*c] -= 1;\n        *c += 1;\n        self.elem[*c] += 1;\n        let p = &mut self.mex;\n        if self.elem[*c - 1] == 0 && *c - 1 < *p {\n            *p = *c - 1;\n        }\n        while self.elem[*p] > 0 {\n            *p += 1;\n        }\n    }\n    fn delete(&mut self, x: usize) {\n        let c = &mut self.cnt[x];\n        self.elem[*c] -= 1;\n        *c -= 1;\n        self.elem[*c] += 1;\n        let p = &mut self.mex;\n        if self.elem[*c + 1] == 0 && *c + 1 < *p {\n            *p = *c + 1;\n        }\n        while self.elem[*p] > 0 {\n            *p += 1;\n        }\n    }\n    fn find(&self) -> usize {\n        self.mex\n    }\n}\n\nfn run() {\n    input! {\n        n: usize,\n        q: usize,\n        a: [usize; n],\n        ask: [(u8, usize1, usize); q],\n    }\n    let mut z = a.clone();\n    for &(_, _, x) in ask.iter().filter(|p| p.0 == 2) {\n        z.push(x);\n    }\n    z.sort();\n    z.dedup();\n    let mut a = a;\n    for a in a.iter_mut() {\n        *a = z.binary_search(a).unwrap();\n    }\n    let mut ask = ask;\n    for p in ask.iter_mut().filter(|p| p.0 == 2) {\n        p.2 = z.binary_search(&p.2).unwrap();\n    }\n    let batch = {\n        2154\n        /*\n        let n = n as f64;\n        let q = q as f64;\n        (n.powi(2) + n.powi(3) / q).cbrt().powi(2) as usize\n        */\n    };\n    let mut update = vec![];\n    let mut query = vec![vec![vec![]; n / batch + 1]; n / batch + 1];\n    for (i, (op, a, b)) in ask.into_iter().enumerate() {\n        if op == 1 {\n            query[a / batch][b / batch].push((a, b, i));\n        } else {\n            update.push((a, b, i));\n        }\n    }\n    let mut ans = vec![0; q];\n    let mut state = State::new(z.len() + n);\n    for (i, q) in query.iter().enumerate() {\n        for q in q.iter() {\n            if q.is_empty() {\n                continue;\n            }\n            state.init();\n            let mut a = a.clone();\n            let mut x = i * batch;\n            let mut y = i * batch;\n            let mut z = 0;\n            for &(l, r, k) in q.iter() {\n                while z < update.len() && update[z].2 < k {\n                    let p = update[z].0;\n                    let v = update[z].1;\n                    if x <= p && p < y {\n                        state.delete(a[p]);\n                        state.insert(v);\n                    }\n                    a[p] = v;\n                    z += 1;\n                }\n                while l < x {\n                    x -= 1;\n                    state.insert(a[x]);\n                }\n                while y < r {\n                    state.insert(a[y]);\n                    y += 1;\n                }\n                while x < l {\n                    state.delete(a[x]);\n                    x += 1;\n                }\n                while r < y {\n                    y -= 1;\n                    state.delete(a[y]);\n                }\n                ans[k] = state.find();\n            }\n        }\n    }\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for a in ans {\n        if a > 0 {\n            writeln!(out, \""{}\"", a).ok();\n        }\n    }\n}\n\nfn main() {\n    run();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""cf551eff198b533729c493e16a085969"", ""src_uid"": ""eb6362941b5186d20721c99fb4808d52"", ""difficulty"": 2600}
{""lang"": ""Rust"", ""source_code"": ""use std::io;\n\n\nfn main() {\n    let (_, k) = {\n        let i = read::<usize>();\n        (i[0], i[1])\n    };\n    let mut an = read::<usize>();\n    an.sort();\n\n    let ans = if k == 0 { an[0] - 1 } else { an[k - 1] };\n\n    let mut cnt = 0;\n    for a in an {\n        if a <= ans { cnt += 1; }\n    }\n\n    if cnt != k || !(1 <= ans && ans <= 10e9 as usize) {\n        println!(\""-1\""); return;\n    }\n    println!(\""{}\"", ans);\n}\n\n\n#[allow(dead_code)]\nfn read<T>() -> Vec<T>\nwhere T:\nstd::str::FromStr,\nT::Err: std::fmt::Debug {\n\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf).unwrap();\n    buf.split_whitespace()\n        .map(|s| s.trim().parse().unwrap())\n        .collect()\n}\n\n#[allow(dead_code)]\nfn read_one<T>() -> T\nwhere T:\nstd::str::FromStr,\nT::Err: std::fmt::Debug {\n\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf).unwrap();\n    buf.trim().parse().unwrap()\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""0d195fa54637b168f210a8b2b619a10c"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""//spnauti-rusT\nuse std::io::*;\nuse std::str::{self,*};\nuse std::fmt::Debug;\n#[allow(unused_imports)] use std::cmp::Ordering::{self,*};\n#[allow(unused_imports)] use std::ops::{self,*};\n#[allow(unused_imports)] use std::iter::{self,*};\n#[allow(unused_imports)] use std::collections::*;\n#[allow(unused_macros)]\nmacro_rules! m {\n    ($c:tt, $x:expr, $y:expr) => {{\n        let b = $y; let a = &mut $x;\n        if b $c *a { *a = b; true } else { false }\n    }};\n}\n#[allow(unused_macros)]\nmacro_rules! l {\n    ($($v:ident),* = $i:ident.$f:ident $a:tt) => {\n        $( let $v = $i.$f$a; )*\n    };\n    ($($v:ident),*:$t:ty = $i:ident.$f:ident $a:tt) => {\n        $( let $v:$t = $i.$f$a; )*\n    };\n}\nstruct WordReader<'a> { it : SplitAsciiWhitespace<'a> }\n#[allow(dead_code)]\nimpl<'a> WordReader<'a> {\n    fn new<T: Read>(b: &mut String, mut r: T) -> WordReader {\n        b.clear();\n        r.read_to_string(b).ok();\n        WordReader { it: b.split_ascii_whitespace() }\n    }\n    fn from_stdin(b: &mut String) -> WordReader {\n        WordReader::new(b, stdin())\n    }\n    fn sl(&mut self) ->  &str { self.it.next().unwrap() }\n    fn bs(&mut self) -> &[u8] { self.sl().as_bytes()    }\n    fn s(&mut self) -> String { String::from(self.sl()) }\n    fn i(&mut self) ->    i32 { self.p()                }\n    fn f(&mut self) ->    f64 { self.p()                }\n    fn u(&mut self) ->  usize { self.p()                }\n    fn sk(&mut self, n: usize) { self.it.nth(n - 1); }\n    fn ii(&mut self, n: usize) -> impl Iterator<Item=i32> {\n        self.ip(n).into_iter()\n    }\n    fn vi(&mut self, n: usize) -> Vec<i32> {\n        self.vp::<i32>(n)\n    }\n    fn p<T: FromStr>(&mut self) -> T where T::Err: Debug {\n        self.sl().parse::<T>().unwrap()\n    }\n    fn ip<T: FromStr>(&mut self, n: usize) -> impl Iterator<Item=T> where T::Err: Debug {\n        self.vp(n).into_iter()\n    }\n    fn vp<T: FromStr>(&mut self, n: usize) -> Vec<T> where T::Err: Debug {\n        (0..n).map(|_| self.p()).collect()\n    }\n}\n//------------------- End rusT\n\nfn main() {\n    let mut bin = String::new();\n    let mut input = WordReader::from_stdin(&mut bin);\n\n    let n = input.u();\n    let k = input.u();\n    let mut a = input.vi(n);\n    a.sort();\n    if (k == 0 && a[0] == 1) || (k < n && a[k - 1] == a[k]) {\n        println!(\""-1\"");\n    } else if k == 0{\n        println!(\""1\"");\n    } else {\n        println!(\""{}\"", a[k - 1]);\n    }\n}\n\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""794415695fbf8b1b4f9f695e6a00d844"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""//spnauti-rusT\nuse std::io::*;\nuse std::str::{self,*};\nuse std::fmt::Debug;\n#[allow(unused_imports)] use std::cmp::Ordering::{self,*};\n#[allow(unused_imports)] use std::ops::{self,*};\n#[allow(unused_imports)] use std::iter::{self,*};\n#[allow(unused_imports)] use std::collections::*;\n#[allow(unused_macros)]\nmacro_rules! m {\n    ($c:tt, $x:expr, $y:expr) => {{\n        let b = $y; let a = &mut $x;\n        if b $c *a { *a = b; true } else { false }\n    }};\n}\n#[allow(unused_macros)]\nmacro_rules! l {\n    ($($v:ident),* = $i:ident.$f:ident $a:tt) => {\n        $( let $v = $i.$f$a; )*\n    };\n    ($($v:ident),*:$t:ty = $i:ident.$f:ident $a:tt) => {\n        $( let $v:$t = $i.$f$a; )*\n    };\n}\nstruct WordReader<'a> { it : SplitAsciiWhitespace<'a> }\n#[allow(dead_code)]\nimpl<'a> WordReader<'a> {\n    fn new<T: Read>(b: &mut String, mut r: T) -> WordReader {\n        b.clear();\n        r.read_to_string(b).ok();\n        WordReader { it: b.split_ascii_whitespace() }\n    }\n    fn from_stdin(b: &mut String) -> WordReader {\n        WordReader::new(b, stdin())\n    }\n    fn sl(&mut self) ->  &str { self.it.next().unwrap() }\n    fn bs(&mut self) -> &[u8] { self.sl().as_bytes()    }\n    fn s(&mut self) -> String { String::from(self.sl()) }\n    fn i(&mut self) ->    i32 { self.p()                }\n    fn f(&mut self) ->    f64 { self.p()                }\n    fn u(&mut self) ->  usize { self.p()                }\n    fn sk(&mut self, n: usize) { self.it.nth(n - 1); }\n    fn ii(&mut self, n: usize) -> impl Iterator<Item=i32> {\n        self.ip(n).into_iter()\n    }\n    fn vi(&mut self, n: usize) -> Vec<i32> {\n        self.vp::<i32>(n)\n    }\n    fn p<T: FromStr>(&mut self) -> T where T::Err: Debug {\n        self.sl().parse::<T>().unwrap()\n    }\n    fn ip<T: FromStr>(&mut self, n: usize) -> impl Iterator<Item=T> where T::Err: Debug {\n        self.vp(n).into_iter()\n    }\n    fn vp<T: FromStr>(&mut self, n: usize) -> Vec<T> where T::Err: Debug {\n        (0..n).map(|_| self.p()).collect()\n    }\n}\n//------------------- End rusT\n\nfn main() {\n    let mut bin = String::new();\n    let mut input = WordReader::from_stdin(&mut bin);\n\n    let n = input.u();\n    let k = input.u();\n    let mut a = input.vi(n);\n    a.sort();\n    if (k == 0 && a[0] == 1) || (k > 0 && k < n && a[k - 1] == a[k]) {\n        println!(\""-1\"");\n    } else if k == 0 {\n        println!(\""1\"");\n    } else {\n        println!(\""{}\"", a[k - 1]);\n    }\n}\n\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""aa5c9f4696b075de7aa32cd4d6a85563"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(dead_code)]\n#![allow(unused_labels)]\n\nuse std::char::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::*;\nuse std::str::FromStr;\n\nmacro_rules! debug {($($a:expr),*) => {eprintln!(concat!($(stringify!($a), \"" = {:?}, \""),*), $($a),*);}}\nmacro_rules! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; let mut next = || { iter . next ( ) . unwrap ( ) } ; input_inner ! { next , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let mut bytes = std :: io :: Read :: bytes ( std :: io :: BufReader :: new ( stdin . lock ( ) ) ) ; let mut next = move || -> String { bytes . by_ref ( ) . map ( | r | r . unwrap ( ) as char ) . skip_while ( | c | c . is_whitespace ( ) ) . take_while ( | c |! c . is_whitespace ( ) ) . collect ( ) } ; input_inner ! { next , $ ( $ r ) * } } ; }\nmacro_rules! input_inner { ( $ next : expr ) => { } ; ( $ next : expr , ) => { } ; ( $ next : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ next , $ t ) ; input_inner ! { $ next $ ( $ r ) * } } ; }\nmacro_rules! read_value { ( $ next : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ next , $ t ) ) ,* ) } ; ( $ next : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ next , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ next : expr , chars ) => { read_value ! ( $ next , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ next : expr , usize1 ) => { read_value ! ( $ next , usize ) - 1 } ; ( $ next : expr , $ t : ty ) => { $ next ( ) . parse ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\n\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\""failed to read char\"") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\""failed to parse token\"")\n}\n\nuse std::f64;\n\nfn min<T: PartialOrd>(a:T, b:T) -> T {\n    if a < b { a }\n    else { b }\n}\n\nfn max<T: PartialOrd>(a:T, b:T) -> T {\n    if a < b { b }\n    else { a }\n}\n\nconst MAX:usize = 30;\nconst INF:i64 = std::i64::MAX;\nconst MOD:i64 = 1e9 as i64 + 7;\n\nstruct Graph {\n    e: Vec<Vec<usize>>,\n    v: Vec<usize>,\n    u: Vec<usize>,\n    f: Vec<bool>,\n    c: i64,\n    vc: Vec<i64>,\n}\n\nimpl Graph {\n    fn new(n:usize) -> Self {\n        Graph {\n            e: vec![vec![];n],\n            v: vec![],\n            u: vec![n;n],\n            f: vec![false;n],\n            c: 0,\n            vc: vec![0;n],\n        }\n    }\n\n    fn dfs(&mut self, crt: usize) {\n        if self.f[crt] { return; }\n        self.c += 1;\n        self.f[crt] = true;\n        self.v.push(crt);\n        self.vc[crt] = self.c;\n        self.u[crt] = self.v.len()-1;\n        for i in 0..self.e[crt].len() {\n            self.dfs(self.e[crt][i]);\n        }\n        //debug!(crt, self.c, self.vc[crt]);\n        self.vc[crt] = self.c - self.vc[crt];\n    }\n}\n\nfn binary_search(s: &Vec<i64>, v:i64) -> usize {\n    let mut left = 0;\n    let mut right = s.len();\n\n    while right-left > 1 {\n        let mid = (right+left)/2;\n        //debug!(left,mid,right,s[mid]);\n        if s[mid] < v { left = mid; }\n        else { right = mid; }\n    }\n    left\n}\n\nfn main() {\n    //let t:usize = read();\n\n    //'outer: for _ in 0..t {\n        let n:usize = read();\n        let k:usize = read();\n        let mut a:Vec<i64> = (0..n).map(|_| read()).collect();\n\n        a.sort();\n\n        if a[k-1] == a[k] {\n            println!(\""-1\"");\n        } else {\n            println!(\""{}\"", a[k-1]);\n        }\n\n    //}\n}\n\n/*\n\n\n*/\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""c9f5ff0d0176504510b4c0b39d298576"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(dead_code)]\n#![allow(unused_labels)]\n\nuse std::char::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::*;\nuse std::str::FromStr;\n\nmacro_rules! debug {($($a:expr),*) => {eprintln!(concat!($(stringify!($a), \"" = {:?}, \""),*), $($a),*);}}\nmacro_rules! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; let mut next = || { iter . next ( ) . unwrap ( ) } ; input_inner ! { next , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let mut bytes = std :: io :: Read :: bytes ( std :: io :: BufReader :: new ( stdin . lock ( ) ) ) ; let mut next = move || -> String { bytes . by_ref ( ) . map ( | r | r . unwrap ( ) as char ) . skip_while ( | c | c . is_whitespace ( ) ) . take_while ( | c |! c . is_whitespace ( ) ) . collect ( ) } ; input_inner ! { next , $ ( $ r ) * } } ; }\nmacro_rules! input_inner { ( $ next : expr ) => { } ; ( $ next : expr , ) => { } ; ( $ next : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ next , $ t ) ; input_inner ! { $ next $ ( $ r ) * } } ; }\nmacro_rules! read_value { ( $ next : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ next , $ t ) ) ,* ) } ; ( $ next : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ next , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ next : expr , chars ) => { read_value ! ( $ next , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ next : expr , usize1 ) => { read_value ! ( $ next , usize ) - 1 } ; ( $ next : expr , $ t : ty ) => { $ next ( ) . parse ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\n\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\""failed to read char\"") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\""failed to parse token\"")\n}\n\nuse std::f64;\n\nfn min<T: PartialOrd>(a:T, b:T) -> T {\n    if a < b { a }\n    else { b }\n}\n\nfn max<T: PartialOrd>(a:T, b:T) -> T {\n    if a < b { b }\n    else { a }\n}\n\nconst MAX:usize = 30;\nconst INF:i64 = std::i64::MAX;\nconst MOD:i64 = 1e9 as i64 + 7;\n\nstruct Graph {\n    e: Vec<Vec<usize>>,\n    v: Vec<usize>,\n    u: Vec<usize>,\n    f: Vec<bool>,\n    c: i64,\n    vc: Vec<i64>,\n}\n\nimpl Graph {\n    fn new(n:usize) -> Self {\n        Graph {\n            e: vec![vec![];n],\n            v: vec![],\n            u: vec![n;n],\n            f: vec![false;n],\n            c: 0,\n            vc: vec![0;n],\n        }\n    }\n\n    fn dfs(&mut self, crt: usize) {\n        if self.f[crt] { return; }\n        self.c += 1;\n        self.f[crt] = true;\n        self.v.push(crt);\n        self.vc[crt] = self.c;\n        self.u[crt] = self.v.len()-1;\n        for i in 0..self.e[crt].len() {\n            self.dfs(self.e[crt][i]);\n        }\n        //debug!(crt, self.c, self.vc[crt]);\n        self.vc[crt] = self.c - self.vc[crt];\n    }\n}\n\nfn binary_search(s: &Vec<i64>, v:i64) -> usize {\n    let mut left = 0;\n    let mut right = s.len();\n\n    while right-left > 1 {\n        let mid = (right+left)/2;\n        //debug!(left,mid,right,s[mid]);\n        if s[mid] < v { left = mid; }\n        else { right = mid; }\n    }\n    left\n}\n\nfn main() {\n    //let t:usize = read();\n\n    //'outer: for _ in 0..t {\n        let n:usize = read();\n        let k:usize = read();\n        let mut a:Vec<i64> = (0..n).map(|_| read()).collect();\n\n        a.sort();\n        if k == 0 {\n            if a[0] == 1 {\n                println!(\""-1\"");\n            } else {\n                println!(\""1\"");\n            }\n            return;\n        }\n        if k == n {\n            println!(\""{}\"", a[k-1]);\n            return;\n        }\n\n        if a[k-1] == a[k] {\n            println!(\""-1\"");\n        } else {\n            println!(\""{}\"", a[k-1]);\n        }\n\n    //}\n}\n\n/*\n\n\n*/\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""a08d9c584e1fc2221b741e30811e84b5"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(dead_code)]\n#![allow(unused_labels)]\n\nuse std::char::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::*;\nuse std::str::FromStr;\n\nmacro_rules! debug {($($a:expr),*) => {eprintln!(concat!($(stringify!($a), \"" = {:?}, \""),*), $($a),*);}}\nmacro_rules! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; let mut next = || { iter . next ( ) . unwrap ( ) } ; input_inner ! { next , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let mut bytes = std :: io :: Read :: bytes ( std :: io :: BufReader :: new ( stdin . lock ( ) ) ) ; let mut next = move || -> String { bytes . by_ref ( ) . map ( | r | r . unwrap ( ) as char ) . skip_while ( | c | c . is_whitespace ( ) ) . take_while ( | c |! c . is_whitespace ( ) ) . collect ( ) } ; input_inner ! { next , $ ( $ r ) * } } ; }\nmacro_rules! input_inner { ( $ next : expr ) => { } ; ( $ next : expr , ) => { } ; ( $ next : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ next , $ t ) ; input_inner ! { $ next $ ( $ r ) * } } ; }\nmacro_rules! read_value { ( $ next : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ next , $ t ) ) ,* ) } ; ( $ next : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ next , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ next : expr , chars ) => { read_value ! ( $ next , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ next : expr , usize1 ) => { read_value ! ( $ next , usize ) - 1 } ; ( $ next : expr , $ t : ty ) => { $ next ( ) . parse ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\n\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\""failed to read char\"") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\""failed to parse token\"")\n}\n\nuse std::f64;\n\nfn min<T: PartialOrd>(a:T, b:T) -> T {\n    if a < b { a }\n    else { b }\n}\n\nfn max<T: PartialOrd>(a:T, b:T) -> T {\n    if a < b { b }\n    else { a }\n}\n\nconst MAX:usize = 30;\nconst INF:i64 = std::i64::MAX;\nconst MOD:i64 = 1e9 as i64 + 7;\n\nstruct Graph {\n    e: Vec<Vec<usize>>,\n    v: Vec<usize>,\n    u: Vec<usize>,\n    f: Vec<bool>,\n    c: i64,\n    vc: Vec<i64>,\n}\n\nimpl Graph {\n    fn new(n:usize) -> Self {\n        Graph {\n            e: vec![vec![];n],\n            v: vec![],\n            u: vec![n;n],\n            f: vec![false;n],\n            c: 0,\n            vc: vec![0;n],\n        }\n    }\n\n    fn dfs(&mut self, crt: usize) {\n        if self.f[crt] { return; }\n        self.c += 1;\n        self.f[crt] = true;\n        self.v.push(crt);\n        self.vc[crt] = self.c;\n        self.u[crt] = self.v.len()-1;\n        for i in 0..self.e[crt].len() {\n            self.dfs(self.e[crt][i]);\n        }\n        //debug!(crt, self.c, self.vc[crt]);\n        self.vc[crt] = self.c - self.vc[crt];\n    }\n}\n\nfn binary_search(s: &Vec<i64>, v:i64) -> usize {\n    let mut left = 0;\n    let mut right = s.len();\n\n    while right-left > 1 {\n        let mid = (right+left)/2;\n        //debug!(left,mid,right,s[mid]);\n        if s[mid] < v { left = mid; }\n        else { right = mid; }\n    }\n    left\n}\n\nfn main() {\n    //let t:usize = read();\n\n    //'outer: for _ in 0..t {\n        let n:usize = read();\n        let k:usize = read();\n        let mut a:Vec<i64> = (0..n).map(|_| read()).collect();\n\n        a.sort();\n        if k == 0 {\n            println!(\""0\"");\n            return;\n        }\n        if k == n {\n            println!(\""{}\"", a[k-1]);\n            return;\n        }\n\n        if a[k-1] == a[k] {\n            println!(\""-1\"");\n        } else {\n            println!(\""{}\"", a[k-1]);\n        }\n\n    //}\n}\n\n/*\n\n\n*/\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""c70ba88514f51b3f143e4ac643e82d1f"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(unused_macros)]\n#![allow(dead_code)]\n#![allow(unused_labels)]\n\nuse std::char::*;\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::*;\nuse std::str::FromStr;\n\nmacro_rules! debug {($($a:expr),*) => {eprintln!(concat!($(stringify!($a), \"" = {:?}, \""),*), $($a),*);}}\nmacro_rules! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; let mut next = || { iter . next ( ) . unwrap ( ) } ; input_inner ! { next , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let mut bytes = std :: io :: Read :: bytes ( std :: io :: BufReader :: new ( stdin . lock ( ) ) ) ; let mut next = move || -> String { bytes . by_ref ( ) . map ( | r | r . unwrap ( ) as char ) . skip_while ( | c | c . is_whitespace ( ) ) . take_while ( | c |! c . is_whitespace ( ) ) . collect ( ) } ; input_inner ! { next , $ ( $ r ) * } } ; }\nmacro_rules! input_inner { ( $ next : expr ) => { } ; ( $ next : expr , ) => { } ; ( $ next : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ next , $ t ) ; input_inner ! { $ next $ ( $ r ) * } } ; }\nmacro_rules! read_value { ( $ next : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ next , $ t ) ) ,* ) } ; ( $ next : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ next , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ next : expr , chars ) => { read_value ! ( $ next , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ next : expr , usize1 ) => { read_value ! ( $ next , usize ) - 1 } ; ( $ next : expr , $ t : ty ) => { $ next ( ) . parse ::<$ t > ( ) . expect ( \""Parse error\"" ) } ; }\n\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\""failed to read char\"") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\""failed to parse token\"")\n}\n\nuse std::f64;\n\nfn min<T: PartialOrd>(a:T, b:T) -> T {\n    if a < b { a }\n    else { b }\n}\n\nfn max<T: PartialOrd>(a:T, b:T) -> T {\n    if a < b { b }\n    else { a }\n}\n\nconst MAX:usize = 30;\nconst INF:i64 = std::i64::MAX;\nconst MOD:i64 = 1e9 as i64 + 7;\n\nstruct Graph {\n    e: Vec<Vec<usize>>,\n    v: Vec<usize>,\n    u: Vec<usize>,\n    f: Vec<bool>,\n    c: i64,\n    vc: Vec<i64>,\n}\n\nimpl Graph {\n    fn new(n:usize) -> Self {\n        Graph {\n            e: vec![vec![];n],\n            v: vec![],\n            u: vec![n;n],\n            f: vec![false;n],\n            c: 0,\n            vc: vec![0;n],\n        }\n    }\n\n    fn dfs(&mut self, crt: usize) {\n        if self.f[crt] { return; }\n        self.c += 1;\n        self.f[crt] = true;\n        self.v.push(crt);\n        self.vc[crt] = self.c;\n        self.u[crt] = self.v.len()-1;\n        for i in 0..self.e[crt].len() {\n            self.dfs(self.e[crt][i]);\n        }\n        //debug!(crt, self.c, self.vc[crt]);\n        self.vc[crt] = self.c - self.vc[crt];\n    }\n}\n\nfn binary_search(s: &Vec<i64>, v:i64) -> usize {\n    let mut left = 0;\n    let mut right = s.len();\n\n    while right-left > 1 {\n        let mid = (right+left)/2;\n        //debug!(left,mid,right,s[mid]);\n        if s[mid] < v { left = mid; }\n        else { right = mid; }\n    }\n    left\n}\n\nfn main() {\n    //let t:usize = read();\n\n    //'outer: for _ in 0..t {\n        let n:usize = read();\n        let k:usize = read();\n        let mut a:Vec<i64> = (0..n).map(|_| read()).collect();\n\n        a.sort();\n        if k == n {\n            println!(\""{}\"", a[k-1]);\n            return;\n        }\n\n        if a[k-1] == a[k] {\n            println!(\""-1\"");\n        } else {\n            println!(\""{}\"", a[k-1]);\n        }\n\n    //}\n}\n\n/*\n\n\n*/\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""5052963af4c57db30abac8de2b25ff20"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""#[allow(dead_code)]\nuse std::cmp::min;\nuse std::collections::HashMap;\nuse std::io;\nuse std::str::FromStr;\nuse std::io::Read;\n\nstruct Input {\n  tokens: <std::vec::Vec<std::string::String> as IntoIterator>::IntoIter,\n  read_all: bool,\n}\n\nimpl Input {\n  pub fn new(read_all: bool) -> Input {\n    if read_all {\n      let mut all = String::new();\n      io::stdin().read_to_string(&mut all).unwrap();\n      let tokens: Vec<String> = all.split_whitespace().map(|s| s.to_string()).collect();\n      Input {\n        tokens: tokens.into_iter(),\n        read_all: true,\n      }\n    } else {\n      Input {\n        tokens: vec!().into_iter(),\n        read_all: false,\n      }\n    }\n  }\n\n  fn refresh_next_line(&mut self) {\n    if self.read_all {\n      panic!();\n    }\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf).unwrap();\n    let tokens: Vec<String> = buf.split_whitespace().map(|s| s.to_string()).collect();\n    self.tokens = tokens.into_iter();\n  }\n\n  fn next_impl(&mut self) -> String {\n    loop {\n      if let Some(next) = self.tokens.next() {\n        return next.to_string();\n      }\n      self.refresh_next_line();\n    }\n  }\n\n  pub fn next<T: FromStr>(&mut self) -> T where <T as std::str::FromStr>::Err: std::fmt::Debug {\n    let next_str = self.next_impl();\n    next_str.parse().unwrap()\n  }\n\n  pub fn next_vec<T: FromStr>(&mut self, len: usize) -> Vec<T> where <T as std::str::FromStr>::Err: std::fmt::Debug {\n    (0..len).map(|_i| self.next()).collect()\n  }\n\n  pub fn next_vec_read_len<T: FromStr>(&mut self) -> Vec<T> where <T as std::str::FromStr>::Err: std::fmt::Debug {\n    let len = self.next();\n    self.next_vec(len)\n  }\n}\n\nfn main() {\n  let mut input = Input::new(false);\n  let n: usize = input.next();\n  let k: usize = input.next();\n  let mut a: Vec<i32> = input.next_vec(n);\n  a.sort();\n  let answer;\n  if k == 0 {\n    answer = if a[0] == 1 { -1 } else { 1 };\n  } else if k == n {\n    answer = a[n - 1];\n  } else {\n    answer = if a[k - 1] == a[k] { -1 } else { a[k - 1] };\n  }\n  println!(\""{}\"", answer);\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""11a816026e4c4e6807e9312cfceb08ab"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""struct Scan {\n    buffer: std::collections::VecDeque<String>,\n}\n\nimpl Scan {\n    fn new() -> Scan {\n        Scan {\n            buffer: std::collections::VecDeque::new(),\n        }\n    }\n\n    fn next<T: std::str::FromStr>(&mut self) -> T {\n        loop {\n            if let Some(token) = self.buffer.pop_front() {\n                break token.parse::<T>().ok().unwrap();\n            }\n            let mut line = String::new();\n            std::io::stdin().read_line(&mut line).expect(\""Fail to read\"");\n            self.buffer = line.split_whitespace().map(String::from).collect();\n        }\n    }\n\n    fn next_n<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.next::<T>()).collect()\n    }\n}\n\nfn _main() {\n    let mut scan = Scan::new();\n    let n: usize = scan.next();\n    let k: usize = scan.next();\n    let mut arr: Vec<usize> = scan.next_n(n);\n    arr.sort();\n    if k == n {\n        println!(\""{}\"", arr[n - 1]);\n        return;\n    }\n    if k == 0 {\n        if arr[0] == 1 {\n            println!(\""-1\"");\n        } else {\n            println!(\""{}\"", arr[0] - 1);\n        }\n        return;\n    }\n    if arr[k - 1] != arr[k] {\n        println!(\""{}\"", arr[k - 1]);\n    } else {\n        println!(\""-1\"");\n    }\n}\n\nfn main() {\n    std::thread::Builder::new()\n        .stack_size(1 << 23)\n        .spawn(_main)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""a2ef8b0dcfd6c938d91621dc8e15c48f"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""macro_rules! parse_line {\n    ($t: ty) => ({\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\""read error\"");\n        let a_str = a_str.trim();\n        a_str.parse::<$t>().expect(\""parse error\"")\n    });\n    ($($t: ty),+) => ({\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\""read error\"");\n        let mut a_iter = a_str.split_whitespace();\n        (\n            $(\n            a_iter.next().unwrap().parse::<$t>().expect(\""parse error\""),\n            )+\n        )\n    })\n}\n\n#[allow(unused_macros)]\nmacro_rules! parse_line_to_vec {\n    ($t: ty) => {{\n        let mut a_str = String::new();\n        std::io::stdin().read_line(&mut a_str).expect(\""read error\"");\n        (a_str\n            .split_whitespace()\n            .map(|x| x.parse::<$t>().unwrap())\n            .collect::<Vec<$t>>())\n    }};\n}\n\nuse std::io::Write;\n\nfn solve(writer: &mut std::io::BufWriter<std::io::Stdout>) {\n    let (n, k) = parse_line!(usize, usize);\n    let mut a = parse_line_to_vec!(u32);\n    a.sort_unstable();\n    if k == 0 {\n        if a[0] == 1 {\n            writeln!(writer, \""-1\"").unwrap();\n        }else{\n            writeln!(writer, \""1\"").unwrap();\n        }\n        return;\n    }\n    if k == n {\n        writeln!(writer, \""{}\"", a[n - 1]).unwrap();\n        return;\n    }\n    if a[k] == a[k - 1] {\n        writeln!(writer, \""-1\"").unwrap();\n    }else{\n        writeln!(writer, \""{}\"", a[k - 1]).unwrap();\n    }\n}\n\nfn main() {\n    let mut writer = std::io::BufWriter::new(std::io::stdout());\n    let tests = 1; // parse_line!(usize);\n    for _ in 0..tests {\n        solve(&mut writer);\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""3b6020650f103927fa767c410c92cc5b"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""use std::io::Read;\n\nfn input(read_file: bool) -> String {\n    if read_file {\n        let mut file = std::fs::File::open(\""sample.txt\"").unwrap();\n        let mut buf = String::new();\n        file.read_to_string(&mut buf).unwrap();\n        buf\n    } else {\n        let mut buf = String::new();\n        std::io::stdin().read_to_string(&mut buf).unwrap();\n        buf.trim_end().to_owned()\n    }\n}\n\nfn solve(ws: &mut std::str::SplitWhitespace) {\n    let n: usize = ws.next().unwrap().parse().unwrap();\n    let k: usize = ws.next().unwrap().parse().unwrap();\n    let mut a = vec![0; n];\n    for i in 0..n {\n        a[i] = ws.next().unwrap().parse().unwrap();\n    }\n\n    a.sort();\n\n    let mut ans = -1;\n    if k == 0 {\n        if a[0] != 1 {\n            ans = 1;\n        }\n    } else {\n        ans = a[k - 1];\n        if k < n && a[k] == ans {\n            ans = -1;\n        }\n    }\n\n    println!(\""{}\"", ans);\n}\n\nfn main() {\n    const READ_FROM_FILE: bool = false;\n\n    let s = input(READ_FROM_FILE);\n    let mut ws = s.split_whitespace();\n\n    solve(&mut ws);\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""256cf10a9bbbc3a17a5a8d550b3347e8"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""use std::io::*;\nuse std::str::FromStr;\n\nfn main() {\n    let stdin = stdin();\n    let mut sc = Scanner::new(stdin.lock());\n\n    let n = sc.next::<usize>();\n    let k = sc.next::<usize>();\n    let mut a = vec![0; n];\n    for i in 0..n {\n        a[i] = sc.next::<usize>();\n    }\n    a.sort();\n    if k != 0 && (k == n || a[k - 1] != a[k]) {\n        println!(\""{}\"", a[k - 1]);\n    } else {\n        println!(\""-1\"");\n    }\n}\n\npub struct Scanner<B> {\n    reader: B,\n    buffer: Vec<String>,\n}\n\nimpl<B: BufRead> Scanner<B> {\n    pub fn new(reader: B) -> Self {\n        Self {\n            reader,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn next<T: FromStr>(&mut self) -> T\n    where\n        T::Err: ::std::fmt::Debug,\n    {\n        if let Some(front) = self.buffer.pop() {\n            front.parse::<T>().expect(&front)\n        } else {\n            let mut input = String::new();\n            self.reader.read_line(&mut input).expect(\""Line not read\"");\n            self.buffer = input.split_whitespace().rev().map(String::from).collect();\n            self.next()\n        }\n    }\n}\n\n// pub trait BinarySearch<T> {\n//     fn lower_bound(&self, &T) -> usize;\n//     fn upper_bound(&self, &T) -> usize;\n// }\n\n// impl<T: Ord> BinarySearch<T> for [T] {\n//     fn lower_bound(&self, x: &T) -> usize {\n//         let mut low = 0;\n//         let mut high = self.len();\n\n//         while low != high {\n//             let mid = (low + high) / 2;\n//             match self[mid].cmp(x) {\n//                 std::cmp::Ordering::Less => {\n//                     low = mid + 1;\n//                 }\n//                 std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\n//                     high = mid;\n//                 }\n//             }\n//         }\n//         low\n//     }\n\n//     fn upper_bound(&self, x: &T) -> usize {\n//         let mut low = 0;\n//         let mut high = self.len();\n\n//         while low != high {\n//             let mid = (low + high) / 2;\n//             match self[mid].cmp(x) {\n//                 std::cmp::Ordering::Less | std::cmp::Ordering::Equal => {\n//                     low = mid + 1;\n//                 }\n//                 std::cmp::Ordering::Greater => {\n//                     high = mid;\n//                 }\n//             }\n//         }\n//         low\n//     }\n// }\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""f66bb326c1ae519b1a043a4888e5ebd1"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""use std::io::*;\nuse std::str::FromStr;\n\nfn main() {\n    let stdin = stdin();\n    let mut sc = Scanner::new(stdin.lock());\n\n    let n = sc.next::<usize>();\n    let k = sc.next::<usize>();\n    let mut a = vec![0; n];\n    for i in 0..n {\n        a[i] = sc.next::<usize>();\n    }\n    a.sort();\n    if k == n || a[k - 1] != a[k] {\n        println!(\""{}\"", a[k - 1]);\n    } else {\n        println!(\""-1\"");\n    }\n}\n\npub struct Scanner<B> {\n    reader: B,\n    buffer: Vec<String>,\n}\n\nimpl<B: BufRead> Scanner<B> {\n    pub fn new(reader: B) -> Self {\n        Self {\n            reader,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn next<T: FromStr>(&mut self) -> T\n    where\n        T::Err: ::std::fmt::Debug,\n    {\n        if let Some(front) = self.buffer.pop() {\n            front.parse::<T>().expect(&front)\n        } else {\n            let mut input = String::new();\n            self.reader.read_line(&mut input).expect(\""Line not read\"");\n            self.buffer = input.split_whitespace().rev().map(String::from).collect();\n            self.next()\n        }\n    }\n}\n\n// pub trait BinarySearch<T> {\n//     fn lower_bound(&self, &T) -> usize;\n//     fn upper_bound(&self, &T) -> usize;\n// }\n\n// impl<T: Ord> BinarySearch<T> for [T] {\n//     fn lower_bound(&self, x: &T) -> usize {\n//         let mut low = 0;\n//         let mut high = self.len();\n\n//         while low != high {\n//             let mid = (low + high) / 2;\n//             match self[mid].cmp(x) {\n//                 std::cmp::Ordering::Less => {\n//                     low = mid + 1;\n//                 }\n//                 std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\n//                     high = mid;\n//                 }\n//             }\n//         }\n//         low\n//     }\n\n//     fn upper_bound(&self, x: &T) -> usize {\n//         let mut low = 0;\n//         let mut high = self.len();\n\n//         while low != high {\n//             let mid = (low + high) / 2;\n//             match self[mid].cmp(x) {\n//                 std::cmp::Ordering::Less | std::cmp::Ordering::Equal => {\n//                     low = mid + 1;\n//                 }\n//                 std::cmp::Ordering::Greater => {\n//                     high = mid;\n//                 }\n//             }\n//         }\n//         low\n//     }\n// }\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""876834ab1c2fd5d6bcbf04c4024bb98f"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""use std::io::*;\nuse std::str::FromStr;\n\nfn main() {\n    let stdin = stdin();\n    let mut sc = Scanner::new(stdin.lock());\n\n    let n = sc.next::<usize>();\n    let k = sc.next::<usize>();\n    let mut a = vec![0; n];\n    for i in 0..n {\n        a[i] = sc.next::<usize>();\n    }\n    a.sort();\n    if k == 0 && 1 < a[0] {\n        println!(\""1\"");\n    } else if k != 0 && (k == n || a[k - 1] != a[k]) {\n        println!(\""{}\"", a[k - 1]);\n    } else {\n        println!(\""-1\"");\n    }\n}\n\npub struct Scanner<B> {\n    reader: B,\n    buffer: Vec<String>,\n}\n\nimpl<B: BufRead> Scanner<B> {\n    pub fn new(reader: B) -> Self {\n        Self {\n            reader,\n            buffer: Vec::new(),\n        }\n    }\n\n    pub fn next<T: FromStr>(&mut self) -> T\n    where\n        T::Err: ::std::fmt::Debug,\n    {\n        if let Some(front) = self.buffer.pop() {\n            front.parse::<T>().expect(&front)\n        } else {\n            let mut input = String::new();\n            self.reader.read_line(&mut input).expect(\""Line not read\"");\n            self.buffer = input.split_whitespace().rev().map(String::from).collect();\n            self.next()\n        }\n    }\n}\n\n// pub trait BinarySearch<T> {\n//     fn lower_bound(&self, &T) -> usize;\n//     fn upper_bound(&self, &T) -> usize;\n// }\n\n// impl<T: Ord> BinarySearch<T> for [T] {\n//     fn lower_bound(&self, x: &T) -> usize {\n//         let mut low = 0;\n//         let mut high = self.len();\n\n//         while low != high {\n//             let mid = (low + high) / 2;\n//             match self[mid].cmp(x) {\n//                 std::cmp::Ordering::Less => {\n//                     low = mid + 1;\n//                 }\n//                 std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {\n//                     high = mid;\n//                 }\n//             }\n//         }\n//         low\n//     }\n\n//     fn upper_bound(&self, x: &T) -> usize {\n//         let mut low = 0;\n//         let mut high = self.len();\n\n//         while low != high {\n//             let mid = (low + high) / 2;\n//             match self[mid].cmp(x) {\n//                 std::cmp::Ordering::Less | std::cmp::Ordering::Equal => {\n//                     low = mid + 1;\n//                 }\n//                 std::cmp::Ordering::Greater => {\n//                     high = mid;\n//                 }\n//             }\n//         }\n//         low\n//     }\n// }\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""08ecef2e461891ab2233d05d6921cc71"", ""src_uid"": ""55297e2a65144323af4d6abd6a6ef050"", ""difficulty"": 1200}
{""lang"": ""Rust"", ""source_code"": ""use std::collections::BinaryHeap;\nuse std::io;\nuse std::mem;\n\nconst DBG: bool = cfg!(mydebug);\n\nfn to_nums(line: &str) -> Vec<i64> {\n\tline.trim().split_whitespace()\n\t\t.map(|s| s.parse().unwrap())\n\t\t.collect()\n}\n\nconst M: i64 = 1000;\n\nfn doable(pwr: &[i64], num: &[i64], lim: i64) -> bool {\n\tif DBG { println!(\""======== lim {}\"", lim); }\n\tlet n = pwr.len();\n\tlet quota: Vec<i64> = (0..n).map(|i| pwr[i] * M - num[i] * lim)\n\t\t.collect();\n\tif DBG {\n\t\tprint!(\""quota\"");\n\t\tfor x in quota.iter() { print!(\"" {}\"", x); }\n\t\tprintln!();\n\t}\n\n\tlet mut total_quota = 0;\n\tlet mut free_pwr = BinaryHeap::new();\n\tlet mut candidates = Vec::new();\n\tfor i in 0..n {\n\t\tif quota[i] <= 0 {\n\t\t\ttotal_quota -= quota[i];\n\t\t\tfree_pwr.push(pwr[i]);\n\t\t\tif DBG { println!(\""free: quota {} pwr {}\"",\n\t\t\t                  -quota[i], pwr[i]); }\n\t\t} else {\n\t\t\tcandidates.push((pwr[i], quota[i]));\n\t\t}\n\t}\n\tcandidates.sort();\n\n\tlet mut f0 = Vec::new();\n\tlet mut f1 = Vec::new();\n\tf1.push(total_quota);\n\twhile !candidates.is_empty() {\n\t\tif f1.is_empty() { return false }\n\t\tlet cur_pwr = candidates.last().unwrap().0;\n\t\tlet mut cur_quota = Vec::new();\n\t\twhile let Some(&(a_pwr, a_quota)) = candidates.last() {\n\t\t\tif a_pwr != cur_pwr { break }\n\t\t\tcandidates.pop();\n\t\t\tcur_quota.push(a_quota);\n\t\t}\n\t\tif DBG { println!(\""cur pwr {}, quota {:?}\"", cur_pwr, cur_quota); }\n\t\tcur_quota.sort();\n\t\tlet mut prefixsum = vec![0];\n\t\tfor &cq in &cur_quota {\n\t\t\tlet s = prefixsum.last().unwrap() + cq;\n\t\t\tprefixsum.push(s);\n\t\t}\n\n\t\twhile let Some(&free) = free_pwr.peek() {\n\t\t\tif free <= cur_pwr { break }\n\t\t\tfree_pwr.pop();\n\t\t\tlet f10 = f1[0];\n\t\t\tf1.insert(0, f10);\n\t\t}\n\t\tif DBG { println!(\""prev config {:?}\"", f1); }\n\t\tmem::swap(&mut f0, &mut f1);\n\t\tf1.clear();\n\t\tfor (k, &v0) in f0.iter().enumerate() {\n\t\t\tfor i in 0..prefixsum.len() {\n\t\t\t\tif v0 < 0 { continue }\n\t\t\t\tlet j = cur_quota.len() - i;\n\t\t\t\tif j > k { continue }\n\t\t\t\tlet t = k - j + i;\n\t\t\t\tif t >= f1.len() { f1.resize(t + 1, -1); }\n\t\t\t\tf1[t] = f1[t].max(v0 - prefixsum[i]);\n\t\t\t}\n\t\t}\n\t\twhile f1.last() == Some(&(-1)) { f1.pop(); }\n\t\tfor i in (1..f1.len()).rev() {\n\t\t\tf1[i - 1] = f1[i - 1].max(f1[i]);\n\t\t}\n\t\tif DBG { println!(\""cur config {:?}\"", f1); }\n\t}\n\n\treturn true\n}\n\nfn main() -> io::Result<()> {\n\tlet f = io::stdin();\n\tlet mut line = String::new();\n\tf.read_line(&mut line)?;\n\tlet n: usize = line.trim().parse().unwrap();\n\tline.clear();\n\tf.read_line(&mut line)?;\n\tlet pwr = to_nums(&line);\n\tline.clear();\n\tf.read_line(&mut line)?;\n\tlet num = to_nums(&line);\n\tlet mut hi = 0;\n\tfor i in 0..n {\n\t\thi = hi.max((pwr[i] * M + num[i] - 1) / num[i]);\n\t}\n\tlet mut lo = 0;\n\twhile lo + 1 < hi {\n\t\tlet mid = (lo + hi) / 2;\n\t\tif doable(&pwr, &num, mid) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\tprintln!(\""{}\"", hi);\n\n\tOk(())\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""7bba301b80eaba10fdbd43449c572ad8"", ""src_uid"": ""8883f8124092ace99ce0309fb8a511aa"", ""difficulty"": 2500}
{""lang"": ""Rust"", ""source_code"": ""use std::collections::BinaryHeap;\nuse std::io;\n\nconst DBG: bool = cfg!(mydebug);\n\nfn to_nums(line: &str) -> Vec<i64> {\n\tline.trim().split_whitespace()\n\t\t.map(|s| s.parse().unwrap())\n\t\t.collect()\n}\n\nconst M: i64 = 1000;\n\nfn doable(pwr: &[i64], num: &[i64], lim: i64) -> bool {\n\tif DBG { println!(\""======== lim {}\"", lim); }\n\tlet n = pwr.len();\n\tlet quota: Vec<i64> = (0..n).map(|i| pwr[i] * M - num[i] * lim)\n\t\t.collect();\n\tif DBG {\n\t\tprint!(\""quota\"");\n\t\tfor x in quota.iter() { print!(\"" {}\"", x); }\n\t\tprintln!();\n\t}\n\n\tlet mut total_quota = 0;\n\tlet mut free_pwr = BinaryHeap::new();\n\tlet mut candidates = Vec::new();\n\tfor i in 0..n {\n\t\tif quota[i] <= 0 {\n\t\t\ttotal_quota -= quota[i];\n\t\t\tfree_pwr.push(pwr[i]);\n\t\t\tif DBG { println!(\""free: quota {} pwr {}\"",\n\t\t\t                  -quota[i], pwr[i]); }\n\t\t} else {\n\t\t\tcandidates.push((pwr[i], quota[i]));\n\t\t}\n\t}\n\tcandidates.sort();\n\n\tlet mut second_by_quota = BinaryHeap::new();\n\twhile let Some((a_pwr, a_quota)) = candidates.pop() {\n\t\tif DBG { println!(\""handling pwr {} quota {}\"", a_pwr, a_quota); }\n\t\tif let Some(&free) = free_pwr.peek() {\n\t\t\tif free > a_pwr {\n\t\t\t\tif DBG { println!(\""as secondary of {}\"", free); }\n\t\t\t\tfree_pwr.pop();\n\t\t\t\tsecond_by_quota.push((-a_quota, a_pwr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tsecond_by_quota.push((-a_quota, a_pwr));\n\t\tlet (neg_b_quota, b_pwr) = second_by_quota.pop().unwrap();\n\t\tlet b_quota = -neg_b_quota;\n\t\tif DBG { println!(\""instead, pwr {} quota {}\"", b_pwr, b_quota); }\n\t\tif b_quota > total_quota { return false; }\n\t\ttotal_quota -= b_quota;\n\t\tfree_pwr.push(b_pwr);\n\t}\n\n\treturn true;\n}\n\nfn main() -> io::Result<()> {\n\tlet f = io::stdin();\n\tlet mut line = String::new();\n\tf.read_line(&mut line)?;\n\tlet n: usize = line.trim().parse().unwrap();\n\tline.clear();\n\tf.read_line(&mut line)?;\n\tlet pwr = to_nums(&line);\n\tline.clear();\n\tf.read_line(&mut line)?;\n\tlet num = to_nums(&line);\n\tlet mut hi = 0;\n\tfor i in 0..n {\n\t\thi = hi.max((pwr[i] * M + num[i] - 1) / num[i]);\n\t}\n\tlet mut lo = 0;\n\twhile lo + 1 < hi {\n\t\tlet mid = (lo + hi) / 2;\n\t\tif doable(&pwr, &num, mid) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\tprintln!(\""{}\"", hi);\n\n\tOk(())\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""5ded5348d7a01f1f6193b10a563ab0bb"", ""src_uid"": ""8883f8124092ace99ce0309fb8a511aa"", ""difficulty"": 2500}
{""lang"": ""Rust"", ""source_code"": ""use std::collections::BinaryHeap;\nuse std::io;\nuse std::mem;\n\nconst DBG: bool = cfg!(mydebug);\n\nfn to_nums(line: &str) -> Vec<i64> {\n\tline.trim().split_whitespace()\n\t\t.map(|s| s.parse().unwrap())\n\t\t.collect()\n}\n\nconst M: i64 = 1000;\n\nfn doable(pwr: &[i64], num: &[i64], lim: i64) -> bool {\n\tif DBG { println!(\""======== lim {}\"", lim); }\n\tlet n = pwr.len();\n\tlet quota: Vec<i64> = (0..n).map(|i| pwr[i] * M - num[i] * lim)\n\t\t.collect();\n\tif DBG {\n\t\tprint!(\""quota\"");\n\t\tfor x in quota.iter() { print!(\"" {}\"", x); }\n\t\tprintln!();\n\t}\n\n\tlet mut total_quota = 0;\n\tlet mut free_pwr = BinaryHeap::new();\n\tlet mut candidates = Vec::new();\n\tfor i in 0..n {\n\t\tif quota[i] <= 0 {\n\t\t\ttotal_quota -= quota[i];\n\t\t\tfree_pwr.push(pwr[i]);\n\t\t\tif DBG { println!(\""free: quota {} pwr {}\"",\n\t\t\t                  -quota[i], pwr[i]); }\n\t\t} else {\n\t\t\tcandidates.push((pwr[i], quota[i]));\n\t\t}\n\t}\n\tcandidates.sort();\n\n\tlet mut f0 = Vec::new();\n\tlet mut f1 = Vec::new();\n\tlet mut cur_quota = Vec::new();\n\tf1.push(total_quota);\n\twhile !candidates.is_empty() {\n\t\tlet cur_pwr = candidates.last().unwrap().0;\n\t\tcur_quota.clear();\n\t\twhile let Some(&(a_pwr, a_quota)) = candidates.last() {\n\t\t\tif a_pwr != cur_pwr { break }\n\t\t\tcandidates.pop();\n\t\t\tcur_quota.push(a_quota);\n\t\t}\n\t\tcur_quota.sort();\n\t\twhile let Some(&free) = free_pwr.peek() {\n\t\t\tif free <= cur_pwr { break }\n\t\t\tfree_pwr.pop();\n\t\t\tlet f10 = f1[0];\n\t\t\tf1.insert(0, f10);\n\t\t}\n\t\tmem::swap(&mut f0, &mut f1);\n\t\tf1.clear();\n\t\tf1.resize(f0.len() + cur_quota.len(), -1);\n\t\tfor (k, &v0) in f0.iter().enumerate() {\n\t\t\tlet mut prefixsum = 0;\n\t\t\tfor i in 0..(cur_quota.len() + 1) {\n\t\t\t\tif i != 0 { prefixsum += cur_quota[i - 1]; }\n\t\t\t\tif prefixsum > v0 { break }\n\t\t\t\tlet j = cur_quota.len() - i;\n\t\t\t\tif j > k { continue }\n\t\t\t\tlet t = k - j + i;\n\t\t\t\tf1[t] = f1[t].max(v0 - prefixsum);\n\t\t\t}\n\t\t}\n\t\twhile f1.last() == Some(&(-1)) { f1.pop(); }\n\t}\n\n\treturn !f1.is_empty();\n}\n\nfn main() -> io::Result<()> {\n\tlet f = io::stdin();\n\tlet mut line = String::new();\n\tf.read_line(&mut line)?;\n\tlet n: usize = line.trim().parse().unwrap();\n\tline.clear();\n\tf.read_line(&mut line)?;\n\tlet pwr = to_nums(&line);\n\tline.clear();\n\tf.read_line(&mut line)?;\n\tlet num = to_nums(&line);\n\tlet mut hi = 0;\n\tfor i in 0..n {\n\t\thi = hi.max((pwr[i] * M + num[i] - 1) / num[i]);\n\t}\n\tlet mut lo = 0;\n\twhile lo + 1 < hi {\n\t\tlet mid = (lo + hi) / 2;\n\t\tif doable(&pwr, &num, mid) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\tprintln!(\""{}\"", hi);\n\n\tOk(())\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""0cd93444fe37d06aa6d712b575d4b769"", ""src_uid"": ""8883f8124092ace99ce0309fb8a511aa"", ""difficulty"": 2500}
{""lang"": ""Rust"", ""source_code"": ""use std::collections::BinaryHeap;\nuse std::io;\nuse std::mem;\n\nconst DBG: bool = cfg!(mydebug);\n\nfn to_nums(line: &str) -> Vec<i64> {\n\tline.trim().split_whitespace()\n\t\t.map(|s| s.parse().unwrap())\n\t\t.collect()\n}\n\nconst M: i64 = 1000;\n\nfn doable(pwr: &[i64], num: &[i64], lim: i64) -> bool {\n\tif DBG { println!(\""======== lim {}\"", lim); }\n\tlet n = pwr.len();\n\tlet quota: Vec<i64> = (0..n).map(|i| pwr[i] * M - num[i] * lim)\n\t\t.collect();\n\tif DBG {\n\t\tprint!(\""quota\"");\n\t\tfor x in quota.iter() { print!(\"" {}\"", x); }\n\t\tprintln!();\n\t}\n\n\tlet mut total_quota = 0;\n\tlet mut free_pwr = BinaryHeap::new();\n\tlet mut candidates = Vec::new();\n\tfor i in 0..n {\n\t\tif quota[i] <= 0 {\n\t\t\ttotal_quota -= quota[i];\n\t\t\tfree_pwr.push(pwr[i]);\n\t\t\tif DBG { println!(\""free: quota {} pwr {}\"",\n\t\t\t                  -quota[i], pwr[i]); }\n\t\t} else {\n\t\t\tcandidates.push((pwr[i], quota[i]));\n\t\t}\n\t}\n\tcandidates.sort();\n\n\tlet mut f0 = Vec::new();\n\tlet mut f1 = Vec::new();\n\tf1.push(total_quota);\n\twhile !candidates.is_empty() {\n\t\tlet cur_pwr = candidates.last().unwrap().0;\n\t\tlet mut cur_quota = Vec::new();\n\t\twhile let Some(&(a_pwr, a_quota)) = candidates.last() {\n\t\t\tif a_pwr != cur_pwr { break }\n\t\t\tcandidates.pop();\n\t\t\tcur_quota.push(a_quota);\n\t\t}\n\t\tif DBG { println!(\""cur pwr {}, quota {:?}\"", cur_pwr, cur_quota); }\n\t\tcur_quota.sort();\n\t\tlet mut prefixsum = vec![0];\n\t\tfor &cq in &cur_quota {\n\t\t\tlet s = prefixsum.last().unwrap() + cq;\n\t\t\tprefixsum.push(s);\n\t\t}\n\n\t\twhile let Some(&free) = free_pwr.peek() {\n\t\t\tif free <= cur_pwr { break }\n\t\t\tfree_pwr.pop();\n\t\t\tlet f10 = f1[0];\n\t\t\tf1.insert(0, f10);\n\t\t}\n\t\tif DBG { println!(\""prev config {:?}\"", f1); }\n\t\tmem::swap(&mut f0, &mut f1);\n\t\tf1.clear();\n\t\tfor (k, &v0) in f0.iter().enumerate() {\n\t\t\tfor i in 0..prefixsum.len() {\n\t\t\t\tif v0 < 0 { continue }\n\t\t\t\tlet j = cur_quota.len() - i;\n\t\t\t\tif j > k { continue }\n\t\t\t\tlet t = k - j + i;\n\t\t\t\tif t >= f1.len() { f1.resize(t + 1, -1); }\n\t\t\t\tf1[t] = f1[t].max(v0 - prefixsum[i]);\n\t\t\t}\n\t\t}\n\t\twhile f1.last() == Some(&(-1)) { f1.pop(); }\n\t\tfor i in (1..f1.len()).rev() {\n\t\t\tf1[i - 1] = f1[i - 1].max(f1[i]);\n\t\t}\n\t\tif DBG { println!(\""cur config {:?}\"", f1); }\n\t\tif f1.is_empty() { return false }\n\t}\n\n\treturn true\n}\n\nfn main() -> io::Result<()> {\n\tlet f = io::stdin();\n\tlet mut line = String::new();\n\tf.read_line(&mut line)?;\n\tlet n: usize = line.trim().parse().unwrap();\n\tline.clear();\n\tf.read_line(&mut line)?;\n\tlet pwr = to_nums(&line);\n\tline.clear();\n\tf.read_line(&mut line)?;\n\tlet num = to_nums(&line);\n\tlet mut hi = 0;\n\tfor i in 0..n {\n\t\thi = hi.max((pwr[i] * M + num[i] - 1) / num[i]);\n\t}\n\tlet mut lo = 0;\n\twhile lo + 1 < hi {\n\t\tlet mid = (lo + hi) / 2;\n\t\tif doable(&pwr, &num, mid) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\tprintln!(\""{}\"", hi);\n\n\tOk(())\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""f375ad2b1360e3a6e611361d300ef545"", ""src_uid"": ""8883f8124092ace99ce0309fb8a511aa"", ""difficulty"": 2500}
{""lang"": ""Rust"", ""source_code"": ""// https://codeforces.com/contest/1137/problem/A\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \"" = {:?}, \""),*), $($a),*);\n    }\n}\n\n\n\nfn process(a: Vec<i32>) -> (Vec<i32>, i32) {\n    let mut ua = a.clone();\n    ua.sort();\n    ua.dedup();\n\n    let n = a.len();\n    let mut r = vec![0; n];\n    for i in 0..n {\n        r[i] = ua.binary_search(&a[i]).unwrap() as i32;\n    }\n    (r, ua.len() as i32)\n}\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: [[i32; m]; n]\n    };\n\n    let mut rows = vec![];\n    for i in 0..n {\n        rows.push(process(a[i].clone()));\n    }\n    let mut cols = vec![];\n    for j in 0..m {\n        let mut ca = vec![0; n];\n        for i in 0..n {\n            ca[i] = a[i][j];\n        }\n        cols.push(process(ca));\n    }\n\n    let mut ans = vec![vec![0; m]; n];\n    for i in 0..n {\n        for j in 0..m {\n            let mut best = (n+m) as i32;\n\n            let mut myc = cols[j].0[i];\n            let mut myr = rows[i].0[j];\n            let mut col_count = cols[j].1;\n            let mut row_count = rows[i].1;\n            ans[i][j] = 1 + max(myc, myr) + max(col_count-myc-1, row_count-myr-1);\n        }\n    }\n\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    for i in 0..n {\n        writeln!(out, \""{}\"", join!(ans[i].clone(), \"" \""));\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""96dd108760a1d4073bc7e8bbc909fabe"", ""src_uid"": ""206861107f0c06d3c8e358a85b9ddd7f"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::Debug;\nuse std::str::FromStr;\n\nfn main() {\n    let nn = read_vec::<usize>();\n    let (n, m) = (nn[0], nn[1]);\n\n    #[derive(Copy, Clone, Debug)]\n    struct Point {\n        i: usize,\n        h: i64,\n        fh: i64,\n    }\n\n    let mut rows = vec![Vec::with_capacity(m); n];\n    let mut columns = vec![Vec::with_capacity(n); m];\n    let mut r_maxes = vec![0; n];\n    let mut c_maxes = vec![0; m];\n\n    for i in 0..n {\n        let p = read_vec::<i64>();\n        for j in 0..m {\n            rows[i].push(Point {\n                i: j,\n                h: p[j],\n                fh: 0,\n            });\n            columns[j].push(Point {\n                i: i,\n                h: p[j],\n                fh: 0,\n            });\n        }\n    }\n\n    for i in 0..n {\n        let row = &mut rows[i];\n        row.sort_unstable_by(\n            |a, b| a.h.cmp(&b.h)\n        );\n        row[0].fh = 1;\n        for i in 1..m {\n            if row[i].h == row[i - 1].h {\n                row[i].fh = row[i - 1].fh;\n            } else {\n                row[i].fh = row[i - 1].fh + 1;\n            }\n        }\n        r_maxes[i] = row[m - 1].fh;\n        row.sort_unstable_by(\n            |a, b| a.i.cmp(&b.i)\n        );\n    }\n\n    for i in 0..m {\n        let row = &mut columns[i];\n        row.sort_unstable_by(\n            |a, b| a.h.cmp(&b.h)\n        );\n        row[0].fh = 1;\n        for i in 1..n {\n            if row[i].h == row[i - 1].h {\n                row[i].fh = row[i - 1].fh;\n            } else {\n                row[i].fh = row[i - 1].fh + 1;\n            }\n        }\n        c_maxes[i] = row[n - 1].fh;\n        row.sort_unstable_by(\n            |a, b| a.i.cmp(&b.i)\n        );\n    }\n\n//    for i in 0..n { print_vec(&rows[i]) }\n//    for i in 0..m { print_vec(&columns[i]) }\n\n    for i in 0..n {\n        for j in 0..m {\n            print!(\""{}\"", max(\n                r_maxes[i] + max(0, columns[j][i].fh - rows[i][j].fh),\n                c_maxes[j] + max(0, -columns[j][i].fh + rows[i][j].fh),\n            ));\n            if j < m - 1 {\n                print! {\"" \""};\n            }\n        }\n        println!()\n    }\n}\n\n#[allow(dead_code)]\nconst DIV: i64 = 1_000_000_007;\n#[allow(dead_code)]\nconst N: usize = 200000;\n#[allow(dead_code)]\nconst CHARS: usize = 'z' as usize - 'a' as usize + 1;\n\n#[allow(dead_code)]\nfn print_vec<T: Debug>(a: &Vec<T>) {\n    for i in 0..a.len() {\n        if i != 0 {\n            print!(\"" \"");\n        }\n        print!(\""{:?}\"", a[i]);\n    }\n    println!();\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut s = String::with_capacity(N);\n    std::io::stdin().read_line(&mut s).unwrap();\n    s\n}\n\n#[allow(dead_code)]\nfn read_vec<T: FromStr>() -> Vec<T>\n    where T::Err: Debug\n{\n    return read_line()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""0bb5a08528b3b09ea20bc5a60b176c6b"", ""src_uid"": ""206861107f0c06d3c8e358a85b9ddd7f"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::Debug;\nuse std::str::FromStr;\n\nfn main() {\n    let nn = read_vec::<usize>();\n    let (n, m) = (nn[0], nn[1]);\n\n    #[derive(Copy, Clone)]\n    struct Point {\n        i: usize,\n        h: i64,\n    }\n\n    let mut rows = vec![Vec::with_capacity(m); n];\n    let mut columns = vec![Vec::with_capacity(n); m];\n    let mut r_maxes = vec![0; n];\n    let mut c_maxes = vec![0; m];\n\n    for i in 0..n {\n        let p = read_vec::<i64>();\n        for j in 0..m {\n            rows[i].push(Point {\n                i: j,\n                h: p[j],\n            });\n            columns[j].push(Point {\n                i: i,\n                h: p[j],\n            });\n        }\n    }\n\n    for i in 0..n {\n        let row = &mut rows[i];\n        row.sort_unstable_by(\n            |a, b| a.h.cmp(&b.h)\n        );\n        row[0].h = 1;\n        for i in 1..n {\n            if row[i].h == row[i - 1].h {\n                row[i].h = row[i - 1].h;\n            } else {\n                row[i].h = row[i - 1].h + 1;\n            }\n        }\n        r_maxes[i] = row[m - 1].h;\n        row.sort_unstable_by(\n            |a, b| a.i.cmp(&b.i)\n        );\n    }\n\n    for i in 0..m {\n        let row = &mut columns[i];\n        row.sort_unstable_by(\n            |a, b| a.h.cmp(&b.h)\n        );\n        row[0].h = 1;\n        for i in 1..n {\n            if row[i].h == row[i - 1].h {\n                row[i].h = row[i - 1].h;\n            } else {\n                row[i].h = row[i - 1].h + 1;\n            }\n        }\n        c_maxes[i] = row[n - 1].h;\n        row.sort_unstable_by(\n            |a, b| a.i.cmp(&b.i)\n        );\n    }\n\n    for i in 0..n {\n        for j in 0..m {\n            print!(\""{}\"", max(\n                r_maxes[i] + max(0, columns[j][i].h - rows[i][j].h),\n                c_maxes[i] + max(0, -columns[j][i].h + rows[i][j].h),\n            ));\n            if j < m - 1 {\n                print! {\"" \""};\n            }\n        }\n        println!()\n    }\n}\n\n#[allow(dead_code)]\nconst DIV: i64 = 1_000_000_007;\n#[allow(dead_code)]\nconst N: usize = 200000;\n#[allow(dead_code)]\nconst CHARS: usize = 'z' as usize - 'a' as usize + 1;\n\n#[allow(dead_code)]\nfn print_vec<T: Debug>(a: &Vec<T>) {\n    for i in 0..a.len() {\n        if i != 0 {\n            print!(\"" \"");\n        }\n        print!(\""{:?}\"", a[i]);\n    }\n    println!();\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut s = String::with_capacity(N);\n    std::io::stdin().read_line(&mut s).unwrap();\n    s\n}\n\n#[allow(dead_code)]\nfn read_vec<T: FromStr>() -> Vec<T>\n    where T::Err: Debug\n{\n    return read_line()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""fe5f20b1f3c53f4ff40179bdf846a1e6"", ""src_uid"": ""206861107f0c06d3c8e358a85b9ddd7f"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::Debug;\nuse std::str::FromStr;\n\nfn main() {\n    let nn = read_vec::<usize>();\n    let (n, m) = (nn[0], nn[1]);\n\n    #[derive(Copy, Clone, Debug)]\n    struct Point {\n        i: usize,\n        h: i64,\n        fh: i64,\n    }\n\n    let mut rows = vec![Vec::with_capacity(m); n];\n    let mut columns = vec![Vec::with_capacity(n); m];\n    let mut r_maxes = vec![0; n];\n    let mut c_maxes = vec![0; m];\n\n    for i in 0..n {\n        let p = read_vec::<i64>();\n        for j in 0..m {\n            rows[i].push(Point {\n                i: j,\n                h: p[j],\n                fh: 0,\n            });\n            columns[j].push(Point {\n                i: i,\n                h: p[j],\n                fh: 0,\n            });\n        }\n    }\n\n    for i in 0..n {\n        let row = &mut rows[i];\n        row.sort_unstable_by(\n            |a, b| a.h.cmp(&b.h)\n        );\n        row[0].fh = 1;\n        for i in 1..m {\n            if row[i].h == row[i - 1].h {\n                row[i].fh = row[i - 1].fh;\n            } else {\n                row[i].fh = row[i - 1].fh + 1;\n            }\n        }\n        r_maxes[i] = row[m - 1].h;\n        row.sort_unstable_by(\n            |a, b| a.i.cmp(&b.i)\n        );\n    }\n\n    for i in 0..m {\n        let row = &mut columns[i];\n        row.sort_unstable_by(\n            |a, b| a.h.cmp(&b.h)\n        );\n        row[0].fh = 1;\n        for i in 1..n {\n            if row[i].h == row[i - 1].h {\n                row[i].fh = row[i - 1].fh;\n            } else {\n                row[i].fh = row[i - 1].fh + 1;\n            }\n        }\n        c_maxes[i] = row[n - 1].h;\n        row.sort_unstable_by(\n            |a, b| a.i.cmp(&b.i)\n        );\n    }\n\n//    for i in 0..n { print_vec(&rows[i]) }\n//    for i in 0..m { print_vec(&columns[i]) }\n\n    for i in 0..n {\n        for j in 0..m {\n            print!(\""{}\"", max(\n                r_maxes[i] + max(0, columns[j][i].h - rows[i][j].h),\n                c_maxes[j] + max(0, -columns[j][i].h + rows[i][j].h),\n            ));\n            if j < m - 1 {\n                print! {\"" \""};\n            }\n        }\n        println!()\n    }\n}\n\n#[allow(dead_code)]\nconst DIV: i64 = 1_000_000_007;\n#[allow(dead_code)]\nconst N: usize = 200000;\n#[allow(dead_code)]\nconst CHARS: usize = 'z' as usize - 'a' as usize + 1;\n\n#[allow(dead_code)]\nfn print_vec<T: Debug>(a: &Vec<T>) {\n    for i in 0..a.len() {\n        if i != 0 {\n            print!(\"" \"");\n        }\n        print!(\""{:?}\"", a[i]);\n    }\n    println!();\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut s = String::with_capacity(N);\n    std::io::stdin().read_line(&mut s).unwrap();\n    s\n}\n\n#[allow(dead_code)]\nfn read_vec<T: FromStr>() -> Vec<T>\n    where T::Err: Debug\n{\n    return read_line()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""a712d3e9b760a08959b7a829b60ecc14"", ""src_uid"": ""206861107f0c06d3c8e358a85b9ddd7f"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::fmt::Debug;\nuse std::str::FromStr;\n\nfn main() {\n    let nn = read_vec::<usize>();\n    let (n, m) = (nn[0], nn[1]);\n\n    #[derive(Copy, Clone)]\n    struct Point {\n        i: usize,\n        h: i64,\n    }\n\n    let mut rows = vec![Vec::with_capacity(m); n];\n    let mut columns = vec![Vec::with_capacity(n); m];\n    let mut r_maxes = vec![0; n];\n    let mut c_maxes = vec![0; m];\n\n    for i in 0..n {\n        let p = read_vec::<i64>();\n        for j in 0..m {\n            rows[i].push(Point {\n                i: j,\n                h: p[j],\n            });\n            columns[j].push(Point {\n                i: i,\n                h: p[j],\n            });\n        }\n    }\n\n    for i in 0..n {\n        let row = &mut rows[i];\n        row.sort_unstable_by(\n            |a, b| a.h.cmp(&b.h)\n        );\n        row[0].h = 1;\n        for i in 1..m {\n            if row[i].h == row[i - 1].h {\n                row[i].h = row[i - 1].h;\n            } else {\n                row[i].h = row[i - 1].h + 1;\n            }\n        }\n        r_maxes[i] = row[m - 1].h;\n        row.sort_unstable_by(\n            |a, b| a.i.cmp(&b.i)\n        );\n    }\n\n    for i in 0..m {\n        let row = &mut columns[i];\n        row.sort_unstable_by(\n            |a, b| a.h.cmp(&b.h)\n        );\n        row[0].h = 1;\n        for i in 1..n {\n            if row[i].h == row[i - 1].h {\n                row[i].h = row[i - 1].h;\n            } else {\n                row[i].h = row[i - 1].h + 1;\n            }\n        }\n        c_maxes[i] = row[n - 1].h;\n        row.sort_unstable_by(\n            |a, b| a.i.cmp(&b.i)\n        );\n    }\n\n    for i in 0..n {\n        for j in 0..m {\n            print!(\""{}\"", max(\n                r_maxes[i] + max(0, columns[j][i].h - rows[i][j].h),\n                c_maxes[j] + max(0, -columns[j][i].h + rows[i][j].h),\n            ));\n            if j < m - 1 {\n                print! {\"" \""};\n            }\n        }\n        println!()\n    }\n}\n\n#[allow(dead_code)]\nconst DIV: i64 = 1_000_000_007;\n#[allow(dead_code)]\nconst N: usize = 200000;\n#[allow(dead_code)]\nconst CHARS: usize = 'z' as usize - 'a' as usize + 1;\n\n#[allow(dead_code)]\nfn print_vec<T: Debug>(a: &Vec<T>) {\n    for i in 0..a.len() {\n        if i != 0 {\n            print!(\"" \"");\n        }\n        print!(\""{:?}\"", a[i]);\n    }\n    println!();\n}\n\n#[allow(dead_code)]\nfn read_line() -> String {\n    let mut s = String::with_capacity(N);\n    std::io::stdin().read_line(&mut s).unwrap();\n    s\n}\n\n#[allow(dead_code)]\nfn read_vec<T: FromStr>() -> Vec<T>\n    where T::Err: Debug\n{\n    return read_line()\n        .split_whitespace()\n        .map(|x| x.parse().unwrap())\n        .collect();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""6797d6df9bed2fe804ad57b31aa3410b"", ""src_uid"": ""206861107f0c06d3c8e358a85b9ddd7f"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""use std::io::BufRead;\n\n#[derive(Clone,Debug)]\nstruct Problem {\n    input: Vec<u32>,\n}\n\nfn read_problem<R: BufRead>(br: R) -> Problem {\n    let mut lines = br.lines().map(Result::unwrap);\n\n    let ct = str::parse(&lines.next().unwrap()).unwrap();\n    let input = lines.next().unwrap().split_whitespace()\n        .map(|w| str::parse::<u32>(w).unwrap())\n        .map(|n| n - 1)\n        .collect::<Vec<_>>();\n    assert!(lines.next().is_none());\n    assert!(input.len() == ct);\n    Problem { input: input }\n}\n\nfn solve(problem: Problem) -> Vec<u32> {\n    let mut best = problem.input.iter().map(|_| u32::max_value()).collect::<Vec<_>>();\n    let mut next = vec![0];\n    let mut cost = 0;\n    while !next.is_empty() {\n        for n in std::mem::replace(&mut next, Vec::new()) {\n            if cost < best[n] {\n                best[n] = cost;\n                if n > 0 {\n                    next.push(n-1);\n                }\n                if n+1 < best.len() {\n                    next.push(n+1);\n                }\n                next.push(problem.input[n] as usize);\n            }\n        }\n        cost += 1;\n    }\n    best\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n    let p = read_problem(stdin.lock());\n    for k in solve(p) {\n        print!(\""{} \"", k);\n    }\n    println!(\""\"");\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""579057b098ba75c0b97d8e8eb337f332"", ""src_uid"": ""d465aec304757dff34a770f7877dd940"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""use std::io::BufRead;\n\n#[derive(Clone,Debug)]\nstruct Problem {\n    input: Vec<u32>,\n}\n\nfn read_problem<R: BufRead>(br: R) -> Problem {\n    let mut lines = br.lines().map(Result::unwrap);\n\n    let ct = str::parse(&lines.next().unwrap()).unwrap();\n    let input = lines.next().unwrap().split_whitespace()\n        .map(|w| str::parse::<u32>(w).unwrap())\n        .map(|n| n - 1)\n        .collect::<Vec<_>>();\n    assert!(lines.next().is_none());\n    assert!(input.len() == ct);\n    Problem { input: input }\n}\n\nfn solve(problem: Problem) -> Vec<u32> {\n    let mut best = problem.input.iter().map(|_| u32::max_value()).collect::<Vec<_>>();\n    let mut next = 0;\n    for (i, ai) in problem.input.into_iter().enumerate() {\n        if next < best[i] {\n            best[i] = next;\n        }\n        next = best[i] + 1;\n        if next < best[ai as usize] {\n            best[ai as usize] = next;\n        }\n    }\n    best\n}\n\nfn main() {\n    let stdin = std::io::stdin();\n    let p = read_problem(stdin.lock());\n    for k in solve(p) {\n        print!(\""{} \"", k);\n    }\n    println!(\""\"");\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""a3c0a4532d6a2ccd612ec071dc470718"", ""src_uid"": ""d465aec304757dff34a770f7877dd940"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""use std::io;\nuse std::io::Read;\nuse std::collections::VecDeque;\n\n\nfn main() {\n    let mut text = String::new();\n    io::stdin().read_to_string(&mut text).unwrap();\n    let mut iter = text.split_whitespace().map(|x| x.parse::<usize>().unwrap());\n    let n = iter.next().unwrap();\n    let a = iter.map(|x| x - 1).collect::<Vec<usize>>();\n    let mut energy = vec![-1; n];\n    energy[0] = 0;\n    let mut queue = VecDeque::new();\n    queue.push_back(0);\n    while let Some(cur) = queue.pop_front() {\n        if cur > 0 && energy[cur - 1] == -1 {\n            energy[cur - 1] = energy[cur] + 1;\n            queue.push_back(cur - 1);\n        }\n        if cur < n - 1 && energy[cur + 1] == -1 {\n            energy[cur + 1] = energy[cur] + 1;\n            queue.push_back(cur + 1);\n        }\n        if energy[a[cur]] == -1 {\n            energy[a[cur]] = energy[cur] + 1;\n            queue.push_back(a[cur]);\n        }\n    }\n    for item in energy {\n        print!(\""{} \"", item);\n    }\n    println!(\""\"");\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""d6d94c995e414ed45df1b742512f6d2b"", ""src_uid"": ""d465aec304757dff34a770f7877dd940"", ""difficulty"": 1600}
{""lang"": ""Rust"", ""source_code"": ""use std::fmt::Debug;\nuse std::str::FromStr;\n\npub struct TokenReader {\n    reader: std::io::Stdin,\n    tokens: Vec<String>,\n    index: usize,\n}\n\nimpl TokenReader {\n    pub fn new() -> Self {\n        Self {\n            reader: std::io::stdin(),\n            tokens: Vec::new(),\n            index: 0,\n        }\n    }\n\n    pub fn next<T>(&mut self) -> T\n    where\n        T: FromStr,\n        T::Err: Debug,\n    {\n        if self.index >= self.tokens.len() {\n            self.load_next_line();\n        }\n        self.index += 1;\n        self.tokens[self.index - 1].parse().unwrap()\n    }\n\n    pub fn vector<T>(&mut self) -> Vec<T>\n    where\n        T: FromStr,\n        T::Err: Debug,\n    {\n        if self.index >= self.tokens.len() {\n            self.load_next_line();\n        }\n        self.index = self.tokens.len();\n        self.tokens.iter().map(|tok| tok.parse().unwrap()).collect()\n    }\n\n    pub fn load_next_line(&mut self) {\n        let mut line = String::new();\n        self.reader.read_line(&mut line).unwrap();\n\n        self.tokens = line\n            .split_whitespace()\n            .map(String::from)\n            .collect();\n        self.index = 0;\n    }\n}\n\nfn eat1(n: &mut i64, v: &mut i64, c: &mut i64) -> i64 {\n    let eaten = std::cmp::min(*n, (*v - *c).abs());\n    *n -= eaten;\n\n    if *v > *c {\n        *v -= eaten;\n    } else {\n        *c -= eaten;\n    }\n\n    eaten\n}\n\nfn eat2(m: &mut i64, v: &mut i64, c: &mut i64) -> i64 {\n    let eaten = std::cmp::min(*m, std::cmp::min(*v, *c));\n    *m -= eaten;\n\n    if *v > *c {\n        *c -= eaten;\n    } else {\n        *v -= eaten;\n    }\n\n    eaten\n}\n\nfn possible(mut v: i64, mut c: i64, mut n: i64, mut m: i64) -> bool {\n    if n + m > v + c {\n        return false;\n    }\n\n    while v != c && n > 0 {\n        if eat1(&mut n, &mut v, &mut c) == 0 {\n            return false;\n        }\n    }\n\n    while n > 0 && m > 0 {\n        let eaten = std::cmp::min(std::cmp::min(v, m), std::cmp::min(c, n));\n        if eaten == 0 {\n            break;\n        }\n\n        v -= eaten;\n        c -= eaten;\n        n -= eaten;\n        m -= eaten;\n    }\n\n    while n > 0 {\n        if eat1(&mut n, &mut v, &mut c) == 0 {\n            return false;\n        }\n    }\n    while m > 0 {\n        if eat2(&mut m, &mut v, &mut c) == 0 {\n            return false;\n        }\n    }\n\n    n == 0 && m == 0\n}\n\nfn main() {\n    let mut reader = TokenReader::new();\n    let tests = reader.next();\n\n    for _ in 0..tests {\n        let v = reader.next();\n        let c = reader.next();\n        let n = reader.next();\n        let m = reader.next();\n        println!(\""{}\"", if possible(v, c, n, m) { \""Yes\"" } else { \""No\"" });\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""bf9f939c68fa657eda8e1bc83b99770b"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""#![allow(dead_code)]\n#![allow(unused_imports)]\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io;\nuse std::ops;\nuse std::str::FromStr;\n\n#[derive(Clone, Debug, Default)]\nstruct ProblemState {\n}\n\nimpl Problem {\n    fn solve(&mut self) {\n        let mut a: u64 = self.scan();\n        let mut b: u64 = self.scan();\n        let mut n: u64 = self.scan();\n        let mut m: u64 = self.scan();\n\n        if a < b {\n            let t = a; a = b; b = t;\n        }\n\n        let x = 2 * b - min(m, b);\n\n        n -= min(n, a - b);\n        m -= min(m, b);\n        n -= min(n, x);\n\n        if n == 0 && m == 0 {\n            println!(\""Yes\"");\n        } else {\n            println!(\""No\"");\n        }\n    }\n}\n\nfn main() {\n    Problem::new().solve_cases();\n}\n\nstruct Problem {\n    input_state: InputState,\n    problem_state: ProblemState,\n}\n\nstruct InputState {\n    stdin: io::Stdin,\n    buffer: String,\n    tokens: VecDeque<String>,\n}\n\nimpl Problem {\n    fn new() -> Self {\n        Self {\n            input_state: InputState {\n                stdin: io::stdin(),\n                buffer: String::new(),\n                tokens: VecDeque::new(),\n            },\n            problem_state: Default::default(),\n        }\n    }\n\n    fn solve_cases(&mut self) {\n        for _ in 0usize..self.scan() {\n            self.solve()\n        }\n    }\n\n    fn scan<T: FromStr>(&mut self) -> T {\n        while self.input_state.tokens.is_empty() {\n            self.input_state.stdin.read_line(&mut self.input_state.buffer).unwrap();\n\n            for token in self.input_state.buffer.split_ascii_whitespace() {\n                self.input_state.tokens.push_back(token.to_string());\n            }\n\n            self.input_state.buffer.clear();\n        }\n\n        self.input_state.tokens.pop_front().unwrap().parse().ok().unwrap()\n    }\n\n    fn scan_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).into_iter().map(|_| self.scan()).collect()\n    }\n\n    fn scan_line(&mut self) -> String {\n        let mut line = String::new();\n        self.input_state.stdin.read_line(&mut line).unwrap();\n        while line.ends_with('\\n') || line.ends_with('\\r') { line.pop(); }\n        line\n    }\n\n    fn scan_line_vec(&mut self, n: usize) -> Vec<String> {\n        (0..n).into_iter().map(|_| self.scan_line()).collect()\n    }\n}\n\nimpl ops::Deref for Problem {\n    type Target = ProblemState;\n\n    fn deref(&self) -> &ProblemState {\n        &self.problem_state\n    }\n}\n\nimpl ops::DerefMut for Problem {\n    fn deref_mut(&mut self) -> &mut ProblemState {\n        &mut self.problem_state\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""4db868163bed32ad8f6f1cc6e182489e"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""#![allow(dead_code)]\n#![allow(unused_imports)]\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io;\nuse std::ops;\nuse std::str::FromStr;\n\n#[derive(Clone, Debug, Default)]\nstruct ProblemState {\n}\n\nimpl Problem {\n    fn solve(&mut self) {\n        let mut a: u64 = self.scan();\n        let mut b: u64 = self.scan();\n        let mut n: u64 = self.scan();\n        let mut m: u64 = self.scan();\n\n        if a < b {\n            let t = a; a = b; b = t;\n        }\n\n        if a > b {\n            n -= min(n, a - b);\n        }\n\n        m -= min(m, b);\n        n -= min(n, b);\n\n        if n == 0 && m == 0 {\n            println!(\""Yes\"");\n        } else {\n            println!(\""No\"");\n        }\n    }\n}\n\nfn main() {\n    Problem::new().solve_cases();\n}\n\nstruct Problem {\n    input_state: InputState,\n    problem_state: ProblemState,\n}\n\nstruct InputState {\n    stdin: io::Stdin,\n    buffer: String,\n    tokens: VecDeque<String>,\n}\n\nimpl Problem {\n    fn new() -> Self {\n        Self {\n            input_state: InputState {\n                stdin: io::stdin(),\n                buffer: String::new(),\n                tokens: VecDeque::new(),\n            },\n            problem_state: Default::default(),\n        }\n    }\n\n    fn solve_cases(&mut self) {\n        for _ in 0usize..self.scan() {\n            self.solve()\n        }\n    }\n\n    fn scan<T: FromStr>(&mut self) -> T {\n        while self.input_state.tokens.is_empty() {\n            self.input_state.stdin.read_line(&mut self.input_state.buffer).unwrap();\n\n            for token in self.input_state.buffer.split_ascii_whitespace() {\n                self.input_state.tokens.push_back(token.to_string());\n            }\n\n            self.input_state.buffer.clear();\n        }\n\n        self.input_state.tokens.pop_front().unwrap().parse().ok().unwrap()\n    }\n\n    fn scan_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).into_iter().map(|_| self.scan()).collect()\n    }\n\n    fn scan_line(&mut self) -> String {\n        let mut line = String::new();\n        self.input_state.stdin.read_line(&mut line).unwrap();\n        while line.ends_with('\\n') || line.ends_with('\\r') { line.pop(); }\n        line\n    }\n\n    fn scan_line_vec(&mut self, n: usize) -> Vec<String> {\n        (0..n).into_iter().map(|_| self.scan_line()).collect()\n    }\n}\n\nimpl ops::Deref for Problem {\n    type Target = ProblemState;\n\n    fn deref(&self) -> &ProblemState {\n        &self.problem_state\n    }\n}\n\nimpl ops::DerefMut for Problem {\n    fn deref_mut(&mut self) -> &mut ProblemState {\n        &mut self.problem_state\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""0444352e17cb62cfe0087aaaa9de7bc4"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_parens)]\n#![allow(unused_imports)]\n#![allow(non_upper_case_globals)]\n#![allow(non_snake_case)]\n#![allow(unused_mut)]\n#![allow(unused_variables)]\n#![allow(dead_code)]\n\n#[allow(unused_macros)]\nmacro_rules! invec {\n    ( $ t : ty ) => {{\n        let mut s = String::new();\n        match std::io::stdin().read_line(&mut s) {\n            Ok(0) => Vec::<$t>::new(),\n            Ok(n) => s\n                .trim()\n                .split_whitespace()\n                .map(|s| s.parse::<$t>().unwrap())\n                .collect::<Vec<$t>>(),\n            Err(_) => Vec::<$t>::new(),\n        }\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n      ($t:ty) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              line.trim().parse::<$t>().unwrap()\n          }\n      };\n      ($($t:ty),*) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              let mut iter = line.split_whitespace();\n              (\n                  $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n              )\n          }\n      };\n      ($t:ty; $n:expr) => {\n          (0..$n).map(|_|\n              get!($t)\n          ).collect::<Vec<_>>()\n      };\n      ($($t:ty),*; $n:expr) => {\n          (0..$n).map(|_|\n              get!($($t),*)\n          ).collect::<Vec<_>>()\n      };\n      ($t:ty ;;) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              line.split_whitespace()\n                  .map(|t| t.parse::<$t>().unwrap())\n                  .collect::<Vec<_>>()\n          }\n      };\n      ($t:ty ;; $n:expr) => {\n          (0..$n).map(|_| get!($t ;;)).collect::<Vec<_>>()\n      };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let mut s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [$t:tt]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n#[allow(unused_macros)]\n#[cfg(debug_assertions)]\nmacro_rules! mydbg {\n    //($arg:expr) => (dbg!($arg))\n    //($arg:expr) => (println!(\""{:?}\"",$arg));\n      ($($a:expr),*) => {\n          eprintln!(concat!($(stringify!($a), \"" = {:?}, \""),*), $($a),*);\n      }\n}\n#[cfg(not(debug_assertions))]\nmacro_rules! mydbg {\n    ($($arg:expr),*) => {};\n}\n\nmacro_rules! echo {\n    ($($a:expr),*) => {\n          $(println!(\""{}\"",$a))*\n      }\n}\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::ops::{Add, Div, Mul, Sub};\n\n#[allow(dead_code)]\nstatic INF_I64: i64 = i64::max_value() / 2;\n#[allow(dead_code)]\nstatic INF_I32: i32 = i32::max_value() / 2;\n#[allow(dead_code)]\nstatic INF_USIZE: usize = usize::max_value() / 2;\n#[allow(dead_code)]\nstatic M_O_D: usize = 1000000007;\n#[allow(dead_code)]\nstatic PAI: f64 = 3.1415926535897932;\n\ntrait IteratorExt: Iterator {\n    fn toVec(self) -> Vec<Self::Item>;\n}\n\nimpl<T: Iterator> IteratorExt for T {\n    fn toVec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\ntrait CharExt {\n    fn toNum(&self) -> usize;\n    fn toAlphabetIndex(&self) -> usize;\n    fn toNumIndex(&self) -> usize;\n}\nimpl CharExt for char {\n    fn toNum(&self) -> usize {\n        return *self as usize;\n    }\n    fn toAlphabetIndex(&self) -> usize {\n        return self.toNum() - 'a' as usize;\n    }\n    fn toNumIndex(&self) -> usize {\n        return self.toNum() - '0' as usize;\n    }\n}\n\ntrait VectorExt {\n    fn joinToString(&self, s: &str) -> String;\n}\nimpl<T: ToString> VectorExt for Vec<T> {\n    fn joinToString(&self, s: &str) -> String {\n        return self\n            .iter()\n            .map(|x| x.to_string())\n            .collect::<Vec<_>>()\n            .join(s);\n    }\n}\n\ntrait StringExt {\n    fn get_reverse(&self) -> String;\n}\nimpl StringExt for String {\n    fn get_reverse(&self) -> String {\n        self.chars().rev().collect::<String>()\n    }\n}\n\ntrait UsizeExt {\n    fn pow(&self, n: usize) -> usize;\n}\nimpl UsizeExt for usize {\n    fn pow(&self, n: usize) -> usize {\n        return ((*self as u64).pow(n as u32)) as usize;\n    }\n}\n\nfn main() {\n    let T = get!(usize);\n    for testcase in 0..T {\n        mydbg!(testcase);\n        let mut ans: usize = 0;\n        let (mut v, mut c, mut n, mut m) = get!(i64, i64, i64, i64);\n        mydbg!(v, c, n, m);\n\n        if v > c {\n            let x = min(m, c);\n            c -= x;\n            m -= x;\n        } else if v <= c {\n            let x = min(m, v);\n            v -= x;\n            m -= x;\n        }\n\n        mydbg!(v, c, n, m);\n        if v > c {\n            let x = min(n, v);\n            v -= x;\n            n -= x;\n        } else if v <= c {\n            let x = min(n, c);\n            c -= x;\n            n -= x;\n        }\n        mydbg!(v, c, n, m);\n\n        if n == 0 && m == 0 {\n            echo!(\""Yes\"");\n        } else {\n            echo!(\""No\"");\n        }\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""72d2fea25f04866e01497803d14b787f"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_parens)]\n#![allow(unused_imports)]\n#![allow(non_upper_case_globals)]\n#![allow(non_snake_case)]\n#![allow(unused_mut)]\n#![allow(unused_variables)]\n#![allow(dead_code)]\n\n#[allow(unused_macros)]\nmacro_rules! invec {\n    ( $ t : ty ) => {{\n        let mut s = String::new();\n        match std::io::stdin().read_line(&mut s) {\n            Ok(0) => Vec::<$t>::new(),\n            Ok(n) => s\n                .trim()\n                .split_whitespace()\n                .map(|s| s.parse::<$t>().unwrap())\n                .collect::<Vec<$t>>(),\n            Err(_) => Vec::<$t>::new(),\n        }\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n      ($t:ty) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              line.trim().parse::<$t>().unwrap()\n          }\n      };\n      ($($t:ty),*) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              let mut iter = line.split_whitespace();\n              (\n                  $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n              )\n          }\n      };\n      ($t:ty; $n:expr) => {\n          (0..$n).map(|_|\n              get!($t)\n          ).collect::<Vec<_>>()\n      };\n      ($($t:ty),*; $n:expr) => {\n          (0..$n).map(|_|\n              get!($($t),*)\n          ).collect::<Vec<_>>()\n      };\n      ($t:ty ;;) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              line.split_whitespace()\n                  .map(|t| t.parse::<$t>().unwrap())\n                  .collect::<Vec<_>>()\n          }\n      };\n      ($t:ty ;; $n:expr) => {\n          (0..$n).map(|_| get!($t ;;)).collect::<Vec<_>>()\n      };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let mut s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [$t:tt]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n#[allow(unused_macros)]\n#[cfg(debug_assertions)]\nmacro_rules! mydbg {\n    //($arg:expr) => (dbg!($arg))\n    //($arg:expr) => (println!(\""{:?}\"",$arg));\n      ($($a:expr),*) => {\n          eprintln!(concat!($(stringify!($a), \"" = {:?}, \""),*), $($a),*);\n      }\n}\n#[cfg(not(debug_assertions))]\nmacro_rules! mydbg {\n    ($($arg:expr),*) => {};\n}\n\nmacro_rules! echo {\n    ($($a:expr),*) => {\n          $(println!(\""{}\"",$a))*\n      }\n}\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::ops::{Add, Div, Mul, Sub};\n\n#[allow(dead_code)]\nstatic INF_I64: i64 = i64::max_value() / 2;\n#[allow(dead_code)]\nstatic INF_I32: i32 = i32::max_value() / 2;\n#[allow(dead_code)]\nstatic INF_USIZE: usize = usize::max_value() / 2;\n#[allow(dead_code)]\nstatic M_O_D: usize = 1000000007;\n#[allow(dead_code)]\nstatic PAI: f64 = 3.1415926535897932;\n\ntrait IteratorExt: Iterator {\n    fn toVec(self) -> Vec<Self::Item>;\n}\n\nimpl<T: Iterator> IteratorExt for T {\n    fn toVec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\ntrait CharExt {\n    fn toNum(&self) -> usize;\n    fn toAlphabetIndex(&self) -> usize;\n    fn toNumIndex(&self) -> usize;\n}\nimpl CharExt for char {\n    fn toNum(&self) -> usize {\n        return *self as usize;\n    }\n    fn toAlphabetIndex(&self) -> usize {\n        return self.toNum() - 'a' as usize;\n    }\n    fn toNumIndex(&self) -> usize {\n        return self.toNum() - '0' as usize;\n    }\n}\n\ntrait VectorExt {\n    fn joinToString(&self, s: &str) -> String;\n}\nimpl<T: ToString> VectorExt for Vec<T> {\n    fn joinToString(&self, s: &str) -> String {\n        return self\n            .iter()\n            .map(|x| x.to_string())\n            .collect::<Vec<_>>()\n            .join(s);\n    }\n}\n\ntrait StringExt {\n    fn get_reverse(&self) -> String;\n}\nimpl StringExt for String {\n    fn get_reverse(&self) -> String {\n        self.chars().rev().collect::<String>()\n    }\n}\n\ntrait UsizeExt {\n    fn pow(&self, n: usize) -> usize;\n}\nimpl UsizeExt for usize {\n    fn pow(&self, n: usize) -> usize {\n        return ((*self as u64).pow(n as u32)) as usize;\n    }\n}\n\nfn main() {\n    let T = get!(usize);\n    for testcase in 0..T {\n        let mut ans: usize = 0;\n        let (mut v, mut c, mut n, mut m) = get!(u64, u64, u64, u64);\n        if v > c {\n            std::mem::swap(&mut v, &mut c);\n        }\n        if m > v {\n            echo!(\""No\"");\n        } else if v - m + c < n {\n            echo!(\""No\"");\n        } else {\n            echo!(\""Yes\"");\n        }\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""716973821a6a38ea6231a427aeaa54ce"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_parens)]\n#![allow(unused_imports)]\n#![allow(non_upper_case_globals)]\n#![allow(non_snake_case)]\n#![allow(unused_mut)]\n#![allow(unused_variables)]\n#![allow(dead_code)]\n\n#[allow(unused_macros)]\nmacro_rules! invec {\n    ( $ t : ty ) => {{\n        let mut s = String::new();\n        match std::io::stdin().read_line(&mut s) {\n            Ok(0) => Vec::<$t>::new(),\n            Ok(n) => s\n                .trim()\n                .split_whitespace()\n                .map(|s| s.parse::<$t>().unwrap())\n                .collect::<Vec<$t>>(),\n            Err(_) => Vec::<$t>::new(),\n        }\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n      ($t:ty) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              line.trim().parse::<$t>().unwrap()\n          }\n      };\n      ($($t:ty),*) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              let mut iter = line.split_whitespace();\n              (\n                  $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n              )\n          }\n      };\n      ($t:ty; $n:expr) => {\n          (0..$n).map(|_|\n              get!($t)\n          ).collect::<Vec<_>>()\n      };\n      ($($t:ty),*; $n:expr) => {\n          (0..$n).map(|_|\n              get!($($t),*)\n          ).collect::<Vec<_>>()\n      };\n      ($t:ty ;;) => {\n          {\n              let mut line: String = String::new();\n              std::io::stdin().read_line(&mut line).unwrap();\n              line.split_whitespace()\n                  .map(|t| t.parse::<$t>().unwrap())\n                  .collect::<Vec<_>>()\n          }\n      };\n      ($t:ty ;; $n:expr) => {\n          (0..$n).map(|_| get!($t ;;)).collect::<Vec<_>>()\n      };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let mut s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [$t:tt]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n#[allow(unused_macros)]\n#[cfg(debug_assertions)]\nmacro_rules! mydbg {\n    //($arg:expr) => (dbg!($arg))\n    //($arg:expr) => (println!(\""{:?}\"",$arg));\n      ($($a:expr),*) => {\n          eprintln!(concat!($(stringify!($a), \"" = {:?}, \""),*), $($a),*);\n      }\n}\n#[cfg(not(debug_assertions))]\nmacro_rules! mydbg {\n    ($($arg:expr),*) => {};\n}\n\nmacro_rules! echo {\n    ($($a:expr),*) => {\n          $(println!(\""{}\"",$a))*\n      }\n}\n\nuse std::cmp::*;\nuse std::collections::*;\nuse std::ops::{Add, Div, Mul, Sub};\n\n#[allow(dead_code)]\nstatic INF_I64: i64 = i64::max_value() / 2;\n#[allow(dead_code)]\nstatic INF_I32: i32 = i32::max_value() / 2;\n#[allow(dead_code)]\nstatic INF_USIZE: usize = usize::max_value() / 2;\n#[allow(dead_code)]\nstatic M_O_D: usize = 1000000007;\n#[allow(dead_code)]\nstatic PAI: f64 = 3.1415926535897932;\n\ntrait IteratorExt: Iterator {\n    fn toVec(self) -> Vec<Self::Item>;\n}\n\nimpl<T: Iterator> IteratorExt for T {\n    fn toVec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\ntrait CharExt {\n    fn toNum(&self) -> usize;\n    fn toAlphabetIndex(&self) -> usize;\n    fn toNumIndex(&self) -> usize;\n}\nimpl CharExt for char {\n    fn toNum(&self) -> usize {\n        return *self as usize;\n    }\n    fn toAlphabetIndex(&self) -> usize {\n        return self.toNum() - 'a' as usize;\n    }\n    fn toNumIndex(&self) -> usize {\n        return self.toNum() - '0' as usize;\n    }\n}\n\ntrait VectorExt {\n    fn joinToString(&self, s: &str) -> String;\n}\nimpl<T: ToString> VectorExt for Vec<T> {\n    fn joinToString(&self, s: &str) -> String {\n        return self\n            .iter()\n            .map(|x| x.to_string())\n            .collect::<Vec<_>>()\n            .join(s);\n    }\n}\n\ntrait StringExt {\n    fn get_reverse(&self) -> String;\n}\nimpl StringExt for String {\n    fn get_reverse(&self) -> String {\n        self.chars().rev().collect::<String>()\n    }\n}\n\ntrait UsizeExt {\n    fn pow(&self, n: usize) -> usize;\n}\nimpl UsizeExt for usize {\n    fn pow(&self, n: usize) -> usize {\n        return ((*self as u64).pow(n as u32)) as usize;\n    }\n}\n\nfn main() {\n    let T = get!(usize);\n    for testcase in 0..T {\n        mydbg!(testcase);\n        let mut ans: usize = 0;\n        let (mut v, mut c, mut n, mut m) = get!(i64, i64, i64, i64);\n        mydbg!(v, c, n, m);\n\n        if v > c {\n            let x = min(m, c);\n            c -= x;\n            m -= x;\n        } else if v <= c {\n            let x = min(m, v);\n            v -= x;\n            m -= x;\n        }\n\n        mydbg!(v, c, n, m);\n        if v > c {\n            let x = min(n, v - c);\n            v -= x;\n            n -= x;\n        } else if v <= c {\n            let x = min(n, c - v);\n            c -= x;\n            n -= x;\n        }\n        mydbg!(v, c, n, m);\n\n        if n == 0 && m == 0 {\n            echo!(\""Yes\"");\n        } else {\n            echo!(\""No\"");\n        }\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""becfc1fd55b4f46b642ae54796c1a487"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""#![allow(unused_imports)]\n#![allow(dead_code)]\n \nuse std::io::Read;\n \n\nstruct State {\n    a: i64,\n    b: i64,\n    n: i64,\n    m: i64\n}\n\nfn solve(st: &mut State) {\n    let mut a = st.a;\n    let mut b = st.b;\n    if a < b {\n        std::mem::swap(&mut a, &mut b);   \n    }\n    if b < st.m {\n        print!(\""No\\n\"");\n        return;\n    }\n    b -= st.m;\n    if a + b >= st.n {\n        print!(\""Yes\\n\"");\n    }\n    else {\n        print!(\""No\\n\"");\n    }\n}\nfn main() {\n    let mut buffer = String::new();\n    std::io::stdin().read_to_string(&mut buffer).unwrap();\n    let mut input = buffer.split_whitespace();\n \n    let t: usize = input.next().unwrap().parse().unwrap();\n    for _ in 0..t {\n        let a: i64 = input.next().unwrap().parse().unwrap();\n        let b: i64 = input.next().unwrap().parse().unwrap();\n        let n: i64 = input.next().unwrap().parse().unwrap();\n        let m: i64 = input.next().unwrap().parse().unwrap();\n        //let a: Vec<i64> = (0..n).map(|_| input.next().unwrap().parse().unwrap()).collect();\n        solve(&mut State{a: a, b: b, n: n, m: m});\n    }\n \n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""3816a214151cc20527a319a7cb7fe1e9"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""//  ____            _                  _                       _       _\n// |  _ \\ _   _ ___| |_    ___ _ __   | |_ ___ _ __ ___  _ __ | | __ _| |_ ___\n// | |_) | | | / __| __|  / __| '_ \\  | __/ _ \\ '_ ` _ \\| '_ \\| |/ _` | __/ _ \\\n// |  _ <| |_| \\__ \\ |_  | (__| |_) | | ||  __/ | | | | | |_) | | (_| | ||  __/\n// |_| \\_\\\\__,_|___/\\__|  \\___| .__/___\\__\\___|_| |_| |_| .__/|_|\\__,_|\\__\\___|\n//                            |_| |_____|               |_|\n\n//https://github.com/manta1130/Competitive_Programming_Template_Rust\n\n#[macro_use]\nmod input {\n\n    use std;\n    use std::io;\n\n    const SPLIT_DELIMITER: char = ' ';\n\n    #[macro_export]\n    #[allow(unused_macros)]\n    macro_rules! input {\n    ( $($x:expr ),*) => {\n        {\n            let temp_str = input_line_str();\n            let mut split_result_iter = temp_str.split_whitespace();\n                $(\n                let buf_split_result = split_result_iter.next();\n                let buf_split_result = buf_split_result.unwrap();\n                    ($x) = buf_split_result.parse().unwrap();\n                )*\n        }\n    };\n}\n\n    #[allow(dead_code)]\n    pub fn input_line_str() -> String {\n        let mut s = String::new();\n        io::stdin().read_line(&mut s).unwrap();\n        s.trim().to_string()\n    }\n\n    #[allow(dead_code)]\n    pub fn p<T>(t: T)\n    where\n        T: std::fmt::Display,\n    {\n        println!(\""{}\"", t);\n    }\n\n    #[allow(dead_code)]\n    pub fn input_vector2d<T>(line: usize) -> Vec<Vec<T>>\n    where\n        T: std::str::FromStr,\n    {\n        let mut v: Vec<Vec<T>> = Vec::new();\n\n        for _ in 0..line {\n            let vec_line = input_vector();\n            v.push(vec_line);\n        }\n        v\n    }\n\n    #[allow(dead_code)]\n    pub fn input_vector<T>() -> Vec<T>\n    where\n        T: std::str::FromStr,\n    {\n        let mut v: Vec<T> = Vec::new();\n\n        let s = input_line_str();\n        let split_result = s.split(SPLIT_DELIMITER);\n        for z in split_result {\n            let buf = match z.parse() {\n                Ok(r) => r,\n                Err(_) => panic!(\""Parse Error\""),\n            };\n            v.push(buf);\n        }\n        v\n    }\n\n    #[allow(dead_code)]\n    pub fn input_vector_row<T>(n: usize) -> Vec<T>\n    where\n        T: std::str::FromStr,\n    {\n        let mut v = Vec::with_capacity(n);\n        for _ in 0..n {\n            let buf = match input_line_str().parse() {\n                Ok(r) => r,\n                Err(_) => panic!(\""Parse Error\""),\n            };\n            v.push(buf);\n        }\n        v\n    }\n\n    pub trait ToCharVec {\n        fn to_charvec(&self) -> Vec<char>;\n    }\n\n    impl ToCharVec for String {\n        fn to_charvec(&self) -> Vec<char> {\n            self.to_string().chars().collect::<Vec<_>>()\n        }\n    }\n}\n\nuse input::*;\nuse std::io::{stdout, BufWriter, Write};\nfn main() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    let t: usize;\n    input!(t);\n    for _ in 0..t {\n        let (mut a, mut b, mut n, m): (u64, u64, u64, u64);\n        input!(a, b, n, m);\n        if a + b < n + m {\n            writeln!(out, \""No\"").unwrap();\n            continue;\n        }\n        let diff = std::cmp::max(a, b) - std::cmp::min(a, b);\n        if a > b {\n            a -= std::cmp::min(diff, n);\n        } else {\n            b -= std::cmp::min(diff, n);\n        }\n        if diff > n {\n            n = 0;\n        } else {\n            n -= diff;\n        }\n        if std::cmp::min(a, b) < m {\n            writeln!(out, \""No\"").unwrap();\n            continue;\n        }\n        writeln!(out, \""Yes\"").unwrap();\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""41f2121957142a30b2d663820b329042"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""use std::cmp;\nuse std::io;\n\nstruct Scanner {\n    buffer: Vec<String>,\n}\n\nimpl Scanner {\n    fn next<T: std::str::FromStr>(&mut self) -> T {\n        if self.buffer.is_empty() {\n            let mut input = String::new();\n            io::stdin().read_line(&mut input).ok();\n            self.buffer = input\n                .trim()\n                .split(' ')\n                .map(|x| x.to_string())\n                .rev()\n                .collect();\n        }\n        let x = self.buffer.pop().unwrap();\n        match x.parse::<T>() {\n            Ok(y) => y,\n            _ => panic!(\""Parsing error !!!\""),\n        }\n    }\n}\n\nfn main() {\n    let mut scan = Scanner { buffer: Vec::new() };\n    let t = scan.next::<u32>();\n    for _test in 0..t {\n        let v = scan.next::<u64>();\n        let c = scan.next::<u64>();\n        let n = scan.next::<u64>();\n        let m = scan.next::<u64>();\n        if n + m <= v + c && cmp::min(v, c) >= m {\n            println!(\""Yes\"");\n        } else {\n            println!(\""No\"");\n        }\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""0bf0249df981052aaeeb489b11382107"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""// First Rust Submission\n\nuse std::io;\n\nfn mnm(x: u64, y: u64) -> u64 {\n    if x < y {\n        return x;\n    } else {\n        return y;\n    }\n}\n\nfn main() {\n    let mut line = String::new();\n    io::stdin().read_line(&mut line).unwrap();\n    let case: u32 = line.trim().parse().unwrap();\n    for test in 0..case {\n        line.clear();\n        io::stdin().read_line(&mut line).unwrap();\n        let input: Vec<&str> = line.split(' ').collect();\n        let v: u64 = input[0].trim().parse().unwrap();\n        let c: u64 = input[1].trim().parse().unwrap();\n        let n: u64 = input[2].trim().parse().unwrap();\n        let m: u64 = input[3].trim().parse().unwrap();\n        if v + c >= n + m && mnm(v, c) >= m {\n            println!(\""{}\"", \""YES\"");\n        } else {\n            println!(\""{}\"", \""NO\"");\n        }\n    }\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""ea0a14b308b0177123f9b440fbaf49fe"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""use std::io::{self, BufRead};\nuse std::cmp::min;\n\nfn main() {\n  let stdin = io::stdin();\n  let mut lines = stdin.lock().lines();\n  let t: usize = lines.next().unwrap().unwrap().parse().unwrap();\n  for _ in 0..t {\n    let xs: Vec<u64> = lines.next().unwrap().unwrap().split(' ').map(|x| x.parse().unwrap()).collect();\n    let (a, b, n, m) = (xs[0], xs[1], xs[2], xs[3]);\n    let c = min(a, b);\n    let ok = m <= c && m + n <= a + b;\n    println!(\""{}\"", if ok { \""Yes\"" } else { \""No\"" });\n  }\n}"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""cc5388c57d67f8edd3359905fead33a9"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
{""lang"": ""Rust"", ""source_code"": ""//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 \u3088\u308a\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, bytes) => {\n        read_value!($iter, String).bytes().collect::<Vec<u8>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\""Parse error\"")\n    };\n}\n\n//\n\nuse std::io::Write;\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        t: usize,\n        ask: [(i64, i64, i64, i64); t],\n    }\n    for (mut a, mut b, n, m) in ask {\n        if a < b {\n            std::mem::swap(&mut a, &mut b);\n        }\n        let ans = if b < m || a + b < n + m {\n            \""No\""\n        } else {\n            \""Yes\""\n        };\n        writeln!(out, \""{}\"", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n"", ""lang_cluster"": ""Rust"", ""compilation_error"": false, ""code_uid"": ""7c2c5be44f85b2c1ac5f8389bcba0518"", ""src_uid"": ""0f960d19e576b7421a7c7a7166a884ea"", ""difficulty"": 1300}
"
b58p4ARB,IndexedArray,LeonMMS,Ruby,Monday 16th of June 2025 03:13:42 PM CDT,"class IndexedArray
  include Enumerable
  def initialize
    @hash = {}
    @open = []
    @last = 0
  end

  def << (value)
    id =  @open.empty? ? @hash.size : @open.shift
    @hash[id] = value
    @last = id
  end

  def delete(id)
    @hash.delete(id)
    @open << id
    if @hash.empty?
      @open.clear
    else
      max_index = @hash.keys.max
      @open.select! { |i| i <= max_index }
      @open.sort!
    end
  end
  
  def [](id)
    @hash[id]
  end

  def each
    return enum_for(:each) unless block_given?
    @hash.keys.each do |id|
      yield @hash[id] if @hash.key?(id)
    end
  end

  def each_with_index
    @hash.keys.each do |id|
      yield @hash[id], id if @hash.key?(id)
    end
  end

  def include?(id)
    @hash.key?(id)
  end

  def index(value)
    @hash.key(value)
  end

  def each_index
    @hash.keys.each do |id|
      yield id if @hash.key?(id)
    end
  end

  def clear
    @hash.clear
    @open.clear
  end

  def size
    @hash.size
  end

  def last
    @hash[@last]
  end

end"
5PGfCpm2,public  static bool ProcessConsoleEvent,Jh0n-K3v1n,C#,Monday 16th of June 2025 02:57:12 PM CDT,"public  static bool ProcessConsoleEvent(int type)
{
    try
    {
        if (ServerConfig.IsInterServer)
        {
            foreach (var client in Database.Server.GamePoll.Values)
            {
                try
                {
                    if (client.Socket != null)//for my fake accounts !
                        client.Socket.Disconnect();
                }
                catch (Exception e)
                {
                    MyConsole.WriteLine(e.ToString());
                }
            }
            return true;
        }
        try
        {
            if (WebServer.Proces.AccServer != null)
            {
                WebServer.Proces.Close();
                WebServer.Proces.AccServer.Close();
            }
            if (GameServer != null)
                GameServer.Close();

           
        }
      catch (Exception e) { MyConsole.SaveException(e); }

        try
        {
            foreach (var user in WebServer.LoaderServer.Clients.Values)
                user.Disconnect();
        }
        catch(Exception e)
        {
            MyConsole.SaveException(e);
        }
        Console.ForegroundColor = System.ConsoleColor.DarkGreen;
        MyConsole.WriteLine(""  "" + ""Guardando datos..."");
        Console.ForegroundColor = System.ConsoleColor.Yellow;
  

        foreach (var client in Database.Server.GamePoll.Values)
        {
            try
            {
                if (client.Socket != null)//for my fake accounts !
                    client.Socket.Disconnect();
            }
            catch (Exception e)
            {
                MyConsole.WriteLine(e.ToString());
            }
        }
        Role.Instance.Clan.ProcessChangeNames();

        Database.Server.SaveDatabase();
        if (Database.ServerDatabase.LoginQueue.Finish())
        {
            System.Threading.Thread.Sleep(1000);
            MyConsole.WriteLine(""  "" + ""Base de datos guardada correctamente."");
        }
    }
    catch (Exception e)
    {
        MyConsole.SaveException(e);
    }
    return true;
}"
DTNh6RSR,Untitled,asdfg0998,C++,Monday 16th of June 2025 02:56:20 PM CDT,"string getLunarPhase(string season, int dayCount, string initialPhase) {
    vector<string> phases = {
        ""NewMoon"", ""Crescent"", ""Quarter"", ""Gibbous"",
        ""Full"", ""Waning"", ""Eclipse"", ""Twilight""
    };

    unordered_map<string, int> monthDays = {
        {""January"", 31}, {""February"", 28}, {""March"", 31}, {""April"", 30},
        {""May"", 31}, {""June"", 30}, {""July"", 31}, {""August"", 31},
        {""September"", 30}, {""October"", 31}, {""November"", 30}, {""December"", 31}
    };

    unordered_map<string, int> phaseIndex;
    for (int i = 0; i < phases.size(); ++i)
        phaseIndex[phases[i]] = i;

    // Step 1: Calculate total days from Jan 1 to (season, dayCount)
    int daysPassed = 0;
    for (auto& [month, days] : monthDays) {
        if (month == season) break;
        daysPassed += days;
    }
    daysPassed += (dayCount - 1);  // 0-based offset

    // Step 2: Compute the resulting phase
    int startPhaseIdx = phaseIndex[initialPhase];
    int resultIdx = (startPhaseIdx + daysPassed) % 8;
    return phases[resultIdx];
}"
KWvV6fTm,Untitled,asdfg0998,C++,Monday 16th of June 2025 02:52:22 PM CDT,"    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};
    int count = 0;

    for (int i = 0; i + 2 < text.length(); ++i) {
        int vowelCount = 0;

        for (int j = i; j < i + 3; ++j) {
            if (vowels.count(text[j])) {
                vowelCount++;
            }
        }

        if (vowelCount == 2) {
            count++;
        }
    }

    return count;
}"
9Mi5Rbni,docker compose /app y traefik,pilasguru,YAML,Monday 16th of June 2025 02:35:41 PM CDT,"# Traefik console 8080
# /app access 80

$ docker network create proxy

# ---
services:
  traefik:
    image: traefik:latest
    command:
      - ""--api.insecure=true""
      - ""--providers.docker=true""
      - ""--entrypoints.web.address=:80""
    ports:
      - ""80:80""
      - ""8080:8080""
    volumes:
      - ""/var/run/docker.sock:/var/run/docker.sock:ro""
    networks:
      - proxy
    labels:
      - ""traefik.enable=false""
networks:
  proxy:
    external: true

# ---
services:
  web:
    image: nginx:latest
    command: >-
      bash -c ""COLORS=('red' 'green' 'blue' 'yellow' 'cyan' 'magenta' 'orange' 'purple' 'pink' 'lime' 'teal' 'brown' 'gold' 'navy' 'olive' 'maroon' 'aqua' 'coral' 'salmon' 'violet');
      COLOR=$${COLORS[$$RANDOM % $${#COLORS[@]}]};
      echo \""<html><body style='background: $$COLOR; color: #ffffff; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; font-size: 24px;'><h1>Mi color de fondo es $$COLOR</h1></body></html>\"" > /usr/share/nginx/html/index.html && nginx -g 'daemon off;'""
    labels:
      - ""traefik.enable=true""
      - ""traefik.http.routers.mi_servicio.rule=PathPrefix(`/app`)""
      - ""traefik.http.routers.mi_servicio.middlewares=strip-app""
      - ""traefik.http.middlewares.strip-app.stripprefix.prefixes=/app""
      - ""traefik.http.services.mi_servicio.loadbalancer.server.port=80""
    deploy:
      replicas: 3
    networks:
      - proxy
networks:
  proxy:
    external: true

"
DTNsguW1,chess plugin,advocaite,C#,Monday 16th of June 2025 02:12:27 PM CDT,"using System;
using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using System.Linq;

namespace Oxide.Plugins
{
    [Info(""ChessPlugin"", ""GrndThftJono & Grok"", ""1.2.2"")]
    [Description(""A chess game integrated into Rust with a clickable GUI and spectator mode."")]
    public class ChessPlugin : CSharpPlugin
    {
        private Dictionary<string, ChessGame> games = new Dictionary<string, ChessGame>();
        private Dictionary<string, PlayerStats> playerStats = new Dictionary<string, PlayerStats>();
        private const string DataFilePath = ""ChessPlugin/games"";
        private const string StatsFilePath = ""ChessPlugin/playerstats"";
        private const string PlayerPermission = ""chessplugin.use"";
        private const string AdminPermission = ""chessplugin.admin"";
        private readonly Dictionary<string, string> playerGUIs = new Dictionary<string, string>();
        private Configuration config;
        private bool debugMode = true;
        private readonly Dictionary<string, float> lastClickTimes = new Dictionary<string, float>(); // For click debouncing

        [PluginReference] private Plugin Economics, ServerRewards;

        private class Configuration
        {
            public Dictionary<string, string> Colors { get; set; } = new Dictionary<string, string>
            {
                { ""Background"", ""0.1 0.1 0.1 0.8"" },
                { ""LightSquare"", ""0.8 0.8 0.8 1"" },
                { ""DarkSquare"", ""0.4 0.4 0.4 1"" },
                { ""Highlight"", ""0 1 0 0.5"" },
                { ""Selected"", ""1 1 0 0.5"" },
                { ""Button"", ""0.2 0.5 0.2 0.8"" },
                { ""ButtonClose"", ""0.5 0.2 0.2 0.8"" },
                { ""UndoLabel"", ""1 1 0 1"" },
                { ""UndoActiveLabel"", ""0 1 0 1"" }
            };
        }

        private enum PieceType
        {
            Empty,
            Pawn,
            Knight,
            Bishop,
            Rook,
            Queen,
            King
        }

        private class Piece
        {
            public PieceType Type { get; set; }
            public bool IsWhite { get; set; }
        }

        private class KingPositions
        {
            public int WhiteRow { get; set; }
            public int WhiteCol { get; set; }
            public int BlackRow { get; set; }
            public int BlackCol { get; set; }
        }

        private class LastMove
        {
            public int RowFrom { get; set; }
            public int ColFrom { get; set; }
            public int RowTo { get; set; }
            public int ColTo { get; set; }
            public Piece MovedPiece { get; set; }
            public Piece CapturedPiece { get; set; }
            public (bool WhiteKingside, bool WhiteQueenside, bool BlackKingside, bool BlackQueenside) CastlingBeforeMove { get; set; }
            public (int Row, int Col)? EnPassantBeforeMove { get; set; }
            public bool WasCastling { get; set; }
            public bool WasEnPassant { get; set; }
            public bool WhiteToMoveBefore { get; set; }
        }

        private class ChessGame
        {
            public Piece[,] Board { get; set; } = new Piece[8, 8];
            public bool WhiteToMove { get; set; } = true;
            public (bool WhiteKingside, bool WhiteQueenside, bool BlackKingside, bool BlackQueenside) Castling { get; set; } = (true, true, true, true);
            public (int Row, int Col)? EnPassant { get; set; }
            public KingPositions KingPos { get; set; } = new KingPositions { WhiteRow = 0, WhiteCol = 4, BlackRow = 7, BlackCol = 4 };
            public string BluePlayerId { get; set; }
            public string RedPlayerId { get; set; }
            public (int Row, int Col)? SelectedSquare { get; set; }
            public HashSet<(int Row, int Col)> LegalMoves { get; set; } = new HashSet<(int Row, int Col)>();
            public bool IsCastlingSelected { get; set; } = false;
            public string Status { get; set; } = ""Waiting for players"";
            public string GameId { get; set; }
            public HashSet<string> SpectatorIds { get; set; } = new HashSet<string>();
            public bool IsSolo { get; set; } = false;
            public bool GameEnded { get; set; } = false;
            public LastMove LastMove { get; set; }
            public bool UndoRequested { get; set; } = false;
            public bool UndoUsedThisTurn { get; set; } = false;
            public int LastUndoTurn { get; set; } = -1;
            public int TurnNumber { get; set; } = 0;

            public ChessGame(string gameId)
            {
                GameId = gameId;
                InitializeBoard();
            }

            private void InitializeBoard()
            {
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                        Board[i, j] = new Piece { Type = PieceType.Empty };

                for (int i = 0; i < 8; i++)
                {
                    Board[1, i] = new Piece { Type = PieceType.Pawn, IsWhite = true };
                    Board[6, i] = new Piece { Type = PieceType.Pawn, IsWhite = false };
                }

                PieceType[] backRank = { PieceType.Rook, PieceType.Knight, PieceType.Bishop, PieceType.Queen, PieceType.King, PieceType.Bishop, PieceType.Knight, PieceType.Rook };
                for (int i = 0; i < 8; i++)
                {
                    Board[0, i] = new Piece { Type = backRank[i], IsWhite = true };
                    Board[7, i] = new Piece { Type = backRank[i], IsWhite = false };
                }

                KingPos.WhiteRow = 0;
                KingPos.WhiteCol = 4;
                KingPos.BlackRow = 7;
                KingPos.BlackCol = 4;
            }
        }

        private class PlayerStats
        {
            public int Wins { get; set; }
            public int Losses { get; set; }
            public int Draws { get; set; }
        }

        private void Init()
        {
            permission.RegisterPermission(PlayerPermission, this);
            permission.RegisterPermission(AdminPermission, this);
            LoadConfig();
            LoadData();
            LoadStats();
            RegisterCommands();
            Puts(""ChessPlugin loaded."");
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyGUI(player);
            SaveData();
            SaveStats();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LogDebug(""Configuration file not found, creating new one."");
                    config = new Configuration();
                    SaveConfig();
                }
            }
            catch (Exception ex)
            {
                Puts($""Error loading configuration: {ex.Message}. Creating default configuration."");
                config = new Configuration();
                SaveConfig();
            }
        }

        protected override void SaveConfig()
        {
            try
            {
                Config.WriteObject(config);
                LogDebug(""Configuration saved."");
            }
            catch (Exception ex)
            {
                Puts($""Error saving configuration: {ex.Message}"");
            }
        }

        private void LoadData()
        {
            try
            {
                games = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, ChessGame>>(DataFilePath);
                if (games == null)
                {
                    LogDebug(""Chess game data not found, initializing empty games."");
                    games = new Dictionary<string, ChessGame>();
                    SaveData();
                }
                Puts($""Loaded {games.Count} chess games."");
            }
            catch (Exception ex)
            {
                Puts($""Error loading chess data: {ex.Message}. Initializing empty games."");
                games = new Dictionary<string, ChessGame>();
                SaveData();
            }
        }

        private void SaveData()
        {
            try
            {
                Interface.Oxide.DataFileSystem.WriteObject(DataFilePath, games);
                LogDebug(""Saved chess game data."");
            }
            catch (Exception ex)
            {
                Puts($""Error saving chess data: {ex.Message}"");
            }
        }

        private void LoadStats()
        {
            try
            {
                playerStats = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, PlayerStats>>(StatsFilePath);
                if (playerStats == null)
                {
                    LogDebug(""Player stats data not found, initializing empty stats."");
                    playerStats = new Dictionary<string, PlayerStats>();
                    SaveStats();
                }
                Puts($""Loaded {$""{playerStats.Count} player stats""}."");
            }
            catch (Exception ex)
            {
                Puts($""Error loading player stats: {ex.Message}. Initializing empty stats."");
                playerStats = new Dictionary<string, PlayerStats>();
                SaveStats();
            }
        }

        private void SaveStats()
        {
            try
            {
                Interface.Oxide.DataFileSystem.WriteObject(StatsFilePath, playerStats);
                LogDebug(""Saved player stats data."");
            }
            catch (Exception ex)
            {
                Puts($""Error saving player stats: {ex.Message}"");
            }
        }

        private void LogDebug(string message)
        {
            if (debugMode)
                Puts($""[DEBUG] {message}"");
        }

        private HashSet<(int Row, int Col)> GetLegalMoves(ChessGame game, int row, int col)
        {
            var moves = new HashSet<(int Row, int Col)>();
            var piece = game.Board[row, col];
            if (piece.Type == PieceType.Empty || piece.IsWhite != game.WhiteToMove)
            {
                LogDebug($""No legal moves: Empty or wrong color at {row},{col}"");
                return moves;
            }

            bool inCheck = IsInCheck(game, game.WhiteToMove);
            LogDebug($""Checking moves for {piece.Type} at {row},{col}. In check: {inCheck}"");

            var tempMoves = new HashSet<(int Row, int Col)>();

            switch (piece.Type)
            {
                case PieceType.Pawn:
                    int direction = piece.IsWhite ? 1 : -1;
                    int startRow = piece.IsWhite ? 1 : 6;
                    int newRow = row + direction;
                    if (newRow >= 0 && newRow < 8 && game.Board[newRow, col].Type == PieceType.Empty)
                    {
                        tempMoves.Add((newRow, col));
                        if (row == startRow && game.Board[newRow + direction, col].Type == PieceType.Empty)
                            tempMoves.Add((newRow + direction, col));
                    }
                    foreach (int dc in new int[] { -1, 1 })
                    {
                        int newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8)
                        {
                            if (game.Board[newRow, newCol].Type != PieceType.Empty && game.Board[newRow, newCol].IsWhite != piece.IsWhite)
                                tempMoves.Add((newRow, newCol));
                            if (game.EnPassant == (newRow, newCol))
                                tempMoves.Add((newRow, newCol));
                        }
                    }
                    break;
                case PieceType.Knight:
                    var knightOffsets = new (int, int)[] { (-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1) };
                    foreach (var (dr, dc) in knightOffsets)
                    {
                        int r = row + dr, c = col + dc;
                        if (r >= 0 && r < 8 && c >= 0 && c < 8 && (game.Board[r, c].Type == PieceType.Empty || game.Board[r, c].IsWhite != piece.IsWhite))
                            tempMoves.Add((r, c));
                    }
                    break;
                case PieceType.Bishop:
                    AddSlidingMoves(game, tempMoves, row, col, piece.IsWhite, new (int, int)[] { (1, 1), (1, -1), (-1, 1), (-1, -1) });
                    break;
                case PieceType.Rook:
                    AddSlidingMoves(game, tempMoves, row, col, piece.IsWhite, new (int, int)[] { (1, 0), (0, 1), (-1, 0), (0, -1) });
                    break;
                case PieceType.Queen:
                    AddSlidingMoves(game, tempMoves, row, col, piece.IsWhite, new (int, int)[] { (1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1) });
                    break;
                case PieceType.King:
                    var kingOffsets = new (int, int)[] { (1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1) };
                    foreach (var (dr, dc) in kingOffsets)
                    {
                        int r = row + dr, c = col + dc;
                        if (r >= 0 && r < 8 && c >= 0 && c < 8 && (game.Board[r, c].Type == PieceType.Empty || game.Board[r, c].IsWhite != piece.IsWhite))
                            tempMoves.Add((r, c));
                    }
                    if (!inCheck)
                    {
                        if (piece.IsWhite)
                        {
                            if (game.Castling.WhiteKingside && game.Board[0, 5].Type == PieceType.Empty && game.Board[0, 6].Type == PieceType.Empty)
                                tempMoves.Add((0, 6));
                            if (game.Castling.WhiteQueenside && game.Board[0, 1].Type == PieceType.Empty && game.Board[0, 2].Type == PieceType.Empty && game.Board[0, 3].Type == PieceType.Empty)
                                tempMoves.Add((0, 2));
                        }
                        else
                        {
                            if (game.Castling.BlackKingside && game.Board[7, 5].Type == PieceType.Empty && game.Board[7, 6].Type == PieceType.Empty)
                                tempMoves.Add((7, 6));
                            if (game.Castling.BlackQueenside && game.Board[7, 1].Type == PieceType.Empty && game.Board[7, 2].Type == PieceType.Empty && game.Board[7, 3].Type == PieceType.Empty)
                                tempMoves.Add((7, 2));
                        }
                    }
                    break;
            }

            foreach (var move in tempMoves)
            {
                if (IsLegalMove(game, row, col, move.Row, move.Col))
                {
                    moves.Add(move);
                    LogDebug($""Legal move for {piece.Type} from {row},{col} to {move.Row},{move.Col}"");
                }
                else
                {
                    LogDebug($""Illegal move for {piece.Type} from {row},{col} to {move.Row},{move.Col} (leaves king in check)"");
                }
            }

            return moves;
        }

        private bool IsLegalMove(ChessGame game, int rowFrom, int colFrom, int rowTo, int colTo)
        {
            var originalPiece = game.Board[rowFrom, colFrom];
            var targetPiece = game.Board[rowTo, colTo];
            if (targetPiece.Type != PieceType.Empty && targetPiece.IsWhite == originalPiece.IsWhite)
            {
                LogDebug($""Invalid move: Cannot capture own piece at {rowTo},{colTo} from {rowFrom},{colFrom}"");
                return false;
            }

            var originalEnPassant = game.EnPassant;
            var originalKingPos = new KingPositions
            {
                WhiteRow = game.KingPos.WhiteRow,
                WhiteCol = game.KingPos.WhiteCol,
                BlackRow = game.KingPos.BlackRow,
                BlackCol = game.KingPos.BlackCol
            };
            var originalCastling = game.Castling;

            game.Board[rowTo, colTo] = originalPiece;
            game.Board[rowFrom, colFrom] = new Piece { Type = PieceType.Empty };

            if (originalPiece.Type == PieceType.King)
            {
                bool isCastling = (rowFrom == rowTo) && (colFrom == 4) && (colTo == 6 || colTo == 2);
                if (isCastling)
                {
                    int rookFromCol = colTo == 6 ? 7 : 0;
                    int rookToCol = colTo == 6 ? 5 : 3;
                    var rookPiece = game.Board[rowTo, rookFromCol];
                    if (rookPiece == null || rookPiece.Type != PieceType.Rook || rookPiece.IsWhite != originalPiece.IsWhite)
                    {
                        LogDebug($""Invalid castling: No valid rook at {rowTo},{rookFromCol}"");
                        game.Board[rowFrom, colFrom] = originalPiece;
                        game.Board[rowTo, colTo] = targetPiece;
                        return false;
                    }
                    game.Board[rowTo, rookToCol] = rookPiece;
                    game.Board[rowTo, rookFromCol] = new Piece { Type = PieceType.Empty };
                }

                if (originalPiece.IsWhite)
                {
                    game.KingPos.WhiteRow = rowTo;
                    game.KingPos.WhiteCol = colTo;
                    game.Castling = (false, false, game.Castling.BlackKingside, game.Castling.BlackQueenside);
                }
                else
                {
                    game.KingPos.BlackRow = rowTo;
                    game.KingPos.BlackCol = colTo;
                    game.Castling = (game.Castling.WhiteKingside, game.Castling.WhiteQueenside, false, false);
                }
            }
            else if (originalPiece.Type == PieceType.Pawn)
            {
                if ((originalPiece.IsWhite && rowTo == 7) || (!originalPiece.IsWhite && rowTo == 0))
                    game.Board[rowTo, colTo] = new Piece { Type = PieceType.Queen, IsWhite = originalPiece.IsWhite };
                game.EnPassant = null;
                if (Math.Abs(rowFrom - rowTo) == 2)
                    game.EnPassant = (rowFrom + (originalPiece.IsWhite ? 1 : -1), colFrom);
                else if (originalEnPassant == (rowTo, colTo))
                    game.Board[originalPiece.IsWhite ? rowTo - 1 : rowTo + 1, colTo] = new Piece { Type = PieceType.Empty };
            }
            else if (originalPiece.Type == PieceType.Rook)
            {
                if (originalPiece.IsWhite)
                {
                    if (rowFrom == 0 && colFrom == 0)
                        game.Castling = (game.Castling.WhiteKingside, false, game.Castling.BlackKingside, game.Castling.BlackQueenside);
                    else if (rowFrom == 0 && colFrom == 7)
                        game.Castling = (false, game.Castling.WhiteQueenside, game.Castling.BlackKingside, game.Castling.BlackQueenside);
                }
                else
                {
                    if (rowFrom == 7 && colFrom == 0)
                        game.Castling = (game.Castling.WhiteKingside, game.Castling.WhiteQueenside, game.Castling.BlackKingside, false);
                    else if (rowFrom == 7 && colFrom == 7)
                        game.Castling = (game.Castling.WhiteKingside, game.Castling.WhiteQueenside, false, game.Castling.BlackQueenside);
                }
            }

            bool isInCheck = IsInCheck(game, originalPiece.IsWhite);

            game.Board[rowFrom, colFrom] = originalPiece;
            game.Board[rowTo, colTo] = targetPiece;
            game.EnPassant = originalEnPassant;
            game.KingPos = originalKingPos;
            game.Castling = originalCastling;

            return !isInCheck;
        }

        private bool MakeMove(ChessGame game, int rowFrom, int colFrom, int rowTo, int colTo)
        {
            try
            {
                var piece = game.Board[rowFrom, colFrom];
                if (piece.Type == PieceType.Empty || piece.IsWhite != game.WhiteToMove)
                {
                    LogDebug($""Invalid move attempt in game {game.GameId}: {rowFrom},{colFrom} to {rowTo},{colTo} (empty or wrong color)"");
                    return false;
                }

                if (!game.LegalMoves.Contains((rowTo, colTo)))
                {
                    LogDebug($""Illegal move in game {game.GameId}: {rowFrom},{colFrom} to {rowTo},{colTo} (not in legal moves)"");
                    return false;
                }

                var targetPiece = game.Board[rowTo, colTo];
                bool isCastling = piece.Type == PieceType.King && rowFrom == rowTo && colFrom == 4 && (colTo == 6 || colTo == 2);
                bool isEnPassant = piece.Type == PieceType.Pawn && game.EnPassant == (rowTo, colTo);

                var lastMove = new LastMove
                {
                    RowFrom = rowFrom,
                    ColFrom = colFrom,
                    RowTo = rowTo,
                    ColTo = colTo,
                    MovedPiece = new Piece { Type = piece.Type, IsWhite = piece.IsWhite },
                    CapturedPiece = targetPiece.Type != PieceType.Empty ? new Piece { Type = targetPiece.Type, IsWhite = targetPiece.IsWhite } : null,
                    CastlingBeforeMove = game.Castling,
                    EnPassantBeforeMove = game.EnPassant,
                    WasCastling = isCastling,
                    WasEnPassant = isEnPassant,
                    WhiteToMoveBefore = game.WhiteToMove
                };

                if (targetPiece.Type == PieceType.King)
                {
                    game.GameEnded = true;
                    game.Status = piece.IsWhite ? ""Blue wins!"" : ""Red wins!"";
                    game.LastMove = lastMove;
                    RecordGameResult(game, piece.IsWhite ? ""Blue"" : ""Red"");
                    ShowBannerToAll($""Game {game.GameId}: {game.Status} (King captured!)"");
                    SaveData();
                    return true;
                }

                LogDebug($""Pre-move board state for game {game.GameId}:\n{DumpBoardState(game)}"");

                if (isCastling)
                {
                    LogDebug($""Executing castling move in game {game.GameId}: King from {rowFrom},{colFrom} to {rowTo},{colTo}"");
                    int rookFromCol = colTo == 6 ? 7 : 0;
                    int rookToCol = colTo == 6 ? 5 : 3;
                    var rookPiece = game.Board[rowTo, rookFromCol];

                    if (rookPiece == null || rookPiece.Type != PieceType.Rook || rookPiece.IsWhite != piece.IsWhite)
                    {
                        LogDebug($""Invalid rook at {rowTo},{rookFromCol} for castling in game {game.GameId}"");
                        return false;
                    }

                    // Move rook
                    game.Board[rowTo, rookToCol] = rookPiece;
                    game.Board[rowTo, rookFromCol] = new Piece { Type = PieceType.Empty };
                    LogDebug($""Castling: Rook moved from {rowTo},{rookFromCol} to {rowTo},{rookToCol}"");

                    // Move king
                    game.Board[rowTo, colTo] = piece;
                    game.Board[rowFrom, colFrom] = new Piece { Type = PieceType.Empty };
                    LogDebug($""Castling: King moved from {rowFrom},{colFrom} to {rowTo},{colTo}"");

                    if (piece.IsWhite)
                    {
                        game.KingPos.WhiteRow = rowTo;
                        game.KingPos.WhiteCol = colTo;
                        game.Castling = (false, false, game.Castling.BlackKingside, game.Castling.BlackQueenside);
                    }
                    else
                    {
                        game.KingPos.BlackRow = rowTo;
                        game.KingPos.BlackCol = colTo;
                        game.Castling = (game.Castling.WhiteKingside, game.Castling.WhiteQueenside, false, false);
                    }
                }
                else
                {
                    game.Board[rowTo, colTo] = piece;
                    game.Board[rowFrom, colFrom] = new Piece { Type = PieceType.Empty };

                    if (piece.Type == PieceType.King)
                    {
                        if (piece.IsWhite)
                        {
                            game.KingPos.WhiteRow = rowTo;
                            game.KingPos.WhiteCol = colTo;
                            game.Castling = (false, false, game.Castling.BlackKingside, game.Castling.BlackQueenside);
                        }
                        else
                        {
                            game.KingPos.BlackRow = rowTo;
                            game.KingPos.BlackCol = colTo;
                            game.Castling = (game.Castling.WhiteKingside, game.Castling.WhiteQueenside, false, false);
                        }
                    }
                    else if (piece.Type == PieceType.Rook)
                    {
                        if (piece.IsWhite)
                        {
                            if (rowFrom == 0 && colFrom == 0)
                                game.Castling = (game.Castling.WhiteKingside, false, game.Castling.BlackKingside, game.Castling.BlackQueenside);
                            else if (rowFrom == 0 && colFrom == 7)
                                game.Castling = (false, game.Castling.WhiteQueenside, game.Castling.BlackKingside, game.Castling.BlackQueenside);
                        }
                        else
                        {
                            if (rowFrom == 7 && colFrom == 0)
                                game.Castling = (game.Castling.WhiteKingside, game.Castling.WhiteQueenside, game.Castling.BlackKingside, false);
                            else if (rowFrom == 7 && colFrom == 7)
                                game.Castling = (game.Castling.WhiteKingside, game.Castling.WhiteQueenside, false, game.Castling.BlackQueenside);
                        }
                    }
                    else if (piece.Type == PieceType.Pawn)
                    {
                        // Handle pawn promotion
                        if ((piece.IsWhite && rowTo == 7) || (!piece.IsWhite && rowTo == 0))
                            game.Board[rowTo, colTo] = new Piece { Type = PieceType.Queen, IsWhite = piece.IsWhite };
                        
                        // Handle en passant capture - remove the captured pawn
                        if (isEnPassant)
                        {
                            int capturedPawnRow = piece.IsWhite ? rowTo - 1 : rowTo + 1;
                            game.Board[capturedPawnRow, colTo] = new Piece { Type = PieceType.Empty };
                            LogDebug($""En passant capture: Removed enemy pawn at {capturedPawnRow},{colTo}"");
                        }
                        
                        // Set en passant target square if pawn moved 2 squares
                        if (Math.Abs(rowFrom - rowTo) == 2)
                        {
                            game.EnPassant = (rowFrom + (piece.IsWhite ? 1 : -1), colFrom);
                            LogDebug($""En passant target set at {game.EnPassant}"");
                        }
                    }
                    
                    // Clear en passant target for any non-pawn double move
                    if (piece.Type != PieceType.Pawn || Math.Abs(rowFrom - rowTo) != 2)
                    {
                        game.EnPassant = null;
                    }
                }

                game.LastMove = lastMove;

                LogDebug($""Post-move board state for game {game.GameId}:\n{DumpBoardState(game)}"");
                if (isCastling)
                    LogDebug($""Castling completed: Board[{rowTo},{(colTo == 5 ? 4 : 2)}]={game.Board[rowTo, (colTo == 5 ? 4 : 2)]?.Type}, Board[{rowTo},{(colTo == 5 ? 7 : 0)}]={game.Board[rowTo, (colTo == 5 ? 7 : 0)]?.Type}"");

                game.WhiteToMove = !game.WhiteToMove;
                game.TurnNumber++;
                game.UndoUsedThisTurn = false;
                game.IsCastlingSelected = false;
                SaveData();
                LogDebug($""Board state saved for game {game.GameId} after move"");

                if (IsCheckmate(game))
                {
                    game.GameEnded = true;
                    game.Status = game.WhiteToMove ? ""Red wins!"" : ""Blue wins!"";
                    RecordGameResult(game, game.WhiteToMove ? ""Red"" : ""Blue"");
                    ShowBannerToAll($""Game {game.GameId}: {game.Status}"");
                }
                else if (IsStalemate(game))
                {
                    game.GameEnded = true;
                    game.Status = ""Draw by stalemate!"";
                    RecordGameResult(game, ""Draw"");
                    ShowBannerToAll($""Game {game.GameId}: {game.Status}"");
                }
                else if (IsInsufficientMaterial(game))
                {
                    game.GameEnded = true;
                    game.Status = ""Draw by insufficient material!"";
                    RecordGameResult(game, ""Draw"");
                    ShowBannerToAll($""Game {game.GameId}: {game.Status}"");
                }

                LogDebug($""Move completed in game {game.GameId}: {rowFrom},{colFrom} to {rowTo},{colTo}"");
                return true;
            }
            catch (Exception ex)
            {
                Puts($""Error in MakeMove for game {game.GameId}: {ex.Message}"");
                return false;
            }
        }

        private void RequestUndo(IPlayer player, ChessGame game)
        {
            if (game.GameEnded)
            {
                player.Reply(""Cannot request undo after the game has ended!"");
                return;
            }

            if (game.IsSolo)
            {
                game.UndoRequested = true;
                SaveData();
                player.Reply(""Undo request accepted (solo mode). Click 'Undo' to revert the last move."");
            }
            else
            {
                if (game.UndoRequested)
                {
                    player.Reply(""An undo request is already pending!"");
                    return;
                }

                game.UndoRequested = true;
                SaveData();

                var otherPlayerId = game.WhiteToMove ? game.RedPlayerId : game.BluePlayerId;
                var otherPlayer = covalence.Players.FindPlayerById(otherPlayerId);
                if (otherPlayer != null && otherPlayer.IsConnected)
                {
                    otherPlayer.Reply($""{player.Name} has requested to undo the last move. Click 'Undo Requested (Accept?)' to accept."");
                }

                player.Reply(""Undo request sent to the other player."");
            }

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p.UserIDString == game.BluePlayerId || p.UserIDString == game.RedPlayerId)
                    ShowGUI(covalence.Players.FindPlayerById(p.UserIDString), game, false);
                else if (game.SpectatorIds.Contains(p.UserIDString))
                    ShowGUI(covalence.Players.FindPlayerById(p.UserIDString), game, true);
            }
        }

        private void AcceptUndo(IPlayer player, ChessGame game)
        {
            if (!game.UndoRequested)
            {
                player.Reply(""No undo request is pending!"");
                return;
            }

            if (game.IsSolo)
            {
                player.Reply(""Undo requests are not needed in solo mode!"");
                return;
            }

            var requestingPlayerId = game.WhiteToMove ? game.RedPlayerId : game.BluePlayerId;
            if (player.Id == requestingPlayerId)
            {
                player.Reply(""You cannot accept your own undo request!"");
                return;
            }

            game.LastUndoTurn = game.TurnNumber;
            SaveData();

            player.Reply(""Undo request accepted. The 'Undo' label is now available for one use this turn."");

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p.UserIDString == game.BluePlayerId || p.UserIDString == game.RedPlayerId)
                    ShowGUI(covalence.Players.FindPlayerById(p.UserIDString), game, false);
                else if (game.SpectatorIds.Contains(p.UserIDString))
                    ShowGUI(covalence.Players.FindPlayerById(p.UserIDString), game, true);
            }
        }

        private void PerformUndo(ChessGame game, IPlayer player)
        {
            if (game.GameEnded)
            {
                player.Reply(""Cannot undo after the game has ended!"");
                return;
            }

            if (game.LastMove == null)
            {
                player.Reply(""No moves to undo!"");
                return;
            }

            if (!game.IsSolo && game.LastUndoTurn != game.TurnNumber)
            {
                player.Reply(""Undo is only available after an accepted undo request!"");
                return;
            }

            if (game.UndoUsedThisTurn)
            {
                player.Reply(""Undo has already been used this turn!"");
                return;
            }

            var lastMove = game.LastMove;

            game.Board[lastMove.RowFrom, lastMove.ColFrom] = lastMove.MovedPiece;
            game.Board[lastMove.RowTo, lastMove.ColTo] = lastMove.CapturedPiece ?? new Piece { Type = PieceType.Empty };

            if (lastMove.WasCastling)
            {
                if (lastMove.ColTo == 6) // Kingside castling: King went to g-file (6)
                {
                    game.Board[lastMove.RowTo, 7] = new Piece { Type = PieceType.Rook, IsWhite = lastMove.MovedPiece.IsWhite };
                    game.Board[lastMove.RowTo, 5] = new Piece { Type = PieceType.Empty };
                    LogDebug($""Undoing kingside castling: Rook restored to {lastMove.RowTo},7"");
                }
                else if (lastMove.ColTo == 2) // Queenside castling: King went to c-file (2)
                {
                    game.Board[lastMove.RowTo, 0] = new Piece { Type = PieceType.Rook, IsWhite = lastMove.MovedPiece.IsWhite };
                    game.Board[lastMove.RowTo, 3] = new Piece { Type = PieceType.Empty };
                    LogDebug($""Undoing queenside castling: Rook restored to {lastMove.RowTo},0"");
                }
            }

            if (lastMove.WasEnPassant)
            {
                game.Board[lastMove.MovedPiece.IsWhite ? lastMove.RowTo - 1 : lastMove.RowTo + 1, lastMove.ColTo] = lastMove.CapturedPiece;
            }

            if (lastMove.MovedPiece.Type == PieceType.King)
            {
                if (lastMove.MovedPiece.IsWhite)
                {
                    game.KingPos.WhiteRow = lastMove.RowFrom;
                    game.KingPos.WhiteCol = lastMove.ColFrom;
                }
                else
                {
                    game.KingPos.BlackRow = lastMove.RowFrom;
                    game.KingPos.BlackCol = lastMove.ColFrom;
                }
            }

            game.Castling = lastMove.CastlingBeforeMove;
            game.EnPassant = lastMove.EnPassantBeforeMove;
            game.WhiteToMove = lastMove.WhiteToMoveBefore;
            game.UndoUsedThisTurn = true;
            game.LastMove = null;
            game.UndoRequested = false;
            game.IsCastlingSelected = false;
            SaveData();

            player.Reply(""Last move undone."");

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p.UserIDString == game.BluePlayerId || p.UserIDString == game.RedPlayerId)
                    ShowGUI(covalence.Players.FindPlayerById(p.UserIDString), game, false);
                else if (game.SpectatorIds.Contains(p.UserIDString))
                    ShowGUI(covalence.Players.FindPlayerById(p.UserIDString), game, true);
            }
        }

        private void ShowGUI(IPlayer player, ChessGame game, bool isSpectator)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null) return;

            DestroyGUI(basePlayer);

            var container = new CuiElementContainer();
            string panelName = $""ChessBoard_{player.Id}_{game.GameId}"";
            playerGUIs[player.Id] = panelName;

            container.Add(new CuiPanel
            {
                Image = { Color = config.Colors[""Background""] },
                RectTransform = { AnchorMin = ""0.2 0.2"", AnchorMax = ""0.8 0.8"" },
                CursorEnabled = true
            }, ""Overlay"", panelName);

            string playerStatus = isSpectator ? ""Spectating"" : (game.BluePlayerId == player.Id ? ""Blue"" : game.RedPlayerId == player.Id ? ""Red"" : ""Spectating"");
            string displayStatus = game.Status.Replace(""Blue"", ""Blue"").Replace(""Red"", ""Red"");
            container.Add(new CuiLabel
            {
                Text = { Text = $""Chess (Game {game.GameId}) - {displayStatus} [{playerStatus}]"", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = config.Colors[""Highlight""] },
                RectTransform = { AnchorMin = ""0.1 0.9"", AnchorMax = ""0.9 1.0"" }
            }, panelName);

            if (!isSpectator && !game.GameEnded)
            {
                string instructionText = game.IsCastlingSelected ? ""Select castling destination"" : ""Click to select and move"";
                container.Add(new CuiLabel
                {
                    Text = { Text = instructionText, FontSize = 12, Align = TextAnchor.MiddleCenter, Color = ""1 1 1 1"" },
                    RectTransform = { AnchorMin = ""0.1 0.85"", AnchorMax = ""0.9 0.9"" }
                }, panelName);

                string undoLabelText = game.UndoRequested ? ""Undo Requested (Accept?)"" : (game.IsSolo || game.LastUndoTurn == game.TurnNumber && !game.UndoUsedThisTurn ? ""Undo"" : ""Request Undo"");
                string undoCommand = game.UndoRequested ? $""chess acceptundo {game.GameId}"" : (game.IsSolo || game.LastUndoTurn == game.TurnNumber && !game.UndoUsedThisTurn ? $""chess undo {game.GameId}"" : $""chess requestundo {game.GameId}"");
                string undoLabelColor = (game.IsSolo || game.LastUndoTurn == game.TurnNumber && !game.UndoUsedThisTurn) ? config.Colors[""UndoActiveLabel""] : config.Colors[""UndoLabel""];
                container.Add(new CuiButton
                {
                    Button = { Color = ""0 0 0 0"", Command = undoCommand },
                    RectTransform = { AnchorMin = ""0.4 0.85"", AnchorMax = ""0.6 0.9"" },
                    Text = { Text = undoLabelText, FontSize = 12, Align = TextAnchor.MiddleCenter, Color = undoLabelColor, Font = ""robotocondensed-bold.ttf"" }
                }, panelName);
            }

            float squareSize = 0.0875f;
            for (int row = 0; row < 8; row++)
            for (int col = 0; col < 8; col++)
            {
                string squareName = $""Square_{row}_{col}"";
                string squareColor = (row + col) % 2 == 0 ? config.Colors[""LightSquare""] : config.Colors[""DarkSquare""];
                if (!isSpectator && game.SelectedSquare == (row, col))
                    squareColor = config.Colors[""Selected""];
                else if (!isSpectator && game.LegalMoves.Contains((row, col)))
                    squareColor = config.Colors[""Highlight""];

                var piece = game.Board[row, col];
                string pieceColor = piece.Type == PieceType.Empty ? ""1 1 1 1"" : (piece.IsWhite ? ""0 0 1 1"" : ""1 0 0 1"");

                container.Add(new CuiButton
                {
                    Button = { Color = squareColor, Command = isSpectator || game.GameEnded ? """" : $""chess click {game.GameId} {row} {col}"" },
                    RectTransform = { AnchorMin = $""{0.1 + col * squareSize} {0.1 + (7 - row) * squareSize}"", AnchorMax = $""{0.1 + (col + 1) * squareSize} {0.1 + (8 - row) * squareSize}"" },
                    Text = { Text = GetPieceSymbol(piece), FontSize = 24, Align = TextAnchor.MiddleCenter, Color = pieceColor }
                }, panelName, squareName);
            }

            container.Add(new CuiButton
            {
                Button = { Color = config.Colors[""ButtonClose""], Close = panelName },
                RectTransform = { AnchorMin = ""0.7 0.05"", AnchorMax = ""0.9 0.1"" },
                Text = { Text = ""Close"", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = ""1 1 1 1"" }
            }, panelName);

            if (!isSpectator && (string.IsNullOrEmpty(game.BluePlayerId) || string.IsNullOrEmpty(game.RedPlayerId)) && !game.GameEnded)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = config.Colors[""Button""], Command = $""chess join {game.GameId}"" },
                    RectTransform = { AnchorMin = ""0.1 0.05"", AnchorMax = ""0.3 0.1"" },
                    Text = { Text = ""Join Game"", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = ""1 1 1 1"" }
                }, panelName);
            }

            CuiHelper.AddUi(basePlayer, container);
            LogDebug($""Showing Chess GUI for {player.Name} (ID: {player.Id}) in game {game.GameId} ({(isSpectator ? ""Spectator"" : ""Player"")})"");
        }

        private void RegisterCommands()
        {
            AddCovalenceCommand(""chess"", nameof(ChessCommand));
            AddCovalenceCommand(""spectate"", nameof(SpectateCommand));
            AddCovalenceCommand(""chesshelp"", nameof(HelpCommand));
        }

        private void ChessCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PlayerPermission))
            {
                player.Reply(""You don't have permission to use this command!"");
                return;
            }

            if (args.Length == 0)
            {
                player.Reply(""Usage: /chess [join <gameid>|create [solo]|reset <gameid>|clearall|stats|requestundo <gameid>|acceptundo <gameid>|undo <gameid>]\nFor rules and info, use /chesshelp"");
                return;
            }

            switch (args[0].ToLower())
            {
                case ""join"":
                    if (args.Length != 2)
                    {
                        player.Reply(""Usage: /chess join <gameid>"");
                        return;
                    }
                    JoinGame(player, args[1]);
                    break;
                case ""create"":
                    bool isSolo = args.Length > 1 && args[1].ToLower() == ""solo"";
                    CreateGame(player, isSolo);
                    break;
                case ""reset"":
                    if (args.Length != 2)
                    {
                        player.Reply(""Usage: /chess reset <gameid>"");
                        return;
                    }
                    if (player.HasPermission(AdminPermission))
                        ResetGame(args[1], player);
                    else
                        player.Reply(""You don't have permission to reset games!"");
                    break;
                case ""clearall"":
                    if (player.HasPermission(AdminPermission))
                        ClearAllGames(player);
                    else
                        player.Reply(""You don't have permission to clear all games!"");
                    break;
                case ""stats"":
                    ShowStats(player);
                    break;
                case ""requestundo"":
                    if (args.Length != 2)
                    {
                        player.Reply(""Usage: /chess requestundo <gameid>"");
                        return;
                    }
                    if (!games.TryGetValue(args[1], out var gameRequestUndo))
                    {
                        player.Reply(""Game not found!"");
                        return;
                    }
                    RequestUndo(player, gameRequestUndo);
                    break;
                case ""acceptundo"":
                    if (args.Length != 2)
                    {
                        player.Reply(""Usage: /chess acceptundo <gameid>"");
                        return;
                    }
                    if (!games.TryGetValue(args[1], out var gameAcceptUndo))
                    {
                        player.Reply(""Game not found!"");
                        return;
                    }
                    AcceptUndo(player, gameAcceptUndo);
                    break;
                case ""undo"":
                    if (args.Length != 2)
                    {
                        player.Reply(""Usage: /chess undo <gameid>"");
                        return;
                    }
                    if (!games.TryGetValue(args[1], out var gameUndo))
                    {
                        player.Reply(""Game not found!"");
                        return;
                    }
                    PerformUndo(gameUndo, player);
                    break;
                default:
                    player.Reply(""Usage: /chess [join <gameid>|create [solo]|reset <gameid>|clearall|stats|requestundo <gameid>|acceptundo <gameid>|undo <gameid>]\nFor rules and info, use /chesshelp"");
                    break;
            }
        }

        private void HelpCommand(IPlayer player, string command, string[] args)
        {
            var helpMessage = @""Welcome to Chess in Rust! Here's a simple guide for you, like explaining to a super smart third grader!

=== How to Play Chess ===
Chess is a fun game on an 8x8 board with 6 types of pieces. Your goal is to trap the other player's king so it can't escape (called checkmate) or capture it. You take turns moving one piece at a time. Blue pieces move first!

**Pieces and How They Move**:
- **Pawn**: Like a brave little soldier! Moves forward 1 square (or 2 from its starting row). Captures diagonally 1 square. If it reaches the other side, it becomes a queen!
- **Rook**: Like a tank! Moves straight up, down, left, or right as far as it wants, unless blocked.
- **Knight**: Like a sneaky horse! Jumps in an L-shape: 2 squares one way, then 1 to the side. Can jump over other pieces!
- **Bishop**: Like a sharp shooter! Moves diagonally as far as it wants, unless blocked.
- **Queen**: The superstar! Moves any direction (straight or diagonal) as far as it wants, unless blocked.
- **King**: The big boss! Moves 1 square any direction. Protect it! If it's trapped (checkmate) or captured, you lose!

**Special Rules**:
- **Check**: If a piece can attack the king, it's in check. You *must* move to save the king (block, capture, or move the king).
- **Checkmate**: If the king can't escape check, the game ends, and the other player wins!
- **Draw**: If no one can win (like stalemate or not enough pieces), it's a tie.
- **Castling**: A special move where the king slides 2 squares toward a rook, and the rook jumps to the other side. Only if neither has moved and the path is clear!

**Winning**: Trap the enemy king in checkmate or capture it! You'll see a big victory message.

=== Playing Chess in Rust ===
Here's how to play chess in this game:
- **Create a Game**: Type `/chess create` to start a new game. You'll get a game ID (like a secret code). Others can join it!
- **Solo Game**: Type `/chess create solo` to practice by yourself, playing both sides.
- **Join a Game**: Type `/chess join <gameid>` to jump into someone's game. You'll be Blue (first move) or Red.
- **Spectate**: Type `/spectate <gameid>` to watch a game without playing.
- **Check Stats**: Type `/chess stats` to see your wins, losses, draws, and the top 5 players.
- **Admin Stuff**: If you're a server boss, use `/chess reset <gameid>` to restart a game or `/chess clearall` to wipe all games.
- **Undo a Move**: Click the 'Request Undo' button (yellow) to ask the other player to undo the last move. If they accept, it turns green ('Undo') and clicking it undoes the move (once per turn). In solo mode, click twice to undo.

**How to Move**:
- Click a piece to select it (it turns yellow). Green squares show where it can go.
- Click a green square to move. For castling, select the king, then click the highlighted destination square. If it's wrong, it'll say Invalid move!
- Win and you'll earn 100 ECON and 160 RP (cool points for the server)!

Have fun playing chess! Type `/chess` to start, or ask an adult for help if you're stuck."";

            player.Reply(helpMessage);
        }

        private void AddSlidingMoves(ChessGame game, HashSet<(int Row, int Col)> moves, int row, int col, bool isWhite, (int, int)[] directions)
        {
            foreach (var (dr, dc) in directions)
            {
                int r = row, c = col;
                while (true)
                {
                    r += dr;
                    c += dc;
                    if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
                    if (game.Board[r, c].Type == PieceType.Empty)
                        moves.Add((r, c));
                    else
                    {
                        if (game.Board[r, c].IsWhite != isWhite)
                            moves.Add((r, c));
                        break;
                    }
                }
            }
        }

        private bool IsCheckmate(ChessGame game)
        {
            if (!IsInCheck(game, game.WhiteToMove)) return false;
            for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++)
            {
                var piece = game.Board[r, c];
                if (piece.Type != PieceType.Empty && piece.IsWhite == game.WhiteToMove)
                {
                    if (GetLegalMoves(game, r, c).Count > 0)
                        return false;
                }
            }
            return true;
        }

        private bool IsStalemate(ChessGame game)
        {
            if (IsInCheck(game, game.WhiteToMove)) return false;
            for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++)
            {
                var piece = game.Board[r, c];
                if (piece.Type != PieceType.Empty && piece.IsWhite == game.WhiteToMove)
                {
                    if (GetLegalMoves(game, r, c).Count > 0)
                        return false;
                }
            }
            return true;
        }

        private bool IsInsufficientMaterial(ChessGame game)
        {
            int whiteKnights = 0, whiteBishops = 0, blackKnights = 0, blackBishops = 0;
            bool whiteHasOther = false, blackHasOther = false;

            for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++)
            {
                var piece = game.Board[r, c];
                if (piece.Type == PieceType.Empty) continue;

                if (piece.IsWhite)
                {
                    if (piece.Type == PieceType.Knight) whiteKnights++;
                    else if (piece.Type == PieceType.Bishop) whiteBishops++;
                    else if (piece.Type != PieceType.King) whiteHasOther = true;
                }
                else
                {
                    if (piece.Type == PieceType.Knight) blackKnights++;
                    else if (piece.Type == PieceType.Bishop) blackBishops++;
                    else if (piece.Type != PieceType.King) blackHasOther = true;
                }
            }

            if (!whiteHasOther && !blackHasOther && whiteKnights == 0 && whiteBishops == 0 && blackKnights == 0 && blackBishops == 0)
                return true;

            if (!whiteHasOther && !blackHasOther &&
                ((whiteKnights == 1 && whiteBishops == 0 && blackKnights == 0 && blackBishops == 0) ||
                 (whiteBishops == 1 && whiteKnights == 0 && blackKnights == 0 && blackBishops == 0) ||
                 (blackKnights == 1 && blackBishops == 0 && whiteKnights == 0 && whiteBishops == 0) ||
                 (blackBishops == 1 && blackKnights == 0 && whiteKnights == 0 && whiteBishops == 0)))
                return true;

            return false;
        }

        private bool IsInCheck(ChessGame game, bool isWhite)
        {
            var kingPos = isWhite ? (game.KingPos.WhiteRow, game.KingPos.WhiteCol) : (game.KingPos.BlackRow, game.KingPos.BlackCol);
            for (int r = 0; r < 8; r++)
            for (int c = 0; c < 8; c++)
            {
                var piece = game.Board[r, c];
                if (piece.Type != PieceType.Empty && piece.IsWhite != isWhite)
                {
                    var moves = GetLegalMoves(game, r, c);
                    foreach (var (moveRow, moveCol) in moves)
                    {
                        if (moveRow == kingPos.Item1 && moveCol == kingPos.Item2)
                        {
                            LogDebug($""King {(isWhite ? ""White"" : ""Black"")} in check by {piece.Type} at {r},{c}"");
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        private void RecordGameResult(ChessGame game, string result)
        {
            if (game.IsSolo) return;

            if (!playerStats.ContainsKey(game.BluePlayerId))
                playerStats[game.BluePlayerId] = new PlayerStats();
            if (!playerStats.ContainsKey(game.RedPlayerId))
                playerStats[game.RedPlayerId] = new PlayerStats();

            if (result == ""Blue"")
            {
                playerStats[game.BluePlayerId].Wins++;
                playerStats[game.RedPlayerId].Losses++;
                AwardRewards(game.BluePlayerId);
            }
            else if (result == ""Red"")
            {
                playerStats[game.RedPlayerId].Wins++;
                playerStats[game.BluePlayerId].Losses++;
                AwardRewards(game.RedPlayerId);
            }
            else if (result == ""Draw"")
            {
                playerStats[game.BluePlayerId].Draws++;
                playerStats[game.RedPlayerId].Draws++;
            }

            SaveStats();
        }

        private void AwardRewards(string playerId)
        {
            var player = covalence.Players.FindPlayerById(playerId);
            if (player == null) return;

            if (Economics != null)
            {
                Economics.Call(""Deposit"", playerId, 100.0);
                player.Reply(""You earned 100 ECON for your chess victory!"");
            }

            if (ServerRewards != null)
            {
                ServerRewards.Call(""AddPoints"", playerId, 160);
                player.Reply(""You earned 160 RP for your chess victory!"");
            }
        }

        private string GetPieceSymbol(Piece piece)
        {
            if (piece.Type == PieceType.Empty) return """";
            var symbols = piece.IsWhite ?
                new Dictionary<PieceType, string>
                {
                    { PieceType.Pawn, ""â™™"" },
                    { PieceType.Knight, ""â™˜"" },
                    { PieceType.Bishop, ""â™—"" },
                    { PieceType.Rook, ""â™–"" },
                    { PieceType.Queen, ""â™•"" },
                    { PieceType.King, ""â™”"" }
                } :
                new Dictionary<PieceType, string>
                {
                    { PieceType.Pawn, ""â™Ÿ"" },
                    { PieceType.Knight, ""â™"" },
                    { PieceType.Bishop, ""â™"" },
                    { PieceType.Rook, ""â™œ"" },
                    { PieceType.Queen, ""â™›"" },
                    { PieceType.King, ""â™š"" }
                };
            return symbols[piece.Type];
        }

        private void DestroyGUI(BasePlayer player)
        {
            if (player == null) return;
            if (playerGUIs.TryGetValue(player.UserIDString, out string panelName))
            {
                CuiHelper.DestroyUi(player, panelName);
                playerGUIs.Remove(player.UserIDString);
            }
        }

        private void ShowBannerToAll(string message)
        {
            var container = new CuiElementContainer();
            string panelName = ""ChessBanner"";

            container.Add(new CuiPanel
            {
                Image = { Color = config.Colors[""Background""] },
                RectTransform = { AnchorMin = ""0 0.9"", AnchorMax = ""1 0.95"" },
                CursorEnabled = false
            }, ""Overlay"", panelName);

            container.Add(new CuiLabel
            {
                Text = { Text = message, FontSize = 14, Align = TextAnchor.MiddleCenter, Color = ""1 1 1 1"" },
                RectTransform = { AnchorMin = ""0 0"", AnchorMax = ""1 1"" }
            }, panelName);

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player != null && player.IsConnected)
                {
                    CuiHelper.DestroyUi(player, panelName);
                    CuiHelper.AddUi(player, container);
                }
            }

            timer.Once(10f, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (player != null && player.IsConnected)
                        CuiHelper.DestroyUi(player, panelName);
                }
            });
        }

        private void SpectateCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PlayerPermission))
            {
                player.Reply(""You don't have permission to use this command!"");
                return;
            }

            if (args.Length != 1)
            {
                player.Reply(""Usage: /spectate <gameid>"");
                return;
            }

            if (!games.TryGetValue(args[0], out var game))
            {
                player.Reply(""Game not found!"");
                return;
            }

            game.SpectatorIds.Add(player.Id);
            ShowGUI(player, game, true);
            player.Reply($""Now spectating game {args[0]}."");
            SaveData();
        }

        private void ShowStats(IPlayer player)
        {
            var stats = playerStats.GetValueOrDefault(player.Id, new PlayerStats());
            var message = $""Chess Stats for {player.Name}:\n"" +
                          $""Wins: {stats.Wins}\n"" +
                          $""Losses: {stats.Losses}\n"" +
                          $""Draws: {stats.Draws}\n\n"" +
                          ""Leaderboard (Top 5):\n"";

            var topPlayers = playerStats.OrderByDescending(x => x.Value.Wins).Take(5).ToList();
            int rank = 1;
            foreach (var entry in topPlayers)
            {
                var p = covalence.Players.FindPlayerById(entry.Key);
                message += $""{rank}. {p?.Name ?? ""Unknown""} - {entry.Value.Wins} Wins\n"";
                rank++;
            }

            player.Reply(message);
        }

        private void CreateGame(IPlayer player, bool isSolo = false)
        {
            string gameId = Guid.NewGuid().ToString(""N"").Substring(0, 8);
            var game = new ChessGame(gameId) { IsSolo = isSolo };
            games[gameId] = game;
            if (isSolo)
            {
                game.BluePlayerId = player.Id;
                game.RedPlayerId = player.Id;
                game.Status = ""Solo Game in progress"";
            }
            SaveData();
            player.Reply($""Created new chess game with ID: {gameId}. Join with /chess join {gameId}"");
            ShowBannerToAll($""{player.Name} created a new chess game ({gameId})!"");
        }

        private void JoinGame(IPlayer player, string gameId)
        {
            if (!games.TryGetValue(gameId, out var game))
            {
                player.Reply(""Game not found!"");
                return;
            }

            if (game.IsSolo)
            {
                if (game.BluePlayerId == player.Id)
                {
                    player.Reply(""Opening your solo game!"");
                    ShowGUI(player, game, false);
                    return;
                }
                else
                {
                    player.Reply(""This is a solo game! Create a new game with /chess create or /chess create solo."");
                    return;
                }
            }

            if (game.BluePlayerId == player.Id || game.RedPlayerId == player.Id)
            {
                player.Reply(""You're already in this game!"");
                ShowGUI(player, game, false);
                return;
            }

            if (string.IsNullOrEmpty(game.BluePlayerId))
            {
                game.BluePlayerId = player.Id;
                player.Reply(""Joined as Blue!"");
                game.Status = string.IsNullOrEmpty(game.RedPlayerId) ? ""Waiting for Red"" : ""Game in progress"";
                SaveData();
            }
            else if (string.IsNullOrEmpty(game.RedPlayerId))
            {
                game.RedPlayerId = player.Id;
                player.Reply(""Joined as Red!"");
                game.Status = ""Game in progress"";
                SaveData();
            }
            else
            {
                player.Reply(""Game is full! Spectate with /spectate <gameid> or create a new game with /chess create."");
                return;
            }

            ShowGUI(player, game, false);
            ShowBannerToAll($""{player.Name} joined chess game {gameId}!"");
        }

        private void ResetGame(string gameId, IPlayer player)
        {
            if (!games.ContainsKey(gameId))
            {
                player.Reply(""Game not found!"");
                return;
            }

            var game = games[gameId];
            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p.UserIDString == game.BluePlayerId || p.UserIDString == game.RedPlayerId || game.SpectatorIds.Contains(p.UserIDString))
                    DestroyGUI(p);
            }
            games.Remove(gameId);
            SaveData();
            player.Reply($""Chess game {gameId} reset!"");
            ShowBannerToAll($""Chess game {gameId} has been reset!"");
        }

        private void ClearAllGames(IPlayer player)
        {
            foreach (var game in games.Values)
            {
                foreach (var p in BasePlayer.activePlayerList)
                {
                    if (p.UserIDString == game.BluePlayerId || p.UserIDString == game.RedPlayerId || game.SpectatorIds.Contains(p.UserIDString))
                        DestroyGUI(p);
                }
            }
            games.Clear();
            SaveData();
            player.Reply(""All chess games have been cleared!"");
            ShowBannerToAll(""All chess games have been cleared!"");
        }

        private string DumpBoardState(ChessGame game)
        {
            var sb = new StringBuilder();
            for (int row = 7; row >= 0; row--)
            {
                for (int col = 0; col < 8; col++)
                {
                    var piece = game.Board[row, col];
                    string symbol = piece.Type == PieceType.Empty ? ""."" : GetPieceSymbol(piece);
                    sb.Append(symbol + "" "");
                }
                sb.AppendLine();
            }
            return sb.ToString();
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return null;

            var command = arg.cmd.Name;
            var args = arg.Args;

            if (command != ""chess"" || args == null || args.Length < 3 || args[0] != ""click"") return null;

            string playerId = player.UserIDString;
            float currentTime = Time.realtimeSinceStartup;
            if (lastClickTimes.TryGetValue(playerId, out float lastClickTime) && (currentTime - lastClickTime) < 0.75f)
            {
                LogDebug($""Click debounced for player {playerId} in game {args[1]}"");
                return null;
            }
            lastClickTimes[playerId] = currentTime;

            LogDebug($""Received command: {command} with args: {string.Join("", "", args)}"");

            string gameId = args[1];
            if (!games.TryGetValue(gameId, out var game))
            {
                covalence.Players.FindPlayerById(playerId)?.Reply(""Game not found!"");
                return null;
            }

            if (game.GameEnded)
            {
                covalence.Players.FindPlayerById(playerId)?.Reply($""Game {gameId} has ended: {game.Status}. Start a new game with /chess create."");
                return null;
            }

            if (!int.TryParse(args[2], out int row) || !int.TryParse(args[3], out int col) || row < 0 || row >= 8 || col < 0 || col >= 8)
            {
                covalence.Players.FindPlayerById(playerId)?.Reply(""Invalid square selection!"");
                return null;
            }

            var iPlayer = covalence.Players.FindPlayerById(playerId);
            if (iPlayer == null) return null;

            if (!game.IsSolo && game.BluePlayerId != iPlayer.Id && game.RedPlayerId != iPlayer.Id)
            {
                iPlayer.Reply(""You must join the game first! Use /chess join <gameid>"");
                return null;
            }

            if (!game.IsSolo && ((game.WhiteToMove && game.BluePlayerId != iPlayer.Id) || (!game.WhiteToMove && game.RedPlayerId != iPlayer.Id)))
            {
                iPlayer.Reply(""It's not your turn!"");
                return null;
            }

            LogDebug($""Processing click at {row},{col} in game {game.GameId}. SelectedSquare: {game.SelectedSquare}, LegalMoves: {string.Join("", "", game.LegalMoves)}"");

            if (game.SelectedSquare == null)
            {
                var piece = game.Board[row, col];
                if (piece.Type != PieceType.Empty && piece.IsWhite == game.WhiteToMove)
                {
                    LogDebug($""First click: Selecting piece {piece.Type} at {row},{col} in game {game.GameId}"");
                    game.SelectedSquare = (row, col);
                    game.LegalMoves = GetLegalMoves(game, row, col);
                    game.IsCastlingSelected = piece.Type == PieceType.King && game.LegalMoves.Any(m => m.Row == row && (m.Col == 6 || m.Col == 2));
                    SaveData();
                    ShowGUI(iPlayer, game, false);
                    LogDebug($""Piece selected. LegalMoves updated: {string.Join("", "", game.LegalMoves)}, IsCastlingSelected: {game.IsCastlingSelected}"");
                }
                else
                {
                    iPlayer.Reply(""Cannot select this piece!"");
                    LogDebug($""Invalid selection attempt at {row},{col} in game {game.GameId}"");
                }
            }
            else
            {
                var (fromRow, fromCol) = game.SelectedSquare.Value;
                var selectedPiece = game.Board[fromRow, fromCol];
                var targetPiece = game.Board[row, col];

                if (row == fromRow && col == fromCol)
                {
                    LogDebug($""Clicked same square {row},{col} in game {game.GameId}. Deselecting."");
                    game.SelectedSquare = null;
                    game.LegalMoves.Clear();
                    game.IsCastlingSelected = false;
                    SaveData();
                    ShowGUI(iPlayer, game, false);
                }
                else if (game.LegalMoves.Contains((row, col)))
                {
                    LogDebug($""Second click: Attempting move from {fromRow},{fromCol} to {row},{col} in game {game.GameId}"");
                    if (MakeMove(game, fromRow, fromCol, row, col))
                    {
                        game.SelectedSquare = null;
                        game.LegalMoves.Clear();
                        game.IsCastlingSelected = false;
                        SaveData();
                        foreach (var p in BasePlayer.activePlayerList)
                        {
                            if (p.UserIDString == game.BluePlayerId || p.UserIDString == game.RedPlayerId)
                                ShowGUI(covalence.Players.FindPlayerById(p.UserIDString), game, false);
                            else if (game.SpectatorIds.Contains(p.UserIDString))
                                ShowGUI(covalence.Players.FindPlayerById(p.UserIDString), game, true);
                        }
                    }
                    else
                    {
                        iPlayer.Reply(""Invalid move!"");
                        game.SelectedSquare = null;
                        game.LegalMoves.Clear();
                        game.IsCastlingSelected = false;
                        SaveData();
                        ShowGUI(iPlayer, game, false);
                        LogDebug($""Invalid move attempted from {fromRow},{fromCol} to {row},{col} in game {game.GameId}"");
                    }
                }
                else
                {
                    iPlayer.Reply(""Invalid destination! Select a highlighted square or click the piece again to deselect."");
                    LogDebug($""Invalid destination {row},{col} clicked in game {game.GameId}. LegalMoves: {string.Join("", "", game.LegalMoves)}"");
                }
            }

            return null;
        }
    }
}"
kgjiGj9Z,Wat ik er zelf van maakte,eXistenZNL,PHP,Monday 16th of June 2025 01:44:01 PM CDT,"        $touchedHourlyRates = [];
        foreach($budgetData as $budgetForEmployee) {
            foreach ($budgetForEmployee as $post => $hoursForPost) {
                $hourlyRate = HourlyRate::updateOrCreate([
                    'order_id' => $order->id,
                    'employee_id' => $budgetForEmployee['employee'],
                    'post_id' => $post,
                    'hours' => $budgetForEmployee['hours'],
                ]);
                $touchedHourlyRates[] = $hourlyRate->id;
            }
        }
        HourlyRate::whereNotIn('id', $touchedHourlyRates)->delete();
"
xpdiYa3H,Wat ChatGPT bedacht,eXistenZNL,PHP,Monday 16th of June 2025 01:40:47 PM CDT,"
        $newEntries = [];

        foreach ($budgetData as $budgetDataForEmployee) {
            $employeeId = $budgetDataForEmployee['employee'];

            foreach ($budgetDataForEmployee['hours'] as $post => $hours) {
                $newEntries[] = [
                    'order_id' => $order->id,
                    'post_id' => $post,
                    'employee_id' => (int) $employeeId,
                    'hours' => (int) $hours,
                ];
            }
        }

        // Get existing budget hours for this order
        $existingEntries = Hour::where('order_id', $order->id)->get();

        // Index by composite key: postId_employeeId
        $existingMap = $existingEntries->keyBy(fn ($item) => $item->post_id . '_' . $item->employee_id);
        $newMap = collect($newEntries)->keyBy(fn ($item) => $item['post_id'] . '_' . $item['employee_id']);

        $toInsert = [];
        $toUpdate = [];
        $toDelete = [];

        foreach ($newMap as $key => $newItem) {
            $newHours = $newItem['hours'];

            if ($newHours === 0) {
                // Mark for deletion if it exists
                if ($existingMap->has($key)) {
                    $itemToDelete = $existingMap[$key];
                    Assert::isInstanceOf($itemToDelete, Hour::class);
                    $toDelete[] = $itemToDelete->id;
                }
            } elseif (!$existingMap->has($key)) {
                $toInsert[] = $newItem;
            } else {
                $existingItem = $existingMap[$key];
                Assert::isInstanceOf($existingItem, Hour::class);
                if ($existingItem->hours !== $newHours) {
                    $existingItem->hours = $newHours;
                    $toUpdate[] = $existingItem;
                }
            }
"
gwvHyd9h,2025-06-16T20:32:10.896884,powerampache,PHP,Monday 16th of June 2025 01:32:11 PM CDT,"1.01-80-play (80) - DB: 83
java.lang.NullPointerException: Parameter specified as non-null is null: method luci.sixsixsix.powerampache2.domain.models.User.<init>, parameter id
	at luci.sixsixsix.powerampache2.domain.models.User.<init>(Unknown Source:20)
	at luci.sixsixsix.powerampache2.data.remote.dto.UserDtoKt.toUser(UserDto.kt:94)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.getUserNetwork(BaseAmpacheRepository.kt:128)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$getUserNetwork$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:811)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:715)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:702)

"
RCRhrU6L,docker-compose web with random background,pilasguru,YAML,Monday 16th of June 2025 01:24:53 PM CDT,"services:
  web:
    image: nginx:latest
    ports:
      - ""8080:80""
    command: >-
      bash -c ""COLORS=('red' 'green' 'blue' 'yellow' 'cyan' 'magenta' 'orange' 'purple' 'pink' 'lime' 'teal' 'brown' 'gold' 'navy' 'olive' 'maroon' 'aqua' 'coral' 'salmon' 'violet');
      COLOR=$${COLORS[$$RANDOM % $${#COLORS[@]}]};
      echo \""<html><body style='background: $$COLOR; color: #ffffff; display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; font-size: 24px;'><h1>Mi color de fondo es $$COLOR</h1></body></html>\"" > /usr/share/nginx/html/index.html && nginx -g 'daemon off;'"""
6XXQJiMC,Untitled,Josif_tepe,Java,Monday 16th of June 2025 01:09:10 PM CDT,"import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Scanner;

class Drzava {
    private String kratenica;
    private String drzava;
    private int brojZiteli;

    public Drzava(String kratenica, String drzava, int brojZiteli) {
        this.kratenica = kratenica;
        this.drzava = drzava;
        this.brojZiteli = brojZiteli;
    }

    public String getKratenica() {
        return kratenica;
    }
    public String getDrzava() {
        return drzava;
    }
    public int getBrojZiteli() {
        return brojZiteli;
    }
    public void setKratenica(String kratenica) {
        this.kratenica = kratenica;
    }
    public void setDrzava(String drzava) {
        this.drzava = drzava;
    }
    public void setBroZiteli(int brojZiteli) {
        this.brojZiteli = brojZiteli;
    }
    public int presmetajMilioni() {
        return Math.round(brojZiteli / 1000000);
    }
}
public class Naloga13 {
    static HashMap<String, Drzava> preberiDrzava(String imeDatoteke) {
        HashMap<String, Drzava> map = new HashMap<>();

        try {
            Scanner scanner = new Scanner(new File(imeDatoteke));
            while(scanner.hasNextLine()) {
                String line = scanner.nextLine();
                String[] niza = line.split("":"");
                map.put(niza[0], new Drzava(niza[0], niza[1], Integer.parseInt(niza[2])));
            }

        }
        catch(Exception e) {
            System.out.println(""Error "" + e);
        }

        return map;
    }
    public static void main(String[] args) {
        HashMap<String, Drzava> map = preberiDrzava(args[0]);
        ArrayList<String> keys = new ArrayList<>(map.keySet());

        keys.sort(new Comparator<String>() {
            @Override
            public int compare(String a, String b) {
                Drzava d1 = map.get(a);
                Drzava d2 = map.get(b);

                if(d1.presmetajMilioni() == d2.presmetajMilioni()) {
                    return d1.getDrzava().compareTo(d2.getDrzava());
                }
                
                return d1.presmetajMilioni() - d2.presmetajMilioni();
            }
        }); 

        System.out.println(keys);
    }
}
"
XgxaRzpG,Untitled,Josif_tepe,Java,Monday 16th of June 2025 12:32:16 PM CDT,"import java.util.TreeSet;

class MnozicaZnakov extends TreeSet<Character> {
    @Override
    public boolean add(Character c) {
        if(c.charValue() >= '0' && c.charValue() <= '9') {
            return super.add(c);
        }
        return false;
    }
}

public class Naloga12 {
    static char[][] mat = new char[9][9];

    static char checkRow(char[][] mat, int i) {
        MnozicaZnakov mz = new MnozicaZnakov();
        for(int j = 0; j < mat.length; j++) {
            if(mat[i][j] != '0' && mz.add(mat[i][j]) == false) {
                return mat[i][j];
            }
        }
        return 0;
    }

    static char checkColumn(char[][] mat, int j) {
        MnozicaZnakov mz = new MnozicaZnakov();
        for(int i = 0; i < mat.length; i++) {
            if(mat[i][j] != '0' && mz.add(mat[i][j]) == false) {
                return mat[i][j];
            }
        }
        return 0;
    }

    static char checkSquare(char[][] mat, int i, int j) {
        MnozicaZnakov mz = new MnozicaZnakov();

        for(int a = 0; a < 3; a++) {
            for(int b = 0; b < 3; b++) {
                if(mat[i * 3 + a][j * 3 + b] != '0' && !mz.add(mat[i * 3 + a ][j * 3 + b])) {
                    return mat[i * 3 + a][j * 3 + b];
                }
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        String s = args[0];

        for(int i = 0; i < s.length(); i++) {
            mat[i / 9][i % 9] = s.charAt(i);
        }
        
        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[i].length; j++) {
                if(mat[i][j] != '0') {
                    System.out.print(mat[i][j] + "" "");
                }
                else {
                    System.out.print(""* "");
                }
               
            }
            System.out.println();
        }
    

    for(int i = 0; i < 9; i++) {
        int broj = checkRow(mat, i);
        if(broj != 0) {
            System.out.printf(""Napaka v vrstici %d (znak %c)"", i + 1, broj);
            return;
        }
    }
    
    for(int j = 0; j < 9; j++) {
        int broj = checkColumn(mat, j);
        if(broj != 0) {
            System.out.printf(""Napaka v stolpcu %d (znak %c)"", j + 1, broj);
            return;
        }
    }
    
    for(int i = 0; i < 3; i++) {
        for(int j = 0; j < 3; j++) {
            int broj = checkSquare(mat, i, j);
            if(broj != 0) {
                System.out.printf(""Napaka v kvadratu (%d, %d) (znak %c)"", i + 1, j + 1, broj);
                return;
            }
        }
    }
    System.out.println(""OK!"");
    // 507200090006030701400000060100490007000508000800027005070000009209080600040009308
}
}
"
9T60LfHi,Homework44,JohnJuly,C#,Monday 16th of June 2025 12:27:24 PM CDT,"using System;
using System.Collections.Generic;

namespace Homework44
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Dispather dispather = new Dispather();
            dispather.isWork();
        }
    }

    class Dispather
    {
        private List<Train> _trains = new List<Train>();

        public void isWork()
        {
            const string CommandCreateTrain = ""go"";
            const string CommandExitMenu = ""exit"";
            const string CommandShowTrains = ""show"";

            bool isWork = true;

            while (isWork)
            {
                ShowShortTrainInfo();

                Console.WriteLine(""\nĞ’Ñ‹ Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ĞµÑÑŒ Ğ² Ğ¼ĞµĞ½Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾ĞµĞ·Ğ´Ğ¾Ğ²"");
                Console.WriteLine($""Ğ§Ñ‚Ğ¾Ğ±Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¿Ğ¾ĞµĞ·Ğ´ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ {CommandCreateTrain}"");
                Console.WriteLine($""Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾ĞµĞ·Ğ´Ğ¾Ğ² Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ {CommandShowTrains}"");
                Console.WriteLine($""Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸Ğ· Ğ¼ĞµĞ½Ñ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ {CommandExitMenu}"");
                Console.Write(""Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ: "");

                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandCreateTrain:
                        CreateTrain();
                        break;

                    case CommandShowTrains:
                        ShowTrainInformation();
                        break;

                    case CommandExitMenu:
                        isWork = ExitProgram();
                        break;

                    default:
                        Console.WriteLine(""ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ²Ğ²Ğ¾Ğ´, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ğµ Ñ€Ğ°Ğ·."");
                        break;
                }

                Console.ReadKey();
                Console.Clear();
            }
        }

        public void ShowTrainInformation()
        {
            if (_trains.Count == 0)
            {
                Console.WriteLine(""ĞŸĞ¾ĞµĞ·Ğ´Ğ¾Ğ² Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚."");
                return;
            }

            Console.WriteLine(""Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¿Ğ¾ĞµĞ·Ğ´Ğ¾Ğ²:"");

            for (int i = 0; i < _trains.Count; i++)
            {
                Console.WriteLine($""ĞŸĞ¾ĞµĞ·Ğ´ {i + 1}: {_trains[i].Direction}, "" +
                $""ĞŸĞ°ÑÑĞ°Ğ¶Ğ¸Ñ€Ğ¾Ğ²: {_trains[i].PassengerCount}, Ğ’Ğ°Ğ³Ğ¾Ğ½Ğ¾Ğ²: {_trains[i].Wagons.Count}"");
            }
        }

        private bool ExitProgram()
        {
            Console.WriteLine(""Ğ’Ñ‹ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ¸Ğ· Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹!"");
            return false;
        }

        private void CreateTrain()
        {
            string direction = CreateDirection();
            int passengerCount = SellTickets();

            if (passengerCount == -1)
            {
                Console.WriteLine(""ĞŸÑ€Ğ¾Ğ´Ğ°Ğ¶Ğ° Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¾Ğ² Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°."");
                return;
            }

            Train train = new Train(direction, passengerCount);
            FormTrain(train);

            Console.WriteLine(""\nĞ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ½Ğ¾Ğ¼ Ğ¿Ğ¾ĞµĞ·Ğ´Ğµ:"");
            train.ShowInfo();

            _trains.Add(train);
        }

        private string CreateDirection()
        {
            string departure, arrival;
            TrainRouteGeneration locationGenerator = new TrainRouteGeneration();
            locationGenerator.GetDifferentLocations(out departure, out arrival);
            return $""{departure} - {arrival}"";
        }

        private int SellTickets()
        {
            Random random = new Random();
            int passengerCount = random.Next(50, 201);

            Console.WriteLine($""ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ¾ Ğ±Ğ¸Ğ»ĞµÑ‚Ğ¾Ğ²: {passengerCount}"");
            return passengerCount;
        }

        private void FormTrain(Train train)
        {
            int wagonCapacity = 24;
            int remainingPassengers = train.PassengerCount;

            while (remainingPassengers > 0)
            {
                Wagon wagon = new Wagon();

                int passengersForThisWagon = Math.Min(wagonCapacity, remainingPassengers);

                wagon.Fill(passengersForThisWagon);
                train.Wagons.Add(wagon);
                remainingPassengers -= passengersForThisWagon;
            }
        }

        private void ShowShortTrainInfo()
        {
            if (_trains.Count == 0)
            {
                Console.WriteLine(""ĞŸĞ¾ĞµĞ·Ğ´Ğ¾Ğ² Ğ¿Ğ¾ĞºĞ° Ğ½ĞµÑ‚."");
                return;
            }

            Console.WriteLine(""Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ Ğ¿Ğ¾ĞµĞ·Ğ´Ğ°:"");

            for (int i = 0; i < _trains.Count; i++)
            {
                Console.WriteLine($""ĞŸĞ¾ĞµĞ·Ğ´ {i + 1}: {_trains[i].Direction},"" +
                $"" ĞŸĞ°ÑÑĞ°Ğ¶Ğ¸Ñ€Ğ¾Ğ²: {_trains[i].PassengerCount}, Ğ’Ğ°Ğ³Ğ¾Ğ½Ğ¾Ğ²: {_trains[i].Wagons.Count}"");
            }
        }
    }

    class Train
    {
        public List<Wagon> Wagons = new List<Wagon>();

        public Train(string direction, int passengerCount)
        {
            Direction = direction;
            PassengerCount = passengerCount;
        }

        public string Direction { get; private set; }
        public int PassengerCount { get; private set; }

        public void ShowInfo()
        {
            Console.WriteLine($""ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: {Direction}"");
            Console.WriteLine($""ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ğ°ÑÑĞ°Ğ¶Ğ¸Ñ€Ğ¾Ğ²: {PassengerCount}"");
            Console.WriteLine($""ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²Ğ°Ğ³Ğ¾Ğ½Ğ¾Ğ²: {Wagons.Count}"");
            Console.WriteLine(""Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ğ²Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ¼:"");

            for (int i = 0; i < Wagons.Count; i++)
            {
                Console.WriteLine($""  Ğ’Ğ°Ğ³Ğ¾Ğ½ {i + 1}: Ğ—Ğ°Ğ½ÑÑ‚Ğ¾ Ğ¼ĞµÑÑ‚: {Wagons[i].OccupiedSeats}"");
            }
        }
    }

    public class Wagon
    {
        public Wagon()
        {
            Capacity = 24;
        }

        public int Capacity { get; private set; }
        public int OccupiedSeats { get; private set; }

        public void Fill(int passengers)
        {
            if (passengers <= Capacity)
            {
                OccupiedSeats = passengers;
            }
            else
            {
                OccupiedSeats = Capacity;
                Console.WriteLine(""ĞŸÑ€ĞµĞ²Ñ‹ÑˆĞµĞ½Ğ° Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ²Ğ°Ğ³Ğ¾Ğ½Ğ°!"");
            }
        }
    }

    class TrainRouteGeneration
    {
        private Random _random = new Random();

        private string[] _locations = new string[]
        {
        ""ĞœĞ¾ÑĞºĞ²Ğ°"", ""Ğ¡Ğ°Ğ½ĞºÑ‚-ĞŸĞµÑ‚ĞµÑ€Ğ±ÑƒÑ€Ğ³"", ""ĞšĞ°Ğ»ÑƒĞ³Ğ°"", ""Ğ¢Ğ²ĞµÑ€ÑŒ"", ""Ğ¯Ñ€Ğ¾ÑĞ»Ğ°Ğ²Ğ»ÑŒ"", ""ĞšÑ€Ğ°ÑĞ½Ğ¾Ğ´Ğ°Ñ€"", ""Ğ Ğ¾ÑÑ‚Ğ¾Ğ²"", ""Ğ’Ğ¾Ğ»Ğ¾Ğ³Ğ´Ğ°"",
        ""ĞĞ¸Ğ¶Ğ½Ğ¸Ğ¹ ĞĞ¾Ğ²Ğ³Ğ¾Ñ€Ğ¾Ğ´"", ""Ğ’Ğ»Ğ°Ğ»Ğ¸Ğ²Ğ¾ÑÑ‚Ğ¾Ğº"", ""Ğ•ĞºĞ°Ñ‚ĞµÑ€Ğ¸Ğ½Ğ±ÑƒÑ€Ğ³"", ""Ğ¡Ğ°Ğ¼Ğ°Ñ€Ğ°"", ""Ğ¡Ğ¾Ñ‡Ğ¸"",
        ""Ğ‘ĞµĞ»Ğ³Ğ¾Ñ€Ğ¾Ğ´"", ""Ğ‘Ñ€ÑĞ½ÑĞº"", ""Ğ¡ĞµÑ€Ğ³Ğ¸ĞµĞ² ĞŸĞ¾ÑĞ°Ğ´"", ""ĞšĞ¾Ğ·ĞµĞ»ÑŒÑĞº"",""Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ²Ğ¾""
        };

        public string GetRandomLocation()
        {
            return _locations[_random.Next(0, _locations.Length)];
        }

        public void GetDifferentLocations(out string departure, out string arrival)
        {
            departure = GetRandomLocation();

            List<string> possibleArrivals = new List<string>();

            foreach (string city in _locations)
            {
                if (city != departure)
                {
                    possibleArrivals.Add(city);
                }
            }

            if (possibleArrivals.Count == 0)
            {
                arrival = departure;
                return;
            }

            arrival = possibleArrivals[_random.Next(possibleArrivals.Count)];
        }
    }
}"
MiKYYNXF,Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… - restaurant_booking,ml1,MySQL,Monday 16th of June 2025 11:09:19 AM CDT,"-- phpMyAdmin SQL Dump
-- version 5.2.1
-- https://www.phpmyadmin.net/
--
-- Ğ¥Ğ¾ÑÑ‚: 127.0.0.1
-- Ğ’Ñ€ĞµĞ¼Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ: Ğ˜ÑĞ½ 16 2025 Ğ³., 17:51
-- Ğ’ĞµÑ€ÑĞ¸Ñ ÑĞµÑ€Ğ²ĞµÑ€Ğ°: 10.4.32-MariaDB
-- Ğ’ĞµÑ€ÑĞ¸Ñ PHP: 8.2.12

SET SQL_MODE = ""NO_AUTO_VALUE_ON_ZERO"";
START TRANSACTION;
SET time_zone = ""+00:00"";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: `restaurant_booking`
--

-- --------------------------------------------------------

--
-- Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `bookings`
--

CREATE TABLE `bookings` (
  `id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `booking_date` date NOT NULL,
  `booking_time` time NOT NULL,
  `guests_count` int(11) NOT NULL,
  `contact_phone` varchar(20) NOT NULL,
  `comment` text DEFAULT NULL,
  `status` enum('new','confirmed','cancelled','completed') DEFAULT 'new',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- --------------------------------------------------------

--
-- Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `reviews`
--

CREATE TABLE `reviews` (
  `id` int(11) NOT NULL,
  `booking_id` int(11) NOT NULL,
  `comment` text DEFAULT NULL,
  `created_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- --------------------------------------------------------

--
-- Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `users`
--

CREATE TABLE `users` (
  `id` int(11) NOT NULL,
  `username` varchar(50) NOT NULL,
  `password` varchar(255) NOT NULL,
  `first_name` varchar(50) NOT NULL,
  `last_name` varchar(50) NOT NULL,
  `phone` varchar(20) NOT NULL,
  `email` varchar(100) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Ğ”Ğ°Ğ¼Ğ¿ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `users`
--

INSERT INTO `users` (`id`, `username`, `password`, `first_name`, `last_name`, `phone`, `email`, `created_at`) VALUES
(1, 'admin', 'restaurant', 'ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€', 'Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ñ‹', '+7(999)-999-99-99', 'admin@restaurant.com', '2025-06-16 13:52:27');

--
-- Ğ˜Ğ½Ğ´ĞµĞºÑÑ‹ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†
--

--
-- Ğ˜Ğ½Ğ´ĞµĞºÑÑ‹ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `bookings`
--
ALTER TABLE `bookings`
  ADD PRIMARY KEY (`id`),
  ADD KEY `user_id` (`user_id`);

--
-- Ğ˜Ğ½Ğ´ĞµĞºÑÑ‹ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `reviews`
--
ALTER TABLE `reviews`
  ADD PRIMARY KEY (`id`),
  ADD KEY `booking_id` (`booking_id`);

--
-- Ğ˜Ğ½Ğ´ĞµĞºÑÑ‹ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `username` (`username`);

--
-- AUTO_INCREMENT Ğ´Ğ»Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†
--

--
-- AUTO_INCREMENT Ğ´Ğ»Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `bookings`
--
ALTER TABLE `bookings`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=12;

--
-- AUTO_INCREMENT Ğ´Ğ»Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `reviews`
--
ALTER TABLE `reviews`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=8;

--
-- AUTO_INCREMENT Ğ´Ğ»Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `users`
--
ALTER TABLE `users`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;

--
-- ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ Ğ²Ğ½ĞµÑˆĞ½ĞµĞ³Ğ¾ ĞºĞ»ÑÑ‡Ğ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†
--

--
-- ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ Ğ²Ğ½ĞµÑˆĞ½ĞµĞ³Ğ¾ ĞºĞ»ÑÑ‡Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `bookings`
--
ALTER TABLE `bookings`
  ADD CONSTRAINT `bookings_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`);

--
-- ĞĞ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ Ğ²Ğ½ĞµÑˆĞ½ĞµĞ³Ğ¾ ĞºĞ»ÑÑ‡Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ `reviews`
--
ALTER TABLE `reviews`
  ADD CONSTRAINT `reviews_ibfk_1` FOREIGN KEY (`booking_id`) REFERENCES `bookings` (`id`);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
"
q1wZEAc5,CC: startup.lua v1.1,joploljojo3,Lua,Monday 16th of June 2025 10:59:17 AM CDT,"local tempPullEvent = os.pullEvent
os.pullEvent = os.pullEventRaw
local Correct = false
local md5 = require(""/lib/md5"")
shell.run(""clear"")
 
while not Correct do
  print(""Username:"")
  username = io.read()
  print(""Password:"")
  password = io.read()
  usernameCorrect = true
  if not fs.exists(""/etc/passwd/""..username) or username == """" then
    shell.run(""clear"")
    print(""Wrong username or password, try again."")
    usernameCorrect = false
  end
  if usernameCorrect == true then
    passhash = tostring(md5.digest(password))
    passfile = fs.open(""/etc/passwd/""..username, ""rb"")
    if passhash == passfile.readAll() then
      shell.run(""cd /home/""..username)
      shell.run(""clear"")
      print(""Welcome, ""..username..""!"")
      passfile.close()
      Correct = true
    else
      passfile.close()
      shell.run(""clear"")
      print(""Wrong username or password, try again."")
    end
  end
end
 
os.pullEvent = tempPullEvent"
myeM5qGa,Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ - index.php,ml1,PHP,Monday 16th of June 2025 10:56:25 AM CDT,"<?php
session_start();
require_once 'config/database.php';
?>
<!DOCTYPE html>
<html lang=""ru"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>Ğ¯ Ğ±ÑƒĞ´Ñƒ ĞºÑƒÑˆĞ°Ñ† - Ğ“Ğ»Ğ°Ğ²Ğ½Ğ°Ñ</title>
    <link href=""https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"" rel=""stylesheet"">
    <link href=""https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css"" rel=""stylesheet"">
    <link href=""assets/css/style.css"" rel=""stylesheet"">
    <style>
        .hero-section {
            background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('https://placehold.co/1920x1080');
            background-size: cover;
            background-position: center;
            color: white;
            padding: 100px 0;
            margin-bottom: 50px;
        }
        .hero-title {
            font-size: 3.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        .hero-subtitle {
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }
        .feature-card {
            text-align: center;
            padding: 2rem;
            border-radius: 10px;
            background: white;
            box-shadow: var(--box-shadow);
            transition: transform 0.3s ease;
            height: 100%;
        }
        .feature-card:hover {
            transform: translateY(-10px);
        }
        .feature-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
        }
        .about-section {
            padding: 50px 0;
            background-color: #f8f9fa;
        }
        .about-image {
            border-radius: 10px;
            box-shadow: var(--box-shadow);
            width: 100%;
            height: auto;
        }
        .cta-section {
            background: var(--primary-color);
            color: white;
            padding: 50px 0;
            margin-top: 50px;
        }
        .cta-button {
            background: white;
            color: var(--primary-color);
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        .cta-button:hover {
            background: var(--secondary-color);
            color: white;
            transform: translateY(-3px);
        }
    </style>
</head>
<body>
    <?php include 'includes/navigation.php'; ?>
    
    <section class=""hero-section"">
        <div class=""container text-center"">
            <h1 class=""hero-title"">Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² ""Ğ¯ Ğ±ÑƒĞ´Ñƒ ĞºÑƒÑˆĞ°Ñ†""</h1>
            <p class=""hero-subtitle"">Ğ›ÑƒÑ‡ÑˆĞ¸Ğµ Ğ±Ğ»ÑĞ´Ğ° Ğ¸ Ğ½ĞµĞ·Ğ°Ğ±Ñ‹Ğ²Ğ°ĞµĞ¼Ğ°Ñ Ğ°Ñ‚Ğ¼Ğ¾ÑÑ„ĞµÑ€Ğ°</p>
            <a href=""booking.php"" class=""btn btn-primary btn-lg"">Ğ—Ğ°Ğ±Ñ€Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ»Ğ¸Ğº</a>
        </div>
    </section>

    <section class=""container"">
        <div class=""row g-4 mb-5"">
            <div class=""col-md-4"">
                <div class=""feature-card"">
                    <i class=""bi bi-emoji-heart-eyes feature-icon""></i>
                    <h3>Ğ’ĞºÑƒÑĞ½Ğ°Ñ ĞµĞ´Ğ°</h3>
                    <p>ĞĞ°ÑˆĞ¸ ÑˆĞµÑ„-Ğ¿Ğ¾Ğ²Ğ°Ñ€Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²ÑÑ‚ Ğ±Ğ»ÑĞ´Ğ° Ñ Ğ»ÑĞ±Ğ¾Ğ²ÑŒÑ Ğ¸ Ğ·Ğ°Ğ±Ğ¾Ñ‚Ğ¾Ğ¹ Ğ¾ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ Ğ³Ğ¾ÑÑ‚Ğµ</p>
                </div>
            </div>
            <div class=""col-md-4"">
                <div class=""feature-card"">
                    <i class=""bi bi-clock feature-icon""></i>
                    <h3>Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾Ğµ Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ</h3>
                    <p>ĞœÑ‹ Ñ†ĞµĞ½Ğ¸Ğ¼ Ğ²Ğ°ÑˆĞµ Ğ²Ñ€ĞµĞ¼Ñ Ğ¸ Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ¾Ğµ Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ</p>
                </div>
            </div>
            <div class=""col-md-4"">
                <div class=""feature-card"">
                    <i class=""bi bi-star feature-icon""></i>
                    <h3>Ğ£ÑÑ‚Ğ½Ğ°Ñ Ğ°Ñ‚Ğ¼Ğ¾ÑÑ„ĞµÑ€Ğ°</h3>
                    <p>ĞšĞ¾Ğ¼Ñ„Ğ¾Ñ€Ñ‚Ğ½Ğ°Ñ Ğ¾Ğ±ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸ÑÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ²Ñ€ĞµĞ¼ÑĞ¿Ñ€ĞµĞ¿Ñ€Ğ¾Ğ²Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ</p>
                </div>
            </div>
        </div>
    </section>

    <section class=""about-section"">
        <div class=""container"">
            <div class=""row align-items-center"">
                <div class=""col-md-6"">
                    <img src=""https://placehold.co/600x400"" alt=""Ğ Ğ½Ğ°ÑˆĞµĞ¼ Ñ€ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½Ğµ"" class=""about-image"">
                </div>
                <div class=""col-md-6"">
                    <h2 class=""mb-4"">Ğ Ğ½Ğ°ÑˆĞµĞ¼ Ñ€ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½Ğµ</h2>
                    <p class=""lead"">ĞœÑ‹ ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ½ĞµĞ·Ğ°Ğ±Ñ‹Ğ²Ğ°ĞµĞ¼Ñ‹Ğµ Ğ²Ğ¿ĞµÑ‡Ğ°Ñ‚Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ğ³Ğ¾ÑÑ‚Ñ</p>
                    <p>ĞĞ°Ñˆ Ñ€ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½ Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ ÑˆĞ¸Ñ€Ğ¾ĞºĞ¸Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ğ±Ğ»ÑĞ´, Ğ¿Ñ€Ğ¸Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ¸Ğ· ÑĞ²ĞµĞ¶Ğ¸Ñ… Ğ¸ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ‚Ğ¾Ğ². ĞœÑ‹ Ğ³Ğ¾Ñ€Ğ´Ğ¸Ğ¼ÑÑ Ğ½Ğ°ÑˆĞµĞ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„ĞµÑÑĞ¸Ğ¾Ğ½Ğ°Ğ»Ğ¾Ğ², ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ´ĞµĞ»Ğ°ÑÑ‚ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ Ğ²Ğ¸Ğ·Ğ¸Ñ‚ Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ñ‹Ğ¼.</p>
                    <ul class=""list-unstyled"">
                        <li><i class=""bi bi-check-circle-fill text-success me-2""></i>Ğ¡Ğ²ĞµĞ¶Ğ¸Ğµ Ğ¸Ğ½Ğ³Ñ€ĞµĞ´Ğ¸ĞµĞ½Ñ‚Ñ‹</li>
                        <li><i class=""bi bi-check-circle-fill text-success me-2""></i>ĞŸÑ€Ğ¾Ñ„ĞµÑÑĞ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ¾Ğ²Ğ°Ñ€Ğ°</li>
                        <li><i class=""bi bi-check-circle-fill text-success me-2""></i>Ğ£ÑÑ‚Ğ½Ğ°Ñ Ğ°Ñ‚Ğ¼Ğ¾ÑÑ„ĞµÑ€Ğ°</li>
                        <li><i class=""bi bi-check-circle-fill text-success me-2""></i>Ğ’Ğ½Ğ¸Ğ¼Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»</li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <section class=""cta-section text-center"">
        <div class=""container"">
            <h2 class=""mb-4"">Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ñ‹ Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½Ğ°ÑˆĞ¸ Ğ±Ğ»ÑĞ´Ğ°?</h2>
            <p class=""lead mb-4"">Ğ—Ğ°Ğ±Ñ€Ğ¾Ğ½Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ ÑÑ‚Ğ¾Ğ»Ğ¸Ğº Ğ¿Ñ€ÑĞ¼Ğ¾ ÑĞµĞ¹Ñ‡Ğ°Ñ Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ ÑĞºĞ¸Ğ´ĞºÑƒ 10% Ğ½Ğ° Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·!</p>
            <a href=""booking.php"" class=""btn cta-button"">Ğ—Ğ°Ğ±Ñ€Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ğ»Ğ¸Ğº</a>
        </div>
    </section>

    <?php include 'includes/footer.php'; ?>
    
    <script src=""https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js""></script>
</body>
</html> "
zK8GeWx5,Untitled,Guest_028374,Lua,Monday 16th of June 2025 10:46:49 AM CDT,"local Library = loadstring(game:HttpGet(""https://raw.githubusercontent.com/Robojini/Tuturial_UI_Library/main/UI_Template_1""))()
local Window = Library.CreateLib(""mx hub oh yes again me"", ""RJTheme3"")
local Tab = Window:NewTab(""you evil"")
local Section = Tab:NewSection(""you really want this?..."")

Section:NewButton(""instant trolling"", ""ButtonInfo"", function()
    _G.auto = true

    while _G.auto do
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-78.2601929, 146.499817, -81.09935)
        wait(0.3)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-45.6606674, 146.105118, -80.9601898)
        wait(0.25)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-34.2864189, 146.64299, -82.5844727)
        wait(0.15)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-24.6313972, 146.640137, -82.3137207)
        wait(0.05)
    end
end)

Section:NewButton(""stop trolling(if you want)"", ""ButtonInfo"", function()
    _G.auto = false
end)"
6ir8VejT,signature,BangYadi,JSON,Monday 16th of June 2025 10:45:01 AM CDT,"{
  ""md5_signatures"": [
    ""31:94:EB:8B:4F:75:25:2E:31:D1:FF:F1:30:4C:E3:3F"",
    ""E8:9B:15:8E:4B:CF:98:8E:BD:09:EB:83:F5:37:8E:87""
  ],
  ""sha1_signatures"": [
    ""7A:27:69:C5:76:77:F7:EF:2F:AD:82:92:73:AD:DD:9F:D5:43:9C:29"",
    ""61:ED:37:7E:85:D3:86:A8:DF:EE:6B:86:4B:D8:5B:0B:FA:A5:AF:81""
  ]
}"
WuUKm4Tu,CC: PA - Time wand mover,kovakovi2000,Lua,Monday 16th of June 2025 09:54:18 AM CDT,"local chest = peripheral.wrap(""top"")  -- or the side it's on, e.g., ""top"", ""left"", etc.
local machine = peripheral.wrap(""bottom"")  -- or the side it's on, e.g., ""back"", ""right"", etc.
local numberOfMachine = 5

local processingTimeInTick = numberOfMachine * 8 * 2
local processingTimeInSeconds = processingTimeInTick / 20  -- Convert ticks to seconds
local rechargeTimeInSeconds = 1  -- Time to recharge the machine
local totalProcessingTimeInSeconds = processingTimeInSeconds + rechargeTimeInSeconds
-- Main loop

machine.pushItems(peripheral.getName(chest), 1)
while true do
  local items = chest.list()
  
  for slot, item in pairs(items) do
    local details = chest.getItemDetail(slot, true)
    if details and details.nbt and string.sub(details.nbt, 1, 8) == ""866815d7"" then
      chest.pushItems(peripheral.getName(machine), slot)
      sleep(totalProcessingTimeInSeconds)  -- Wait for the machine to process the item
      machine.pushItems(peripheral.getName(chest), 1)
    end
  end
end"
2JRg7JNT,dutradev,GENERALCORING4,JSON,Monday 16th of June 2025 09:50:08 AM CDT,"# Settings for controlling the auto-battler for AFK players.
AFKHandler {
    # The time in seconds before a player in a battle is declared to be AFK and the auto-battle code takes over for them.
    afkActivateSeconds=90
    # The time in seconds before the auto-battle handler picks a move automatically each turn.
    afkHandlerTurnSeconds=15
    # Have auto-battle take over if the player is AFK during a battle.
    # Activates after the specified time period and gives specified time for each turn after that.
    enableAFKHandler=false
}
# Settings for breeding behavior.
Breeding {
    # Allows the placement of ranch blocks, which are required for breeding Pokemon.
    allowBreeding=true
    # Allows two Ditto to breed together to produce Eggs with random PokÃƒÂ©mon inside.
    allowDittoDittoBreeding=true
    # Allow the crafting of ranch blocks.
    allowRanchCrafting=true
    # Allow the ranch expansion.
    allowRanchExpansion=true
    # Enable random Eggs from Ditto-Ditto breeding to contain Legendaries.
    allowRandomBreedingEggsToBeLegendary=false
    # Enables random Eggs from /pokegiveegg to contain Legendaries.
    allowRandomSpawnedEggsToBeLegendary=false
    # Seconds between running the environment check for breeders, requires useBreedingEnvironment to be enabled
    breedingEnviromentCheckSeconds=500
    # Number of world ticks needed to increase the breeding stage.
    breedingTicks=18000
    # Number of stages to go through before breeding occurs (1-5).
    numBreedingStages=5
    # Sets the number of steps per Egg cycle. Lower numbers hatch Eggs faster.
    stepsPerEggCycle=255
    # Control speed of breeding based on the blocks set in the area. If false, will set breeding speed to 1.0x.
    useBreedingEnviroment=true
    # Control speed of breeding based on the blocks set in the area. If false, will set breeding speed to 1.0x.
    useBreedingEnvironment=true
}
# Settings for re-routing the Pixelmon saving system into an external database.
Database {
    # Put the connection string for the external database in the form jdbc:dbtype://...
    connectionString=""jdbc:hd://""
    # Enable this to change the save system over to a database specified in the connection string property. Only H2 and MySQL currently supported.
    saveToExternalDatabase=false
}
# Options for the elevator.
Elevator {
    # Maximum search range up/down for a pairing elevator.
    elevatorSearchRange=10
}
# Settings for controlling external moves.
ExternalMoves {
    # Allows the use of external moves such as Rock Smash and Cut.
    allowExternalMoves=true
}
# General settings for the world.
General {
    # Allow the anvil to replace finished items with starting item from player's inventory without manual placing.
    allowAnvilAutoreloading=false
    # Allow player to throw Poke Balls from hotbar. If false, Poke Balls can only be thrown in battles.
    allowCaptureOutsideBattle=false
    # Allows move tutors that teach event moves to spawn naturally.
    allowEventMoveTutors=false
    # Allows the 17 types of Gems to be dropped by bosses.
    allowGemBossDrop=true
    # Allows the 17 types of Gems to be crafted by players.
    allowGemCrafting=true
    # Determines if player vs. player battles give Pokemon experience. No EXP gain in PvP when false.
    allowPVPExperience=true
    # Allow players to plant Apricorns in the ground.
    allowPlanting=true
    # Allow the player to nickname Pokemon (not a server-wide setting, just a client setting).
    allowPokemonNicknames=true
    # Determines if player vs. player battles give Pokemon experience. No EXP gain in PvP when false.
    allowPvPExperience=true
    # Permits bosses to drop ranch area upgrades.
    allowRanchUpgradeBossDrop=true
    # Allows players to make Rare Candies by crafting (server-side option).
    allowRareCandyCrafting=true
    # Allows players to make Rare Candies by crafting (server-side option).
    allowRateCandyCrafting=true
    # Allow players to ride Pokemon. If false, no Pokemon can be ridden (server-side option).
    allowRiding=true
    # If enabled, TMs are reusable. If disabled, TMs are consumed upon use.
    allowTMReuse=false
    # Determines if player vs. Trainer battles give Pokemon experience. No EXP gain in Trainer when false.
    allowTrainerExperience=true
    # Allow creepers, skeletons, etc. to spawn in the world. DANGER - can kill you while battling.
    allowVanillaMobs=false
    # Award photos to players who defeat wild Pokemon.
    awardPhotos=false
    # The radius in chunks around a player that Pokemon can spawn within.
    chunkSpawnRadius=8
    # Allow players to use cloning machines to clone Mew into Mewtwo.
    cloningMachineEnabled=true
    # Sets the amount of boxes players have in their PCs (capped at 256 per player).
    computerBoxes=256
    # When mounted, enables steering the Pokemon by looking.
    enablePointToSteer=true
    # Allows the Pokedex to open wiki pages.
    # Turn this off if you don't want the wiki opening from inside Pixelmon.
    enablePokedexWikiWebsiteOpen=false
    # Allow wild Pokemon to initiate battles.
    enableWildAggression=false
    # Allow wild Pokemon to initiate battles.
    enableWildAgression=false
    # If enabled, players will be able to challenge others by throwing a Pokemon at the enemy player rather than a Pokemon.
    engagePlayerByPokeBall=false
    # If enabled, players will be able to challenge others by throwing a Pokemon at the enemy player rather than a Pokemon.
    engagePlayerByPokeball=false
    # What will happen if a battle is force-ended without a proper conclusion.
    # 0: A winner is determined based on the number of remaining PokÃƒÂ©mon (with % HP as a tiebreaker).
    # 1: The battle is considered a draw.
    # 2: The battle is considered abnormally ended.
    forceEndBattleResult=0
    # Adjusts the variation in size caused by growth (0-2). 1 is normal.
    growthScaleModifier=1
    # Allow bosses to drop Isi's hourglasses, items that let you skip stages of breeding.
    isiHourglassBossDrop=true
    # Sets how far Pokemon names and levels can be seen from (client setting only). 1=Default, 2=Farther, 3=Far
    namePlateRange=3
    # Requires flying and water Pokemon mounts to have HM moves Fly or Surf (respectively) to be able to ride them.
    needHMToRide=false
    # Sets NPC rarity. Higher values spawn NPCs (Trainers, tutors) more often, 0 spawns no NPCs.
    npcRarity=50
    # Allows wild Pokemon to drop items like feathers, etc. on death.
    pokemonDropsEnabled=true
    # Prints more detailed error messages to the server.log file if enabled.
    printErrors=true
    # Removes regular Minecraft music so only Pixelmon music plays. Currently locked to true in code.
    removeVanillaMusic=true
    # If enabled, consumable held items will be returned to PokÃƒÂ©mon at the end of player vs. player battles.
    returnHeldItems=true
    # Set Legendary shrines to one use (false) or multiple use (true).
    reusableBirdShrines=true
    # Increases size of Pokemon models in-game by 30%.
    scalePokemonModels=true
    # Allow Legendary bird shrines to spawn randomly in world.
    spawnBirdShrines=true
    # Allow Spectral Jeweller Gem shrines to spawn randomly in world.
    spawnGemShrines=false
    # Allow random generation of structures such as Pokemon Centers, shrines, and other buildings if true.
    spawnStructures=true
    # If true, must be opped to use spawners. If false, must be in Creative mode.
    spawnersOpOnly=true
    # Battle camera rotates around player if true, and is stationary if false.
    spinBattleCamera=false
    # Lets you choose to give/not give a starter to a player on join (via the Pixelmon starter screen).
    starterOnJoin=true
    # The time taken before syncing to the system clock (in seconds).
    systemTimeSyncInterval=30
    # Set traders to one use (false) or multiple use (true).
    tradersReusable=true
    # Allows you to toggle which tab list you would like to use.
    # True for Pixelmon's, false for vanilla's.
    useCustomTabList=false
    # Load external NPC files from the ""npcs"" folder.  If set to true and the ""npcs"" folder does not exist, Pixelmon will create the folder and dump the existing files there.
    useExternalNPCFiles=true
    # Load external structure files from the ""structures"" folder.  If set to true and the ""structures"" folder does not exist, Pixelmon will create the folder and dump the existing files there.
    useExternalStructureFiles=false
    # Lets your world follow real world time or not (uses the server's system clock).
    useSystemTimeForWorldTime=false
    # Wild Pokemon will have a chance based on unfavourable battle conditions to try and flee from battle.
    wildCanFlee=false
    # Saves Pixelmon entities to file when world saves (greatly increases save file size and save time if true). Required for the morph mod.
    writeEntitiesToWorld=false
}
# Graphics settings.
Graphics {
    # Use the low resolution textures for Pokemon and Poke Balls. Useful for low end systems.
    lowResTextures=false
    # Multiplier of the 64 distance usually used for rendering.
    renderDistanceWeight=2
    # Display the currently selected Pokemon's attack target on the screen.
    showCurrentAttackTarget=true
    # Use the original Pokemon textures for statues.
    useOriginalPokemonTexturesForStatues=false
    # Use the SMD normal maps for shading Poke Balls.
    useSmoothShadingOnPokeBalls=true
    # Use the SMD normal maps for shading Poke Balls.
    useSmoothShadingOnPokeballs=true
    # Use the SMD normal maps for shading Pokemon.
    useSmoothShadingOnPokemon=true
}
# Settings for PixelUtilities features.
PixelUtilities {
    # Specify the coordinates of the event PokeGift chest here.
    eventCoords=[
        notConfigured
    ]
    # Enable/Disable Legendaries from being added to the event Poke Gift.
    eventHasLegendaries=false
    # Each Pokemon has a 1/10 chance of being a Shiny.
    eventHasShinies=false
    # Sets the maximum amount of Pokemon that are in spawned Poke Gifts.
    eventMaxPokemon=1
    # Should an event Poke Gift spawn?
    eventPokeGiftLoad=false
    # The rate of Shiny Pokemon appearing in a Poke Gift (1/x).
    eventShinyRate=10
    # Define a custom date for PokeGift events (day then month).
    eventTime=""D/M""
    # Allows Poke Gifts to be used (both placing and using, prevention against spam).
    pokeGiftHaveEvents=true
    # Enable multiple players to get the Pokemon from the gift.
    pokeGiftReusable=false
    # Enable multiple players to get the Pokemon from the gift.
    pokegiftReusable=false
    # Scale grass battles to players team levels?
    scaleGrassBattles=false
}
# Settings for controlling PokeLoot chest spawns and behavior.
PokeLoot {
    # Allow Hidden Grottos to spawn in the world.
    spawnGrotto=true
    # Allows invisible PokeChests to spawn around the world randomly.
    spawnHidden=true
    # Default spawn mode (FCFS=0, PL1D=1, PUD=2, TIMED=3)
    # FCFS = First Come First Serve, only one player can loot chest, then chests vanishes.
    # PL1D = Player 1 Drop, chest gives one drop per person. Chest remains for others to use once each.
    # PUD = Player Unlimited Drops, chests can be used infinitely by all players.
    # TIMED = Each player allowed to loot again after specified time interval (individual timers). Chest remains after looting.
    spawnMode=0
    # Allows normal visible PokeChests to spawn around the world randomly.
    spawnNormal=true
    # Chest spawn rate
    # 0: 1 per 64 chunks
    # 1: 1 per 32 chunks
    # 2: 1 per 18 chunks
    # 3: 1 per 10 chunks
    spawnRate=1
    # Sets frequency that a player can reuse a timed loot chest (both placed in Creative and naturally spawned if set to TIMED.
    # Time conversions: one hour = 3600 seconds, one day = 86400 seconds, one week = 604800 seconds.
    timedLootReuseSeconds=86400
}
# Sound settings.
Sounds {
    # Maximum number of world ticks before a new music track will start.
    maxMusicDelay=24000
    # Minimum number of world ticks before a new music track will start.
    minMusicDelay=12000
}
# Settings that control what Pokemon spawns and how many of them spawn.
Spawning {
    # These values set whether or not a Generation's Pokemon will be spawned.
    Gens {
        # Pokedex 1-151
        Gen1=true
        # Pokedex 152-251
        Gen2=true
        # Pokedex 252-386
        Gen3=true
        # Pokedex 387-493
        Gen4=true
        # Pokedex 494-649
        Gen5=true
        # Pokedex 650-719
        Gen6=true
    }
    # Allow wild Legendaries to spawn (besides specific event spawns).
    allowLegendarySpawn=true
    # Chance of a group of wild Pokemon containing a boss Pokemon (1/rate). 0 disables boss spawns.
    bossSpawnRate=250
    # The radius in chunks around a player, that Pixelmon can spawn within.
    chunkSpawnRadius=8
    # Forces wild Pokemon to despawn after a battle.
    despawnOnFleeOrLoss=false
    # Displays server-wide announcement 'A Legendary has spawned in <name> biome' when a Legendary spawns.
    displayLegendaryGlobalMessage=true
    # Chance of a wild Pokemon spawning with its hidden ability (1/rate). 0 disables hidden ability spawns.
    hiddenAbilitySpawnRate=150
    # Minimum number of ticks before a particular legendary can spawn again (via main spawner).
    legendaryRepeatSpawnTicks=96000
    # Chance that a Legendary spawn attempt will succeed (0-1).
    legendarySpawnChance=0.0750000029802322
    # Sets odds of Legendary spawning (1 in X spawns). Higher values spawn wild Legendaries less often.
    legendarySpawnRate=22000
    # Average number of ticks before an attempt at Legendary spawning will be made (modified by spawn chance).
    legendarySpawnTicks=3000
    # Max number of flying Pokemon at one time (keep this low).
    maxFlyingPokemon=2
    # Max number of land Pokemon at one time.
    maxLandPokemon=40
    # Max number of underground Pokemon at one time.
    maxUndergroundPokemon=20
    # Max number of water Pokemon at one time.
    maxWaterPokemon=20
    # Replaces Minecraft's villagers with Pixelmon NPCs.
    replaceMCVillagers=true
    # Shiny calculation uses 1/(Shiny rate) to get odds of becoming Shiny.
    shinySpawnRate=8192
    # List of dimensions that Pokemon will spawn in.
    spawnDimensions=[
        0
    ]
    # Poke Marts will spawn with shopkeepers in Minecraft's towns
    spawnPokeMarts=true
    # Pokemarts will spawn with shopkeepers in Minecraft's towns
    spawnPokemarts=true
}
Starters {
    # Level (min=5, max=100)
    level=5
    # Shiny starters
    shiny=false
    # List of starters (max of 15)
    starterList=[
        Bulbasaur,
        Squirtle,
        Charmander,
        Chikorita,
        Totodile,
        Cyndaquil,
        Treecko,
        Mudkip,
        Torchic,
        Turtwig,
        Piplup,
        Chimchar,
        Snivy,
        Oshawott,
        Tepig
    ]
}
"
M8szzvzR,Untitled,linus666,Python,Monday 16th of June 2025 09:40:27 AM CDT,"go = range
enum = enumerate

def read_line():
    return input()

   
def read_int():
    return int(read_line())
 
 
def read_ints():
    return map(int, read_line().split())
 
 
def yes_no(yes, yes_str=""yes"", no_str=""no""):
    return yes_str if yes else no_str


def C(a):
    from collections import Counter as C
    return C(a)


def swap(a, i, j):
    a[i], a[j] = a[j], a[i]

# def test():
# 
#     def get_test():
#         pass
#     
#     def get_true_ans():
#         pass
#         
#     pass



def solve():

    # from collections import Counter as C, defaultdict as dd
    # from itertools import groupby as g
    # from bisect import bisect_left as bl, bisect_right as br
    pass"
CwSPkeGi,test_rwspin.c,funny_falcon,C,Monday 16th of June 2025 09:20:04 AM CDT,"#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <stdbool.h>
#include <stdatomic.h>
#include <stdint.h>
#include <threads.h>
#include <immintrin.h>
#include <unistd.h>

typedef atomic_uint_least32_t RWSpin;

static inline void
spin_delay(uint32_t *delay)
{
	++(*delay);
	if (*delay == 1000)
	{
		usleep(1000);
		*delay = 0;
	}
	else if (*delay % 100 == 0)
		thrd_yield();
	else //if (*delay % 4 == 0)
		_mm_pause();
	atomic_signal_fence(memory_order_relaxed);
}


enum
{
	RW_SPIN_EX_LOCK = 1,
	RW_SPIN_SH_MARK = 2,
};

static void RWSpinLockEx_slowpath(RWSpin *spin, uint32_t val);

static inline void
RWSpinLockEx(RWSpin *spin)
{
	uint32_t old = atomic_load_explicit(spin, memory_order_relaxed);
	
	if (old ||
		!atomic_compare_exchange_strong(spin, &old, RW_SPIN_EX_LOCK))
		RWSpinLockEx_slowpath(spin, old);
}

static void
RWSpinLockEx_slowpath(RWSpin *spin, uint32_t val)
{
	uint32_t delay = 0;
	for (;;)
	{
		if (val == 0)
		{
			if (atomic_compare_exchange_strong(spin, &val, RW_SPIN_EX_LOCK))
				break;
		}
		else
		{
			spin_delay(&delay);
			val = atomic_load_explicit(spin, memory_order_relaxed);
		}
	}
}

static inline void
RWSpinUnlockEx(RWSpin *spin)
{
	atomic_fetch_sub(spin, RW_SPIN_EX_LOCK);
}

static void RWSpinLockSh_slowpath(RWSpin *spin, uint32_t val);

static inline void
RWSpinLockSh(RWSpin *spin)
{
	uint32_t val = atomic_fetch_add(spin, RW_SPIN_SH_MARK);

	if (val & RW_SPIN_EX_LOCK)
		RWSpinLockSh_slowpath(spin, val);
}

static void
RWSpinLockSh_slowpath(RWSpin *spin, uint32_t val)
{
	uint32_t delay = 0;

	while (val & RW_SPIN_EX_LOCK)
	{
		spin_delay(&delay);
		val = atomic_load_explicit(spin, memory_order_relaxed);
	}

	atomic_thread_fence(memory_order_seq_cst);
}

static inline void
RWSpinUnlockSh(RWSpin *spin)
{
	atomic_fetch_sub(spin, RW_SPIN_SH_MARK);
}

static inline void
FlagAcquire(atomic_bool *flg)
{
	uint32_t delay = 0;
	while (atomic_exchange_explicit(flg, 1, memory_order_acquire))
	{
		while (atomic_load_explicit(flg, memory_order_relaxed))
			spin_delay(&delay);
	}
}

static inline void
FlagRelease(atomic_bool *flg)
{
	atomic_store_explicit(flg, 0, memory_order_relaxed);
}

typedef atomic_uint_least64_t RWOptLock;
typedef struct {
	RWOptLock *lock;
	uint64_t v;
	uint32_t delay;
	bool check;
} RWOptLockRead;

static inline void
RWOptAcquire(RWOptLock *lock)
{
	uint32_t delay = 0;
	uint64_t val = atomic_fetch_or(lock, 1);
	if ((val & 1) == 0)
		return;
	do
	{
		spin_delay(&delay);
		val = atomic_load_explicit(lock, memory_order_relaxed);
	} while((val & 1) || (atomic_fetch_or(lock, 1) & 1));
}

static inline void
RWOptRelease(RWOptLock *lock)
{
	atomic_fetch_add(lock, 1);
}

static inline bool
RWOptReadDone( RWOptLockRead *rd)
{
	uint64_t val;
	if (rd->check)
	{
		atomic_thread_fence(memory_order_seq_cst);
		val = atomic_load_explicit(rd->lock, memory_order_relaxed);
		if (val == rd->v)
			return true;
		rd->v = val;
	}
	else
	{
		rd->check = true;
		val = atomic_load_explicit(rd->lock, memory_order_relaxed);
	}
	val = rd->v;
	while (val & 1)
	{
		spin_delay(&rd->delay);
		val = atomic_load_explicit(rd->lock, memory_order_relaxed);
	}
	rd->v = val;
	atomic_thread_fence(memory_order_seq_cst);
	return false;
}

#define RWOptReadLoop(opt) for (RWOptLockRead _rd_ = (RWOptLockRead){.lock = (opt)}; !RWOptReadDone(&_rd_);)

typedef struct {
	RWSpin spin;
	atomic_bool spin_flg;
	RWOptLock opt;
	char pad[128];
	uint32_t iters;
	uint32_t every;
	uint64_t a;
	uint64_t b;
} TestVal;

static int
test_func_ex(void *arg)
{
	TestVal *val = arg;
	uint32_t delay = 0;
	bool less;
	uint64_t sa, sb;

	for (unsigned i = 0; i < val->iters; i++)
	{
		if (i % val->every == 0)
		{
			FlagAcquire(&val->spin_flg);
			assert(val->a == val->b || val->a == val->b + 1);
			less = val->a <= val->b;
			atomic_signal_fence(memory_order_relaxed); /* acts as compiler barrier */
			if (less)
				val->a++;
			else
				val->b++;
			FlagRelease(&val->spin_flg);
		}
		else
		{
			FlagAcquire(&val->spin_flg);
			sa = val->a;
			atomic_signal_fence(memory_order_relaxed); /* acts as compiler barrier */
			sb = val->b;
			FlagRelease(&val->spin_flg);
			assert(sa == sb || sa == sb + 1);
		}
	}
	return 0;
}

static int
test_func_rwspin(void *arg)
{
	TestVal *val = arg;
	uint32_t delay = 0;
	bool less;
	uint64_t sa, sb;

	for (unsigned i = 0; i < val->iters; i++)
	{
		//if (i % 1000 == 0)
			//fprintf(stderr, ""%i\n"", i);
		if (i % val->every == 0)
		{
			RWSpinLockEx(&val->spin);
			assert(val->a == val->b || val->a == val->b + 1);
			less = val->a <= val->b;
			atomic_signal_fence(memory_order_relaxed); /* acts as compiler barrier */
			if (less)
				val->a++;
			else
				val->b++;
			RWSpinUnlockEx(&val->spin);
		}
		else
		{
			RWSpinLockSh(&val->spin);
			sa = val->a;
			atomic_signal_fence(memory_order_relaxed); /* acts as compiler barrier */
			sb = val->b;
			RWSpinUnlockSh(&val->spin);
			assert(sa == sb || sa == sb + 1);
		}
	}
	return 0;
}

static int
test_func_rwopt(void *arg)
{
	TestVal *val = arg;
	uint32_t delay = 0;
	bool less;
	uint64_t sa, sb;

	for (unsigned i = 0; i < val->iters; i++)
	{
		if (i % val->every == 0)
		{
			RWOptAcquire(&val->opt);
			assert(val->a == val->b || val->a == val->b + 1);
			less = val->a <= val->b;
			atomic_signal_fence(memory_order_relaxed); /* acts as compiler barrier */
			if (less)
				val->a++;
			else
				val->b++;
			RWOptRelease(&val->opt);
		}
		else
		{
			RWOptReadLoop(&val->opt)
			{
				sa = val->a;
				atomic_signal_fence(memory_order_relaxed); /* acts as compiler barrier */
				sb = val->b;
			}
			assert(sa == sb || sa == sb + 1);
		}
	}
	return 0;
}

int main(int argc, char **argv)
{
	long niters = argc > 1 ? atol(argv[1]) : 10000;
	long every = argc > 2 ? atol(argv[2]) : 8;
	long kind = argc > 3 ? atol(argv[3]) : 1;
	long nthreads = argc > 4 ? atol(argv[4]) : 8;

	TestVal val = {.spin = 0, .spin_flg = false,
		.every = every, .iters = niters};

	thrd_start_t func = kind == 0 ? test_func_rwspin :
	                    kind == 1 ? test_func_ex :
	                    kind == 2 ? test_func_rwopt : NULL;
	                              
	thrd_t *threads = calloc(nthreads, sizeof(thrd_t));
	assert(threads != NULL);


	for (int i = 0; i < nthreads; i++)
	{
		int r = thrd_create(&threads[i], func, &val);
		assert(r == thrd_success);
	}
	for (int i = 0; i < nthreads; i++)
	{
		int r = thrd_join(threads[i], NULL);
		assert(r == thrd_success);
	}
	return 0;
}
"
iJDRbWqA,Beaver Builder fix,swte,PHP,Monday 16th of June 2025 08:43:32 AM CDT,"<?php
/**
 * Plugin Name: FLBuilder Fix
 */

if (
    isset($_POST['fl_builder_data']['action']) &&
    $_POST['fl_builder_data']['action'] === 'render_legacy_settings'
) {
   $_GET['noshifty'] = 1;
}
"
GrNEXyse,Go min/max implementation,metalim,Go,Monday 16th of June 2025 07:50:14 AM CDT,"// minMax converts an OMIN/OMAX builtin call into SSA.
func (s *state) minMax(n *ir.CallExpr) *ssa.Value {
	// The OMIN/OMAX builtin is variadic, but its semantics are
	// equivalent to left-folding a binary min/max operation across the
	// arguments list.
	fold := func(op func(x, a *ssa.Value) *ssa.Value) *ssa.Value {
		x := s.expr(n.Args[0])
		for _, arg := range n.Args[1:] {
			x = op(x, s.expr(arg))
		}
		return x
	}

	typ := n.Type()

	if typ.IsFloat() || typ.IsString() {
		// min/max semantics for floats are tricky because of NaNs and
		// negative zero. Some architectures have instructions which
		// we can use to generate the right result. For others we must
		// call into the runtime instead.
		//
		// Strings are conceptually simpler, but we currently desugar
		// string comparisons during walk, not ssagen.

		if typ.IsFloat() {
			hasIntrinsic := false
			switch Arch.LinkArch.Family {
			case sys.AMD64, sys.ARM64, sys.Loong64, sys.RISCV64:
				hasIntrinsic = true
			case sys.PPC64:
				hasIntrinsic = buildcfg.GOPPC64 >= 9
			}

			if hasIntrinsic {
				var op ssa.Op
				switch {
				case typ.Kind() == types.TFLOAT64 && n.Op() == ir.OMIN:
					op = ssa.OpMin64F
				case typ.Kind() == types.TFLOAT64 && n.Op() == ir.OMAX:
					op = ssa.OpMax64F
				case typ.Kind() == types.TFLOAT32 && n.Op() == ir.OMIN:
					op = ssa.OpMin32F
				case typ.Kind() == types.TFLOAT32 && n.Op() == ir.OMAX:
					op = ssa.OpMax32F
				}
				return fold(func(x, a *ssa.Value) *ssa.Value {
					return s.newValue2(op, typ, x, a)
				})
			}
		}
		var name string
		switch typ.Kind() {
		case types.TFLOAT32:
			switch n.Op() {
			case ir.OMIN:
				name = ""fmin32""
			case ir.OMAX:
				name = ""fmax32""
			}
		case types.TFLOAT64:
			switch n.Op() {
			case ir.OMIN:
				name = ""fmin64""
			case ir.OMAX:
				name = ""fmax64""
			}
		case types.TSTRING:
			switch n.Op() {
			case ir.OMIN:
				name = ""strmin""
			case ir.OMAX:
				name = ""strmax""
			}
		}
		fn := typecheck.LookupRuntimeFunc(name)

		return fold(func(x, a *ssa.Value) *ssa.Value {
			return s.rtcall(fn, true, []*types.Type{typ}, x, a)[0]
		})
	}

	if typ.IsInteger() {
		if Arch.LinkArch.Family == sys.RISCV64 && buildcfg.GORISCV64 >= 22 && typ.Size() == 8 {
			var op ssa.Op
			switch {
			case typ.IsSigned() && n.Op() == ir.OMIN:
				op = ssa.OpMin64
			case typ.IsSigned() && n.Op() == ir.OMAX:
				op = ssa.OpMax64
			case typ.IsUnsigned() && n.Op() == ir.OMIN:
				op = ssa.OpMin64u
			case typ.IsUnsigned() && n.Op() == ir.OMAX:
				op = ssa.OpMax64u
			}
			return fold(func(x, a *ssa.Value) *ssa.Value {
				return s.newValue2(op, typ, x, a)
			})
		}
	}

	lt := s.ssaOp(ir.OLT, typ)

	return fold(func(x, a *ssa.Value) *ssa.Value {
		switch n.Op() {
		case ir.OMIN:
			// a < x ? a : x
			return s.ternary(s.newValue2(lt, types.Types[types.TBOOL], a, x), a, x)
		case ir.OMAX:
			// x < a ? a : x
			return s.ternary(s.newValue2(lt, types.Types[types.TBOOL], x, a), a, x)
		}
		panic(""unreachable"")
	})
}
"
wdPGRxXV,Ğ¼Ğ¸ĞºÑ€Ğ¾Ñ€Ğ°Ğ·Ğ¼ĞµÑ‚ĞºĞ° Ğ´Ğ»Ñ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ² ggsel,ashenkai,JSON,Monday 16th of June 2025 07:38:12 AM CDT,"{
  ""@context"": ""https://schema.org"",
  ""@type"": ""Product"",
  ""name"": ""Minecraft: Java &Bedrock Ğ´Ğ»Ñ ĞŸĞš ĞšĞ»ÑÑ‡ Ğ’Ğ¡Ğ• Ğ¡Ğ¢Ğ ĞĞĞ«"", // ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°
  ""image"": ""https://img.ggsel.ru/3834786/original/AUTOxAUTO/6332344_imgwebp.webp"", // ĞšĞ°Ñ€Ñ‚Ğ¸Ğ½ĞºĞ° Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°
  ""description"": ""ĞŸĞ¾ĞºÑƒĞ¿Ğ°Ğ¹Ñ‚Ğµ ĞºĞ»ÑÑ‡ Minecraft: Java &Bedrock Ğ´Ğ»Ñ ĞŸĞš ĞšĞ»ÑÑ‡ Ğ’Ğ¡Ğ• Ğ¡Ğ¢Ğ ĞĞĞ« Ñƒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ²Ñ†Ğ° All for Gamers Ñ Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸ĞµĞ¹ ÑĞ´ĞµĞ»ĞºĞ¸ Ğ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°Ğ¼Ğ¸. ĞœĞ¾Ğ¼ĞµĞ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ°. Ğ¡ĞºĞ¸Ğ´ĞºĞ° Ğ´Ğ¾ ĞºĞ¾Ğ½Ñ†Ğ° Ğ½ĞµĞ´ĞµĞ»Ğ¸! ĞŸÑ€Ğ¾Ğ´Ğ°Ğ½Ğ¾: 21Â 217. ĞŸĞ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ñ… Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ¾Ğ²: 1Â 629."", // ĞŸĞ¾Ğ´Ñ‚ÑĞ³Ğ¸Ğ²Ğ°ĞµĞ¼ meta-description
  ""brand"": {
    ""@type"": ""Brand"",
    ""name"": ""GGSEL""
  },
  ""aggregateRating"": {
    ""@type"": ""AggregateRating"",
    ""ratingValue"": 5, // ĞŸĞ¾Ğ´Ñ‚ÑĞ³Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°
    ""bestRating"": 5,
    ""worstRating"": 1,
    ""reviewCount"": 1629 // ĞŸĞ¾Ğ´Ñ‚ÑĞ³Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ ĞºĞ¾Ğ»-Ğ²Ğ¾ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ¾Ğ²
  },
  ""offers"": {
    ""@type"": ""Offer"",
    ""url"": ""https://ggsel.net/catalog/product/3834786"",
    ""priceCurrency"": ""RUB"", // Ğ”Ğ»Ñ ru-Ğ²ĞµÑ€ÑĞ¸Ğ¸ ""RUB"", Ğ´Ğ»Ñ en-Ğ²ĞµÑ€ÑĞ¸Ğ¸ ""USD""
    ""price"": 1699, // ĞœĞµĞ½ÑĞµÑ‚ÑÑ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ğ²ĞµÑ€ÑĞ¸Ğ¸
    ""priceValidUntil"": ""2025-06-23"", // ĞŸĞ¾Ğ´Ñ‚ÑĞ³Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ ĞºĞ¾Ğ½ĞµÑ‡Ğ½Ğ°Ñ Ğ´Ğ°Ñ‚Ğ° ÑĞºĞ¸Ğ´ĞºĞ¸
    ""availability"": ""https://schema.org/InStock"", // Ğ•ÑĞ»Ğ¸ Ğ½Ğµ Ğ² Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğ¸ - ""https://schema.org/OutOfStock""
    ""seller"": {
      ""@type"": ""Organization"",
      ""name"": ""ThunderGames"" // ĞŸĞ¾Ğ´Ñ‚ÑĞ³Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ Ğ¸Ğ¼Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ²Ñ†Ğ°
    },
    ""priceSpecification"": [
      {
        ""@type"": ""UnitPriceSpecification"",
        ""priceCurrency"": ""RUB"", // Ğ”Ğ»Ñ ru-Ğ²ĞµÑ€ÑĞ¸Ğ¸ ""RUB"", Ğ´Ğ»Ñ en-Ğ²ĞµÑ€ÑĞ¸Ğ¸ ""USD""
        ""price"": 1899, // Ğ¤Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ñ†ĞµĞ½Ğ°; ĞœĞµĞ½ÑĞµÑ‚ÑÑ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ğ²ĞµÑ€ÑĞ¸Ğ¸
        ""description"": ""ĞĞ±Ñ‹Ñ‡Ğ½Ğ°Ñ Ñ†ĞµĞ½Ğ°""
      },
      {
        ""@type"": ""UnitPriceSpecification"",
        ""priceCurrency"": ""RUB"", // Ğ”Ğ»Ñ ru-Ğ²ĞµÑ€ÑĞ¸Ğ¸ ""RUB"", Ğ´Ğ»Ñ en-Ğ²ĞµÑ€ÑĞ¸Ğ¸ ""USD""
        ""price"": 1699, // Ğ¦ĞµĞ½Ğ° ÑĞ¾ ÑĞºĞ¸Ğ´ĞºĞ¾Ğ¹; ĞœĞµĞ½ÑĞµÑ‚ÑÑ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ğ²ĞµÑ€ÑĞ¸Ğ¸
        ""description"": ""Ğ¦ĞµĞ½Ğ° ÑĞ¾ ÑĞºĞ¸Ğ´ĞºĞ¾Ğ¹""
      }
    ]
  }
}
"
