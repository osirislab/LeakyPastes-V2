id,title,username,language,date,content
w8pk15sE,Vouchers Method,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 01:03:08 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

93619
"
YCvsVj7e,❤️ Telegram Leaks ❤️,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:59:27 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

01489
"
BPCH4dMJ,❤️ Private BTC Method ❤️,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:55:45 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

09128
"
nqRCKQ8h,Leaked Accounts - Fresh Hits,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:52:03 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

13896
"
017KDz0Z,Bot 23 Azionario Meta 60 Min,Maurizio-Ciullo,JavaScript,Thursday 15th of May 2025 12:50:41 PM CDT,"////////////////////////////////////////////////////// STRATEGIA FINITA SU AZIONARIO AMERICANO META PARTE 2 DI 2 Azionario Meta 15Min
//////////////////////////////////////////////////////  INIZIO SVILUPPO TIMEFRAME 60 MIN, TEST PORTAFOGLIO 30 MIN ""VEDI VIDEO CARTELLA QTA MASTERMIND"", APPLICAZIONE STRATEGIA FINALE 15 MIN
// Header e Footer sono solo per il backtest in sample out of sample ricuvuto dallo study, nella strategia non serve può essere eliminato, serve solo per lo sviluppo.

---------------- HEADER INIZIO: DA ELIMINARE ----------------}
Inputs: isSampleOutOfSampleActive(0), displayMode(1);
if isSampleOutOfSampleActive = 0 or (
((displayMode = 1 or displayMode = 3) and isSampleOutOfSampleActive = 1 and ((Date >= 1120518 and Date <= 1146500) or (Date >= 1163824 and Date <= 1189806) or (Date >= 1207130 and Date <= 1233112) or marketposition <> 0)) or 
((displayMode = 2 or displayMode = 3) and isSampleOutOfSampleActive = 1 and ((Date > 1146501 and Date <= 1163823) or (Date > 1189807 and Date <= 1207129) or (Date > 1233113 and Date <= 1250435) or marketposition <> 0))) then begin
{---------------- HEADER FINE: DA ELIMINARE ----------------}

Inputs: be(200);
Vars: n(0);
n = 10000 / Close;


setStopPosition;

if MarketPosition = 0 then begin
	//Il prezzo di chiusura di ieri e' sceso di almeno lo 0.5% rispetto a due giorni fa.
	if (CloseD(1) < CloseD(2) ) then begin
		if ( (HighS(0) - OpenS(0)) > ((HighS(1) - OpenS(1)))) then begin
			buy n shares next bar at market;
		end;
	end;
end;

setbreakeven(be);
SetStopLoss(300);
SetProfitTarget(450);


{---------------- FOOTER INIZIO: DA ELIMINARE ----------------}
end;
{---------------- FOOTER FINE: DA ELIMINARE ----------------}"
G3DBL1vj,telegram leaks❤️ 3A,Samuelflopez,JavaScript,Thursday 15th of May 2025 12:50:40 PM CDT," 
check it out at >> https://t.me/LucasL3AK  

9ndTgW74lj
"
sG1Htg7W,BALANCE MEHTOD❤️ XN,jocaquim,JavaScript,Thursday 15th of May 2025 12:50:20 PM CDT," 
check it out at >> https://t.me/LucasL3AK  

haSUnIlqpJ
"
NC3QkCH6,Vouchers Method,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:48:20 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

15248
"
gXJrev0q,❤️ Telegram Leaks ❤️,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:44:37 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

52208
"
ubW4Gx7i,❤️ Private BTC Method ❤️,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:40:56 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

68043
"
q7Dp2isp,Leaked Accounts - Fresh Hits,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:37:08 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

42225
"
MGVWjUPr,❤️private mehtod❤️ RM,jocaquim,JavaScript,Thursday 15th of May 2025 12:33:38 PM CDT," 
check it out at >> https://t.me/LucasL3AK  

oeLjsVD95y
"
2qmX4QjX,Vouchers Method,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:33:26 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

52116
"
At0tUu7V,❤️ Telegram Leaks ❤️,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:29:44 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

88516
"
PNLs1jy8,❤️ Private BTC Method ❤️,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:26:02 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

10343
"
ALdx09Cm,test1,Trollwor,Lua,Thursday 15th of May 2025 12:25:00 PM CDT,"local whitelist = {
	pass1 = {player = ""pl1"", mode = 0},
	pass2 = {player = ""pl2"", mode = 11},
	hello123 = {player = ""1tt_nonamescripts"", mode = 4},
}"
X8mkfj2V,Leaked Accounts - Fresh Hits,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:22:21 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

98607
"
wvjiJEsL,❤️private mehtod CD,Samuelflopez,JavaScript,Thursday 15th of May 2025 12:20:37 PM CDT," 
check it out at >> https://t.me/LucasL3AK  

dqyIDzBHWc
"
HxR3xANY,Vouchers Method,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:18:39 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

21581
"
CwvwRev2,❤️BTC BALANCE GUIDE❤️ GV,jocaquim,JavaScript,Thursday 15th of May 2025 12:16:55 PM CDT," 
check it out at >> https://t.me/LucasL3AK  

yOeFGGLO3K
"
Ww6nPdST,❤️ Telegram Leaks ❤️,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:14:57 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

04138
"
mPD7GWYJ,❤️ Private BTC Method ❤️,jojotasdgdfgfghfg,JavaScript,Thursday 15th of May 2025 12:11:15 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

25926
"
MHKvDNTG,❤️ Telegram Leaks ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 12:07:26 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

35189
"
GiSs3c3N,❤️ Private BTC Method ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 12:03:45 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

23139
"
3AJQD7a0,Leaked Accounts - Fresh Hits,Pebblesresortss,JavaScript,Thursday 15th of May 2025 12:00:04 PM CDT,"
Check it out at >> https://t.me/leakzbyeminem

79859
"
NLBbTZuB,Vouchers Method,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:56:22 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

68555
"
Kdbm2Txp,❤️ Telegram Leaks ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:52:39 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

70054
"
PrRgaU4g,❤️ Private BTC Method ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:48:57 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

66235
"
00c9Z4DF,Leaked Accounts - Fresh Hits,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:45:15 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

71352
"
1QrxSz1e,Vouchers Method,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:41:32 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

57300
"
cv6rig9L,❤️ Telegram Leaks ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:37:51 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

89784
"
F60yKhUe,❤️ Private BTC Method ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:34:09 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

63184
"
C3Fs5FAC,Leaked Accounts - Fresh Hits,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:30:27 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

84585
"
3LCH21wE,Другий семестр. Лабораторна робота №18 (Завдання 2),Lavig,C++,Thursday 15th of May 2025 11:29:30 AM CDT,"#include <iostream>
#include <windows.h>
#include <vector>

using namespace std;

template<typename Iterator, typename Condition>
Iterator findFirstIf(Iterator start, Iterator end, Condition cond) {
    for (Iterator current = start; current != end; ++current) {
        if (cond(*current)) {
            return current;
        }
    }
    return end;
}

bool isEven(int x) {
    return x % 2 == 0;
}

bool isGreater(int x) {
    return x > 5;
}

int main() {
    SetConsoleOutputCP(1251);
    SetConsoleCP(1251);
    const int N = 5;
    int arr[N]{};
    vector<int> vec;
    cout << ""Введіть 5 цілих чисел:"" << endl;
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
        vec.push_back(arr[i]);
    }
    int* arrResult = findFirstIf(arr, arr + N, isEven);
    if (arrResult != arr + N) {
        cout << ""Перший парний елемент: "" << *arrResult << "", його індекс - "" << (arrResult - arr) << endl;
    }
    else {
        cout << ""Парних елементів у масиві немає"" << endl;
    }
    auto vecResult = findFirstIf(vec.begin(), vec.end(), isGreater);
    if (vecResult != vec.end()) {
        cout << ""Перший елемент більший за 5: "" << *vecResult << "", його індекс - "" << (vecResult - vec.begin()) << endl;
    }
    else {
        cout << ""У масиві немає елементів більших за 5"" << endl;
    }
}"
A4jnmP5z,Vouchers Method,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:26:46 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

42739
"
jUMZ9zDT,Untitled,soupyc,PowerShell,Thursday 15th of May 2025 11:25:35 AM CDT,"<#
.SYNOPSIS
    Creates address lists, policies, and DLs for each OU in a customer's account. Sets policies and if flagged, Mailbox/calendar permissions for each Mailbox.

.DESCRIPTION
    Given account ID and platform (SEH or PLR), retrieves Exchange server FQDN and account username from DATAC.
    Gets all organizational units for given account.
    Gets domain of account Exchange server and connects to an available Exchange endpoint in that domain.

    Create-AddressLists
        Checks each Org Unit for Address List, All Rooms List, Global Address List, Offline Address Book, and Address Book Policy.
        If Address List is not present, creates new address list or updates existing one with current user values.
        If ""All Rooms Address List"" for account is not present, creates room list or updates existing one.
        If Global Address List is not present, creates new GAL or updates existing one.
        If Offline Address Book is not present, creates new OAB or updates existing one.
        If no Address Book Policy is present, creates new ABP with new or existing Address List, GAL, All Rooms List, and Offline Address book from previous logic in function.

    Update-DistributionList
        Checks each Org Unit for a distribution list containing users in that OU. Every OU should have a DL with all members.
        If DL is not present, creates new DL with proper OU and PrimarySmtpAddress set to convention.
        ADSI attributes are set on DL to hide from address list and set account, hosting object type, and hosting owner for use in HostPilot.

    Update-Mailboxes
        Gets all Mailboxes for each OU and changes address book policy from default to policy created earlier.
        Adds each Mailbox to distribution list created earlier.
        Changes default calendar permissions for each Mailbox to AccessRights - None.
        Changes calendar permissions for distribution list for each Mailbox to AccessRights - AvailabilityOnly.

    Special conditions for CID-3356
        Address list creation recipient filters vary depending on the OU the mailbox is in.
        RB-##### OUs can see their own mailboxes and those of the Home Office OU.
        The Home Office OU can see EVERYONE on the account.

.NOTES
    Author: Rio Sinnott (rsinnott@intermedia.com), Eric Campbell (ecampbell@intermedia.com)
    Last Updated: 2025-5-12
#>

[Diagnostics.CodeAnalysis.SuppressMessageAttribute(""PSUseSupportsShouldProcess"", """", Justification = ""Ignored."")]
[CmdletBinding()]
Param (
    [Parameter(Mandatory = $false)]
    [Switch] $Force,

    [Parameter(Mandatory = $false)]
    [Switch] $WhatIf
)

#region Initialize Variables

# specifies the module affiliated with this task
[String] $moduleName = ""Update-GALSegmentation""

# path to ModuleName's module file
[String] $modulePath = Join-Path -Path $PSScriptRoot -ChildPath (""{0}.psd1"" -f $moduleName)

# script name for logging
[String] $scriptName = ($MyInvocation.MyCommand.Name).Split('.')[0]

# Specifies the amount (in days) to retain logs.
[Int32] $logRetentionDays = 28

# set new values to preference variables
$Global:DebugPreference = ""Continue""
$Global:VerbosePreference = ""Continue""
$Global:InformationPreference = ""Continue""
$Global:ProgressPreference = ""SilentlyContinue""

# Specifies whether script is ran on a Jumpnet.
# This is used to prevent the script from exiting console.
[Bool] $isJumpnet = $ENV:COMPUTERNAME -match ""^JN""

# Specifies whether a fatal error has occurred - used to determine exit code.
[Bool] $fatalError = $false

# commands to import
[array] $exchangeCmds = @(
    'Get-AddressList', 'New-AddressList', 'Update-AddressList',
    'Get-GlobalAddressList', 'New-GlobalAddressList', 'Update-GlobalAddressList',
    'Get-OfflineAddressBook', 'New-OfflineAddressBook', 'Update-OfflineAddressBook',
    'Get-AddressBookPolicy', 'New-AddressBookPolicy',
    'Get-DistributionGroup', 'New-DistributionGroup', 'Set-DistributionGroup',
    'Get-DistributionGroupMember', 'Add-DistributionGroupMember',
    'Get-Recipient', 'Get-Mailbox', 'Set-Mailbox', 'Get-MailboxFolderPermission', 'Set-MailboxFolderPermission',
    'Add-MailboxFolderPermission', 'Get-OrganizationalUnit'
)

#endregion Initialize Variables

#region Prereq - Import Module and Initialize Logging
try
{
    Write-Information -MessageData (""Importing Module '{0}'."" -f $modulePath)
    Import-Module -Name $modulePath -Force -ErrorAction Stop

    Write-Information -MessageData ""Initialize Logging""

    [Hashtable] $logParam = Set-LogParams -ScriptName $scriptName -ErrorAction Stop
    [String] $logFolderPath = $logParam.LogFilePath | Split-Path -Parent -ErrorAction Stop
}
catch
{
    $caughtError = $_

    Write-Error -ErrorRecord $caughtError

    if ($isJumpnet)
    {
        return
    }

    exit 1
}
#endregion Prereq - Import Module and Initialize Logging

$stopwatch = [System.Diagnostics.Stopwatch]::new()

try
{
    $stopwatch.Start()

    Write-IMEvent -Event ""---------------------- Started new log session ----------------------"" -Type INF @logParam
    Write-IMEvent -Event ""Started by: $($env:USERDOMAIN)\$($env:USERNAME)"" -Type INF @logParam

    # get module private data
    [PSModuleInfo]$moduleInfo = Get-Module -Name $moduleName -ErrorAction Stop
    [hashtable[]]$accounts = @()

    if ($moduleInfo -and $moduleInfo.PrivateData -and $moduleInfo.PrivateData.ContainsKey('Accounts'))
    {
        $accounts = $moduleInfo.PrivateData.Accounts
    }
    else
    {
        Write-IMEvent -Event ""No Accounts defined in module PrivateData."" -Type ERR @logParam
        exit 1
    }

    # validate config entries
    $accounts | Test-ConfigEntry -LogParam $logParam

    if ($WhatIf)
    {
        Write-IMEvent -Event ""WhatIf mode enabled. No changes will be made."" -Type VRB @logParam
    }

    foreach ($entry in $accounts)
    {
        try
        {
            # set account specific variables
            [string]$accountID = $entry.Account
            [string]$platform = $entry.Platform
            [bool]$updatePerms = $entry.UpdatePermissions

            Write-IMEvent -Event (""Processing account: AccountID: {0}, Platform: {1}"" -f $accountID, $platform) -Type VRB @logParam

            # Get account info from SQL using account ID
            [System.Data.DataRow]$accountResults = Get-SQLAccount -accountID $accountID -platform $platform -LogParam $logParam

            if (-not $accountResults)
            {
                Write-IMEvent -Event (""There are no results for account: AccountID: {0}, Platform: {1}"" -f $accountID, $platform) -Type ERR @logParam
                continue
            }

            # set more account specific variables
            [string]$exchangeServer = $accountResults.MSExchange_server
            [string]$accountUsername = $accountResults.userName

            # Get OUs for account
            [object[]]$ouTable = Get-SQLOrgUnits -AccountID $accountID -LogParam $logParam

            if ($ouTable.Rows.Count -eq 0)
            {
                Write-IMEvent -Event (""No HP OUs returned for AccountID: {0}"" -f $accountID) -Type ERR @logParam
                continue
            }

            # filter test OUs
            [object[]]$allOUs = $ouTable.name | Where-Object { $_ -notlike ""*test*"" }

            # Connect to Exchange
            [string]$domain = ($exchangeServer.Split("".""))[1]
            Write-IMEvent -Event (""Connecting to Exchange Domain: {0}"" -f $domain) -Type VRB @logParam
            if (-not (Connect-ExchangePS -Domain $domain -Commands $exchangeCmds -logParam $logParam -Force))
            {
                Write-IMEvent -Event (""Unable to connect to Exchange Domain: {0}"" -f $domain) -Type ERR @logParam
                continue
            }

            # Get Domain Controller for directory binds
            [WTServer]$dcServer = Get-WTServer -Domain $domain -Definition ""DC"" |
                Where-Object { $_.ServerFqdn -notmatch ""PROV"" } |
                    Sort-Object { Get-Random } |
                        Where-Object { Test-Connection -ComputerName $_.ServerFqdn -Count 1 -Quiet } |
                            Select-Object -First 1

            if (-not $dcServer)
            {
                Write-IMEvent -Event (""No available DCs found for domain {0}"" -f $domain) -Type ERR @logParam
                continue
            }

            [string]$DC = $dcServer.ServerFqdn

            # Get Mailboxes to process
            try
            {
                [object[]]$mailboxes = Get-Mailbox -OrganizationalUnit $accountUsername -ResultSize Unlimited -ErrorAction Stop
            }
            catch
            {
                Write-IMEvent -Event (""Unable to get Mailboxes or no Mailboxes exist for account {0}. Error: {1}"" -f $accountUsername, $_.Exception.Message) -Type ERR @logParam
                continue
            }

            foreach ($HPOU in $AllOUs)
            {
                try
                {
                    Write-IMEvent -Event (""Creating or updating address lists for HP OU $($HPOU)"") -Type VRB @logParam
                    [hashtable] $addressListsSplat = @{
                        Account     = $accountUsername
                        HPOU        = $HPOU
                        DC          = $DC
                        LogParam    = $logParam
                        Force       = $Force
                        WhatIf      = $WhatIf
                        ErrorAction = ""Stop""
                    }
                    Add-AddressLists @addressListsSplat

                    Write-IMEvent -Event (""Creating or updating distribution lists for HP OU $($HPOU)"") -Type VRB @logParam
                    [hashtable] $distributionListsSplat = @{
                        Account        = $accountUsername
                        AccountId      = $accountID
                        HPOU           = $HPOU
                        ExchangeServer = $exchangeServer
                        LogParam       = $logParam
                        Force          = $Force
                        WhatIf         = $WhatIf
                        ErrorAction    = ""Stop""
                    }
                    Update-DistributionList @distributionListsSplat

                    Write-IMEvent -Event (""Updating Mailboxes for HP OU $($HPOU)"") -Type VRB @logParam
                    [hashtable] $mailboxesSplat = @{
                        Account           = $accountUsername
                        HPOU              = $HPOU
                        DC                = $DC
                        Mailboxes         = $Mailboxes
                        UpdatePermissions = $updatePerms
                        LogParam          = $logParam
                        Force             = $Force
                        WhatIf            = $WhatIf
                        ErrorAction       = ""Stop""
                    }
                    Update-Mailboxes @mailboxesSplat
                }
                catch
                {
                    Write-IMEvent -Event (""Unable to process HP OU {0}. Error: {1}"" -f $HPOU, $_.Exception.Message) -Type ERR @logParam
                    continue
                }
            }

            Write-IMEvent -Event (""Completed processing for AccountID: {0}"" -f $accountID) -Type INF @logParam
        }
        catch
        {
            $caughtError = $_
            $fatalError = $true
            Write-IMEvent -Event (""{0} - {1}"" -f $caughtError.ToString(), $caughtError.ScriptStackTrace) -Type ERR @logParam
        }
        finally
        {
            if ([ExSession]::IsActive())
            {
                Write-IMEvent -Event ""Removing Session for AccountID: $($accountID)"" -Type VRB @logParam
                [ExSession]::Dispose()
            }
        }

    }
}
catch
{
    $caughtError = $_
    $fatalError = $true
    Write-IMEvent -Event (""{0} - {1}"" -f $caughtError.ToString(), $caughtError.ScriptStackTrace) -Type ERR @logParam
}

finally
{
    $stopwatch.Stop()

    Write-IMEvent -Event (""Removing logs older than {0} days"" -f $logRetentionDays) -Type INF @logParam

    Remove-ImLog  -LogFolderPath $logfolderpath -RetentionTimeSpan ([timespan]::FromDays($logRetentionDays))

    Write-IMEvent -Event (""Script completed in {0} hours and {1} minutes"" -f $stopwatch.Elapsed.Hours, $stopwatch.Elapsed.Minutes) -Type VRB @logParam
    Write-IMEvent @logParam -Event ""---------------------- Completed log session ----------------------"" -Type INF

    if (-not $WhatIf -and -not $isJumpnet)
    {
        exit [Int32] $fatalError
    }
}

using namespace System.Management.Automation
using namespace System.Management.Automation.Runspaces

#region Classes
class ExSession
{
    # Specifies the Session/Module for current PSSession.
    # Only One Module/Session can be active at a time.
    static [PSsession] $Session
    static [PSModuleInfo] $Module

    # Specifies the WTServer affiliated with current PSSession
    static [Object] $WTServer

    # Specifies the States that are considered 'active' for PSSessions.
    # If a PSSession is not within one of these states the Session is marked as 'Inactive'.
    hidden static [String[]] $ValidStates = @(""Connecting"", ""Opened"", ""Opening"")

    ExSession ()
    {
    }

    static [Void] SetWTServer ([Object] $Server)
    {
        if ($Server.GetType().Name -ne ""WTServer"")
        {
            throw [System.ArgumentException]::new((""Server '{0}' is not a WTServer."" -f $Server))
        }

        [ExSession]::WTServer = $Server
    }

    static [Bool] IsActive ()
    {
        return [ExSession]::IsActive($false)
    }

    static [Bool] IsActive ([Bool] $CheckModule)
    {
        # Inactive - Session is not set and/or Domain is not set.
        if ($null -eq [ExSession]::Session -or $null -eq [ExSession]::WTServer)
        {
            return $false
        }

        # Inactive - Session is not in an active state.
        if ([ExSession]::Session.State -notin [ExSession]::ValidStates)
        {
            return $false
        }

        # Inactive - ComputerName's Domain does not match WTServer's Domain
        if ([ExSession]::Session.ComputerName.Split(""."")[1] -ne [ExSession]::WTServer.DomainName)
        {
            return $false
        }

        # PSSession is active. If CheckModule wasn't provided we don't need to check [ExSession]::Module.
        if (-not $CheckModule)
        {
            return $true
        }

        if ($null -eq [ExSession]::Module)
        {
            return $false
        }

        return [ExSession]::WTServer.ToString() -match [ExSession]::Module.Description
    }

    static [Void] Dispose ()
    {
        [ExSession]::WTServer = $null

        if ($null -ne [ExSession]::Session)
        {
            $computerName = [ExSession]::Session.ComputerName

            Get-PSSession -Id ([ExSession]::Session.Id) -ErrorAction SilentlyContinue |
                Remove-PSSession -WhatIf:$false -Confirm:$false -ErrorAction SilentlyContinue

            [ExSession]::Session = $null

            # Additional Cleanup required when specifying '-Global' within Connect-ExchangePS.
            Get-Module -All -Name ""tmp*"" -ErrorAction SilentlyContinue |
                Where-Object { $computerName -match $_.Description } |
                    Remove-Module -Force -ErrorAction SilentlyContinue -WhatIf:$false

            [ExSession]::Module = $null
        }

        if ($null -ne [ExSession]::Module)
        {
            Get-Module -Name ([ExSession]::Module.Name) -All -ErrorAction SilentlyContinue |
                Remove-Module -Force -WhatIf:$false -ErrorAction SilentlyContinue

            [ExSession]::Module = $null
        }
    }
}

#endregion Classes

#region Register Custom Types
# Expose custom types to user in session
$ExportableTypes = @(
    [ExSession]
)

# Only import if $ExportableTypes has something.
if ($ExportableTypes.Count -gt 0)
{
    # Get the Internal TypeAccelerators class to use its static methods.
    $TypeAcceleratorsClass = [PSObject].Assembly.GetType(
        ""System.Management.Automation.TypeAccelerators""
    )

    # Add types to TypeAccelerators
    # if it exists, skip it.
    $ExistingTypeAccelerators = $TypeAcceleratorsClass::Get
    foreach ($Type in $ExportableTypes)
    {
        if ($Type.FullName -notin $ExistingTypeAccelerators.Keys)
        {
            [Void] $TypeAcceleratorsClass::Add($Type.FullName, $Type)
        }
        else
        {
            continue
        }
    }
}
#endregion Register Custom Types

#region Functions

function Set-LogParams
{
    <#
.SYNOPSIS
    Creates and/or Retrieves current Log Parameters.
.DESCRIPTION
    Creates and/or Retrieves current Log Parameters.

    The Hashtable returned will be used for Write-ImEvent throughout the module.
.PARAMETER ScriptName
    Specifies the Name of the Script or function.
.EXAMPLE
    [Hashtable]$LogParams = Set-LogParams -ScriptName ""Update-JournalRuleNew""

    > $LogParams
        Name                           Value
        ----                           -----
        LogFilePath                    ....2024-01-14_Update-JournalRuleNew.log
        TaskName                       Update-JournalRuleNew
.INPUTS
    None
.OUTPUTS
    Hashtable
    Results of Set-LogParams will return as a Hashtable.
#>
    [CmdletBinding()]
    [OutputType([Hashtable])]
    Param (
        [Parameter(Mandatory = $false)]
        [ValidateNotNullorEmpty()]
        [String]$ScriptName = ""Update-GALSegmentation""
    )

    Begin
    {
        # This prevents an exception from being thrown if you run this function in Console/ISE.
        if (-not $PSScriptRoot)
        {
            [String]$LogFolderPath = Join-Path -Path $ENV:TEMP -ChildPath ""Logs""
        }
        else
        {
            [String]$LogFolderPath = Join-Path -Path $PSScriptRoot -ChildPath ""Logs""
        }

        [String]$CurrentLogName = (""{0}_{1}.log"" -f $(Get-Date -f yyyy-MM-dd), $ScriptName)
        [String]$LogFilePath = Join-Path -Path $LogFolderPath -ChildPath $CurrentLogName

        [Hashtable]$LogParams = @{
            TaskName    = $ScriptName
            LogFilePath = $LogFilePath
        }
    }
    Process
    {
        if (Test-Path -Path $LogFilePath -PathType Leaf)
        {
            return $LogParams
        }

        Write-Debug (""{0}:  Log file '{1}' does not exist. Creating."" -f $MyInvocation.MyCommand.Name, $LogFilePath)
        if (-not (Test-Path -Path $LogFolderPath -PathType Container))
        {
            Write-Debug (""{0}:  Creating directory '{1}'."" -f $MyInvocation.MyCommand.Name, $LogFolderPath)
            $null = New-Item -Path $LogFolderPath -ItemType Directory -ErrorAction Stop
        }

        if (-not (Test-Path -Path $LogFilePath -PathType Leaf))
        {
            Write-Debug (""{0}:  Creating log file '{1}'."" -f $MyInvocation.MyCommand.Name, $LogFilePath)
            $null = New-Item -Path $LogFilePath -ItemType File -ErrorAction Stop
        }

        return $LogParams
    }
}

function Connect-ExchangePS
{
    <#
.SYNOPSIS
    Creates/Imports Exchange Powershell session
.DESCRIPTION
    Creates/Imports Exchange Powershell session.

    Can be initiated using one of two parameter sets:

        Domain:
        Default option.  Provide the command with the -Domain parameter filled in with the domain you wish
        to connect to and it will make a query using ImWebTools module to find endpoints, then establish a
        remote Exchange powershell session to one of the servers.

        Server:
        Provide the command with one or more Exchange servers' FQDNs via the -Server parameter.  The
        command will iterate through the array of FQDNs provided until it is able to establish a remote Exchange
        powershell session to one of the servers.

    If successful, this Cmdlet will return a bool of 'False' or 'True' dependent on the success of the Cmdlet.
.PARAMETER Domain
    Specify the Intermedia domain number you want to establish a remote Exchange powershell session to.
.PARAMETER Server
    Specify the Exchange servers you want to connect to. Webtools will be queried to verify the provided Server(s) are marked
    as MBX Servers. If they are MBX Servers, this Cmdlet will iterate through the provided Server(s) until it is able to establish
    a remote Exchange powershell connection.
.PARAMETER CommandName
    Optional parameter which allows you to specify an array of commands to import selectively, rather than import all commands.

    NOTE: This parameter is ignored if Parameter -SkipImport is specified.
.PARAMETER SkipImport
    Specifies whether to skip importing the Exchange psSession. Importing an Exchange psSession gives access to Exchange Cmdlets within
    your current session. You'd typically use this for tasks that require one or two Exchange Cmdlets.

    In which case, you can just use Invoke-Command.

    NOTE: This overrides Parameter -CommandName.
.PARAMETER Force
    Specifies whether to force a new psSession connection.
.EXAMPLE
    Connect-ExchangePS -Domain 154 -SkipImport

    This example creates a powershell session on Exchange domain 154 and does NOT import the PSSession,
        which means you must use Invoke-Command to use Exchange Cmdlets.
.EXAMPLE
    $Servers = Get-WTServer -Domain 154 -Definition MBX -ExcludeServer PROV
    Connect-ExchangePS -Server $Servers

    This example obtains a list of Exchange Servers from Domain 154, which excludes PROV servers, then proceeds to
        attempt a PSSession connection.

    Upon connection, the PSSession will be imported, which allows use of Exchange Cmdlets without using Invoke-Command.
.EXAMPLE
    Connect-ExchangePS -Domain 157 -Force -SkipImport

    This example demonstrates how to force recreate a Exchange PowerShell session regardless if one is acive or not.

    The Cmdlet will NOT import the PSSession, which means you must use Invoke-Command to use Exchange Cmdlets.
.EXAMPLE
    Connect-ExchangePS -Domain 157 -CommandName ""Get-Mailbox""

    This example demonstrates how to import a specific Exchange Cmdlet rather than importing all Exchange Cmdlets.
.INPUTS
    None
.OUTPUTS
    System.Boolean

    This Cmdlet returns the status of Connecting to Exchange.
    - True: Successful connection
    - False: Failure
#>
    [CmdletBinding(DefaultParameterSetName = 'Domain')]
    [OutputType([Bool])]
    Param
    (
        [Parameter(Mandatory = $true, ParameterSetName = 'Domain')]
        [Object] $Domain,

        [Parameter(Mandatory = $true, ParameterSetName = 'Servers')]
        [Alias(""ExchangeServers"", ""Servers"")]
        [Object[]] $Server,

        [Parameter(Mandatory = $false)]
        [Switch] $SkipImport,

        [Parameter(Mandatory = $false)]
        [Alias(""Commands"", ""CommandNames"")]
        [String[]] $CommandName,

        [Parameter(Mandatory = $false)]
        [Switch] $Force,

        [Parameter(Mandatory = $false)]
        [Hashtable] $LogParam
    )

    # Skip - ExSession currently active.
    if (-not $Force -and [ExSession]::IsActive())
    {
        return $true
    }

    $ProgressPreference = ""SilentlyContinue""

    if (-not $LogParam)
    {
        $LogParam = Initialize-Log
    }

    #region Step 1 - Retrieve Exchange Servers
    [Hashtable] $getWTServersParams = @{
        Definition    = ""MBX""
        ErrorVariable = ""serverError""
    }

    if ($PSCmdlet.ParameterSetName -match ""Domain"")
    {
        [Object[]] $wtDomain = Get-WTDomain -Domain $Domain -ErrorVariable ""domainError""

        if ($wtDomain.Count -le 0)
        {
            [String] $errMsg = (""Webtools did not return results for Domain '{0}'."" -f $Domain)

            if ($domainError.Count -gt 0)
            {
                $errMsg = (""{0} Error: {1}"" -f $errMsg, $domainError[0].ToString())
            }

            Write-IMEvent -Event $errMsg -Type ERR @LogParam
            return $false
        }

        $getWTServersParams.Add(""Domain"", $wtDomain)
    }

    if ($PSCmdlet.ParameterSetName -match ""Server"")
    {
        $getWTServersParams.Add(""Server"", $Server)
    }

    [Object[]] $exServers = Get-WTServer @getWTServersParams

    # Error - No Servers
    if ($exServers.Count -le 0)
    {
        [String] $errMsg = ""Webtools did not return Exchange Servers.""

        if ($serverError.Count -gt 0)
        {
            $errMsg = (""{0} Error: {1}"" -f $errMsg, $serverError[0].ToString())
        }

        Write-IMEvent -Event $errMsg -Type ERR @LogParam
        return $false
    }

    [String[]] $uniqueDomains = $exServers.DomainName | Select-Object -Unique

    # Error - Can only connect to one Domain at a time.
    if ($uniqueDomains.Count -gt 1)
    {
        $errMsgSB = [System.Text.StringBuilder]::new()

        [Void] $errMsgSB.Append((""Expected only one Domain to be returned from Webtools but Webtools ""))
        [Void] $errMsgSB.Append((""returned the following Domains: {0}. "" -f ($uniqueDomains -join "", "")))
        [Void] $errMsgSB.AppendLine(""Please provide a singular Domain (e.g., EXCH157)."")

        Write-IMEvent -Event $errMsgSB.ToString() -Type ERR @LogParam
        return $false
    }

    $Domain = $uniqueDomains[0]
    #endregion Step 1 - Retrieve Exchange Servers

    #region Step 2 - Connect to Exchange
    # Shuffle exServers so we're not connecting to the same server each time.
    [Object[]] $randServers = $exServers | Get-Random -Count $exServers.Count

    # Error - randServers empty
    if ($randServers.Count -le 0)
    {
        $errMsgSB = [System.Text.StringBuilder]::new()
        [Void] $errMsgSB.Append(""An attempt was made to randomly sort Servers retrieved from Webtools "")
        [Void] $errMsgSB.Append(""but zero Servers were found. This should not occur and implies there's a "")
        [Void] $errMsgSB.AppendLine((""logic flaw within Cmdlet '{0}'."" -f $MyInvocation.MyCommand.Name))

        Write-IMEvent -Event $errMsgSB.ToString() -Type ERR @LogParam
        return $false
    }

    # Cleanup current values before adding new ones.
    [ExSession]::Dispose()

    ForEach ($exServer in $randServers)
    {
        # Dictates whether to cleanup during an error.
        [Bool] $hasError = $false

        try
        {
            Write-IMEvent -Event (""Attempting connection to {0}..."" -f $exServer) -Type DBG @LogParam

            $connectionUri = [System.UriBuilder]::new(""http"", $exServer.ToString(), 80, ""PowerShell"")

            # Specifies parameter splat for New-PSSession.
            [Hashtable] $newPSSessionParams = @{
                ConfigurationName = ""Microsoft.Exchange""
                ConnectionUri     = $connectionUri.Uri.AbsoluteUri
                ErrorAction       = ""Stop""
            }

            [ExSession]::Session = New-PSSession @newPSSessionParams
            [ExSession]::SetWTServer($exServer)

            Write-IMEvent -Event (""Exchange Powershell session to {0} successfully created."" -f $exServer) -Type DBG @LogParam

            if ($SkipImport)
            {
                break
            }

            # Specifies Parameter Splat for Import-PSSession
            [Hashtable] $importPSSessionParams = @{
                Session             = ([ExSession]::Session)
                AllowClobber        = $true
                DisableNameChecking = $true
                Verbose             = $false
                WarningAction       = ""SilentlyContinue""
                ErrorAction         = ""Stop""
            }

            if ($PSBoundParameters.ContainsKey(""CommandName""))
            {
                $importPSSessionParams.Add(""CommandName"", $CommandName)
            }

            Write-IMEvent -Event (""Attempting import for PSSession {0}..."" -f $exServer) -Type DBG @LogParam

            [ExSession]::Module = Import-PSSession @importPSSessionParams

            Write-IMEvent -Event (""Exchange PowerShell Session to {0} successfully imported."" -f $exServer) -Type DBG @LogParam

            [hashtable] $impoartParams = @{
                ModuleInfo          = ([ExSession]::Module)
                Global              = $true
                DisableNameChecking = $true
                Force               = $true
                Verbose             = $false
                WarningAction       = ""SilentlyContinue""
                ErrorAction         = ""Stop""
            }

            Write-IMEvent -Event ""Globally importing Exchange Cmdlets."" -Type DBG @LogParam

            Import-Module @impoartParams
            break
        }
        catch [System.Management.Automation.Remoting.PSRemotingTransportException]
        {
            $caughtError = $_
            $hasError = $true

            # ErrorCode of '5' indicates access denied.
            # ErrorCode of '1326' indicates invalid credentials.
            if ($caughtError.Exception.ErrorCode -eq 5 -or $caughtError.Exception.ErrorCode -eq 1326)
            {
                Write-IMEvent -Event (""Server: {0}. Error: {1}"" -f $exServer, $caughtError.ToString()) -Type ERR @LogParam
                break
            }

            Write-IMEvent -Event (""Skipping {0} and trying again. Error: {1}"" -f $exServer, $caughtError.ToString()) -Type WRN @LogParam
        }
        catch [System.ArgumentException]
        {
            $caughtError = $_
            $hasError = $true

            if ($caughtError.ToString() -match ""Get-Command"")
            {
                [String] $errMsg = (""One or many of the following Cmdlet(s) were not found: {0}"" -f ($CommandName -join "", ""))
            }
            else
            {
                [String] $errMsg = $caughtError.ToString()
            }

            Write-IMEvent -Event $errMsg -Type ERR @LogParam
            return $false
        }
        catch
        {
            $caughtError = $_
            $hasError = $true

            if ($null -eq [ExSession]::Session)
            {
                [String] $errMsg = (""Unable to establish remote powershell session to '{0}'. Error: {1}"" -f $exServer, $caughtError.ToString())
            }
            else
            {
                [String] $errMsg = (""Unable to import remote powershell session to '{0}'. Error: {1}"" -f $exServer, $caughtError.ToString())
            }

            Write-IMEvent -Event $errMsg -Type WRN @LogParam
        }
        finally
        {
            if ($hasError)
            {
                [ExSession]::Dispose()
            }
        }
    }
    #endregion Step 2 - Connect to Exchange

    # Error - PSSession Creation Failed.
    if ($null -eq [ExSession]::Session)
    {
        $errMsgSB = [System.Text.StringBuilder]::new()
        [Void] $errMsgSB.Append((""Could not establish remote powershell session in Domain {0}. "" -f $Domain))
        [Void] $errMsgSB.AppendLine(""Please check logs for more information."")

        Write-IMEvent -Event $errMsgSB.ToString() -Type ERR @LogParam
        return $false
    }

    # Error - Import Session and/or Module Failed.
    if (-not $SkipImport -and $null -eq [ExSession]::Module)
    {
        $errMsgSB = [System.Text.StringBuilder]::new()
        [Void] $errMsgSB.Append((""Could not import Exchange PowerShell Session/Module for Domain {0}. "" -f $Domain))
        [Void] $errMsgSB.AppendLine(""Please check logs for more information."")

        Write-IMEvent -Event $errMsgSB.ToString() -Type ERR @LogParam
        return $false
    }

    return [ExSession]::IsActive()
}

function Test-ConfigEntry
{
    <#
.SYNOPSIS
    Tests a single configuration entry for required fields and valid types.

.DESCRIPTION
    Ensures a hashtable contains the required keys for GAL segmentation:
    - Account (string)
    - Platform ('PLR' or 'SEH')
    - UpdatePermissions (boolean)

    Logs errors via Write-IMEvent if invalid, and throws.

.PARAMETER Entry
    A hashtable containing one account configuration block.

.PARAMETER LogParam
    Hashtable used for logging with Write-IMEvent.

.EXAMPLE
    $cfg.Accounts | ForEach-Object { Test-ConfigEntry -Entry $_ -LogParam $logParam }
#>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [hashtable] $Entry,

        [Parameter(Mandatory = $true)]
        [hashtable] $LogParam
    )

    process
    {
        [array]$requiredKeys = 'Account', 'Platform', 'UpdatePermissions'

        foreach ($key in $requiredKeys)
        {
            if (-not $Entry.ContainsKey($key))
            {
                $msg = ""Missing required key '$key' in config entry: $($Entry | Out-String)""
                Write-IMEvent -Event $msg -Type ERR @LogParam
                throw $msg
            }
        }

        if ($Entry.UpdatePermissions -isnot [bool])
        {
            $msg = ""UpdatePermissions must be a boolean. Got: $($Entry.UpdatePermissions.GetType().Name)""
            Write-IMEvent -Event $msg -Type ERR @LogParam
            throw $msg
        }

        if ($Entry.Platform -notin @('PLR', 'SEH'))
        {
            $msg = ""Invalid Platform '$($Entry.Platform)'. Must be 'PLR' or 'SEH'.""
            Write-IMEvent -Event $msg -Type ERR @LogParam
            throw $msg
        }
    }
}

function Send-EmailNotification
{
    <#
.SYNOPSIS
    Sends an email notification using the standard SMTP relay.
.DESCRIPTION
    Sends an HTML-formatted email message to the specified recipient(s) via relay1.msoutlookonline.net.
    Logs an error with Write-IMEvent if the send operation fails.

.PARAMETER FromAddress
    Optional sender address. Defaults to ""$env:COMPUTERNAME@intermedia.com"".

.PARAMETER ToAddress
    The primary recipient email address.

.PARAMETER Subject
    The subject line of the email.

.PARAMETER BccAddress
    BCC recipient for audit or escalation purposes.

.PARAMETER Body
    The body of the email. Must be a valid HTML string.

.PARAMETER LogParam
    Hashtable containing TaskName and LogFilePath for structured logging.

.EXAMPLE
    Send-EmailNotification -ToAddress ""admin@intermedia.com"" -BccAddress ""psa@intermedia.com"" `
        -Subject ""Alert: Action Required"" -Body ""<h1>Check the logs.</h1>"" -LogParam $logParam

#>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [string] $FromAddress = ""$($env:COMPUTERNAME)@intermedia.com"",

        [Parameter(Mandatory = $true)]
        [string] $ToAddress,

        [Parameter(Mandatory = $true)]
        [string] $Subject,

        [Parameter(Mandatory = $true)]
        [string] $BccAddress,

        [Parameter(Mandatory = $true)]
        [string] $Body,

        [Parameter(Mandatory = $true)]
        [hashtable] $LogParam
    )

    $smtpServer = ""relay1.msoutlookonline.net""

    try
    {
        $mailMessage = [System.Net.Mail.MailMessage]::new($FromAddress, $ToAddress, $Subject, $Body)
        $mailMessage.IsBodyHtml = $true
        $mailMessage.Bcc.Add($BccAddress)

        $smtpClient = [System.Net.Mail.SmtpClient]::new($smtpServer)

        $smtpClient.Send($mailMessage)
        Write-IMEvent -Event ""Email notification sent to $ToAddress (BCC: $BccAddress)."" -Type INF @LogParam
    }
    catch
    {
        $errMsg = ""Unable to send email notification. $($_.Exception.Message)""
        Write-IMEvent -Event $errMsg -Type ERR @LogParam
    }
    finally
    {
        if ($null -ne $mailMessage) { $mailMessage.Dispose() }
        if ($null -ne $smtpClient) { $smtpClient.Dispose() }
    }
}

function Get-SQLAccount
{
    <#
.SYNOPSIS
    Retrieves the Exchange server FQDN and account username for a customer from DATAC.

.DESCRIPTION
    Looks up account metadata from DATAC's SQL databases to retrieve:
      - The FQDN of the associated Exchange server
      - The username (organizational unit) used to query mailboxes and apply Exchange configuration

    The query is executed against either MSExchangeHosting_PLR or MSExchangeHosting depending on the specified platform.
    This information is required to connect to the correct Exchange session and retrieve mailbox objects under the account.

.PARAMETER AccountID
    The 7-digit numeric account ID used to identify the customer. Example: 1234567.

.PARAMETER Platform
    The platform type for the account. Must be either 'PLR' or 'SEH'.

.PARAMETER LogParam
    A hashtable for structured logging (passed to Write-IMEvent).

.EXAMPLE
    Import-Module .\Update-GALSegmentation.psd1

    $logParam = Set-LogParams -ScriptName ""GALSegmentation"" -ErrorAction Stop

    $accountId = 1234567
    $platform = ""PLR""

    $result = Get-SQLAccount -AccountID $accountId -Platform $platform -LogParam $logParam

    if ($result.Rows.Count -eq 0) {
        Write-Warning ""No result returned for AccountID $accountId""
    } else {
        $exchangeServer = $result.MSExchange_server
        $accountUsername = $result.userName
    }

    # This example demonstrates retrieving the Exchange server FQDN and user context
    # for a given customer account. The result is used to establish remote Exchange sessions.

.OUTPUTS
    [System.Data.DataTable] – Contains one row with MSExchange_server and userName columns.

#>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string] $AccountID,

        [Parameter(Mandatory = $true)]
        [ValidateSet(""PLR"", ""SEH"")]
        [string] $Platform,

        [Parameter(Mandatory = $true)]
        [hashtable] $LogParam
    )

    # build SQL query based on platform
    [string] $query = if ($Platform -eq ""PLR"")
    {
        (
            ""SELECT MSExchange_server, userName
             FROM MSExchangeHosting_PLR.dbo.Accounts
             WHERE accountID = '{0}'"" -f $AccountID.Trim()
        )
    }
    else
    {
        (
            ""SELECT MSEa.MSExchange_server, MSEa.userName
             FROM MSExchangeHosting.dbo.Accounts MSEa
             LEFT JOIN MSExchangeHosting_dedicated.dbo.Accounts MSEdA ON MSEa.accountId = MSEdA.accountId
             WHERE MSEa.accountID = '{0}'"" -f $AccountID.Trim()
        )
    }

    $connectionString = ""Server=DATAC.wh.intermedia.net;Integrated Security=true""

    # execute SQL query
    try
    {
        $sqlConnection = [System.Data.SqlClient.SqlConnection]::new($connectionString)
        $sqlCommand = $sqlConnection.CreateCommand()
        $sqlCommand.CommandTimeout = 1200
        $sqlCommand.CommandText = $query

        $adapter = [System.Data.SqlClient.SqlDataAdapter]::new($sqlCommand)
        $dataTable = [System.Data.DataTable]::new()

        $null = $adapter.Fill($dataTable)

        Write-IMEvent -Event (""SQL query succeeded for account {0} on platform {1}."" -f $AccountID, $Platform) -Type VRB @LogParam

        return $dataTable
    }
    catch
    {
        $msg = (""SQL error while querying account {0} on {1}: {2}"" -f $AccountID, $Platform, $_.Exception.Message)
        Write-IMEvent -Event $msg -Type ERR @LogParam
        throw $msg
    }
    finally
    {
        if ($sqlConnection)
        {
            $sqlConnection.Close()
        }
    }
}

function Get-SQLOrgUnits
{
    <#
.SYNOPSIS
    Retrieves a list of Organizational Units (OUs) for the specified account from DATAC.

.DESCRIPTION
    Executes a SQL query against IntermediaHosting.dbo.AccountOrgUnits on the DATAC server to retrieve all
    HostPilot Organizational Unit names associated with the given account ID. This is required to process
    each OU for address list, GAL, and mailbox policy assignments.

.PARAMETER AccountID
    The 7-digit account ID for the customer (e.g., 1234567).

.PARAMETER LogParam
    A hashtable used to pass logging context to Write-IMEvent.

.EXAMPLE
    Import-Module .\Update-GALSegmentation.psd1

    $logParam = Set-LogParams -ScriptName ""GALSegmentation"" -ErrorAction Stop

    $accountId = 1234567
    $ouTable = Get-SQLOrgUnits -AccountID $accountId -LogParam $logParam

    if ($ouTable.Rows.Count -eq 0) {
        Write-Warning ""No OUs returned for account $accountId""
    } else {
        $ouNames = $ouTable.name | Where-Object { $_ -notlike ""*test*"" }
        $ouNames
    }

    # This example shows how to retrieve OUs for an account and filter out test OUs.
    # The $logParam ensures all SQL and result checks are logged.
#>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string] $AccountID,

        [Parameter(Mandatory = $true)]
        [hashtable] $LogParam
    )

    [string] $query = (
        ""SELECT name
     FROM IntermediaHosting.dbo.AccountOrgUnits
     WHERE accountID = '{0}'"" -f $AccountID.Trim()
    )

    $connectionString = ""Server=DATAC.wh.intermedia.net;Integrated Security=true""

    try
    {
        $sqlConnection = [System.Data.SqlClient.SqlConnection]::new($connectionString)
        $sqlCommand = $sqlConnection.CreateCommand()
        $sqlCommand.CommandTimeout = 1200
        $sqlCommand.CommandText = $query

        $adapter = [System.Data.SqlClient.SqlDataAdapter]::new($sqlCommand)
        $dataTable = [System.Data.DataTable]::new()

        $null = $adapter.Fill($dataTable)

        Write-IMEvent -Event (""SQL query succeeded for Org Units on AccountID {0}."" -f $AccountID) -Type VRB @LogParam

        return $dataTable
    }
    catch
    {
        $msg = (""SQL error while querying Org Units for AccountID {0}: {1}"" -f $AccountID, $_.Exception.Message)
        Write-IMEvent -Event $msg -Type ERR @LogParam
        throw $msg
    }
    finally
    {
        if ($sqlConnection)
        {
            $sqlConnection.Close()
        }
    }
}

function Get-RecipientFilter
{
    <#
    .SYNOPSIS
        Generates a recipient filter string for Exchange address list objects.

    .DESCRIPTION
        Constructs a valid recipient filter string based on the account name, HostPilot OU (HPOU),
        and the type of Exchange object being created (Company Address List, Room List, or GAL).

        CID-3356 and RB-* OUs are handled with specific exceptions based on control panel requirements.

    .PARAMETER Account
        The customer account name (e.g., 'CID-3356', 'BarryPlantGRP') used in filter logic.

    .PARAMETER HPOU
        The HostPilot OU name (e.g., 'Main Office', 'Home Office', 'RB-SX-254').

    .PARAMETER Type
        The object type for which the filter is being built. Accepted values: 'Company', 'Room', 'GAL'.

    .EXAMPLE
        $filter = Get-RecipientFilter -Account 'CID-3356' -HPOU 'RB-SX-254' -Type 'Company'

        # Returns a recipient filter allowing RB-SX-254 to see itself and Home Office (CID-3356-specific logic)

    .OUTPUTS
        [string] The generated recipient filter string.
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string] $Account,

        [Parameter(Mandatory = $true)]
        [string] $HPOU,

        [Parameter(Mandatory = $true)]
        [ValidateSet('Company', 'Room', 'GAL')]
        [string] $Type
    )

    [string] $custOU = ""*OrgUnit=$HPOU*""

    # CID-3356-specific logic
    if ($Account -eq 'CID-3356')
    {
        if ($HPOU -like 'Home Office')
        {
            return ""CustomAttribute15 -eq 'CID-3356' -and Alias -ne `$null""
        }

        if ($HPOU -like 'RB*')
        {
            switch ($Type)
            {
                'Room'
                {
                    return ""CustomAttribute15 -eq 'CID-3356' -and CustomAttribute7 -ne `$null -and RecipientType -eq 'UserMailbox' -and ResourceMetaData -like 'ResourceType:*' -and ResourceSearchProperties -ne `$null""
                }
                default
                {
                    # Shared filter logic for 'Company' and 'GAL' object types
                    return ""(CustomAttribute15 -eq '$Account' -and (CustomAttribute1 -like '$custOU' -or CustomAttribute1 -like '*OrgUnit=Home Office*')) -and Alias -ne `$null""
                }
            }
        }

        if ($Type -eq 'Room')
        {
            return ""CustomAttribute15 -eq 'CID-3356' -and RecipientType -eq 'UserMailbox' -and ResourceMetaData -like 'ResourceType:*' -and ResourceSearchProperties -ne `$null""
        }
    }

    # Default for all other accounts
    switch ($Type)
    {
        'Room'
        {
            return ""CustomAttribute15 -eq '$Account' -and CustomAttribute1 -like '$custOU' -and RecipientType -eq 'UserMailbox' -and ResourceMetaData -like 'ResourceType:*' -and ResourceSearchProperties -ne `$null""
        }
        default
        {
            # Shared filter logic for 'Company' and 'GAL' object types
            return ""CustomAttribute15 -eq '$Account' -and CustomAttribute1 -like '$custOU' -and Alias -ne `$null""
        }
    }
}

function Add-AddressLists
{
    <#
.SYNOPSIS
    Creates or updates address lists, GALs, room lists, OABs, and ABPs for a customer’s Organizational Unit.

.DESCRIPTION
    Ensures that a customer OU has the necessary address list infrastructure:
    - Company Address List
    - All Rooms Address List
    - Global Address List (GAL)
    - Offline Address Book (OAB)
    - Address Book Policy (ABP)

    For each of the above:
    - If the object doesn't exist, it is created with the appropriate recipient filter.
    - If it does exist, it is updated in-place.

    CID-3356 account has custom recipient filter logic. This Cmdlet is intended to be called per-OU
    during GAL segmentation and Exchange policy setup workflows.

.PARAMETER Account
    The customer account username (e.g., 'CID-3356' or 'BarryPlantGRP') used in recipient filters.

.PARAMETER HPOU
    The HostPilot Organizational Unit name (e.g., ""Home Office"", ""BARRY PLANT DANDENONG"").

.PARAMETER DC
    The FQDN of a writable domain controller to bind Exchange operations to.

.PARAMETER LogParam
    A hashtable containing the TaskName and LogFilePath for Write-IMEvent.

.EXAMPLE
    Import-Module .\Update-GALSegmentation.psd1

    $logParam = Set-LogParams -ScriptName ""GALSegmentation"" -ErrorAction Stop

    # Get the account metadata from DATAC
    $accountId = 1426905
    $accountResult = Get-SQLAccount -AccountID $accountId -Platform ""SEH"" -LogParam $logParam
    $accountUsername = $accountResult.userName
    $dc = ""DC082-CO-1.EXCH082.SERVERPOD.NET""  # From Get-WTServer or known good DC

    # Create address lists for the 'Main Office' OU
    Add-AddressLists -Account $accountUsername -HPOU ""Main Office"" -DC $dc -LogParam $logParam

    # This example sets up the Company Address List, Room List, GAL, OAB, and ABP
    # for the 'Main Office' OU under a standard SEH platform account.

.EXAMPLE
    Import-Module .\Update-GALSegmentation.psd1

    $logParam = Set-LogParams -ScriptName ""GALSegmentation"" -ErrorAction Stop

    $account = ""CID-3356""
    $hpou = ""Home Office""
    $dc = ""DC125-CO-1.EXCH125.SERVERPOD.NET""

    Add-AddressLists -Account $account -HPOU $hpou -DC $dc -LogParam $logParam

    # This creates or updates the full address list infrastructure for the 'Home Office' OU under account CID-3356.
    # The recipient filters will allow users in this OU to see all users on the account.
#>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = ""High"")]
    param (
        [Parameter(Mandatory = $true)][string]   $Account,
        [Parameter(Mandatory = $true)][string]   $HPOU,
        [Parameter(Mandatory = $true)][string]   $DC,
        [Parameter(Mandatory = $true)][hashtable] $LogParam,
        [Parameter(Mandatory = $false)][switch] $Force
    )

    [bool] $whatif = $WhatIfPreference

    if ($Force -and $ConfirmPreference -ne 'Low' -and -not $whatif)
    {
        $ConfirmPreference = 'None'
    }

    [string] $Name = $HPOU -replace "" "", ""_""
    [string] $Room = ""${Name}_AllRooms""

    # check for Company Address List
    try
    {
        [object]$AddressList = Get-AddressList -Identity $Name -DomainController $DC -ErrorAction Stop
    }
    catch
    {
        Write-IMEvent -Event (""No Company Address List found for {0}."" -f $HPOU) -Type VRB @LogParam
        $AddressList = $null
    }

    # if no Company Address List, create one
    if (-not $AddressList)
    {
        [string]$RecipientFilter = Get-RecipientFilter -Account $Account -HPOU $HPOU -Type 'Company'

        try
        {
            if ($PSCmdlet.ShouldProcess($Name, ""Create Company Address List""))
            {
                Write-IMEvent -Event (""Creating Company Address List for {0}."" -f $HPOU) -Type VRB @LogParam
                [hashtable] $CALParams = @{
                    Name             = $Name
                    DomainController = $DC
                    DisplayName      = ""Company Address List""
                    RecipientFilter  = $RecipientFilter
                    ErrorAction      = 'Stop'
                }

                New-AddressList @CALParams

                $maxRetries = 3
                $delaySeconds = 10
                $AddressList = $null

                for ($i = 1; $i -le $maxRetries; $i++)
                {
                    try
                    {
                        $AddressList = Get-AddressList -Identity $Name -DomainController $DC -ErrorAction Stop
                        break
                    }
                    catch
                    {
                        Write-IMEvent -Event (""Retry {0} - Unable to retrieve Company Address List for {1} - {2}."" -f $i, $HPOU, $_.Exception.Message) -Type WRN @LogParam
                        Start-Sleep -Seconds $delaySeconds
                    }
                }

                if (-not $AddressList)
                {
                    Write-IMEvent -Event (""Failed to confirm creation of Company Address List for {0} after {1} attempts."" -f $HPOU, $maxRetries) -Type ERR @LogParam
                }
            }
        }
        catch
        {
            Write-IMEvent -Event (""Unable to create Company Address List for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }
    else
    {
        Write-IMEvent -Event (""Company Address List exists for {0}, updating."" -f $HPOU) -Type VRB @LogParam
        try
        {
            Get-AddressList -Identity $Name | Update-AddressList
        }
        catch
        {
            Write-IMEvent -Event (""Unable to update Company Address List for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }

    # check for Room List
    try
    {
        $RoomList = Get-AddressList -Identity $Room -DomainController $DC -ErrorAction Stop
    }
    catch
    {
        Write-IMEvent -Event (""No Room List found for {0}."" -f $HPOU) -Type VRB @LogParam
        $RoomList = $null
    }

    # if no Room List, create one
    if (-not $RoomList)
    {
        $RecipientFilter = Get-RecipientFilter -Account $Account -HPOU $HPOU -Type 'Room'

        try
        {
            if ($PSCmdlet.ShouldProcess($Room, ""Create Room List""))
            {
                Write-IMEvent -Event (""Creating Room List for {0}."" -f $HPOU) -Type VRB @LogParam
                [hashtable] $RoomParams = @{
                    Name             = $Room
                    DomainController = $DC
                    DisplayName      = ""All Rooms Address List""
                    RecipientFilter  = $RecipientFilter
                    ErrorAction      = 'Stop'
                }

                New-AddressList @RoomParams

                $maxRetries = 3
                $delaySeconds = 10
                $RoomList = $null

                for ($i = 1; $i -le $maxRetries; $i++)
                {
                    try
                    {
                        $RoomList = Get-AddressList -Identity $Room -DomainController $DC -ErrorAction Stop
                        break
                    }
                    catch
                    {
                        Write-IMEvent -Event (""Retry {0} - Unable to retrieve Room List for {1} - {2}."" -f $i, $HPOU, $_.Exception.Message) -Type WRN @LogParam
                        Start-Sleep -Seconds $delaySeconds
                    }
                }
            }
        }
        catch
        {
            Write-IMEvent -Event (""Unable to create Room List for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }
    else # if Room List exists, log and update
    {
        Write-IMEvent -Event (""Room List exists for {0}, updating."" -f $HPOU) -Type VRB @LogParam
        try
        {
            Get-AddressList -Identity $Room | Update-AddressList
        }
        catch
        {
            Write-IMEvent -Event (""Unable to update Room List for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }

    # check for Global Address List
    try
    {
        $GAL = Get-GlobalAddressList -Identity $Name -DomainController $DC -ErrorAction Stop
    }
    catch
    {
        Write-IMEvent -Event (""No GAL found for {0}."" -f $HPOU) -Type VRB @LogParam
        $GAL = $null
    }

    # if no GAL, create one
    if (-not $GAL)
    {
        $RecipientFilter = Get-RecipientFilter -Account $Account -HPOU $HPOU -Type 'GAL'

        try
        {
            if ($PSCmdlet.ShouldProcess($Name, ""Create GAL""))
            {
                Write-IMEvent -Event (""Creating GAL for {0}."" -f $HPOU) -Type VRB @LogParam
                [hashtable] $GALParams = @{
                    Name             = $Name
                    DomainController = $DC
                    RecipientFilter  = $RecipientFilter
                    ErrorAction      = 'Stop'
                }

                New-GlobalAddressList @GALParams

                $maxRetries = 3
                $delaySeconds = 10
                $GAL = $null

                for ($i = 1; $i -le $maxRetries; $i++)
                {
                    try
                    {
                        $GAL = Get-GlobalAddressList -Identity $Name -DomainController $DC -ErrorAction Stop
                        break
                    }
                    catch
                    {
                        Write-IMEvent -Event (""Retry {0} - Unable to retrieve GAL for {1} - {2}."" -f $i, $HPOU, $_.Exception.Message) -Type WRN @LogParam
                        Start-Sleep -Seconds $delaySeconds
                    }
                }
            }
        }
        catch
        {
            Write-IMEvent -Event (""Unable to create GAL for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }
    else # if GAL exists, log and update
    {
        Write-IMEvent -Event (""GAL exists for {0}, updating."" -f $HPOU) -Type VRB @LogParam
        try
        {
            Get-GlobalAddressList -Identity $Name | Update-GlobalAddressList
        }
        catch
        {
            Write-IMEvent -Event (""Unable to update GAL for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }

    # check for Offline Address Book
    try
    {
        $OAB = Get-OfflineAddressBook -Identity $Name -DomainController $DC -ErrorAction Stop
    }
    catch
    {
        Write-IMEvent -Event (""No OAB found for {0}."" -f $HPOU) -Type VRB @LogParam
        $OAB = $null
    }

    # if no OAB, create one
    if (-not $OAB)
    {
        try
        {

            if ($PSCmdlet.ShouldProcess($Name, ""Create OAB""))
            {
                $AddressList = @(Get-AddressList -Identity $Name -DomainController $DC)
                Write-IMEvent -Event (""Creating OAB for {0}."" -f $HPOU) -Type VRB @LogParam
                [hashtable] $OABParams = @{
                    Name                         = $Name
                    DomainController             = $DC
                    AddressLists                 = $AddressList.DistinguishedName
                    GlobalWebDistributionEnabled = $true
                    ErrorAction                  = ""Stop""
                }

                New-OfflineAddressBook @OABParams

                $maxRetries = 3
                $delaySeconds = 10
                $OAB = $null

                for ($i = 1; $i -le $maxRetries; $i++)
                {
                    try
                    {
                        $OAB = Get-OfflineAddressBook -Identity $Name -DomainController $DC -ErrorAction Stop
                        break
                    }
                    catch
                    {
                        Write-IMEvent -Event (""Retry {0} - Unable to retrieve OAB for {1} - {2}."" -f $i, $HPOU, $_.Exception.Message) -Type WRN @LogParam
                        Start-Sleep -Seconds $delaySeconds
                    }
                }
            }
        }
        catch
        {
            Write-IMEvent -Event (""Unable to create OAB for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }
    else # if OAB exists, log and update
    {
        Write-IMEvent -Event (""OAB exists for {0}, updating."" -f $HPOU) -Type VRB @LogParam
        try
        {
            Get-OfflineAddressBook -Identity $Name | Update-OfflineAddressBook
        }
        catch
        {
            Write-IMEvent -Event (""Unable to update OAB for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }

    # check for Address Book Policy
    try
    {
        $ABP = Get-AddressBookPolicy -Identity $Name -DomainController $DC -ErrorAction Stop
    }
    catch
    {
        Write-IMEvent -Event (""No ABP found for {0}."" -f $HPOU) -Type VRB @LogParam
        $ABP = $null
    }

    # if no ABP, create one
    if (-not $ABP)
    {
        try
        {
            if ($PSCmdlet.ShouldProcess($Name, ""Create ABP""))
            {
                $AddressList = Get-AddressList -Identity $Name -DomainController $DC
                $GAL = Get-GlobalAddressList -Identity $Name -DomainController $DC
                $RoomList = Get-AddressList -Identity $Room -DomainController $DC
                $OAB = Get-OfflineAddressBook -Identity $Name -DomainController $DC

                [hashtable] $ABPParams = @{
                    Name               = $Name
                    DomainController   = $DC
                    AddressLists       = $AddressList.DistinguishedName
                    GlobalAddressList  = $GAL.DistinguishedName
                    RoomList           = $RoomList.DistinguishedName
                    OfflineAddressBook = $OAB.DistinguishedName
                }

                New-AddressBookPolicy @ABPParams
            }

        }
        catch
        {
            Write-IMEvent -Event (""Unable to create ABP for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        }
    }
    else # if ABP exists, log
    {
        Write-IMEvent -Event (""ABP exists for {0}."" -f $HPOU) -Type VRB @LogParam
    }
}

function Update-DistributionList
{
    <#
.SYNOPSIS
    Creates or updates a distribution list (DL) for a HostPilot OU.

.DESCRIPTION
    Ensures that a distribution list exists for a given Organizational Unit in the customer's account.
    - DL name is generated using a standard naming convention
    - If the DL does not exist, it is created with proper attributes.
    - If the DL does exist, it is left unchanged.
    - On creation, the DL is updated via ADSI to:
        - Hide it from address lists
        - Set hosting-related attributes for HostPilot
    - CustomAttribute7 is also applied.

    This function is called per-OU during address book segmentation workflows. It assumes that an Exchange session is already connected.

.PARAMETER Account
    The account username (e.g., 'BarryPlantGRP', 'CID-3356'). Used in DL naming and attribute tagging.

.PARAMETER AccountID
    The numeric account ID (e.g., 1234567). Used in downstream logic and for correlation.

.PARAMETER HPOU
    The HostPilot Organizational Unit name (e.g., ""BARRY PLANT KEYSBOROUGH"", ""Main Office"").

.PARAMETER ExchangeServer
    The Exchange server FQDN used to resolve the originating DC for ADSI operations.

.PARAMETER LogParam
    A hashtable containing logging context used by Write-IMEvent.

.EXAMPLE
    Import-Module .\Update-GALSegmentation.psd1

    $logParam = Set-LogParams -ScriptName ""GALSegmentation"" -ErrorAction Stop

    $accountId = 1426905
    $platform = ""SEH""
    $accountResult = Get-SQLAccount -AccountID $accountId -Platform $platform -LogParam $logParam
    $accountUsername = $accountResult.userName

    $exchangeServer = ""mbx082-w1-co-1.exch082.serverpod.net""
    $ou = ""Main Office""

    Update-DistributionList -Account $accountUsername -AccountID $accountId -HPOU $ou -ExchangeServer $exchangeServer -LogParam $logParam

    # This creates or verifies the DL for 'Main Office' under the given account.
    # If the DL doesn't exist, it is created, hidden from address lists, and tagged with HostPilot attributes.

#>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = ""High"")]
    param (
        [Parameter(Mandatory = $true)][string]   $Account,
        [Parameter(Mandatory = $true)][string]   $AccountID,
        [Parameter(Mandatory = $true)][string]   $HPOU,
        [Parameter(Mandatory = $true)][string]   $ExchangeServer,
        [Parameter(Mandatory = $true)][hashtable] $LogParam,
        [Parameter(Mandatory = $false)][switch]  $Force
    )

    [bool] $whatif = $WhatIfPreference

    if ($Force -and $ConfirmPreference -ne 'Low' -and -not $whatif)
    {
        $ConfirmPreference = 'None'
    }

    $HostingOU = Get-OrganizationalUnit -Identity $Account

    # Generate DL name
    [string] $DLName = ""HPOrg_"" + ($HPOU -replace "" "", ""_"")


    # Global DL conflict check
    $existingRecipient = Get-Recipient -Identity $DLName -ErrorAction SilentlyContinue

    if ($existingRecipient)
    {
        if ($existingRecipient.CustomAttribute15 -eq $Account)
        {
            Write-IMEvent -Event (""DL {0} already exists for {1} (matched on CustomAttribute15), skipping creation."" -f $DLName, $HPOU) -Type VRB @LogParam
            return
        }
        else
        {
            $originalDLName = $DLName
            $DLName = ""${DLName}_${Account}""
            Write-IMEvent -Event (""DL name {0} already exists for another account. Using fallback name {1} for {2}."" -f $originalDLName, $DLName, $HPOU) -Type WRN @LogParam
        }
    }

    # Create DL
    $DLAddress = ""${DLName}@${Account}.serverdata.net""
    $CreateDLParams = @{
        Name               = $DLName
        SamAccountName     = $DLName
        OrganizationalUnit = $HostingOU.Name
        Type               = 'Security'
        PrimarySmtpAddress = $DLAddress
        ErrorAction        = 'Stop'
    }

    try
    {
        if ($PSCmdlet.ShouldProcess(""DL $DLName in $HPOU"", ""Create""))
        {
            New-DistributionGroup @CreateDLParams
            Write-IMEvent -Event (""DL {0} created for {1}."" -f $DLName, $HPOU) -Type INF @LogParam

            # validate DL
            $DL = $null
            $maxRetries = 3
            $delaySeconds = 10

            for ($i = 1; $i -le $maxRetries; $i++)
            {
                try
                {
                    $DL = Get-DistributionGroup -Identity $DLName -OrganizationalUnit $Account -ErrorAction Stop
                    break
                }
                catch
                {
                    Write-IMEvent -Event (""Attempt {0} - Unable to retrieve DL for {1} - {2}."" -f $i, $HPOU, $_.Exception.Message) -Type WRN @LogParam
                    Start-Sleep -Seconds $delaySeconds
                }
            }

            if (-not $DL)
            {
                Write-IMEvent -Event ""DL retrieval failed after $maxRetries attempts for $HPOU. Aborting DL configuration."" -Type ERR @LogParam
                Send-EmailNotification -ToAddress ""PSA@intermedia.com"" `
                    -Subject ""DL not created"" `
                    -Body ""DL $DLName for $HPOU could not be verified post-creation after $maxRetries attempts."" `
                    -BccAddress ""PSA@intermedia.com"" `
                    -LogParam $LogParam
                return
            }
        }
    }
    catch
    {
        Write-IMEvent -Event (""Unable to create DL for {0} - {1}."" -f $HPOU, $_.Exception.Message) -Type ERR @LogParam
        return
    }

    # set DL ADSI and custom attributes
    try
    {
        Write-IMEvent -Event ""Setting ADSI attributes for $DLName."" -Type VRB @LogParam
        if ($PSCmdlet.ShouldProcess(""$DLName"", ""Set Attributes""))
        {
            [adsi] $adsi = ""LDAP://${ExchangeServer}/$($DL.DistinguishedName)""
            $adsi.hostingextensionAttribute1 = ""hidden""
            $adsi.extensionAttribute15 = $Account
            $adsi.hostingObjectType = @('MSExchange2007DistributionList')
            $adsi.HostingOwner = @('MSExchange2007DistributionLists')
            $adsi.SetInfo()
            Write-IMEvent -Event (""ADSI attributes set for {0}."" -f $DLName) -Type VRB @LogParam
        }
    }
    catch
    {
        Write-IMEvent -Event (""Failed to set ADSI attributes for {0} - {1}."" -f $DLName, $_.Exception.Message) -Type ERR @LogParam
    }

    try
    {
        if ($PSCmdlet.ShouldProcess(""$DLName"", ""Update Distribution Group""))
        {
            Write-IMEvent -Event (""Applying HideFromAddressList and CustomAttribute7 for {0}."" -f $DLName) -Type VRB @LogParam
            Set-DistributionGroup -Identity $DLName -Alias ""${DLName}${Account}"" -HiddenFromAddressListsEnabled $true -CustomAttribute7 $HPOU
        }
    }
    catch
    {
        Write-IMEvent -Event (""Failed to apply HideFromAddressList and CustomAttribute7 for {0} - {1}."" -f $DLName, $_.Exception.Message) -Type ERR @LogParam
    }
}

function Set-MailboxCalendarPermissionState
{
    <#
.SYNOPSIS
    Ensures a mailbox calendar folder has the expected permission for a specific user.

.DESCRIPTION
    Checks if a specific user (e.g., 'Default', 'AllUsers@Account', or a DL name) has a permission entry
    on a mailbox calendar folder. If the entry is missing, it will be added. If it exists but has the
    wrong AccessRights, it will be updated. All actions are logged using Write-IMEvent.

.PARAMETER CalendarPath
    The path to the mailbox calendar folder (e.g., 'UserName:\Calendar').

.PARAMETER User
    The user or security principal to modify (e.g., 'Default', 'AllUsers@account', or DL name).

.PARAMETER Access
    The expected AccessRights value (e.g., 'None', 'AvailabilityOnly').

.PARAMETER LogParam
    A hashtable of logging parameters used by Write-IMEvent.

.EXAMPLE
    Set-MailboxCalendarPermissionState -CalendarPath 'jsmith:\Calendar' -User 'Default' -Access 'None' -LogParam $logParam

.EXAMPLE
    Set-MailboxCalendarPermissionState -CalendarPath 'jsmith:\Calendar' -User 'AllUsers@CID-3356' -Access 'None' -LogParam $logParam

.EXAMPLE
    Set-MailboxCalendarPermissionState -CalendarPath 'jsmith:\Calendar' -User 'HPOrg_Main_Office' -Access 'AvailabilityOnly' -LogParam $logParam
#>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'High')]
    param (
        [Parameter(Mandatory = $true)][string] $CalendarPath,
        [Parameter(Mandatory = $true)][string] $User,
        [Parameter(Mandatory = $true)][string] $Access,
        [Parameter(Mandatory = $true)][hashtable] $LogParam,
        [Parameter(Mandatory = $false)][switch] $Force
    )

    [bool] $whatif = $WhatIfPreference

    if ($Force -and $ConfirmPreference -ne 'Low' -and -not $whatif)
    {
        $ConfirmPreference = 'None'
    }

    try
    {
        $perm = Get-MailboxFolderPermission -Identity $CalendarPath -User $User -ErrorAction Stop
        if ($perm.AccessRights -ne $Access)
        {
            if ($PScmdlet.ShouldProcess(""$CalendarPath"", ""Set Permission for $User""))
            {
                Set-MailboxFolderPermission -Identity $CalendarPath -User $User -AccessRights $Access
                Write-IMEvent -Event (""Set {0} access to {1} on {2}."" -f $User, $Access, $CalendarPath) -Type INF @LogParam
            }
        }
    }
    catch
    {
        try
        {
            if ($PScmdlet.ShouldProcess(""$CalendarPath"", ""Add Permission for $User""))
            {
                Add-MailboxFolderPermission -Identity $CalendarPath -User $User -AccessRights $Access
                Write-IMEvent -Event (""Added {0} access to {1} on {2}."" -f $User, $Access, $CalendarPath) -Type INF @LogParam
            }
        }
        catch
        {
            Write-IMEvent -Event (""Failed to add {0} access to {1} on {2} - {3}."" -f $User, $Access, $CalendarPath, $_.Exception.Message) -Type ERR @LogParam
        }
    }
}

function Update-Mailboxes
{
    <#
.SYNOPSIS
    Applies address book policy, DL membership, and calendar permissions to mailboxes in a HostPilot OU.

.DESCRIPTION
    This function performs mailbox-level configuration for a specific Organizational Unit:
    - Assigns the Address Book Policy (ABP) if it's not already set
    - Applies CustomAttribute7 with the OU name
    - Adds the mailbox to the correct distribution list
    - Optionally applies calendar permissions:
        - Default → None
        - AllUsers@$Account → None
        - DL → AvailabilityOnly

    This function assumes:
    - A remote Exchange session is already connected
    - The DL for the OU already exists
    - The list of mailboxes is pre-fetched for the full account

.PARAMETER Account
    The account username (e.g., 'CID-3356' or 'BarryPlantGRP') used in DL and calendar targeting.

.PARAMETER HPOU
    The Organizational Unit to target (e.g., 'Home Office', 'Main Office', or a Barry Plant branch name).

.PARAMETER DC
    A writable domain controller FQDN, used for ABP lookups.

.PARAMETER UpdatePermissions
    If true, calendar permissions will be adjusted. If false, only ABP and DL operations are performed.

.PARAMETER Mailboxes
    A pre-fetched list of mailbox objects from `Get-Mailbox -OrganizationalUnit $accountUsername`.

.PARAMETER LogParam
    A hashtable for structured logging via Write-IMEvent.

.EXAMPLE
    Import-Module .\Update-GALSegmentation.psd1

    $logParam = Set-LogParams -ScriptName ""GALSegmentation"" -ErrorAction Stop

    $accountId = 1426905
    $platform = ""SEH""
    $accountResult = Get-SQLAccount -AccountID $accountId -Platform $platform -LogParam $logParam
    $accountUsername = $accountResult.userName
    $mailboxes = Get-Mailbox -OrganizationalUnit $accountUsername -ResultSize Unlimited
    $dc = ""DC082-CO-1.EXCH082.SERVERPOD.NET""


    Update-Mailboxes -Account $accountUsername -HPOU ""Main Office"" -DC $dc -Mailboxes $mailboxes -UpdatePermissions $true -LogParam $logParam

    # This example updates mailboxes in 'Main Office' for a standard account:
    # - Applies ABP if needed
    # - Adds to DL
    # - Sets calendar permissions for Default, AllUsers, and DL

#>
    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = ""High"")]
    param (
        [Parameter(Mandatory = $true)][string]     $Account,
        [Parameter(Mandatory = $true)][string]     $HPOU,
        [Parameter(Mandatory = $true)][string]     $DC,
        [Parameter(Mandatory = $true)][bool]       $UpdatePermissions,
        [Parameter(Mandatory = $true)][array[]]    $Mailboxes,
        [Parameter(Mandatory = $true)][hashtable]  $LogParam,
        [Parameter(Mandatory = $false)][switch]    $Force
    )

    [bool] $whatif = $WhatIfPreference

    if ($Force -and $ConfirmPreference -ne 'Low' -and -not $whatif)
    {
        $ConfirmPreference = 'None'
    }

    # TOP-LEVEL WhatIf guard
    $topTarget = ""Update all mailboxes in OU '$HPOU'""
    if (-not $PSCmdlet.ShouldProcess($topTarget, 'Execute'))
    {
        return
    }


    [string] $ABPName = $HPOU -replace "" "", ""_""
    Write-IMEvent -Event (""Looking up Address Book Policy {0}."" -f $ABPName) -Type VRB @LogParam

    # ABP lookup
    [object] $ABP = Get-AddressBookPolicy -Identity $ABPName -DomainController $DC -ErrorAction SilentlyContinue
    if (-not $ABP)
    {
        Write-IMEvent -Event (""ABP {0} not found for {1}."" -f $ABPName, $HPOU) -Type ERR @LogParam
        return
    }

    # Mailbox filtering for HP OU
    [object]$OUMailboxes = $Mailboxes | Where-Object { $_.CustomAttribute1 -match [regex]::Escape($HPOU) }

    if (-not $OUMailboxes)
    {
        Write-IMEvent -Event (""No mailboxes found in OU {0}."" -f $HPOU) -Type VRB @LogParam
        return
    }

    # Generate DL name
    $DLName = ""HPOrg_"" + ($HPOU -replace "" "", ""_"")

    foreach ($Mailbox in $OUMailboxes)
    {

        # Now calculate if the mailbox actually needs an ABP update
        $NeedsAbpUpdate = (
            $Mailbox.AddressBookPolicy -ne $ABP.Identity -or
            $Mailbox.CustomAttribute7 -ne $HPOU
        )

        if ($NeedsAbpUpdate)
        {
            Write-IMEvent -Event (""Updating ABP and CustomAttribute7 for mailbox {0}."" -f $Mailbox.UserPrincipalName) -Type VRB @LogParam
            try
            {
                if ($PSCmdlet.ShouldProcess(""Mailbox $($Mailbox.UserPrincipalName)"", ""Update ABP and CustomAttribute7""))
                {
                    Set-Mailbox -Identity $Mailbox.Identity -AddressBookPolicy $ABP.Identity -CustomAttribute7 $HPOU
                }
            }
            catch
            {
                Write-IMEvent -Event (""Unable to update ABP and CustomAttribute7 for mailbox {0}: {1}."" -f $Mailbox.UserPrincipalName, $_.Exception.Message) -Type ERR @LogParam
            }
        }

        try
        {
            # This is to prevent the script from breaking if the DL doesn't exist
            if (-not (Get-DistributionGroup -Identity $DLName -ErrorAction SilentlyContinue))
            {
                Write-IMEvent -Event (""DL {0} not found during mailbox processing for {1}, skipping membership assignment."" -f $DLName, $HPOU) -Type ERR @LogParam
                continue
            }

            $isMember = Get-DistributionGroupMember -Identity $DLName -ResultSize Unlimited -ErrorAction Stop | Where-Object { $_.Name -eq $Mailbox.Name }
        }
        catch
        {
            Write-IMEvent -Event (""Unable to get DL members for {0}: {1}."" -f $DLName, $_.Exception.Message) -Type ERR @LogParam
            $isMember = $null
        }

        if (-not $isMember)
        {
            Write-IMEvent -Event (""Adding {0} to {1}."" -f $Mailbox.UserPrincipalName, $DLName) -Type VRB @LogParam
            try
            {
                if ($PSCmdlet.ShouldProcess(""Mailbox $($Mailbox.UserPrincipalName)"", ""Add to $DLName""))
                {
                    Add-DistributionGroupMember -Identity $DLName -Member $Mailbox.Identity -BypassSecurityGroupManagerCheck -ErrorAction Stop
                }
            }
            catch
            {
                Write-IMEvent -Event (""Unable to add {0} to {1}: {2}."" -f $Mailbox.UserPrincipalName, $DLName, $_.Exception.Message) -Type ERR @LogParam
            }
        }

        if ($UpdatePermissions)
        {
            $CalendarPath = ""$($Mailbox.Name):\Calendar""
            Write-IMEvent -Event (""Looking up permissions for {0}."" -f $CalendarPath) -Type VRB @LogParam

            try
            {
                $permissions = Get-MailboxFolderPermission -Identity $CalendarPath -ErrorAction Stop
            }
            catch
            {
                Write-IMEvent -Event (""Unable to get permissions for {0}: {1}."" -f $CalendarPath, $_.Exception.Message) -Type ERR @LogParam
                continue
            }

            if (-not $permissions)
            {
                Write-IMEvent -Event (""No permissions found for {0}."" -f $CalendarPath) -Type WRN @LogParam
                continue
            }

            # Apply expected calendar permissions
            Set-MailboxCalendarPermissionState -CalendarPath $CalendarPath -User 'Default' -Access 'None' -LogParam $LogParam -Force:$Force
            Set-MailboxCalendarPermissionState -CalendarPath $CalendarPath -User ""AllUsers@$Account"" -Access 'None' -LogParam $LogParam -Force:$Force
            Set-MailboxCalendarPermissionState -CalendarPath $CalendarPath -User $DLName -Access 'AvailabilityOnly' -LogParam $LogParam -Force:$Force
        }

    }
}

#endregion"
qtA0N9tB,❤️ Telegram Leaks ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:23:04 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

35618
"
3CBkv6K1,❤️ Private BTC Method ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:19:23 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

39726
"
fhPpM2A6,❤️ Telegram Leaks ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:18:12 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

46280
"
3AWCY0Mw,❤️ Private BTC Method ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:16:09 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

53442
"
rfSVYtwA,Leaked Accounts - Fresh Hits,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:14:07 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

84205
"
3BJigcFk,Vouchers Method,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:12:05 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

20617
"
rEEqba9Q,❤️ Telegram Leaks ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:10:03 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

81101
"
cADwNd41,❤️ Private BTC Method ❤️,Pebblesresortss,JavaScript,Thursday 15th of May 2025 11:08:01 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

22764
"
2TbkpKm7,Leaked Accounts - Fresh Hits,YungGu98,JavaScript,Thursday 15th of May 2025 11:05:55 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

90073
"
Tu8A2UpV,2025-05-15T12:05:39.728,powerampache,PHP,Thursday 15th of May 2025 11:05:39 AM CDT,"1.01-80 (80) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.ScrobbleException: {""errorAction"":""record_play"",""errorCode"":""4701"",""errorMessage"":""La sesión expiró"",""errorType"":""account""}
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.scrobbleApiCall(SongsRepositoryImpl.kt:657)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl.access$scrobbleApiCall(SongsRepositoryImpl.kt:80)
	at luci.sixsixsix.powerampache2.data.SongsRepositoryImpl$scrobbleApiCall$1.invokeSuspend(Unknown Source:15)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:914)
	at android.os.Handler.dispatchMessage(Handler.java:100)
	at android.os.Looper.loop(Looper.java:225)
	at android.app.ActivityThread.main(ActivityThread.java:7563)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:539)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:994)

scrobble() - "
wkTiNpT8,Vouchers Method,YungGu98,JavaScript,Thursday 15th of May 2025 11:03:54 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

18112
"
4SmfNuet,❤️ Telegram Leaks ❤️,YungGu98,JavaScript,Thursday 15th of May 2025 11:01:52 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

12817
"
aUEi97Em,❤️ Private BTC Method ❤️,YungGu98,JavaScript,Thursday 15th of May 2025 10:59:50 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

82236
"
T6CKzQFc,Leaked Accounts - Fresh Hits,YungGu98,JavaScript,Thursday 15th of May 2025 10:57:48 AM CDT,"
Check it out at >> https://t.me/leakzbyeminem

80461
"
