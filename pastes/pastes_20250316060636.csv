id,title,username,language,date,content
NeJD1sca,[EroticBeauty] Luna Art - Presenting Luna Art 3 - Mar 15,MarcSpencer,HTML,Sunday 16th of March 2025 01:02:58 AM CDT,"[EroticBeauty] Luna Art - Presenting Luna Art 3 - Mar 15
<a href=""https://fappic.com/ecotylaw0nmj/mf4twa2iboaw.jpg""><img src=""https://img103.fappic.com/i/03907/ecotylaw0nmj_t.jpg""></a><a href=""https://fappic.com/k5zxqjy4hati/6g41zx9ey4yv.jpg""><img src=""https://img103.fappic.com/i/03907/k5zxqjy4hati_t.jpg""></a><a href=""https://fappic.com/voq7sqycyxxr/7w03sjclbf7y.jpg""><img src=""https://img103.fappic.com/i/03907/voq7sqycyxxr_t.jpg""></a><a href=""https://fappic.com/wceqth3tpggg/tnhf4636vsuy.jpg""><img src=""https://img103.fappic.com/i/03907/wceqth3tpggg_t.jpg""></a><a href=""https://fappic.com/rtjnc8fxbthw/0iizmc0bov54.jpg""><img src=""https://img103.fappic.com/i/03907/rtjnc8fxbthw_t.jpg""></a><a href=""https://fappic.com/q84g1m6pm11b/kq7n9dva3kvg.jpg""><img src=""https://img103.fappic.com/i/03907/q84g1m6pm11b_t.jpg""></a><a href=""https://fappic.com/ch4qcs54n9gq/l7nv2srvb9p4.jpg""><img src=""https://img103.fappic.com/i/03907/ch4qcs54n9gq_t.jpg""></a><a href=""https://fappic.com/gr5hh2vmtqzk/vfo8d6wqchy6.jpg""><img src=""https://img103.fappic.com/i/03907/gr5hh2vmtqzk_t.jpg""></a><a href=""https://fappic.com/nk9e0mierddz/u70vwmuow1bs.jpg""><img src=""https://img103.fappic.com/i/03907/nk9e0mierddz_t.jpg""></a><a href=""https://fappic.com/s0qk93csk966/zt9h2tvfxiiz.jpg""><img src=""https://img103.fappic.com/i/03907/s0qk93csk966_t.jpg""></a><a href=""https://fappic.com/wuul1rirs1z0/1tsy0lnek40t.jpg""><img src=""https://img103.fappic.com/i/03907/wuul1rirs1z0_t.jpg""></a><a href=""https://fappic.com/5oyaiuvg878v/z0ow9em7bxv0.jpg""><img src=""https://img103.fappic.com/i/03907/5oyaiuvg878v_t.jpg""></a><a href=""https://fappic.com/vhit89uilklc/33xerwprtlqr.jpg""><img src=""https://img103.fappic.com/i/03907/vhit89uilklc_t.jpg""></a><a href=""https://fappic.com/zveqhfmfou9m/xwntd8a9apgg.jpg""><img src=""https://img103.fappic.com/i/03907/zveqhfmfou9m_t.jpg""></a><a href=""https://fappic.com/yscbxrf75264/baldxq694n7k.jpg""><img src=""https://img103.fappic.com/i/03907/yscbxrf75264_t.jpg""></a><a href=""https://fappic.com/7fremlic5e7w/sfpjmkm7xfj9.jpg""><img src=""https://img103.fappic.com/i/03907/7fremlic5e7w_t.jpg""></a><a href=""https://fappic.com/hdkq48tv1x3b/o33ghhmjgj22.jpg""><img src=""https://img103.fappic.com/i/03907/hdkq48tv1x3b_t.jpg""></a><a href=""https://fappic.com/3li3y2v4l6re/9pfl045a3r33.jpg""><img src=""https://img103.fappic.com/i/03907/3li3y2v4l6re_t.jpg""></a><a href=""https://fappic.com/d8eace3l2ibz/ebx3d08umwoj.jpg""><img src=""https://img103.fappic.com/i/03907/d8eace3l2ibz_t.jpg""></a><a href=""https://fappic.com/mcp0526eq64a/6do1fo8zjisc.jpg""><img src=""https://img103.fappic.com/i/03907/mcp0526eq64a_t.jpg""></a><a href=""https://fappic.com/9j6c77eva982/2q4f8xrmxtdx.jpg""><img src=""https://img103.fappic.com/i/03907/9j6c77eva982_t.jpg""></a><a href=""https://fappic.com/7oll4zh3o6rg/3fi1aw1v84c8.jpg""><img src=""https://img103.fappic.com/i/03907/7oll4zh3o6rg_t.jpg""></a><a href=""https://fappic.com/34mr6u073kp9/o86yinu0i3on.jpg""><img src=""https://img103.fappic.com/i/03907/34mr6u073kp9_t.jpg""></a><a href=""https://fappic.com/hqvj9w7dk1k9/7zvaht3nr95p.jpg""><img src=""https://img103.fappic.com/i/03907/hqvj9w7dk1k9_t.jpg""></a><a href=""https://fappic.com/ilgtbks84ijj/qcuo5bwplvuf.jpg""><img src=""https://img103.fappic.com/i/03907/ilgtbks84ijj_t.jpg""></a><a href=""https://fappic.com/ppb3mptn9h03/8gmzbdubz4k5.jpg""><img src=""https://img103.fappic.com/i/03907/ppb3mptn9h03_t.jpg""></a><a href=""https://fappic.com/si9f2z3zdi6p/r1axcscgr3ul.jpg""><img src=""https://img103.fappic.com/i/03907/si9f2z3zdi6p_t.jpg""></a><a href=""https://fappic.com/pep0xd1oeait/vmigggwjfclw.jpg""><img src=""https://img103.fappic.com/i/03907/pep0xd1oeait_t.jpg""></a><a href=""https://fappic.com/0pm00dgg5kau/1lj5grtsfiv0.jpg""><img src=""https://img103.fappic.com/i/03907/0pm00dgg5kau_t.jpg""></a><a href=""https://fappic.com/7m96njk0isrz/vzb4joflepo9.jpg""><img src=""https://img103.fappic.com/i/03907/7m96njk0isrz_t.jpg""></a><a href=""https://fappic.com/5xo9782z8640/9qh97kkyntth.jpg""><img src=""https://img103.fappic.com/i/03907/5xo9782z8640_t.jpg""></a><a href=""https://fappic.com/ya8npk1kcyp1/xiajdhhtn1za.jpg""><img src=""https://img103.fappic.com/i/03907/ya8npk1kcyp1_t.jpg""></a><a href=""https://fappic.com/ik8dswaggrgi/0kh69bi8xblo.jpg""><img src=""https://img103.fappic.com/i/03907/ik8dswaggrgi_t.jpg""></a><a href=""https://fappic.com/0fy7jqzyhyw0/re7h35fd57vu.jpg""><img src=""https://img103.fappic.com/i/03907/0fy7jqzyhyw0_t.jpg""></a><a href=""https://fappic.com/g7utvegthhtn/q5g5hyldpbx8.jpg""><img src=""https://img103.fappic.com/i/03907/g7utvegthhtn_t.jpg""></a><a href=""https://fappic.com/6diwmflv1cfp/jfnjmh06692c.jpg""><img src=""https://img103.fappic.com/i/03907/6diwmflv1cfp_t.jpg""></a><a href=""https://fappic.com/wdw85bzs07zo/eit73fjp1f5v.jpg""><img src=""https://img103.fappic.com/i/03907/wdw85bzs07zo_t.jpg""></a><a href=""https://fappic.com/f0b190vpwmdz/y9oyg8td2955.jpg""><img src=""https://img103.fappic.com/i/03907/f0b190vpwmdz_t.jpg""></a><a href=""https://fappic.com/k4end7dkhv60/owqo0p6xn75c.jpg""><img src=""https://img103.fappic.com/i/03907/k4end7dkhv60_t.jpg""></a><a href=""https://fappic.com/mdsjkp0xdsbe/srtapz7z698h.jpg""><img src=""https://img103.fappic.com/i/03907/mdsjkp0xdsbe_t.jpg""></a><a href=""https://fappic.com/ie40lzigo9go/bd79j9uk186c.jpg""><img src=""https://img103.fappic.com/i/03907/ie40lzigo9go_t.jpg""></a><a href=""https://fappic.com/ddbi3jzob2l5/0zylefscc8hd.jpg""><img src=""https://img103.fappic.com/i/03907/ddbi3jzob2l5_t.jpg""></a><a href=""https://fappic.com/92jvbf83ecxb/9sklpwn1oh5k.jpg""><img src=""https://img103.fappic.com/i/03907/92jvbf83ecxb_t.jpg""></a><a href=""https://fappic.com/r2pyaanmu568/flew2yhentsl.jpg""><img src=""https://img103.fappic.com/i/03907/r2pyaanmu568_t.jpg""></a><a href=""https://fappic.com/zd1t4eoio8xv/gqesgf7bgfdy.jpg""><img src=""https://img103.fappic.com/i/03907/zd1t4eoio8xv_t.jpg""></a><a href=""https://fappic.com/owhyqby9kltv/b3gocudz9sxo.jpg""><img src=""https://img103.fappic.com/i/03907/owhyqby9kltv_t.jpg""></a><a href=""https://fappic.com/es1l85zwkvl4/fk1uqste2flf.jpg""><img src=""https://img103.fappic.com/i/03907/es1l85zwkvl4_t.jpg""></a><a href=""https://fappic.com/getdoj2i3lmc/vhhjyn9j0ode.jpg""><img src=""https://img103.fappic.com/i/03907/getdoj2i3lmc_t.jpg""></a><a href=""https://fappic.com/adj1fdgnp3kc/65ifi63fbrhp.jpg""><img src=""https://img103.fappic.com/i/03907/adj1fdgnp3kc_t.jpg""></a><a href=""https://fappic.com/xgye9ah1aw5d/2ltxcgsw4bzt.jpg""><img src=""https://img103.fappic.com/i/03907/xgye9ah1aw5d_t.jpg""></a><a href=""https://fappic.com/omounxq857ls/ed6gw1127rge.jpg""><img src=""https://img103.fappic.com/i/03907/omounxq857ls_t.jpg""></a><a href=""https://fappic.com/74qbu7oaifg7/xxwciyd3mhqq.jpg""><img src=""https://img103.fappic.com/i/03907/74qbu7oaifg7_t.jpg""></a><a href=""https://fappic.com/mvnuupmg46ng/stwfykkezc07.jpg""><img src=""https://img103.fappic.com/i/03907/mvnuupmg46ng_t.jpg""></a><a href=""https://fappic.com/tekgrqbimoum/47o4fa6363ok.jpg""><img src=""https://img103.fappic.com/i/03907/tekgrqbimoum_t.jpg""></a><a href=""https://fappic.com/dau7o5748tdx/j69gdchja6ho.jpg""><img src=""https://img103.fappic.com/i/03907/dau7o5748tdx_t.jpg""></a><a href=""https://fappic.com/j5egcnv5b7y0/qqvupffjlsjv.jpg""><img src=""https://img103.fappic.com/i/03907/j5egcnv5b7y0_t.jpg""></a><a href=""https://fappic.com/uzwq8eczzl24/zsnic2xwel1m.jpg""><img src=""https://img103.fappic.com/i/03907/uzwq8eczzl24_t.jpg""></a><a href=""https://fappic.com/0a0uwogu4jd4/qcmnyeu90usd.jpg""><img src=""https://img103.fappic.com/i/03907/0a0uwogu4jd4_t.jpg""></a><a href=""https://fappic.com/sor39xitif4x/slmt2y33qi63.jpg""><img src=""https://img103.fappic.com/i/03907/sor39xitif4x_t.jpg""></a><a href=""https://fappic.com/ocw9ox0z59hg/b479yq50iwvn.jpg""><img src=""https://img103.fappic.com/i/03907/ocw9ox0z59hg_t.jpg""></a><a href=""https://fappic.com/o2xfniuooleg/8s6hcvvz79im.jpg""><img src=""https://img103.fappic.com/i/03907/o2xfniuooleg_t.jpg""></a><a href=""https://fappic.com/2cjnwkycm278/3u19c7yy07yf.jpg""><img src=""https://img103.fappic.com/i/03907/2cjnwkycm278_t.jpg""></a><a href=""https://fappic.com/peje7peyvnjl/p20ce0d8gdgw.jpg""><img src=""https://img103.fappic.com/i/03907/peje7peyvnjl_t.jpg""></a><a href=""https://fappic.com/vginrnj4j24v/ooqkw782m4u0.jpg""><img src=""https://img103.fappic.com/i/03907/vginrnj4j24v_t.jpg""></a><a href=""https://fappic.com/yjf2fm0qb8ka/gjekini6l7x2.jpg""><img src=""https://img103.fappic.com/i/03907/yjf2fm0qb8ka_t.jpg""></a><a href=""https://fappic.com/d6h6bs6wagdu/ieaarnppjl72.jpg""><img src=""https://img103.fappic.com/i/03907/d6h6bs6wagdu_t.jpg""></a><a href=""https://fappic.com/ctjv90ddv2ry/caj1nsv62x2e.jpg""><img src=""https://img103.fappic.com/i/03907/ctjv90ddv2ry_t.jpg""></a><a href=""https://fappic.com/y2bdbj4dxn1d/6besncwc37mm.jpg""><img src=""https://img103.fappic.com/i/03907/y2bdbj4dxn1d_t.jpg""></a><a href=""https://fappic.com/cawfkk8uvrw2/bdfc22z35t1u.jpg""><img src=""https://img103.fappic.com/i/03907/cawfkk8uvrw2_t.jpg""></a><a href=""https://fappic.com/rvyng2mlgwei/brvopc8lqltz.jpg""><img src=""https://img103.fappic.com/i/03907/rvyng2mlgwei_t.jpg""></a><a href=""https://fappic.com/jb7xvuzyydrl/nc3iepvq6n6c.jpg""><img src=""https://img103.fappic.com/i/03907/jb7xvuzyydrl_t.jpg""></a><a href=""https://fappic.com/c8v5iiov1mzp/oy776ztx0vag.jpg""><img src=""https://img103.fappic.com/i/03907/c8v5iiov1mzp_t.jpg""></a><a href=""https://fappic.com/nwoqqvqbzvfa/cp6gkh1dal3d.jpg""><img src=""https://img103.fappic.com/i/03907/nwoqqvqbzvfa_t.jpg""></a><a href=""https://fappic.com/o40tlz8y2ohy/yygq9zwu5f84.jpg""><img src=""https://img103.fappic.com/i/03907/o40tlz8y2ohy_t.jpg""></a><a href=""https://fappic.com/xtr5g4i1tpfy/n1zzgxgenl18.jpg""><img src=""https://img103.fappic.com/i/03907/xtr5g4i1tpfy_t.jpg""></a><a href=""https://fappic.com/nfu3wgxuvgfj/v611jpb96qu0.jpg""><img src=""https://img103.fappic.com/i/03907/nfu3wgxuvgfj_t.jpg""></a><a href=""https://fappic.com/c4soexgs5nv6/83o0isb4ywl3.jpg""><img src=""https://img103.fappic.com/i/03907/c4soexgs5nv6_t.jpg""></a><a href=""https://fappic.com/57910gdk62qp/v26skr32j5uh.jpg""><img src=""https://img103.fappic.com/i/03907/57910gdk62qp_t.jpg""></a><a href=""https://fappic.com/gptx23xmobmg/qof3wk487z9z.jpg""><img src=""https://img103.fappic.com/i/03907/gptx23xmobmg_t.jpg""></a><a href=""https://fappic.com/m9wpeyhrtygd/0z9m3i3cmpyv.jpg""><img src=""https://img103.fappic.com/i/03907/m9wpeyhrtygd_t.jpg""></a><a href=""https://fappic.com/uefms7ivjr4k/i4i3424rgt6a.jpg""><img src=""https://img103.fappic.com/i/03907/uefms7ivjr4k_t.jpg""></a><a href=""https://fappic.com/97gnjgk8lkx7/iub5skphyyz9.jpg""><img src=""https://img103.fappic.com/i/03907/97gnjgk8lkx7_t.jpg""></a><a href=""https://fappic.com/7yjrrk15xnzx/fspwnnh0uc3c.jpg""><img src=""https://img103.fappic.com/i/03907/7yjrrk15xnzx_t.jpg""></a><a href=""https://fappic.com/l8rax26fms5q/a3wb3m68rs5g.jpg""><img src=""https://img103.fappic.com/i/03907/l8rax26fms5q_t.jpg""></a>"
rtZqT2cW,Untitled,Strange_Your_Here,C,Sunday 16th of March 2025 12:52:53 AM CDT,https://pastebin.com/Xrq9P5Rk
ifTTupqW,Linux. Mount NTFS volume using ntfs-3g,sytchenko,Bash,Saturday 15th of March 2025 10:52:07 PM CDT,"# Mount
sudo mount -t ntfs-3g /dev/sdb1 /mnt

# Unmount
sudo umount /dev/sdb1"
u11Gwmpb,DataManager,g14ndev,Lua,Saturday 15th of March 2025 10:21:06 PM CDT,"local ProfileService = require(game.ServerScriptService.ProfileService)

-----------------------------------------------------------
-- DataStore Configuration
-----------------------------------------------------------
local DataStoreName = ""PlayerData_1"" -- Change this name to reset all data

-- Default data template for new players.
-- If a player joins for the first time, their data will be initialized using these values.
local DataTemplate = {
	Coins = 0,                   -- Integer: Total coins the player has
	Loot = {},                   -- Dictionary: key = loot name, value = quantity
	Weapons = {""Bow""},           -- Array: List of weapon names the player owns (default: ""Bow"")
	Kills = 0,                   -- Integer: Total number of kills
	Equipped_Weapon = ""Bow""      -- String: The weapon currently equipped (default: ""Bow"")
}

-----------------------------------------------------------
-- Global Variables
-----------------------------------------------------------
local Profiles = {} -- Table to store each player's loaded profile during gameplay

-- Create the ProfileStore using ProfileService.
-- This connects to the DataStore using the DataTemplate.
local ProfileStore = ProfileService.GetProfileStore(DataStoreName, DataTemplate)

-----------------------------------------------------------
-- Remote Setup for Live Data Updates
-----------------------------------------------------------
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
-- Get (or create) the Remotes folder in ReplicatedStorage.
local Remotes = ReplicatedStorage:FindFirstChild(""Remotes"") or Instance.new(""Folder"")
Remotes.Name = ""Remotes""
Remotes.Parent = ReplicatedStorage

-- RemoteEvent to push live data updates to the client.
local UpdateEvent = Remotes:FindFirstChild(""UpdatePlayerData"") or Instance.new(""RemoteEvent"")
UpdateEvent.Name = ""UpdatePlayerData""
UpdateEvent.Parent = Remotes

-- RemoteFunction to allow clients to fetch their data on startup.
local GetDataFunction = Remotes:FindFirstChild(""GetPlayerData"") or Instance.new(""RemoteFunction"")
GetDataFunction.Name = ""GetPlayerData""
GetDataFunction.Parent = Remotes

-----------------------------------------------------------
-- DataManager Table
-----------------------------------------------------------
local DataManager = {}

-----------------------------------------------------------
-- Function: DataManager.SendUpdate
-- Description: Sends the current profile data to the specified player's client.
-- Parameters: player (Player) – the player whose data to update.
-----------------------------------------------------------
function DataManager.SendUpdate(player)
	local profile = Profiles[player]
	if profile then
		-- Fire the remote event with the player's current data table.
		UpdateEvent:FireClient(player, profile.Data)
	end
end

-----------------------------------------------------------
-- Function: DataManager.LoadData
-- Description: Loads a player's data using ProfileService when they join.
-- If the player has no previous data, it initializes with DataTemplate.
-- It also sets up a listener to kick the player if the profile is released.
-- Finally, if the player is still in-game, it stores their profile and sends an initial update.
-----------------------------------------------------------
function DataManager.LoadData(player)
	-- Attempt to load the player's profile from the DataStore using their UserId.
	local profile = ProfileStore:LoadProfileAsync(""Player_"" .. player.UserId)

	if profile then
		-- Link the profile to the player's UserId.
		profile:AddUserId(player.UserId)
		-- Reconcile the profile so any missing fields are filled using DataTemplate.
		profile:Reconcile()
		-- Listen for profile release (e.g. data error) and kick the player if it happens.
		profile:ListenToRelease(function()
			Profiles[player] = nil
			player:Kick(""Data Error: Please rejoin!"")
		end)

		-- Ensure every field defined in DataTemplate exists in profile.Data.
		for key, defaultValue in pairs(DataTemplate) do
			if profile.Data[key] == nil then
				profile.Data[key] = defaultValue
			end
		end

		--print(""Data loaded for"", player.Name, profile.Data)

		-- Only store the profile if the player is still in the game.
		if player:IsDescendantOf(game.Players) then
			Profiles[player] = profile
			-- Send the initial data update to the player's client.
			DataManager.SendUpdate(player)

			-- Immediately equip the weapon if the player's character already exists.
			if player.Character then
				-- Wait a short moment to ensure the Backpack is ready.
				local backpack = player:FindFirstChild(""Backpack"") or player:WaitForChild(""Backpack"")
				task.wait(0.5)
				DataManager.EquipWeapon(player, profile.Data.Equipped_Weapon)
			end

			-- Also listen for CharacterAdded to equip weapon on respawn.
			player.CharacterAdded:Connect(function(character)
				local backpack = player:FindFirstChild(""Backpack"") or player:WaitForChild(""Backpack"")
				task.wait(0.5) -- Small delay for smooth loading
				DataManager.EquipWeapon(player, profile.Data.Equipped_Weapon)
			end)
		else
			profile:Release()
		end
	else
		-- If profile fails to load, kick the player.
		player:Kick(""Data failed to load. Try rejoining."")
	end
end

-----------------------------------------------------------
-- Function: DataManager.EquipWeapon
-- Description: Equips a weapon for the player by cloning the weapon tool from ReplicatedStorage.
-- It removes any existing weapon from the player's Backpack, then equips the new weapon.
-- Also updates the player's profile with the newly equipped weapon and sends a UI update.
-- Parameters:
--   player (Player): The player to equip the weapon.
--   weaponName (string): The name of the weapon to equip.
-----------------------------------------------------------
function DataManager.EquipWeapon(player, weaponName)
	-- Get the Weapons folder from ReplicatedStorage.
	local Weapons = ReplicatedStorage:FindFirstChild(""Weapons"")
	local profile = Profiles[player]
	if not Weapons then
		warn(""Weapons folder missing in ReplicatedStorage!"")
		return
	end

	-- Find the weapon tool by name.
	local clonedWeapon = Weapons:FindFirstChild(weaponName)
	-- Wait for the player's Backpack.
	local Backpack = player:WaitForChild(""Backpack"")
	local StarterGear = player:WaitForChild(""StarterGear"")
	if clonedWeapon and Backpack then
		-- Remove any existing weapon tools from the Backpack.
		for _, tool in ipairs(Backpack:GetChildren()) do
			if tool:IsA(""Tool"") then
				tool:Destroy()
			end
		end

		-- Also clear StarterGear to ensure consistency.
		for _, tool in ipairs(StarterGear:GetChildren()) do
			if tool:IsA(""Tool"") then
				tool:Destroy()
			end
		end

		-- Clone the weapon tool and parent it to the Backpack.
		local newWeapon = clonedWeapon:Clone()
		newWeapon.Parent = Backpack

		-- Clone for StarterGear as well.
		local starterGearWeapon = clonedWeapon:Clone()
		starterGearWeapon.Parent = StarterGear

		-- Update the player's profile with the newly equipped weapon.
		profile.Data.Equipped_Weapon = weaponName

		-- Send a live update to the client.
		DataManager.SendUpdate(player)
		-- Debug (optional): print(""Equipped"", weaponName, ""to"", player.Name)
	else
		warn(""Could not equip weapon for"", player.Name)
	end
end

-----------------------------------------------------------
-- RemoteFunction: GetDataFunction.OnServerInvoke
-- Description: When the client requests their data, this function waits until the player's profile is loaded
-- (with a maximum wait time) and then returns the stored data. If data isn’t available, it returns the default template.
-----------------------------------------------------------
function GetDataFunction.OnServerInvoke(player)
	local totalWait = 0
	while not Profiles[player] and totalWait < 5 do
		task.wait(0.2)
		totalWait = totalWait + 0.2
	end
	if not Profiles[player] then
		return DataTemplate
	end
	return Profiles[player].Data
end

-----------------------------------------------------------
-- Function: DataManager.SaveData
-- Description: Called when a player leaves. It releases their profile, which saves the data.
-----------------------------------------------------------
function DataManager.SaveData(player)
	local profile = Profiles[player]
	if profile then
		profile:Release()
	end
end

-----------------------------------------------------------
-- Update Methods for Player Data
-----------------------------------------------------------

-- Function: DataManager.UpdateStat
-- Updates a specific stat in the player's data, then sends a live update.
function DataManager.UpdateStat(player, stat, value)
	local profile = Profiles[player]
	if profile and profile.Data[stat] ~= nil then
		profile.Data[stat] = value
		DataManager.SendUpdate(player)
	end
end

-- Function: DataManager.AddLoot
-- Adds a specified amount of loot to the player's data if it is obtainable,
-- updates the player's profile, sends a live update, and triggers a GUI popup.
function DataManager.AddLoot(player, lootName, amount)
	local obtainableLoot = require(game.ServerScriptService.LootManager).GetObtainableLoot()
	local profile = Profiles[player]
	-- Only add loot if it's marked as obtainable.
	if profile and obtainableLoot[lootName] then
		profile.Data.Loot[lootName] = (profile.Data.Loot[lootName] or 0) + amount
		DataManager.SendUpdate(player)

		-- Trigger the loot popup GUI on the client.
		local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
		local Remotes = ReplicatedStorage:WaitForChild(""Remotes"")
		local LootPopupEvent = Remotes:FindFirstChild(""LootPopupEvent"")
		if LootPopupEvent then
			LootPopupEvent:FireClient(player, lootName, amount)
		end
	end
end

-- Function: DataManager.RemoveLoot
-- Removes a specified amount of loot from the player's data if they have enough.
-- Returns true if successful; false otherwise.
function DataManager.RemoveLoot(player, lootName, amount)
	local profile = Profiles[player]
	if profile and profile.Data.Loot[lootName] and profile.Data.Loot[lootName] >= amount then
		profile.Data.Loot[lootName] = profile.Data.Loot[lootName] - amount
		if profile.Data.Loot[lootName] <= 0 then
			profile.Data.Loot[lootName] = nil
		end
		DataManager.SendUpdate(player)
		return true
	end
	return false
end

-- Function: DataManager.AddWeapon
-- Adds a weapon to the player's owned list (if they don't already own it) and sends an update.
function DataManager.AddWeapon(player, weaponName)
	local profile = Profiles[player]
	if profile and not table.find(profile.Data.Weapons, weaponName) then
		table.insert(profile.Data.Weapons, weaponName)
		DataManager.SendUpdate(player)
	end
end

-- Function: DataManager.AddCoins
-- Increments the player's coins by the given amount and sends an update.
function DataManager.AddCoins(player, amount)
	local profile = Profiles[player]
	if profile then
		profile.Data.Coins = profile.Data.Coins + amount
		DataManager.SendUpdate(player)
	end
end

-- Function: DataManager.RemoveCoins
-- Deducts coins from the player's data if they have enough.
-- Returns true if successful; false otherwise.
function DataManager.RemoveCoins(player, amount)
	local profile = Profiles[player]
	if profile and profile.Data.Coins >= amount then
		profile.Data.Coins = profile.Data.Coins - amount
		DataManager.SendUpdate(player)
		return true
	end
	return false
end

-- Function: DataManager.AddKill
-- Increments the player's kill count by one and sends an update.
function DataManager.AddKill(player)
	local profile = Profiles[player]
	if profile then
		profile.Data.Kills = profile.Data.Kills + 1
		DataManager.SendUpdate(player)
	end
end

-----------------------------------------------------------
-- Connect Player Events
-----------------------------------------------------------
game.Players.PlayerAdded:Connect(DataManager.LoadData)      -- Load data when a player joins
game.Players.PlayerRemoving:Connect(DataManager.SaveData)   -- Save data when a player leaves

-----------------------------------------------------------
-- Return the DataManager module
-----------------------------------------------------------
return DataManager
"
DwaxHenE,Untitled,smj007,Python,Saturday 15th of March 2025 09:16:18 PM CDT,"class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        
        z = len(digits) - 1
        carry = 1
        
        while (z>=0 and carry>0):
            carry = (digits[z] + 1)//10
            digits[z] = (digits[z] + 1)%10
            z = z - 1
            
        if carry > 0:
            digits = [1] + digits
            
        return digits
"
vf5TNJGi,Untitled,Mysoft,mIRC,Saturday 15th of March 2025 08:55:28 PM CDT,"; $1 = XVal ; $2 = YVal
alias Mandel_Pixel {    
  var %J 1 , %M = 0 , %R = $1 , %I = $2
  while (%J < 128) { 

    inc %J
    %M = $calc((%R *%R)-(%I *%I))
    %I = $calc((2*(%R *%I)) + $2)
    %R = %M + $1
    ;if $abs(%M) > 3 return %J

    inc %J
    %M = $calc((%R *%R)-(%I *%I))
    %I = $calc((2*(%R *%I)) + $2)
    %R = %M + $1
    ;if $abs(%M) > 3 return %J

    inc %J
    %M = $calc((%R *%R)-(%I *%I))
    %I = $calc((2*(%R *%I)) + $2)
    %R = %M + $1
    if $abs(%M) > 3 return %J   

  }
  return %J
}

alias Mandel_Row {
  if (!$window(@Mandel)) {
    .timerMandel off
    unset %m_Y
    unset %m_Start
    halt
  }
  var %X = 0    
  while ( %X < 256 ) {
    var %I = $Mandel_Pixel( $calc( %X / 25600 - 1.378 ) , $calc( %m_Y / 19200 - .09 ) )
    if ( %I > 85 ) { %I = 85 }
    drawdot -nr @Mandel $rgb( %I , $calc(%I *2) , $calc(%I *3) ) 1 %X %m_Y
    inc %X    
  }
  drawdot @Mandel
  dec %m_Y
  if (!%m_Y) { 
    echo > $calc( ($ticks - %m_Start) / 500 ) $+ s
    unset %m_Y
    unset %m_Start
  }
}

alias Mandel_Calc {
  window -daCp @Mandel 0 0 256 224
  set %m_Start $ticks
  set %m_Y 191
  .timerMandel -m %m_Y 1 Mandel_Row
}
"
hSCDiq7j,chatplus-v2.5.0,Darknight8151,JSON,Saturday 15th of March 2025 08:08:03 PM CDT,"{
    ""enabled"": true,
    ""addMessagesIfDisabled"": false,
    ""showVanillaWhenUnfocused"": false,
    ""vanillaInputBox"": false,
    ""saveInputBoxMessage"": false,
    ""wrappedMessageLineIndent"": 0,
    ""maxMessages"": -1,
    ""maxCommandSuggestions"": 15,
    ""jumpToMessageMode"": ""CURSOR"",
    ""selectChatLinePriority"": 100,
    ""timestampSettings"": {
        ""enabled"": true,
        ""timestampFormat"": ""&7Sent at &e{hh:mm:ss a}&7."",
        ""chatTimestampModeType"": ""HOVER""
    },
    ""inputOverFlowAutoFillSettings"": {
        ""enabled"": true,
        ""onlyOnEnter"": true,
        ""clearQueueIfCloseOnEmpty"": true,
        ""autoFillCommandInteraction"": ""IGNORE"",
        ""queueMode"": ""OVERWRITE""
    },
    ""messageImagePreviewSettings"": {
        ""enabled"": true,
        ""hasPreviewLinePriority"": 20,
        ""previewLineColor"": -932928701
    },
    ""hideChatEnabled"": false,
    ""hideChatShowWhenFocused"": true,
    ""hideChatShowHiddenOnScreen"": true,
    ""hideChatToggleKey"": {
        ""key"": ""key.keyboard.unknown"",
        ""modifier"": 0
    },
    ""alwaysShowChat"": false,
    ""alwaysShowChatToggleKey"": {
        ""key"": ""key.keyboard.unknown"",
        ""modifier"": 0
    },
    ""compactMessagesEnabled"": true,
    ""compactMessagesRefreshAddedTime"": false,
    ""compactMessagesSearchAmount"": 1,
    ""compactMessageComparatorMode"": ""VANILLA"",
    ""compactMessageSettings"": {
        ""ignoreTimestamps"": true,
        ""contents"": true,
        ""style"": true,
        ""styleSettings"": {
            ""color"": true,
            ""bold"": true,
            ""italic"": true,
            ""underlined"": true,
            ""strikethrough"": true,
            ""obfuscated"": true,
            ""clickEvent"": true,
            ""hoverEvent"": true,
            ""insertion"": true,
            ""font"": true
        }
    },
    ""scrollbarEnabled"": true,
    ""invertedScrolling"": false,
    ""scrollbarColor"": -8354165,
    ""scrollbarWidth"": 6,
    ""animationEnabled"": true,
    ""animationDisableOnFocus"": false,
    ""animationNewMessageTransitionTime"": 200,
    ""scrollCycleTabEnabled"": true,
    ""arrowCycleTabEnabled"": true,
    ""moveToTabWhenCycling"": true,
    ""inputBoxAutoAdjustChatWindowEnabled"": true,
    ""tabNotificationSettings"": {
        ""enabled"": true,
        ""scale"": 0.4
    },
    ""chatWindows"": [
        {
            ""generalSettings"": {
                ""disabled"": false,
                ""backgroundColor"": -2147483648,
                ""unfocusedBackgroundColorOpacityMultiplier"": 0.39999998,
                ""scale"": 1.0,
                ""textOpacity"": 1.0,
                ""textShadow"": true,
                ""unfocusedTextOpacityMultiplier"": 1.0,
                ""unfocusedHeight"": 0.5,
                ""lineSpacing"": 0.0,
                ""messageAlignment"": ""LEFT"",
                ""messageDirection"": ""BOTTOM_UP""
            },
            ""outlineSettings"": {
                ""enabled"": false,
                ""showWhenChatNotOpen"": false,
                ""outlineColor"": 0,
                ""unfocusedOutlineColorOpacityMultiplier"": 0.39999998,
                ""outlineBoxType"": ""TEXT_BOX"",
                ""outlineTabType"": ""SELECTED_TAB_OPEN_TOP""
            },
            ""padding"": {
                ""left"": 0,
                ""right"": 0,
                ""bottom"": 0
            },
            ""renderer"": {
                ""x"": 0,
                ""y"": 329,
                ""width"": 229,
                ""height"": 108
            },
            ""tabSettings"": {
                ""selectedTabIndex"": 0,
                ""startRenderTabIndex"": 0,
                ""hideTabs"": false,
                ""showTabsWhenChatNotOpen"": true,
                ""position"": ""BOTTOM"",
                ""tabTextColorSelected"": -2293760,
                ""tabTextColorUnselected"": -6710887,
                ""unfocusedTabOpacityMultiplier"": 0.39999998,
                ""tabs"": [
                    {
                        ""pattern"": ""(?s).*"",
                        ""formatted"": false,
                        ""name"": ""All"",
                        ""autoPrefix"": """",
                        ""serverTabPatterns"": [],
                        ""priority"": 0,
                        ""alwaysAdd"": true,
                        ""skipOthers"": false,
                        ""commandsOverrideAutoPrefix"": true,
                        ""temporary"": false
                    }
                ]
            },
            ""autoTabCreator"": {
                ""autoTabOptions"": [
                    {
                        ""pattern"": ""^\\[((Moi . . (\\w+))|(. (\\w+) . Moi))\\] .*"",
                        ""formatted"": false,
                        ""skipOthersOnCreation"": true,
                        ""tabNameFormatter"": ""%GROUP_3%%GROUP_5%"",
                        ""regexFormatter"": ""\\[((Moi . . %GROUP_3%%GROUP_5%)|(. %GROUP_3%%GROUP_5% . Moi))\\] .*"",
                        ""autoPrefixFormatter"": ""/msg %GROUP_3%%GROUP_5% "",
                        ""priority"": 0,
                        ""alwaysAdd"": false,
                        ""skipOthers"": false,
                        ""commandsOverrideAutoPrefix"": true,
                        ""temporary"": true
                    }
                ]
            }
        }
    ],
    ""movableChatEnabled"": false,
    ""movableChatShowEnabledOnScreen"": true,
    ""movableChatKey"": {
        ""key"": ""key.keyboard.unknown"",
        ""modifier"": 0
    },
    ""movableChatColor"": -922746881,
    ""movableChatSelectedColor"": -939458816,
    ""movableChatToggleTextBarElement"": false,
    ""inputBoxSettings"": {
        ""startY"": -10
    },
    ""sendNoteEnabled"": true,
    ""sendNoteKey"": {
        ""key"": ""key.keyboard.enter"",
        ""modifier"": 4
    },
    ""sendNoteClickMode"": ""APPEND_INPUT"",
    ""sendNoteSelectMode"": ""LINE"",
    ""sendNoteSelectKey"": ""key.keyboard.left.shift"",
    ""sendNoteSelectModeKey"": ""WHOLE_MESSAGE"",
    ""sendNoteTextBarElementEnabled"": true,
    ""filterMessagesEnabled"": true,
    ""filterMessagesLinePriority"": 150,
    ""filterMessagesPatterns"": [],
    ""hoverHighlightEnabled"": true,
    ""hoverHighlightLinePriority"": 0,
    ""hoverHighlightMode"": ""BRIGHTER"",
    ""hoverHighlightColor"": 419430400,
    ""bookmarkEnabled"": true,
    ""bookmarkLinePriority"": 30,
    ""bookmarkColor"": -925260989,
    ""bookmarkKey"": {
        ""key"": ""key.keyboard.b"",
        ""modifier"": 2
    },
    ""bookmarkTextBarElementEnabled"": true,
    ""bookmarkTextBarElementKey"": {
        ""key"": ""key.keyboard.b"",
        ""modifier"": 2
    },
    ""autoBookMarkPatterns"": [],
    ""findMessageEnabled"": true,
    ""findMessageHighlightInputBox"": false,
    ""findMessageHighlightMatchedText"": true,
    ""findMessageIgnoreCase"": true,
    ""findMessageLinePriority"": 250,
    ""findMessageKey"": {
        ""key"": ""key.keyboard.f"",
        ""modifier"": 2
    },
    ""findMessageDefaultMode"": ""CONTAINS"",
    ""findMessageTextBarElementEnabled"": true,
    ""copyMessageKey"": {
        ""key"": ""key.keyboard.c"",
        ""modifier"": 2
    },
    ""copyMessageLinePriority"": 50,
    ""copyNoFormatting"": true,
    ""copyMessageFormattingSymbolOverride"": """",
    ""copyMessageSeparator"": ""\n"",
    ""deleteMessageEnabled"": true,
    ""deleteMessageKey"": {
        ""key"": ""key.keyboard.d"",
        ""modifier"": 2
    },
    ""screenshotChatEnabled"": true,
    ""screenshotChatCopyToClipboard"": true,
    ""screenshotChatSaveToFile"": true,
    ""screenshotChatAutoUpload"": true,
    ""screenshotChatLinePriority"": 200,
    ""screenshotChatKey"": {
        ""key"": ""key.keyboard.s"",
        ""modifier"": 2
    },
    ""screenshotDefaultScreenShotMode"": ""CURRENT_WINDOW"",
    ""screenshotDefaultScreenBackgroundMode"": ""TRANSPARENT"",
    ""screenshotDefaultScreenShotWindowsMode"": ""SPLIT"",
    ""screenshotChatTextBarElementEnabled"": true,
    ""playerHeadChatDisplayEnabled"": false,
    ""playerHeadChatDisplayShowOnWrapped"": false,
    ""playerHeadChatDisplayOffsetNonHeadMessages"": false,
    ""playerHeadChatDisplayOffsetNonHeadMessagesShowOnWrapped"": true,
    ""keyNoScroll"": ""key.keyboard.left.control"",
    ""keyFineScroll"": ""key.keyboard.left.shift"",
    ""keyLargeScroll"": ""key.keyboard.left.alt"",
    ""keyPeekChat"": ""key.keyboard.unknown"",
    ""translatorEnabled"": true,
    ""translatorTextBarElementEnabled"": true,
    ""translatorRegexes"": [],
    ""translateTo"": ""Auto Detect"",
    ""translateSelf"": ""Auto Detect"",
    ""translateSpeak"": ""English"",
    ""translateKeepOnAfterChatClose"": true,
    ""translateKey"": {
        ""key"": ""key.keyboard.t"",
        ""modifier"": 2
    },
    ""translateToggleKey"": {
        ""key"": ""key.keyboard.t"",
        ""modifier"": 2
    },
    ""translateClickEnabled"": true,
    ""speechToTextEnabled"": true,
    ""speechToTextToInputBox"": true,
    ""speechToTextMicrophoneKey"": ""key.keyboard.b"",
    ""speechToTextQuickSendKey"": ""key.keyboard.enter"",
    ""speechToTextTranslateEnabled"": false,
    ""speechToTextTranslateToInputBox"": true,
    ""speechToTextTranslateLang"": ""English"",
    ""speechToTextAutoReplacePlayers"": true,
    ""speechToTextAutoReplacePlayersMaxSearchDepth"": 3,
    ""speechToTextReplace"": [],
    ""speechToTextSampleRate"": 48000,
    ""speechToTextMicrophone"": ""Default"",
    ""speechToTextSelectedAudioModel"": """"
}"
rQNMuS4h,ChestInventory,dadragon84,Lua,Saturday 15th of March 2025 07:16:28 PM CDT,"-- Turtle-Programm fÃ¼r cc:tweaked
 
-- Konfiguration
local INPUT_CHEST = ""right""   -- Deposit box
local DEPOT_CHEST = ""bottom""  -- Depot kit
local PRICE_CHEST = ""back""    -- Investigations
local OUTPUT_CHEST = ""left""  -- Payout box
local MAX_ITEMS = 16           -- Maximum number of prizes per transaction
 
-- Advanced peripherals for chat messages
local chat = peripheral.find(""chatBox"")
 
-- Auxiliary functions
local function selectItem(name)
    for i = 1, 16 do
        turtle.select(i)
        local detail = turtle.getItemDetail()
        if detail and detail.name == name then
            return true
        end
    end
    return false
end
 
local function dropAll(direction)
    for i = 1, 16 do
        turtle.select(i)
        if direction == ""up"" then
            turtle.dropUp()
        elseif direction == ""down"" then
            turtle.dropDown()
        elseif direction == ""forward"" then
            turtle.drop()
        end
    end
end
 
local function countItems(itemName)
    local count = 0
    for i = 1, 16 do
        local detail = turtle.getItemDetail(i)
        if detail and detail.name == itemName then
            count = count + detail.count
        end
    end
    return count
end
 
local function sendMessage(message)
    if chat then
        chat.sendMessage(message)
    else
        print(message)
    end
end
 
-- Main logic
local function processTransaction()
    turtle.turnRight()
 
    while turtle.suck() do
        -- As long as there are items in the deposit box, collect
    end
 
    local diamonds = countItems(""minecraft:diamond"")
    local emeralds = countItems(""minecraft:emerald"")
    local totalItems = diamonds + emeralds
 
    if totalItems > 0 then
        -- Put diamonds and emeralds in the depot
        if diamonds > 0 then
            selectItem(""minecraft:diamond"")
            dropAll(""down"")
        end
 
        if emeralds > 0 then
            selectItem(""minecraft:emerald"")
            dropAll(""down"")
        end
 
        sendMessage(""There were "" .. totalItems .. "" Diamonds/Emeralds deposited."")
 
        -- Remove prizes from prize box and place them in payout box
        local itemsToGive = math.min(totalItems, MAX_ITEMS)
        turtle.turnRight()
        for i = 1, itemsToGive do
            if not turtle.suck() then
                sendMessage(""Prize box is empty. Not enough prizes could be provided."")
                break
            end
        end
        turtle.turnRight()
        dropAll(""forward"")
        sendMessage(""The prizes were placed in the payout box."")
         turtle.turnRight()
    else
        -- Move incorrect items to the depot
        sendMessage(""No valid items found. Move faulty items to the depot.."")
        dropAll(""down"")
        redstone.setOutput(""front"", true)
        sleep(0.5)
        redstone.setOutput(""front"", false)
         turtle.turnLeft()
       end
 
    sendMessage(""Thank you for your trust - gambling can be addictive!"")
    
end
 
-- Event Listener for Redstone Signal
while true do
    if redstone.getInput(""top"") then
        processTransaction()
        while redstone.getInput(""top"") do
            sleep(0.1) -- Wait until the pulse ends
        end
    end
    sleep(0.1)
end
"
zdP31a16,Untitled,smj007,Python,Saturday 15th of March 2025 06:25:25 PM CDT,"class Solution:
    def pivotIndex(self, nums: List[int]) -> int:

        totalSum = sum(nums)
        runningSum = 0
        
        for i in range(len(nums)):
            leftSum = runningSum
            rightSum = totalSum - runningSum - nums[i]
            if leftSum == rightSum:
                return i
            runningSum += nums[i]

        return -1"
ApVVa3yN,HW 4_1_2,rukvir,C#,Saturday 15th of March 2025 05:54:23 PM CDT,"using System;

namespace HomeWork
{
    class Program
    {
        static void Main(string[] args)
        {
            int columnMatrix = 10;
            int lineMatrix = 10;
            int minNumberMatrix = -10;
            int maxNumberMatrix = 11;
            int[,] userMatrix = new int[lineMatrix, columnMatrix];
            Random random = new Random();

            int maxElement = minNumberMatrix;
            int swapElement = 00;

            for (int i = 0; i < userMatrix.GetLength(0); i++)
            {
                for (int j = 0; j < userMatrix.GetLength(1); j++)
                {
                    userMatrix[i, j] = random.Next(minNumberMatrix, maxNumberMatrix);
                    Console.Write($""{userMatrix[i, j]}\t"");
                }
                Console.WriteLine(""\n"");
            }

            for (int i = 0; i < userMatrix.GetLength(0); i++)
            {
                for (int j = 0; j < userMatrix.GetLength(1); j++)
                {
                    if (maxElement < userMatrix[i, j])
                    {
                        maxElement = userMatrix[i, j];
                    }
                }
            }

            Console.WriteLine(""\n================================"");
            Console.WriteLine($"" Cамый большой элемент: {maxElement} ."");
            Console.WriteLine(""================================\n"");

            for (int i = 1; i < userMatrix.GetLength(0); i++)
            {
                for (int j = 1; j < userMatrix.GetLength(1); j++)
                {
                    if (userMatrix[i, j] == maxElement)
                    {
                        userMatrix[i, j] = swapElement;
                        Console.Write($""{userMatrix[i, j]}\t"");
                    }
                    else
                        Console.Write($""{userMatrix[i, j]}\t"");
                }
                Console.WriteLine(""\n"");
            }

            Console.ReadKey();
        }
    }
}"
td5Ey1YM,modpack_version_updater,A4ivi4,XML,Saturday 15th of March 2025 04:34:11 PM CDT,"<?xml version=""1.0"" encoding=""utf-8"" standalone=""yes""?>
<hmpReleaseInfo.xml>

  <uk>
    <enabled>true</enabled>
    <version>4.2 читай нижче про 
                              оновлення</version>
    <changes>
Версія #1.2.34, від 09.03.2025:
                  • Оновлено для патча 1.28.0.0. 
                       1)  •В МЕНЕДЖЕРІ АНГАРІВ НЕ ПРАЦЮЄ МАКОВЕ
                                     ПОЛЕ
                           2)  • ОНОЛЕНО СЕСІЙНУ СТАТИСТИКУ  9.03.2025
                           3)  • ДОДАНО АВТОМАТИЧНЕ ПОВЕРНЕННЯ 
                                     ОБЛАДНАННЯ
                                      УВАГА! ПРАЦЮЄ ТІЛЬКИ З WOT +
                                     ТА БЕЗ УВІМКНЕНОГО  В МОДПАКОВІ  ХВМ!  
                              4)  • ОНОВЛЕНО ПОКАЗНИК WN8 НА ВСІ ТАНКИ 
             
            
            

    </changes>
    <forumTheme></forumTheme>
    <downloadLink>https://habwotmods.pp.ua/</downloadLink>
    <modsBlackList>
    </modsBlackList>
    <xvm>
      <isReleaseAvailable>False</isReleaseAvailable>
      <releaseVersionURL>https://dl1.modxvm.com/release/xvm_10.2.1.zip</releaseVersionURL>
      <nightlyVersionURL>https://nightly.modxvm.com/download/master/xvm_latest.zip</nightlyVersionURL>
    </xvm>
  </uk>

  <en>
    <enabled>true</enabled>
    <version>4.2</version>
    <changes>
Version #1.2.34, date 09.03.2025:
 • updated: patch 1.28.0.0.
    • Updated:
                             

             • ADDED AUTOMATIC EQUIPMENT RETURN
                                     WARNING! ONLY WORKS WITH WOT + AND WITHOUT ENABLED 
                                   IN MODPAKOV KhVM 

                                  • UPDATED WN8 INDICATOR FOR ALL TANKS
   
   

    </changes>
    <forumTheme></forumTheme>
    <downloadLink>https://habwotmods.pp.ua/</downloadLink>
    <modsBlackList>
    </modsBlackList>
    <xvm>
      <isReleaseAvailable>False</isReleaseAvailable>
      <releaseVersionURL>https://dl1.modxvm.com/release/xvm_10.2.1.zip</releaseVersionURL>
      <nightlyVersionURL>https://nightly.modxvm.com/download/master/xvm_latest.zip</nightlyVersionURL>
    </xvm>
  </en>

  <ru>
    <enabled>true</enabled>
    <version>4.2</version>
    <changes>
Версия #1.2.34, от 09.03.2025:
   • Сборка обновлена для 1.28.0.0.
       • Обновлено:
                                 • Добавлено АВТОМАТИЧЕСКОЕ ВОЗВРАЩЕНИЕ ОБОРУДОВАНИЯ
                                     ВНИМАНИЕ! РАБОТАЕТ ТОЛЬКО С WOT + И БЕЗ ВКЛЮЧЕННОГО 
                                   В МОДПАКОВЕ ХВМ 

                                  • ОБНОВЛЕН ПОКАЗАТЕЛЬ WN8 НА ВСЕ ТАНКИ


    </changes>
    <forumTheme></forumTheme>
    <downloadLink>https://habwotmods.pp.ua/</downloadLink>
    <modsBlackList>
    </modsBlackList>
    <xvm>
      <isReleaseAvailable>False</isReleaseAvailable>
      <releaseVersionURL>https://dl1.modxvm.com/release/xvm_10.2.1.zip</releaseVersionURL>
      <nightlyVersionURL>https://nightly.modxvm.com/download/master/xvm_latest.zip</nightlyVersionURL>
    </xvm>
  </ru>

</hmpReleaseInfo.xml>
"
9D2Qt3Xh,Sakuna Moveset Made by 7S_TH34RCHY kit by slelrkfodos,Nuggetthe1,Lua,Saturday 15th of March 2025 03:54:25 PM CDT,"-- Sakuna
-- Limited

-- Moves 1 Name  
local player = game.Players.LocalPlayer  
local playerGui = player.PlayerGui  
local hotbar = playerGui:FindFirstChild(""Hotbar"")  
local backpack = hotbar:FindFirstChild(""Backpack"")  
local hotbarFrame = backpack:FindFirstChild(""Hotbar"")  
local baseButton = hotbarFrame:FindFirstChild(""1"").Base  
local ToolName = baseButton.ToolName  
ToolName.Text = ""Dismantle""  

-- Moves 2 Name  
local player = game.Players.LocalPlayer  
local playerGui = player.PlayerGui  
local hotbar = playerGui:FindFirstChild(""Hotbar"")  
local backpack = hotbar:FindFirstChild(""Backpack"")  
local hotbarFrame = backpack:FindFirstChild(""Hotbar"")  
local baseButton = hotbarFrame:FindFirstChild(""2"").Base  
local ToolName = baseButton.ToolName  
ToolName.Text = ""Cleave Combo""  

-- Moves 3 Name  
local player = game.Players.LocalPlayer  
local playerGui = player.PlayerGui  
local hotbar = playerGui:FindFirstChild(""Hotbar"")  
local backpack = hotbar:FindFirstChild(""Backpack"")  
local hotbarFrame = backpack:FindFirstChild(""Hotbar"")  
local baseButton = hotbarFrame:FindFirstChild(""3"").Base  
local ToolName = baseButton.ToolName  
ToolName.Text = ""Cleave Dash""  

-- Moves 4 Name  
local player = game.Players.LocalPlayer  
local playerGui = player.PlayerGui  
local hotbar = playerGui:FindFirstChild(""Hotbar"")  
local backpack = hotbar:FindFirstChild(""Backpack"")  
local hotbarFrame = backpack:FindFirstChild(""Hotbar"")  
local baseButton = hotbarFrame:FindFirstChild(""4"").Base  
local ToolName = baseButton.ToolName  
ToolName.Text = ""Dismantling counter""  

local Players = game:GetService(""Players"")  
local player = Players.LocalPlayer  
local playerGui = player:WaitForChild(""PlayerGui"")  

-- Ult here  
local function findGuiAndSetText()  
    local screenGui = playerGui:FindFirstChild(""ScreenGui"")  
    if screenGui then  
        local magicHealthFrame = screenGui:FindFirstChild(""MagicHealth"")  
        if magicHealthFrame then  
            local textLabel = magicHealthFrame:FindFirstChild(""TextLabel"")  
            if textLabel then  
                textLabel.Text = ""Made In Hell""  
            end  
        end  
    end  
end  

playerGui.DescendantAdded:Connect(findGuiAndSetText)  
findGuiAndSetText()  

-- Moves  

-- Move 1 here  
local animationId = 15290930205  
local player = game.Players.LocalPlayer  
local character = player.Character or player.CharacterAdded:Wait()  
local humanoid = character:WaitForChild(""Humanoid"")  

local function onAnimationPlayed(animationTrack)  
    if animationTrack.Animation.AnimationId == ""rbxassetid://"" .. animationId then  
        local p = game.Players.LocalPlayer  
        local Humanoid = p.Character:WaitForChild(""Humanoid"")  
        for _, animTrack in pairs(Humanoid:GetPlayingAnimationTracks()) do  
            animTrack:Stop()  
        end  
        local AnimAnim = Instance.new(""Animation"")  
        AnimAnim.AnimationId = ""rbxassetid://13071982935""  
        local Anim = Humanoid:LoadAnimation(AnimAnim)  
        local startTime = 0  
        Anim:Play(0)  
        Anim:AdjustSpeed(0)  
        Anim.TimePosition = startTime  
        Anim:AdjustSpeed(1)  
    end  
end  

-- Move 2 here  
humanoid.AnimationPlayed:Connect(onAnimationPlayed)  

local animationId = 15145462680  
local player = game.Players.LocalPlayer  
local character = player.Character or player.CharacterAdded:Wait()  
local humanoid = character:WaitForChild(""Humanoid"")  

local function onAnimationPlayed(animationTrack)  
    if animationTrack.Animation.AnimationId == ""rbxassetid://"" .. animationId then  
        local p = game.Players.LocalPlayer  
        local Humanoid = p.Character:WaitForChild(""Humanoid"")  
        for _, animTrack in pairs(Humanoid:GetPlayingAnimationTracks()) do  
            animTrack:Stop()  
        end  
        local AnimAnim = Instance.new(""Animation"")  
        AnimAnim.AnimationId = ""rbxassetid://13073745835""  
        local Anim = Humanoid:LoadAnimation(AnimAnim)  
        local startTime = 0  
        Anim:Play()  
        Anim:AdjustSpeed(0.5)  
        Anim.TimePosition = startTime  
        Anim:AdjustSpeed(1)  
    end  
end  

-- Move 3 here  
humanoid.AnimationPlayed:Connect(onAnimationPlayed)  

local animationId = 18716871856  
local player = game.Players.LocalPlayer  
local character = player.Character or player.CharacterAdded:Wait()  
local humanoid = character:WaitForChild(""Humanoid"")  

local function onAnimationPlayed(animationTrack)  
    if animationTrack.Animation.AnimationId == ""rbxassetid://"" .. animationId then  
        local p = game.Players.LocalPlayer  
        local Humanoid = p.Character:WaitForChild(""Humanoid"")  
        for _, animTrack in pairs(Humanoid:GetPlayingAnimationTracks()) do  
            animTrack:Stop()  
        end  
        local AnimAnim = Instance.new(""Animation"")  
        AnimAnim.AnimationId = ""rbxassetid://13073745835""  
        local Anim = Humanoid:LoadAnimation(AnimAnim)  
        local startTime = 0  
        Anim:Play()  
        Anim:AdjustSpeed(1)  
        Anim.TimePosition = startTime  
        Anim:AdjustSpeed(1.1)  
        delay(1.8, function()  
            Anim:Stop()  
        end)  
    end  
end  

-- Move 4 here  
humanoid.AnimationPlayed:Connect(onAnimationPlayed)  

local animationId = 15311685628  
local player = game.Players.LocalPlayer  
local character = player.Character or player.CharacterAdded:Wait()  
local humanoid = character:WaitForChild(""Humanoid"")  

local function onAnimationPlayed(animationTrack)  
    if animationTrack.Animation.AnimationId == ""rbxassetid://"" .. animationId then  
        local p = game.Players.LocalPlayer  
        local Humanoid = p.Character:WaitForChild(""Humanoid"")  
        for _, animTrack in pairs(Humanoid:GetPlayingAnimationTracks()) do  
            animTrack:Stop()  
        end  
        local AnimAnim = Instance.new(""Animation"")  
        AnimAnim.AnimationId = ""rbxassetid://15290930205""  
        local Anim = Humanoid:LoadAnimation(AnimAnim)  
        local startTime = 0  
        Anim:Play()  
        Anim:AdjustSpeed(0)  
        Anim.TimePosition = startTime  
        Anim:AdjustSpeed(1)  
    end  
end  

player.CharacterAdded:Connect(function(newCharacter)  
    character = newCharacter  
    humanoidRootPart = character:WaitForChild(""HumanoidRootPart"")  
    character.DescendantAdded:Connect(onBodyVelocityAdded)  
    for _, descendant in pairs(character:GetDescendants()) do  
        onBodyVelocityAdded(descendant)  
    end  
end)  "
bKb7fkJs,Source Script 1,OverclockedGD,Lua,Saturday 15th of March 2025 03:53:06 PM CDT,"print(2 + 2)
print(""Hello!, World"")"
WfgqVHGa,BWR - Changelog 15/03/25,SSilver,Diff,Saturday 15th of March 2025 03:46:49 PM CDT,"Panic Attack
- Alt-Fire starts with a -15% accuracy penalty
Alt-fire's burst of damage is a bit too effective in gunning down enemies especially with the more consistent damage making it applicable in a fairly decent range. The base spread on it was increased to force it's users to close in closer to enemies to get the most out of this ability.

Mad Milk, Gas Passer, Jarate
  Corrected recharge on extinguishing teammates to be -33%
Fixing an inconsistency to the improvement on this method of recharging the jars, still improved over vanilla but not inconsistently a much higher refund.

The Shortstop
+ Increased max ramp up to 175% (was 150%)
- Reduced base damage to 10.5 per pellet (was 12)
A rather frequent complaint about fighting the weapon was it's consistent damage dealing, particularly with the buff to it's reload. However rather than make the weapon more clunky for the user while dishing the same damage in spurts, this change was made to rein in it's damage overall if just slightly to make it less potent but still consistent. It's damage up close however was increased to not punish the scout using it in a less than ideal range compared to it's alternatives.

Flying Guillotine
+ Added: Recharges to full on-kill with any weapon
- Removed faster recharge on long range hits
- Increased base recharge rate to 10 seconds (was 8 seconds)
- Removed mini-crits on long range hits
More further changes to the weapon to discourage it's usage in long range spam, an interaction that was relatively riskless for the Scout with a faster recharge and little retaliation from the enemies. This new upside however should better reward scouts more proactive in using the weapon in using it to either open or close out fights.

B.A.S.E. Jumper
- Reduced blast jump damage resistance to -15% (was -25%)
- Reduced damage to deplete CHUTE to 80 (was 100)
The bonus to blast jumping allowed for a few too many extra jumps to take advantage of the height on-demand. This was reduced slightly, along with reducing damage to close the CHUTE to make incoming chip shots a more effective counter.

Huo-Long Heater
+ Increased blast radius of explosion on-kill by 10%
  Kills with the weapon will leave enemies ignited
A slight improvement to the weapon's consistency in forcing enemies to disperse and punish larger groups.

The Classic
+ Crits now occur above 90% charge (was at 100%)
+ Added +100% faster move speed while charging
- Removed clip size bonus (+50%)
The slowness of the weapon was still a bit of a concern. To ameleriate this, the window for headshots was made slightly less strict, in addition to making the weapon less of a slog to hold while charging (about on par with the Huntsman). As compensation for making it less slow, it's clip was reverted in order to make using the weapon less sustainable before reloading.

The Razorback
+ Damage over time effects are nullified when the shield is broken
+ Damage vulnerabilities no longer bypass lethal damage protection
Improvements to the consistency of using the weapon, while also making it safer against bleed and afterburn after weapons that provide it.

The Bushwacka
+ Increased mark for death on hit to 3 seconds (was 2 seconds)
The window was a little strict in how you could follow-up your own hit, thus was increased without being too extreme.

Revolvers
  Spread reset no longer occurs linearly, just resets after 1 second
+ Added 15% accuracy bonus (equivalent to former accuracy bonus from linear reset)
The wonkiness of non-headshot headshots being counted was rather troublesome to work with, as was using the scaling crosshair for anything but the revolver meant to revolve around said headshots. Thus the weapons were more straightforwardly improved in their accuracy.

Disguises
  Gaining disguise no longer misapplies attributes to the Spy
A problem that was causing your items to provide the wrong attributes based on what disguise you took.

The Enforcer
+ Increased damage bonus while disguised to +30% (was +20%)
+ Removed increase in decloak time (was +0.5 sec)
- Added +20% cloak drain rate
The weapon's upsides and downside was reevaluated to provide something less intrusive for when you choose to decloak but more beffitting a weapon that relies more on your disguise, and for encouraing direct usage of the weapon to get out of a jam rather than cloaking ASAP."
KWjif17y,Sorted Union Challenge,Fire_Ice_Shock,JavaScript,Saturday 15th of March 2025 03:39:03 PM CDT,"function uniteUnique(arr, ...restOfArr) {
//To solve the 'Sorted Union' challenge, I would start off with: 

//First is to consider any numbers or elements from any array that has a duplicate element from another array. A copy of any number is a duplicate. An array can have some numbers that are a copy of another; I would need to return only one array with each different number from the element's normal index order. The ordering of element values in the array from least to greatest or greatest to least would not matter. Only the order of their numerical position. 

//I can start off by defining two new empty arrays. One array is for pushing in the 'arr' elements. The variable would be given a name as 'newArray' and the other is for pushing each number from 'arr.' The second variable is named 'newArray2.' 

//Secondly, I also have to consider if all of the given arrays represent more than one parameter or not. If I debug 'arr,' I notice that there is only one array passing as an argument to 'arr.'...restOfArr' represents the rest of the arrays. 

//Thirdly, I would think of how I can compare and contrast each element in a single array, and then I would think of how to compare and contrast each element from one array to every other array passing into the 'arr' and the rest parameter as their arguments. 

//To do that, I can try to merge all of the given arrays to become one array with all of their elements. 

//Here are my suggestions or options: 

//• I can use the filter method because with the 'filter' method, all it takes is setting an equality or inequality statement that gets rid of duplicates.

//• I can use the 'reduce' method to merge all of the given arrays from 'arr' and the rest of the parameters into one array. One thing about what 'reduce' does is take every element from a single array and add all the numbers as its total. The 'reduce' method would not give me the returning output that I would need. The result needs me to return each number of all given arrays from its argument values passed to all of its parameters.

//• I can use the 'push' method to push in every given array from 'arr' and from the rest. Then, use the 'map' method.

//• I can use the concept of destructuring to take each element from an array and give each of them a variable to be packed into an array.

//• I can use the 'forEach' method to iterate through each element from 'arr.' Then, use the 'push' method to add every number to 'newArray2.'

//• I can use the 'toSpliced' method to begin with the starting number and then delete that starting number.

//Next, I would define a counter for all of the duplicates. No duplicates or more copies should be in 'newArray2.'

  let count = 0;
  
  console.log(""""); //Skipping a linespace.
  console.log(arr); //Logging 'arr'.
  console.log(...restOfArr); //Logging the rest of 'arr'.

  let newArray = [], newArray2 = [];
  newArray.push(arr,...restOfArr);
  
  //console.log(""My"", `${stringName}`, ""array:"", newArray, ""\n""); //'stringName' is the name of how many times I am reusing 'uniteUnique' to pass arrays as an argument.

  //I am using the 'forEach' method to make sure I pass every element-value into 'newArray2' by iterating all of the elements from 'newArray'.

  let forEachElementFromArrAndRestOfArr = newArray.forEach(function(arrayOfIntegers,integerIndex) {
    console.log(""\nNumerical position: "" + integerIndex + "", "" + ""Current array: "" + ""["" + arrayOfIntegers + ""]"");
    arrayOfIntegers.forEach(function(num,i)
    {
        console.log(""\nCurrent number: "" + arrayOfIntegers[i]);
        
        //For every different number, I would try to push each of them into 'newArray2'(the variable is a second new array).
        //I think using an if-statement is a good idea to compare each number to every other number from 'newArray2'.
        
        newArray2.push(num);
        console.log(newArray2);
        count += 1;
        console.log(""Number count: "" + count);
    }
  )})

  console.log(""\n\nLength of 'newArray2': "" + newArray2.length);
  if(count === newArray2.length)
  {

    //For line 59 to 61, I would use two variable as two pointers. Each of them are use as values for two elements from 'newArray2'. 'pointer1' is use for every element starting at index equals to zero and 'pointer2' is use as a variable for the last element starting at index equals to the length of 'newArray2' minus 1.

    //Both of them would be use to iterate through 'newArray2'.

      let pointer1, pointer2;
      [pointer1,pointer2] = [0,newArray2.length-1];
      console.log(""'newArray2': "", newArray2);

      //Line 63 and below this program, I would be comparing the first number to all of the numbers after the first, before comparing the second number to all the next numbers in 'newArray2'.
      
      newArray2.forEach(function(numberElement,pointer1,callbackNewArray2) {

        console.log(""\nLength of 'newArray2 for index': "", newArray2.length-1, ""\n"");
        console.log(""\nIndex from 'forEach': "" + pointer1 + ""\nIndex pointer 1: "" + pointer1, ""\nIndex pointer 2: "" + pointer2);
        console.log(""\nIs 'newArray2[pointer1]' strictly equal to 'newArray2[pointer2]'? "" + ""\nnumber: "" + newArray2[pointer1] + "" === "" +""number: "" + newArray2[pointer2]); //Is the boolean condition true or false? Comparing first number to the call back number.
        console.log(""\nIs 'callbackNewArray2[pointer1]' the same as 'newArray2[pointer1]'. Also for 'callbackNewArray2[pointer2]' and 'newArray2[pointer2]'?\n"" + callbackNewArray2[pointer1] + "" : "" + newArray2[pointer1] + ""\n"" + callbackNewArray2[pointer2], "":"", newArray2[pointer2]);

        newArray2.forEach(function(numberElement,index,callbackNewArray2) {

        if((callbackNewArray2[pointer1] === callbackNewArray2[pointer2])) //If boolean condition is true for 'newArray2[pointer1] === newArray2[pointer2]'.
        {
          console.log(""Comparing to find an equality for: "" + callbackNewArray2[pointer1] + "" to "" + callbackNewArray2[pointer2]);
          if(pointer1 !== pointer2)
          {
            newArray2.splice(pointer2,1);
            console.log(newArray2);
            pointer2 -= 1;
          }
          else if(pointer1 === pointer2)
          {
            pointer1 += 1, pointer2 += newArray2.length-1;
          }
        }
        else if((callbackNewArray2[pointer1] !== callbackNewArray2[pointer2]))
        {
          if(pointer1 !== pointer2)
          {
            pointer2 -= 1;
          }
          else if(pointer1 === pointer2)
          {
            pointer1 += 1, pointer2 += newArray2.length-1;
          }
        }

        })

      })

  }
  
  console.log(newArray2);
  return newArray2;
}

//Uncommenting the function calls are permitted, but do not change any of the function's code below or uncomment the expected output below this line. If their is any error(s) from the expected output, I will try to correct any errors from the expected output. The expected output should return a single array with one for each different number in the element's natural order. 
//Five tests are needed to pass this challenge.

//uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
//Expected output: [1, 3, 2, 5, 4]

uniteUnique([1, 2, 3], [5, 2, 1]);
//Expected output: [1, 2, 3, 5]

//uniteUnique([1, 2, 3], [5, 2, 1, 4], [2, 1], [6, 7, 8]);
//Expected output: [1, 2, 3, 5, 4, 6, 7, 8]

//uniteUnique([1, 3, 2], [5, 4], [5, 6]);
//Expected output: [1, 3, 2, 5, 4, 6]

//uniteUnique([1, 3, 2, 3], [5, 2, 1, 4], [2, 1]);
//Expected output: [1, 3, 2, 5, 4]"
zfT8pCvc,Untitled,LA77,C,Saturday 15th of March 2025 03:08:17 PM CDT,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_FILENAME 65

typedef struct SharedContent {
    char *data;
    int refcount;
} SharedContent;

typedef struct Inode {
    char name[MAX_FILENAME]; 
    bool is_directory;
    bool is_symlink;
    SharedContent *shared;
    struct Inode *parent;
    struct Inode *children;
    struct Inode *next;
} Inode;

Inode *root;
Inode *cwd;

void init_filesystem(void);
void free_inode(Inode *inode);
SharedContent* create_shared_content(const char *initial);
Inode* find_inode_no_symlink(const char *path);
Inode* find_inode_follow(const char *path);
void cmd_ls(char *path);
void cmd_cd(char *path);
void cmd_cat(char *filePath);
void cmd_echo(char *text, char *filename, bool append);
void cmd_touch_single(char *filename);
void cmd_touch(char *args);
void cmd_mkdir(char *args);
void cmd_rm(char *params);
void cmd_find(Inode *dir, const char *path);
void cmd_ln(char *path1, char *path2, bool hard);
void cmd_ln_symlink(char *targetPath, char *linkPath);
void cmd_cp(char *s1, char *s2, bool recursive);
void cmd_mv(char *path1, char *path2);
void process_command(char *command);
void shell_loop(void);


void init_filesystem() {
    root = (Inode*)calloc(1, sizeof(Inode));
    // Root’s name can be just ""/""
    strncpy(root->name, ""/"", MAX_FILENAME - 1);
    root->name[MAX_FILENAME - 1] = '\0';
    root->is_directory = true;
    root->is_symlink   = false;
    root->shared       = NULL;
    root->parent       = root;   

    cwd = root;
}

void free_inode(Inode *inode) {

    if (inode->shared) {
        inode->shared->refcount--;
        if (inode->shared->refcount <= 0) {
            free(inode->shared->data);
            free(inode->shared);
        }
    }
    free(inode);
}

SharedContent* create_shared_content(const char *initial) {
    SharedContent *sc = (SharedContent*)malloc(sizeof(SharedContent));
    sc->refcount = 1;
    if (initial) {
        sc->data = (char*)malloc(strlen(initial) + 1);
        strcpy(sc->data, initial);
    } else {
        sc->data = NULL;
    }
    return sc;
}

static void remove_from_parent(Inode *inode);
static void rm_recursive(Inode *inode);


static void remove_from_parent(Inode *inode) {
    if (!inode || !inode->parent) return;
    Inode *p = inode->parent;

    // If it’s the first child
    if (p->children == inode) {
        p->children = inode->next;
    } else {
        // Otherwise find it
        Inode *cur = p->children;
        while (cur && cur->next != inode) {
            cur = cur->next;
        }
        if (cur) {
            cur->next = inode->next;
        }
    }
    inode->parent = NULL;
    inode->next   = NULL;
}

static void rm_recursive(Inode *inode) {
    if (!inode) return;

    // If directory with children, remove them first
    if (inode->is_directory && inode->children) {
        Inode *child = inode->children;
        while (child) {
            Inode *nxt = child->next;
            rm_recursive(child);
            child = nxt;
        }
    }

    if(inode == cwd)
    {
        cwd = root;
    }

    remove_from_parent(inode);
    free_inode(inode);
}


static Inode* linear_find_child(Inode *parent, const char *name) {
    if (!parent->is_directory) return NULL;
    Inode *child = parent->children;
    while (child) {
        if (strcmp(child->name, name) == 0) {
            return child;
        }
        child = child->next;
    }
    return NULL;
}


Inode* find_inode_no_symlink(const char *path) {
    if (!path) return NULL;
    if (!*path) return cwd;  

    // Make a copy for strtok
    char *path_copy = (char*)malloc(strlen(path) + 1);
    strcpy(path_copy, path);

    // If path starts with '/', we begin at root, else at cwd
    Inode *current = (path_copy[0] == '/') ? root : cwd;

    // Tokenize
    char *component = strtok(path_copy, ""/"");
    if (!component && path_copy[0] == '/') {
        free(path_copy);
        return root;
    }

    while (component) {
        if (strcmp(component, ""."") == 0) {
            // stay
        } else if (strcmp(component, "".."") == 0) {
            if (current != root)
                current = current->parent;
        } else {
            // find a child
            Inode *child = linear_find_child(current, component);
            if (!child) {
                free(path_copy);
                return NULL;
            }
            current = child;
        }
        component = strtok(NULL, ""/"");
    }
    free(path_copy);
    return current;
}

// Like find_inode_no_symlink but if the final Inode is a symlink, follow it repeatedly (up to 100).
Inode* find_inode_follow(const char *path) {
    if (!path) return NULL;
    Inode *node = find_inode_no_symlink(path);
    if (!node) return NULL;

    int symlink_depth = 0;
    while (node->is_symlink) {
        if (!node->shared || !node->shared->data) {
            // broken symlink
            return NULL;
        }
        if (++symlink_depth > 100) {
            // protect from infinite loops
            return NULL;
        }
        
        char *linkTarget = node->shared->data;
        bool isAbs = (linkTarget[0] == '/');
        Inode *startDir = isAbs ? root : node->parent;

        // temporarily treat startDir as ""cwd""
        Inode *oldCwd = cwd;
        cwd = startDir;
        Inode *resolved = find_inode_no_symlink(linkTarget);
        cwd = oldCwd;
        if (!resolved) return NULL;
        node = resolved;
    }
    return node;
}

static int cstring_cmp(const void *p1, const void *p2) {
    const char *s1 = *(const char **)p1;
    const char *s2 = *(const char **)p2;
    return strcmp(s1, s2);
}

static int inode_name_cmp(const void *p1, const void *p2) {
    const Inode *i1 = *(const Inode **)p1;
    const Inode *i2 = *(const Inode **)p2;
    return strcmp(i1->name, i2->name);
}

// ----------------------------------------------------------------
// Commands
// ----------------------------------------------------------------

void cmd_ls(char *path) {
    Inode *dir = cwd;
    if (path && *path) {
        Inode *maybe = find_inode_follow(path);
        if (!maybe) return; // invalid path => no output
        if (!maybe->is_directory) {
            
            printf(""%s\n"", maybe->name);
            return;
        }
        dir = maybe;
    }
    // Count children
    int count = 0;
    Inode *child = dir->children;
    while (child) {
        count++;
        child = child->next;
    }
    if (count == 0) return;

    // Gather child->name in array
    char **names = (char**)malloc(count * sizeof(char*));
    child = dir->children;
    for (int i=0; i<count; i++) {
        names[i] = child->name; 
        child = child->next;
    }
    qsort(names, count, sizeof(char*), cstring_cmp);

    for (int i=0; i<count; i++) {
        printf(""%s\n"", names[i]);
    }
    free(names);
}

void cmd_cd(char *path) {
    if (!path || !*path) {
        // cd with no args => go to root
        cwd = root;
        return;
    }
    Inode *dest = find_inode_follow(path);
    if (dest && dest->is_directory) {
        cwd = dest;
    }
}

void cmd_cat(char *filePath) {
    if (!filePath) return;
    Inode *f = find_inode_follow(filePath);
    if (!f) return;  // doesn’t exist
    if (f->is_directory) return; // cat on a directory => do nothing
    if (f->shared && f->shared->data) {
        printf(""%s\n"", f->shared->data);
    }
}

// Helper for echo overwrite
static void echo_overwrite(char *text, char *filename) {
    if (!text || !filename) return;
    Inode *f = find_inode_follow(filename);
    if (!f) {
        
        Inode *maybe = find_inode_no_symlink(filename);
        if (!maybe) {

            cmd_touch_single(filename);
            f = find_inode_follow(filename);
            if (!f) return;
        } else {
            
            return;
        }
    }
    if (f->is_directory) return;

    if (!f->shared) {
        f->shared = create_shared_content(NULL);
    } else if (f->shared->data) {
        free(f->shared->data);
        f->shared->data = NULL;
    }
    f->shared->data = (char*)malloc(strlen(text)+1);
    strcpy(f->shared->data, text);
}

static void echo_add(char *text, char *filename) {
    if (!text || !filename) return;
    Inode *f = find_inode_follow(filename);
    if (!f) {
        Inode *maybe = find_inode_no_symlink(filename);
        if (!maybe) {
            cmd_touch_single(filename);
            f = find_inode_follow(filename);
            if (!f) return;
        } else {
            return;
        }
    }
    if (f->is_directory) return;

    if (!f->shared) {
        f->shared = create_shared_content(NULL);
    }
    if (!f->shared->data) {
        f->shared->data = (char*)malloc(strlen(text)+1);
        strcpy(f->shared->data, text);
    } else {
        size_t oldlen = strlen(f->shared->data);
        size_t newlen = oldlen + strlen(text) + 1;
        char *new_data = (char*)realloc(f->shared->data, newlen);
        if (!new_data) {
            
            free(f->shared->data);
            f->shared->data = NULL;
            return;
        }
        f->shared->data = new_data;
        strcat(f->shared->data, text);
    }
}

void cmd_echo(char *text, char *filename, bool append) {
    if (!text || !filename) return;
    if (!append) {
        echo_overwrite(text, filename);
    } else {
        echo_add(text, filename);
    }
}

void cmd_touch_single(char *filename) {
    if (!filename || !*filename) return;
    Inode *exists = find_inode_no_symlink(filename);
    if (exists) return;

    int idx = -1;
    size_t len = strlen(filename);
    for (size_t i = 0; i < len; i++) {
        if (filename[i] == '/') idx = i;
    }

    char *dir_path = NULL;
    char *base_name = NULL;
    if (idx != -1) {
        if (idx == 0) {
            dir_path = strdup(""/"");
        } else {
            dir_path = (char*)malloc(idx + 1);
            if (dir_path) {
                strncpy(dir_path, filename, idx);
                dir_path[idx] = '\0';
            }
        }
        base_name = strdup(filename + idx + 1);
    } else {
        dir_path = strdup("""");
        base_name = strdup(filename);
    }

    Inode *parent_dir = find_inode_no_symlink(dir_path);
    if (!parent_dir) {
        parent_dir = cwd;
    }
    if (!parent_dir->is_directory) {
        free(dir_path);
        free(base_name);
        return;
    }

    Inode *newf = (Inode*)malloc(sizeof(Inode));
    memset(newf, 0, sizeof(Inode));
    strncpy(newf->name, base_name, MAX_FILENAME - 1);
    newf->name[MAX_FILENAME - 1] = '\0';
    newf->is_directory = false;
    newf->is_symlink   = false;
    newf->shared       = create_shared_content(NULL);
    newf->parent       = parent_dir;

    newf->next = parent_dir->children;
    parent_dir->children = newf;

    free(dir_path);
    free(base_name);
}


void cmd_touch(char *args) {
    if (!args || !*args) return;
    char *args_copy = strdup(args);
    char *save;
    char *token = strtok_r(args_copy, "" "", &save);
    while (token) {
        cmd_touch_single(token);
        token = strtok_r(NULL, "" "", &save);
    }
    free(args_copy);
}

void _mkdir(char *dirname) {

    char *copy = malloc((strlen(dirname) + 1) * sizeof(char));
    strcpy(copy, dirname);

    Inode *current = (copy[0] == '/') ? root : cwd;
    char *save;
    char *component = strtok_r(copy, ""/"", &save);
    while (component) {
        if (strcmp(component, ""."") == 0) {
        } else if (strcmp(component, "".."") == 0) {
            if (current != root) current = current->parent;
        } else {

            Inode *scan = current->children;
            Inode *found = NULL;
            while (scan) {
                if (scan->is_directory && strcmp(scan->name, component) == 0) {
                    found = scan;
                    break;
                }
                scan = scan->next;
            }
            if (found) {
                current = found;
            } else {
                Inode *newd = (Inode*)calloc(1, sizeof(Inode));

                strncpy(newd->name, component, MAX_FILENAME - 1);
                newd->name[MAX_FILENAME - 1] = '\0';
                newd->is_directory = true;
                newd->is_symlink   = false;
                newd->parent       = current;
                newd->next         = current->children;
                current->children  = newd;
                current = newd;
            }
        }
        component = strtok_r(NULL, ""/"", &save);
    }
    free(copy);
}

void cmd_mkdir(char *args) {

    char *copy = malloc((strlen(args) + 1) * sizeof(char));
    strcpy(copy, args);
    char *save;
    char *token = strtok_r(copy, "" "", &save);
    while (token) {

        if (strcmp(token, ""-p"") == 0) {
        } else {
            _mkdir(token);
        }
        token = strtok_r(NULL, "" "", &save);
    }
    free(copy);
}

void cmd_rm(char *params) {
    if (!params || !*params) return;
    char *copy = strdup(params);
    char *p = copy;
    while (*p == ' ') p++;

    bool recursive_flag = false;
    if (strncmp(p, ""-r"", 2) == 0 && (p[2] == ' ' || p[2] == '\0')) {
        recursive_flag = true;
        p += 2;
        while (*p == ' ') p++;
    }

    while (*p) {
        char *start = p;
        while (*p && *p != ' ') p++;
        bool ended = false;
        if (*p == ' ') {
            *p = '\0';
            p++;
            ended = true;
        }
        if (*start) {

            Inode *target = find_inode_no_symlink(start);
            if (target) {
                if (target->is_directory && !recursive_flag) {

                } else {
                    rm_recursive(target);
                }
            }
        }
        while (*p == ' ') p++;
        if (!ended && !*p) break;
    }
    free(copy);
}


void cmd_find(Inode *dir, const char *path) {
    if (!dir || !path) return;

    if (strcmp(path, ""."") == 0) {
        printf("".\n"");
    }

    int count = 0;
    Inode *child = dir->children;
    while (child) {
        count++;
        child = child->next;
    }
    if (count == 0) return;

    Inode **arr = (Inode**)malloc(count * sizeof(Inode*));
    child = dir->children;
    for (int i = 0; i < count; i++) {
        arr[i] = child;
        child = child->next;
    }
    qsort(arr, count, sizeof(Inode*), inode_name_cmp);

    for (int i = 0; i < count; i++) {
        Inode *c = arr[i];
        size_t new_path_len = strlen(path) + 1 /* for ""/"" */ + strlen(c->name) + 1;
        char *new_path = (char*)malloc(new_path_len);
        if (!new_path) continue;
        snprintf(new_path, new_path_len, ""%s/%s"", path, c->name);
        printf(""%s\n"", new_path);
        if (c->is_directory) {
            cmd_find(c, new_path);
        }
        free(new_path);
    }
    free(arr);
}

void cmd_ln(char *path1, char *path2, bool hard) {
    // (void)hard;  // unused, but you can keep this line if needed
    if (!path1 || !path2) return;

    Inode *source = find_inode_no_symlink(path1);
    if (!source) return;
    if (source->is_directory) {
        return;  // The assignment disallows creating hard links to directories
    }
    
    // Find the slash position
    int idx = -1;
    int len = strlen(path2);
    for (int i = 0; i < len; i++) {
        if (path2[i] == '/') idx = (int)i;
    }
    
    // Allocate dir_path / base_name dynamically
    char *dir_path = NULL;
    char *base_name = NULL;

    if (idx != -1) {
        // path2 has at least one slash
        if (idx == 0) {
            // Leading slash => parent directory is ""/""
            dir_path = strdup(""/"");
        } else {
            // Copy everything up to idx
            dir_path = (char*)malloc(idx + 1);
            strncpy(dir_path, path2, idx);
            dir_path[idx] = '\0';
        }
        base_name = strdup(path2 + idx + 1);
    } else {
        // No slash => parent directory is "".""
        dir_path = strdup(""."");
        base_name = strdup(path2);
    }

    Inode *parent_dir = find_inode_no_symlink(dir_path);
    // If parent_dir does not exist, fallback to cwd
    if (!parent_dir) {
        parent_dir = cwd;
    }
    if (!parent_dir->is_directory) {
        free(dir_path);
        free(base_name);
        return;
    }

    // Create the new hard link inode
    Inode *new_link = (Inode*)calloc(1, sizeof(Inode));
    strncpy(new_link->name, base_name, MAX_FILENAME - 1);
    new_link->name[MAX_FILENAME - 1] = '\0';
    new_link->is_directory = false;
    new_link->is_symlink   = false;
    new_link->shared       = source->shared;  // share the file data
    if (new_link->shared) {
        new_link->shared->refcount++;
    }
    new_link->parent = parent_dir;
    new_link->next   = parent_dir->children;
    parent_dir->children = new_link;

    free(dir_path);
    free(base_name);
}

// Symlink creation
void cmd_ln_symlink(char *targetPath, char *linkPath) {
    if (!targetPath || !linkPath) return;

    int idx = -1;
    size_t len = strlen(linkPath);
    for (size_t i = 0; i < len; i++) {
        if (linkPath[i] == '/') idx = i;
    }
    char *dir_path = NULL;
    char *file_name = NULL;
    if (idx != -1) {
        if (idx == 0) {
            dir_path = strdup(""/"");
        } else {
            dir_path = (char*)malloc(idx + 1);
            if (dir_path) {
                strncpy(dir_path, linkPath, idx);
                dir_path[idx] = '\0';
            }
        }
        file_name = strdup(linkPath + idx + 1);
    } else {
        dir_path = strdup(""."");
        file_name = strdup(linkPath);
    }

    Inode *parent_dir = find_inode_no_symlink(dir_path);
    if (!parent_dir) parent_dir = cwd;
    if (!parent_dir->is_directory) {
        free(dir_path);
        free(file_name);
        return;
    }

    Inode *new_link = (Inode*)calloc(1, sizeof(Inode));
    strncpy(new_link->name, file_name, MAX_FILENAME - 1);
    new_link->name[MAX_FILENAME - 1] = '\0';
    new_link->is_directory = false;
    new_link->is_symlink   = true;
    new_link->shared       = create_shared_content(targetPath);
    new_link->parent       = parent_dir;
    new_link->next         = parent_dir->children;
    parent_dir->children   = new_link;

    free(dir_path);
    free(file_name);
}


static void copy_file(Inode *src, char *dest_path) {
    if (!src || !dest_path) return;

    Inode *dest = find_inode_no_symlink(dest_path);
    if (dest) rm_recursive(dest);

    cmd_touch_single(dest_path);
    dest = find_inode_no_symlink(dest_path);
    if (!dest) return; 
    if (src->shared && src->shared->data) {
        if (!dest->shared) {
            dest->shared = create_shared_content(NULL);
        } else {
            free(dest->shared->data);
            dest->shared->data = NULL;
        }
        dest->shared->data = (char*)malloc(strlen(src->shared->data)+1);
        strcpy(dest->shared->data, src->shared->data);
    }
}

static void copy_directory(Inode *src, Inode *dest_dir) {
    if (!src || !dest_dir) return;
    // For each child in src, replicate
    for (Inode *child = src->children; child; child = child->next) {
        if (child->is_directory) {
            Inode *nd = (Inode*)calloc(1, sizeof(Inode));
            strncpy(nd->name, child->name, MAX_FILENAME - 1);
            nd->name[MAX_FILENAME - 1] = '\0';
            nd->is_directory = true;
            nd->is_symlink   = false;
            nd->parent       = dest_dir;
            nd->next         = dest_dir->children;
            dest_dir->children = nd;
            copy_directory(child, nd);
        } else {
            Inode *nf = (Inode*)calloc(1, sizeof(Inode));
            strncpy(nf->name, child->name, MAX_FILENAME - 1);
            nf->name[MAX_FILENAME - 1] = '\0';
            nf->is_directory = false;
            nf->is_symlink   = child->is_symlink;
            nf->parent       = dest_dir;
            nf->next         = dest_dir->children;
            dest_dir->children = nf;

            if (child->shared && child->shared->data) {
                nf->shared = create_shared_content(child->shared->data);
            } else {
                nf->shared = create_shared_content(NULL);
            }
        }
    }
}

void cmd_cp(char *s1, char *s2, bool recursive) {
    if (!s1 || !s2) return;
    Inode *src = find_inode_follow(s1);
    if (!src) return;

    if (src->is_directory) {
        if (!recursive) return;
        Inode *dst = find_inode_no_symlink(s2);
        if (!dst) {
            // create it
            _mkdir(s2);
            dst = find_inode_no_symlink(s2);
            if (!dst) return;
        }
        copy_directory(src, dst);
    } else {
        // copy file
        copy_file(src, s2);
    }
}

void cmd_mv(char *path1, char *path2) {
    if (!path1 || !path2) return;
    Inode *file1 = find_inode_no_symlink(path1);
    if (!file1) return;

    int last_slash = -1;
    size_t len = strlen(path2);
    for (size_t i = 0; i < len; i++) {
        if (path2[i] == '/') last_slash = i;
    }
    char *dir_path = NULL;
    char *base_name = NULL;
    if (last_slash == -1) {
        dir_path = strdup(""."");
        base_name = strdup(path2);
    } else {
        if (last_slash == 0) {
            dir_path = strdup(""/"");
        } else {
            dir_path = (char*)malloc(last_slash + 1);
            if (dir_path) {
                strncpy(dir_path, path2, last_slash);
                dir_path[last_slash] = '\0';
            }
        }
        base_name = strdup(path2 + last_slash + 1);
    }

    Inode *new_parent = find_inode_no_symlink(dir_path);
    if (!new_parent) {
        free(dir_path);
        free(base_name);
        return;
    }
    if (!new_parent->is_directory) {
        free(dir_path);
        free(base_name);
        return;
    }

    Inode *c = new_parent->children;
    Inode *existing = NULL;
    while (c) {
        if (strcmp(c->name, base_name) == 0) {
            existing = c;
            break;
        }
        c = c->next;
    }
    if (existing) rm_recursive(existing);

    remove_from_parent(file1);
    memset(file1->name, 0, MAX_FILENAME);
    strncpy(file1->name, base_name, MAX_FILENAME - 1);
    file1->name[MAX_FILENAME - 1] = '\0';

    file1->parent = new_parent;
    file1->next = new_parent->children;
    new_parent->children = file1;

    free(dir_path);
    free(base_name);
}


void process_command(char *command) {

    char *localbuf = malloc((strlen(command) + 1) * sizeof(char));
    strcpy(localbuf, command);

    // printf(""LOCALBUF: %s\n\n"", localbuf);
    
    char *cmd = strtok(localbuf, "" "");
    if (!cmd) {
        return;
    }
    char *rest = strtok(NULL, """");
    if (rest) {
        while (*rest == ' ') rest++;
    }
    if (strcmp(cmd, ""ls"") == 0) {
        if (rest && *rest) cmd_ls(rest);
        else cmd_ls(NULL);
    }
    else if (strcmp(cmd, ""cd"") == 0) {
        if (rest && *rest) cmd_cd(rest);
        else cmd_cd(NULL);
    }
    else if (strcmp(cmd, ""cat"") == 0) {
        if (rest && *rest) cmd_cat(rest);
    }
    else if (strcmp(cmd, ""touch"") == 0) {
        if (rest && *rest) cmd_touch(rest);
    }
    else if (strcmp(cmd, ""echo"") == 0) {
        if (!rest || !*rest) {
            return;
        }
        char *quoteBegin = strchr(rest, '""');
        if (!quoteBegin) {
            return;
        }
        quoteBegin++;
        char *quoteEnd = strchr(quoteBegin, '""');
        if (!quoteEnd) {
            return;
        }
        *quoteEnd = '\0';
        char *afterQuote = quoteEnd + 1;
        while (*afterQuote == ' ') afterQuote++;
        if (!*afterQuote) {
            return;
        }
        char *redir = strtok(afterQuote, "" "");
        if (!redir) {
            return;
        }
        char *filename = strtok(NULL, "" "");
        if (!filename) {
            return;
        }
        bool append = (strcmp(redir, "">>"") == 0);
        cmd_echo(quoteBegin, filename, append);
    }
    else if (strcmp(cmd, ""mkdir"") == 0) {
        // if (rest && *rest) cmd_mkdir(rest);
    }
    else if (strcmp(cmd, ""rm"") == 0) {
        // if (rest && *rest) cmd_rm(rest);
    }
    else if (strcmp(cmd, ""find"") == 0) {
        // cmd_find(cwd, ""."");
    }
    else if (strcmp(cmd, ""cp"") == 0) {
        /*if (!rest || !*rest) {
            return;
        }
        char *local = strdup(rest);
        char *tok = strtok(local, "" "");
        if (!tok) {
            free(local);
            return;
        }
        bool recursive = false;
        if (strcmp(tok, ""-r"") == 0) {
            recursive = true;
            tok = strtok(NULL, "" "");
            if (!tok) {
                free(local);
                return;
            }
        }
        char *arg1 = tok;
        char *arg2 = strtok(NULL, """");
        if (!arg2 || !*arg2) {
            free(local);
            return;
        }
        while (*arg2 == ' ') arg2++;
        if (!*arg2) {
            free(local);
            return;
        }
        cmd_cp(arg1, arg2, recursive);
        free(local);*/
    }
    else if (strcmp(cmd, ""mv"") == 0) {
        /*if (!rest || !*rest) {
            return;
        }
        char *local = strdup(rest);
        char *arg1 = strtok(local, "" "");
        if (!arg1) {
            free(local);
            return;
        }
        char *arg2 = strtok(NULL, """");
        if (!arg2) {
            free(local);
            return;
        }
        while (*arg2 == ' ') arg2++;
        if (!*arg2) {
            free(local);
            return;
        }
        cmd_mv(arg1, arg2);
        free(local);*/
    }
    else if (strcmp(cmd, ""ln"") == 0) {
        /*if (!rest || !*rest) {
            return;
        }
        char *local = strdup(rest);
        char *maybeFlag = strtok(local, "" "");
        if (!maybeFlag) {
            free(local);
            return;
        }
        if (strcmp(maybeFlag, ""-s"") == 0) {
            char *path1 = strtok(NULL, "" "");
            if (!path1) {
                free(local);
                return;
            }
            char *path2 = strtok(NULL, """");
            if (!path2) {
                free(local);
                return;
            }
            while (*path2 == ' ') path2++;
            if (!*path2) {
                free(local);
                return;
            }
            cmd_ln_symlink(path1, path2);
        } else {
            // Hard link
            char *path2 = strtok(NULL, """");
            if (!path2) {
                free(local);
                return;
            }
            while (*path2 == ' ') path2++;
            if (!*path2) {
                free(local);
                return;
            }
            cmd_ln(maybeFlag, path2, true);
        }
        free(local);*/
    }
    else if (strcmp(cmd, ""exit"") == 0) {
        Inode *child = root->children;
        while (child) {
            Inode *nx = child->next;
            rm_recursive(child);
            child = nx;
        }
        free(localbuf);
        free_inode(root);
        exit(0);
    }
    free(localbuf);
}

void shell_loop() {
    char *command = NULL;
    size_t len = 0;
    while (getline(&command, &len, stdin) != -1) {
        size_t command_len = strlen(command);
        if (command_len > 0 && command[command_len - 1] == '\n') {
            command[command_len - 1] = '\0';
        }
        process_command(command);
    }
    free(command);
}

int main() {
    init_filesystem();
    shell_loop();
    return 0;
}"
HShf4mnZ,Script fireteam roblox,zoga70122,Lua,Saturday 15th of March 2025 02:06:56 PM CDT,"loadstring(game:HttpGet(""https://raw.githubusercontent.com/Hesg21as/Script-fireteam/refs/heads/main/script.lua""))()"
GH7X5neP,Untitled,smj007,Python,Saturday 15th of March 2025 01:43:06 PM CDT,"class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:

        # take a sliding window approach
        # sliding window approaches are based on expansion and contractions
        # when you find an ideal state - you expand
        # when you find a valid stte - you contract
        # ideal condition is decided by the number of zeros in the sliding window

        left = 0
        right = 0
        countZeroes = 0
        maxConsecutiveOnes = -1

        while (right < len(nums)):
            if nums[right]==0:
                countZeroes += 1

            if countZeroes >= 2:
                if nums[left]==0:
                    countZeroes -= 1
                left += 1

            maxConsecutiveOnes = max(maxConsecutiveOnes, right-left+1)
            right += 1

        return maxConsecutiveOnes"
Djn8ET5b,computer dmg smelter,Justin8303,Lua,Saturday 15th of March 2025 01:35:58 PM CDT,"-- CONSTANTS
local INTERVAL = 20
local PIPE_SIDE = ""top""
local REQUEST_IDS = {
 
--Item IDs
  314,
  315,
  316,
  317
}

local HAS_DAMAGE = false
 
 
-- IMPLEMENTATION
function convertNBT(nbt)
    local conv = {}
    if (nbt == nil) then
        return nil
    elseif (nbt[""type""] == ""NBTTagCompound"") or (nbt[""type""] == ""NBTTagList"") then
        for key, value in pairs(nbt[""value""]) do
            conv[key] = convertNBT(value)
        end
    else
        conv = nbt[""value""]
    end
    return conv
end
 
function getItems(pipe)
    pipe.getAvailableItems()
    local event, result = os.pullEvent(""available_items_return"")
    return result
end
 
function inList(item)
    for _, id in pairs(REQUEST_IDS) do
        if item.id == id then
            return true
        end
    end
    return false
end
 
 
-- MAIN
local pipe = peripheral.wrap(PIPE_SIDE)
while true do
    for i, result in pairs(getItems(pipe)) do
        local iid, amount = unpack(result)
        local item = {
            id = pipe.getItemID(iid),
            dmg = pipe.getItemDamage(iid),
            nbt = convertNBT(pipe.getNBTTagCompound(iid))
        }
		
		if item.dmg == nil and not HAS_DAMAGE or
		   item.dmg ~= nil and item.dmg == 0 and not HAS_DAMAGE or 
		   HAS_DAMAGE == nil then
			if inList(item) then
				pipe.makeRequest(iid, amount)
				sleep(2)
			end
		end
    end
    sleep(INTERVAL)
end
"
3rXgzxVf,Untitled,darekfive,Java,Saturday 15th of March 2025 01:21:53 PM CDT,"class Solution {
    int[][] dirs = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1, -1}, {1, 0} , {1,1}};
    public int shortestPathBinaryMatrix(int[][] grid) {
        //bfs
        int m = grid.length;
        if (m == 1) return grid[0][0] == 0 ? 1 : -1; //1x1 edge case
        if (grid[0][0] == 1) return -1; //invalid start
        Queue<int[]> q = new ArrayDeque<>();
        grid[0][0] = 1; //mark visited
        q.offer(new int[] {0,0});
        HashMap<Integer,Integer> parent = new HashMap<>();
        int level = 1;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i =0; i < size ;i++) {
                int[] cur = q.poll();
                for (int[] d : dirs) {
                    int x = d[0] + cur[0];
                    int y = d[1] + cur[1];
                    if (x >= 0 && x < m && y >= 0 && y < m && grid[x][y] == 0) {
                        parent.put(x*1000+y, cur[0] *1000 + cur[1]);
                        if (x == m-1 && y == m-1) {
                            outputPath(x*1000+y, parent);
                            return level + 1;
                        }
                        grid[x][y] = 1;//mark visited
                        q.offer(new int[] {x,y});
                    }
                }
            }
            level++;
        }
        return -1;
    }
    void outputPath(int key, HashMap<Integer,Integer> map) {
        StringBuilder sb = new StringBuilder();
        List<String> path = new ArrayList<>();
        while (map.containsKey(key)) {
            sb.append(""["")
            .append(key/1000)
            .append("","")
            .append(key%1000)
            .append(""]"");
            path.add(sb.toString());
            sb.setLength(0);
            key = map.get(key);
        }
        path.add(""[0,0]"");
        Collections.reverse(path);
        System.out.println(String.join(""->"", path));
    }"
yUU3Tnu2,blowHard.ino,j0h,Arduino,Saturday 15th of March 2025 01:09:41 PM CDT,"#include <Keyboard.h>
#include <Bounce2.h>

#define left_mic 0
#define rght_mic 1
#define fwd_mic  2

// Create Bounce objects for buttons
Bounce left = Bounce();
Bounce rght = Bounce();
Bounce fwd = Bounce();

void setup() {

  Serial.begin(19200);
 // delay(3000);
pinMode(0, INPUT_PULLUP);
pinMode(1, INPUT_PULLUP);
pinMode(2, INPUT_PULLUP);

 int bounceTime = 1;
  // Attach buttons to Bounce objects and set debounce interval
  left.attach(left_mic, INPUT_PULLUP);
  left.interval(bounceTime);

  rght.attach(rght_mic, INPUT_PULLUP);
  rght.interval(bounceTime);

  fwd.attach(fwd_mic, INPUT_PULLUP);
  fwd.interval(bounceTime);
Keyboard.begin();
}

void loop() {
  left.update();
  rght.update();
  fwd.update();

  // Handle button presses with debouncing
  if (left.fell()) {
    Serial.println(""LEFT"");
    Keyboard.press(KEY_LEFT);
    Keyboard.release(KEY_LEFT);
  }
  if (rght.fell()) {
    Serial.println(""Riiight"");
    Keyboard.press(KEY_RIGHT);
    Keyboard.release(KEY_RIGHT);
  }
  if (fwd.fell()) {
    Serial.println(""Forward!"");
    Keyboard.press(KEY_UP_ARROW);
    Keyboard.release(KEY_UP_ARROW);
 
  }  

}
/*
  
  
  RFWD.update();
  LFWD.update();
  rota.update();
  rset.update();
  zmin.update();
  zout.update();
  zmax.update();
  lrota.update();


  if (RFWD.fell()) {
    Keyboard.press(KEY_LEFT_SHIFT);
    Keyboard.press(KEY_R);
    Keyboard.press(KEY_UP_ARROW);
    Keyboard.release(KEY_R);
    Keyboard.release(KEY_UP_ARROW);
    Keyboard.release(KEY_LEFT_SHIFT);
  }
  if (LFWD.fell()) {
    Keyboard.press(KEY_UP_ARROW);
    Keyboard.press(KEY_R);
    Keyboard.release(KEY_UP_ARROW);
    Keyboard.release(KEY_R);
  }
  if (rota.fell()) {
    Keyboard.press(KEY_R);
    Keyboard.release(KEY_R);
  }
  if (rset.fell()) {
    Keyboard.press(KEY_X);
    Keyboard.release(KEY_X);
  }
  if (zmin.fell()) {
    Keyboard.press(KEYPAD_MINUS);
    Keyboard.release(KEYPAD_MINUS);
  }
  if (zmax.fell()) {
    Keyboard.press(KEYPAD_PLUS);
    Keyboard.release(KEYPAD_PLUS);
  }
  if (lrota.fell()) {
    Keyboard.press(KEY_R);
    Keyboard.release(KEY_R);
  }
*/



  /*
  const int debounceInterval = 5;

  // Attach buttons to Bounce objects and set debounce interval
  left.attach(aleft, INPUT_PULLUP);
  left.interval(debounceInterval);
  
  rght.attach(arght, INPUT_PULLUP);
  rght.interval(debounceInterval);

  fwd.attach(afwd, INPUT_PULLUP);
  fwd.interval(debounceInterval);

  RFWD.attach(aRFWD, INPUT_PULLUP);
  RFWD.interval(debounceInterval);

  LFWD.attach(aLFWD, INPUT_PULLUP);
  LFWD.interval(debounceInterval);

  rota.attach(arota, INPUT_PULLUP);
  rota.interval(debounceInterval);

  rset.attach(arset, INPUT_PULLUP);
  rset.interval(debounceInterval);

  zmin.attach(azmin, INPUT_PULLUP);
  zmin.interval(debounceInterval);

  zout.attach(azout, INPUT_PULLUP);
  zout.interval(debounceInterval);

  zmax.attach(azmax, INPUT_PULLUP);
  zmax.interval(debounceInterval);

  lrota.attach(alrota, INPUT_PULLUP);
  lrota.interval(debounceInterval);
*/"
MGCkU5WC,for dll,dllbridge,C,Saturday 15th of March 2025 01:08:56 PM CDT,"0) extern ""C"" __declspec(dllexport)
   - - - - - - - - - - - - - - - - -
1) int (*_rr)();
2) HMODULE  hDll = 0;
3) hDll = LoadLibrary(""dll/for.dll"");
4) _rr = (int(*)())GetProcAddress(hDll, ""_rr"");
5) FreeLibrary(hDll);"
UNnnKBBQ,phd,mayankjoin3,MySQL,Saturday 15th of March 2025 12:56:38 PM CDT,"CREATE TABLE phd_scholar (
id INT AUTO_INCREMENT PRIMARY KEY,

/*Auto Fetch based on Trigger Values*/
name_of_scholar VARCHAR(255) NOT NULL,
dept VARCHAR(255) NOT NULL,
roll VARCHAR(50) UNIQUE NOT NULL,
broad_research_area VARCHAR(255),
admission_month ENUM('January', 'June') NOT NULL,
gender ENUM('Male', 'Female', 'Other') NOT NULL,
category VARCHAR(100),
scholar_phd_category VARCHAR(100),
mobile VARCHAR(100),
/*Auto Fetch based on Trigger Values*/

/*Text Boxes Start*/
proj_num VARCHAR(50),
proj_name VARCHAR(255),
proj_tenure VARCHAR(100),
sponsored_agency_name VARCHAR(255),
/*Text Boxes End*/

date_of_joining_as_per_memo DATE,

dc_chair VARCHAR(255),
supervisor VARCHAR(255),
supervisor_emp_id INT,
co_supervisor VARCHAR(255),
co_supervisor_emp_id INT,
dc_internal_member_emp_id INT,
dc_internal_member VARCHAR(255),
dc_external_member_emp_id INT,
dc_external_member VARCHAR(255),
dc_additional_member_1_emp_id INT,
dc_additional_member_1 VARCHAR(255),
dc_additional_member_2_emp_id INT,
dc_additional_member_2 VARCHAR(255),
date_of_dc_formation DATE,
form_dc_submit_flag BOOLEAN DEFAULT 0,
dc_approval_dean BOOLEAN DEFAULT 0,

dc_course_work_fac_1 VARCHAR(255),
dc_course_work_fac_2 VARCHAR(255),
dc_course_work_fac_3 VARCHAR(255),
dc_course_work_fac_4 VARCHAR(255),
dc_course_work_fac_5 VARCHAR(255),
dc_course_work_fac_6 VARCHAR(255),
dc_course_work_fac_7 VARCHAR(255),
dc_course_work_fac_8 VARCHAR(255),
dc_course_work_fac_9 VARCHAR(255),
dc_course_work_fac_10 VARCHAR(255),

date_of_compre_attempt_1 DATE,
result_of_compre_attempt_1 ENUM('Pass', 'Fail'),
mode_of_compre_attempt_1 ENUM('Both', 'Oral', 'Written'), /*Take as input dropdown*/
form_submit_flag_compre_attempt_1 BOOLEAN DEFAULT 0,
compre_exam_attempt_1_result_approval_dean BOOLEAN DEFAULT 0,

date_of_compre_attempt_2 DATE,
result_of_compre_attempt_2 ENUM('Pass', 'Fail'),
mode_of_compre_attempt_2 ENUM('Both', 'Oral', 'Written'),  /*Take as input dropdown*/
form_submit_flag_compre_attempt_2 BOOLEAN DEFAULT 0,
compre_exam_attempt_2_result_approval_dean BOOLEAN DEFAULT 0,

date_of_reg_1 DATE,
title_of_reg_1 VARCHAR(255),
dc_comment_in_reg_1 VARCHAR(255),
result_of_reg_1 ENUM('Pass', 'Fail'),
form_submit_flag_reg_1 BOOLEAN DEFAULT 0,
reg_1_result_approval_dean BOOLEAN DEFAULT 0,

date_of_reg_2 DATE,
title_of_reg_2 VARCHAR(255),
dc_comment_in_reg_2 VARCHAR(255),
result_of_reg_2 ENUM('Pass', 'Fail'),
form_submit_flag_reg_2 BOOLEAN DEFAULT 0,
reg_2_result_approval_dean BOOLEAN DEFAULT 0,

date_of_enhancement DATE,
dc_comment_in_enhancement VARCHAR(255),
current_stipend_amount INT,
enhanced_stipend_amount INT,

date_of_aps_1 DATE,
title_of_aps_1 VARCHAR(255),
dc_comment_in_aps_1 VARCHAR(255),
result_of_aps_1 ENUM('Pass', 'Fail'),
form_submit_flag_aps_1 BOOLEAN DEFAULT 0,
aps_1_result_approval_dean BOOLEAN DEFAULT 0,

date_of_aps_2 DATE,
title_of_aps_2 VARCHAR(255),
dc_comment_in_aps_2 VARCHAR(255),
result_of_aps_2 ENUM('Pass', 'Fail'),
form_submit_flag_aps_2 BOOLEAN DEFAULT 0,
aps_2_result_approval_dean BOOLEAN DEFAULT 0,

date_of_aps_3 DATE,
title_of_aps_3 VARCHAR(255),
dc_comment_in_aps_3 VARCHAR(255),
result_of_aps_3 ENUM('Pass', 'Fail'),
form_submit_flag_aps_3 BOOLEAN DEFAULT 0,
aps_3_result_approval_dean BOOLEAN DEFAULT 0,

date_of_aps_4 DATE,
title_of_aps_4 VARCHAR(255),
dc_comment_in_aps_4 VARCHAR(255),
result_of_aps_4 ENUM('Pass', 'Fail'),
form_submit_flag_aps_4 BOOLEAN DEFAULT 0,
aps_4_result_approval_dean BOOLEAN DEFAULT 0,

date_of_aps_5 DATE,
title_of_aps_5 VARCHAR(255),
dc_comment_in_aps_5 VARCHAR(255),
result_of_aps_5 ENUM('Pass', 'Fail'),
form_submit_flag_aps_5 BOOLEAN DEFAULT 0,
aps_5_result_approval_dean BOOLEAN DEFAULT 0,

date_of_synopsis_attempt_1 DATE,
title_of_synopsis_attempt_1 VARCHAR(255),
dc_comment_in_synopsis_attempt_1 VARCHAR(255),
result_of_synopsis_attempt_1 ENUM('Pass', 'Fail'),
form_submit_flag_synopsis_attempt_1 BOOLEAN DEFAULT 0,
synopsis_attempt_1_result_approval_dean BOOLEAN DEFAULT 0,

date_of_synopsis_attempt_2 DATE,
title_of_synopsis_attempt_2 VARCHAR(255),
dc_comment_in_synopsis_attempt_2 VARCHAR(255),
result_of_synopsis_attempt_2 ENUM('Pass', 'Fail'),
form_submit_flag_synopsis_attempt_2 BOOLEAN DEFAULT 0,
synopsis_attempt_2_result_approval_dean BOOLEAN DEFAULT 0,

panel_of_examiners JSON, -- Stores a list of examiners
form_submit_flag_panel_of_examiners BOOLEAN DEFAULT 0,

date_of_thesis_submission DATE,
thesis_title VARCHAR(255),
form_submit_flag_thesis BOOLEAN DEFAULT 0,

name_of_external_examiner VARCHAR(255),
date_of_viva_voce DATE,

created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
"
9NX0ZDVR,Пример кода внутреннего модуля,armedjack,C++,Saturday 15th of March 2025 12:42:46 PM CDT,"#include <SPI.h>
#include <RF24.h>
#include <LiquidCrystal_I2C.h>

// Определение пинов для NRF24L01
#define CE_PIN 9
#define CSN_PIN 10

// Инициализация объекта radio
RF24 radio(CE_PIN, CSN_PIN);

// Адрес трубы – должен совпадать с передатчиком
const byte address[6] = ""00001"";

// Структура данных для приёма (та же, что и у внешнего модуля)
struct DataPacket {
  float temperature;
  float humidity;
};

// Инициализация LCD (I2C адрес, размеры: 16 символов x 2 строки)
LiquidCrystal_I2C lcd(0x27, 16, 2);

void setup() {
  // Инициализация последовательного порта для отладки
  Serial.begin(9600);
  
  // Инициализация LCD экрана
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(""Waiting data..."");
  
  // Инициализация NRF24L01
  if (!radio.begin()) {
    Serial.println(""Ошибка инициализации NRF24L01"");
    while (1);
  }
  
  // Настройка параметров модуля
  radio.setChannel(76);                // Выбор канала
  radio.setPALevel(RF24_PA_LOW);         // Уровень мощности
  radio.setDataRate(RF24_250KBPS);       // Скорость передачи данных
  
  // Открываем трубу для чтения с указанным адресом
  radio.openReadingPipe(0, address);
  
  // Переводим модуль в режим прослушивания
  radio.startListening();
  
  Serial.println(""Приёмник запущен и слушает..."");
}

void loop() {
  // Проверяем, если данные доступны для чтения
  if (radio.available()) {
    // Создаем переменную для полученных данных
    DataPacket receivedData;
    
    // Читаем данные из модуля
    radio.read(&receivedData, sizeof(receivedData));
    
    // Вывод в Serial Monitor для отладки
    Serial.print(""Получено: T = "");
    Serial.print(receivedData.temperature);
    Serial.print("" C, H = "");
    Serial.print(receivedData.humidity);
    Serial.println("" %"");
    
    // Обновляем информацию на LCD экране
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(""Temp: "");
    lcd.print(receivedData.temperature);
    lcd.print("" C"");
    lcd.setCursor(0, 1);
    lcd.print(""Hum: "");
    lcd.print(receivedData.humidity);
    lcd.print("" %"");
  }
  
  // Небольшая задержка для стабильности отображения
  delay(500);
}
"
TwDp9q1L,Пример кода внешнего модуля погодной станции,armedjack,C++,Saturday 15th of March 2025 12:38:27 PM CDT,"#include <SPI.h>
#include <RF24.h>
#include <DHT.h>

// Определения пинов
#define DHTPIN 2          // Пин для DHT11
#define DHTTYPE DHT11     // Модель датчика

// Пины для NRF24L01
#define CE_PIN 9
#define CSN_PIN 10

// Инициализация объектов
RF24 radio(CE_PIN, CSN_PIN);
DHT dht(DHTPIN, DHTTYPE);

// Определяем адрес для связи
const byte address[6] = ""00001"";

// Структура для передачи данных
struct DataPacket {
  float temperature;
  float humidity;
};

void setup() {
  Serial.begin(9600);
  
  // Инициализация DHT11
  dht.begin();
  
  // Инициализация модуля NRF24L01
  if (!radio.begin()) {
    Serial.println(""Ошибка инициализации NRF24L01"");
    while (1);
  }
  
  // Настройка параметров модуля
  radio.setChannel(76);                // Выбор канала (проверьте, чтобы не было помех)
  radio.setPALevel(RF24_PA_LOW);         // Уровень мощности
  radio.setDataRate(RF24_250KBPS);       // Скорость передачи данных
  
  // Открываем трубу для записи
  radio.openWritingPipe(address);
  
  // Переводим модуль в режим передачи
  radio.stopListening();
  
  Serial.println(""NRF24L01 инициализирован. Начало передачи данных..."");
}

void loop() {
  // Считывание данных с DHT11
  float humidity = dht.readHumidity();
  float temperature = dht.readTemperature();
  
  // Проверка корректности считывания
  if (isnan(humidity) || isnan(temperature)) {
    Serial.println(""Ошибка чтения с DHT11"");
    delay(2000);
    return;
  }
  
  // Заполнение структуры данными
  DataPacket dataPacket;
  dataPacket.temperature = temperature;
  dataPacket.humidity = humidity;
  
  // Отправка данных через NRF24L01
  bool success = radio.write(&dataPacket, sizeof(dataPacket));
  if (success) {
    Serial.print(""Данные отправлены: T = "");
    Serial.print(temperature);
    Serial.print("" C, H = "");
    Serial.print(humidity);
    Serial.println("" %"");
  } else {
    Serial.println(""Ошибка передачи данных"");
  }
  
  // Задержка между отправками (например, 2 секунды)
  delay(2000);
}
"
cd3PjFQb,Find device name input in list,Code_187,Python,Saturday 15th of March 2025 12:36:45 PM CDT,"import time

devises_list = [""iphone"", ""android"", ""radio"", ""tv"", ""tablet"", ""pc"", ""laptop""]
""""""
    if the number of elements in the list increases to 1000? 100 000?
    list should be converted to set
    
    devises_set = set(devises_list)
""""""


def check_devices_set(devise_name, devises_list):
    start_time = time.time()
    found = devise_name in devises_list
    elapsed_time = time.time() - start_time
    return found, elapsed_time


while True:
    user_input = input(""Enter a devise name: (or 'exit' to quit) "").lower()

    if user_input == 'exit':
        break

    found, elapsed_time = check_devices_set(user_input, devises_list)

    if found:
        print(f""'{user_input}' found in the list"")
    else:
        print(f""'{user_input}' not found in the list"")

    print(f'Time taken: {elapsed_time:.6f} second\n')
"
BdWX45Vr,turtle dmg crafter,Justin8303,Lua,Saturday 15th of March 2025 12:25:53 PM CDT,"-- CONSTANTS
local INTERVAL = 20
local PIPE_SIDE = ""top""
local OUTPUT_SIDE = ""bottom""

-- Maximaler Schadenswert für jedes Item
local MAX_DAMAGE = {
    [314] = 77,   -- Gold Helm
    [315] = 112,
    [316] = 105,
    [317] = 91,   -- Gold Boots
    [283] = 32,   -- Gold Schwert
    [306] = 165,  -- Eisen Helm
    [307] = 240,
    [308] = 225,
    [309] = 195,  -- Eisen Boots
    [267] = 250,  -- Eisen Schwert
    [256] = 250,  -- Eisen Schaufel
}

-- IMPLEMENTATION
function convertNBT(nbt)
    local conv = {}
    if (nbt == nil) then
        return nil
    elseif (nbt[""type""] == ""NBTTagCompound"") or (nbt[""type""] == ""NBTTagList"") then
        for key, value in pairs(nbt[""value""]) do
            conv[key] = convertNBT(value)
        end
    else
        conv = nbt[""value""]
    end
    return conv
end

function getItems(pipe)
    pipe.getAvailableItems()
    local event, result = os.pullEvent(""available_items_return"")
    return result
end

function findRepairItem(pipe, damagedItem, display)
    local bestMatch = nil
    local minimumWaste = nil
    for i, result in pairs(getItems(pipe)) do
        local iid, amount = unpack(result)
        local item = {
            id = pipe.getItemID(iid),
            dmg = pipe.getItemDamage(iid),
            nbt = convertNBT(pipe.getNBTTagCompound(iid))
        }
        if item.id == damagedItem.id and item.dmg ~= nil and item.dmg > 0 then
            local durabilityLeft = MAX_DAMAGE[item.id] - item.dmg
            local waste = durabilityLeft - damagedItem.dmg
            if waste >= 0 and (minimumWaste == nil or waste < minimumWaste) then
                bestMatch = iid
                minimumWaste = waste
                if display then
                    print(string.format(""Found potential repair item. ID: %d, Durability: %d, Waste: %d"", item.id, durabilityLeft, waste))
                end
            end
        end
    end
    if minimumWaste ~= nil and minimumWaste > 5 then
        return nil
    end
    return bestMatch
end

function findPerfectRepairPair(pipe)
    local highestItem = nil
    local secondHighestItem = nil
    local highestDamage = -1

    for i, result in pairs(getItems(pipe)) do
        local iid, amount = unpack(result)
        local item = {
            id = pipe.getItemID(iid),
            dmg = pipe.getItemDamage(iid),
            nbt = convertNBT(pipe.getNBTTagCompound(iid))
        }

        if item.dmg ~= nil then
            local remainingDurability = MAX_DAMAGE[item.id] - item.dmg

            if remainingDurability > 0 then
                for j, result2 in pairs(getItems(pipe)) do
                    if i ~= j then 
                        local iid2, amount2 = unpack(result2)
                        local item2 = {
                            id = pipe.getItemID(iid2),
                            dmg = pipe.getItemDamage(iid2),
                            nbt = convertNBT(pipe.getNBTTagCompound(iid2))
                        }

                        if item.id == item2.id and item2.dmg ~= nil then
                            local remainingDurability2 = MAX_DAMAGE[item2.id] - item2.dmg
                            if remainingDurability + remainingDurability2 == MAX_DAMAGE[item.id] then
                                return iid, iid2
                            end
                        end
                    end
                end
            end
        end
    end

    return nil, nil
end

-- MAIN
local pipe = peripheral.wrap(PIPE_SIDE)
while true do
    local success = false
    for i, result in pairs(getItems(pipe)) do
        local iid, amount = unpack(result)
        local item = {
            id = pipe.getItemID(iid),
            dmg = pipe.getItemDamage(iid),
            nbt = convertNBT(pipe.getNBTTagCompound(iid))
        }

        if MAX_DAMAGE[item.id] and item.dmg ~= nil and item.dmg > 0 then
            local repairIID = findRepairItem(pipe, item, true)
            if repairIID ~= nil then
                pipe.makeRequest(iid, 1)
                sleep(0.1)
                pipe.makeRequest(repairIID, 1)
                sleep(1.5)

                print(string.format(""repairing item ID: %d with repair item ID: %d"", item.id, pipe.getItemID(repairIID)))

                if not turtle.craft() then
                   print(""not successful"")
                else
                    success = true
                end

                sleep(0.5)
                rs.setOutput(""back"", true)
                sleep(0.5)
                rs.setOutput(""back"", false)
            end
        end
    end

    if not success then
        local highestIID, secondHighestIID = findPerfectRepairPair(pipe)

        if highestIID and secondHighestIID then
            pipe.makeRequest(highestIID, 1)
            sleep(0.1)
            pipe.makeRequest(secondHighestIID, 1)
            sleep(1.5)

            print(string.format(""Combining item ID: %d with item ID: %d"", pipe.getItemID(highestIID), pipe.getItemID(secondHighestIID)))

            if turtle.craft() then
                success = true
                sleep(0.5)
                rs.setOutput(""back"", true)
                sleep(0.5)
                rs.setOutput(""back"", false)
            else
                print(""Crafting failed"")
            end
        end
    end

    sleep(INTERVAL)
end"
FpXUacvK,messageSender.lua,Chaos_Cash,Lua,Saturday 15th of March 2025 12:09:33 PM CDT,"function sendWithThisBox(boxKey)

	for k,v in pairs(sendTheseMessages) do
	curMessageKey = k
	curMessage = v[""message""]
	curPlayer = v[""player""]
	curColor = v[""color""]
	break
	end

local chatBox = chatBoxes[boxKey][""peripheral""]


	if type(curMessage) ~= ""table"" then
	local json = textutils.serialiseJSON({text = curMessage, color = curColor})
	chatBox.sendFormattedMessageToPlayer(json, curPlayer, systemName)
	table.remove(sendTheseMessages, curMessageKey)
	chatBoxes[boxKey][""cooldownTime""] = os.epoch(""local"")
	return
	end


	for k,v in pairs(curMessage) do
		if type(v) == ""table"" then
			if not v[""color""] then
			curMessage[k][""color""] = curColor
			end
		else
		curMessage[k] = {text = v, color = curColor}
		end
	end
	
local json = textutils.serialiseJSON(curMessage)
chatBox.sendFormattedMessageToPlayer(json, curPlayer, systemName)


table.remove(sendTheseMessages, curMessageKey)
chatBoxes[boxKey][""cooldownTime""] = os.epoch(""local"")
end



	
function mainSender()
	while true do
		if table.maxn(sendTheseMessages) < 1 then
		os.pullEvent(""sendMessage"")
		else
		sleep(0.05)
		end


		for chatBoxKey,chatBox in pairs(chatBoxes) do
			if os.epoch(""local"") - chatBox[""cooldownTime""] > 999 then
			sendWithThisBox(chatBoxKey)
			end
			
			if table.maxn(sendTheseMessages) < 1 then
			break
			end
		end

	end
end



	while true do
	sleep(1)
	mainSender()
	end"
Lq0DuTQ9,回文数组 参考代码,Dmaxiya,C++,Saturday 15th of March 2025 11:16:35 AM CDT,"#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int maxn = 100000 + 100;
int n;
LL ans;
int num[maxn];

int main() {
#ifdef ExRoc
    freopen(""test.txt"", ""r"", stdin);
#endif
    ios::sync_with_stdio(false);

    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> num[i];
    }
    for (int i = 1; i <= n / 2; ++i) {
        int d = num[n - i + 1] - num[i];
        ans += abs(d);
        num[i] += d;
        if (d > 0) {
            num[i + 1] += min(max(num[n - i] - num[i + 1], 0), d);
        }
        if (d < 0) {
            num[i + 1] += max(min(num[n - i] - num[i + 1], 0), d);
        }
    }
    cout << ans << endl;

    return 0;
}
"
63zeY2tF,OpenComputers Applied Energistics 2 Auto Stock,henk2002,Lua,Saturday 15th of March 2025 10:25:20 AM CDT,"local component = require(""component"")
local fs = require(""filesystem"")
local serialization = require(""serialization"")
local meController = component.proxy(component.me_controller.address)
local gpu = component.gpu
gpu.setResolution(160,50)
local gui = require(""gui"")
local event = require(""event"")

gui.checkVersion(2,5)

local prgName = ""Applied Energistics 2 Auto Stock""
local version = ""v1.3""
local lines = {}
local items = {}
local craftTasks = {}
local maxCpuUsage = 1
local currentCpuUsage = 0

local function LoadConfig()
  local file,err = io.open(""config.cfg"", ""r"")
  if err == nil then
    local data = file:read(""*n"")
    maxCpuUsage = tonumber(data)
    gui.setText(mainGui, CpuMaxUsage, maxCpuUsage .. """")
    file:close()
  end
end

local function SaveConfig()
  local file,err = io.open(""config.cfg"", ""w"")
  file:write(maxCpuUsage)
  file:close()
end

local function LoadItems()
  local file,err = io.open(""items.cfg"", ""r"")
  if err == nil then
    local data = file:read(""*a"")
    file:close()

    local itemsToLoad = serialization.unserialize(data)
    items = {}
    for index = 1, #itemsToLoad do
      items[index] = itemsToLoad[index]
    end

    for index = 1, #items do
      items[index][""Name""] = """"
      items[index][""CurrentCraftAmount""] = 0
      items[index][""CurrentValue""] = 0
      items[index][""Message""] = """"
    end
  end
end

local function SaveItems()
  local file,err = io.open(""items.cfg"", ""w"")
  local itemsToSave = {}
  for index = 1, #items do
    itemsToSave[index] = {}
    itemsToSave[index][""rawItemName""] = items[index][""rawItemName""]
    itemsToSave[index][""rawItemDamage""] = items[index][""rawItemDamage""]
    itemsToSave[index][""Setpoint""] = items[index][""Setpoint""]
    itemsToSave[index][""CraftAmount""] = items[index][""CraftAmount""]
  end
  file:write(serialization.serialize(itemsToSave))
  file:close()

  LoadItems()
end

mainGui = gui.newGui(1, 2, 159, 48, true)

local function DrawHeaders()
  Header_Name = gui.newLabel(mainGui, 4, 2, ""Name"", 0xc0c0c0, 0x0, 30)
  Header_Current = gui.newLabel(mainGui, 35, 2, ""Current (Setpoint)"", 0xc0c0c0, 0x0, 18)
  Header_Crafting = gui.newLabel(mainGui, 54, 2, ""Crafting"", 0xc0c0c0, 0x0, 8)
  Header_Message = gui.newLabel(mainGui, 63, 2, ""Message"", 0xc0c0c0, 0x0, 15)
  Header_Line = gui.newHLine(mainGui, 1, 3, 76)
  Header2_Name = gui.newLabel(mainGui, 84, 2, ""Name"", 0xc0c0c0, 0x0, 30)
  Header2_Current = gui.newLabel(mainGui, 115, 2, ""Current (Setpoint)"", 0xc0c0c0, 0x0, 18)
  Header2_Crafting = gui.newLabel(mainGui, 134, 2, ""Crafting"", 0xc0c0c0, 0x0, 8)
  Header2_Message = gui.newLabel(mainGui, 143, 2, ""Message"", 0xc0c0c0, 0x0, 15)
  Header2_Line = gui.newHLine(mainGui, 81, 3, 76)
end

local function DrawLines()
  local rowCount = 1
  for index = 1, 86 do
    if index % 2 == 1 then
      lines[index] = {}
      lines[index][""Radio""] = gui.newRadio(mainGui, 1, 3 + rowCount)
      lines[index][""Name""] = gui.newLabel(mainGui, 4, 3 + rowCount, """", 0xc0c0c0, 0x0, 30)
      lines[index][""Current""] = gui.newLabel(mainGui, 35, 3 + rowCount, """", 0xc0c0c0, 0x0, 18)
      lines[index][""Crafting""] = gui.newLabel(mainGui, 54, 3 + rowCount, """", 0xc0c0c0, 0x0, 8)
      lines[index][""Message""] = gui.newLabel(mainGui, 63, 3 + rowCount, """", 0xc0c0c0, 0x0, 15)
    else
      lines[index] = {}
      lines[index][""Radio""] = gui.newRadio(mainGui, 81, 3 + rowCount)
      lines[index][""Name""] = gui.newLabel(mainGui, 84, 3 + rowCount, """", 0xc0c0c0, 0x0, 30)
      lines[index][""Current""] = gui.newLabel(mainGui, 115, 3 + rowCount, """", 0xc0c0c0, 0x0, 18)
      lines[index][""Crafting""] = gui.newLabel(mainGui, 134, 3 + rowCount, """", 0xc0c0c0, 0x0, 8)
      lines[index][""Message""] = gui.newLabel(mainGui, 143, 3 + rowCount, """", 0xc0c0c0, 0x0, 15)
      rowCount = rowCount + 1
    end
  end

  for index = 1, 86 do
    gui.setVisible(mainGui, lines[index][""Radio""], false, true)
  end
end

local function EmptyLines()
  for index = 1, 86 do
    gui.setVisible(mainGui, lines[index][""Radio""], false, true)
    gui.setText(mainGui, lines[index][""Name""], """")
    gui.setText(mainGui, lines[index][""Current""], """")
    gui.setText(mainGui, lines[index][""Crafting""], """")
    gui.setText(mainGui, lines[index][""Message""], """")
  end
end

local function FillLines()
  for index = 1, #items do
    gui.setVisible(mainGui, lines[index][""Radio""], true, true)
    gui.setEnable(mainGui, lines[index][""Radio""], true, true)
    gui.setText(mainGui, lines[index][""Name""], items[index][""Name""])
    gui.setText(mainGui, lines[index][""Current""], items[index][""CurrentValue""] .. "" ("" .. items[index][""Setpoint""] .. "")"")
    if items[index][""CurrentCraftAmount""] > 0 then
      gui.setText(mainGui, lines[index][""Crafting""], items[index][""CurrentCraftAmount""] .. """")
    else
      gui.setText(mainGui, lines[index][""Crafting""], """")
    end
    gui.setText(mainGui, lines[index][""Message""], items[index][""Message""])
  end
end

local addGui_Open
local changeGui_Open
local addItem = {}
local changeItemIndex

local function Item_Name_Callback(guiID, textID, text)
   addItem[""Name""] = text
end

local function Setpoint_Callback(guiID, textID, text)
   addItem[""Setpoint""] = tonumber(text)
end

local function ItemDamage_Callback(guiID, textID, text)
   addItem[""Damage""] = tonumber(text)
end

local function CraftAmount_Callback(guiID, textID, text)
   addItem[""CraftAmount""] = tonumber(text)
end

local function addButtonCallback(guiID, id)
  index = #items + 1
  if index <= 86 then
    items[index] = {}
    items[index][""rawItemName""] = addItem[""Name""]
    items[index][""rawItemDamage""] = addItem[""Damage""]
    items[index][""Setpoint""] = addItem[""Setpoint""]
    items[index][""CraftAmount""] = addItem[""CraftAmount""]

    SaveItems()

    addGui_Open = false
  else
    addGui_Open = false
    gui.showMsg(""Maximum number of items reached (86 items)."")
  end
end

local function changeButtonCallback(guiID, id)
  index = changeItemIndex
  items[index] = {}
  items[index][""rawItemName""] = addItem[""Name""]
  items[index][""rawItemDamage""] = addItem[""Damage""]
  items[index][""Setpoint""] = addItem[""Setpoint""]
  items[index][""CraftAmount""] = addItem[""CraftAmount""]

  SaveItems()

  changeGui_Open = false
end

local function exitButtonCallback(guiID, id)
  addGui_Open = false
  changeGui_Open = false
end

local function AddItem_Callback(guiID, buttonID)
  local addGui = gui.newGui(""center"", ""center"", 62, 10, true, ""Add Item"")
  Item_Name_Label = gui.newLabel(addGui, 1, 1, ""   Item Name: "", 0xc0c0c0, 0x0, 7)
  Item_Name = gui.newText(addGui, 15, 1, 30, """", Item_Name_Callback, 30, false)
  Item_Damage_Label = gui.newLabel(addGui, 1, 3, "" Item Damage: "", 0xc0c0c0, 0x0, 7)
  Item_Damage = gui.newText(addGui, 15, 3, 8, """", ItemDamage_Callback, 8, false)
  Item_Damage_Help = gui.newLabel(addGui, 24, 3, ""(Metadata number of item)"", 0xc0c0c0, 0x0, 7)
  Setpoint_Label = gui.newLabel(addGui, 1, 5, ""    Setpoint: "", 0xc0c0c0, 0x0, 7)
  Setpoint = gui.newText(addGui, 15, 5, 8, """", Setpoint_Callback, 8, false)
  Setpoint_Help = gui.newLabel(addGui, 24, 5, ""(How many items to keep in stock)"", 0xc0c0c0, 0x0, 7)  
  CraftAmount_Label = gui.newLabel(addGui, 1, 7, ""Craft Amount: "", 0xc0c0c0, 0x0, 7)
  CraftAmount = gui.newText(addGui, 15, 7, 8, """", CraftAmount_Callback, 8, false)
  CraftAmount_Help = gui.newLabel(addGui, 24, 7, ""(How many items to craft max at once)"", 0xc0c0c0, 0x0, 7)
  addButton = gui.newButton(addGui, 41, 9, ""Add Item"", addButtonCallback)
  exitButton = gui.newButton(addGui, 52, 9, ""Cancel"", exitButtonCallback)

  addGui_Open = true
  addItem = {}

  gui.displayGui(addGui)
  while addGui_Open do
    gui.runGui(addGui)
  end
  gui.closeGui(addGui)
end

local function RemoveItem_Callback(guiID, buttonID)
   local radioIndex = gui.getRadio(guiID)
   local removeIndex

   for index = 1, #lines do
    if lines[index][""Radio""] == radioIndex then
      removeIndex = index
    end
   end
   
   table.remove(items, removeIndex)
   saveItems()
   EmptyLines()
end

local function ChangeItem_Callback(guiID, buttonID)
  local radioIndex = gui.getRadio(guiID)
  if radioIndex > 0 then
    for index = 1, #lines do
      if lines[index][""Radio""] == radioIndex then
        changeItemIndex = index
      end
    end

    local changeGui = gui.newGui(""center"", ""center"", 62, 10, true, ""Change Item"")
    Item_Name_Label = gui.newLabel(changeGui, 1, 1, ""   Item Name: "", 0xc0c0c0, 0x0, 7)
    Item_Name = gui.newText(changeGui, 15, 1, 30, items[changeItemIndex][""rawItemName""], Item_Name_Callback, 30, false)
    Item_Damage_Label = gui.newLabel(changeGui, 1, 3, "" Item Damage: "", 0xc0c0c0, 0x0, 7)
    Item_Damage = gui.newText(changeGui, 15, 3, 8, items[changeItemIndex][""rawItemDamage""], ItemDamage_Callback, 8, false)
    Item_Damage_Help = gui.newLabel(changeGui, 24, 3, ""(Metadata number of item)"", 0xc0c0c0, 0x0, 7)
    Setpoint_Label = gui.newLabel(changeGui, 1, 5, ""    Setpoint: "", 0xc0c0c0, 0x0, 7)
    Setpoint = gui.newText(changeGui, 15, 5, 8, items[changeItemIndex][""Setpoint""], Setpoint_Callback, 8, false)
    Setpoint_Help = gui.newLabel(changeGui, 24, 5, ""(How many items to keep in stock)"", 0xc0c0c0, 0x0, 7)  
    CraftAmount_Label = gui.newLabel(changeGui, 1, 7, ""Craft Amount: "", 0xc0c0c0, 0x0, 7)
    CraftAmount = gui.newText(changeGui, 15, 7, 8, items[changeItemIndex][""CraftAmount""], CraftAmount_Callback, 8, false)
    CraftAmount_Help = gui.newLabel(changeGui, 24, 7, ""(How many items to craft max at once)"", 0xc0c0c0, 0x0, 7)
    changeButton = gui.newButton(changeGui, 38, 9, ""Change Item"", changeButtonCallback)
    exitButton = gui.newButton(changeGui, 52, 9, ""Cancel"", exitButtonCallback)

    changeGui_Open = true
    addItem = {}
    addItem[""Name""] = items[changeItemIndex][""rawItemName""]
    addItem[""Damage""] = items[changeItemIndex][""rawItemDamage""]
    addItem[""Setpoint""] = items[changeItemIndex][""Setpoint""]
    addItem[""CraftAmount""] = items[changeItemIndex][""CraftAmount""]

    gui.displayGui(changeGui)
    while changeGui_Open do
      gui.runGui(changeGui)
    end
    gui.closeGui(changeGui)
  end
end

local function CpuMaxUsage_Callback(guiID, textID, text)
  maxCpuUsage = tonumber(text)
  SaveConfig()
end

local function DrawButtons()
  AddButton = gui.newButton(mainGui, 1, 1, ""Add Item"", AddItem_Callback)
  RemoveButton = gui.newButton(mainGui, 12, 1, ""Remove Item"", RemoveItem_Callback)
  ChangeButton = gui.newButton(mainGui, 26, 1, ""Change Item"", ChangeItem_Callback)
  CpuUsageLabel = gui.newLabel(mainGui, 118, 1, ""CPU usage: "", 0xc0c0c0, 0x0, 13)
  CpuMaxUsageLabel = gui.newLabel(mainGui, 134, 1, ""Max CPU usage: "", 0xc0c0c0, 0x0, 15)
  CpuMaxUsage = gui.newText(mainGui, 149, 1, 4, maxCpuUsage .. """", CpuMaxUsage_Callback, 4, false)
end

function CheckItemsAndCraft()
  for index = 1, #items do
    items[index][""Message""] = """"
    items[index][""CurrentValue""] = 0
    items[index][""Name""] = """"
    
    local meItem = meController.getItemsInNetwork({ name = items[index][""rawItemName""], damage = items[index][""rawItemDamage""]})
    if meItem.n >= 1 then
      if not meItem[1].isCraftable then
        items[index][""Message""] = ""Not Craftable""
      end

      items[index][""CurrentValue""] = meItem[1].size
      items[index][""Name""] = meItem[1].label

      indexCraftTask = 1
      for indexCraftTasks = 1, #craftTasks do
        if craftTasks[indexCraftTasks].Id == index then indexCraftTask = indexCraftTasks end
      end

      if craftTasks[indexCraftTask].task ~= nil and indexCraftTask > 1 then
        if craftTasks[indexCraftTask].task.isDone() or craftTasks[indexCraftTask].task.isCanceled() then
          currentCpuUsage = currentCpuUsage - 1
          items[index][""CurrentCraftAmount""] = 0
          table.remove(craftTasks, indexCraftTask)
        end
      else
        if items[index][""CurrentCraftAmount""] == 0 and items[index][""CurrentValue""] < items[index][""Setpoint""] then
          if currentCpuUsage < maxCpuUsage then
            local meCpus = meController.getCpus()
            local occupiedCpus = 0
            for cpuIndex = 1, #meCpus do
              if meCpus[cpuIndex].busy then occupiedCpus = occupiedCpus + 1 end
            end
          
            if occupiedCpus < #meCpus then
              local currentCraftAmount = items[index][""Setpoint""] - items[index][""CurrentValue""]
              if currentCraftAmount > items[index][""CraftAmount""] then
                currentCraftAmount = items[index][""CraftAmount""]
              end

              local craftables = meController.getCraftables({ name = items[index][""rawItemName""], damage = items[index][""rawItemDamage""]})
              if craftables.n >= 1 then
                craftTask = craftables[1].request(currentCraftAmount)

                if craftTask.isCanceled() then
                  items[index][""Message""] = ""No ingredients""
                else
                  items[index][""CurrentCraftAmount""] = currentCraftAmount
                  craftTaskWithId = { Id = index, task = craftTask }
                  newIndex = #craftTasks + 1
                  craftTasks[newIndex] = craftTaskWithId
                  currentCpuUsage = currentCpuUsage + 1
                end
              end
            else
              items[index][""Message""] = ""All CPUs busy""
            end
          else
            items[index][""Message""] = ""All CPUs busy""
          end
        end
      end
    end
  end

  gui.setText(mainGui, CpuUsageLabel, ""CPU Usage: "" .. currentCpuUsage)
end

DrawHeaders()
DrawLines()
DrawButtons()
LoadConfig()
LoadItems()

gui.clearScreen()
gui.setTop(""Applied Energistics 2 Auto Stock"")
gui.setBottom("""")

-- Create Empty craftTask
craftTasks[1] = { Id = 0, task = """" }

-- Main loop
while true do
   gui.runGui(mainGui)
   CheckItemsAndCraft()
   FillLines()
end"
f4y8N37C,База для скрипта для Russia car driving | Sochi,zoga70122,Lua,Saturday 15th of March 2025 09:14:31 AM CDT,"--база гуи 

local library = loadstring(game:HttpGet(('https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wall%20v3')))()

local w = library:CreateWindow(""Script for | Sochi"") 
local c = w:CreateFolder(""Base Function"") 
local b = w:CreateFolder(""Teleport"") 

--база 2

local Players = game:GetService(""Players"")
local RunService = game:GetService(""RunService"")
local TweenService = game:GetService(""TweenService"")
local UserInputService = game:GetService(""UserInputService"")

--функции Teleport

b:Button(""Tp AvtoSalon"", function()
    wait(0.7)
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1496.90686, 524.141968, 1530.62219, 0.766061246, 0, 0.642767608, 0, 1, 0, -0.642767608, 0, 0.766061246)
end)

b:Button(""Tp Gruchiki"", function()
    wait(0.7)
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1234.30786, 518.440063, 2433.15796, -0.0871315002, -0, -0.996196866, 0, -1, 0, -0.996196866, 0, 0.087131381)
end)

--[[

функции base function

тут прописываем функции например так

c:Button(""Esp"", function()
    а тут уже функцию
end)

]]

"
uenEp90j,Query by name order,edigitman,Java,Saturday 15th of March 2025 09:07:40 AM CDT,"Which one better prioritize the results start with the searched string ?
    
Version 1:
@Query(""Select org from Organisation org "" +
       ""WHERE org.status in ('ACTIVATED', 'SUSPENDED') "" +
         ""AND (UPPER(org.orgName) LIKE UPPER('%' || :name || '%') OR org.identificationCode LIKE %:code% ) "" +
         ""AND (:interest IS NULL OR org.interestRepresented = :interest)"" + 
       ""ORDER BY CASE "" +
          ""WHEN UPPER(org.orgName) LIKE UPPER(CONCAT(:name, '%')) THEN 1 "" +
          ""WHEN org.identificationCode LIKE CONCAT(:code, '%') THEN 2 "" +
          ""ELSE 3 END"")


Version 2:
@Query(""SELECT org from Organisation org "" +
       ""WHERE org.status in ('ACTIVATED', 'SUSPENDED') "" +
         ""AND (LOCATE(UPPER(:name), UPPER(org.orgName)) > 0 OR LOCATE(:code, org.identificationCode) > 0) "" +
         ""AND (:interest IS NULL OR org.interestRepresented = :interest)"" + 
       ""ORDER BY LOCATE(UPPER(:name), UPPER(org.orgName)) + LOCATE(:code, org.identificationCode)"")
"
0cSSTDNz,Untitled,ur001,HTML 5,Saturday 15th of March 2025 08:51:38 AM CDT,"<!DOCTYPE html>
<html lang=""ru"">
<body>
    <h1>Калькулятор из URL-хэша</h1>
    <div id=""result""></div>

    <script>
        // Считалка из хэша
        function calculateFromHash() {
            // Получение строки из  хэша
            const hash = window.location.hash.substr(1);

            try {
                const {x, y} = parseHashData(hash);
                displayResults(`Результат: ${x} + ${y} = ${x + y}`);
            } catch (e) {
                displayResults(e.message);
            }
        }

        // Разбор данных из хэша
        function parseHashData(hash) {
            if (!hash) throw new Error('Добавьте в URL параметры в формате #x;y');

            const values = hash.split(';');
            if (values.length !== 2) throw new Error('Нужно ровно два значения, разделённых точкой с запятой');

            const x = Number(values[0]);
            const y = Number(values[1]);
            if (isNaN(x) || isNaN(y)) throw new Error('Оба параметра должны быть числами');

            return { x, y };
        }

        // Отображение результатов
        function displayResults(text) {
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = text;
        }

        // Инициализация обработчиков событий
        window.addEventListener('DOMContentLoaded', calculateFromHash);
        window.addEventListener('hashchange', calculateFromHash);
    </script>
</body>
</html>"
wPZHUCJN,Seonbi - PaperNoted,Kelly-B9978,HTML,Saturday 15th of March 2025 08:41:14 AM CDT,"<!--
[คู่มือการใช้งาน]

สีกระดาษ: --ppnote-bg: #f2f2f2;
สีเส้นบรรทัด: --ppnote-line-x: steelblue;
สีเส้นแนวตั้ง: --ppnote-line-y: rgba(255, 0, 0, 0.3);
สีข้อความ: --ppnote-txt: #000;
สีชื่อบนโพลารอยด์: --ppnote-primary: #000;

หมุนสีเทป: --ppnote-hue: 300deg; (มีค่า 0 - 360deg ลองหมุนเล่นดู)

png ทั้ง 3 อัน มีขนาด 1:1 (จัตุรัส) หากรู้สึกว่ารูปที่นำมามีการเว้นขอบมากเกินจนภาพเล็ก สามารถเติม --ppnote-size: ขนาดที่ต้องการ ต่อท้ายลิงก์รูปได้เลย

ตำแหน่งภาพ : เพิ่ม --ppnote-pos: 50% 50%; ต่อท้ายลิงก์รูปที่ต้องการปรับ
 - เลขตัวแรกคือการขยับซ้าย - ขวา โดย 0% = ชิดซ้าย 100% = ชิดขวา
 - เลขตัวแรกคือการขยับขึ้น - ลง โดย 0% = ชิดบน 100% = ชิดล่าง
 
ขนาดภาพ : เพิ่ม --ppnote-size: cover; ต่อท้ายลิงก์รูปที่ต้องการปรับ
 - cover คือ ขยายเต็มพื้นที่
 - 100% คือ ขนาดเดิมของรูป
 - มากกว่า 100% คือ ขนาดใหญ่ขึ้น
 - น้อยกว่า 100% คือ ขนาดเล็กลง
-->

<link href=""https://dl.dropbox.com/scl/fi/6uuiw6f73mogmgwfq73yr/seonbi-papernoted.css?rlkey=rnx2jkexyaube906iz67ncwuk&st=z4ee2m39"" rel=""stylesheet"">
<div id=""PaperNoted""><a href=""https://discord.com/users/625292873914515456/""></a><div class=""ppnote-paper"" style=""--ppnote-bg: #f2f2f2;--ppnote-line-x: steelblue;--ppnote-line-y: rgba(255, 0, 0, 0.3);--ppnote-txt: #000;--ppnote-primary: #000;"">
<div class=""ppnote-line"">
<div class=""ppnote-content"">
[b]@ สถานที่[/b]

--เนื้อหา--</div>
<div class=""ppnote-ps""><b>หมายเหตุ :</b>--หมานเหตุ--</div>
</div>
<div class=""ppnote-polaroid"" style=""--ppnote-hue: 300deg;"">
<div class=""ppnote-png1"" style=""--ppnote-png: url(--ลิงก์รูป png ด้านบน--);""></div>
<div class=""ppnote-png2"" style=""--ppnote-png: url(--ลิงก์รูป png ด้านล่าง--);""></div>
<div class=""ppnote-png3"" style=""--ppnote-png: url(--ลิงก์รูป png ด้านซ้าย--);""></div>
<div class=""ppnote-pic"" style=""--ppnote-pic: url(--ลิงก์รูป ในโพลารอยด์--);""></div>
<div class=""ppnote-name"">Joelle F. Escoffier</div>
</div></div></div>"
AGhcFWXk,Untitled,Worgle123,JavaScript,Saturday 15th of March 2025 08:31:56 AM CDT,"/*Be aware that this method could potentially delete your Minecraft license.  I used it on an alt, not my main.  If you want to use this on your main account, be aware of the risks.
Open your browser, and head to minecraft.net - make sure you are logged in.  Then press Ctrl+Shift+I to open Developer tools/inspect.  Click on console and paste the text below then hit enter. You should have the cape!!*/
 
const mcToken = JSON.parse(localStorage.getItem('MCToken')).mcToken;
 
fetch(""https://net.web.minecraft-services.net/api/v1.0/grant/offer?offer=7118a7d5-240e-4f6d-8959-5269ba041938"", {
  ""headers"": {
    ""accept"": ""/"",
    ""accept-language"": ""en-US,en;q=0.9"",
    ""authorization"": mcToken,
    ""content-type"": ""application/json"",
    ""priority"": ""u=1, i"",
    ""sec-ch-ua-mobile"": ""?0"",
    ""sec-ch-ua-platform"":""Windows"",
    ""sec-fetch-dest"": ""empty"",
    ""sec-fetch-mode"": ""cors"",
    ""sec-fetch-site"": ""cross-site""
  },
  ""referrer"": ""https://www.minecraft.net/"",
  ""referrerPolicy"": ""strict-origin-when-cross-origin"",
  ""body"": null,
  ""method"": ""PUT"",
  ""mode"": ""cors"",
  ""credentials"": ""include""
})
.then(response => {
    console.log('Status Code:', response.status);
  })"
JBwqJq7v,advanture.cpp,DrAungWinHtut,C++,Saturday 15th of March 2025 08:23:47 AM CDT,"#include<iostream>
#include<cstdlib>
#include<conio.h>
using namespace std;

int main()
{
	int life = 3;
	int minx = 0;
	int miny = 0;
	int maxx = 25;
	int maxy = 15;

	int treasurex = 10;
	int treasurey = 10;

	int playerx = 0;
	int playery = 0;

	int trap1x = 5;
	int trap1y = 5;

	int trap2x = 15;
	int trap2y = 5;

	int trap3x = 5;
	int trap3y = 10;

	int trap4x = 15;
	int trap4y = 10;

	int lifeaddx = 10;
	int lifeaddy = 5;

	int key = '\0';
	cout << ""Welcome to the game"" << endl;
	cout << ""You are at position (0,0)"" << endl;
	cout << ""Enter 'w' to move up, 's' to move down, 'a' to move left, 'd' to move right"" << endl;
	cout << ""Enter 'q' to quit the game"" << endl;
	system(""pause"");
	system(""cls"");
	while (1) {
		
		key = _getch();
		switch (key) {
		case 'w': 
			if (playery > miny) {
				playery--;
			}
			break;
		case 's': 
			if (playery < maxy) {
				playery++;
			}
			break;
		case 'a': 
			if (playerx > minx) {
				playerx--;
			}
			break;
		case 'd': 
			if (playerx < maxx) {
				playerx++;
			}
			break;
		case 'q':
			cout << ""You quit the game"" << endl;
			exit(0);
		}
		cout << ""You are at position ("" << playerx << "","" << playery << "")"" << endl;
		if (playerx == treasurex && playery == treasurey) {
			cout << ""You found the treasure"" << endl;
			cout << ""You win the game"" << endl;
			exit(0);
		}
		if (playerx == trap1x && playery == trap1y) {
			cout << ""You are caught in trap 1"" << endl;
			life--;			
		}
		if (playerx == trap2x && playery == trap2y) {
			cout << ""You are caught in trap 2"" << endl;
			life--;
		}
		if (playerx == trap3x && playery == trap3y) {
			cout << ""You are caught in trap 3"" << endl;
			life--;
		}
		if (playerx == trap4x && playery == trap4y) {
			cout << ""You are caught in trap 4"" << endl;
			life--;
		}
		if (playerx == lifeaddx && playery == lifeaddy) {
			cout << ""You found a life"" << endl;
			life++;
		}
		cout << ""Your Life is now "" << life << endl;
		if (life == 0) {
			cout << ""You lost the game"" << endl;
			exit(0);
		}
	}
	return 0;
}"
weJE1ALK,системы счисления,nq1s788,Python,Saturday 15th of March 2025 08:22:15 AM CDT,"#из любой в десятичную -- int('101001', 2)
#из десятичной в двоичную -- bin(54)[2:]
#из десятичной в восьмиричная -- oct(54)[2:]
#из десятичной в 16ричная -- hex(54)[2:]
#hex bin oct dec -- калькулятор разработчика
#16  2   8   10
#во всех остальных случаях -- можно вайлом
n, x = map(int, input().split()) #переводим n из десятичной в x-ичную
ost = ''
while n != 0:
    #если x < 10
    ost += str(n % x)
    n //= x
    #если x > 10 нужно еще в буквы остатки >= 10 переводить
    o = n % x
    if o < 10:
        ost += str(o)
    else:
        ost += 'ABCDEFGH'[o - 10]
    n //= x
print(ost[::-1]) #выводим развернутые остатки"
vwEAUMEp,NoobAI module,g14ndev,Lua,Saturday 15th of March 2025 08:20:40 AM CDT,"-- this module handles noob ai behaviour in addition to genetics
-- author: Gixnly




local NoobAI = {}
NoobAI.__index = NoobAI

-- 💡 SERVICES
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local Players = game:GetService(""Players"")
local RunService = game:GetService(""RunService"")
local Debris = game:GetService(""Debris"")
local ServerScriptService = game:GetService(""ServerScriptService"")
local DataManager = require(ServerScriptService.DataManager)
local LootManager = require(ServerScriptService.LootManager)

-- Global table to track all NoobAI instances, keyed by Model
local ActiveNoobs = {}

-----------------------------------------------------------
-- Utility function: randomColorVariation
-- Returns a Color3 that is a slight variation of the base color.
-----------------------------------------------------------
local function randomColorVariation(baseColor, variation)
	local r = math.clamp(baseColor.R + (math.random()-0.5)*variation, 0, 1)
	local g = math.clamp(baseColor.G + (math.random()-0.5)*variation, 0, 1)
	local b = math.clamp(baseColor.B + (math.random()-0.5)*variation, 0, 1)
	return Color3.new(r, g, b)
end

-----------------------------------------------------------
-- Utility function: averageValue
-- Returns the average of two numbers plus a small random variation.
-----------------------------------------------------------
local function averageValue(val1, val2, variation)
	return ((val1 + val2) / 2) + (math.random()-0.5)*variation
end

-----------------------------------------------------------
-- Constructor: NoobAI.new
-----------------------------------------------------------
function NoobAI.new(spawnPosition, geneticParents)
	local noobTemplate = ReplicatedStorage:FindFirstChild(""Noobs"") and ReplicatedStorage.Noobs:FindFirstChild(""Noob"")
	assert(noobTemplate, ""⚠️ Noob template missing from ReplicatedStorage.Noobs!"")

	local model = noobTemplate:Clone()
	model:SetPrimaryPartCFrame(CFrame.new(spawnPosition))
	model.Parent = workspace
	model:SetAttribute(""CanDamage"", true)

	local humanoid = model:FindFirstChildOfClass(""Humanoid"")
	local rootPart = model:FindFirstChild(""HumanoidRootPart"")
	local animationsFolder = model:FindFirstChild(""Animations"")
	local lootFolder = model:FindFirstChild(""Loot"")

	assert(humanoid, ""⚠️ Noob template is missing a Humanoid!"")
	assert(rootPart, ""⚠️ Noob template is missing a HumanoidRootPart!"")
	assert(animationsFolder, ""⚠️ Noob template is missing an 'Animations' folder!"")

	humanoid.BreakJointsOnDeath = false

	local self = setmetatable({}, NoobAI)
	self.Model = model
	self.Humanoid = humanoid
	self.RootPart = rootPart
	self.Animations = animationsFolder
	self.LootFolder = lootFolder
	self.Target = nil
	self.IsScared = false
	self.LastAnimation = nil
	self.CurrentAnimationTrack = nil
	self.FleeDestination = nil
	self.Dead = false
	self.AnimationTracks = {}
	self.LastPlayerCheck = tick()
	self.DespawnDelay = 30
	self.DespawnRadius = 100
	self.LastAttacker = nil
	self.LastStateChange = tick() -- Track when state last changed
	self.DespawnChanceMultiplier = 1 -- Starts at 1x chance

	local animator = humanoid:FindFirstChild(""Animator"") or Instance.new(""Animator"", humanoid)
	self.Animator = animator

	local damageEvent = Instance.new(""BindableEvent"")
	damageEvent.Name = ""TakeDamageEvent""
	damageEvent.Parent = model
	damageEvent.Event:Connect(function(damage, attacker)
		self:TakeDamage(damage, attacker)
	end)

	local stats = model:FindFirstChild(""Stats"")
	assert(stats, ""⚠️ Noob template is missing a 'Stats' folder!"")

	self.Genetics = {}
	if geneticParents then
		local parent1 = geneticParents[1]
		local parent2 = geneticParents[2]
		if math.random() < 0.5 then
			self.Genetics.Gender = parent1.Gender
		else
			self.Genetics.Gender = parent2.Gender
		end
		if self.Genetics.Gender == ""Male"" then
			local baseBlue = Color3.new(0.2, 0.2, 0.8)
			self.Genetics.TorsoColor = randomColorVariation(parent1.TorsoColor and Color3.new(
				averageValue(parent1.TorsoColor.R, parent2.TorsoColor.R, 0.1),
				averageValue(parent1.TorsoColor.G, parent2.TorsoColor.G, 0.1),
				averageValue(parent1.TorsoColor.B, parent2.TorsoColor.B, 0.1)
				) or baseBlue, 0.05)
		else
			local basePink = Color3.new(0.9, 0.6, 0.7)
			self.Genetics.TorsoColor = randomColorVariation(parent1.TorsoColor and Color3.new(
				averageValue(parent1.TorsoColor.R, parent2.TorsoColor.R, 0.1),
				averageValue(parent1.TorsoColor.G, parent2.TorsoColor.G, 0.1),
				averageValue(parent1.TorsoColor.B, parent2.TorsoColor.B, 0.1)
				) or basePink, 0.05)
		end
		local baseYellow = Color3.new(1, 0.9, 0.4)
		self.Genetics.HeadColor = randomColorVariation(parent1.HeadColor and Color3.new(
			averageValue(parent1.HeadColor.R, parent2.HeadColor.R, 0.1),
			averageValue(parent1.HeadColor.G, parent2.HeadColor.G, 0.1),
			averageValue(parent1.HeadColor.B, parent2.HeadColor.B, 0.1)
			) or baseYellow, 0.05)
		self.Genetics.ArmColor = self.Genetics.HeadColor
		self.Genetics.HealthModifier = averageValue(parent1.HealthModifier or 100, parent2.HealthModifier or 100, 5)
		self.Genetics.ScaredDamageModifier = averageValue(parent1.ScaredDamageModifier or 15, parent2.ScaredDamageModifier or 15, 2)
		self.Genetics.FieldOfVisionModifier = averageValue(parent1.FieldOfVisionModifier or 20, parent2.FieldOfVisionModifier or 20, 2)
	else
		if math.random() < 0.5 then
			self.Genetics.Gender = ""Male""
		else
			self.Genetics.Gender = ""Female""
		end
		if self.Genetics.Gender == ""Male"" then
			local baseBlue = Color3.new(0.2, 0.2, 0.8)
			self.Genetics.TorsoColor = randomColorVariation(baseBlue, 0.05)
		else
			local basePink = Color3.new(0.9, 0.6, 0.7)
			self.Genetics.TorsoColor = randomColorVariation(basePink, 0.05)
		end
		local baseYellow = Color3.new(1, 0.9, 0.4)
		self.Genetics.HeadColor = randomColorVariation(baseYellow, 0.05)
		self.Genetics.ArmColor = self.Genetics.HeadColor
		self.Genetics.HealthModifier = math.random(90, 110)
		self.Genetics.ScaredDamageModifier = math.random(13, 17)
		self.Genetics.FieldOfVisionModifier = math.random(18, 22)
	end

	local torso = model:FindFirstChild(""Torso"")
	if torso then
		torso.Color = self.Genetics.TorsoColor
	end
	local head = model:FindFirstChild(""Head"")
	if head then
		head.Color = self.Genetics.HeadColor
	end
	local leftArm = model:FindFirstChild(""Left Arm"")
	local rightArm = model:FindFirstChild(""Right Arm"")
	if leftArm then
		leftArm.Color = self.Genetics.ArmColor
	end
	if rightArm then
		rightArm.Color = self.Genetics.ArmColor
	end

	self.Config = {
		WalkSpeed    = (stats:FindFirstChild(""WalkSpeed"")    and stats.WalkSpeed.Value)    or 8,
		RunSpeed     = (stats:FindFirstChild(""RunSpeed"")     and stats.RunSpeed.Value)     or 16,
		Aggressive   = (stats:FindFirstChild(""Aggressive"")   and stats.Aggressive.Value)   or (math.random() < 0.2),
		AttackRadius = (stats:FindFirstChild(""AttackRadius"") and stats.AttackRadius.Value) or 5,
		FieldOfVision= ((stats:FindFirstChild(""FieldOfVision"")and stats.FieldOfVision.Value) or 20) * (self.Genetics.FieldOfVisionModifier/100),
		Health       = ((stats:FindFirstChild(""Health"")       and stats.Health.Value)       or 100) * (self.Genetics.HealthModifier/100),
		AttackDamage = (stats:FindFirstChild(""AttackDamage"") and stats.AttackDamage.Value) or 10,
		ScaredDamage = ((stats:FindFirstChild(""ScaredDamage"") and stats.ScaredDamage.Value) or 15) * (self.Genetics.ScaredDamageModifier/100)
	}

	humanoid.WalkSpeed = self.Config.WalkSpeed
	humanoid:SetAttribute(""CanDamage"", true)

	self.State = ""Idle""
	self.LastUpdate = tick()
	self.BaseReproductionCooldown = 30 -- Base value before doubling
	self.ReproductionCooldown = self.BaseReproductionCooldown
	self.LastReproductionTime = tick()
	self.ReproductionCount = 0 -- Track number of times this noob has reproduced

	local aiInstanceValue = model:FindFirstChild(""AIInstance"")
	if not aiInstanceValue then
		aiInstanceValue = Instance.new(""ObjectValue"")
		aiInstanceValue.Name = ""AIInstance""
		aiInstanceValue.Parent = model
	end
	aiInstanceValue.Value = model

	ActiveNoobs[model] = self

	spawn(function()
		self:BehaviorLoop()
	end)

	print(""Noob Spawned"")
	print(""Genetics:"", self.Genetics)

	return self
end

-----------------------------------------------------------
-- BehaviorLoop
-----------------------------------------------------------
function NoobAI:BehaviorLoop()
	while self.Model and self.Model.Parent and not self.Dead do
		self.LastUpdate = tick()

		if self.Humanoid.Health < (self.Config.Health * 0.2) and self.State ~= ""Fleeing"" then
			self.State = ""Fleeing""
		end

		if self.State == ""Idle"" then
			self:IdleBehavior()
			self:CheckReproduction()
		elseif self.State == ""Chasing"" then
			self:PlayAnimation(""Run"", true)
			self:ChaseBehavior()
		elseif self.State == ""Attacking"" then
			self:PlayAnimation(""Attack"", false)
			self:AttackBehavior()
		elseif self.State == ""Fleeing"" then
			if not self.IsScared then
				self.IsScared = true
				self:PlayAnimation(""Scared"", false)
				wait(1)
			end
			self:PlayAnimation(""Run"", true)
			self:FleeBehavior()
		end

		-- Update despawn logic
		if self:IsPlayerInRange(self.DespawnRadius) then
			self.LastPlayerCheck = tick()
		else
			if tick() - self.LastPlayerCheck >= self.DespawnDelay then
				self:Despawn()
				break
			end
		end

		-- Check continuous idle time for despawn chance
		if self.State == ""Idle"" then
			local idleTime = tick() - self.LastStateChange
			if idleTime >= 60 then -- 1 minute
				local minutesPast = math.floor(idleTime / 60)
				self.DespawnChanceMultiplier = 2 ^ (minutesPast - 1) -- Doubles every minute after 1
				if not self:IsPlayerInRange(self.DespawnRadius) and math.random() < (0.1 * self.DespawnChanceMultiplier) then
					self:Despawn()
					break
				end
			end
		end

		wait(0.1)
	end
end

-----------------------------------------------------------
-- CheckReproduction
-----------------------------------------------------------
function NoobAI:CheckReproduction()
	if tick() - self.LastReproductionTime < self.ReproductionCooldown then
		return
	end

	for model, partner in pairs(ActiveNoobs) do
		if model ~= self.Model and model.Parent then
			if partner.Genetics.Gender ~= self.Genetics.Gender and partner.State == ""Idle"" then
				local distance = (partner.RootPart.Position - self.RootPart.Position).Magnitude
				if distance < 5 then
					self:Reproduce(partner)
					self.LastReproductionTime = tick()
					partner.LastReproductionTime = tick()
					return
				end
			end
		end
	end
end

-----------------------------------------------------------
-- Reproduce
-----------------------------------------------------------
function NoobAI:Reproduce(partner)
	local spawnPos = (self.RootPart.Position + partner.RootPart.Position) / 2 + Vector3.new(math.random(-2,2), 0, math.random(-2,2))
	local newNoob = NoobAI.new(spawnPos, {self.Genetics, partner.Genetics})

	-- Double reproduction cooldown for both parents
	self.ReproductionCount = self.ReproductionCount + 1
	self.ReproductionCooldown = self.BaseReproductionCooldown * (2 ^ self.ReproductionCount)
	partner.ReproductionCount = partner.ReproductionCount + 1
	partner.ReproductionCooldown = partner.BaseReproductionCooldown * (2 ^ partner.ReproductionCount)

	print(""Reproduction successful: new noob spawned at"", spawnPos)
	print(self.Model.Name .. "" new cooldown: "", self.ReproductionCooldown)
	print(partner.Model.Name .. "" new cooldown: "", partner.ReproductionCooldown)
end

-----------------------------------------------------------
-- IsPlayerInRange
-----------------------------------------------------------
function NoobAI:IsPlayerInRange(range)
	for _, player in pairs(Players:GetPlayers()) do
		local char = player.Character
		local hrp = char and char:FindFirstChild(""HumanoidRootPart"")
		if hrp then
			if (hrp.Position - self.RootPart.Position).Magnitude <= range then
				return true
			end
		end
	end
	return false
end

-----------------------------------------------------------
-- PlayAnimation
-----------------------------------------------------------
function NoobAI:PlayAnimation(animationName, shouldLoop)
	if self.LastAnimation == animationName then
		return
	end
	self.LastAnimation = animationName

	if self.CurrentAnimationTrack then
		self.CurrentAnimationTrack:Stop()
	end

	local track = self.AnimationTracks[animationName]
	if not track then
		local anim = self.Animations:FindFirstChild(animationName)
		if anim and anim:IsA(""Animation"") then
			track = self.Animator:LoadAnimation(anim)
			self.AnimationTracks[animationName] = track
		end
	end

	if track then
		track.Looped = shouldLoop
		track:Play()
		self.CurrentAnimationTrack = track
	else
		self.CurrentAnimationTrack = nil
	end
end

-----------------------------------------------------------
-- IdleBehavior
-----------------------------------------------------------
function NoobAI:IdleBehavior()
	if math.random() < 0.3 then
		self:PlayAnimation(""Walk"", true)
		local randomOffset = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))
		local randomDestination = self.RootPart.Position + randomOffset
		self:MoveTowards(randomDestination, self.Config.WalkSpeed)
	else
		self:PlayAnimation(""Idle"", true)
	end

	local closestTarget = self:FindClosestEnemy()
	local isAggressive = (self.Humanoid.Health >= (self.Config.Health * 0.2)) and self.Config.Aggressive
	if closestTarget and isAggressive then
		local distance = (closestTarget.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
		if distance < self.Config.FieldOfVision then
			self.State = ""Chasing""
			self.Target = closestTarget
		end
	end
end

-----------------------------------------------------------
-- FindClosestEnemy
-----------------------------------------------------------
function NoobAI:FindClosestEnemy()
	local closestPlayer = nil
	local closestDistance = math.huge

	for _, player in pairs(Players:GetPlayers()) do
		if player.Character and player.Character:FindFirstChild(""HumanoidRootPart"") then
			local distance = (player.Character.HumanoidRootPart.Position - self.RootPart.Position).Magnitude
			if distance < closestDistance then
				closestDistance = distance
				closestPlayer = player
			end
		end
	end

	return closestPlayer
end

-----------------------------------------------------------
-- ChaseBehavior
-----------------------------------------------------------
function NoobAI:ChaseBehavior()
	if not self.Target or not self.Target.Character then
		self.State = ""Idle""
		return
	end

	if self.Humanoid.Health < (self.Config.Health * 0.2) then
		self.State = ""Fleeing""
		return
	end

	local targetPos = self.Target.Character.HumanoidRootPart.Position
	self:MoveTowards(targetPos, self.Config.RunSpeed)

	local distance = (targetPos - self.RootPart.Position).Magnitude
	if distance < (self.Config.AttackRadius + 1) then
		self.State = ""Attacking""
	end
end

-----------------------------------------------------------
-- AttackBehavior
-----------------------------------------------------------
function NoobAI:AttackBehavior()
	if self.Target and self.Target.Character then
		local targetHumanoid = self.Target.Character:FindFirstChildOfClass(""Humanoid"")
		if targetHumanoid then
			targetHumanoid:TakeDamage(self.Config.AttackDamage)
		end
	end
	wait(1)
	self.State = ""Idle""
end

-----------------------------------------------------------
-- FleeBehavior
-----------------------------------------------------------
function NoobAI:FleeBehavior()
	if not self.Target or not self.Target.Character or not self.Target.Character:FindFirstChild(""HumanoidRootPart"") then
		self.State = ""Idle""
		self.FleeDestination = nil
		return
	end

	if not self.FleeDestination then
		local directionAway = (self.RootPart.Position - self.Target.Character.HumanoidRootPart.Position).Unit
		self.FleeDestination = self.RootPart.Position + directionAway * math.random(15, 30)
	end

	self:MoveTowards(self.FleeDestination, self.Config.RunSpeed)

	if (self.FleeDestination - self.RootPart.Position).Magnitude < 3 then
		self.State = ""Idle""
		self.FleeDestination = nil
	end
end

-----------------------------------------------------------
-- MoveTowards
-----------------------------------------------------------
function NoobAI:MoveTowards(targetPos, speed)
	self.Humanoid.WalkSpeed = speed
	self.Humanoid:MoveTo(targetPos)
end

-----------------------------------------------------------
-- TakeDamage
-----------------------------------------------------------
function NoobAI:TakeDamage(amount, attacker)
	self.Humanoid:TakeDamage(amount)
	self.LastAttacker = attacker
	self.LastStateChange = tick() -- Reset idle timer on damage

	if self.Humanoid.Health <= 0 then
		self:Die()
	elseif self.Humanoid.Health < (self.Config.Health * 0.2) or (self.State ~= ""Fleeing"" and amount >= self.Config.ScaredDamage) then
		self.State = ""Fleeing""
		self.Target = attacker
		self.FleeDestination = nil
	end
end

-----------------------------------------------------------
-- Die
-----------------------------------------------------------
function NoobAI:Die()
	self.Dead = true
	self.RootPart.Anchored = true
	self.Humanoid.PlatformStand = true
	self:PlayAnimation(""Die"", false)

	if self.LastAttacker then
		DataManager.AddKill(self.LastAttacker)
	elseif self.Target then
		DataManager.AddKill(self.Target)
	else
		print(""No attacker recorded; kill not awarded."")
	end

	LootManager.SpawnLootBag(1, 1, 2, 3, self.Model.PrimaryPart.Position)

	if self.CurrentAnimationTrack and self.CurrentAnimationTrack.Stopped then
		self.CurrentAnimationTrack.Stopped:Wait()
	else
		wait(4)
	end

	self:DestroyNoob()
end

-----------------------------------------------------------
-- Despawn
-----------------------------------------------------------
function NoobAI:Despawn()
	self.Dead = true
	self:DestroyNoob()
end

-----------------------------------------------------------
-- DestroyNoob
-----------------------------------------------------------
function NoobAI:DestroyNoob()
	for name, track in pairs(self.AnimationTracks) do
		track:Stop()
		track:Destroy()
	end
	self.AnimationTracks = {}

	if self.Model then
		self.Model:Destroy()
	end

	ActiveNoobs[self.Model] = nil
end

return NoobAI"
afpQr5BG,F-4E base,Gamenator,C++,Saturday 15th of March 2025 07:03:06 AM CDT,"class PW_VN_F4E_BASE: PW_VN_B_F4C{
    scope = 2;
    displayName = ""F-4E Phantom II"";
    aileronSensitivity = 1.6;  // Slightly improved roll rate
    elevatorSensitivity = 1.1;  // Slightly improved pitch responsiveness
    thrustCoef[] = {1.8,1.85,1.9,2.0,2.06,2.1,2.25,2.35,2.5,2.65,2.85,1.8,0.2,0,0,0};  // Increased engine power
    acceleration = 240;  // Improved acceleration
    flapsFrictionCoef = 0.3;  // Small reduction in flap drag for improved handling
    draconicForceXCoef = 32;  // Slightly more lateral stability
    draconicForceYCoef = 1.3;  // Increased vertical stability
    draconicForceZCoef = 1.1;  // More effective thrust vectoring
    draconicTorqueXCoef[] = {6.5,7.7,8.4,9.2,10,10.3,10.5,10.6,10.6,10.7,10.7};  // Improved roll response
    draconicTorqueYCoef[] = {15,10.5,3.5,1.0,0.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  // Slightly stronger pitch authority
    unitInfoType=""RscOptics_CAS_Pilot"";
	driverWeaponsInfoType=""RscOptics_CAS_01_TGP"";
    weapons[]=
		{   ""weapon_Fighter_Gun20mm_AA"",
			""CMFlareLauncher""
		};
    magazines[]={
        ""120Rnd_CMFlare_Chaff_Magazine"",
        ""magazine_Fighter04_Gun20mm_AA_x640""};

    class pilotCamera
    {
        minTurn = -20;
        maxTurn = 60;
        initTurn = 0;
        minElev = -25;
        maxElev = 65;
        initElev = 0;
        maxXRotSpeed = 0.05;
        maxYRotSpeed = 0.05;
        maxMouseXRotSpeed = 0.5;
        maxMouseYRotSpeed = 0.5;
        pilotOpticsShowCursor = 1;
        controllable = 1;
        class OpticsIn
        {
            class Wide
            {
                opticsDisplayName = ""WFOV"";
                initAngleX = 0;
                minAngleX = 0;
                maxAngleX = 0;
                initAngleY = 0;
                minAngleY = 0;
                maxAngleY = 0;
                initFov = 0.2;
                minFov = 0.2;
                maxFov = 0.2;
                directionStabilized = 0;
                stabilizedInAxes=""StabilizedInAxesBoth"";
                visionMode[] = {""Normal"",""NVG""};
                thermalMode[] = {};
                gunnerOpticsModel = ""\A3\Drones_F\Weapons_F_Gamma\Reticle\UAV_Optics_Gunner_wide_F.p3d"";
                opticsPPEffects[] = {""OpticsCHAbera2"",""OpticsBlur2""};
            };

            class Medium : Wide
				{
					opticsDisplayName	= ""MFOV"";
					initFov				= 0.125;
					minFov				= 0.125;
					maxFov				= 0.125;
					gunnerOpticsModel	= ""\A3\Drones_F\Weapons_F_Gamma\Reticle\UAV_Optics_Gunner_medium_F.p3d"";
				};
        };

         class Turrets: Turrets
    {
        class MainTurret: NewTurret
        {
            LODTurnedIn = 1100;
            LODTurnedOut = 1100;
            LODOpticsIn = 1100;
            LODOpticsOut = 1100;
            commanding = -1;
            isCopilot = 1;
            primaryGunner = 0;
            primaryObserver = 1;
            proxyType = ""CPGunner"";
            proxyIndex = 1;
            weapons[] = {};
            magazines[] = {};
            enableManualFire = 1;
            soundServo[] = {"""",0.00316228,1};
            startEngine = 0;
            gunnerCompartments = ""Compartment2"";
            gunnerGetInAction = ""GetInVertical"";
            gunnerGetOutAction = ""GetOutHigh"";
            memoryPointsGetInGunner = ""getin_gunner_pos"";
            memoryPointsGetInGunnerDir = ""getin_gunner_dir"";
            castGunnerShadow = 1;
            viewGunnerShadow = 1;
            gunnerAction = ""vn_f4_copilot"";
            gunnerInAction = ""vn_f4_copilot"";
            gunnerLeftHandAnimName = ""lever_copilot"";
            gunnerRightHandAnimName = ""stick_copilot"";
            gunnerLeftLegAnimName = ""pedal_copilot_left"";
            gunnerRightLegAnimName = ""pedal_copilot_right"";
            hasGunner = 1;
            hideWeaponsGunner = 1;
            inGunnerMayFire = 1;
            lockWhenDriverOut = 0;
            outGunnerMayFire = 1;
            canEject = 0;
            gunnerForceOptics = 0;
            gunnerOpticsColor[] = {0.227,0.769,0.24,1};
            gunnerForceOutOptics = 0;
            gunnerUsesPilotView = 0;
            gunnerOpticsShowCursor = 1;
            showGunnerOptics = 1;
            usePiP = 1;
            body = ""otocvez"";
            gun = ""otochlaven"";
            animationSourceBody = ""otocvez"";
            animationSourceGun = ""otochlaven"";
            memoryPointGun = ""gunnerview_copilot"";
            memoryPointGunnerOptics = ""gunnerview_copilot_dir"";
            gunBeg = ""gunnerview_copilot_dir"";
            gunEnd = ""gunnerview_copilot"";
            stabilizedInAxes = 0;
            maxHorizontalRotSpeed = 10;
            maxVerticalRotSpeed = 10;
            turretInfoType = ""RscOptics_CAS_Pilot"";
            gunnerOpticsModel = ""A3\drones_f\Weapons_F_Gamma\Reticle\UGV_01_Optics_Gunner_F.p3d"";
            minElev = -45;
            maxElev = 45;
            initElev = -15;
            minTurn = -45;
            maxTurn = 45;
            initTurn = 0;
            initFov = 0.95;
            maxXRotSpeed = 1;
            maxYRotSpeed = 1;
            maxMouseXRotSpeed = 0.5;
            maxMouseYRotSpeed = 0.5;
            pilotOpticsShowCursor = 1;
            controllable = 1;
            class OpticsIn
            {
                class Wide
                {
                    opticsDisplayName = ""WFOV"";
                    initAngleX = 0;
                    minAngleX = 0;
                    maxAngleX = 0;
                    initAngleY = 0;
                    minAngleY = 0;
                    maxAngleY = 0;
                    initFov = 0.2;
                    minFov = 0.2;
                    maxFov = 0.2;
                    directionStabilized = 0;
                    stabilizedInAxes=""StabilizedInAxesBoth"";
                    visionMode[] = {""Normal"",""NVG""};
                    thermalMode[] = {};
                    gunnerOpticsModel = ""\A3\Drones_F\Weapons_F_Gamma\Reticle\UAV_Optics_Gunner_wide_F.p3d"";
                    opticsPPEffects[] = {""OpticsCHAbera2"",""OpticsBlur2""};
                };
    
                class Medium : Wide
                    {
                        opticsDisplayName	= ""MFOV"";
                        initFov				= 0.125;
                        minFov				= 0.125;
                        maxFov				= 0.125;
                        gunnerOpticsModel	= ""\A3\Drones_F\Weapons_F_Gamma\Reticle\UAV_Optics_Gunner_medium_F.p3d"";
                    };
            };
            class ViewOptics
            {
                initAngleX = 0;
                minAngleX = -90;
                maxAngleX = 25;
                initAngleY = 0;
                minAngleY = -80;
                maxAngleY = 80;
                initFov = 0.15;
                minFov = 0.025;
                maxFov = 0.3;
                visionMode[] = {""Normal"",""NVG""};
            };
            class ViewGunner
            {
                initAngleX = -18;
                minAngleX = -45;
                maxAngleX = 85;
                initAngleY = 0;
                minAngleY = -165;
                maxAngleY = 165;
                initFov = 0.6;
                minFov = 0.25;
                maxFov = 0.6;
            };
            
        };

        class CopilotTurret: CopilotTurret{
            turretInfoType = ""RscOptics_CAS_Pilot"";
            class OpticsIn
            {
                class Wide
                {
                    opticsDisplayName = ""WFOV"";
                    initAngleX = 0;
                    minAngleX = 0;
                    maxAngleX = 0;
                    initAngleY = 0;
                    minAngleY = 0;
                    maxAngleY = 0;
                    initFov = 0.2;
                    minFov = 0.2;
                    maxFov = 0.2;
                    directionStabilized = 0;
                    stabilizedInAxes=""StabilizedInAxesBoth"";
                    visionMode[] = {""Normal"",""NVG""};
                    thermalMode[] = {};
                    gunnerOpticsModel = ""\A3\Drones_F\Weapons_F_Gamma\Reticle\UAV_Optics_Gunner_wide_F.p3d"";
                    opticsPPEffects[] = {""OpticsCHAbera2"",""OpticsBlur2""};
                };
    
                class Medium : Wide
                    {
                        opticsDisplayName	= ""MFOV"";
                        initFov				= 0.125;
                        minFov				= 0.125;
                        maxFov				= 0.125;
                        gunnerOpticsModel	= ""\A3\Drones_F\Weapons_F_Gamma\Reticle\UAV_Optics_Gunner_medium_F.p3d"";
                    };
            };
        };


    };



    };   
};"
9qsk8p8C,dataNone,TestGuy1,JSON,Saturday 15th of March 2025 07:00:07 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'd3e3d5de4443fd8602a4f8de4f8f2f6e11059efd8c86b36617477ae785c602fdc62c2d29c0b8ac944a2c8e339a89fd53ad657556e79a968482afb8601f601b152d042381488407f7ee156cacb8319f9331b391c0c47ad545fbf92a28c32de6918b87c11d2c80cdc9799f7982feb4e013b6fb0a1aa18700e8fdfb80f1b22c16d1',
  otherdata: [
    '31599098a851ae878e5ab7e588cbdce4',
    'f8e826ee6dd4909cd05d20dd61a9a435',
    '360b121c25760d0709b723eb86d3e0c0',
    '50c06dc92f8dc7b2eb6dce04478b828f',
    'ad270ddf896d20062a5dc1af543aed7f',
    '76f2cc5d771d81c735063aedcd54ef12',
    'df38067d702d380f617c18951aa21982',
    'e3a840e59c517871764a52387ab890ec'
  ]
}"
CTERpYN5,sjekk,Nix71,C++,Saturday 15th of March 2025 06:24:41 AM CDT,"
sjekk denne youtube kanalen eller søk youtube etter ""Skizit Gesture""


https://www.youtube.com/playlist?list=PLirQEwT5SeWL9SEO1tgqDM1qsSNc-2ZTE

"
6dB9Z91K,Untitled,hishlishter,C#,Saturday 15th of March 2025 06:08:58 AM CDT,"using System;
using System.Drawing;
using System.Windows.Forms;
using System.Timers;
 
namespace NeuralNetworkPrediction
{
    public class MainPanel : Panel
    {
        // Константы
        private const int N = 300;
        private const double TAU = 0.01;
        private const double TAU_STEP = 0.01;
        private const double D_H = 0.05;
        private const double ALPHA = 0.01;
        private const int R = 10;
        private const double START_X = -10.0;
        private const double END_X = 5.0;
 
        private const double A0 = 11.25; 
        private const double A1 = -1.5;
        private const double A2 = -58;
        private const double A3 = -271.5;
        private const double A4 = -369.25;
        private const double A5 = -95;
 
        // Переменные нейросети
        private double c_x;
        private double[] u_t;
        private double[] u;
        private double[] u_n;
        private double[] g;
        private int n_t;
        private int step;
        private int err;
        private double learningPercentage;
 
        // Графические параметры
        private double graphW, graphH, graphDx, graphBx, graphRx;
 
        private Timer timer;
 
        public MainPanel()
        {
            // Инициализация переменных
            c_x = START_X;
            u_t = new double[N];
            u = new double[N];
            u_n = new double[N];
            g = new double[R];
 
            for (int i = 0; i < N; i++)
            {
                u[i] = 0.0;
                u_t[i] = 0.0;
                u_n[i] = 0.0;
            }
            for (int i = 0; i < R; i++)
            {
                g[i] = 0.0;
            }
            n_t = N / 2 + 1;
            step = 1;
            err = 0;
            learningPercentage = 0.0;
 
            // Настройка панели
            DoubleBuffered = true;
 
            // Запуск таймера
            timer = new Timer();
            timer.Interval = 1;
            timer.Tick += Timer_Tick;
            timer.Start();
        }
 
        private double Sign(double x)
        {
            if (x > 0) return 1.0;
            else if (x < 0) return -1.0;
            return 0.0;
        }
 
        private double F(double x)
        {
            return A0 * Math.Pow(x, 5) + A1 * Math.Pow(x, 4) + A2 * Math.Pow(x, 3)
                + A3 * Math.Pow(x, 2) + A4 * x + A5;
        }
 
        private void Teach(double[] u, double[] g, int n_t, double delta)
        {
            double[] delta_g = new double[R];
            for (int r = 0; r < R; r++)
            {
                double x_r = u[n_t - 1 - r];
                delta_g[r] = ALPHA * Sign(x_r) * Sign(delta);
            }
            for (int r = 0; r < R; r++)
            {
                g[r] += delta_g[r];
            }
            err++;
        }
 
        private void CalculateLearningPercentage()
        {
            double totalError = 0.0;
            double minVal = u[0], maxVal = u[0];
            for (int i = 0; i < N; i++)
            {
                totalError += Math.Abs(u_n[i] - u_t[i]);
                if (u[i] < minVal) minVal = u[i];
                if (u[i] > maxVal) maxVal = u[i];
            }
            double avgError = totalError / N;
            double range = maxVal - minVal;
            if (range < 1e-9) range = 1.0;
            learningPercentage = 100 * (1 - avgError / range);
            if (learningPercentage < 0) learningPercentage = 0;
            if (learningPercentage > 100) learningPercentage = 100;
        }
 
        private void NewStep()
        {
            for (int i = 0; i < N; i++)
            {
                u_n[i] = F(c_x + i * TAU);
            }
            c_x += TAU_STEP;
 
            if (c_x > END_X)
            {
                c_x = START_X;
            }
 
            for (int i = 0; i < N; i++)
            {
                u_t[i] = 0.0;
            }
            for (int i = R; i < N; i++)
            {
                for (int r = 0; r < R; r++)
                {
                    u_t[i] += g[r] * u[i - 1 - r];
                }
            }
            for (int i = 0; i < R; i++)
            {
                u_t[i] = u[i];
            }
 
            double d_u = u_n[n_t] - u_t[n_t];
            if (d_u < -D_H || d_u > D_H)
            {
                Teach(u, g, n_t, d_u);
            }
            step++;
        }
 
        private void UpdateVars()
        {
            NewStep();
            for (int i = 0; i < N; i++)
            {
                u[i] = u_n[i];
            }
            CalculateLearningPercentage();
        }
 
        protected override void OnPaint(PaintEventArgs e)
        {
            base.OnPaint(e);
            Graphics g2 = e.Graphics;
 
            // Инициализация графических параметров
            graphW = Width;
            graphH = Height;
            graphDx = graphW / N;
            graphBx = (graphW - graphDx * (N - 1)) / 2.0;
            graphRx = graphBx + (N - 1) * graphDx;
 
            // Масштабирование
            double minVal = u[0], maxVal = u[0];
            for (int i = 1; i < N; i++)
            {
                if (u[i] < minVal) minVal = u[i];
                if (u[i] > maxVal) maxVal = u[i];
            }
            double mid = (maxVal + minVal) / 2.0;
            double diff = maxVal - minVal;
            minVal = mid - diff * 1.5;
            maxVal = mid + diff * 1.5;
            if (Math.Abs(maxVal - minVal) < 1e-9)
            {
                minVal -= 1.0;
                maxVal += 1.0;
            }
            double localMtt = graphH / (maxVal - minVal);
            double y_c = localMtt * maxVal;
 
            // Рисуем оси
            using (Pen pen = new Pen(Color.Black))
            {
                g2.DrawLine(pen, (float)graphBx, 0, (float)graphBx, (float)graphH);
                g2.DrawLine(pen, (float)graphRx, 0, (float)graphRx, (float)graphH);
                g2.DrawLine(pen, (float)graphBx, 0, (float)graphRx, 0);
                g2.DrawLine(pen, (float)graphBx, (float)graphH, (float)graphRx, (float)graphH);
                g2.DrawLine(pen, (float)graphBx, (float)y_c, (float)graphRx, (float)y_c);
 
                for (int i = 1; i < N - 1; i++)
                {
                    float x = (float)(graphBx + i * graphDx);
                    g2.DrawLine(pen, x, (float)(y_c - 3), x, (float)(y_c + 3));
                }
                float x_nt = (float)(graphBx + (n_t - 1) * graphDx);
                g2.DrawLine(pen, x_nt, 0, x_nt, (float)graphH);
            }
 
            // Рисуем кривую u
            using (Pen greenPen = new Pen(Color.Green))
            {
                float oldX = (float)graphBx;
                float oldY = (float)(y_c - localMtt * u[0]);
                for (int i = 1; i < N; i++)
                {
                    float x = (float)(graphBx + i * graphDx);
                    float y = (float)(y_c - localMtt * u[i]);
                    g2.DrawLine(greenPen, oldX, oldY, x, y);
                    oldX = x;
                    oldY = y;
                }
            }
 
            // Рисуем прогноз u_t
            using (Pen redPen = new Pen(Color.Red))
            {
                float oldX = (float)graphBx;
                float oldY = (float)(y_c - localMtt * u_t[0]);
                for (int i = 1; i < N; i++)
                {
                    float x = (float)(graphBx + i * graphDx);
                    float y = (float)(y_c - localMtt * u_t[i]);
                    g2.DrawLine(redPen, oldX, oldY, x, y);
                    oldX = x;
                    oldY = y;
                }
            }
 
            // Рисуем текст
            using (Font font = new Font(""Arial"", 10))
            using (Brush brush = new SolidBrush(Color.Black))
            {
                float textX = 20;
                float textY = 20;
                g2.DrawString($""Step = {step}"", font, brush, textX, textY); textY += 16;
                g2.DrawString($""dH = {D_H:F2}"", font, brush, textX, textY); textY += 16;
                g2.DrawString($""dG = {ALPHA:F3}"", font, brush, textX, textY); textY += 16;
                for (int i = 0; i < R; i++)
                {
                    g2.DrawString($""G[{i}] = {g[i]:F3}"", font, brush, textX, textY);
                    textY += 16;
                }
                g2.DrawString($""Learning: {learningPercentage:F2}%"", font, brush, textX, textY);
                textY += 16;
                g2.DrawString($""c_x = {c_x:F3}"", font, brush, textX, textY);
            }
        }
 
        protected override Size DefaultSize => new Size(800, 600);
 
        private void Timer_Tick(object sender, EventArgs e)
        {
            UpdateVars();
            Invalidate();
        }
 
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Form form = new Form
            {
                Text = ""Прогнозирование функции (нейросеть)"",
                ClientSize = new Size(800, 600)
            };
            MainPanel panel = new MainPanel();
            form.Controls.Add(panel);
            panel.Dock = DockStyle.Fill;
            form.ShowDialog();
        }
    }
}"
kXPKDDuf,HLL_Nivel3,Letal_1988,INI file,Saturday 15th of March 2025 06:08:10 AM CDT,"Techniques=ContrastAdaptiveSharpen@CAS.fx,Curves@Curves.fx,DPX@DPX.fx,Levels@Levels.fx,LumaSharpen@LumaSharpen.fx,Technicolor2@Technicolor2.fx,Tonemap@Tonemap.fx
TechniqueSorting=AdvancedCRT@CRT.fx,Before@Splitscreen.fx,After@Splitscreen.fx,ContrastAdaptiveSharpen@CAS.fx,ASCII@ASCII.fx,Border@Border.fx,CA@ChromaticAberration.fx,Cartoon@Cartoon.fx,ColorMatrix@ColorMatrix.fx,Curves@Curves.fx,Daltonize@Daltonize.fx,Deband@Deband.fx,DisplayDepth@DisplayDepth.fx,DPX@DPX.fx,FilmGrain@FilmGrain.fx,FXAA@FXAA.fx,HDR@FakeHDR.fx,Layer@Layer.fx,Levels@Levels.fx,LiftGammaGain@LiftGammaGain.fx,LumaSharpen@LumaSharpen.fx,LUT@LUT.fx,Monochrome@Monochrome.fx,Nostalgia@Nostalgia.fx,SMAA@SMAA.fx,Technicolor@Technicolor.fx,Technicolor@HLL.fx,Technicolor2@Technicolor2.fx,Tint@Sepia.fx,Tonemap@Tonemap.fx,UIMask_Top@UIMask.fx,UIMask_Bottom@UIMask.fx,Vibrance@Vibrance.fx,Vignette@Vignette.fx

[CAS.fx]
Contrast=0.000000
Sharpening=2.000000

[Curves.fx]
Contrast=-0.270000
Formula=7
Mode=0

[DPX.fx]
Colorfulness=2.345000
Contrast=0.512000
RGB_C=0.360000,0.360000,0.340000
RGB_Curve=8.000000,8.000000,8.000000
Saturation=3.000000
Strength=0.427000

[Levels.fx]
BlackPoint=27
HighlightClipping=0
WhitePoint=144

[LumaSharpen.fx]
offset_bias=0.388000
pattern=1
sharp_clamp=0.163000
sharp_strength=0.867000
show_sharpen=0

[Technicolor2.fx]
Brightness=0.689000
ColorStrength=0.200000,0.200000,0.200000
Saturation=0.987000
Strength=0.621000

[Tonemap.fx]
Bleach=0.000000
Defog=0.000000
Exposure=0.000000
FogColor=0.000000,0.000000,1.000000
Gamma=1.000000
Saturation=1.000000

"
X5E5erCm,HLL_Nivel2,Letal_1988,INI file,Saturday 15th of March 2025 06:07:23 AM CDT,"Techniques=ContrastAdaptiveSharpen@CAS.fx,Curves@Curves.fx,DPX@DPX.fx,Levels@Levels.fx,LumaSharpen@LumaSharpen.fx,Technicolor2@Technicolor2.fx,Tonemap@Tonemap.fx
TechniqueSorting=AdvancedCRT@CRT.fx,Before@Splitscreen.fx,After@Splitscreen.fx,ContrastAdaptiveSharpen@CAS.fx,ASCII@ASCII.fx,Border@Border.fx,CA@ChromaticAberration.fx,Cartoon@Cartoon.fx,ColorMatrix@ColorMatrix.fx,Curves@Curves.fx,Daltonize@Daltonize.fx,Deband@Deband.fx,DisplayDepth@DisplayDepth.fx,DPX@DPX.fx,FilmGrain@FilmGrain.fx,FXAA@FXAA.fx,HDR@FakeHDR.fx,Layer@Layer.fx,Levels@Levels.fx,LiftGammaGain@LiftGammaGain.fx,LumaSharpen@LumaSharpen.fx,LUT@LUT.fx,Monochrome@Monochrome.fx,Nostalgia@Nostalgia.fx,SMAA@SMAA.fx,Technicolor@Technicolor.fx,Technicolor@HLL.fx,Technicolor2@Technicolor2.fx,Tint@Sepia.fx,Tonemap@Tonemap.fx,UIMask_Top@UIMask.fx,UIMask_Bottom@UIMask.fx,Vibrance@Vibrance.fx,Vignette@Vignette.fx

[CAS.fx]
Contrast=0.000000
Sharpening=2.000000

[Curves.fx]
Contrast=-1.000000
Formula=7
Mode=0

[DPX.fx]
Colorfulness=2.345000
Contrast=0.512000
RGB_C=0.360000,0.360000,0.340000
RGB_Curve=8.000000,8.000000,8.000000
Saturation=3.000000
Strength=0.427000

[Levels.fx]
BlackPoint=37
HighlightClipping=0
WhitePoint=194

[LumaSharpen.fx]
offset_bias=0.388000
pattern=1
sharp_clamp=0.163000
sharp_strength=0.867000
show_sharpen=0

[Technicolor2.fx]
Brightness=0.689000
ColorStrength=0.200000,0.200000,0.200000
Saturation=0.987000
Strength=0.621000

[Tonemap.fx]
Bleach=0.000000
Defog=0.000000
Exposure=0.000000
FogColor=0.000000,0.000000,1.000000
Gamma=1.000000
Saturation=1.000000

"
bJJhvQRC,folk sitter på et lukket nettverk og juger for de store herrer..,Nix71,C++,Saturday 15th of March 2025 06:03:21 AM CDT,"hører folk sitter på et lukket nettverk og juger for de store herrer..

drittlei å gjenta meg sjøl,, men ikke tro på alt dere ser og hører...

holografiske øyer og gud vet hva.

YOU SHOULD GATHER YOURSELF AND BEGIN TO ASK SOME IMPORTANT QUESIONS..

DONT SIT WITH A PHONE/APP AND THINK IT SHOULD BE LIKE THIS..

FOLK BLIR STYRT SKJØNN DET DA... AV DET FORBANNA NETTVERKET..

IKKE GLEM DET ER HUNDRE TUSENVIS MOT DEN SÅKALTE NYE DRITTEN..

BEGYNN Å LES AMERIKANSKE FORUM SÅ SKJØNNER DERE FORBANNELSEN OG GALSKEPEN I VERDEN IDAG.

ALT SER NORMALT UT PÅ UTSIA,MEN ,MEN,MEN...

OG IKKE TRO AT DET ER BARE DERE PÅ TVEITA SOM FÅR MED SEG ALT DETTE.

HVOR ER PERSONVERNET OG RETTSTATEN BLITT AV I ALL IMPLANTASJON OGSÅ VIDERE.

SJEKK ØYA DERES,, HINT"
ZTjY2x7H,Untitled,hishlishter,C#,Saturday 15th of March 2025 06:00:38 AM CDT,"using System;


    public class Program
    {
        // Константы: число нейронов, коэффициент обучения, число обучающих примеров
        const int INPUT_NEURONS = 4;    // Параметры: давление, сахар, пульс, температура
        const int HIDDEN_NEURONS = 3;
        const int OUTPUT_NEURONS = 4;   // 4 класса здоровья
        const double LEARN_RATE = 0.2;
        const int MAX_SAMPLES = 16;

        // Jagged-массивы для весов (с дополнительной строкой для смещения)
        double[][] wih; // Веса между входным и скрытым слоями (размер: INPUT_NEURONS+1 x HIDDEN_NEURONS)
        double[][] who; // Веса между скрытым и выходным слоями (размер: HIDDEN_NEURONS+1 x OUTPUT_NEURONS)

        // Массивы для хранения значений нейронов
        double[] inputs;  // Входной слой
        double[] hidden;  // Скрытый слой
        double[] target;  // Целевой вектор (one-hot кодировка)
        double[] actual;  // Фактический выход сети

        // Массивы для ошибок нейронов
        double[] erro;    // Ошибки на выходном слое
        double[] errh;    // Ошибки на скрытом слое

        // Массив с названиями классов здоровья
        string[] conditions = { ""Здоров"", ""Предболен"", ""Болен"", ""Критическое состояние"" };

        // Класс, представляющий обучающий пример
        public class Sample
        {
            public double bloodPressure; // Артериальное давление (мм рт. ст.)
            public double bloodSugar;    // Уровень сахара (мг/дл)
            public double heartRate;     // Пульс (уд/мин)
            public double temperature;   // Температура тела (°C)
            public double[] Out;         // One-hot представление класса

            public Sample(double bloodPressure, double bloodSugar, double heartRate, double temperature, double[] output)
            {
                this.bloodPressure = bloodPressure;
                this.bloodSugar = bloodSugar;
                this.heartRate = heartRate;
                this.temperature = temperature;
                this.Out = output;
            }
        }

        // Обучающий набор: 16 примеров (по 4 для каждого класса)
        Sample[] samples = new Sample[]
        {
            // ""Здоров"": нормальные показатели
            new Sample(120, 100, 75, 36.8, new double[]{1.0, 0.0, 0.0, 0.0}),
            new Sample(118, 98, 73, 36.7, new double[]{1.0, 0.0, 0.0, 0.0}),
            new Sample(121, 101, 76, 36.9, new double[]{1.0, 0.0, 0.0, 0.0}),
            new Sample(119, 99, 74, 36.8, new double[]{1.0, 0.0, 0.0, 0.0}),

            // ""Предболен"": небольшие отклонения
            new Sample(130, 110, 80, 37.2, new double[]{0.0, 1.0, 0.0, 0.0}),
            new Sample(128, 108, 79, 37.1, new double[]{0.0, 1.0, 0.0, 0.0}),
            new Sample(131, 112, 81, 37.3, new double[]{0.0, 1.0, 0.0, 0.0}),
            new Sample(129, 109, 80, 37.2, new double[]{0.0, 1.0, 0.0, 0.0}),

            // ""Болен"": выраженные отклонения
            new Sample(150, 140, 90, 38.0, new double[]{0.0, 0.0, 1.0, 0.0}),
            new Sample(148, 138, 89, 37.9, new double[]{0.0, 0.0, 1.0, 0.0}),
            new Sample(151, 142, 91, 38.1, new double[]{0.0, 0.0, 1.0, 0.0}),
            new Sample(149, 139, 90, 38.0, new double[]{0.0, 0.0, 1.0, 0.0}),

            // ""Критическое состояние"": очень сильные отклонения
            new Sample(170, 180, 120, 39.0, new double[]{0.0, 0.0, 0.0, 1.0}),
            new Sample(168, 178, 118, 38.9, new double[]{0.0, 0.0, 0.0, 1.0}),
            new Sample(171, 182, 121, 39.1, new double[]{0.0, 0.0, 0.0, 1.0}),
            new Sample(169, 179, 119, 39.0, new double[]{0.0, 0.0, 0.0, 1.0})
        };

        // Минимальные и максимальные значения для нормализации входных данных
        const double BP_MIN = 80;       // мм рт. ст.
        const double BP_MAX = 180;
        const double SUGAR_MIN = 70;    // мг/дл
        const double SUGAR_MAX = 200;
        const double HR_MIN = 50;       // уд/мин
        const double HR_MAX = 150;
        const double TEMP_MIN = 35;     // °C
        const double TEMP_MAX = 41;

        static Random rand = new Random();

        // Конструктор: выделение памяти для массивов весов и нейронов
        public Program()
        {
            wih = new double[INPUT_NEURONS + 1][];
            for (int i = 0; i < INPUT_NEURONS + 1; i++)
            {
                wih[i] = new double[HIDDEN_NEURONS];
            }
            who = new double[HIDDEN_NEURONS + 1][];
            for (int i = 0; i < HIDDEN_NEURONS + 1; i++)
            {
                who[i] = new double[OUTPUT_NEURONS];
            }

            inputs = new double[INPUT_NEURONS];
            hidden = new double[HIDDEN_NEURONS];
            target = new double[OUTPUT_NEURONS];
            actual = new double[OUTPUT_NEURONS];

            erro = new double[OUTPUT_NEURONS];
            errh = new double[HIDDEN_NEURONS];
        }

        // Инициализация весов случайными значениями в диапазоне [-0.5, 0.5]
        void AssignRandomWeights()
        {
            for (int inp = 0; inp < INPUT_NEURONS + 1; inp++)
            {
                for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
                {
                    wih[inp][hid] = rand.NextDouble() - 0.5;
                }
            }
            for (int hid = 0; hid < HIDDEN_NEURONS + 1; hid++)
            {
                for (int out = 0; out < OUTPUT_NEURONS; out++)
                {
                    who[hid][out] = rand.NextDouble() - 0.5;
                }
            }
        }

        // Функция активации (сигмоида) и её производная
        double Sigmoid(double val)
        {
            return 1.0 / (1.0 + Math.Exp(-val));
        }

        double SigmoidDerivative(double val)
        {
            return val * (1.0 - val);
        }

        // Нормализация входных данных (без добавления шума)
        void NormalizeInputs()
        {
            inputs[0] = (inputs[0] - BP_MIN) / (BP_MAX - BP_MIN);
            inputs[1] = (inputs[1] - SUGAR_MIN) / (SUGAR_MAX - SUGAR_MIN);
            inputs[2] = (inputs[2] - HR_MIN) / (HR_MAX - HR_MIN);
            inputs[3] = (inputs[3] - TEMP_MIN) / (TEMP_MAX - TEMP_MIN);
        }

        // Прямое распространение сигнала по сети
        void FeedForward()
        {
            // Вычисление выхода скрытого слоя
            for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
            {
                double sum = 0.0;
                for (int inp = 0; inp < INPUT_NEURONS; inp++)
                {
                    sum += inputs[inp] * wih[inp][hid];
                }
                // Добавляем смещение (последний элемент в wih)
                sum += wih[INPUT_NEURONS][hid];
                hidden[hid] = Sigmoid(sum);
            }
            // Вычисление выхода выходного слоя
            for (int out = 0; out < OUTPUT_NEURONS; out++)
            {
                double sum = 0.0;
                for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
                {
                    sum += hidden[hid] * who[hid][out];
                }
                // Добавляем смещение (последний элемент в who)
                sum += who[HIDDEN_NEURONS][out];
                actual[out] = Sigmoid(sum);
            }
        }

        // Алгоритм обратного распространения ошибки
        void BackPropagate()
        {
            // Вычисление ошибки на выходном слое
            for (int out = 0; out < OUTPUT_NEURONS; out++)
            {
                erro[out] = (target[out] - actual[out]) * SigmoidDerivative(actual[out]);
            }
            // Вычисление ошибки на скрытом слое
            for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
            {
                errh[hid] = 0.0;
                for (int out = 0; out < OUTPUT_NEURONS; out++)
                {
                    errh[hid] += erro[out] * who[hid][out];
                }
                errh[hid] *= SigmoidDerivative(hidden[hid]);
            }
            // Обновление весов между скрытым и выходным слоями
            for (int out = 0; out < OUTPUT_NEURONS; out++)
            {
                for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
                {
                    who[hid][out] += LEARN_RATE * erro[out] * hidden[hid];
                }
                // Обновление смещения
                who[HIDDEN_NEURONS][out] += LEARN_RATE * erro[out];
            }
            // Обновление весов между входным и скрытым слоями
            for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
            {
                for (int inp = 0; inp < INPUT_NEURONS; inp++)
                {
                    wih[inp][hid] += LEARN_RATE * errh[hid] * inputs[inp];
                }
                // Обновление смещения
                wih[INPUT_NEURONS][hid] += LEARN_RATE * errh[hid];
            }
        }

        // Функция, возвращающая индекс элемента с наибольшим значением (определяет класс)
        int Action(double[] vector)
        {
            int sel = 0;
            double max = vector[0];
            for (int i = 1; i < OUTPUT_NEURONS; i++)
            {
                if (vector[i] > max)
                {
                    max = vector[i];
                    sel = i;
                }
            }
            return sel;
        }

        public static void Main(string[] args)
        {
            Program eq = new Program();
            eq.AssignRandomWeights();

            int sampleIndex = 0;
            double err;
            // Обучение сети (10000 итераций)
            for (int step = 0; step < 10000; step++)
            {
                sampleIndex = (sampleIndex + 1) % MAX_SAMPLES;
                Sample s = eq.samples[sampleIndex];
                // Заполняем входной вектор данными из обучающего примера
                // Порядок: давление, сахар, пульс, температура
                eq.inputs[0] = s.bloodPressure;
                eq.inputs[1] = s.bloodSugar;
                eq.inputs[2] = s.heartRate;
                eq.inputs[3] = s.temperature;
                // Нормализуем входные данные (без шума)
                eq.NormalizeInputs();
                // Копируем целевой вектор
                for (int i = 0; i < OUTPUT_NEURONS; i++)
                {
                    eq.target[i] = s.Out[i];
                }
                eq.FeedForward();
                err = 0.0;
                for (int i = 0; i < OUTPUT_NEURONS; i++)
                {
                    double diff = s.Out[i] - eq.actual[i];
                    err += diff * diff;
                }
                err = 0.5 * err;
                if (step % 1000 == 0)
                {
                    Console.WriteLine(""step = "" + step + "" mse = "" + err);
                }
                eq.BackPropagate();
            }

            Console.WriteLine();
            int correct = 0;
            // Проверка сети на обучающих примерах
            for (int i = 0; i < MAX_SAMPLES; i++)
            {
                Sample s = eq.samples[i];
                eq.inputs[0] = s.bloodPressure;
                eq.inputs[1] = s.bloodSugar;
                eq.inputs[2] = s.heartRate;
                eq.inputs[3] = s.temperature;
                eq.NormalizeInputs();
                for (int j = 0; j < OUTPUT_NEURONS; j++)
                {
                    eq.target[j] = s.Out[j];
                }
                eq.FeedForward();
                int predicted = eq.Action(eq.actual);
                int expected = eq.Action(eq.target);
                if (predicted != expected)
                {
                    Console.WriteLine(""Input: "" + s.bloodPressure + "" "" + s.bloodSugar + "" "" 
                        + s.heartRate + "" "" + s.temperature +
                        "" predicted: "" + eq.conditions[predicted] +
                        "" expected: "" + eq.conditions[expected]);
                }
                else
                {
                    correct++;
                }
            }
            Console.WriteLine(""Network is "" + ((float)correct / MAX_SAMPLES * 100.0) + ""% correct\n"");

            // Дополнительное тестирование с новыми входными данными:
            // Порядок входов: давление, сахар, пульс, температура.
            double[][] testInputs = new double[][]
            {
                new double[] {120, 100, 75, 36.8},   // ожидается ""Здоров""
                new double[] {130, 110, 80, 37.2},   // ожидается ""Предболен""
                new double[] {150, 140, 90, 38.0},   // ожидается ""Болен""
                new double[] {170, 180, 120, 39.0}   // ожидается ""Критическое состояние""
            };
            foreach (double[] test in testInputs)
            {
                eq.inputs[0] = test[0];
                eq.inputs[1] = test[1];
                eq.inputs[2] = test[2];
                eq.inputs[3] = test[3];
                eq.NormalizeInputs();
                eq.FeedForward();
                int index = eq.Action(eq.actual);
                Console.WriteLine(""Input: ["" + test[0] + "", "" + test[1] + "", "" + test[2] + "", "" + test[3]
                    + ""] -> "" + eq.conditions[index]);
            }
        }
    }
"
EdPxUdv3,Event overlap times,Code_187,Python,Saturday 15th of March 2025 05:54:29 AM CDT,"def find_event_overlap(event1, event2):
    def time_to_minutes(time_str):
        hours, minutes = map(int, time_str.split(':'))
        return hours * 60 + minutes

    start1, end1 = time_to_minutes(event1[0]), time_to_minutes(event1[1])
    start2, end2 = time_to_minutes(event2[0]), time_to_minutes(event2[1])

    overlap_start = max(start1, start2)
    overlap_end = min(end1, end2)

    if overlap_start <= overlap_end:
        def minutes_to_time(minutes):
            hours = minutes // 60
            minutes %= 60
            return ""{:02d}:{:02d}"".format(hours, minutes)

        return 'true'""\n""f""The two events overlap from {minutes_to_time(overlap_start)} to {minutes_to_time(overlap_end)}.""
    else:
        return 'false'""\n""""The two events do not overlap.""


event_1 = [""02:15"",""04:00""]
event_2 = [""04:00"",""06:00""]
print(find_event_overlap(event_1, event_2))

event_1 = [""01:00"", ""02:35""]
event_2 = [""01:25"", ""06:00""]
print(find_event_overlap(event_1, event_2))

event_1 = [""10:15"", ""11:15""]
event_2 = [""14:30"", ""16:40""]
print(find_event_overlap(event_1, event_2))"
B4KxbHhd,Untitled,hishlishter,C#,Saturday 15th of March 2025 05:54:28 AM CDT,"using System;

namespace Org.Example
{
    public class Program
    {
        // Константы: число нейронов, скорость обучения и число обучающих примеров
        const int INPUT_NEURONS = 4;    // Параметры: давление, сахар, пульс, температура
        const int HIDDEN_NEURONS = 3;
        const int OUTPUT_NEURONS = 4;   // 4 класса здоровья
        const double LEARN_RATE = 0.2;
        const int MAX_SAMPLES = 16;

        // Jagged-массивы для весов (с дополнительной строкой для смещения)
        double[][] wih; // Веса между входным и скрытым слоями (размер: INPUT_NEURONS+1 x HIDDEN_NEURONS)
        double[][] who; // Веса между скрытым и выходным слоями (размер: HIDDEN_NEURONS+1 x OUTPUT_NEURONS)

        // Массивы для хранения значений нейронов
        double[] inputs;  // Входной слой
        double[] hidden;  // Скрытый слой
        double[] target;  // Целевой вектор (one-hot кодировка)
        double[] actual;  // Фактический выход сети

        // Массивы для ошибок нейронов
        double[] erro;    // Ошибки на выходном слое
        double[] errh;    // Ошибки на скрытом слое

        // Массив с названиями классов здоровья
        string[] conditions = { ""Здоров"", ""Предболен"", ""Болен"", ""Критическое состояние"" };

        // Класс, представляющий обучающий пример
        public class Sample
        {
            public double bloodPressure; // Артериальное давление (мм рт. ст.)
            public double bloodSugar;    // Уровень сахара (мг/дл)
            public double heartRate;     // Пульс (уд/мин)
            public double temperature;   // Температура тела (°C)
            public double[] Out;         // One-hot представление класса

            public Sample(double bloodPressure, double bloodSugar, double heartRate, double temperature, double[] output)
            {
                this.bloodPressure = bloodPressure;
                this.bloodSugar = bloodSugar;
                this.heartRate = heartRate;
                this.temperature = temperature;
                this.Out = output;
            }
        }

        // Обучающий набор: 16 примеров (по 4 для каждого класса)
        Sample[] samples = new Sample[]
        {
            // ""Здоров"": нормальные показатели
            new Sample(120, 100, 75, 36.8, new double[] {1.0, 0.0, 0.0, 0.0}),
            new Sample(118, 98, 73, 36.7, new double[] {1.0, 0.0, 0.0, 0.0}),
            new Sample(121, 101, 76, 36.9, new double[] {1.0, 0.0, 0.0, 0.0}),
            new Sample(119, 99, 74, 36.8, new double[] {1.0, 0.0, 0.0, 0.0}),

            // ""Предболен"": небольшие отклонения
            new Sample(130, 110, 80, 37.2, new double[] {0.0, 1.0, 0.0, 0.0}),
            new Sample(128, 108, 79, 37.1, new double[] {0.0, 1.0, 0.0, 0.0}),
            new Sample(131, 112, 81, 37.3, new double[] {0.0, 1.0, 0.0, 0.0}),
            new Sample(129, 109, 80, 37.2, new double[] {0.0, 1.0, 0.0, 0.0}),

            // ""Болен"": выраженные отклонения
            new Sample(150, 140, 90, 38.0, new double[] {0.0, 0.0, 1.0, 0.0}),
            new Sample(148, 138, 89, 37.9, new double[] {0.0, 0.0, 1.0, 0.0}),
            new Sample(151, 142, 91, 38.1, new double[] {0.0, 0.0, 1.0, 0.0}),
            new Sample(149, 139, 90, 38.0, new double[] {0.0, 0.0, 1.0, 0.0}),

            // ""Критическое состояние"": очень сильные отклонения
            new Sample(170, 180, 120, 39.0, new double[] {0.0, 0.0, 0.0, 1.0}),
            new Sample(168, 178, 118, 38.9, new double[] {0.0, 0.0, 0.0, 1.0}),
            new Sample(171, 182, 121, 39.1, new double[] {0.0, 0.0, 0.0, 1.0}),
            new Sample(169, 179, 119, 39.0, new double[] {0.0, 0.0, 0.0, 1.0})
        };

        // Диапазоны для нормализации входных данных
        const double BP_MIN = 80;      // мм рт. ст.
        const double BP_MAX = 180;
        const double SUGAR_MIN = 70;   // мг/дл
        const double SUGAR_MAX = 200;
        const double HR_MIN = 50;      // уд/мин
        const double HR_MAX = 150;
        const double TEMP_MIN = 35;    // °C
        const double TEMP_MAX = 41;

        // Статический экземпляр Random для генерации случайных чисел
        static Random rand = new Random();

        // Конструктор: инициализация массивов
        public Program()
        {
            // Инициализация массивов для весов
            wih = new double[INPUT_NEURONS + 1][];
            for (int i = 0; i < INPUT_NEURONS + 1; i++)
            {
                wih[i] = new double[HIDDEN_NEURONS];
            }
            who = new double[HIDDEN_NEURONS + 1][];
            for (int i = 0; i < HIDDEN_NEURONS + 1; i++)
            {
                who[i] = new double[OUTPUT_NEURONS];
            }
            // Инициализация массивов для нейронов и ошибок
            inputs = new double[INPUT_NEURONS];
            hidden = new double[HIDDEN_NEURONS];
            target = new double[OUTPUT_NEURONS];
            actual = new double[OUTPUT_NEURONS];
            erro = new double[OUTPUT_NEURONS];
            errh = new double[HIDDEN_NEURONS];
        }

        // Инициализация весов случайными значениями в диапазоне [-0.5, 0.5]
        void AssignRandomWeights()
        {
            for (int inp = 0; inp < INPUT_NEURONS + 1; inp++)
            {
                for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
                {
                    wih[inp][hid] = rand.NextDouble() - 0.5;
                }
            }
            for (int hid = 0; hid < HIDDEN_NEURONS + 1; hid++)
            {
                for (int out = 0; out < OUTPUT_NEURONS; out++)
                {
                    who[hid][out] = rand.NextDouble() - 0.5;
                }
            }
        }

        // Функция активации (сигмоида) и её производная
        double Sigmoid(double val)
        {
            return 1.0 / (1.0 + Math.Exp(-val));
        }

        double SigmoidDerivative(double val)
        {
            return val * (1.0 - val);
        }

        // Нормализация входных данных (без добавления шума)
        void NormalizeInputs()
        {
            // Приведение к диапазону [0, 1] по формуле: (value - min) / (max - min)
            inputs[0] = (inputs[0] - BP_MIN) / (BP_MAX - BP_MIN);
            inputs[1] = (inputs[1] - SUGAR_MIN) / (SUGAR_MAX - SUGAR_MIN);
            inputs[2] = (inputs[2] - HR_MIN) / (HR_MAX - HR_MIN);
            inputs[3] = (inputs[3] - TEMP_MIN) / (TEMP_MAX - TEMP_MIN);
        }

        // Прямое распространение сигнала по сети
        void FeedForward()
        {
            // Вычисление выхода скрытого слоя
            for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
            {
                double sum = 0.0;
                for (int inp = 0; inp < INPUT_NEURONS; inp++)
                {
                    sum += inputs[inp] * wih[inp][hid];
                }
                // Смещение: последний элемент в массиве wih для данного скрытого нейрона
                sum += wih[INPUT_NEURONS][hid];
                hidden[hid] = Sigmoid(sum);
            }
            // Вычисление выхода выходного слоя
            for (int out = 0; out < OUTPUT_NEURONS; out++)
            {
                double sum = 0.0;
                for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
                {
                    sum += hidden[hid] * who[hid][out];
                }
                // Смещение: последний элемент в массиве who для данного выходного нейрона
                sum += who[HIDDEN_NEURONS][out];
                actual[out] = Sigmoid(sum);
            }
        }

        // Алгоритм обратного распространения ошибки
        void BackPropagate()
        {
            // Вычисление ошибки на выходном слое
            for (int out = 0; out < OUTPUT_NEURONS; out++)
            {
                erro[out] = (target[out] - actual[out]) * SigmoidDerivative(actual[out]);
            }
            // Вычисление ошибки на скрытом слое
            for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
            {
                errh[hid] = 0.0;
                for (int out = 0; out < OUTPUT_NEURONS; out++)
                {
                    errh[hid] += erro[out] * who[hid][out];
                }
                errh[hid] *= SigmoidDerivative(hidden[hid]);
            }
            // Обновление весов между скрытым и выходным слоями
            for (int out = 0; out < OUTPUT_NEURONS; out++)
            {
                for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
                {
                    who[hid][out] += LEARN_RATE * erro[out] * hidden[hid];
                }
                // Обновление смещения
                who[HIDDEN_NEURONS][out] += LEARN_RATE * erro[out];
            }
            // Обновление весов между входным и скрытым слоями
            for (int hid = 0; hid < HIDDEN_NEURONS; hid++)
            {
                for (int inp = 0; inp < INPUT_NEURONS; inp++)
                {
                    wih[inp][hid] += LEARN_RATE * errh[hid] * inputs[inp];
                }
                // Обновление смещения
                wih[INPUT_NEURONS][hid] += LEARN_RATE * errh[hid];
            }
        }

        // Функция, возвращающая индекс элемента с наибольшим значением (определяет класс)
        int Action(double[] vector)
        {
            int sel = 0;
            double max = vector[0];
            for (int i = 1; i < OUTPUT_NEURONS; i++)
            {
                if (vector[i] > max)
                {
                    max = vector[i];
                    sel = i;
                }
            }
            return sel;
        }

        public static void Main(string[] args)
        {
            Program wc = new Program();
            wc.AssignRandomWeights();

            int sampleIndex = 0;
            double err;
            // Обучение сети (10000 итераций)
            for (int step = 0; step < 10000; step++)
            {
                sampleIndex = (sampleIndex + 1) % MAX_SAMPLES;
                Sample s = wc.samples[sampleIndex];
                // Заполняем входной вектор данными из обучающего примера
                // Порядок: давление, сахар, пульс, температура
                wc.inputs[0] = s.bloodPressure;
                wc.inputs[1] = s.bloodSugar;
                wc.inputs[2] = s.heartRate;
                wc.inputs[3] = s.temperature;
                // Нормализуем входные данные (без шума)
                wc.NormalizeInputs();
                // Копируем целевой вектор
                for (int i = 0; i < OUTPUT_NEURONS; i++)
                {
                    wc.target[i] = s.Out[i];
                }
                wc.FeedForward();
                err = 0.0;
                for (int i = 0; i < OUTPUT_NEURONS; i++)
                {
                    double diff = s.Out[i] - wc.actual[i];
                    err += diff * diff;
                }
                err = 0.5 * err;
                if (step % 1000 == 0)
                {
                    Console.WriteLine(""step = "" + step + "" mse = "" + err);
                }
                wc.BackPropagate();
            }

            Console.WriteLine();
            int correct = 0;
            // Проверка сети на обучающих примерах
            for (int i = 0; i < MAX_SAMPLES; i++)
            {
                Sample s = wc.samples[i];
                wc.inputs[0] = s.bloodPressure;
                wc.inputs[1] = s.bloodSugar;
                wc.inputs[2] = s.heartRate;
                wc.inputs[3] = s.temperature;
                wc.NormalizeInputs();
                for (int j = 0; j < OUTPUT_NEURONS; j++)
                {
                    wc.target[j] = s.Out[j];
                }
                wc.FeedForward();
                int predicted = wc.Action(wc.actual);
                int expected = wc.Action(wc.target);
                if (predicted != expected)
                {
                    Console.WriteLine(""Input: "" + s.bloodPressure + "" "" + s.bloodSugar + "" "" 
                        + s.heartRate + "" "" + s.temperature +
                        "" predicted: "" + wc.conditions[predicted] +
                        "" expected: "" + wc.conditions[expected]);
                }
                else
                {
                    correct++;
                }
            }
            Console.WriteLine(""Network is "" + ((float)correct / MAX_SAMPLES * 100.0) + ""% correct\n"");

            // Дополнительное тестирование с новыми входными данными
            // Задаем тестовые значения, ожидаемые для каждого класса:
            double[][] testInputs = new double[][]
            {
                new double[] {120, 100, 75, 36.8},   // ожидается ""Здоров""
                new double[] {130, 110, 80, 37.2},   // ожидается ""Предболен""
                new double[] {150, 140, 90, 38.0},   // ожидается ""Болен""
                new double[] {170, 180, 120, 39.0}   // ожидается ""Критическое состояние""
            };
            foreach (double[] test in testInputs)
            {
                wc.inputs[0] = test[0];
                wc.inputs[1] = test[1];
                wc.inputs[2] = test[2];
                wc.inputs[3] = test[3];
                wc.NormalizeInputs();
                wc.FeedForward();
                int index = wc.Action(wc.actual);
                Console.WriteLine(""Input: ["" + test[0] + "", "" + test[1] + "", "" + test[2] + "", "" + test[3]
                    + ""] -> "" + wc.conditions[index]);
            }
        }
    }
}
"
AfXjh89Y,Untitled,VeNoM_1,Pawn,Saturday 15th of March 2025 05:48:13 AM CDT,"#include <a_samp>
#include <samp_bcrypt>
#include <sscanf2>
#include <zcmd>
#define SERVER_DATABASE ""server.db""

#define REGISTER_DIALOG 0
#define LOGIN_DIALOG 1
#define MAX_HOUSES 100
#define PLAYER 0
#define HELPER 1
#define ADMIN 2
#define OWNER 3

#define VIP_BRONZE 0
#define VIP_SILVER 1
#define VIP_GOLD 2
#define VIP_DIAMOND 3
#define REWARD_INTERVAL (3600000)
#define REWARD_MONEY 2000
#define REWARD_SCORE 1

#define GAMESTATE_FREEROAM 0
#define GAMESTATE_ROLEPLAY 1
#define VIP_CHAT_COLOR F72585

#define COLOR_YELLOW 0xFFFF00AA
#define COLOR_RED 0xAA3333AA
#define COLOR_MAGENTA 0xFF00FFFF
#define COLOR_GOLD 0xFFD700FF
#define COLOR_GREEN 0x008000FF

new DB:server_database;
new DBResult:database_result;
new rpName[MAX_PLAYERS][24];
new Text:PublicTD[1];

enum player_data
{
	player_kills,
	player_deaths,
	player_admin_level,
	player_vip_level,

	bool:player_logged
};

new PlayerData[MAX_PLAYERS][player_data];
new gamestate=GAMESTATE_FREEROAM;

stock GetName(playerid)
{
	new name[MAX_PLAYER_NAME];
	GetPlayerName(playerid, name, sizeof(name));
	return name;
}

stock DB_Escape(text[])//Credits: Y_Less
{
    new ret[80 * 2], ch, i, j;
    while ((ch = text[i++]) && j < sizeof (ret))
    {
        if (ch == '\'')
        {
            if (j < sizeof (ret) - 2)
            {
                ret[j++] = '\'';
                ret[j++] = '\'';
            }
        }
        else if (j < sizeof (ret))
        {
            ret[j++] = ch;
        }
        else
        {
            j++;
        }
    }
    ret[sizeof (ret) - 1] = '\0';
    return ret;
}

stock SaveAccount(playerid)
{
    new query[256];
	if(PlayerData[playerid][player_logged] == true)
	{
	    format(query, sizeof(query),
		""UPDATE USERS SET SCORE = '%d', KILLS = '%d', DEATHS = '%d',ADMIN_LEVEL = '%d', VIP_LEVEL = '%d' WHERE NAME = '%s' COLLATE NOCASE"",
		GetPlayerScore(playerid), PlayerData[playerid][player_kills], PlayerData[playerid][player_deaths],
		PlayerData[playerid][player_admin_level], PlayerData[playerid][player_vip_level],GetName(playerid));
		database_result = db_query(server_database, query);
		db_free_result(database_result);
	}
	return 1;
}


main() { }

public OnGameModeInit()
{
	SetGameModeText(""Blank Script"");
	SetTimer(""GiveHourlyReward"",REWARD_INTERVAL,true);
	ManualVehicleEngineAndLights();
	AddPlayerClass(0, 1958.3783, 1343.1572, 15.3746, 269.1425, 0, 0, 0, 0, 0, 0);

	server_database = db_open(SERVER_DATABASE);

	db_query(server_database, ""CREATE TABLE IF NOT EXISTS USERS (`NAME`, `PASS`, `SCORE`, `KILLS`, `DEATHS`,`ADMIN_LEVEL`,`VIP_LEVEL`)"");
    PublicTD[0] = TextDrawCreate(480.000000, 316.000000, ""~y~NAME:_~g~INFERNUS~n~~y~SPEED:_~b~0KM/h~n~~y~HEALTH:_~r~100~n~~y~FUEL:_~w~64L"");
    TextDrawFont(PublicTD[0], 1);
    TextDrawLetterSize(PublicTD[0], 0.229166, 1.950000);
    TextDrawTextSize(PublicTD[0], 572.500000, 15.500000);
    TextDrawSetOutline(PublicTD[0], 1);
    TextDrawSetShadow(PublicTD[0], 0);
    TextDrawAlignment(PublicTD[0], 1);
    TextDrawColor(PublicTD[0], -1);
    TextDrawBackgroundColor(PublicTD[0], 255);
    TextDrawBoxColor(PublicTD[0], 100);
    TextDrawUseBox(PublicTD[0], 1);
    TextDrawSetProportional(PublicTD[0], 1);
    TextDrawSetSelectable(PublicTD[0], 0);
	return 1;
}

public OnGameModeExit()
{
    db_close(server_database);
	return 1;
}

public OnPlayerConnect(playerid)
{
	SetPlayerScore(playerid, 0);

	PlayerData[playerid][player_kills] = 0;
	PlayerData[playerid][player_deaths] = 0;
	PlayerData[playerid][player_admin_level] = 0;
	PlayerData[playerid][player_logged] = false;
	GivePlayerMoney(playerid, 500000);

    new query[128];
	format(query, sizeof(query), ""SELECT NAME FROM USERS WHERE NAME = '%s' COLLATE NOCASE"", DB_Escape(GetName(playerid)));
  	database_result = db_query(server_database, query);
  	if(db_num_rows(database_result))
	{
		ShowPlayerDialog(playerid, LOGIN_DIALOG, DIALOG_STYLE_PASSWORD, ""{FFFFFF}Account Login"", ""{FFFFFF}Please enter your password below to login to your account:"", ""Enter"", ""Leave"");
	}
	else
	{
		ShowPlayerDialog(playerid, REGISTER_DIALOG, DIALOG_STYLE_PASSWORD, ""{FFFFFF}Register Account"", ""{FFFFFF}Please enter a password below to register an account:"", ""Enter"", ""Leave"");
	}
	return 1;
}

public OnPlayerDisconnect(playerid, reason)
{
	SaveAccount(playerid);
	return 1;
}

public OnPlayerStateChange(playerid, newstate, oldstate)
{
    if (newstate == PLAYER_STATE_DRIVER) // Player entered a vehicle as a driver
    {
        TextDrawShowForPlayer(playerid, PublicTD[0]);
    }
    else if (oldstate == PLAYER_STATE_DRIVER) // Player exited the vehicle
    {
        TextDrawHideForPlayer(playerid, PublicTD[0]);
    }
    return 1;
}

public OnPlayerDeath(playerid, killerid, reason)
{
    if(killerid != INVALID_PLAYER_ID)
	{
	    SetPlayerScore(killerid, GetPlayerScore(killerid) + 1);
		PlayerData[killerid][player_kills]++;
	}

	SetPlayerScore(playerid, GetPlayerScore(playerid) - 1);
    PlayerData[playerid][player_deaths]++;
	return 1;
}

public OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])
{
	if(dialogid == REGISTER_DIALOG)
	{
	    if(response)
	    {
	        if(strlen(inputtext) < 3 || strlen(inputtext) > 24)
			{
				SendClientMessage(playerid, -1, ""SERVER: Your password must be from 3-24 characters."");
				return ShowPlayerDialog(playerid, REGISTER_DIALOG, DIALOG_STYLE_PASSWORD, ""{FFFFFF}Register Account"", ""{FFFFFF}Please enter a password below to register an account:"", ""Enter"", ""Leave"");
			}

			bcrypt_hash(playerid, ""OnPlayerRegister"", inputtext, 12);
			return 1;
	    }
	    else
	    {
	        Kick(playerid);
	    }
	}
	else if(dialogid == LOGIN_DIALOG)
	{
	    if(response)
	    {
	        new query[256], field[64];
	        format(query, sizeof(query), ""SELECT PASS FROM USERS WHERE NAME = '%s' COLLATE NOCASE"", DB_Escape(GetName(playerid)));
			database_result = db_query(server_database, query);
		  	if(db_num_rows(database_result))
			{
				db_get_field_assoc(database_result, ""PASS"", field, sizeof(field));
			  	bcrypt_verify(playerid, ""OnPlayerLogin"", inputtext, field);
			}
			return 1;
	    }
	    else
	    {
	        Kick(playerid);
	    }
	}
	return 1;
}

forward OnPlayerLogin(playerid, bool:success);
public OnPlayerLogin(playerid, bool:success)
{
 	if(success)
	{
		new query[256], field[24];
	    format(query, sizeof(query), ""SELECT * FROM USERS WHERE NAME = '%s' COLLATE NOCASE"", DB_Escape(GetName(playerid)));
		database_result = db_query(server_database, query);
		if(db_num_rows(database_result))
		{
			db_get_field_assoc(database_result, ""SCORE"", field, sizeof(field));
			SetPlayerScore(playerid, strval(field));

			db_get_field_assoc(database_result, ""KILLS"", field, sizeof(field));
			PlayerData[playerid][player_kills] = strval(field);

			db_get_field_assoc(database_result, ""DEATHS"", field, sizeof(field));
			PlayerData[playerid][player_deaths] = strval(field);

			db_get_field_assoc(database_result, ""ADMIN_LEVEL"", field, sizeof(field));
			PlayerData[playerid][player_admin_level] = strval(field);
			db_get_field_assoc(database_result, ""VIP_LEVEL"", field, sizeof(field));
			PlayerData[playerid][player_vip_level] = strval(field);
		}

		db_free_result(database_result);

		PlayerData[playerid][player_logged] = true;

		SendClientMessage(playerid, -1, ""SERVER: You have successfully logged into your account."");
		return 1;
 	}
	else
 	{
 		Kick(playerid);
 	}
	return 1;
}

forward OnPlayerRegister(playerid);
public OnPlayerRegister(playerid)
{
	new password[64];
	bcrypt_get_hash(password);

	new query[256];
	format(query, sizeof(query), ""INSERT INTO USERS (NAME, PASS, SCORE, KILLS, DEATHS,ADMIN_LEVEL,VIP_LEVEL,last_x,last_y,last_z,last_angle,INT,WORLD) VALUES ('%s', '%s', '%d', '%d', '%d','%d','%d')"", DB_Escape(GetName(playerid)), password, GetPlayerScore(playerid), PlayerData[playerid][player_kills], PlayerData[playerid][player_deaths],PlayerData[playerid][player_admin_level],PlayerData[playerid][player_vip_level]);
	database_result = db_query(server_database, query);
	db_free_result(database_result);

	PlayerData[playerid][player_logged] = true;

	SendClientMessage(playerid, -1, ""SERVER: You have successfully registered an account."");
	return 1;
}
forward GiveHourlyReward();
public GiveHourlyReward()
{
	new i;
	for(i=0;i<MAX_PLAYERS;i++)
	{
	    GivePlayerMoney(i,REWARD_MONEY);
	    SetPlayerScore(i,GetPlayerScore(i)+REWARD_SCORE);
	    SendClientMessage(i, 0x00FF00FF, ""You have received your hourly reward: $2000 and +1 Score!"");
	}
	return 1;
}
public OnPlayerText(playerid,text[])
{
    if(text[0]=='#')
    {
        if (PlayerData[playerid][player_vip_level] < VIP_BRONZE)
        {
            SendClientMessage(playerid, COLOR_RED, ""You are not a VIP!"");
            return 0; // Block message from being sent to normal chat
        }
        new message[128];
        format(message, sizeof(message), ""[VIP Chat] %s: %s"", GetPlayerNameEx(playerid), text[1]); // Remove #

        for (new i = 0; i < MAX_PLAYERS; i++)
        {
            if (IsPlayerConnected(i) && PlayerData[i][player_vip_level] >= VIP_BRONZE)
            {
                SendClientMessage(i, COLOR_GOLD, message);
            }
        }

        return 0; // Block original message from going to normal chat
	}
	
	return 1;
}

public OnPlayerUpdate(playerid)
{
    if (GetPlayerState(playerid) == PLAYER_STATE_DRIVER) // Only update if player is driving
    {
        new vehicleid = GetPlayerVehicleID(playerid);
        new vehicleModel = GetVehicleModel(vehicleid);
        new Float:vehicleHealth;
		GetVehicleHealth(vehicleid, vehicleHealth);

        // Get speed
        new str[64], speed = GetPlayerSpeed(playerid);
        format(str, sizeof(str), ""~y~NAME:_~g~%s~n~~y~SPEED:_~b~%dKM/h~n~~y~HEALTH:_~r~%d~n~~y~FUEL:_~w~64L"",
               GetVehicleName(vehicleModel), speed, vehicleHealth);

        TextDrawSetString(PublicTD[0], str);
    }
    return 1;
}
stock GetPlayerSpeed(playerid)
{
    new Float:x, Float:y, Float:z, Float:speed;
    GetPlayerVelocity(playerid, x, y, z);

    // Approximate square root without floatsqrt
    new Float:sum = (x * x + y * y + z * z);
    new Float:approx = sum / (1.0 + sum / 2.0); // Simple approximation

    speed = floatmul(approx, 180.0); // Convert to km/h
    return floatround(speed);
}
stock GetVehicleName(vehicleid)
{
    new name[32];
    switch (vehicleid)
    {
        case 411: name = ""INFERNUS"";
        case 451: name = ""TURISMO"";
        case 400: name = ""LANDSTALKER"";
        default: name = ""UNKNOWN"";
    }
    return name;
}
stock GetPlayerNameEx(playerid)
{
    new name[MAX_PLAYER_NAME];
    GetPlayerName(playerid, name, sizeof(name));
    return name;
}
CMD:setlevel(playerid, params[])
{
    new targetid, name[MAX_PLAYER_NAME], level[16], string[128], query[256], admin;

    if (!IsPlayerAdmin(playerid))
        return SendClientMessage(playerid, -1, ""You are not authorized to use this command."");

    // Parse the parameters using sscanf
    if (sscanf(params, ""us[16]"", targetid, level))
        return SendClientMessage(playerid, -1, ""Syntax: /setlevel [playerid] [level]"");

    // Check if target player is valid
    if (!IsPlayerConnected(targetid))
        return SendClientMessage(playerid, -1, ""Invalid player ID."");

    // Determine admin level
    if (!strcmp(level, ""player"", true)) admin = PLAYER;
    else if (!strcmp(level, ""helper"", true)) admin = HELPER;
    else if (!strcmp(level, ""admin"", true)) admin = ADMIN;
    else if (!strcmp(level, ""owner"", true)) admin = OWNER;
    else
        return SendClientMessage(playerid, -1, ""Invalid admin level."");

    // Get player's name
    GetPlayerName(targetid, name, sizeof(name));

    // Check if database is connected
    if (!server_database)
        return SendClientMessage(playerid, -1, ""Database connection error."");

    // Query to check if player exists in DB
    format(query, sizeof(query), ""SELECT ADMIN_LEVEL FROM USERS WHERE NAME = '%s' COLLATE NOCASE"", DB_Escape(name));
    new DBResult:result = db_query(server_database, query);

    if (db_num_rows(result))
    {
        db_free_result(result);

        // Update admin level in database
        format(query, sizeof(query), ""UPDATE USERS SET ADMIN_LEVEL = %d WHERE NAME = '%s' COLLATE NOCASE"", admin, DB_Escape(name));
        db_query(server_database, query);

        // Update player's admin level in memory
        PlayerData[targetid][player_admin_level] = admin;

        format(string, sizeof(string), ""SERVER: You have successfully set the admin level of %s to %s."", name, level);
        SendClientMessage(playerid, -1, string);
    }
    else
    {
        SendClientMessage(playerid, -1, ""Player not found in database."");
        db_free_result(result);
    }

    return 1;
}

CMD:setvip(playerid, params[])
{
    new targetid, name[24], vip[16], string[128], query[256], vip_level;

    if (!IsPlayerAdmin(playerid))
        return SendClientMessage(playerid, -1, ""You are not authorized to use this command."");

    // Corrected sscanf format
    if (sscanf(params, ""us[16]"", targetid, name, vip))
        return SendClientMessage(playerid, -1, ""Syntax: /setvip [playerid] [vip level]"");

    if (!IsPlayerConnected(targetid))
        return SendClientMessage(playerid, -1, ""Invalid player ID."");

    if (!strcmp(vip, ""bronze"", true)) vip_level = VIP_BRONZE;
    else if (!strcmp(vip, ""silver"", true)) vip_level = VIP_SILVER;
    else if (!strcmp(vip, ""gold"", true)) vip_level = VIP_GOLD;
    else if (!strcmp(vip, ""diamond"", true)) vip_level = VIP_DIAMOND;
    else
        return SendClientMessage(playerid, -1, ""Invalid VIP level."");

    format(query, sizeof(query), ""UPDATE USERS SET VIP_LEVEL = %d WHERE NAME = '%s' COLLATE NOCASE"", vip_level, DB_Escape(name));
    db_query(server_database, query);

    PlayerData[targetid][player_vip_level] = vip_level;

    format(string, sizeof(string), ""SERVER: You have successfully set the VIP level of %s to %s."", name, vip);
    SendClientMessage(playerid, -1, string);

    return 1;
}

CMD:v(playerid,params[])
{
	if(PlayerData[playerid][player_vip_level]<VIP_BRONZE)
	{
	    return SendClientMessage(playerid, -1, ""You are not a VIP player."");
	}
	if(isnull(params))
	{
	    return SendClientMessage(playerid, -1, ""Usage: /v [message]"");
	}
	new color, msg[128], name[MAX_PLAYER_NAME];
    GetPlayerName(playerid, name, sizeof(name));
    switch(PlayerData[playerid][player_vip_level])
    {
        case VIP_BRONZE: color = 0xCD7F32FF; // Bronze
        case VIP_SILVER: color = 0xC0C0C0FF; // Silver
        case VIP_GOLD: color = 0xFFD700FF; // Gold
        case VIP_DIAMOND: color = 0xFFF72585; // Diamond
        default: color = 0xFFFFFFAA;
    }
    format(msg, sizeof(msg), ""[VIP Chat] %s: %s"", name, params);
    for(new i = 0; i < MAX_PLAYERS; i++)
    {
        if(PlayerData[i][player_vip_level] >= VIP_BRONZE)
        {
            SendClientMessage(i, color, msg);
        }
    }
	return 1;
}
CMD:checkstatus(playerid, params[])
{
    new targetid, name[MAX_PLAYER_NAME], string[128], adminTitle[32], vipTitle[32];

    // If no parameters are provided, check the player's own status
    if (sscanf(params, ""u"", targetid))
        targetid = playerid;

    if (!IsPlayerConnected(targetid))
        return SendClientMessage(playerid, -1, ""Invalid player ID."");

    GetPlayerName(targetid, name, sizeof(name));

    // Assign Admin Titles
    switch (PlayerData[targetid][player_admin_level])
    {
        case 0:  adminTitle = ""None"";
        case 1:  adminTitle = ""Moderator"";
        case 2:  adminTitle = ""Administrator"";
        case 3:  adminTitle = ""Senior Admin"";
        case 4:  adminTitle = ""Head Admin"";
        case 5:  adminTitle = ""Owner"";
        default: adminTitle = ""Unknown"";
    }

    // Assign VIP Titles
    switch (PlayerData[targetid][player_vip_level])
    {
        case 0:  vipTitle = ""None"";
        case 1:  vipTitle = ""Silver VIP"";
        case 2:  vipTitle = ""Gold VIP"";
        case 3:  vipTitle = ""Platinum VIP"";
        case 4:  vipTitle = ""Diamond VIP"";
        default: vipTitle = ""Unknown"";
    }

    format(string, sizeof(string), ""Player: %s | Admin: %s | VIP: %s"", name, adminTitle, vipTitle);
    SendClientMessage(playerid, -1, string);

    return 1;
}
/*CMD:ban(playerid,params[])
{
	new targetid,reason;
	if(PlayerData[playerid][player_admin_level]<5) return SendClientMessage(playerid,-1,""You are not authorized to use this command"");
	if(sscanf(params,""uz"",targetid,reason))return SendClientMessage(playerid,-1,""Usage: /ban [playerid] [reason]"");
	if(!IsPlayerConnected(playerid))return SendClientMessage(playerid,-1,""Player is not connected"");
	
	
}*/
CMD:cca(playerid, params[])
{
    if (!IsPlayerAdmin(playerid) && PlayerData[playerid][player_admin_level]<0) // Check if the player is an admin
    {
        SendClientMessage(playerid, 0xFF0000FF, ""You don't have permission to use this command!"");
        return 1;
    }

    for (new i = 0; i < 50; i++) // Sends 50 empty messages to clear the chat for all players
    {
        SendClientMessageToAll(-1, "" "");
    }

    SendClientMessageToAll(0x00FF00FF, ""The chat has been cleared by an admin!"");
    return 1;
}
CMD:engine(playerid, params[])
{
    if(!IsPlayerInAnyVehicle(playerid)) return SendClientMessage(playerid, COLOR_RED, ""You are not in a vehicle!"");

    new vehicleid = GetPlayerVehicleID(playerid);
    new engine, lights, alarm, doors, bonnet, boot, objective;
    GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);

    if(engine == VEHICLE_PARAMS_OFF) {
        SetVehicleParamsEx(vehicleid, VEHICLE_PARAMS_ON, lights, alarm, doors, bonnet, boot, objective);
        SendClientMessage(playerid, COLOR_YELLOW, ""Engine started!"");
    } else {
        SetVehicleParamsEx(vehicleid, VEHICLE_PARAMS_OFF, lights, alarm, doors, bonnet, boot, objective);
        SendClientMessage(playerid, -1, ""Engine turned off!"");
    }
    return 1;
}

CMD:lights(playerid, params[])
{
    if(!IsPlayerInAnyVehicle(playerid)) return SendClientMessage(playerid, COLOR_RED, ""You are not in a vehicle!"");

    new vehicleid = GetPlayerVehicleID(playerid);
    new engine, lights, alarm, doors, bonnet, boot, objective;
    GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);

    if(lights == VEHICLE_PARAMS_OFF) {
        SetVehicleParamsEx(vehicleid, engine, VEHICLE_PARAMS_ON, alarm, doors, bonnet, boot, objective);
        SendClientMessage(playerid, COLOR_YELLOW, ""Lights turned on!"");
    } else {
        SetVehicleParamsEx(vehicleid, engine, VEHICLE_PARAMS_OFF, alarm, doors, bonnet, boot, objective);
        SendClientMessage(playerid, -1, ""Lights turned off!"");
    }
    return 1;
}

CMD:bonnet(playerid, params[])
{
    if(!IsPlayerInAnyVehicle(playerid)) return SendClientMessage(playerid, COLOR_RED, ""You are not in a vehicle!"");

    new vehicleid = GetPlayerVehicleID(playerid);
    new engine, lights, alarm, doors, bonnet, boot, objective;
    GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);

    if(bonnet == VEHICLE_PARAMS_OFF) {
        SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, VEHICLE_PARAMS_ON, boot, objective);
        SendClientMessage(playerid, COLOR_YELLOW, ""Bonnet opened!"");
    } else {
        SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, VEHICLE_PARAMS_OFF, boot, objective);
        SendClientMessage(playerid, -1, ""Bonnet closed!"");
    }
    return 1;
}

CMD:boot(playerid, params[])
{
    if(!IsPlayerInAnyVehicle(playerid)) return SendClientMessage(playerid, COLOR_RED, ""You are not in a vehicle!"");

    new vehicleid = GetPlayerVehicleID(playerid);
    new engine, lights, alarm, doors, bonnet, boot, objective;
    GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);

    if(boot == VEHICLE_PARAMS_OFF) {
        SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, VEHICLE_PARAMS_ON, objective);
        SendClientMessage(playerid, COLOR_YELLOW, ""Boot opened!"");
    } else {
        SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, VEHICLE_PARAMS_OFF, objective);
        SendClientMessage(playerid, -1, ""Boot closed!"");
    }
    return 1;
}

CMD:doors(playerid, params[])
{
    if(!IsPlayerInAnyVehicle(playerid)) return SendClientMessage(playerid, COLOR_RED, ""You are not in a vehicle!"");

    new vehicleid = GetPlayerVehicleID(playerid);
    new engine, lights, alarm, doors, bonnet, boot, objective;
    GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);

    if(doors == VEHICLE_PARAMS_OFF) {
        SetVehicleParamsEx(vehicleid, engine, lights, alarm, VEHICLE_PARAMS_ON, bonnet, boot, objective);
        SendClientMessage(playerid, COLOR_YELLOW, ""Doors locked!"");
    } else {
        SetVehicleParamsEx(vehicleid, engine, lights, alarm, VEHICLE_PARAMS_OFF, bonnet, boot, objective);
        SendClientMessage(playerid, -1, ""Doors unlocked!"");
    }
    return 1;
}
CMD:viphelp(playerid, params[])
{
    if(PlayerData[playerid][player_vip_level]<VIP_BRONZE) return SendClientMessage(playerid, COLOR_RED, ""You are not a VIP!"");

    SendClientMessage(playerid, COLOR_GOLD, ""[VIP COMMANDS]"");
    SendClientMessage(playerid, COLOR_YELLOW, ""/vipheal - Fully restores your health & armor"");
    SendClientMessage(playerid, COLOR_YELLOW, ""/vipcar - Spawns a luxury VIP vehicle"");
    SendClientMessage(playerid, COLOR_YELLOW, ""/vipskin - Change to exclusive VIP skins"");
    SendClientMessage(playerid, COLOR_YELLOW, ""/vipweapons - Get special weapons"");
    SendClientMessage(playerid, COLOR_YELLOW, ""/vipjetpack - Get a jetpack"");
    SendClientMessage(playerid,COLOR_YELLOW,""/viprepair - Repairs the car"");
    return 1;
}
CMD:vipheal(playerid, params[])
{
    if(PlayerData[playerid][player_vip_level] > 0)
    {
        SetPlayerHealth(playerid, 100.0);
        SendClientMessage(playerid, COLOR_YELLOW, ""VIP: You have been healed!"");
    }
    else
    {
        SendClientMessage(playerid, COLOR_RED, ""VIP: This command is only for VIP players!"");
    }
    return 1;
}

CMD:vipweapons(playerid, params[])
{
    if(PlayerData[playerid][player_vip_level] > 0)
    {
        GivePlayerWeapon(playerid, 24, 100); // Deagle with 100 ammo
        GivePlayerWeapon(playerid, 31, 200); // M4 with 200 ammo
        SendClientMessage(playerid, COLOR_YELLOW, ""VIP: You have received your VIP weapons!"");
    }
    else
    {
        SendClientMessage(playerid, COLOR_RED, ""VIP: This command is only for VIP players!"");
    }
    return 1;
}

CMD:vipcar(playerid, params[])
{
    if (PlayerData[playerid][player_vip_level] < VIP_BRONZE) // Check if player is VIP
    {
        SendClientMessage(playerid, COLOR_RED, ""You are not a VIP!"");
        return 1;
    }

    new vehicleid;
    if(sscanf(params, ""d"", vehicleid))
    {
        SendClientMessage(playerid, COLOR_YELLOW, ""Usage: /vipcar [vehicle ID]"");
        return 1;
    }

    SpawnVIPCar(playerid, vehicleid);
    return 1;
}

CMD:vipcolor(playerid, params[])
{
    if(PlayerData[playerid][player_vip_level] > 0)
    {
        new color;
        switch (PlayerData[playerid][player_vip_level])
        {
            case VIP_BRONZE: color = 0xCD7F32FF;
            case VIP_SILVER: color = 0xC0C0C0FF;
            case VIP_GOLD: color = 0xFFD700FF;
            case VIP_DIAMOND: color = 0x1E90FFFF;
        }
        SetPlayerColor(playerid, color);
        SendClientMessage(playerid, COLOR_YELLOW, ""VIP: Your player color has been updated!"");
    }
    else
    {
        SendClientMessage(playerid, COLOR_RED, ""VIP: This command is only for VIP players!"");
    }
    return 1;
}
CMD:viprepair(playerid, params[])
{
    if (PlayerData[playerid][player_vip_level] < VIP_BRONZE)
    {
        SendClientMessage(playerid, COLOR_RED, ""You are not a VIP!"");
        return 1;
    }

    new vehicleid = GetPlayerVehicleID(playerid);
    if (!vehicleid)
    {
        SendClientMessage(playerid, COLOR_YELLOW, ""You are not in a vehicle!"");
        return 1;
    }

    RepairVehicle(vehicleid);
    SendClientMessage(playerid, COLOR_GREEN, ""Your vehicle has been repaired!"");
    return 1;
}

CMD:vipjetpack(playerid, params[])
{
    if(PlayerData[playerid][player_vip_level] > 0)
    {
        GivePlayerWeapon(playerid, 370, 1); // Jetpack
        SendClientMessage(playerid, COLOR_YELLOW, ""VIP: You have received a Jetpack!"");
    }
    else
    {
        SendClientMessage(playerid, COLOR_RED, ""VIP: This command is only for VIP players!"");
    }
    return 1;
}
stock SpawnVIPCar(playerid, vehicleid)
{
    new Float:x, Float:y, Float:z, Float:angle;

    // Get player position and facing angle
    GetPlayerPos(playerid, x, y, z);
    GetPlayerFacingAngle(playerid, angle);

    // Calculate position in front of the player
    x += 3.0 * floatsin(-angle, degrees);
    y += 3.0 * floatcos(-angle, degrees);

    // Spawn the VIP car in front of the player
    new carid = CreateVehicle(vehicleid, x, y, z, angle, -1, -1, 100);

    // Put player in the driver's seat
    PutPlayerInVehicle(playerid, carid, 0);

    SendClientMessage(playerid, 0x00FF00FF, ""VIP car has been spawned in front of you!"");

    return carid;
}
CMD:vipskin(playerid, params[])
{
    if (PlayerData[playerid][player_vip_level] < VIP_BRONZE)
    {
        SendClientMessage(playerid, COLOR_RED, ""You are not a VIP!"");
        return 1;
    }

    new skinid;
    if(sscanf(params, ""d"", skinid))
    {
        SendClientMessage(playerid, COLOR_YELLOW, ""Usage: /vipskin [skin ID]"");
        return 1;
    }

    if (skinid < 0 || skinid > 311) // San Andreas has skins from 0 to 311
    {
        SendClientMessage(playerid, COLOR_RED, ""Invalid skin ID! Choose between 0-311."");
        return 1;
    }

    SetPlayerSkin(playerid, skinid);
    SendClientMessage(playerid, COLOR_GREEN, ""Your VIP skin has been changed!"");

    return 1;
}
CMD:freeroam(playerid, params[])
{
    if (gamestate == GAMESTATE_FREEROAM) return SendClientMessage(playerid, COLOR_RED, ""You are already in Freeroam mode."");
    gamestate = GAMESTATE_FREEROAM;
    SendClientMessageToAll(COLOR_YELLOW, ""Game state changed to Freeroam."");
    return 1;
}

CMD:roleplay(playerid, params[])
{
    if (gamestate == GAMESTATE_ROLEPLAY) return SendClientMessage(playerid, COLOR_RED, ""You are already in Roleplay mode."");
    gamestate = GAMESTATE_ROLEPLAY;
    SendClientMessageToAll(COLOR_YELLOW, ""Game state changed to Roleplay."");
    return 1;
}
CMD:me(playerid, params[])
{
    if (gamestate != GAMESTATE_ROLEPLAY)
        return SendClientMessage(playerid, COLOR_RED, ""Roleplay mode is not enabled!"");
    if (isnull(params))
        return SendClientMessage(playerid, COLOR_YELLOW, ""USAGE: /me [action]"");
    new str[128];
    format(str, sizeof(str), ""* %s %s"", rpName[playerid], params);
    SendClientMessageToAll(COLOR_YELLOW, str);
    return 1;
}

CMD:do(playerid, params[])
{
    if (gamestate != GAMESTATE_ROLEPLAY)
        return SendClientMessage(playerid, COLOR_RED, ""Roleplay mode is not enabled!"");
    if (isnull(params))
        return SendClientMessage(playerid, COLOR_YELLOW, ""USAGE: /do [description]"");
    new str[128];
    format(str, sizeof(str), ""* %s"", params);
    SendClientMessageToAll(COLOR_YELLOW, str);
    return 1;
}

CMD:b(playerid, params[])
{
    if (gamestate != GAMESTATE_ROLEPLAY)
        return SendClientMessage(playerid, COLOR_RED, ""Roleplay mode is not enabled!"");
    if (isnull(params))
        return SendClientMessage(playerid, COLOR_YELLOW, ""USAGE: /b [message]"");
    new str[128];
    format(str, sizeof(str), ""(OOC) %s: %s"", rpName[playerid], params);
    SendClientMessageToAll(COLOR_YELLOW, str);
    return 1;
}
CMD:shout(playerid, params[])
{
    if (gamestate != GAMESTATE_ROLEPLAY)
        return SendClientMessage(playerid, COLOR_RED, ""Roleplay mode is not enabled!"");
    if (isnull(params))
        return SendClientMessage(playerid, COLOR_YELLOW, ""USAGE: /shout [message]"");
    new str[128];
    format(str, sizeof(str), ""%s shouts: %s!"", rpName[playerid], strupr(params));
    SendClientMessageToAll(COLOR_YELLOW, str);
    return 1;
}
stock strupr(string[])
{
    for (new i = 0; i < strlen(string); i++)
    {
        if (string[i] >= 'a' && string[i] <= 'z')
        {
            string[i] -= 32; // Convert to uppercase
        }
    }
    return string;
}
"
ZdAVZC9z,# tk_text_zoom.py,here2share,Python,Saturday 15th of March 2025 05:43:19 AM CDT,"# tk_text_zoom.py

import tkinter as tk
from PIL import Image, ImageDraw, ImageFont, ImageTk

WW, HH = 640, 640
CX, CY = WW // 2, HH // 2

root = tk.Tk()
root.title(""# tk_text_zoom.py"")
root.geometry(""+0+0"")
canvas = tk.Canvas(root, width=WW, height=HH)
canvas.pack()

def get_font(font_size):
    return ImageFont.truetype(""times.ttf"", font_size)

def create_txt():
    font_size = 400
    font = get_font(font_size)
    while True:
        bbox = font.getbbox(""a"")
        text_width = bbox[2] - bbox[0]
        text_height = bbox[3] - bbox[1]
        if text_width > WW - 8 or text_height > HH - 8:
            break
        font_size += 1
        font = get_font(font_size)
        
    def blank_check():
        for x in range(WW):
            if pixels[x, HH - 1][0]:
                return False
        return True
    
    for y_offset in range(HH):
        img = Image.new(""RGBA"", (WW, HH), (0, 0, 0, 0))
        draw = ImageDraw.Draw(img)
        draw.text((CX, CY - y_offset), ""a"", fill=""red"", font=font, anchor=""mm"")
        pixels = img.load()
        if blank_check():
            break
    return img

img_txt_default = create_txt()
img_txt = img_txt_default.copy()
zoom = 1.05

current_scale = 1
while 1:
	t = int(current_scale)
	scaled_img = img_txt.resize((t, t), Image.ANTIALIAS)

	if t > WW:
		left = (t - WW) // 2
		top = (t - HH) // 2
		right = left + WW
		bottom = top + HH
		img_txt = scaled_img.crop((left, top, right, bottom))
		zoom = 1.0075

		if current_scale > 780:
			img_txt = img_txt_default.copy()
			current_scale = 1
	else:
		zoom = 1.05
		
	current_scale *= zoom

	scaled_tk_img = ImageTk.PhotoImage(scaled_img)

	canvas.delete(""all"")
	canvas.create_image(CX, CY, image=scaled_tk_img, anchor=""center"")

	canvas.update()"
