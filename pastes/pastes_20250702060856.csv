id,title,username,language,date,content
J9L0HGMs,✅ MAKE $12OO IN 10 MIN 8,patoza,JavaScript,Wednesday 2nd of July 2025 01:03:39 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 2675720
"
y6byP5EB,Untitled,johnkris,Python,Wednesday 2nd of July 2025 01:03:07 AM CDT,"import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from pathlib import Path
import shutil, pandas as pd, matplotlib.pyplot as plt, numpy as np, datetime, pytz, scipy.stats, threading, time
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
try:
    from PIL import Image, ImageTk, ImageResampling
    LANCZOS = ImageResampling.LANCZOS
except:
    from PIL import Image, ImageTk
    LANCZOS = Image.LANCZOS
import subprocess, logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s-%(levelname)s-%(message)s')

class SeismicWaveAnalyzer:
    def __init__(self, root):
        self.root = root
        self.root.withdraw()
        self.data_dir = Path.home() / ""SeismicWaveData""
        self.out_dir = self.data_dir / ""Outputs""
        self.data_dir.mkdir(exist_ok=True)
        self.out_dir.mkdir(exist_ok=True)
        self.show_splash()

    def show_splash(self):
        s = tk.Toplevel()
        s.title(""Welcome"")
        s.configure(bg=""#fff"")
        s.attributes('-fullscreen', True)
        s.overrideredirect(True)
        ttk.Button(s, text=""Skip"", command=lambda: self.launch_main(s), style=""Custom.TButton"").place(relx=.95, rely=.95, anchor=""se"")
        try:
            img = Image.open(self.data_dir / ""picture1.png"").resize((200, 200), LANCZOS)
            p = ImageTk.PhotoImage(img)
            tk.Label(s, image=p, bg=""#fff"").place(x=20, y=20)
            img_label = tk.Label(s, image=p)
            img_label.image = p
        except:
            tk.Label(s, text=""[Image 1]"", width=20, height=10, bg=""#d3d3d3"").place(x=20, y=20)
        try:
            img = Image.open(self.data_dir / ""picture2.png"").resize((200, 200), LANCZOS)
            p = ImageTk.PhotoImage(img)
            tk.Label(s, image=p, bg=""#fff"").place(relx=1.0, y=20, anchor=""ne"")
            img_label = tk.Label(s, image=p)
            img_label.image = p
        except:
            tk.Label(s, text=""[Image 2]"", width=20, height=10, bg=""#d3d3d3"").place(relx=1.0, y=20, anchor=""ne"")
        f = tk.Frame(s, bg=""#fff"")
        f.place(relx=.5, rely=.5, anchor=""center"")
        tk.Label(f, text=""Seismic Wave Analysis"", font=(""Segoe UI"", 20, ""bold""), bg=""#fff"").pack(pady=10)
        tk.Label(f, text=""FTT Mode Project"", font=(""Segoe UI"", 16), bg=""#fff"").pack(pady=5)
        tk.Label(f, text=""Instrumentation & Eng. Geophysics"", font=(""Segoe UI"", 14), bg=""#fff"").pack(pady=5)
        tk.Label(f, text=""Dr N Satyavani, Lead"", font=(""Segoe UI"", 14, ""italic""), bg=""#fff"").pack(pady=5)
        s.after(6000, lambda: self.launch_main(s))

    def launch_main(self, s):
        s.destroy()
        self.root.deiconify()
        self.root.title(""Seismic Wave Analysis Tool"")
        self.root.geometry(""1000x700"")
        self.root.state('zoomed')
        self.theme = {""bg"": ""#fff"", ""fg"": ""#212121"", ""entry_bg"": ""#f5f5f5"", ""accent"": ""#003087"", ""btn_fg"": ""#fff""}
        self.root.configure(bg=self.theme[""bg""])
        self.raw_tree = self.qual_tree = self.ana_tree = self.sum_tree = self.lay_tree = self.corr_tree = self.rt_tree = self.plot_canvas = self.cur_fig = None
        self.cur_data = self.raw_data = self.cur_file = self.deviations = self.qual_issues = self.layers = self.corr_data = self.rt_data = None
        self.plot_label = ttk.Label(self.root)
        self.sel_rows = {}
        self.min_d_var = tk.StringVar()
        self.max_d_var = tk.StringVar()
        self.rt_running = False
        self.plot_opts = {k: tk.BooleanVar(value=True) for k in [""Vp/Vs Ratio"", ""Poisson's Ratio"", ""Shear Modulus"", ""Bulk Modulus"", ""Young's Modulus"", ""Travel Time Deviations""]}
        self.setup_gui()
        self.update_clock()

    def setup_gui(self):
        m = tk.Menu(self.root)
        self.root.config(menu=m)
        fm = tk.Menu(m, tearoff=0)
        m.add_cascade(label=""File"", menu=fm)
        fm.add_command(label=""Exit"", command=self.root.quit)
        ff = ttk.Frame(self.root)
        ff.pack(pady=10, padx=10, fill=tk.X)
        ttk.Label(ff, text=""Upload CHST:"", font=(""Segoe UI"", 10)).pack(side=tk.LEFT, padx=5)
        ttk.Button(ff, text=""Upload"", command=self.upload_file, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(ff, text=""Create Template"", command=self.create_template, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(ff, text=""Import CSV to PDF"", command=self.import_csv_pdf, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(ff, text=""Refresh"", command=self.refresh_files, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Label(ff, text=""Select File:"", font=(""Segoe UI"", 10)).pack(side=tk.LEFT, padx=5)
        self.file_var = tk.StringVar()
        self.file_cb = ttk.Combobox(ff, textvariable=self.file_var, state=""readonly"")
        self.file_cb.pack(side=tk.LEFT, padx=5)
        self.file_cb.bind(""<<ComboboxSelected>>"", self.load_file)
        self.nb = ttk.Notebook(self.root)
        self.nb.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)
        self.raw_f = ttk.Frame(self.nb)
        self.nb.add(self.raw_f, text=""Raw Data"")
        self.setup_raw_tab()
        self.qual_f = ttk.Frame(self.nb)
        self.nb.add(self.qual_f, text=""Quality Check"")
        self.setup_qual_tab()
        self.ana_f = ttk.Frame(self.nb)
        self.nb.add(self.ana_f, text=""Analysis"")
        self.setup_ana_tab()
        self.sum_f = ttk.Frame(self.nb)
        self.nb.add(self.sum_f, text=""Summary"")
        self.setup_sum_tab()
        self.lay_f = ttk.Frame(self.nb)
        self.nb.add(self.lay_f, text=""Layers"")
        self.setup_lay_tab()
        self.corr_f = ttk.Frame(self.nb)
        self.nb.add(self.corr_f, text=""Correlation Analysis"")
        self.setup_corr_tab()
        self.rt_f = ttk.Frame(self.nb)
        self.nb.add(self.rt_f, text=""Real-Time"")
        self.setup_rt_tab()
        self.viz_f = ttk.Frame(self.nb)
        self.nb.add(self.viz_f, text=""Visualizations"")
        self.setup_viz_tab()
        ef = ttk.Frame(self.root)
        ef.pack(pady=5, fill=tk.X)
        for t, c in [(""Raw Data"", self.export_raw), (""Quality Check"", self.export_qual), (""Analysis to PDF"", self.export_ana_pdf), (""Summary"", self.export_sum), (""Layers"", self.export_lay), (""Correlation"", self.export_corr), (""Detailed Report"", self.export_report)]:
            ttk.Button(ef, text=f""Export {t} to CSV"", command=c, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        sf = ttk.Frame(self.root)
        sf.pack(side=tk.BOTTOM, fill=tk.X)
        self.status_var = tk.StringVar()
        tk.Label(sf, textvariable=self.status_var, bd=1, relief=tk.SUNKEN, anchor=tk.W, font=(""Segoe UI"", 10)).pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.clock_var = tk.StringVar()
        tk.Label(sf, textvariable=self.clock_var, bd=1, relief=tk.SUNKEN, anchor=tk.E, font=(""Segoe UI"", 10)).pack(side=tk.RIGHT)
        self.apply_theme()
        self.refresh_files()

    def apply_theme(self):
        s = ttk.Style()
        s.theme_use('clam')
        s.configure(""Custom.TButton"", background=self.theme[""accent""], foreground=self.theme[""btn_fg""], font=(""Segoe UI"", 10), padding=8)
        s.map(""Custom.TButton"", background=[('active', '#002070')], foreground=[('active', '#fff')])
        s.configure(""TCombobox"", fieldbackground=self.theme[""entry_bg""], foreground=self.theme[""fg""])
        s.configure(""Treeview"", background=self.theme[""entry_bg""], foreground=self.theme[""fg""], fieldbackground=self.theme[""entry_bg""])
        s.configure(""Treeview.Heading"", background=self.theme[""bg""], foreground=self.theme[""fg""])

    def update_clock(self):
        self.clock_var.set(datetime.now(pytz.timezone('Asia/Kolkata')).strftime(""%a, %b %d, %Y %I:%M %p IST""))
        self.root.after(1000, self.update_clock)

    def setup_raw_tab(self):
        sf = ttk.Frame(self.raw_f)
        sf.pack(fill=tk.X, pady=5)
        ttk.Label(sf, text=""Depth Range (m):"").pack(side=tk.LEFT, padx=5)
        ttk.Entry(sf, textvariable=self.min_d_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Label(sf, text=""to"").pack(side=tk.LEFT)
        ttk.Entry(sf, textvariable=self.max_d_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(sf, text=""Apply"", command=self.apply_sel, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(sf, text=""Reset"", command=self.reset_sel, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        f = ttk.Frame(self.raw_f)
        f.pack(pady=10, fill=tk.BOTH, expand=True)
        c = tk.Canvas(f)
        sy = ttk.Scrollbar(f, orient=tk.VERTICAL, command=c.yview)
        sx = ttk.Scrollbar(f, orient=tk.HORIZONTAL, command=c.xview)
        sf = ttk.Frame(c)
        sf.bind(""<Configure>"", lambda e: c.configure(scrollregion=c.bbox(""all"")))
        c.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
        sy.pack(side=tk.RIGHT, fill=tk.Y)
        sx.pack(side=tk.BOTTOM, fill=tk.X)
        c.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        c.create_window((0, 0), window=sf, anchor=""nw"")
        self.raw_tree = ttk.Treeview(sf, show=""headings"")
        self.raw_tree.pack(fill=tk.BOTH, expand=True)

    def setup_qual_tab(self):
        f = ttk.Frame(self.qual_f)
        f.pack(pady=10, fill=tk.BOTH, expand=True)
        c = tk.Canvas(f)
        sy = ttk.Scrollbar(f, orient=tk.VERTICAL, command=c.yview)
        sx = ttk.Scrollbar(f, orient=tk.HORIZONTAL, command=c.xview)
        sf = ttk.Frame(c)
        sf.bind(""<Configure>"", lambda e: c.configure(scrollregion=c.bbox(""all"")))
        c.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
        sy.pack(side=tk.RIGHT, fill=tk.Y)
        sx.pack(side=tk.BOTTOM, fill=tk.X)
        c.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        c.create_window((0, 0), window=sf, anchor=""nw"")
        self.qual_tree = ttk.Treeview(sf, show=""headings"")
        self.qual_tree.pack(fill=tk.BOTH, expand=True)

    def setup_ana_tab(self):
        f = ttk.Frame(self.ana_f)
        f.pack(pady=10, fill=tk.BOTH, expand=True)
        cf = ttk.Frame(f)
        cf.pack(fill=tk.X, pady=5)
        b = ttk.Button(cf, text=""Run Monte Carlo"", command=self.run_mc, style=""Custom.TButton"")
        b.pack(side=tk.LEFT, padx=5)
        b.bind(""<Enter>"", lambda e: self.show_tip(b, ""Runs 1000 iterations with 1% noise""))
        b.bind(""<Leave>"", lambda e: self.hide_tip())
        c = tk.Canvas(f)
        sy = ttk.Scrollbar(f, orient=tk.VERTICAL, command=c.yview)
        sx = ttk.Scrollbar(f, orient=tk.HORIZONTAL, command=c.xview)
        sf = ttk.Frame(c)
        sf.bind(""<Configure>"", lambda e: c.configure(scrollregion=c.bbox(""all"")))
        c.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
        sy.pack(side=tk.RIGHT, fill=tk.Y)
        sx.pack(side=tk.BOTTOM, fill=tk.X)
        c.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        c.create_window((0, 0), window=sf, anchor=""nw"")
        self.ana_tree = ttk.Treeview(sf, show=""headings"")
        self.ana_tree.pack(fill=tk.BOTH, expand=True)

    def show_tip(self, w, t):
        self.tip = tk.Toplevel(w)
        self.tip.wm_overrideredirect(True)
        self.tip.wm_geometry(f""+{w.winfo_rootx()+20}+{w.winfo_rooty()+20}"")
        tk.Label(self.tip, text=t, background=""yellow"", relief=""solid"", borderwidth=1, font=(""Segoe UI"", 10)).pack()

    def hide_tip(self):
        if hasattr(self, 'tip'):
            self.tip.destroy()

    def setup_sum_tab(self):
        f = ttk.Frame(self.sum_f)
        f.pack(pady=10, fill=tk.BOTH, expand=True)
        c = tk.Canvas(f)
        sy = ttk.Scrollbar(f, orient=tk.VERTICAL, command=c.yview)
        sx = ttk.Scrollbar(f, orient=tk.HORIZONTAL, command=c.xview)
        sf = ttk.Frame(c)
        sf.bind(""<Configure>"", lambda e: c.configure(scrollregion=c.bbox(""all"")))
        c.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
        sy.pack(side=tk.RIGHT, fill=tk.Y)
        sx.pack(side=tk.BOTTOM, fill=tk.X)
        c.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        c.create_window((0, 0), window=sf, anchor=""nw"")
        self.sum_tree = ttk.Treeview(sf, show=""headings"")
        self.sum_tree.pack(fill=tk.BOTH, expand=True)

    def setup_lay_tab(self):
        f = ttk.Frame(self.lay_f)
        f.pack(pady=10, fill=tk.BOTH, expand=True)
        c = tk.Canvas(f)
        sy = ttk.Scrollbar(f, orient=tk.VERTICAL, command=c.yview)
        sx = ttk.Scrollbar(f, orient=tk.HORIZONTAL, command=c.xview)
        sf = ttk.Frame(c)
        sf.bind(""<Configure>"", lambda e: c.configure(scrollregion=c.bbox(""all"")))
        c.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
        sy.pack(side=tk.RIGHT, fill=tk.Y)
        sx.pack(side=tk.BOTTOM, fill=tk.X)
        c.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        c.create_window((0, 0), window=sf, anchor=""nw"")
        self.lay_tree = ttk.Treeview(sf, show=""headings"")
        self.lay_tree.pack(fill=tk.BOTH, expand=True)

    def setup_corr_tab(self):
        f = ttk.Frame(self.corr_f)
        f.pack(pady=10, fill=tk.BOTH, expand=True)
        cf = ttk.Frame(f)
        cf.pack(fill=tk.X, pady=5)
        ttk.Button(cf, text=""Upload SPT/Sonic"", command=self.upload_corr, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(cf, text=""Run Correlation"", command=self.run_corr, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        c = tk.Canvas(f)
        sy = ttk.Scrollbar(f, orient=tk.VERTICAL, command=c.yview)
        sx = ttk.Scrollbar(f, orient=tk.HORIZONTAL, command=c.xview)
        sf = ttk.Frame(c)
        sf.bind(""<Configure>"", lambda e: c.configure(scrollregion=c.bbox(""all"")))
        c.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
        sy.pack(side=tk.RIGHT, fill=tk.Y)
        sx.pack(side=tk.BOTTOM, fill=tk.X)
        c.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        c.create_window((0, 0), window=sf, anchor=""nw"")
        self.corr_tree = ttk.Treeview(sf, show=""headings"")
        self.corr_tree.pack(fill=tk.BOTH, expand=True)
        self.corr_plot_label = ttk.Label(sf, text=""Upload SPT/Sonic to view correlations."")
        self.corr_plot_label.pack(fill=tk.BOTH, expand=True)

    def setup_rt_tab(self):
        f = ttk.Frame(self.rt_f)
        f.pack(pady=10, fill=tk.BOTH, expand=True)
        cf = ttk.Frame(f)
        cf.pack(fill=tk.X, pady=5)
        ttk.Button(cf, text=""Start Real-Time"", command=self.start_rt, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(cf, text=""Stop Real-Time"", command=self.stop_rt, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        c = tk.Canvas(f)
        sy = ttk.Scrollbar(f, orient=tk.VERTICAL, command=c.yview)
        sx = ttk.Scrollbar(f, orient=tk.HORIZONTAL, command=c.xview)
        sf = ttk.Frame(c)
        sf.bind(""<Configure>"", lambda e: c.configure(scrollregion=c.bbox(""all"")))
        c.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
        sy.pack(side=tk.RIGHT, fill=tk.Y)
        sx.pack(side=tk.BOTTOM, fill=tk.X)
        c.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        c.create_window((0, 0), window=sf, anchor=""nw"")
        self.rt_tree = ttk.Treeview(sf, show=""headings"")
        self.rt_tree.pack(fill=tk.BOTH, expand=True)
        self.rt_plot_label = ttk.Label(sf, text=""Start real-time to view data."")
        self.rt_plot_label.pack(fill=tk.BOTH, expand=True)

    def setup_viz_tab(self):
        f = ttk.Frame(self.viz_f)
        f.pack(pady=10, fill=tk.BOTH, expand=True)
        of = ttk.Frame(f)
        of.pack(fill=tk.X, pady=5)
        ttk.Label(of, text=""Plot Params:"", font=(""Segoe UI"", 10)).pack(side=tk.LEFT, padx=5)
        for p, v in self.plot_opts.items():
            ttk.Checkbutton(of, text=p, variable=v, command=self.update_plots).pack(side=tk.LEFT, padx=5)
        df = ttk.Frame(of)
        df.pack(side=tk.LEFT, padx=10)
        ttk.Label(df, text=""Depth Range (m):"").pack(side=tk.LEFT)
        ttk.Entry(df, textvariable=self.min_d_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Label(df, text=""to"").pack(side=tk.LEFT)
        ttk.Entry(df, textvariable=self.max_d_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(df, text=""Update Plot"", command=self.update_plots, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(of, text=""Save Plots"", command=self.save_plots, style=""Custom.TButton"").pack(side=tk.RIGHT, padx=5)
        self.canvas = tk.Canvas(f)
        sy = ttk.Scrollbar(f, orient=tk.VERTICAL, command=self.canvas.yview)
        sx = ttk.Scrollbar(f, orient=tk.HORIZONTAL, command=self.canvas.xview)
        self.scroll_f = ttk.Frame(self.canvas)
        self.scroll_f.bind(""<Configure>"", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox(""all"")))
        self.canvas.configure(yscrollcommand=sy.set, xscrollcommand=sx.set)
        sy.pack(side=tk.RIGHT, fill=tk.Y)
        sx.pack(side=tk.BOTTOM, fill=tk.X)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.canvas.create_window((0, 0), window=self.scroll_f, anchor=""nw"")
        self.plot_label.pack(fill=tk.BOTH, expand=True)
       def export_report(self):
            if not shutil.which('latexmk'):
                messagebox.showerror(""Error"", ""LaTeX not installed."")
                return
    try:
                adf = self.analyze_data(self.cur_data)
                ts = datetime.now().strftime('%Y%m%d_%H%M')
                od = self.out_dir / ts
                od.mkdir(exist_ok=True)
                fn = Path(self.cur_file).stem
                tp = od / f""{fn}_detailed_report_{ts}.tex""
                lc = r""""""\documentclass[a4paper,12pt]{article}
\usepackage{booktabs,longtable,geometry,amsmath,amsfonts,noto}
\geometry{margin=1in}
\begin{document}
\section*{Detailed Seismic Analysis Report}
\subsection*{Analysis Data}
\begin{longtable}{@{}"""""" + ""c"" * len(adf.columns) + r""""""@{}}
\toprule """""" + r"" & "".join([f""\\textbf{{{c}}}"" for c in adf.columns]) + r""""""\\\midrule\endhead""""""
        for _, r in adf.iterrows():
            lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) if pd.notna(v) else """" for v in r]) + r""\\\midrule"" + ""\n""
        lc += r""\bottomrule\end{longtable}""
        if self.qual_issues is not None and not self.qual_issues.empty:
            lc += r""\section*{Quality Check Issues}\begin{longtable}{@{}"" + ""c"" * len(self.qual_issues.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in self.qual_issues.columns]) + r""\\\midrule\endhead""
            for _, r in self.qual_issues.iterrows():
                lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r]) + r""\\\midrule"" + ""\n""
            lc += r""\bottomrule\end{longtable}""
        p = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio', 'Poisson’s Ratio', 'Shear Modulus (MPa)', 'Bulk Modulus (MPa)', 'Young’s Modulus (MPa)']
        vd = adf[p].dropna()
        sd = {
            'Parameter': p,
            'Mean': [vd[c].mean() if not vd[c].empty else np.nan for c in p],
            'Median': [vd[c].median() if not vd[c].empty else np.nan for c in p],
            'Std Dev': [vd[c].std() if not vd[c].empty else np.nan for c in p],
            'Min': [vd[c].min() if not vd[c].empty else np.nan for c in p],
            'Max': [vd[c].max() if not vd[c].empty else np.nan for c in p]
        }
        sdf = pd.DataFrame(sd)
        lc += r""\section*{Summary Statistics}\begin{longtable}{@{}"" + ""c"" * len(sdf.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in sdf.columns]) + r""\\\midrule\endhead""
        for _, r in sdf.iterrows():
            lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r]) + r""\\\midrule"" + ""\n""
        lc += r""\bottomrule\end{longtable}""
        if self.layers is not None and not self.layers.empty:
            lc += r""\section*{Identified Layers}\begin{longtable}{@{}"" + ""c"" * len(self.layers.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in self.layers.columns]) + r""\\\midrule\endhead""
            for _, r in self.layers.iterrows():
                lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r]) + r""\\\midrule"" + ""\n""
            lc += r""\bottomrule\end{longtable}""
        if self.corr_res is not None and not self.corr_res.empty:
            lc += r""\section*{Correlation Results}\begin{longtable}{@{}"" + ""c"" * len(self.corr_res.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in self.corr_res.columns]) + r""\\\midrule\endhead""
            for _, r in self.corr_res.iterrows():
                lc += r"" & "".join([f""{v:.3f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r]) + r""\\\midrule"" + ""\n""
            lc += r""\bottomrule\end{longtable}""
        lc += r""\end{document}""
        with open(tp, 'w', encoding='utf-8') as f:
            f.write(lc)
        subprocess.run(['latexmk', '-pdf', f'-outdir={od}', str(tp)], capture_output=True, text=True, check=True)
        pp = od / f""{fn}_detailed_report_{ts}.pdf""
        if pp.exists():
            self.status_var.set(f""Exported report to {pp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            messagebox.showinfo(""Success"", f""Report to {pp}"")
        else:
            raise Exception(""PDF failed"")
    except Exception as e:
        messagebox.showerror(""Error"", f""Export failed: {str(e)}"")
        logging.error(f""Report export failed: {str(e)}"")

    def export_ana_pdf(self):
        if not shutil.which('latexmk'):
            messagebox.showerror(""Error"", ""LaTeX not installed."")
            return
        if self.cur_data is None:
            messagebox.showwarning(""No Data"", ""Load file."")
            return
        try:
            df = self.analyze_data(self.cur_data)
            ts = datetime.now().strftime('%Y%m%d_%H%M')
            od = self.out_dir / ts
            od.mkdir(exist_ok=True)
            fn = Path(self.cur_file).stem
            tp = od / f""{fn}_analysis_{ts}.tex""
            lc = r""\documentclass[a4paper,12pt]{article}\usepackage{booktabs,longtable,geometry,amsmath,amsfonts,noto}\geometry{margin=1in}\begin{document}\section*{Analysis Report}\begin{longtable}{@{}"" + ""c"" * len(df.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in df.columns]) + r""\\\midrule\endhead""
            for _, r in df.iterrows():
                lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) if pd.notna(v) else """" for v in r]) + r""\\\midrule"" + ""\n""
            lc += r""\bottomrule\end{longtable}\end{document}""
            with open(tp, 'w', encoding='utf-8') as f:
                f.write(lc)
            subprocess.run(['latexmk', '-pdf', f'-outdir={od}', str(tp)], capture_output=True, text=True, check=True)
            pp = od / f""{fn}_analysis_{ts}.pdf""
            if pp.exists():
                self.status_var.set(f""Exported analysis to PDF: {pp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
                messagebox.showinfo(""Success"", f""Exported to {pp}"")
            else:
                raise Exception(""PDF failed"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Export failed: {str(e)}"")
            logging.error(f""Analysis PDF failed: {str(e)}"")

    def refresh_files(self):
        files = [f for f in self.data_dir.glob(""*.[cx][sv][l]*"")]
        self.file_cb['values'] = [f.name for f in files]
        self.file_var.set("""")
        self.clear_tabs()
        self.status_var.set(""Select file."")

    def upload_file(self):
        fp = filedialog.askopenfilename(filetypes=[(""Excel/CSV"", ""*.xlsx *.csv""), (""Excel"", ""*.xlsx""), (""CSV"", ""*.csv""), (""All"", ""*.*"")])
        if fp:
            try:
                shutil.copy(fp, self.data_dir / Path(fp).name)
                self.refresh_files()
                self.status_var.set(f""Uploaded: {Path(fp).name} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            except Exception as e:
                messagebox.showerror(""Error"", f""Upload failed: {str(e)}"")
                logging.error(f""Upload failed: {str(e)}"")

    def create_template(self):
        try:
            df = pd.DataFrame([[3.0, 100.0, 7.91, 16.81], [4.5, 98.5, 8.0, 17.0], [6.0, 97.0, 8.5, 17.5]], 
                             columns=[""Depth (m)"", ""Elevation (m)"", ""P wave time (ms)"", ""S wave time (ms)""])
            p = self.data_dir / ""template_seismic_data.xlsx""
            df.to_excel(p, index=False)
            self.refresh_files()
            self.status_var.set(f""Created template: template_seismic_data.xlsx at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            messagebox.showinfo(""Success"", f""Template created: template_seismic_data.xlsx"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Template failed: {str(e)}"")
            logging.error(f""Template failed: {str(e)}"")

    def find_header_row(self, df):
        for i, r in df.iterrows():
            rv = [str(v).strip() if pd.notna(v) else """" for v in r.values]
            if ""Depth"" in rv:
                di = rv.index(""Depth"")
                if i + 1 < len(df) and str(df.iloc[i + 1, di]).strip() == ""(m)"":
                    return i
        return None

    def load_file(self, e=None):
        sf = self.file_var.get()
        if not sf:
            return
        self.clear_tabs()
        self.cur_file = sf
        fp = self.data_dir / sf
        try:
            if sf.endswith('.xlsx'):
                xl = pd.ExcelFile(fp)
                for sn in xl.sheet_names:
                    df = pd.read_excel(fp, sheet_name=sn, header=None)
                    hr = self.find_header_row(df)
                    if hr is not None:
                        df = pd.read_excel(fp, sheet_name=sn, header=[hr, hr + 1])
                        break
                else:
                    raise ValueError(""No 'Depth' followed by '(m)'"")
                cn = []
                cc = {}
                for c in df.columns:
                    cn1 = f""{c[0]} {c[1]}"".strip() if c[1] and pd.notna(c[1]) else c[0]
                    cc[cn1] = cc.get(cn1, 0) + 1
                    cn.append(f""{cn1} {cc[cn1]}"" if cc[cn1] > 1 else cn1)
                df.columns = cn
            elif sf.endswith('.csv'):
                dt = pd.read_csv(fp, header=None)
                hr = self.find_header_row(dt)
                if hr is None:
                    raise ValueError(""No 'Depth' followed by '(m)'"")
                df = pd.read_csv(fp, header=[hr, hr + 1])
                cn = []
                cc = {}
                for c in df.columns:
                    cn1 = f""{c[0]} {c[1]}"".strip() if c[1] and pd.notna(c[1]) else c[0]
                    cc[cn1] = cc.get(cn1, 0) + 1
                    cn.append(f""{cn1} {cc[cn1]}"" if cc[cn1] > 1 else cn1)
                df.columns = cn
            else:
                raise ValueError(""Unsupported format"")
            df.columns = [c.replace('\n', ' ') for c in df.columns]
            df.columns = ['Depth (m)' if c.startswith('Depth') else c for c in df.columns]
            ec = [c for c in df.columns if c.startswith('Elevation')]
            if ec:
                ve = next((c for c in ec if df[c].notna().any()), None)
                if ve:
                    df.rename(columns={ve: 'Elevation (m)'}, inplace=True)
                    df.drop(columns=[c for c in ec if c != ve], inplace=True)
            df = df.dropna(axis=1, how='all')
            df = df.loc[:, (df.notna().any()) | (df.columns == 'Depth (m)')].dropna(subset=df.columns.difference(['Depth (m)']), how='all')
            self.raw_data = df[df['Depth (m)'].notna()].copy()
            self.cur_data = self.raw_data.copy()
            if not all(c in df.columns for c in ['Depth (m)', 'Elevation (m)']):
                raise ValueError(""Missing Depth/Elevation"")
            self.display_raw(self.raw_data)
            adf = self.analyze_data(self.cur_data)
            self.display_ana(adf)
            self.check_qual(self.cur_data)
            self.display_qual()
            self.display_sum(adf)
            self.identify_layers(adf)
            self.display_lay()
            self.plot_viz(self.cur_data, adf)
            self.status_var.set(f""Loaded: {sf} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            logging.info(f""Loaded file {sf} with {len(self.cur_data)} rows"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Load failed: {str(e)}"")
            logging.error(f""Load failed: {str(e)}"")
            self.clear_tabs()

    def clear_tabs(self):
        for t in [self.raw_tree, self.qual_tree, self.ana_tree, self.sum_tree, self.lay_tree, self.corr_tree, self.rt_tree]:
            if t:
                for i in t.get_children():
                    t.delete(i)
        if hasattr(self, 'plot_canvas') and self.plot_canvas:
            self.plot_canvas.get_tk_widget().destroy()
        if hasattr(self, 'cur_fig') and self.cur_fig:
            plt.close(self.cur_fig)
        self.plot_label.pack(fill=tk.BOTH, expand=True)
        self.cur_data = self.raw_data = self.cur_file = self.deviations = self.qual_issues = self.layers = self.corr_data = self.rt_data = self.cur_fig = None
        self.sel_rows = {}

    def on_select_row(self, e):
        i = self.raw_tree.identify_row(e.y)
        if not i:
            return
        idx = int(self.raw_tree.index(i))
        self.sel_rows[idx] = not self.sel_rows.get(idx, False)
        self.raw_tree.set(i, ""Select"", ""✔"" if self.sel_rows[idx] else """")

    def display_raw(self, df):
        for i in self.raw_tree.get_children():
            self.raw_tree.delete(i)
        c = [""Select""] + list(df.columns)
        self.raw_tree[""columns""] = c
        for col in c:
            self.raw_tree.heading(col, text=col)
            self.raw_tree.column(col, anchor=tk.CENTER, stretch=True)
        self.sel_rows = {}
        for idx, r in df.iterrows():
            self.raw_tree.insert("""", tk.END, values=[""""] + [str(v) if pd.notna(v) else """" for v in r])
            self.sel_rows[idx] = False
        self.raw_tree.column(""Select"", width=50, minwidth=50)
        self.raw_tree.bind(""<Button-1>"", self.on_select_row)
        for col in c[1:]:
            dl = [len(str(r.get(col, """"))) for _, r in df.iterrows()][:100]
            self.raw_tree.column(col, width=max(dl, default=0) * 10, minwidth=150)

    def apply_sel(self):
        if self.raw_data is None:
            return
        df = self.raw_data.copy()
        try:
            md = float(self.min_d_var.get()) if self.min_d_var.get().strip() else df['Depth (m)'].min()
            xd = float(self.max_d_var.get()) if self.max_d_var.get().strip() else df['Depth (m)'].max()
            if md > xd:
                md, xd = xd, md
            df = df[(df['Depth (m)'] >= md) & (df['Depth (m)'] <= xd)]
        except ValueError:
            messagebox.showwarning(""Invalid"", ""Enter valid depth."")
            return
        si = [i for i, s in self.sel_rows.items() if s]
        if si:
            df = df.iloc[si]
        self.cur_data = df
        adf = self.analyze_data(df)
        self.display_ana(adf)
        self.check_qual(df)
        self.display_qual()
        self.display_sum(adf)
        self.identify_layers(adf)
        self.display_lay()
        self.plot_viz(df, adf)
        self.status_var.set(f""Selected: {len(df)} rows at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")

    def reset_sel(self):
        if self.raw_data is None:
            return
        self.cur_data = self.raw_data.copy()
        self.min_d_var.set("""")
        self.max_d_var.set("""")
        self.sel_rows = {i: False for i in range(len(self.raw_data))}
        for i in self.raw_tree.get_children():
            self.raw_tree.set(i, ""Select"", """")
        adf = self.analyze_data(self.cur_data)
        self.display_ana(adf)
        self.check_qual(self.cur_data)
        self.display_qual()
        self.display_sum(adf)
        self.identify_layers(adf)
        self.display_lay()
        self.plot_viz(self.cur_data, adf)
        self.status_var.set(f""Reset: {len(self.cur_data)} rows at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")

    def check_qual(self, df):
        pc = [c for c in df.columns if ""P wave time"" in c]
        sc = [c for c in df.columns if ""S wave time"" in c]
        if not pc or not sc:
            self.qual_issues = pd.DataFrame(columns=['Depth (m)', 'First P-wave Time (µs)', 'First S-wave Time (µs)', 'Flag Reason'])
            logging.warning(""No P/S wave columns found."")
            return
        df['First P-wave Time (µs)'] = df[pc].min(axis=1) * 1000
        df['First S-wave Time (µs)'] = df[sc].min(axis=1) * 1000
        pm = df['First P-wave Time (µs)'].median()
        ps = df['First P-wave Time (µs)'].std()
        sm = df['First S-wave Time (µs)'].median()
        ss = df['First S-wave Time (µs)'].std()
        dd = df['Depth (m)'].diff()
        nmi = dd[dd <= 0].index
        qi = []
        for i, r in df.iterrows():
            f = []
            if pd.notna(r['First P-wave Time (µs)']):
                if r['First P-wave Time (µs)'] < 0.5:
                    f.append(""P-wave time too small"")
                if abs(r['First P-wave Time (µs)'] - pm) > 2 * ps:
                    f.append(f""P-wave outlier (value={r['First P-wave Time (µs)']:.2f}, median={pm:.2f})"")
            if pd.notna(r['First S-wave Time (µs)']):
                if r['First S-wave Time (µs)'] < 0.5:
                    f.append(""S-wave time too small"")
                if abs(r['First S-wave Time (µs)'] - sm) > 2 * ss:
                    f.append(f""S-wave outlier (value={r['First S-wave Time (µs)']:.2f}, median={sm:.2f})"")
            if i in nmi and i > 0:
                f.append(""Depth not monotonic"")
            if f:
                qi.append([r['Depth (m)'], r['First P-wave Time (µs)'], r['First S-wave Time (µs)'], ""; "".join(f)])
                logging.info(f""Flagged depth {r['Depth (m)']}: {'; '.join(f)}"")
        self.qual_issues = pd.DataFrame(qi, columns=['Depth (m)', 'First P-wave Time (µs)', 'First S-wave Time (µs)', 'Flag Reason']) if qi else pd.DataFrame(columns=['Depth (m)', 'First P-wave Time (µs)', 'First S-wave Time (µs)', 'Flag Reason'])
        logging.info(f""Quality check processed {len(df)} depths, found {len(qi)} issues."")

    def display_qual(self):
        for i in self.qual_tree.get_children():
            self.qual_tree.delete(i)
        c = list(self.qual_issues.columns)
        self.qual_tree[""columns""] = c
        for col in c:
            self.qual_tree.heading(col, text=col)
            self.qual_tree.column(col, anchor=tk.CENTER)
        for _, r in self.qual_issues.iterrows():
            self.qual_tree.insert("""", tk.END, values=[f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r])
        for col in c:
            dl = [len(str(r.get(col, """"))) for _, r in self.qual_issues.iterrows()][:100]
            self.qual_tree.column(col, width=max(dl, default=0) * 10, minwidth=300 if col == ""Flag Reason"" else 150)

    def run_mc(self):
        if self.cur_data is None:
            messagebox.showwarning(""No Data"", ""Load file."")
            return
        try:
            df = self.cur_data.copy()
            ni = 1000
            tns = 0.01
            pc = [c for c in df.columns if ""P wave time"" in c]
            sc = [c for c in df.columns if ""S wave time"" in c]
            if not pc or not sc:
                raise ValueError(""No P/S wave columns"")
            if df[pc + sc].isna().all().all():
                raise ValueError(""All P/S wave times are missing"")
            res = {'P-wave Velocity (m/s)': [], 'S-wave Velocity (m/s)': [], 'Vp/Vs Ratio': []}
            for _ in range(ni):
                ds = df.copy()
                for c in pc + sc:
                    ds[c] = ds[c] * (1 + np.random.normal(0, tns, len(ds)))
                as_ = self.analyze_data(ds)
                for p in res:
                    res[p].append(as_[p].values)
            for p in res:
                res[p] = np.array(res[p])
                df[f'{p} Mean'] = np.nanmean(res[p], axis=0)
                df[f'{p} CI Lower'] = np.nanpercentile(res[p], 2.5, axis=0)
                df[f'{p} CI Upper'] = np.nanpercentile(res[p], 97.5, axis=0)
            self.cur_data = df
            self.display_ana(df)
            self.status_var.set(f""Monte Carlo done at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            logging.info(f""Monte Carlo processed {len(df)} depths with {ni} iterations."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Monte Carlo failed: {str(e)}"")
            logging.error(f""Monte Carlo failed: {str(e)}"")
            def upload_corr(self):
        fp = filedialog.askopenfilename(filetypes=[(""Excel/CSV"", ""*.xlsx *.csv""), (""Excel"", ""*.xlsx""), (""CSV"", ""*.csv""), (""All"", ""*.*"")])
        if fp:
            try:
                self.corr_data = pd.read_excel(fp) if fp.endswith('.xlsx') else pd.read_csv(fp)
                if 'Depth (m)' not in self.corr_data.columns:
                    raise ValueError(""SPT/Sonic needs Depth (m)"")
                self.status_var.set(f""Uploaded SPT/Sonic: {Path(fp).name} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            except Exception as e:
                messagebox.showerror(""Error"", f""Upload failed: {str(e)}"")
                logging.error(f""Corr upload failed: {str(e)}"")

    def run_corr(self):
        if self.cur_data is None or self.corr_data is None:
            messagebox.showwarning(""No Data"", ""Load CHST and SPT/Sonic."")
            return
        try:
            sdf = self.analyze_data(self.cur_data)
            mdf = pd.merge(sdf, self.corr_data, on='Depth (m)', how='inner')
            if mdf.empty:
                raise ValueError(""No matching depths"")
            cr = []
            sp = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio']
            cp = [c for c in self.corr_data.columns if c != 'Depth (m)']
            for s in sp:
                for c in cp:
                    vd = mdf[[s, c]].dropna()
                    if len(vd) > 1:
                        cr.append([s, c, *scipy.stats.pearsonr(vd[s], vd[c])])
            self.corr_res = pd.DataFrame(cr, columns=['Seismic Param', 'Corr Param', 'Pearson Corr', 'P-Value'])
            self.display_corr()
            self.plot_corr(mdf)
            self.status_var.set(f""Correlation done at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Correlation failed: {str(e)}"")
            logging.error(f""Correlation failed: {str(e)}"")

    def display_corr(self):
        for i in self.corr_tree.get_children():
            self.corr_tree.delete(i)
        c = list(self.corr_res.columns)
        self.corr_tree[""columns""] = c
        for col in c:
            self.corr_tree.heading(col, text=col)
            self.corr_tree.column(col, anchor=tk.CENTER)
        for _, r in self.corr_res.iterrows():
            self.corr_tree.insert("""", tk.END, values=[f""{v:.3f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r])
        for col in c:
            dl = [len(str(r.get(col, """"))) for _, r in self.corr_res.iterrows()][:100]
            self.corr_tree.column(col, width=max(dl, default=0) * 10, minwidth=150)

    def plot_corr(self, mdf):
        if hasattr(self, 'corr_canvas') and self.corr_canvas:
            self.corr_canvas.get_tk_widget().destroy()
        if hasattr(self, 'corr_fig') and self.corr_fig:
            plt.close(self.corr_fig)
        self.corr_plot_label.pack_forget()
        sp = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)']
        cp = [c for c in mdf.columns if c not in sp + ['Depth (m)']]
        if not cp:
            self.corr_plot_label = ttk.Label(self.corr_tree.master, text=""No corr params."")
            self.corr_plot_label.pack(fill=tk.BOTH, expand=True)
            return
        np = len(sp) * len(cp)
        r = (np + 2) // 3
        self.corr_fig, ax = plt.subplots(r, 3, figsize=(15, 4 * r))
        ax = ax.flatten()
        pi = 0
        for s in sp:
            for c in cp:
                vd = mdf[[s, c]].dropna()
                if len(vd) > 1:
                    ax[pi].scatter(vd[s], vd[c], c='b', alpha=0.5)
                    ax[pi].set_xlabel(s)
                    ax[pi].set_ylabel(c)
                    ax[pi].set_title(f'{s} vs {c}')
                    ax[pi].grid(True)
                    pi += 1
        for i in range(pi, len(ax)):
            ax[i].axis('off')
        plt.tight_layout()
        self.corr_canvas = FigureCanvasTkAgg(self.corr_fig, master=self.corr_tree.master)
        self.corr_canvas.draw()
        self.corr_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def start_rt(self):
        if self.rt_running:
            return
        self.rt_running = True
        self.rt_data = pd.DataFrame(columns=['Depth (m)', 'Elevation (m)', 'P wave time (ms)', 'S wave time (ms)'])
        self.display_rt()
        self.rt_thread = threading.Thread(target=self.rt_acq, daemon=True)
        self.rt_thread.start()
        self.status_var.set(""Started real-time."")

    def stop_rt(self):
        self.rt_running = False
        self.status_var.set(""Stopped real-time."")

    def rt_acq(self):
        rf = self.data_dir / ""realtime_chst_data.csv""
        while self.rt_running:
            try:
                if rf.exists():
                    dn = pd.read_csv(rf)
                    if not dn.empty:
                        self.rt_data = pd.concat([self.rt_data, dn]).drop_duplicates(subset=['Depth (m)']).reset_index(drop=True)
                        self.root.after(0, self.update_rt_display)
                time.sleep(1)
            except Exception as e:
                logging.error(f""Real-time error: {str(e)}"")

    def update_rt_display(self):
        self.display_rt()
        self.plot_rt()

    def display_rt(self):
        for i in self.rt_tree.get_children():
            self.rt_tree.delete(i)
        c = list(self.rt_data.columns)
        self.rt_tree[""columns""] = c
        for col in c:
            self.rt_tree.heading(col, text=col)
            self.rt_tree.column(col, anchor=tk.CENTER)
        for _, r in self.rt_data.iterrows():
            self.rt_tree.insert("""", tk.END, values=[f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r])
        for col in c:
            dl = [len(str(r.get(col, """"))) for _, r in self.rt_data.iterrows()][:100]
            self.corr_tree.column(col, width=max(dl, default=0) * 10, minwidth=150)

    def plot_rt(self):
        if hasattr(self, 'rt_canvas') and self.rt_canvas:
            self.rt_canvas.get_tk_widget().destroy()
        if hasattr(self, 'rt_fig') and self.rt_fig:
            plt.close(self.rt_fig)
        self.rt_plot_label.pack_forget()
        if self.rt_data.empty:
            self.rt_plot_label = ttk.Label(self.rt_tree.master, text=""No real-time data."")
            self.rt_plot_label.pack(fill=tk.BOTH, expand=True)
            return
        adf = self.analyze_data(self.rt_data)
        self.rt_fig, ax = plt.subplots(figsize=(10, 5))
        ax.plot(adf['P-wave Velocity (m/s)'], adf['Depth (m)'], 'b-', label='P-wave')
        ax.plot(adf['S-wave Velocity (m/s)'], adf['Depth (m)'], 'r-', label='S-wave')
        ax.set_xlabel('Velocity (m/s)')
        ax.set_ylabel('Depth (m)')
        ax.set_title('Real-Time Velocities')
        ax.invert_yaxis()
        ax.legend()
        ax.grid(True)
        self.rt_canvas = FigureCanvasTkAgg(self.rt_fig, master=self.rt_tree.master)
        self.rt_canvas.draw()
        self.rt_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def analyze_data(self, df):
        df = df.copy()
        df['Depth (m)'] = pd.to_numeric(df['Depth (m)'], errors='coerce')
        pc = [c for c in df.columns if ""P wave time"" in c]
        sc = [c for c in df.columns if ""S wave time"" in c]
        if not pc or not sc:
            raise ValueError(""No P/S wave columns"")
        for c in pc + sc:
            df[c] = pd.to_numeric(df[c], errors='coerce')
        df['First P-wave Time (µs)'] = df[pc].min(axis=1) * 1000
        df['First S-wave Time (µs)'] = df[sc].min(axis=1) * 1000
        df['P-wave Time Diff'] = df['First P-wave Time (µs)'].diff()
        df['S-wave Time Diff'] = df['First S-wave Time (µs)'].diff()
        df['P-wave Velocity (m/s)'] = np.nan
        df['S-wave Velocity (m/s)'] = np.nan
        mt = 0.001
        for i in range(1, len(df)):
            dd = df['Depth (m)'].iloc[i] - df['Depth (m)'].iloc[i-1]
            dpt = df['P-wave Time Diff'].iloc[i] / 10**6 if pd.notna(df['P-wave Time Diff'].iloc[i]) else np.nan
            dst = df['S-wave Time Diff'].iloc[i] / 10**6 if pd.notna(df['S-wave Time Diff'].iloc[i]) else np.nan
            if pd.notna(dpt) and abs(dpt) > mt and dd > 0:
                pv = abs(dd / dpt)
                if 10 <= pv <= 10000:
                    df['P-wave Velocity (m/s)'].iloc[i] = pv
                else:
                    logging.warning(f""Invalid P-wave velocity {pv:.2f} at depth {df['Depth (m)'].iloc[i]}"")
            if pd.notna(dst) and abs(dst) > mt and dd > 0:
                sv = abs(dd / dst)
                if 10 <= sv <= 10000:
                    df['S-wave Velocity (m/s)'].iloc[i] = sv
                else:
                    logging.warning(f""Invalid S-wave velocity {sv:.2f} at depth {df['Depth (m)'].iloc[i]}"")
        df['Vp/Vs Ratio'] = df['P-wave Velocity (m/s)'] / df['S-wave Velocity (m/s)']
        df['Poisson’s Ratio'] = (df['Vp/Vs Ratio']**2 - 2) / (2 * (df['Vp/Vs Ratio']**2 - 1))
        d = 2000
        df['Shear Modulus (MPa)'] = d * df['S-wave Velocity (m/s)']**2 / 10**6
        df['Bulk Modulus (MPa)'] = d * (df['P-wave Velocity (m/s)']**2 - (4/3) * df['S-wave Velocity (m/s)']**2) / 10**6
        df['Young’s Modulus (MPa)'] = df['Shear Modulus (MPa)'] * (3 * df['Bulk Modulus (MPa)'] + df['Shear Modulus (MPa)']) / (df['Bulk Modulus (MPa)'] + df['Shear Modulus (MPa)'])
        logging.info(f""Analyzed {len(df)} depths, P-wave NaNs: {df['P-wave Velocity (m/s)'].isna().sum()}, S-wave NaNs: {df['S-wave Velocity (m/s)'].isna().sum()}"")
        return df

    def display_ana(self, df):
        for i in self.ana_tree.get_children():
            self.ana_tree.delete(i)
        c = ['Depth (m)', 'P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio', 'Poisson’s Ratio', 'Shear Modulus (MPa)', 'Bulk Modulus (MPa)', 'Young’s Modulus (MPa)'] + \
            [c for c in df.columns if c.endswith('Mean') or c.endswith('CI Lower') or c.endswith('CI Upper')]
        self.ana_tree[""columns""] = c
        for col in c:
            self.ana_tree.heading(col, text=col)
            self.ana_tree.column(col, anchor=tk.CENTER)
        for _, r in df.iterrows():
            self.ana_tree.insert("""", tk.END, values=[f""{r.get(col, np.nan):.2f}"" if isinstance(r.get(col), (int, float)) and pd.notna(r.get(col)) else """" for col in c])
        for col in c:
            dl = [len(str(r.get(col, """"))) for _, r in df.iterrows()][:100]
            self.ana_tree.column(col, width=max(dl, default=0) * 10, minwidth=150)

    def identify_layers(self, df):
        vt = 0.2
        l = []
        cl = {'Start Depth': df['Depth (m)'].iloc[0], 'End Depth': df['Depth (m)'].iloc[0], 'P-wave Velocity': [], 'S-wave Velocity': []}
        for i in range(1, len(df)):
            pv = df['P-wave Velocity (m/s)'].iloc[i]
            sv = df['S-wave Velocity (m/s)'].iloc[i]
            if pd.notna(pv) and pd.notna(sv) and 10 <= pv <= 10000 and 10 <= sv <= 10000:
                cl['P-wave Velocity'].append(pv)
                cl['S-wave Velocity'].append(sv)
                cl['End Depth'] = df['Depth (m)'].iloc[i]
                if i < len(df) - 1:
                    npv = df['P-wave Velocity (m/s)'].iloc[i + 1]
                    if pd.notna(npv) and abs(pv - npv) / pv > vt:
                        ld = {
                            'Start Depth (m)': cl['Start Depth'],
                            'End Depth (m)': cl['End Depth'],
                            'Avg P-wave Velocity (m/s)': np.mean(cl['P-wave Velocity']) if cl['P-wave Velocity'] else np.nan,
                            'Avg S-wave Velocity (m/s)': np.mean(cl['S-wave Velocity']) if cl['S-wave Velocity'] else np.nan
                        }
                        l.append(ld)
                        cl = {'Start Depth': df['Depth (m)'].iloc[i + 1], 'End Depth': df['Depth (m)'].iloc[i + 1], 'P-wave Velocity': [], 'S-wave Velocity': []}
            else:
                logging.warning(f""Skipped layer at depth {df['Depth (m)'].iloc[i]}: P-wave={pv}, S-wave={sv}"")
        if cl['P-wave Velocity']:
            ld = {
                'Start Depth (m)': cl['Start Depth'],
                'End Depth (m)': cl['End Depth'],
                'Avg P-wave Velocity (m/s)': np.mean(cl['P-wave Velocity']) if cl['P-wave Velocity'] else np.nan,
                'Avg S-wave Velocity (m/s)': np.mean(cl['S-wave Velocity']) if cl['S-wave Velocity'] else np.nan
            }
            l.append(ld)
        self.layers = pd.DataFrame(l) if l else pd.DataFrame(columns=['Start Depth (m)', 'End Depth (m)', 'Avg P-wave Velocity (m/s)', 'Avg S-wave Velocity (m/s)'])
        logging.info(f""Identified {len(l)} layers, checked depths {df['Depth (m)'].min()} to {df['Depth (m)'].max()}"")

    def display_lay(self):
        for i in self.lay_tree.get_children():
            self.lay_tree.delete(i)
        c = list(self.layers.columns)
        self.lay_tree[""columns""] = c
        for col in c:
            self.lay_tree.heading(col, text=col)
            self.lay_tree.column(col, anchor=tk.CENTER)
        for _, r in self.layers.iterrows():
            self.lay_tree.insert("""", tk.END, values=[f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r])
        for col in c:
            dl = [len(str(r.get(col, """"))) for _, r in self.layers.iterrows()][:100]
            self.lay_tree.column(col, width=max(dl, default=0) * 10, minwidth=200)

    def display_sum(self, df):
        for i in self.sum_tree.get_children():
            self.sum_tree.delete(i)
        p = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio', 'Poisson’s Ratio', 'Shear Modulus (MPa)', 'Bulk Modulus (MPa)', 'Young’s Modulus (MPa)']
        vd = df[p].dropna()
        sd = {
            'Parameter': p,
            'Mean': [vd[c].mean() if not vd[c].empty else np.nan for c in p],
            'Median': [vd[c].median() if not vd[c].empty else np.nan for c in p],
            'Std Dev': [vd[c].std() if not vd[c].empty else np.nan for c in p],
            'Min': [vd[c].min() if not vd[c].empty else np.nan for c in p],
            'Max': [vd[c].max() if not vd[c].empty else np.nan for c in p]
        }
        sdf = pd.DataFrame(sd)
        self.sum_tree[""columns""] = list(sdf.columns)
        for col in sdf.columns:
            self.sum_tree.heading(col, text=col)
            self.sum_tree.column(col, anchor=tk.CENTER)
        for _, r in sdf.iterrows():
            self.sum_tree.insert("""", tk.END, values=[f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r])
        for col in sdf.columns:
            dl = [len(str(r.get(col, """"))) for _, r in sdf.iterrows()][:100]
            self.sum_tree.column(col, width=max(dl, default=0) * 10, minwidth=150)
        logging.info(f""Summary stats for P-wave Velocity: Mean={sd['Mean'][0]:.2f}, Median={sd['Median'][0]:.2f}, Min={sd['Min'][0]:.2f}, Max={sd['Max'][0]:.2f}"")

    def plot_viz(self, rdf, adf):
        if hasattr(self, 'plot_canvas') and self.plot_canvas:
            self.plot_canvas.get_tk_widget().destroy()
        if hasattr(self, 'cur_fig') and self.cur_fig:
            plt.close(self.cur_fig)
        self.plot_label.pack_forget()
        if adf.empty:
            self.plot_label = ttk.Label(self.scroll_f, text=""No data for viz."")
            self.plot_label.pack(fill=tk.BOTH, expand=True)
            return
        try:
            md = float(self.min_d_var.get()) if self.min_d_var.get().strip() else adf['Depth (m)'].min()
            xd = float(self.max_d_var.get()) if self.max_d_var.get().strip() else adf['Depth (m)'].max()
            if md > xd:
                md, xd = xd, md
            pdf = adf[(adf['Depth (m)'] >= md) & (adf['Depth (m)'] <= xd)]
        except ValueError:
            pdf = adf
        ap = [p for p, v in self.plot_opts.items() if v.get()]
        if not ap:
            self.plot_label = ttk.Label(self.scroll_f, text=""No params selected."")
            self.plot_label.pack(fill=tk.BOTH, expand=True)
            return
        np = len(ap)
        r = (np + 2) // 3
        self.cur_fig, ax = plt.subplots(r, min(np, 3), figsize=(15, 4 * r))
        ax = [ax] if np == 1 else ax.flatten()
        pi = 0
        for p in ap:
            if p == ""Travel Time Deviations"":
                if self.qual_issues is not None and not self.qual_issues.empty:
                    ax[pi].scatter(self.qual_issues['First P-wave Time (µs)'], self.qual_issues['Depth (m)'], c='r', label='P-wave Dev', alpha=0.5)
                    ax[pi].scatter(self.qual_issues['First S-wave Time (µs)'], self.qual_issues['Depth (m)'], c='b', label='S-wave Dev', alpha=0.5)
                    ax[pi].set_xlabel('Time (µs)')
                    ax[pi].set_ylabel('Depth (m)')
                    ax[pi].set_title('Travel Time Deviations')
                    ax[pi].invert_yaxis()
                    ax[pi].legend()
                    ax[pi].grid(True)
                    pi += 1
            else:
                if p in pdf.columns:
                    ax[pi].plot(pdf[p], pdf['Depth (m)'], 'b-')
                    ax[pi].set_xlabel(p)
                    ax[pi].set_ylabel('Depth (m)')
                    ax[pi].set_title(p)
                    ax[pi].invert_yaxis()
                    ax[pi].grid(True)
                    pi += 1
        for i in range(pi, len(ax)):
            ax[i].axis('off')
        plt.tight_layout()
        self.plot_canvas = FigureCanvasTkAgg(self.cur_fig, master=self.scroll_f)
        self.plot_canvas.draw()
        self.plot_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def update_plots(self):
        if self.cur_data is not None:
            adf = self.analyze_data(self.cur_data)
            self.plot_viz(self.cur_data, adf)

    def save_plots(self):
        if self.cur_fig is None:
            messagebox.showwarning(""No Plot"", ""No plot to save."")
            return
        fp = filedialog.asksaveasfilename(defaultextension="".png"", filetypes=[(""PNG"", ""*.png""), (""All"", ""*.*"")])
        if fp:
            try:
                self.cur_fig.savefig(fp, dpi=300)
                self.status_var.set(f""Saved plot to {fp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            except Exception as e:
                messagebox.showerror(""Error"", f""Save failed: {str(e)}"")
                logging.error(f""Plot save failed: {str(e)}"")

    def export_raw(self):
        if self.raw_data is None:
            messagebox.showwarning(""No Data"", ""Load file."")
            return
        try:
            ts = datetime.now().strftime('%Y%m%d_%H%M')
            od = self.out_dir / ts
            od.mkdir(exist_ok=True)
            fn = Path(self.cur_file).stem
            cp = od / f""{fn}_raw_data_{ts}.csv""
            self.raw_data.to_csv(cp, index=False)
            self.status_var.set(f""Exported raw to {cp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            messagebox.showinfo(""Success"", f""Raw data to {cp}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Export failed: {str(e)}"")
            logging.error(f""Raw export failed: {str(e)}"")

    def export_qual(self):
        if self.qual_issues is None:
            messagebox.showwarning(""No Data"", ""Load file and check quality."")
            return
        try:
            ts = datetime.now().strftime('%Y%m%d_%H%M')
            od = self.out_dir / ts
            od.mkdir(exist_ok=True)
            fn = Path(self.cur_file).stem
            cp = od / f""{fn}_quality_check_{ts}.csv""
            self.qual_issues.to_csv(cp, index=False)
            self.status_var.set(f""Exported quality to {cp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            messagebox.showinfo(""Success"", f""Quality to {cp}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Export failed: {str(e)}"")
            logging.error(f""Quality export failed: {str(e)}"")

    def export_sum(self):
        if self.cur_data is None:
            messagebox.showwarning(""No Data"", ""Load file."")
            return
        try:
            adf = self.analyze_data(self.cur_data)
            p = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio', 'Poisson’s Ratio', 'Shear Modulus (MPa)', 'Bulk Modulus (MPa)', 'Young’s Modulus (MPa)']
            vd = adf[p].dropna()
            sd = {
                'Parameter': p,
                'Mean': [vd[c].mean() if not vd[c].empty else np.nan for c in p],
                'Median': [vd[c].median() if not vd[c].empty else np.nan for c in p],
                'Std Dev': [vd[c].std() if not vd[c].empty else np.nan for c in p],
                'Min': [vd[c].min() if not vd[c].empty else np.nan for c in p],
                'Max': [vd[c].max() if not vd[c].empty else np.nan for c in p]
            }
            sdf = pd.DataFrame(sd)
            ts = datetime.now().strftime('%Y%m%d_%H%M')
            od = self.out_dir / ts
            od.mkdir(exist_ok=True)
            fn = Path(self.cur_file).stem
            cp = od / f""{fn}_summary_{ts}.csv""
            sdf.to_csv(cp, index=False)
            self.status_var.set(f""Exported summary to {cp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            messagebox.showinfo(""Success"", f""Summary to {cp}"")
            logging.info(f""Exported summary: Mean P-wave={sd['Mean'][0]:.2f}, Median P-wave={sd['Median'][0]:.2f}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Export failed: {str(e)}"")
            logging.error(f""Summary export failed: {str(e)}"")

    def export_lay(self):
        if self.layers is None:
            messagebox.showwarning(""No Data"", ""Load file and identify layers."")
            return
        try:
            ts = datetime.now().strftime('%Y%m%d_%H%M')
            od = self.out_dir / ts
            od.mkdir(exist_ok=True)
            fn = Path(self.cur_file).stem
            cp = od / f""{fn}_layers_{ts}.csv""
            self.layers.to_csv(cp, index=False)
            self.status_var.set(f""Exported layers to {cp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            messagebox.showinfo(""Success"", f""Layers to {cp}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Export failed: {str(e)}"")
            logging.error(f""Layers export failed: {str(e)}"")

    def export_corr(self):
        if self.corr_res is None:
            messagebox.showwarning(""No Data"", ""Run correlation."")
            return
        try:
            ts = datetime.now().strftime('%Y%m%d_%H%M')
            od = self.out_dir / ts
            od.mkdir(exist_ok=True)
            fn = Path(self.cur_file).stem
            cp = od / f""{fn}_correlation_{ts}.csv""
            self.corr_res.to_csv(cp, index=False)
            self.status_var.set(f""Exported correlation to {cp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
            messagebox.showinfo(""Success"", f""Correlation to {cp}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Export failed: {str(e)}"")
            logging.error(f""Correlation export failed: {str(e)}"")

    def export_report(self):
        if self.cur_data is None:
            messagebox.showwarning(""No Data"", ""Load file."")
            return
        if not shutil.which('latexmk'):
            messagebox.showerror(""Error"", ""LaTeX not installed."")
            return
        try:
            adf = self.analyze_data(self.cur_data)
            ts = datetime.now().strftime('%Y%m%d_%H%M')
            od = self.out_dir / ts
            od.mkdir(exist_ok=True)
            fn = Path(self.cur_file).stem
            tp = od / f""{fn}_detailed_report_{ts}.tex""
            lc = r""""""\documentclass[a4paper,12pt]{article}
\usepackage{booktabs,longtable,geometry,amsmath,amsfonts,noto}
\geometry{margin=1in}
\begin{document}
\section*{Detailed Seismic Analysis Report}
\subsection*{Analysis Data}
\begin{longtable}{@{}"""""" + ""c"" * len(adf.columns) + r""""""@{}}
""""""
\toprule "" + r"" & "".join([f""\\textbf{{{c}}}"" for c in adf.columns]) + r""\\\midrule\endhead""
            for _, r in adf.iterrows():
                lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) if pd.notna(v) else """" for v in r]) + r""\\\midrule"" + ""\n""
            lc += r""\bottomrule\end{longtable}""
            if self.qual_issues is not None and not self.qual_issues.empty:
                lc += r""\section*{Quality Check Issues}\begin{longtable}{@{}"" + ""c"" * len(self.qual_issues.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in self.qual_issues.columns]) + r""\\\midrule\endhead""
                for _, r in self.qual_issues.iterrows():
                    lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r]) + r""\\\midrule"" + ""\n""
                lc += r""\bottomrule\end{longtable}""
            p = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio', 'Poisson’s Ratio', 'Shear Modulus (MPa)', 'Bulk Modulus (MPa)', 'Young’s Modulus (MPa)']
            vd = adf[p].dropna()
            sd = {
                'Parameter': p,
                'Mean': [vd[c].mean() if not vd[c].empty else np.nan for c in p],
                'Median': [vd[c].median() if not vd[c].empty else np.nan for c in p],
                'Std Dev': [vd[c].std() if not vd[c].empty else np.nan for c in p],
                'Min': [vd[c].min() if not vd[c].empty else np.nan for c in p],
                'Max': [vd[c].max() if not vd[c].empty else np.nan for c in p]
            }
            sdf = pd.DataFrame(sd)
            lc += r""\section*{Summary Statistics}\begin{longtable}{@{}"" + ""c"" * len(sdf.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in sdf.columns]) + r""\\\midrule\endhead""
            for _, r in sdf.iterrows():
                lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r]) + r""\\\midrule"" + ""\n""
            lc += r""\bottomrule\end{longtable}""
            if self.layers is not None and not self.layers.empty:
                lc += r""\section*{Identified Layers}\begin{longtable}{@{}"" + ""c"" * len(self.layers.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in self.layers.columns]) + r""\\\midrule\endhead""
                for _, r in self.layers.iterrows():
                    lc += r"" & "".join([f""{v:.2f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r]) + r""\\\midrule"" + ""\n""
                lc += r""\bottomrule\end{longtable}""
            if self.corr_res is not None and not self.corr_res.empty:
                lc += r""\section*{Correlation Results}\begin{longtable}{@{}"" + ""c"" * len(self.corr_res.columns) + r""@{}}\toprule"" + r"" & "".join([f""\\textbf{{{c}}}"" for c in self.corr_res.columns]) + r""\\\midrule\endhead""
                for _, r in self.corr_res.iterrows():
                    lc += r"" & "".join([f""{v:.3f}"" if isinstance(v, (int, float)) and pd.notna(v) else str(v) for v in r]) + r""\\\midrule"" + ""\n""
                lc += r""\bottomrule\end{longtable}""
            lc += r""\end{document}""
            with open(tp, 'w', encoding='utf-8') as f:
                f.write(lc)
            subprocess.run(['latexmk', '-pdf', f'-outdir={od}', str(tp)], capture_output=True, text=True, check=True)
            pp = od / f""{fn}_detailed_report_{ts}.pdf""
            if pp.exists():
                self.status_var.set(f""Exported report to {pp} at {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%I:%M %p IST')}"")
                messagebox.showinfo(""Success"", f""Report to {pp}"")
            else:
                raise Exception(""PDF failed"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Export failed: {str(e)}"")
            logging.error(f""Report export failed: {str(e)}"")"
prrDHdf7,Make $1200 in 15 minutes R,Zweii,JavaScript,Wednesday 2nd of July 2025 01:02:50 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 6231220
"
3xywnfRS,✅ Crypto Accounts 0,unknxwnghxst,JavaScript,Wednesday 2nd of July 2025 01:02:15 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 8435144
"
7DKbPtMP,✅ Crypto Accounts 8,patoza,JavaScript,Wednesday 2nd of July 2025 12:50:15 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 5777213
"
tUpnfAN0,MAKE $500 INSTANTLY 9,Zweii,JavaScript,Wednesday 2nd of July 2025 12:49:25 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 9244956
"
j5aD5nY7,FREE BTC GUIDE U,unknxwnghxst,JavaScript,Wednesday 2nd of July 2025 12:48:49 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 3552058
"
wW9Marzy,FREE BTC GUIDE R,patoza,JavaScript,Wednesday 2nd of July 2025 12:36:51 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 5635965
"
2kDBLGG3,✅ MAKE $12OO IN 10 MIN S,Zweii,JavaScript,Wednesday 2nd of July 2025 12:36:00 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 7315903
"
ixaZUbLq,Make $1200 in 15 minutes 6,unknxwnghxst,JavaScript,Wednesday 2nd of July 2025 12:35:23 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 5781612
"
FC5FMFRb,Make $1200 in 15 minutes H,patoza,JavaScript,Wednesday 2nd of July 2025 12:23:25 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 4792670
"
xgQFg8TD,✅ Crypto Accounts 5,Zweii,JavaScript,Wednesday 2nd of July 2025 12:22:35 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 9368439
"
7GbqWQPH,✅ MAKE $12OO IN 10 MIN A,unknxwnghxst,JavaScript,Wednesday 2nd of July 2025 12:21:59 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 7201058
"
3gj5fi0h,MAKE $500 INSTANTLY U,patoza,JavaScript,Wednesday 2nd of July 2025 12:09:58 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 1270328
"
3rf1We60,Make $1200 in 15 minutes R,Zweii,JavaScript,Wednesday 2nd of July 2025 12:09:07 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 6867415
"
T3BVGCrD,✅ Crypto Accounts 0,unknxwnghxst,JavaScript,Wednesday 2nd of July 2025 12:08:33 AM CDT,"We just posted new leaks.

Join the channel: https://t.me/SDZgui
ACC 4780192
"
5ERFEjNR,Untitled,johnkris,C,Tuesday 1st of July 2025 11:43:41 PM CDT,"import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import os
import shutil
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
from datetime import datetime
from PIL import Image, ImageTk
import pytz
from scipy.stats import pearsonr
import threading
import time

class SeismicWaveAnalyzer:
    def __init__(self, root):
        self.root = root
        self.root.withdraw()

        # Directories
        self.data_dir = r""C:\SeismicWaveData""
        self.output_base_dir = os.path.join(self.data_dir, ""Outputs"")
        try:
            os.makedirs(self.data_dir, exist_ok=True)
            os.makedirs(self.output_base_dir, exist_ok=True)
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to create directories: {str(e)}"")
            self.root.destroy()
            return

        self.show_splash_screen()

    def show_splash_screen(self):
        splash = tk.Toplevel()
        splash.title(""Welcome"")
        splash.configure(bg=""#ffffff"")
        splash.attributes('-fullscreen', True)
        splash.overrideredirect(True)

        try:
            img1 = Image.open(r""C:\SeismicWaveData\picture1.png"")
            img1 = img1.resize((200, 200), Image.LANCZOS)
            photo1 = ImageTk.PhotoImage(img1)
            img1_label = tk.Label(splash, image=photo1, bg=""#ffffff"")
            img1_label.image = photo1
            img1_label.place(x=20, y=20)
        except Exception:
            img1_placeholder = tk.Label(splash, text=""[Reference Image 1 Placeholder]"", width=20, height=10, bg=""#d3d3d3"")
            img1_placeholder.place(x=20, y=20)

        try:
            img2 = Image.open(r""C:\SeismicWaveData\picture2.png"")
            img2 = img2.resize((200, 200), Image.LANCZOS)
            photo2 = ImageTk.PhotoImage(img2)
            img2_label = tk.Label(splash, image=photo2, bg=""#ffffff"")
            img2_label.image = photo2
            img2_label.place(relx=1.0, y=20, anchor=""ne"")
        except Exception:
            img2_placeholder = tk.Label(splash, text=""[Reference Image 2 Placeholder]"", width=20, height=10, bg=""#d3d3d3"")
            img2_placeholder.place(relx=1.0, y=20, anchor=""ne"")

        text_frame = tk.Frame(splash, bg=""#ffffff"")
        text_frame.place(relx=0.5, rely=0.5, anchor=""center"")

        tk.Label(text_frame, text=""Seismic Wave Analysis Tool"", font=(""Segoe UI"", 20, ""bold""), bg=""#ffffff"").pack(pady=10)
        tk.Label(text_frame, text=""An FTT Mode Project"", font=(""Segoe UI"", 16), bg=""#ffffff"").pack(pady=5)
        tk.Label(text_frame, text=""Instrumentation & Engineering Geophysics Group"", font=(""Segoe UI"", 14), bg=""#ffffff"").pack(pady=5)
        tk.Label(text_frame, text=""Dr N Satyavani, Project Lead"", font=(""Segoe UI"", 14, ""italic""), bg=""#ffffff"").pack(pady=5)

        splash.after(6000, lambda: self.launch_main_window(splash))

    def launch_main_window(self, splash):
        splash.destroy()
        self.root.deiconify()
        self.root.title(""Seismic Wave Analysis Tool"")
        self.root.geometry(""1000x700"")
        self.root.state('zoomed')

        self.light_theme = {
            ""bg"": ""#ffffff"",
            ""fg"": ""#212121"",
            ""entry_bg"": ""#f5f5f5"",
            ""accent"": ""#003087"",
            ""button_fg"": ""#ffffff"",
        }
        self.root.configure(bg=self.light_theme[""bg""])

        self.raw_tree = None
        self.quality_tree = None
        self.analysis_tree = None
        self.summary_tree = None
        self.layers_tree = None
        self.correlation_tree = None
        self.realtime_tree = None
        self.plot_label = None
        self.plot_canvas = None
        self.current_data = None
        self.raw_data = None
        self.current_file = None
        self.deviations = None
        self.quality_issues = None
        self.layers = None
        self.correlation_data = None
        self.realtime_data = None
        self.current_fig = None
        self.selected_rows = {}
        self.raw_data_min_depth_var = tk.StringVar()
        self.raw_data_max_depth_var = tk.StringVar()
        self.realtime_running = False

        # Visualization options
        self.plot_options = {
            ""Vp/Vs Ratio"": tk.BooleanVar(value=True),
            ""Poisson's Ratio"": tk.BooleanVar(value=True),
            ""Shear Modulus"": tk.BooleanVar(value=True),
            ""Bulk Modulus"": tk.BooleanVar(value=True),
            ""Young's Modulus"": tk.BooleanVar(value=True),
            ""Lame's Lambda"": tk.BooleanVar(value=True),
            ""Travel Time Deviations"": tk.BooleanVar(value=True),
        }
        self.min_depth_var = tk.StringVar()
        self.max_depth_var = tk.StringVar()

        self.setup_gui()
        self.update_clock()

    def setup_gui(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label=""File"", menu=file_menu)
        file_menu.add_command(label=""Exit"", command=self.root.quit)

        file_frame = ttk.Frame(self.root)
        file_frame.pack(pady=10, padx=10, fill=tk.X)

        ttk.Label(file_frame, text=""Upload CHST File:"", font=(""Segoe UI"", 10)).pack(side=tk.LEFT, padx=5)
        upload_button = ttk.Button(file_frame, text=""Upload"", command=self.upload_file, style=""Custom.TButton"")
        upload_button.pack(side=tk.LEFT, padx=5)

        ttk.Button(file_frame, text=""Create Template File"", command=self.create_template_file, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)

        ttk.Button(file_frame, text=""Import CSV to PDF"", command=self.import_csv_to_pdf, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)

        refresh_button = ttk.Button(file_frame, text=""Refresh"", command=self.refresh_file_list, style=""Custom.TButton"")
        refresh_button.pack(side=tk.LEFT, padx=5)

        ttk.Label(file_frame, text=""Select File:"", font=(""Segoe UI"", 10)).pack(side=tk.LEFT, padx=5)
        self.file_var = tk.StringVar()
        self.file_combobox = ttk.Combobox(file_frame, textvariable=self.file_var, state=""readonly"")
        self.file_combobox.pack(side=tk.LEFT, padx=5)
        self.file_combobox.bind(""<<ComboboxSelected>>"", self.load_file_data)

        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

        self.raw_data_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.raw_data_frame, text=""Raw Data"")
        self.setup_raw_data_tab()

        self.quality_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.quality_frame, text=""Quality Check"")
        self.setup_quality_tab()

        self.analysis_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.analysis_frame, text=""Analysis"")
        self.setup_analysis_tab()

        self.summary_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.summary_frame, text=""Summary"")
        self.setup_summary_tab()

        self.layers_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.layers_frame, text=""Layers"")
        self.setup_layers_tab()

        self.correlation_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.correlation_frame, text=""Correlation Analysis"")
        self.setup_correlation_tab()

        self.realtime_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.realtime_frame, text=""Real-Time"")
        self.setup_realtime_tab()

        self.visualization_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.visualization_frame, text=""Visualizations"")
        self.setup_visualization_tab()

        export_frame = ttk.Frame(self.root)
        export_frame.pack(pady=5, fill=tk.X)
        ttk.Button(export_frame, text=""Export Raw Data to CSV"", command=self.export_raw_data, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(export_frame, text=""Export Quality Check to CSV"", command=self.export_quality_check, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(export_frame, text=""Export Analysis to PDF"", command=self.export_analysis_to_pdf, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(export_frame, text=""Export Summary to CSV"", command=self.export_summary, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(export_frame, text=""Export Layers to CSV"", command=self.export_layers, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(export_frame, text=""Export Correlation to CSV"", command=self.export_correlation, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(export_frame, text=""Export Detailed Report"", command=self.export_detailed_report, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)

        self.status_var = tk.StringVar()
        self.clock_var = tk.StringVar()
        status_frame = ttk.Frame(self.root)
        status_frame.pack(side=tk.BOTTOM, fill=tk.X)
        status_bar = tk.Label(status_frame, textvariable=self.status_var, bd=1, relief=tk.SUNKEN, anchor=tk.W, font=(""Segoe UI"", 10))
        status_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
        clock_label = tk.Label(status_frame, textvariable=self.clock_var, bd=1, relief=tk.SUNKEN, anchor=tk.E, font=(""Segoe UI"", 10))
        clock_label.pack(side=tk.RIGHT)

        self.apply_theme()
        self.refresh_file_list()

    def apply_theme(self):
        style = ttk.Style()
        style.theme_use('clam')
        style.configure(""Custom.TFrame"", background=self.light_theme[""bg""])
        style.configure(""Custom.TButton"", 
                        background=self.light_theme[""accent""], 
                        foreground=self.light_theme[""button_fg""],
                        font=(""Segoe UI"", 10),
                        padding=8)
        style.configure(""TCombobox"", fieldbackground=self.light_theme[""entry_bg""], foreground=self.light_theme[""fg""])
        style.configure(""Treeview"", background=self.light_theme[""entry_bg""], foreground=self.light_theme[""fg""], fieldbackground=self.light_theme[""entry_bg""])
        style.configure(""Treeview.Heading"", background=self.light_theme[""bg""], foreground=self.light_theme[""fg""])

    def update_clock(self):
        ist = pytz.timezone('Asia/Kolkata')
        current_time = datetime.now(ist).strftime(""%a, %b %d, %Y %I:%M %p IST"")
        self.clock_var.set(current_time)
        self.root.after(1000, self.update_clock)

    def setup_raw_data_tab(self):
        selection_frame = ttk.Frame(self.raw_data_frame)
        selection_frame.pack(fill=tk.X, pady=5)

        ttk.Label(selection_frame, text=""Select Depth Range (m):"").pack(side=tk.LEFT, padx=5)
        ttk.Entry(selection_frame, textvariable=self.raw_data_min_depth_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Label(selection_frame, text=""to"").pack(side=tk.LEFT)
        ttk.Entry(selection_frame, textvariable=self.raw_data_max_depth_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(selection_frame, text=""Apply Selection"", command=self.apply_selection, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(selection_frame, text=""Reset Selection"", command=self.reset_selection, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)

        frame = ttk.Frame(self.raw_data_frame, style=""Custom.TFrame"")
        frame.pack(pady=10, fill=tk.BOTH, expand=True)

        canvas = tk.Canvas(frame)
        scrollbar_y = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=canvas.xview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            ""<Configure>"",
            lambda e: canvas.configure(scrollregion=canvas.bbox(""all""))
        )

        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        canvas.create_window((0, 0), window=scrollable_frame, anchor=""nw"")

        self.raw_tree = ttk.Treeview(scrollable_frame, show=""headings"")
        self.raw_tree.pack(fill=tk.BOTH, expand=True)

    def setup_quality_tab(self):
        frame = ttk.Frame(self.quality_frame, style=""Custom.TFrame"")
        frame.pack(pady=10, fill=tk.BOTH, expand=True)

        canvas = tk.Canvas(frame)
        scrollbar_y = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=canvas.xview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            ""<Configure>"",
            lambda e: canvas.configure(scrollregion=canvas.bbox(""all""))
        )

        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        canvas.create_window((0, 0), window=scrollable_frame, anchor=""nw"")

        self.quality_tree = ttk.Treeview(scrollable_frame, show=""headings"")
        self.quality_tree.pack(fill=tk.BOTH, expand=True)

    def setup_analysis_tab(self):
        frame = ttk.Frame(self.analysis_frame, style=""Custom.TFrame"")
        frame.pack(pady=10, fill=tk.BOTH, expand=True)

        control_frame = ttk.Frame(frame)
        control_frame.pack(fill=tk.X, pady=5)
        ttk.Button(control_frame, text=""Run Monte Carlo Simulation"", command=self.run_monte_carlo, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)

        canvas = tk.Canvas(frame)
        scrollbar_y = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=canvas.xview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            ""<Configure>"",
            lambda e: canvas.configure(scrollregion=canvas.bbox(""all""))
        )

        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        canvas.create_window((0, 0), window=scrollable_frame, anchor=""nw"")

        self.analysis_tree = ttk.Treeview(scrollable_frame, show=""headings"")
        self.analysis_tree.pack(fill=tk.BOTH, expand=True)

    def setup_summary_tab(self):
        frame = ttk.Frame(self.summary_frame, style=""Custom.TFrame"")
        frame.pack(pady=10, fill=tk.BOTH, expand=True)

        canvas = tk.Canvas(frame)
        scrollbar_y = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=canvas.xview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            ""<Configure>"",
            lambda e: canvas.configure(scrollregion=canvas.bbox(""all""))
        )

        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        canvas.create_window((0, 0), window=scrollable_frame, anchor=""nw"")

        self.summary_tree = ttk.Treeview(scrollable_frame, show=""headings"")
        self.summary_tree.pack(fill=tk.BOTH, expand=True)

    def setup_layers_tab(self):
        frame = ttk.Frame(self.layers_frame, style=""Custom.TFrame"")
        frame.pack(pady=10, fill=tk.BOTH, expand=True)

        canvas = tk.Canvas(frame)
        scrollbar_y = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=canvas.xview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            ""<Configure>"",
            lambda e: canvas.configure(scrollregion=canvas.bbox(""all""))
        )

        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        canvas.create_window((0, 0), window=scrollable_frame, anchor=""nw"")

        self.layers_tree = ttk.Treeview(scrollable_frame, show=""headings"")
        self.layers_tree.pack(fill=tk.BOTH, expand=True)

    def setup_correlation_tab(self):
        frame = ttk.Frame(self.correlation_frame, style=""Custom.TFrame"")
        frame.pack(pady=10, fill=tk.BOTH, expand=True)

        control_frame = ttk.Frame(frame)
        control_frame.pack(fill=tk.X, pady=5)
        ttk.Button(control_frame, text=""Upload SPT/Sonic Log File"", command=self.upload_correlation_file, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(control_frame, text=""Run Correlation Analysis"", command=self.run_correlation_analysis, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)

        canvas = tk.Canvas(frame)
        scrollbar_y = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=canvas.xview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            ""<Configure>"",
            lambda e: canvas.configure(scrollregion=canvas.bbox(""all""))
        )

        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        canvas.create_window((0, 0), window=scrollable_frame, anchor=""nw"")

        self.correlation_tree = ttk.Treeview(scrollable_frame, show=""headings"")
        self.correlation_tree.pack(fill=tk.BOTH, expand=True)

        self.correlation_plot_label = ttk.Label(scrollable_frame, text=""Upload SPT/Sonic Log file to view correlations."")
        self.correlation_plot_label.pack(fill=tk.BOTH, expand=True)

    def setup_realtime_tab(self):
        frame = ttk.Frame(self.realtime_frame, style=""Custom.TFrame"")
        frame.pack(pady=10, fill=tk.BOTH, expand=True)

        control_frame = ttk.Frame(frame)
        control_frame.pack(fill=tk.X, pady=5)
        ttk.Button(control_frame, text=""Start Real-Time Acquisition"", command=self.start_realtime, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)
        ttk.Button(control_frame, text=""Stop Real-Time Acquisition"", command=self.stop_realtime, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)

        canvas = tk.Canvas(frame)
        scrollbar_y = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=canvas.xview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            ""<Configure>"",
            lambda e: canvas.configure(scrollregion=canvas.bbox(""all""))
        )

        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        canvas.create_window((0, 0), window=scrollable_frame, anchor=""nw"")

        self.realtime_tree = ttk.Treeview(scrollable_frame, show=""headings"")
        self.realtime_tree.pack(fill=tk.BOTH, expand=True)

        self.realtime_plot_label = ttk.Label(scrollable_frame, text=""Start real-time acquisition to view data."")
        self.realtime_plot_label.pack(fill=tk.BOTH, expand=True)

    def setup_visualization_tab(self):
        frame = ttk.Frame(self.visualization_frame, style=""Custom.TFrame"")
        frame.pack(pady=10, fill=tk.BOTH, expand=True)

        options_frame = ttk.Frame(frame)
        options_frame.pack(fill=tk.X, pady=5)

        ttk.Label(options_frame, text=""Select Parameters to Plot:"", font=(""Segoe UI"", 10)).pack(side=tk.LEFT, padx=5)
        for param, var in self.plot_options.items():
            ttk.Checkbutton(options_frame, text=param, variable=var, command=self.update_plots).pack(side=tk.LEFT, padx=5)

        depth_frame = ttk.Frame(options_frame)
        depth_frame.pack(side=tk.LEFT, padx=10)
        ttk.Label(depth_frame, text=""Depth Range (m):"").pack(side=tk.LEFT)
        ttk.Entry(depth_frame, textvariable=self.min_depth_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Label(depth_frame, text=""to"").pack(side=tk.LEFT)
        ttk.Entry(depth_frame, textvariable=self.max_depth_var, width=10).pack(side=tk.LEFT, padx=5)
        ttk.Button(depth_frame, text=""Update Plot"", command=self.update_plots, style=""Custom.TButton"").pack(side=tk.LEFT, padx=5)

        ttk.Button(options_frame, text=""Save Plots"", command=self.save_plots, style=""Custom.TButton"").pack(side=tk.RIGHT, padx=5)

        self.canvas = tk.Canvas(frame)
        scrollbar_y = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=self.canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame, orient=tk.HORIZONTAL, command=self.canvas.xview)
        self.scrollable_frame = ttk.Frame(self.canvas)

        self.scrollable_frame.bind(
            ""<Configure>"",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox(""all""))
        )
        self.canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor=""nw"")

        self.plot_label = ttk.Label(self.scrollable_frame, text=""Select a file to view visualizations."")
        self.plot_label.pack(fill=tk.BOTH, expand=True)

    def import_csv_to_pdf(self):
        file_path = filedialog.askopenfilename(filetypes=[(""CSV Files"", ""*.csv""), (""All Files"", ""*.*"")])
        if not file_path:
            return

        try:
            df = pd.read_csv(file_path)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M')
            output_dir = os.path.join(self.output_base_dir, timestamp)
            os.makedirs(output_dir, exist_ok=True)
            input_filename = os.path.splitext(os.path.basename(file_path))[0]
            tex_filename = f""{input_filename}_data_{timestamp}.tex""
            tex_path = os.path.join(output_dir, tex_filename)
            pdf_filename = f""{input_filename}_data_{timestamp}.pdf""
            pdf_path = os.path.join(output_dir, pdf_filename)

            latex_content = r""""""
\documentclass[a4paper,12pt]{article}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{noto}

\begin{document}

\section*{Seismic Data Table}

\begin{longtable}{@{}"""""" + ""c"" * len(df.columns) + r""""""@{}}
\toprule
"""""" + "" & "".join([f""\\textbf{{{col}}}"" for col in df.columns]) + r"""""" \\
\midrule
\endhead
""""""

            for _, row in df.iterrows():
                formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
                latex_content += "" & "".join(formatted_row) + r"" \\ \midrule"" + ""\n""

            latex_content += r""""""
\bottomrule
\end{longtable}

\end{document}
""""""

            with open(tex_path, 'w', encoding='utf-8') as f:
                f.write(latex_content)

            os.system(f'latexmk -pdf -outdir=""{output_dir}"" ""{tex_path}""')

            if os.path.exists(pdf_path):
                ist = pytz.timezone('Asia/Kolkata')
                timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
                self.status_var.set(f""Imported CSV and generated PDF: {pdf_path} at {timestamp}"")
                messagebox.showinfo(""Success"", f""CSV imported and PDF generated successfully at {pdf_path}."")
            else:
                raise Exception(""PDF compilation failed."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to import CSV or generate PDF: {str(e)}"")

    def export_analysis_to_pdf(self):
        if self.current_data is None:
            messagebox.showwarning(""No Data"", ""Please load a valid file before exporting analysis."")
            return
        try:
            analysis_df = self.analyze_data(self.current_data)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M')
            output_dir = os.path.join(self.output_base_dir, timestamp)
            os.makedirs(output_dir, exist_ok=True)
            input_filename = os.path.splitext(self.current_file)[0]
            tex_filename = f""{input_filename}_analysis_{timestamp}.tex""
            tex_path = os.path.join(output_dir, tex_filename)
            pdf_filename = f""{input_filename}_analysis_{timestamp}.pdf""
            pdf_path = os.path.join(output_dir, pdf_filename)

            latex_content = r""""""
\documentclass[a4paper,12pt]{article}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{noto}

\begin{document}

\section*{Seismic Analysis Report}

\begin{longtable}{@{}"""""" + ""c"" * len(analysis_df.columns) + r""""""@{}}
\toprule
"""""" + "" & "".join([f""\\textbf{{{col}}}"" for col in analysis_df.columns]) + r"""""" \\
\midrule
\endhead
""""""

            for _, row in analysis_df.iterrows():
                formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
                latex_content += "" & "".join(formatted_row) + r"" \\ \midrule"" + ""\n""

            latex_content += r""""""
\bottomrule
\end{longtable}

\end{document}
""""""

            with open(tex_path, 'w', encoding='utf-8') as f:
                f.write(latex_content)

            os.system(f'latexmk -pdf -outdir=""{output_dir}"" ""{tex_path}""')

            if os.path.exists(pdf_path):
                ist = pytz.timezone('Asia/Kolkata')
                timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
                self.status_var.set(f""Exported analysis to PDF: {pdf_path} at {timestamp}"")
                messagebox.showinfo(""Success"", f""Analysis exported successfully to {pdf_path}."")
            else:
                raise Exception(""PDF compilation failed."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to export analysis to PDF: {str(e)}"")

    def refresh_file_list(self):
        files = [f for f in os.listdir(self.data_dir) if f.endswith(('.xlsx', '.csv'))]
        self.file_combobox['values'] = files
        self.file_var.set("""")
        self.clear_tabs()
        self.status_var.set(""Please select a file from the dropdown."")

    def upload_file(self):
        file_path = filedialog.askopenfilename(filetypes=[
            (""Excel and CSV Files"", ""*.xlsx *.csv""),
            (""Excel Files"", ""*.xlsx""),
            (""CSV Files"", ""*.csv""),
            (""All Files"", ""*.*"")
        ])
        if file_path:
            try:
                dest_path = os.path.join(self.data_dir, os.path.basename(file_path))
                shutil.copy(file_path, dest_path)
                self.refresh_file_list()
                ist = pytz.timezone('Asia/Kolkata')
                timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
                self.status_var.set(f""Uploaded: {os.path.basename(file_path)} at {timestamp}"")
            except Exception as e:
                messagebox.showerror(""Error"", f""Failed to upload file: {str(e)}"")

    def create_template_file(self):
        try:
            columns = [""Depth (m)"", ""Elevation (m)"", ""P wave time (ms)"", ""S wave time (ms)""]
            data_rows = [
                [3.00, 100.00, 5.00, 10.00],
                [4.50, 98.50, 5.50, 11.00],
                [6.00, 97.00, 6.00, 12.00]
            ]

            df_template = pd.DataFrame(data_rows, columns=columns)
            template_path = os.path.join(self.data_dir, ""template_seismic_data.xlsx"")
            df_template.to_excel(template_path, index=False)

            self.refresh_file_list()
            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Created template file: template_seismic_data.xlsx at {timestamp}"")
            messagebox.showinfo(""Success"", ""Template file created successfully: template_seismic_data.xlsx"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to create template file: {str(e)}"")

    def find_header_row(self, df):
        for idx, row in df.iterrows():
            row_values = [str(val).strip() if pd.notna(val) else """" for val in row.values]
            if ""Depth"" in row_values:
                depth_col_idx = row_values.index(""Depth"")
                if idx + 1 < len(df):
                    next_row = df.iloc[idx + 1]
                    next_row_values = [str(val).strip() if pd.notna(val) else """" for val in next_row.values]
                    if depth_col_idx < len(next_row_values) and next_row_values[depth_col_idx] == ""(m)"":
                        return idx
        return None

    def load_file_data(self, event=None):
        selected_file = self.file_var.get()
        if not selected_file:
            return

        self.clear_tabs()

        self.current_file = selected_file
        file_path = os.path.join(self.data_dir, selected_file)
        try:
            if selected_file.endswith('.xlsx'):
                xl = pd.ExcelFile(file_path)
                sheet_names = xl.sheet_names
                header_row = None
                target_sheet = None
                for sheet in sheet_names:
                    df_sheet = pd.read_excel(file_path, sheet_name=sheet, header=None)
                    header_row = self.find_header_row(df_sheet)
                    if header_row is not None:
                        target_sheet = sheet
                        break

                if header_row is None:
                    raise ValueError(""Could not find 'Depth' followed by '(m)' in any sheet of the file."")

                df = pd.read_excel(file_path, sheet_name=target_sheet, header=[header_row, header_row + 1])
                col_names = []
                col_counts = {}
                for col in df.columns:
                    col_name = f""{col[0]} {col[1]}"".strip() if col[1] and pd.notna(col[1]) else col[0]
                    if col_name in col_counts:
                        col_counts[col_name] += 1
                        col_names.append(f""{col_name} {col_counts[col_name]}"")
                    else:
                        col_counts[col_name] = 0
                        col_names.append(col_name)
                df.columns = col_names
            elif selected_file.endswith('.csv'):
                df_temp = pd.read_csv(file_path, header=None)
                header_row = self.find_header_row(df_temp)
                if header_row is None:
                    raise ValueError(""Could not find 'Depth' followed by '(m)' in the CSV file."")

                df = pd.read_csv(file_path, header=[header_row, header_row + 1])
                col_names = []
                col_counts = {}
                for col in df.columns:
                    col_name = f""{col[0]} {col[1]}"".strip() if col[1] and pd.notna(col[1]) else col[0]
                    if col_name in col_counts:
                        col_counts[col_name] += 1
                        col_names.append(f""{col_name} {col_counts[col_name]}"")
                    else:
                        col_counts[col_name] = 0
                        col_names.append(col_name)
                df.columns = col_names
            else:
                raise ValueError(""Unsupported file format. Please upload an Excel (.xlsx) or CSV (.csv) file."")

            df.columns = [col.replace('\n', ' ') for col in df.columns]
            df.columns = ['Depth (m)' if col.startswith('Depth') else col for col in df.columns]

            elevation_cols = [col for col in df.columns if col.startswith('Elevation')]
            if elevation_cols:
                valid_elevation_col = None
                for col in elevation_cols:
                    if df[col].notna().any():
                        valid_elevation_col = col
                        break
                if valid_elevation_col:
                    df.rename(columns={valid_elevation_col: 'Elevation (m)'}, inplace=True)
                    other_elevation_cols = [col for col in elevation_cols if col != valid_elevation_col]
                    df.drop(columns=other_elevation_cols, inplace=True)

            df = df.dropna(axis=1, how='all')
            df = df.loc[:, (df.notna().any()) | (df.columns == 'Depth (m)')].dropna(subset=df.columns.difference(['Depth (m)']), how='all')
            df_raw = df[df['Depth (m)'].notna()]
            self.raw_data = df_raw.copy()

            self.current_data = self.raw_data.copy()

            required_columns = ['Depth (m)', 'Elevation (m)']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                raise ValueError(f""Missing required columns: {', '.join(missing_columns)}"")

            self.display_raw_data(self.raw_data)
            analysis_df = self.analyze_data(self.current_data)
            self.display_analysis(analysis_df)
            self.check_data_quality(self.current_data)
            self.display_quality_check()
            self.display_summary(analysis_df)
            self.identify_layers(analysis_df)
            self.display_layers()
            self.plot_visualizations(self.current_data, analysis_df)

            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Loaded: {selected_file} at {timestamp}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to load file: {str(e)}"")
            self.clear_tabs()

    def on_select_row(self, event):
        item = self.raw_tree.identify_row(event.y)
        if not item:
            return
        idx = int(self.raw_tree.index(item))
        current_value = self.selected_rows.get(idx, False)
        self.selected_rows[idx] = not current_value
        self.raw_tree.set(item, ""Select"", ""✔"" if self.selected_rows[idx] else """")

    def display_raw_data(self, df):
        for item in self.raw_tree.get_children():
            self.raw_tree.delete(item)

        full_df = self.raw_data
        columns = [""Select""] + list(full_df.columns)
        self.raw_tree[""columns""] = columns
        for col in columns:
            self.raw_tree.heading(col, text=col)
            self.raw_tree.column(col, anchor=tk.CENTER, stretch=True)

        self.selected_rows = {}
        for idx, row in full_df.iterrows():
            formatted_row = [""""] + [str(val) if pd.notna(val) else """" for val in row]
            self.raw_tree.insert("""", tk.END, values=formatted_row)
            self.selected_rows[idx] = False

        self.raw_tree.column(""Select"", width=50, minwidth=50)
        self.raw_tree.bind(""<Button-1>"", self.on_select_row)

        for col in columns[1:]:
            data_lengths = [len(str(row.get(col, """"))) if pd.notna(row.get(col)) else 0 for _, row in full_df.iterrows()]
            data_max = max(data_lengths, default=0)
            max_length = max(len(str(col)), data_max)
            self.raw_tree.column(col, width=max_length * 10, minwidth=150)

    def apply_selection(self):
        if self.raw_data is None:
            return

        df = self.raw_data.copy()

        try:
            min_depth = float(self.raw_data_min_depth_var.get()) if self.raw_data_min_depth_var.get() else df['Depth (m)'].min()
            max_depth = float(self.raw_data_max_depth_var.get()) if self.raw_data_max_depth_var.get() else df['Depth (m)'].max()
            if min_depth > max_depth:
                min_depth, max_depth = max_depth, min_depth
            df = df[(df['Depth (m)'] >= min_depth) & (df['Depth (m)'] <= max_depth)]
        except ValueError:
            pass

        selected_indices = [idx for idx, selected in self.selected_rows.items() if selected]
        if selected_indices:
            df = df.iloc[selected_indices]

        self.current_data = df
        analysis_df = self.analyze_data(self.current_data)
        self.display_analysis(analysis_df)
        self.check_data_quality(self.current_data)
        self.display_quality_check()
        self.display_summary(analysis_df)
        self.identify_layers(analysis_df)
        self.display_layers()
        self.plot_visualizations(self.current_data, analysis_df)

        ist = pytz.timezone('Asia/Kolkata')
        timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
        self.status_var.set(f""Applied selection: {len(self.current_data)} rows at {timestamp}"")

    def reset_selection(self):
        if self.raw_data is None:
            return

        self.current_data = self.raw_data.copy()
        self.raw_data_min_depth_var.set("""")
        self.raw_data_max_depth_var.set("""")
        self.selected_rows = {idx: False for idx in range(len(self.raw_data))}
        for item in self.raw_tree.get_children():
            self.raw_tree.set(item, ""Select"", """")

        analysis_df = self.analyze_data(self.current_data)
        self.display_analysis(analysis_df)
        self.check_data_quality(self.current_data)
        self.display_quality_check()
        self.display_summary(analysis_df)
        self.identify_layers(analysis_df)
        self.display_layers()
        self.plot_visualizations(self.current_data, analysis_df)

        ist = pytz.timezone('Asia/Kolkata')
        timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
        self.status_var.set(f""Reset selection: {len(self.current_data)} rows at {timestamp}"")

    def check_data_quality(self, df):
        p_wave_cols = [col for col in df.columns if ""P wave time"" in col]
        s_wave_cols = [col for col in df.columns if ""S wave time"" in col]

        if not p_wave_cols or not s_wave_cols:
            self.quality_issues = pd.DataFrame(columns=['Depth (m)', 'First P-wave Time (µs)', 'First S-wave Time (µs)', 'Flag Reason'])
            return

        df['First P-wave Time (µs)'] = df[p_wave_cols].min(axis=1) * 1000
        df['First S-wave Time (µs)'] = df[s_wave_cols].min(axis=1) * 1000

        p_median = df['First P-wave Time (µs)'].median()
        p_std = df['First P-wave Time (µs)'].std()
        s_median = df['First S-wave Time (µs)'].median()
        s_std = df['First S-wave Time (µs)'].std()

        depth_diff = df['Depth (m)'].diff()
        non_monotonic_indices = depth_diff[depth_diff <= 0].index

        quality_issues = []
        for idx, row in df.iterrows():
            p_time = row['First P-wave Time (µs)']
            s_time = row['First S-wave Time (µs)']
            depth = row['Depth (m)']
            flags = []

            if pd.notna(p_time):
                if p_time < 0.5:
                    flags.append(""P-wave time too small (< 0.5 µs)"")
                if abs(p_time - p_median) > 2 * p_std:
                    flags.append(""P-wave time outlier"")
            if pd.notna(s_time):
                if s_time < 0.5:
                    flags.append(""S-wave time too small (< 0.5 µs)"")
                if abs(s_time - s_median) > 2 * s_std:
                    flags.append(""S-wave time outlier"")

            if idx in non_monotonic_indices and idx > 0:
                flags.append(""Depth not monotonically increasing"")

            if flags:
                quality_issues.append([depth, p_time, s_time, ""; "".join(flags)])

        if quality_issues:
            self.quality_issues = pd.DataFrame(quality_issues, columns=['Depth (m)', 'First P-wave Time (µs)', 'First S-wave Time (µs)', 'Flag Reason'])
        else:
            self.quality_issues = pd.DataFrame(columns=['Depth (m)', 'First P-wave Time (µs)', 'First S-wave Time (µs)', 'Flag Reason'])

    def display_quality_check(self):
        for item in self.quality_tree.get_children():
            self.quality_tree.delete(item)

        columns = list(self.quality_issues.columns)
        self.quality_tree[""columns""] = columns
        for col in columns:
            self.quality_tree.heading(col, text=col)
            self.quality_tree.column(col, anchor=tk.CENTER)

        for idx, row in self.quality_issues.iterrows():
            formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) for val in row]
            self.quality_tree.insert("""", tk.END, values=formatted_row)

        for col in columns:
            data_lengths = [len(str(row.get(col, """"))) if pd.notna(row.get(col)) else 0 for _, row in self.quality_issues.iterrows()]
            data_max = max(data_lengths, default=0)
            max_length = max(len(str(col)), data_max)
            min_width = 300 if col == ""Flag Reason"" else 150
            self.quality_tree.column(col, width=max_length * 10, minwidth=min_width)

    def run_monte_carlo(self):
        if self.current_data is None:
            messagebox.showwarning(""No Data"", ""Please load a valid file before running Monte Carlo simulation."")
            return

        try:
            df = self.current_data.copy()
            n_iterations = 1000
            time_noise_std = 0.01  # 1% noise in travel times

            p_wave_cols = [col for col in df.columns if ""P wave time"" in col]
            s_wave_cols = [col for col in df.columns if ""S wave time"" in col]
            if not p_wave_cols or not s_wave_cols:
                raise ValueError(""P-wave or S-wave time columns not found."")

            results = {
                'P-wave Velocity (m/s)': [],
                'S-wave Velocity (m/s)': [],
                'Vp/Vs Ratio': []
            }

            for _ in range(n_iterations):
                df_sim = df.copy()
                for col in p_wave_cols:
                    df_sim[col] = df_sim[col] * (1 + np.random.normal(0, time_noise_std, len(df_sim)))
                for col in s_wave_cols:
                    df_sim[col] = df_sim[col] * (1 + np.random.normal(0, time_noise_std, len(df_sim)))

                analysis_sim = self.analyze_data(df_sim)
                for param in results.keys():
                    results[param].append(analysis_sim[param].values)

            for param in results:
                results[param] = np.array(results[param])
                mean = np.mean(results[param], axis=0)
                ci_lower = np.percentile(results[param], 2.5, axis=0)
                ci_upper = np.percentile(results[param], 97.5, axis=0)
                df[f'{param} Mean'] = mean
                df[f'{param} CI Lower'] = ci_lower
                df[f'{param} CI Upper'] = ci_upper

            self.current_data = df
            self.display_analysis(self.current_data)
            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Monte Carlo simulation completed at {timestamp}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to run Monte Carlo simulation: {str(e)}"")

    def upload_correlation_file(self):
        file_path = filedialog.askopenfilename(filetypes=[
            (""Excel and CSV Files"", ""*.xlsx *.csv""),
            (""Excel Files"", ""*.xlsx""),
            (""CSV Files"", ""*.csv""),
            (""All Files"", ""*.*"")
        ])
        if file_path:
            try:
                if file_path.endswith('.xlsx'):
                    df = pd.read_excel(file_path)
                elif file_path.endswith('.csv'):
                    df = pd.read_csv(file_path)
                else:
                    raise ValueError(""Unsupported file format."")

                required_cols = ['Depth (m)']
                if not all(col in df.columns for col in required_cols):
                    raise ValueError(""SPT/Sonic Log file must contain 'Depth (m)' column."")

                self.correlation_data = df
                ist = pytz.timezone('Asia/Kolkata')
                timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
                self.status_var.set(f""Uploaded SPT/Sonic Log file: {os.path.basename(file_path)} at {timestamp}"")
            except Exception as e:
                messagebox.showerror(""Error"", f""Failed to upload SPT/Sonic Log file: {str(e)}"")

    def run_correlation_analysis(self):
        if self.current_data is None or self.correlation_data is None:
            messagebox.showwarning(""No Data"", ""Please load both CHST and SPT/Sonic Log files."")
            return

        try:
            seismic_df = self.analyze_data(self.current_data)
            correlation_df = self.correlation_data

            merged_df = pd.merge(seismic_df, correlation_df, on='Depth (m)', how='inner')
            if merged_df.empty:
                raise ValueError(""No matching depths found between CHST and SPT/Sonic Log data."")

            correlation_results = []
            seismic_params = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio']
            correlation_params = [col for col in correlation_df.columns if col != 'Depth (m)']

            for s_param in seismic_params:
                for c_param in correlation_params:
                    if merged_df[s_param].notna().sum() > 1 and merged_df[c_param].notna().sum() > 1:
                        corr, p_value = pearsonr(merged_df[s_param].dropna(), merged_df[c_param].dropna())
                        correlation_results.append([s_param, c_param, corr, p_value])

            self.correlation_results = pd.DataFrame(correlation_results, columns=['Seismic Parameter', 'Correlation Parameter', 'Pearson Correlation', 'P-Value'])

            self.display_correlation()
            self.plot_correlation(merged_df)
            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Correlation analysis completed at {timestamp}"")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to run correlation analysis: {str(e)}"")

    def display_correlation(self):
        for item in self.correlation_tree.get_children():
            self.correlation_tree.delete(item)

        columns = list(self.correlation_results.columns)
        self.correlation_tree[""columns""] = columns
        for col in columns:
            self.correlation_tree.heading(col, text=col)
            self.correlation_tree.column(col, anchor=tk.CENTER)

        for idx, row in self.correlation_results.iterrows():
            formatted_row = [f""{val:.3f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) for val in row]
            self.correlation_tree.insert("""", tk.END, values=formatted_row)

        for col in columns:
            data_lengths = [len(str(row.get(col, """"))) if pd.notna(row.get(col)) else 0 for _, row in self.correlation_results.iterrows()]
            data_max = max(data_lengths, default=0)
            max_length = max(len(str(col)), data_max)
            self.correlation_tree.column(col, width=max_length * 10, minwidth=150)

    def plot_correlation(self, merged_df):
        if hasattr(self, 'correlation_canvas') and self.correlation_canvas:
            self.correlation_canvas.get_tk_widget().destroy()
        if hasattr(self, 'correlation_fig') and self.correlation_fig:
            plt.close(self.correlation_fig)
        self.correlation_plot_label.pack_forget()

        seismic_params = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)']
        correlation_params = [col for col in merged_df.columns if col not in seismic_params + ['Depth (m)']]

        if not correlation_params:
            self.correlation_plot_label = ttk.Label(self.correlation_tree.master, text=""No valid correlation parameters found."")
            self.correlation_plot_label.pack(fill=tk.BOTH, expand=True)
            return

        n_plots = len(seismic_params) * len(correlation_params)
        rows = (n_plots + 2) // 3
        self.correlation_fig, axes = plt.subplots(rows, 3, figsize=(15, 4 * rows))
        axes = axes.flatten()

        plot_idx = 0
        for s_param in seismic_params:
            for c_param in correlation_params:
                axes[plot_idx].scatter(merged_df[s_param], merged_df[c_param], c='b', alpha=0.5)
                axes[plot_idx].set_xlabel(s_param)
                axes[plot_idx].set_ylabel(c_param)
                axes[plot_idx].set_title(f'{s_param} vs {c_param}')
                axes[plot_idx].grid(True)
                plot_idx += 1

        for i in range(plot_idx, len(axes)):
            axes[i].axis('off')

        plt.tight_layout()
        self.correlation_canvas = FigureCanvasTkAgg(self.correlation_fig, master=self.correlation_tree.master)
        self.correlation_canvas.draw()
        self.correlation_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def start_realtime(self):
        if self.realtime_running:
            return

        self.realtime_running = True
        self.realtime_data = pd.DataFrame(columns=['Depth (m)', 'Elevation (m)', 'P wave time (ms)', 'S wave time (ms)'])
        self.display_realtime()

        self.realtime_thread = threading.Thread(target=self.realtime_acquisition, daemon=True)
        self.realtime_thread.start()
        self.status_var.set(""Started real-time acquisition."")

    def stop_realtime(self):
        self.realtime_running = False
        self.status_var.set(""Stopped real-time acquisition."")

    def realtime_acquisition(self):
        realtime_file = os.path.join(self.data_dir, ""realtime_chst_data.csv"")
        while self.realtime_running:
            try:
                if os.path.exists(realtime_file):
                    df_new = pd.read_csv(realtime_file)
                    if not df_new.empty:
                        self.realtime_data = pd.concat([self.realtime_data, df_new]).drop_duplicates(subset=['Depth (m)']).reset_index(drop=True)
                        self.root.after(0, self.update_realtime_display)
            except Exception as e:
                print(f""Real-time error: {str(e)}"")
            time.sleep(1)

    def update_realtime_display(self):
        self.display_realtime()
        self.plot_realtime()

    def display_realtime(self):
        for item in self.realtime_tree.get_children():
            self.realtime_tree.delete(item)

        columns = list(self.realtime_data.columns)
        self.realtime_tree[""columns""] = columns
        for col in columns:
            self.realtime_tree.heading(col, text=col)
            self.realtime_tree.column(col, anchor=tk.CENTER)

        for idx, row in self.realtime_data.iterrows():
            formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) for val in row]
            self.realtime_tree.insert("""", tk.END, values=formatted_row)

        for col in columns:
            data_lengths = [len(str(row.get(col, """"))) if pd.notna(row.get(col)) else 0 for _, row in self.realtime_data.iterrows()]
            data_max = max(data_lengths, default=0)
            max_length = max(len(str(col)), data_max)
            self.realtime_tree.column(col, width=max_length * 10, minwidth=150)

    def plot_realtime(self):
        if hasattr(self, 'realtime_canvas') and self.realtime_canvas:
            self.realtime_canvas.get_tk_widget().destroy()
        if hasattr(self, 'realtime_fig') and self.realtime_fig:
            plt.close(self.realtime_fig)
        self.realtime_plot_label.pack_forget()

        if self.realtime_data.empty:
            self.realtime_plot_label = ttk.Label(self.realtime_tree.master, text=""No real-time data available."")
            self.realtime_plot_label.pack(fill=tk.BOTH, expand=True)
            return

        analysis_df = self.analyze_data(self.realtime_data)
        self.realtime_fig, ax = plt.subplots(figsize=(10, 5))
        ax.plot(analysis_df['Depth (m)'], analysis_df['P-wave Velocity (m/s)'], 'b-', label='P-wave Velocity')
        ax.plot(analysis_df['Depth (m)'], analysis_df['S-wave Velocity (m/s)'], 'r-', label='S-wave Velocity')
        ax.set_xlabel('Depth (m)')
        ax.set_ylabel('Velocity (m/s)')
        ax.set_title('Real-Time Seismic Velocities')
        ax.legend()
        ax.grid(True)

        self.realtime_canvas = FigureCanvasTkAgg(self.realtime_fig, master=self.realtime_tree.master)
        self.realtime_canvas.draw()
        self.realtime_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def analyze_data(self, df):
        df = df.copy()
        df['Depth (m)'] = pd.to_numeric(df['Depth (m)'], errors='coerce')
        
        p_wave_cols = [col for col in df.columns if ""P wave time"" in col]
        s_wave_cols = [col for col in df.columns if ""S wave time"" in col]

        if not p_wave_cols or not s_wave_cols:
            raise ValueError(""P-wave or S-wave time columns not found in the data."")

        for col in p_wave_cols + s_wave_cols:
            df[col] = pd.to_numeric(df[col], errors='coerce')

        df['First P-wave Time (µs)'] = df[p_wave_cols].min(axis=1) * 1000
        df['First S-wave Time (µs)'] = df[s_wave_cols].min(axis=1) * 1000

        df['P-wave Time Diff'] = df['First P-wave Time (µs)'].diff()
        df['S-wave Time Diff'] = df['First S-wave Time (µs)'].diff()
        
        p_mean_diff = df['P-wave Time Diff'].mean()
        p_std_diff = df['P-wave Time Diff'].std()
        s_mean_diff = df['S-wave Time Diff'].mean()
        s_std_diff = df['S-wave Time Diff'].std()
        
        df['P-wave Deviation'] = (df['P-wave Time Diff'] < 0) | (abs(df['P-wave Time Diff'] - p_mean_diff) > 2 * p_std_diff)
        df['S-wave Deviation'] = (df['S-wave Time Diff'] < 0) | (abs(df['S-wave Time Diff'] - s_mean_diff) > 2 * s_std_diff)
        
        self.deviations = df[df['P-wave Deviation'] | df['S-wave Deviation']][['Depth (m)', 'First P-wave Time (µs)', 'First S-wave Time (µs)']]

        df['P-wave Velocity (m/s)'] = 0.0
        df['S-wave Velocity (m/s)'] = 0.0
        for i in range(1, len(df)):
            delta_depth = df['Depth (m)'].iloc[i] - df['Depth (m)'].iloc[i-1]
            delta_p_time = (df['First P-wave Time (µs)'].iloc[i] - df['First P-wave Time (µs)'].iloc[i-1]) / 10**6 if pd.notna(df['First P-wave Time (µs)'].iloc[i]) and pd.notna(df['First P-wave Time (µs)'].iloc[i-1]) else 0
            delta_s_time = (df['First S-wave Time (µs)'].iloc[i] - df['First S-wave Time (µs)'].iloc[i-1]) / 10**6 if pd.notna(df['First S-wave Time (µs)'].iloc[i]) and pd.notna(df['First S-wave Time (µs)'].iloc[i-1]) else 0
            if delta_depth > 0 and delta_p_time > 0:
                df.loc[df.index[i], 'P-wave Velocity (m/s)'] = delta_depth / delta_p_time
            if delta_depth > 0 and delta_s_time > 0:
                df.loc[df.index[i], 'S-wave Velocity (m/s)'] = delta_depth / delta_s_time

        df['P-wave Velocity (m/s)'] = df['P-wave Velocity (m/s)'].replace([np.inf, -np.inf], 0).fillna(0)
        df['S-wave Velocity (m/s)'] = df['S-wave Velocity (m/s)'].replace([np.inf, -np.inf], 0).fillna(0)

        df['Vp/Vs Ratio'] = df['P-wave Velocity (m/s)'] / df['S-wave Velocity (m/s)']
        df['Vp/Vs Ratio'] = df['Vp/Vs Ratio'].replace([np.inf, -np.inf], 0).fillna(0)

        vp_vs = df['Vp/Vs Ratio']
        df['Poisson\'s Ratio'] = ((vp_vs**2 - 2) / (2 * (vp_vs**2 - 1))).replace([np.inf, -np.inf], 0).fillna(0)

        rho = 2500
        df['Shear Modulus (GPa)'] = (rho * (df['S-wave Velocity (m/s)']**2)) / 1e9
        df['Shear Modulus (GPa)'] = df['Shear Modulus (GPa)'].replace([np.inf, -np.inf], 0).fillna(0)

        df['Bulk Modulus (GPa)'] = (rho * (df['P-wave Velocity (m/s)']**2 - (4/3) * df['S-wave Velocity (m/s)']**2)) / 1e9
        df['Bulk Modulus (GPa)'] = df['Bulk Modulus (GPa)'].replace([np.inf, -np.inf], 0).fillna(0)

        num = 3 * df['P-wave Velocity (m/s)']**2 - 4 * df['S-wave Velocity (m/s)']**2
        denom = df['P-wave Velocity (m/s)']**2 - df['S-wave Velocity (m/s)']**2
        df['Young\'s Modulus (GPa)'] = (rho * df['S-wave Velocity (m/s)']**2 * num / denom) / 1e9
        df['Young\'s Modulus (GPa)'] = df['Young\'s Modulus (GPa)'].replace([np.inf, -np.inf], 0).fillna(0)

        df['Lame\'s Lambda (GPa)'] = df['Bulk Modulus (GPa)'] - (2/3) * df['Shear Modulus (GPa)']
        df['Lame\'s Lambda (GPa)'] = df['Lame\'s Lambda (GPa)'].replace([np.inf, -np.inf], 0).fillna(0)

        params = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio', 
                  'Poisson\'s Ratio', 'Shear Modulus (GPa)', 'Bulk Modulus (GPa)', 
                  'Young\'s Modulus (GPa)', 'Lame\'s Lambda (GPa)']
        
        analysis_df = df.copy()
        for param in params:
            analysis_df[f""{param} +10%""] = analysis_df[param] * 1.10
            analysis_df[f""{param} -10%""] = analysis_df[param] * 0.90

        analysis_cols = ['Depth (m)', 'Elevation (m)', 'First P-wave Time (µs)', 'First S-wave Time (µs)'] + \
                        [col for col in analysis_df.columns if col.startswith(tuple(params)) or col in params]
        return analysis_df[analysis_cols]

    def identify_layers(self, analysis_df):
        layers = []
        threshold = 0.20
        for i in range(1, len(analysis_df)):
            prev_p_velocity = analysis_df['P-wave Velocity (m/s)'].iloc[i-1]
            curr_p_velocity = analysis_df['P-wave Velocity (m/s)'].iloc[i]
            prev_s_velocity = analysis_df['S-wave Velocity (m/s)'].iloc[i-1]
            curr_s_velocity = analysis_df['S-wave Velocity (m/s)'].iloc[i]
            depth = analysis_df['Depth (m)'].iloc[i]

            p_change = abs(curr_p_velocity - prev_p_velocity) / prev_p_velocity if prev_p_velocity != 0 else 0
            s_change = abs(curr_s_velocity - prev_s_velocity) / prev_s_velocity if prev_s_velocity != 0 else 0

            if p_change > threshold or s_change > threshold:
                reason = []
                if p_change > threshold:
                    reason.append(f""P-wave velocity change: {p_change:.2%}"")
                if s_change > threshold:
                    reason.append(f""S-wave velocity change: {s_change:.2%}"")
                layers.append([depth, curr_p_velocity, curr_s_velocity, ""; "".join(reason)])

        if layers:
            self.layers = pd.DataFrame(layers, columns=['Depth (m)', 'P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Reason'])
        else:
            self.layers = pd.DataFrame(columns=['Depth (m)', 'P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Reason'])

    def display_layers(self):
        for item in self.layers_tree.get_children():
            self.layers_tree.delete(item)

        columns = list(self.layers.columns)
        self.layers_tree[""columns""] = columns
        for col in columns:
            self.layers_tree.heading(col, text=col)
            self.layers_tree.column(col, anchor=tk.CENTER, stretch=True)

        for idx, row in self.layers.iterrows():
            formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) for val in row]
            self.layers_tree.insert("""", tk.END, values=formatted_row)

        for col in columns:
            data_lengths = [len(str(row.get(col, """"))) if pd.notna(row.get(col)) else 0 for _, row in self.layers.iterrows()]
            data_max = max(data_lengths, default=0)
            max_length = max(len(str(col)), data_max)
            min_width = 1200 if col == ""Reason"" else 150
            self.layers_tree.column(col, width=max(max_length * 20, min_width), minwidth=min_width, stretch=True)

    def display_analysis(self, analysis_df):
        for item in self.analysis_tree.get_children():
            self.analysis_tree.delete(item)

        columns = list(analysis_df.columns)
        self.analysis_tree[""columns""] = columns
        for col in columns:
            self.analysis_tree.heading(col, text=col)
            self.analysis_tree.column(col, anchor=tk.CENTER)

        for idx, row in analysis_df.iterrows():
            formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
            self.analysis_tree.insert("""", tk.END, values=formatted_row)

        for col in columns:
            data_lengths = [len(str(row.get(col, """"))) if pd.notna(row.get(col)) else 0 for _, row in analysis_df.iterrows()]
            data_max = max(data_lengths, default=0)
            max_length = max(len(str(col)), data_max)
            self.analysis_tree.column(col, width=max_length * 10, minwidth=150)

    def compute_summary_stats(self, analysis_df):
        params = ['P-wave Velocity (m/s)', 'S-wave Velocity (m/s)', 'Vp/Vs Ratio', 
                  'Poisson\'s Ratio', 'Shear Modulus (GPa)', 'Bulk Modulus (GPa)', 
                  'Young\'s Modulus (GPa)', 'Lame\'s Lambda (GPa)']
        
        summary_data = []
        for param in params:
            data = analysis_df[param]
            summary_data.append([
                param,
                data.mean(),
                data.median(),
                data.std(),
                data.min(),
                data.max()
            ])

        return pd.DataFrame(summary_data, columns=['Parameter', 'Mean', 'Median', 'Std Dev', 'Min', 'Max'])

    def display_summary(self, analysis_df):
        summary_df = self.compute_summary_stats(analysis_df)
        
        for item in self.summary_tree.get_children():
            self.summary_tree.delete(item)

        columns = list(summary_df.columns)
        self.summary_tree[""columns""] = columns
        for col in columns:
            self.summary_tree.heading(col, text=col)
            self.summary_tree.column(col, anchor=tk.CENTER)

        for idx, row in summary_df.iterrows():
            formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) for val in row]
            self.summary_tree.insert("""", tk.END, values=formatted_row)

        for col in columns:
            data_lengths = [len(str(row.get(col, """"))) if pd.notna(row.get(col)) else 0 for _, row in summary_df.iterrows()]
            data_max = max(data_lengths, default=0)
            max_length = max(len(str(col)), data_max)
            self.summary_tree.column(col, width=max_length * 10, minwidth=150)

    def plot_visualizations(self, df, analysis_df):
        if self.plot_canvas:
            self.plot_canvas.get_tk_widget().destroy()
        if self.current_fig:
            plt.close(self.current_fig)
        self.plot_label.pack_forget()

        try:
            min_depth = float(self.min_depth_var.get()) if self.min_depth_var.get() else analysis_df['Depth (m)'].min()
            max_depth = float(self.max_depth_var.get()) if self.max_depth_var.get() else analysis_df['Depth (m)'].max()
            if min_depth > max_depth:
                min_depth, max_depth = max_depth, min_depth
        except ValueError:
            min_depth = analysis_df['Depth (m)'].min()
            max_depth = analysis_df['Depth (m)'].max()

        plot_df = analysis_df[(analysis_df['Depth (m)'] >= min_depth) & (analysis_df['Depth (m)'] <= max_depth)]
        plot_deviations = self.deviations
        if plot_deviations is not None and not plot_deviations.empty:
            plot_deviations = plot_deviations[(plot_deviations['Depth (m)'] >= min_depth) & (plot_deviations['Depth (m)'] <= max_depth)]

        plots_to_show = [param for param, var in self.plot_options.items() if var.get()]
        if not plots_to_show:
            self.plot_label = ttk.Label(self.scrollable_frame, text=""Select at least one parameter to plot."")
            self.plot_label.pack(fill=tk.BOTH, expand=True)
            return

        num_plots = len(plots_to_show)
        rows = (num_plots + 2) // 3
        fig, axes = plt.subplots(rows, 3, figsize=(15, 4 * rows))
        axes = axes.flatten()

        plot_index = 0
        plot_configs = [
            (""Vp/Vs Ratio"", 'g-', 'Vp/Vs Ratio', 'Vp/Vs Ratio vs Depth'),
            (""Poisson's Ratio"", 'b-', 'Poisson\'s Ratio', 'Poisson\'s Ratio vs Depth'),
            (""Shear Modulus"", 'r-', 'Shear Modulus (GPa)', 'Shear Modulus vs Depth'),
            (""Bulk Modulus"", 'c-', 'Bulk Modulus (GPa)', 'Bulk Modulus vs Depth'),
            (""Young's Modulus"", 'm-', 'Young\'s Modulus (GPa)', 'Young\'s Modulus vs Depth'),
            (""Lame's Lambda"", 'y-', 'Lame\'s Lambda (GPa)', 'Lame\'s Lambda vs Depth'),
            (""Travel Time Deviations"", None, None, 'Travel Time Deviations')
        ]

        for param, color, y_label, title in plot_configs:
            if param not in plots_to_show:
                continue

            if param == ""Travel Time Deviations"":
                if plot_deviations is not None and not plot_deviations.empty:
                    axes[plot_index].plot(plot_deviations['Depth (m)'], plot_deviations['First P-wave Time (µs)'], 'r-', label='P-wave Deviations')
                    axes[plot_index].plot(plot_deviations['Depth (m)'], plot_deviations['First S-wave Time (µs)'], 'b-', label='S-wave Deviations')
                    axes[plot_index].set_xlabel('Depth (m)', fontsize=12)
                    axes[plot_index].set_ylabel('Travel Time (µs)', fontsize=12)
                    axes[plot_index].set_title('Travel Time Deviations', fontsize=14)
                    axes[plot_index].grid(True)
                    axes[plot_index].legend()
                else:
                    axes[plot_index].text(0.5, 0.5, 'No Deviations Detected', horizontalalignment='center', verticalalignment='center')
                    axes[plot_index].set_title('Travel Time Deviations', fontsize=14)
                    axes[plot_index].grid(True)
            else:
                axes[plot_index].plot(plot_df['Depth (m)'], plot_df[y_label], color, label=y_label)
                axes[plot_index].set_xlabel('Depth (m)', fontsize=12)
                axes[plot_index].set_ylabel(y_label, fontsize=12)
                axes[plot_index].set_title(title, fontsize=14)
                axes[plot_index].grid(True)
                axes[plot_index].legend()

            plot_index += 1

        for i in range(plot_index, len(axes)):
            axes[i].axis('off')

        plt.tight_layout()

        self.current_fig = fig
        self.plot_canvas = FigureCanvasTkAgg(fig, master=self.scrollable_frame)
        self.plot_canvas.draw()
        self.plot_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def update_plots(self):
        if self.current_data is None:
            return
        analysis_df = self.analyze_data(self.current_data)
        self.plot_visualizations(self.current_data, analysis_df)

    def save_plots(self):
        if self.current_fig is None:
            messagebox.showwarning(""No Plot"", ""No plots available to save."")
            return

        file_path = filedialog.asksaveasfilename(defaultextension="".png"", filetypes=[(""PNG Files"", ""*.png""), (""All Files"", ""*.*"")])
        if file_path:
            try:
                self.current_fig.savefig(file_path, dpi=300, bbox_inches='tight')
                ist = pytz.timezone('Asia/Kolkata')
                timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
                self.status_var.set(f""Saved plot to {file_path} at {timestamp}"")
            except Exception as e:
                messagebox.showerror(""Error"", f""Failed to save plot: {str(e)}"")

    def export_raw_data(self):
        if self.current_data is None:
            messagebox.showwarning(""No Data"", ""Please load a valid file before exporting raw data."")
            return
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M')
            output_dir = os.path.join(self.output_base_dir, timestamp)
            os.makedirs(output_dir, exist_ok=True)
            input_filename = os.path.splitext(self.current_file)[0]
            csv_filename = f""{input_filename}_raw_data_{timestamp}.csv""
            csv_path = os.path.join(output_dir, csv_filename)
            self.current_data.to_csv(csv_path, index=False)
            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Exported raw data to {csv_path} at {timestamp}"")
            messagebox.showinfo(""Success"", f""Raw data exported successfully to {csv_path}."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to export raw data: {str(e)}"")

    def export_quality_check(self):
        if self.quality_issues is None or self.quality_issues.empty:
            messagebox.showwarning(""No Data"", ""No quality check data available to export."")
            return
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M')
            output_dir = os.path.join(self.output_base_dir, timestamp)
            os.makedirs(output_dir, exist_ok=True)
            input_filename = os.path.splitext(self.current_file)[0]
            csv_filename = f""{input_filename}_quality_check_{timestamp}.csv""
            csv_path = os.path.join(output_dir, csv_filename)
            self.quality_issues.to_csv(csv_path, index=False)
            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Exported quality check to {csv_path} at {timestamp}"")
            messagebox.showinfo(""Success"", f""Quality check exported successfully to {csv_path}."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to export quality check: {str(e)}"")

    def export_summary(self):
        if self.current_data is None:
            messagebox.showwarning(""No Data"", ""Please load a valid file before exporting summary."")
            return
        try:
            analysis_df = self.analyze_data(self.current_data)
            summary_df = self.compute_summary_stats(analysis_df)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M')
            output_dir = os.path.join(self.output_base_dir, timestamp)
            os.makedirs(output_dir, exist_ok=True)
            input_filename = os.path.splitext(self.current_file)[0]
            csv_filename = f""{input_filename}_summary_{timestamp}.csv""
            csv_path = os.path.join(output_dir, csv_filename)
            summary_df.to_csv(csv_path, index=False)
            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Exported summary to {csv_path} at {timestamp}"")
            messagebox.showinfo(""Success"", f""Summary exported successfully to {csv_path}."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to export summary: {str(e)}"")

    def export_layers(self):
        if self.layers is None or self.layers.empty:
            messagebox.showwarning(""No Data"", ""No layer data available to export."")
            return
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M')
            output_dir = os.path.join(self.output_base_dir, timestamp)
            os.makedirs(output_dir, exist_ok=True)
            input_filename = os.path.splitext(self.current_file)[0]
            csv_filename = f""{input_filename}_layers_{timestamp}.csv""
            csv_path = os.path.join(output_dir, csv_filename)
            self.layers.to_csv(csv_path, index=False)
            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Exported layers to {csv_path} at {timestamp}"")
            messagebox.showinfo(""Success"", f""Layers exported successfully to {csv_path}."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to export layers: {str(e)}"")

    def export_correlation(self):
        if self.correlation_results is None or self.correlation_results.empty:
            messagebox.showwarning(""No Data"", ""No correlation data available to export."")
            return
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M')
            output_dir = os.path.join(self.output_base_dir, timestamp)
            os.makedirs(output_dir, exist_ok=True)
            input_filename = os.path.splitext(self.current_file)[0]
            csv_filename = f""{input_filename}_correlation_{timestamp}.csv""
            csv_path = os.path.join(output_dir, csv_filename)
            self.correlation_results.to_csv(csv_path, index=False)
            ist = pytz.timezone('Asia/Kolkata')
            timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
            self.status_var.set(f""Exported correlation data to {csv_path} at {timestamp}"")
            messagebox.showinfo(""Success"", f""Correlation data exported successfully to {csv_path}."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to export correlation data: {str(e)}"")

    def export_detailed_report(self):
        if self.current_data is None:
            messagebox.showwarning(""No Data"", ""Please load a valid file before exporting detailed report."")
            return
        try:
            analysis_df = self.analyze_data(self.current_data)
            summary_df = self.compute_summary_stats(analysis_df)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M')
            output_dir = os.path.join(self.output_base_dir, timestamp)
            os.makedirs(output_dir, exist_ok=True)
            input_filename = os.path.splitext(self.current_file)[0]
            tex_filename = f""{input_filename}_detailed_report_{timestamp}.tex""
            tex_path = os.path.join(output_dir, tex_filename)
            pdf_filename = f""{input_filename}_detailed_report_{timestamp}.pdf""
            pdf_path = os.path.join(output_dir, pdf_filename)

            latex_content = r""""""
\documentclass[a4paper,12pt]{article}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{noto}

\begin{document}

\section*{Detailed Seismic Analysis Report}

\subsection*{Raw Data}
\begin{longtable}{@{}"""""" + ""c"" * len(self.current_data.columns) + r""""""@{}}
\toprule
"""""" + "" & "".join([f""\\textbf{{{col}}}"" for col in self.current_data.columns]) + r"""""" \\
\midrule
\endhead
""""""
            for _, row in self.current_data.iterrows():
                formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
                latex_content += "" & "".join(formatted_row) + r"" \\ \midrule"" + ""\n""
            latex_content += r""""""
\bottomrule
\end{longtable}

\subsection*{Quality Check}
""""""
            if self.quality_issues is not None and not self.quality_issues.empty:
                latex_content += r""""""
\begin{longtable}{@{}"""""" + ""c"" * len(self.quality_issues.columns) + r""""""@{}}
\toprule
"""""" + "" & "".join([f""\\textbf{{{col}}}"" for col in self.quality_issues.columns]) + r"""""" \\
\midrule
\endhead
""""""
                for _, row in self.quality_issues.iterrows():
                    formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
                    latex_content += "" & "".join(formatted_row) + r"" \\ \midrule"" + ""\n""
                latex_content += r""""""
\bottomrule
\end{longtable}
""""""
            else:
                latex_content += r""No quality issues detected.""

            latex_content += r""""""
\subsection*{Analysis}
\begin{longtable}{@{}"""""" + ""c"" * len(analysis_df.columns) + r""""""@{}}
\toprule
"""""" + "" & "".join([f""\\textbf{{{col}}}"" for col in analysis_df.columns]) + r"""""" \\
\midrule
\endhead
""""""
            for _, row in analysis_df.iterrows():
                formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
                latex_content += "" & "".join(formatted_row) + r"" \\ \midrule"" + ""\n""
            latex_content += r""""""
\bottomrule
\end{longtable}

\subsection*{Summary}
\begin{longtable}{@{}"""""" + ""c"" * len(summary_df.columns) + r""""""@{}}
\toprule
"""""" + "" & "".join([f""\\textbf{{{col}}}"" for col in summary_df.columns]) + r"""""" \\
\midrule
\endhead
""""""
            for _, row in summary_df.iterrows():
                formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
                latex_content += "" & "".join(formatted_row) + r"" \\ \midrule"" + ""\n""
            latex_content += r""""""
\bottomrule
\end{longtable}

\subsection*{Identified Layers}
""""""
            if self.layers is not None and not self.layers.empty:
                latex_content += r""""""
\begin{longtable}{@{}"""""" + ""c"" * len(self.layers.columns) + r""""""@{}}
\toprule
"""""" + "" & "".join([f""\\textbf{{{col}}}"" for col in self.layers.columns]) + r"""""" \\
\midrule
\endhead
""""""
                for _, row in self.layers.iterrows():
                    formatted_row = [f""{val:.2f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
                    latex_content += "" & "".join(formatted_row) + r"" \\ \midrule"" + ""\n""
                latex_content += r""""""
\bottomrule
\end{longtable}
""""""
            else:
                latex_content += r""No significant layer boundaries detected.""

            latex_content += r""""""
\subsection*{Correlation Analysis}
""""""
            if self.correlation_results is not None and not self.correlation_results.empty:
                latex_content += r""""""
\begin{longtable}{@{}"""""" + ""c"" * len(self.correlation_results.columns) + r""""""@{}}
\toprule
"""""" + "" & "".join([f""\\textbf{{{col}}}"" for col in self.correlation_results.columns]) + r"""""" \\
\midrule
\endhead
""""""
                for _, row in self.correlation_results.iterrows():
                    formatted_row = [f""{val:.3f}"" if isinstance(val, (int, float)) and pd.notna(val) else str(val) if pd.notna(val) else """" for val in row]
                    latex_content += "" & "".join(formatted_row) + r"" \\ \midrule"" + ""\n""
                latex_content += r""""""
\bottomrule
\end{longtable}
""""""
            else:
                latex_content += r""No correlation analysis data available.""

            latex_content += r""""""
\end{document}
""""""

            with open(tex_path, 'w', encoding='utf-8') as f:
                f.write(latex_content)

            os.system(f'latexmk -pdf -outdir=""{output_dir}"" ""{tex_path}""')

            if os.path.exists(pdf_path):
                ist = pytz.timezone('Asia/Kolkata')
                timestamp = datetime.now(ist).strftime(""%I:%M %p IST"")
                self.status_var.set(f""Exported detailed report to {pdf_path} at {timestamp}"")
                messagebox.showinfo(""Success"", f""Detailed report exported successfully to {pdf_path}."")
            else:
                raise Exception(""PDF compilation failed."")
        except Exception as e:
            messagebox.showerror(""Error"", f""Failed to export detailed report: {str(e)}"")

    def clear_tabs(self):
        for tree in [self.raw_tree, self.quality_tree, self.analysis_tree, self.summary_tree, self.layers_tree, self.correlation_tree, self.realtime_tree]:
            if tree:
                for item in tree.get_children():
                    tree.delete(item)
        if self.plot_canvas:
            self.plot_canvas.get_tk_widget().destroy()
            self.plot_canvas = None
        if self.current_fig:
            plt.close(self.current_fig)
            self.current_fig = None
        self.plot_label = ttk.Label(self.scrollable_frame, text=""Select a file to view visualizations."")
        self.plot_label.pack(fill=tk.BOTH, expand=True)
        if hasattr(self, 'correlation_canvas') and self.correlation_canvas:
            self.correlation_canvas.get_tk_widget().destroy()
            self.correlation_canvas = None
        if hasattr(self, 'correlation_fig') and self.correlation_fig:
            plt.close(self.correlation_fig)
            self.correlation_fig = None
        self.correlation_plot_label = ttk.Label(self.correlation_tree.master, text=""Upload SPT/Sonic Log file to view correlations."")
        self.correlation_plot_label.pack(fill=tk.BOTH, expand=True)
        if hasattr(self, 'realtime_canvas') and self.realtime_canvas:
            self.realtime_canvas.get_tk_widget().destroy()
            self.realtime_canvas = None
        if hasattr(self, 'realtime_fig') and self.realtime_fig:
            plt.close(self.realtime_fig)
            self.realtime_fig = None
        self.realtime_plot_label = ttk.Label(self.realtime_tree.master, text=""Start real-time acquisition to view data."")
        self.realtime_plot_label.pack(fill=tk.BOTH, expand=True)
        self.current_data = None
        self.raw_data = None
        self.quality_issues = None
        self.layers = None
        self.correlation_results = None
        self.realtime_data = None
        self.selected_rows = {}

if __name__ == ""__main__"":
    root = tk.Tk()
    app = SeismicWaveAnalyzer(root)
    root.mainloop()
"
VkzxQvbk,Module 6.5 Practice Question 2,gk231192,R,Tuesday 1st of July 2025 11:23:32 PM CDT,"# Load necessary library
library(ggplot2)
library(corrplot)
library(car)  # for vif() function

# mtcars is a built-in dataset in R. Let's see what it looks like.
head(mtcars)

# Calculate correlation matrix
corr_matrix <- cor(mtcars)

# Print correlation matrix
print(corr_matrix)

# Create a correlation plot using corrplot()
corrplot(corr_matrix, method = ""circle"")

# You can also create a correlation heatmap with ggplot2
corr_data <- reshape2::melt(corr_matrix)
names(corr_data) <- c(""Variable 1"", ""Variable 2"", ""Correlation"")
ggplot(corr_data, aes('Variable 1', 'Variable 2', fill = Correlation)) +
  geom_tile() +
  scale_fill_gradient2(low = ""blue"", high = ""red"", mid = ""white"",
                       midpoint = 0, limit = c(-1,1), space = ""Lab"",
                       name=""Pearson\nCorrelation"") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1,
                                   size = 12, hjust = 1)) +
  coord_fixed()

# Fit a multiple linear regression model to the data using ""lm"" function
# We will try to predict ""mpg"" (Miles/(US) gallon) using ""hp"" (Gross horsepower) and ""wt"" (Weight (1000 lbs))
model <- lm(mpg ~ hp + wt, data = mtcars)

# Print a summary of the model
summary(model)

# The summary includes coefficients for each predictor variable (Intercept, hp, and wt), and their significance levels.
# For instance, the p-value associated with the hp and wt variable tells us whether that variable is a significant predictor
# of mpg after accounting for the other variables in the model.

# Check multicollinearity using VIF
vif_values <- vif(model)

# Print VIF values
print(vif_values)

# If VIF values are high (>5 or >10 typically), then there's multicollinearity.
# You may want to remove one of the predictors or use regularization techniques to handle it.

# For instance, let's assume that the VIF for ""hp"" was high.
# We would fit the model without ""hp""
model2 <- lm(mpg ~ wt, data = mtcars)

# Checking the VIF for the new model
print(vif(model2))

#Does the above line of code return an error? Why does it return an error?

# We can generate predictions from our previous model
mtcars$predicted_mpg <- predict(model, mtcars)

# Create a scatter plot of actual vs predicted values
ggplot(mtcars, aes(x = mpg, y = predicted_mpg)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, color = ""red"", linetype = ""dashed"") +
  labs(title = ""Actual vs Predicted MPG"",
       x = ""Actual MPG"",
       y = ""Predicted MPG"") +
  theme_minimal()

# You can see the line of best fit in red, and the individual predictions as points.
# The closer these points are to the line, the more accurate our predictions are.

# To check the assumptions of the linear regression model, we can look at the residuals.
residuals <- residuals(model)

# Plot the residuals
plot(residuals, main=""Residuals of the Model"", ylab=""Residuals"", xlab=""Index"")
abline(h=0, col=""red"")

# In this plot, residuals are plotted against the index of observations.
# Ideally, we want to see residuals scattered randomly around zero, which would suggest that our model's assumptions are met."
Li8vczTf,ms hub,bastyav,HTML,Tuesday 1st of July 2025 11:12:01 PM CDT,https://serviceshub.microsoft.com/home
fD2CBaSL,feeding,Purwadi,PHP,Tuesday 1st of July 2025 09:13:24 PM CDT,"public function FeedTaskIdBpjs()
{
  date_default_timezone_set('Asia/Jakarta');

  $tglAntrianAwal = now()->format('Y-m-d');
  $tglAntrianAkhir = now()->format('Y-m-d');

  /* update status antrol ----------------------------------------------------- */
  $query = DB::connection('simak')->table('tbt_antrian_pendaftaran')->select([
    'tbt_antrian_pendaftaran.id',
    'tbt_antrian_pendaftaran.no_trans',
    'tbt_antrian_pendaftaran.tgl',
    'tbt_antrian_pendaftaran.tgl_panggil',
    'tbt_antrian_pendaftaran.wkt_panggil',
    'tbt_antrian_pendaftaran.loket',
    'tbt_antrian_pendaftaran.no_urut',
  ])->whereBetween('tgl', [$tglAntrianAwal, $tglAntrianAkhir])->whereNotNull('no_trans')->where('no_trans', '!=', '')->where('st_antrol', '0')->orderBy('tgl', 'asc');

  dump(count($query->get()));

  $query->chunk(100, function (Collection $rows) {
    foreach ($rows as $rowData) {
      $kodebooking = date('Ymd', strtotime($rowData->tgl)) . $rowData->loket . $rowData->no_urut;

      $output = $this->antrean->antreanPerKodeBooking($kodebooking);
      if ($output['metadata']['code'] == '200') {
        DB::connection('simak')->table('tbt_antrian_pendaftaran')->where('id', $rowData->id)->update([
          'st_antrol' => '1',
        ]);
      }
    }
    sleep(60);
  });

  /* update task id antrol ---------------------------------------------------- */
  $query = DB::connection('simak')->table('tbt_antrian_pendaftaran')->select([
    'tbt_antrian_pendaftaran.id',
    'tbt_antrian_pendaftaran.no_trans',
    'tbt_antrian_pendaftaran.tgl',
    'tbt_antrian_pendaftaran.tgl_panggil',
    'tbt_antrian_pendaftaran.wkt_panggil',
    'tbt_antrian_pendaftaran.loket',
    'tbt_antrian_pendaftaran.no_urut',
  ])->whereBetween('tgl', [$tglAntrianAwal, $tglAntrianAkhir])->whereNotNull('no_trans')->where('no_trans', '!=', '')->where('st_antrol', '!=', '0')->orderBy('tgl', 'asc');

  dump(count($query->get()));

  $query->chunk(100, function (Collection $rows) {
    foreach ($rows as $rowData) {
      $kodebooking = date('Ymd', strtotime($rowData->tgl)) . $rowData->loket . $rowData->no_urut;

      /* START: TASK ID 1 --------------------------------------------------------- */
      $tglPanggil = date_format(date_create($rowData->tgl_panggil . ' ' . $rowData->wkt_panggil), 'Y-m-d H:i:s');
      $start = strtotime(date('Y-m-d H:i:s', strtotime($tglPanggil . '-10 minutes')));
      $end = strtotime($tglPanggil);

      $newTimestamp = mt_rand($start, $end);
      $newTime = date('Y-m-d H:i:s', $newTimestamp);
      $timestamp = $newTimestamp * 1000;

      $this->FeedTaskIdBpjsProcess('1', $rowData, $kodebooking, $timestamp);
      /* END: TASK ID 1 ----------------------------------------------------------- */

      /* START: TASK ID 2 --------------------------------------------------------- */
      $timestamp = $end * 1000;
      $this->FeedTaskIdBpjsProcess('2', $rowData, $kodebooking, $timestamp);
      /* END: TASK ID 2 ----------------------------------------------------------- */

      $RwtjlnRecord = DB::connection('simak')->table('tbt_rawat_jalan')->where('no_trans', $rowData->no_trans)->first();
      if ($RwtjlnRecord) {
        /* START: TASK ID 3 --------------------------------------------------------- */
        $tglKunjungan = date_format(date_create($RwtjlnRecord->tgl_visit . ' ' . $RwtjlnRecord->wkt_visit), 'Y-m-d H:i:s');

        $startTimestamp = $timestamp;
        $endTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+3 minutes', $startTimestamp / 1000)));
        $tolTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+1 minutes', $startTimestamp / 1000)));

        $newTimestamp = mt_rand($tolTimestamp, $endTimestamp);
        $timestamp = $newTimestamp * 1000;

        $this->FeedTaskIdBpjsProcess('3', $rowData, $kodebooking, $timestamp);
        /* END: TASK ID 3 ----------------------------------------------------------- */

        /* START: TASK ID 4 --------------------------------------------------------- */
        $startTimestamp = $timestamp;
        $endTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+20 minutes', $startTimestamp / 1000)));
        $tolTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+10 minutes', $startTimestamp / 1000)));

        $newTimestamp = mt_rand($tolTimestamp, $endTimestamp);
        $timestamp = $newTimestamp * 1000;

        $this->FeedTaskIdBpjsProcess('4', $rowData, $kodebooking, $timestamp);
        /* END: TASK ID 4 ----------------------------------------------------------- */

        /* START: TASK ID 5 --------------------------------------------------------- */
        $startTimestamp = $timestamp;
        $endTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+20 minutes', $startTimestamp / 1000)));
        $tolTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+10 minutes', $startTimestamp / 1000)));

        $newTimestamp = mt_rand($tolTimestamp, $endTimestamp);
        $timestamp = $newTimestamp * 1000;

        $this->FeedTaskIdBpjsProcess('5', $rowData, $kodebooking, $timestamp);
        /* END: TASK ID 5 ----------------------------------------------------------- */

        /* START: TASK ID 6 --------------------------------------------------------- */
        $startTimestamp = $timestamp;
        $endTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+15 minutes', $startTimestamp / 1000)));
        $tolTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+5 minutes', $startTimestamp / 1000)));

        $newTimestamp = mt_rand($tolTimestamp, $endTimestamp);
        $timestamp = $newTimestamp * 1000;

        $this->FeedTaskIdBpjsProcess('6', $rowData, $kodebooking, $timestamp);
        /* END: TASK ID 6 ----------------------------------------------------------- */

        /* START: TASK ID 7 --------------------------------------------------------- */
        $startTimestamp = $timestamp;
        $endTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+20 minutes', $startTimestamp / 1000)));
        $tolTimestamp = strtotime(date('Y-m-d H:i:s', strtotime('+10 minutes', $startTimestamp / 1000)));

        $newTimestamp = mt_rand($tolTimestamp, $endTimestamp);
        $timestamp = $newTimestamp * 1000;

        $this->FeedTaskIdBpjsProcess('7', $rowData, $kodebooking, $timestamp);
        /* END: TASK ID 7 ----------------------------------------------------------- */
      }
    }
    sleep(60);
  });
}

public function FeedTaskIdBpjsProcess($taskid, $rowData, $kodebooking, $timestamp)
{
  $timestampnow = now()->timestamp * 1000;
  $execute = $timestamp < $timestampnow;

  if (!$execute) return;

  $AntreanOnlineRecord = DB::connection('simak')->table('tbt_antrean_online')->where('id_antrian', $rowData->id)->where('taskid', $taskid)->first();
  if (!$AntreanOnlineRecord) {
    $insert = DB::connection('simak')->table('tbt_antrean_online')->insertGetId([
      'tgl' => $rowData->tgl,
      'wkt' => now()->format('Y-m-d H:i:s'),
      'id_antrian' => $rowData->id,
      'taskid' => $taskid,
      'timestamp' => $timestamp,
      'st' => '0',
    ]);
    $AntreanOnlineRecord = DB::connection('simak')->table('tbt_antrean_online')->where('id', $insert)->first();
    $st = $AntreanOnlineRecord->st;
  } else {
    $st = $AntreanOnlineRecord->st;
  }

  dump('x ------------------------------------------------------------------------');
  dump(""status taskid {$taskid} kodebooking: {$kodebooking} | id: {$rowData->id} => "".($st == '0' ? 'belum' : 'sudah')."" submit"");
  dump('x ------------------------------------------------------------------------');

  if ($st != '1') {
    $dataUpdateAntrean = [
      'kodebooking' => $kodebooking,
      'taskid' => $taskid,
      'waktu' => $timestamp,
    ];
    $output = $this->antrean->updateWaktuAntrean($dataUpdateAntrean);

    DB::connection('simak')->table('api_response_antrean')->insert([
      'tgl' => $rowData->tgl,
      'waktu' => now()->format('H:i:s'),
      'source' => 'feeding',
      'id_antrian' => $rowData->id,
      'data_content' => addslashes(json_encode($dataUpdateAntrean)),
      'response_type' => '0',
      'response' => json_encode($output),
    ]);

    if ($output['metadata']['code'] == '200') {
      DB::connection('simak')->table('tbt_antrean_online')->where('id', $AntreanOnlineRecord->id)->update([
        'st' => '1',
      ]);
    }
  }
}






"
PWz8Kvxb,MTP Device Transfer,DePhoegon,PowerShell,Tuesday 1st of July 2025 08:59:30 PM CDT,"param(
    [Parameter(Mandatory)]
    [string]$PhoneName,

    [Parameter(Mandatory)]
    [string]$DestinationFolder
)

# Timestamped log file in root of destination
$timestamp = Get-Date -Format 'yyyy-MM-dd_HH-mm-ss'
$hashLog = Join-Path $DestinationFolder ""FileSizeMismatchLog_$timestamp.txt""
New-Item -ItemType File -Path $hashLog -Force | Out-Null

# Target folder names
$targetFolders = @(""DCIM"", ""Camera"", ""Pictures"", ""Screenshots"", ""Recordings"")

# Shell access
$shell   = New-Object -ComObject Shell.Application
$desktop = $shell.Namespace(0)
$mtp     = $desktop.Items() | Where-Object { $_.Name -eq $PhoneName }

if (-not $mtp) {
    Write-Error ""Could not find device '$PhoneName'.""
    exit 1
}

# Get storage roots: Internal + SD card etc.
$volumes = $mtp.GetFolder.Items() | Where-Object { $_.IsFolder }

if (-not $volumes) {
    Write-Error ""No accessible storage volumes found on device.""
    exit 1
}

function Test-FileSizeIntegrity {
    param (
        [object]$ShellItem,
        [string]$DestinationFilePath,
        [string]$RelativePath
    )

    if (-not (Test-Path $DestinationFilePath)) {
        Add-Content $hashLog ""`r`n❌ Missing file:`r`nDEST: $DestinationFilePath`r`nSRC Item: $RelativePath`r`n""
        return
    }

    $mtpSize   = [int64]$ShellItem.Size
    $localSize = (Get-Item $DestinationFilePath).Length

    $sizeDiff = [math]::Abs($mtpSize - $localSize)

    if ($sizeDiff -le 4096) {  # allow up to 4KB padding tolerance
        Write-Host (""✅ Size matched: $RelativePath → $mtpSize bytes (MTP) / $localSize bytes (Local)"")
    } else {
        $logEntry = @""
        ❌ Size mismatch:
        PATH:   $RelativePath
        MTP:    $mtpSize bytes
        LOCAL:  $localSize bytes
        FILE:   $DestinationFilePath

""@
        Add-Content $hashLog $logEntry
        Write-Warning ""⚠ Size mismatch for $RelativePath → $mtpSize bytes (MTP) / $localSize bytes (Local)""
    }
}

function Copy-MatchingFolders {
    param($folder, $currentDepth, $maxDepth, $outPath)

    foreach ($item in $folder.Items()) {
        if (-not $item.IsFolder) { continue }

        $name = $item.Name
        $targetPath = Join-Path $outPath $name

        if ($targetFolders -contains $name) {
            Write-Host ""📁 Copying entire folder '$name' to '$targetPath'""
            if (-not (Test-Path $targetPath)) {
                New-Item -ItemType Directory -Path $targetPath | Out-Null
            }

            $sourceItems = $item.GetFolder.Items()
            foreach ($subitem in $sourceItems) {
                $shell.Namespace($targetPath).CopyHere($subitem, 16)
                Start-Sleep -Milliseconds 100
            }

            # After all files are copied — run integrity checks once
            try {
                $shellItems = $item.GetFolder.Items() | Where-Object { -not $_.IsFolder }
                foreach ($child in $shellItems) {
                    $destFilePath = Join-Path $targetPath $child.Name
                    $relativePath = $child.Name
                    Test-FileSizeIntegrity -ShellItem $child -DestinationFilePath $destFilePath -RelativePath $relativePath
                }
            } catch {
                Write-Warning ""⚠ Could not perform post-copy integrity check for '$name'""
            }
            continue
        }


        if ($currentDepth -lt $maxDepth) {
            try {
                Copy-MatchingFolders -folder $item.GetFolder -currentDepth ($currentDepth + 1) -maxDepth $maxDepth -outPath $outPath
            } catch {
                Write-Warning ""⚠ Could not access subfolder '$name'""
            }
        }
    }
}

# Walk all volumes (e.g. Internal, SD card)
foreach ($volume in $volumes) {
    $volumeName = $volume.Name
    $volumeFolder = $volume.GetFolder
    $volumeOutput = Join-Path $DestinationFolder $volumeName

    Write-Host ""`n🔎 Scanning '$volumeName'...""
    if (-not (Test-Path $volumeOutput)) {
        New-Item -ItemType Directory -Path $volumeOutput | Out-Null
    }

    Copy-MatchingFolders -folder $volumeFolder -currentDepth 1 -maxDepth 2 -outPath $volumeOutput
}
if ((Get-Content $hashLog).Length -eq 0) {
    Remove-Item $hashLog -Force
    Write-Host ""`n✅ No file size mismatches detected. Log file removed.""
} else {
    Write-Host ""`n⚠ File size mismatches recorded in: $hashLog""
}
Write-Host ""`n✅ All matching folders copied from all available device storage to '$DestinationFolder'"""
iNPWrv2x,Mass Storage Moving,DePhoegon,PowerShell,Tuesday 1st of July 2025 08:57:16 PM CDT,"Param(
    [Parameter(Mandatory = $true)]
    [string]$Source,

    [Parameter(Mandatory = $true)]
    [string]$Destination,

    [int]$BufferSizeMB = 4,
    [string]$MoveFiles = ""false""
)
$shouldMove = $false
if ($MoveFiles.ToLower() -eq ""true"") {
    $shouldMove = $true
}

#HASH
function Get-FileHashSHA256 {
    param([string]$Path)
    return (Get-FileHash -Algorithm SHA256 -Path $Path).Hash
}

# Format: YYYY-MM-DD_HH-MM-SS for cross-platform friendliness
$timestamp = (Get-Date -Format ""yyyy-MM-dd_HH-mm-ss"")
$logFileName = ""HashMismatchLog_$timestamp.txt""
$logFilePath = Join-Path $Destination $logFileName

# Create an empty file to start with
New-Item -ItemType File -Path $logFilePath -Force | Out-Null

# Prepare buffer size in bytes
$bufferSize = $BufferSizeMB * 1MB

# Gather all files
$files      = Get-ChildItem -Path $Source -Recurse -File
$totalCount = $files.Count
if ($totalCount -eq 0) {
    Write-Host ""No files found under $Source""
    exit
}

$currentIndex = 0

foreach ($file in $files) {
    $currentIndex++

    $relative = $file.FullName.Substring($Source.Length).TrimStart('\')
    $destFull = Join-Path $Destination $relative
    $destDir  = Split-Path $destFull -Parent

    if (-not (Test-Path $destDir)) {
        New-Item -ItemType Directory -Path $destDir | Out-Null
    }

    $bytesCopied = 0
    $fileSize    = $file.Length
    $reader      = [System.IO.File]::OpenRead($file.FullName)
    $writer      = [System.IO.File]::Create($destFull)

    try {
        $buffer = New-Object byte[] ($BufferSizeMB * 1MB)

        while (($read = $reader.Read($buffer, 0, $buffer.Length)) -gt 0) {
            $writer.Write($buffer, 0, $read)
            $bytesCopied += $read

            $percentFile    = [math]::Round(($bytesCopied / $fileSize) * 100, 1)
            $percentOverall = [math]::Round(($currentIndex / $totalCount) * 100, 1)

            Write-Progress `
                -Activity ""Copying file $currentIndex of $totalCount"" `
                -Status ""$percentFile%% of $($file.Name)"" `
                -PercentComplete $percentOverall
        }
    }
    finally {
        $reader.Close()
        $writer.Close()
    }

    # Verify hash match
    $srcHash = Get-FileHashSHA256 -Path $file.FullName
    $dstHash = Get-FileHashSHA256 -Path $destFull

    if ($srcHash -eq $dstHash) {
        Write-Host ""✅ Verified: $relative""

        if ($shouldMove) {
            try {
                Remove-Item $file.FullName -Force
                Write-Host ""🗑️ Moved (source deleted): $relative""
            } catch {
                Write-Warning ""⚠️ Failed to delete source file: $relative""
            }
        } else {
            Write-Host ""Copied: $relative""
        }
    } else {
        Write-Warning ""❌ Hash mismatch for $relative — file NOT deleted!""
        $logEntry = @""
        SOURCE: $($file.FullName)
        DEST:   $destFull

""@
        Add-Content -Path $logFilePath -Value $logEntry
    }
}

# Finalize progress
Write-Progress -Activity ""Copy Complete"" -Completed
Write-Host ""All $totalCount files copied from `""$Source`"" to `""$Destination`"".""
if ((Get-Content $logFilePath).Length -eq 0) {
    Remove-Item $logFilePath -Force
    Write-Host ""✅ No hash mismatches detected — log file auto-deleted.""
} else {
    Write-Host ""⚠ Hash mismatches logged in: $logFilePath""
}
"
bb8paaUG,ff,vuseless,HTML,Tuesday 1st of July 2025 08:16:07 PM CDT,"onlinepoll.me/en/poll/vote/who-is-smarter-3

<!-- will delete soon -->"
Hykp5c9L,2025-07-01_stats.json,rdp_snitch,JSON,Tuesday 1st of July 2025 07:18:12 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 9468,
    ""194.165.16.166"": 6,
    ""111.170.152.113"": 3,
    ""205.210.31.206"": 9,
    ""109.160.70.30"": 6,
    ""147.185.132.141"": 9,
    ""128.22.147.233"": 3,
    ""68.183.179.179"": 3,
    ""45.79.168.172"": 3,
    ""205.210.31.199"": 9,
    ""152.32.180.98"": 3,
    ""194.165.16.164"": 6,
    ""147.185.132.90"": 9,
    ""45.227.254.151"": 6
  },
  ""asn"": {
    ""AS29222"": 9468,
    ""AS48721"": 12,
    ""AS151185"": 3,
    ""AS396982"": 36,
    ""AS44247"": 6,
    ""AS17511"": 3,
    ""AS14061"": 3,
    ""AS63949"": 3,
    ""AS135377"": 3,
    ""AS267784"": 6
  },
  ""isp"": {
    ""Infomaniak Network SA"": 9468,
    ""Flyservers S.A."": 18,
    ""China Telecom"": 3,
    ""Google LLC"": 36,
    ""Videosat09 GCN"": 6,
    ""OPTAGE Inc."": 3,
    ""DigitalOcean, LLC"": 3,
    ""Akamai Technologies, Inc."": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3
  },
  ""org"": {
    ""Infomaniak Network SA"": 9468,
    ""Flyservers S.A"": 12,
    ""Chinanet HB"": 3,
    ""Palo Alto Networks, Inc"": 36,
    ""Unknown"": 6,
    ""OPTAGE Inc."": 3,
    ""DigitalOcean, LLC"": 3,
    ""Linode"": 3,
    ""UCloud (HK) Holdings Group Limited"": 3,
    ""Xwin Universal LTD"": 6
  },
  ""regionName"": {
    ""Lucerne"": 9468,
    ""Kaunas"": 12,
    ""Hubei"": 3,
    ""California"": 36,
    ""Veliko Tarnovo"": 6,
    ""Kyoto"": 3,
    ""South West"": 3,
    ""New Jersey"": 3,
    ""Dubai"": 3,
    ""Vilnius"": 6
  },
  ""country"": {
    ""Switzerland"": 9468,
    ""Lithuania"": 18,
    ""China"": 3,
    ""United States"": 39,
    ""Bulgaria"": 6,
    ""Japan"": 3,
    ""Singapore"": 3,
    ""United Arab Emirates"": 3
  },
  ""account"": {
    ""hello"": 9483,
    ""Test"": 18,
    ""UZIJIcyxx"": 3,
    ""StaMhl"": 3,
    ""OBeGuv"": 3,
    ""vzGIRITet"": 3,
    ""uZlnhM"": 3,
    ""MncCfP"": 3,
    ""(empty)"": 3,
    ""iWwrKuqsq"": 3,
    ""ZDucwQ"": 3,
    ""RfuUxD"": 3,
    ""Administrator"": 3,
    ""vJfKFsAac"": 3,
    ""jqfagm"": 3,
    ""lOtxOq"": 3
  },
  ""keyboard"": {
    ""Unknown"": 9543
  },
  ""client_build"": {
    ""Unknown"": 9543
  },
  ""client_name"": {
    ""Unknown"": 9543
  },
  ""ip_type"": {
    ""mobile & hosting"": 9468,
    ""Unknown"": 30,
    ""hosting"": 45
  }
}"
qkbaHf9A,2025-07-01_stats.json,rdp_snitch,JSON,Tuesday 1st of July 2025 07:16:06 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 6312,
    ""194.165.16.166"": 4,
    ""111.170.152.113"": 2,
    ""205.210.31.206"": 6,
    ""109.160.70.30"": 4,
    ""147.185.132.141"": 6,
    ""128.22.147.233"": 2,
    ""68.183.179.179"": 2,
    ""45.79.168.172"": 2,
    ""205.210.31.199"": 6,
    ""152.32.180.98"": 2,
    ""194.165.16.164"": 4,
    ""147.185.132.90"": 6,
    ""45.227.254.151"": 4
  },
  ""asn"": {
    ""AS29222"": 6312,
    ""AS48721"": 8,
    ""AS151185"": 2,
    ""AS396982"": 24,
    ""AS44247"": 4,
    ""AS17511"": 2,
    ""AS14061"": 2,
    ""AS63949"": 2,
    ""AS135377"": 2,
    ""AS267784"": 4
  },
  ""isp"": {
    ""Infomaniak Network SA"": 6312,
    ""Flyservers S.A."": 12,
    ""China Telecom"": 2,
    ""Google LLC"": 24,
    ""Videosat09 GCN"": 4,
    ""OPTAGE Inc."": 2,
    ""DigitalOcean, LLC"": 2,
    ""Akamai Technologies, Inc."": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2
  },
  ""org"": {
    ""Infomaniak Network SA"": 6312,
    ""Flyservers S.A"": 8,
    ""Chinanet HB"": 2,
    ""Palo Alto Networks, Inc"": 24,
    ""Unknown"": 4,
    ""OPTAGE Inc."": 2,
    ""DigitalOcean, LLC"": 2,
    ""Linode"": 2,
    ""UCloud (HK) Holdings Group Limited"": 2,
    ""Xwin Universal LTD"": 4
  },
  ""regionName"": {
    ""Lucerne"": 6312,
    ""Kaunas"": 8,
    ""Hubei"": 2,
    ""California"": 24,
    ""Veliko Tarnovo"": 4,
    ""Kyoto"": 2,
    ""South West"": 2,
    ""New Jersey"": 2,
    ""Dubai"": 2,
    ""Vilnius"": 4
  },
  ""country"": {
    ""Switzerland"": 6312,
    ""Lithuania"": 12,
    ""China"": 2,
    ""United States"": 26,
    ""Bulgaria"": 4,
    ""Japan"": 2,
    ""Singapore"": 2,
    ""United Arab Emirates"": 2
  },
  ""account"": {
    ""hello"": 6322,
    ""Test"": 12,
    ""UZIJIcyxx"": 2,
    ""StaMhl"": 2,
    ""OBeGuv"": 2,
    ""vzGIRITet"": 2,
    ""uZlnhM"": 2,
    ""MncCfP"": 2,
    ""(empty)"": 2,
    ""iWwrKuqsq"": 2,
    ""ZDucwQ"": 2,
    ""RfuUxD"": 2,
    ""Administrator"": 2,
    ""vJfKFsAac"": 2,
    ""jqfagm"": 2,
    ""lOtxOq"": 2
  },
  ""keyboard"": {
    ""Unknown"": 6362
  },
  ""client_build"": {
    ""Unknown"": 6362
  },
  ""client_name"": {
    ""Unknown"": 6362
  },
  ""ip_type"": {
    ""mobile & hosting"": 6312,
    ""Unknown"": 20,
    ""hosting"": 30
  }
}"
egNwtBiV,2025-07-01_stats.json,rdp_snitch,JSON,Tuesday 1st of July 2025 07:15:09 PM CDT,"{
  ""ip"": {
    ""188.213.128.212"": 3156,
    ""194.165.16.166"": 2,
    ""111.170.152.113"": 1,
    ""205.210.31.206"": 3,
    ""109.160.70.30"": 2,
    ""147.185.132.141"": 3,
    ""128.22.147.233"": 1,
    ""68.183.179.179"": 1,
    ""45.79.168.172"": 1,
    ""205.210.31.199"": 3,
    ""152.32.180.98"": 1,
    ""194.165.16.164"": 2,
    ""147.185.132.90"": 3,
    ""45.227.254.151"": 2
  },
  ""asn"": {
    ""AS29222"": 3156,
    ""AS48721"": 4,
    ""AS151185"": 1,
    ""AS396982"": 12,
    ""AS44247"": 2,
    ""AS17511"": 1,
    ""AS14061"": 1,
    ""AS63949"": 1,
    ""AS135377"": 1,
    ""AS267784"": 2
  },
  ""isp"": {
    ""Infomaniak Network SA"": 3156,
    ""Flyservers S.A."": 6,
    ""China Telecom"": 1,
    ""Google LLC"": 12,
    ""Videosat09 GCN"": 2,
    ""OPTAGE Inc."": 1,
    ""DigitalOcean, LLC"": 1,
    ""Akamai Technologies, Inc."": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1
  },
  ""org"": {
    ""Infomaniak Network SA"": 3156,
    ""Flyservers S.A"": 4,
    ""Chinanet HB"": 1,
    ""Palo Alto Networks, Inc"": 12,
    ""Unknown"": 2,
    ""OPTAGE Inc."": 1,
    ""DigitalOcean, LLC"": 1,
    ""Linode"": 1,
    ""UCloud (HK) Holdings Group Limited"": 1,
    ""Xwin Universal LTD"": 2
  },
  ""regionName"": {
    ""Lucerne"": 3156,
    ""Kaunas"": 4,
    ""Hubei"": 1,
    ""California"": 12,
    ""Veliko Tarnovo"": 2,
    ""Kyoto"": 1,
    ""South West"": 1,
    ""New Jersey"": 1,
    ""Dubai"": 1,
    ""Vilnius"": 2
  },
  ""country"": {
    ""Switzerland"": 3156,
    ""Lithuania"": 6,
    ""China"": 1,
    ""United States"": 13,
    ""Bulgaria"": 2,
    ""Japan"": 1,
    ""Singapore"": 1,
    ""United Arab Emirates"": 1
  },
  ""account"": {
    ""hello"": 3161,
    ""Test"": 6,
    ""UZIJIcyxx"": 1,
    ""StaMhl"": 1,
    ""OBeGuv"": 1,
    ""vzGIRITet"": 1,
    ""uZlnhM"": 1,
    ""MncCfP"": 1,
    ""(empty)"": 1,
    ""iWwrKuqsq"": 1,
    ""ZDucwQ"": 1,
    ""RfuUxD"": 1,
    ""Administrator"": 1,
    ""vJfKFsAac"": 1,
    ""jqfagm"": 1,
    ""lOtxOq"": 1
  },
  ""keyboard"": {
    ""Unknown"": 3181
  },
  ""client_build"": {
    ""Unknown"": 3181
  },
  ""client_name"": {
    ""Unknown"": 3181
  },
  ""ip_type"": {
    ""mobile & hosting"": 3156,
    ""Unknown"": 10,
    ""hosting"": 15
  }
}"
W866rnTD,BWR - Changelog 01/07/25 🍁,SSilver,Diff,Tuesday 1st of July 2025 06:30:49 PM CDT,"Pain Train
- Removed speedboost granted on killing enemies with pickups in Player Destruction
This was not ideal when every player is a potential source of pick-ups to gain this speed up benefit from, and is against the spirit of the upside meant to be for defending intelligence.

Soda Popper
  Fixed bug where it would charge on self-damage
An oversight in modifying how HYPE was gained that came up with the Boston Basher.

Sun-On-A-Stick
  Replaced burning effect to be less obstructive and to linger less
Something that ought to hopefully be less smoky and intrusive.

Compression Blast
  Fixed bug where reflecting Dragon's Fury fireball dealt reduced damage
An oversight due to the modified flamethrower damage counting reflected fireballs as flame damage.

The Backburner
+ Removed critical hit multipier scaling with consecutive hits
The crit damage ramp-up is seen as not necessary now that Pyro's mobility was reduced significantly.

The Phlogistinator
+ Alt-Fire maxes-out Temperature against enemies on-hit
This change should make alt-fire a more useful tool without directly upping it's damage, now helping to setup maximized primary fire damage and additionally making MMMPH more potent when applied properly.

The Manmelter
+ Gain a stored crit on-kill against a burning target
- Removed gaining crits from extinguishing teammates
This weapon's ability to peform on it's own seemed to be at odds with it's ability to punish enemy pyros. Thusly it's ability to gain crits from extinguishing was removed. It can still provide a supportive benefit, however now additionally gains crit on-kills to make the user net positive on crits when spending flares against some targets.

Shields
  Shield Leap will now cancel charge prematurely while maintaining momentum
This change should make leap less punishing to use with charge to cross great distances, allowing for that repositioning while retaining some charge leftover for a faster recharge.

Loch-n-Load
+ Added: This weapons deploys 40% faster
+ Removed slower reload speed penalty
- Removed faster firing speed bonus
The faster firing speed seemed to be at odds with both the new upside and made spamming the weapon a little annoying while the demo is at a range that prevents reprisal. Reverting this change along with the reload speed should keep the weapon's theme of lower sustainability, while a new upside in deploy speed should help it keep up for the demo who needs to use their pills to quickly dispatch an enemy. It additionally should combo especially well with it's new stickybomb detonating upside.

Bazaar Bagain
  Fixed issue with building damage at max charge
Correcting a slight rounding issue.

Cloaking
- Removed faster base cloaking time
The speedier ability to enter cloak was too much of an overcorrection compared to just the decloaking time, as such was reverted. It made escapes with cloak far too guaranteed prior.

Red-Tape Recorder
+ Attached sappers emit Spy Radar while active
  Radar pings every 3 seconds with 2 second outlines
- 33% smaller radar range
- Radar cannot be activated manually
A suggested change to differentiate the sapper in a way that would fit it's more disruptive role. This change ought to further emphasize the quick removal of it while benefitting the spy with his quick escape to take advantage of said disruption, additionally benefitting the spy's team with the enemy's position."
0hCFk9LA,iframe - child page,Vojkovic,JavaScript,Tuesday 1st of July 2025 05:07:21 PM CDT,"<script>
  (function() {
    // If not in iframe, do nothing
    try {
      if (window.top === window.self) return;
    } catch(e) {}
    
    // Set to false to prevent dataLayer messages from being sent to parent
    var sendDataLayerMessages = true;
    
    // Set the prefix that will be used in the event name, and under which all
    // the dataLayer properties will be embedded
    var dataLayerMessagePrefix = 'iframe';
    
    // Set to parent origin (""https://www.domain.com"")
    var parentOrigin = 'https://www.mathnasium.com/';

    // Maximum time in milliseconds to poll the parent frame for ready signal
    var maxTime = 2000;
    
    // Don't touch anything that follows
    var pollInterval = 200;
    var parentReady = false;
    
    var postCallback = function(event) {
      if (event.origin !== parentOrigin) return;
      if (event.data.event !== 'clientId' && event.data !== 'parentReady') return;
      
      if (event.data.event === 'clientId') {
        window.dataLayer.push({
          event: 'clientId',
          clientId: event.data.clientId
        });
      }
      
      if (event.data === 'parentReady' && !parentReady) {
        window.clearInterval(poll);
        if (sendDataLayerMessages) startDataLayerMessageCollection();
        parentReady = true;
      }
    };
    
    var pollCallback = function() {
      // If maximum time is reached, stop polling
      maxTime -= pollInterval;
      if (maxTime <= 0) window.clearInterval(poll);
      // Send message to parent that iframe is ready to retrieve Client ID
      window.top.postMessage('childReady', parentOrigin);
    };
    
    var createMessage = function(obj) {
      if (!Array.isArray(obj) && typeof obj === 'object') {
        var flattenObj = JSON.parse(JSON.stringify(obj));
		var message = {};
        // Add metadata about the page into the message
        message[dataLayerMessagePrefix] = {
          pageData: {
            url: document.location.href,
            title: document.title
          }
        };
        for (var prop in flattenObj) {
          if (flattenObj.hasOwnProperty(prop) && prop !== 'gtm.uniqueEventId') {
            if (prop === 'event') {
              message.event = dataLayerMessagePrefix + '.' + flattenObj[prop];
            } else {
              message[dataLayerMessagePrefix][prop] = flattenObj[prop];
            }
          }
        }
        if (!message.event) message.event = dataLayerMessagePrefix + '.Message';
        return message;
      }
      return false;
    };
    
    var startDataLayerMessageCollection = function() {
      // Send the current dataLayer content to top frame, flatten the object
      window.dataLayer.forEach(function(obj) {
        var message = createMessage(obj);
        if (message) window.top.postMessage(message, parentOrigin);
      });
      // Create the push listener for future messages
      var oldPush = window.dataLayer.push;
      window.dataLayer.push = function() {
        var states = [].slice.call(arguments, 0);
        states.forEach(function(arg) {
          var message = createMessage(arg);
          if (message) window.top.postMessage(message, parentOrigin);
        });
        return oldPush.apply(window.dataLayer, states);
      };
    };
    
    // Start polling the parent page with ""childReady"" message
    var poll = window.setInterval(pollCallback, pollInterval);
    
    // Start listening for messages from the parent page
    window.addEventListener('message', postCallback);
  })();
</script>"
zRb8V7iz,Pbinfo #879,Hezov,C++,Tuesday 1st of July 2025 04:15:03 PM CDT,"#include <fstream>
#include <cstring>
using namespace std;
ifstream cin(""egalitati.in"");
ofstream cout(""egalitati.out"");
struct ecuatie{char var1[30], op, var2[30]; }v[27];
int sol[27];
char s[150];
int getNum(char s[])
{
    int sol = 0;
    for(int i = 0;s[i]!=0;i++)
        sol = sol * 10 + (s[i]-'0');
    return sol;
}
void solve(int poz)
{
    int nr1 = 0, nr2 = 0;
    if('a' <= v[poz].var1[0] && v[poz].var1[0] <= 'z')
    {
        solve(v[poz].var1[0] - 'a');
        nr1 = sol[v[poz].var1[0] - 'a'];
    }
    else nr1 = getNum(v[poz].var1);
    if(v[poz].op != 0)
    {
        if('a' <= v[poz].var2[0] && v[poz].var2[0] <= 'z')
        {
            solve(v[poz].var2[0] - 'a');
            nr2 = sol[v[poz].var2[0] - 'a'];
        }
        else nr2 = getNum(v[poz].var2);

        if(v[poz].op == '+')
        {
            sol[poz] = nr1 + nr2;
            return;
        }
        if(v[poz].op == '*')
        {
            sol[poz] = nr1 * nr2;
            return;
        }
    }
    else
    {
        sol[poz] = nr1;
        return;
    }

}
int main()
{
    for(int i = 0;i<26;i++)
        sol[i] = -1;
    int n;
    cin >> n ;
    cin.get();
    for(int i = 1;i <= n;i++)
    {
        cin.getline(s,100);
        int poz = s[0] - 'a', cnt = 1;
        for(int it = 1;s[it]!=0;it++)
        {
            if(s[it] == ' ' || s[it] == '=')
                continue;
            if(cnt == 1)
            {
                while(s[it] != ' ' && s[it] != '+' && s[it] != '*' && s[it]!=0)
                    v[poz].var1[strlen(v[poz].var1)] = s[it], it++;
                it--;
                cnt++;
            }
            else if(cnt == 2)
            {
                if((s[it] == '+' || s[it] == '*') && s[it]!=0)
                    v[poz].op = s[it], it++;
                it--;
                cnt++;
            }
            else if(cnt == 3)
            {
                while(s[it] != ' ' && s[it]!=0)
                    v[poz].var2[strlen(v[poz].var2)] = s[it], it++;
                it--;
                cnt++;
            }
        }
        for(int it = 0;it<100;it++)
            s[it] = 0;
    }
    for(int i = 0;i<26;i++)
        if(sol[i] == -1 && strlen(v[i].var1) != 0)
            solve(i);
    for(int i = 0;i<26;i++)
        if(sol[i] != -1)
            cout <<(char)(i+'a') << "" = "" << sol[i] << '\n';
    return 0;
}"
rHYq8UMv,Untitled,Ewgeniy,Lua,Tuesday 1st of July 2025 03:12:35 PM CDT,"-- tui.lua — Расширенная библиотека псевдографического интерфейса для OpenComputers

local component = require(""component"")
local term = require(""term"")
local event = require(""event"")
local gpu = component.gpu
local tui = {}

-- Цвета по умолчанию
tui.bgColor = 0x000000
tui.fgColor = 0xFFFFFF

function tui.setColors(fg, bg)
  gpu.setForeground(fg or tui.fgColor)
  gpu.setBackground(bg or tui.bgColor)
end

function tui.clear(bg)
  local w, h = gpu.getResolution()
  tui.setColors(nil, bg or tui.bgColor)
  gpu.fill(1, 1, w, h, "" "")
end

function tui.box(x, y, w, h, title)
  gpu.set(x, y, ""╔"" .. string.rep(""═"", w - 2) .. ""╗"")
  for i = 1, h - 2 do
    gpu.set(x, y + i, ""║"" .. string.rep("" "", w - 2) .. ""║"")
  end
  gpu.set(x, y + h - 1, ""╚"" .. string.rep(""═"", w - 2) .. ""╝"")
  if title then gpu.set(x + 2, y, title) end
end

function tui.centerText(y, text)
  local w = gpu.getResolution()
  local x = math.floor((w - #text) / 2) + 1
  gpu.set(x, y, text)
end

function tui.button(x, y, label, active)
  local pad = 2
  local text = string.rep("" "", pad) .. label .. string.rep("" "", pad)
  tui.setColors(active and 0x000000 or 0xFFFFFF, active and 0xFFFFFF or 0x444444)
  gpu.set(x, y, text)
  tui.setColors()
  return {x = x, y = y, w = #text, h = 1, label = label}
end

function tui.clicked(btn, x, y)
  return x >= btn.x and x < btn.x + btn.w and y == btn.y
end

function tui.input(x, y, w, default)
  tui.setColors(0xFFFFFF, 0x000000)
  gpu.fill(x, y, w, 1, "" "")
  gpu.set(x, y, default or """")
  term.setCursor(x, y)
  term.setCursorBlink(true)
  local input = io.read()
  term.setCursorBlink(false)
  return input
end

function tui.list(x, y, w, h, items, selected, keyControl)
  selected = math.max(1, math.min(selected or 1, #items))
  local offset = math.min(math.max(0, selected - math.floor(h / 2)), math.max(0, #items - h))

  local function drawList()
    for i = 1, h do
      local idx = offset + i
      local item = items[idx]
      if item then
        local isSelected = (idx == selected)
        tui.setColors(isSelected and 0x000000 or 0xFFFFFF, isSelected and 0xAAAAAA or 0x000000)
        gpu.fill(x, y + i - 1, w, 1, "" "")
        gpu.set(x + 1, y + i - 1, item:sub(1, w - 2))
      else
        gpu.fill(x, y + i - 1, w, 1, "" "")
      end
    end
    tui.setColors()
  end

  drawList()

  if keyControl then
    while true do
      local _, _, _, key = event.pull(""key_down"")
      if key == 200 then -- up
        if selected > 1 then selected = selected - 1 end
      elseif key == 208 then -- down
        if selected < #items then selected = selected + 1 end
      elseif key == 28 then -- enter
        break
      end
      offset = math.min(math.max(0, selected - math.floor(h / 2)), math.max(0, #items - h))
      drawList()
    end
  end

  return selected
end

function tui.toggle(x, y, label, state)
  local onText = ""Вкл""
  local offText = ""Выкл""
  local status = state and onText or offText
  local fullText = label .. "": ["" .. status .. ""]""
  local width = #label + 2 + math.max(#onText, #offText) + 2
  local bg = state and 0x00AA00 or 0xAA0000

  tui.setColors(0xFFFFFF, bg)
  gpu.fill(x, y, width, 1, "" "")
  gpu.set(x + 1, y, fullText)
  tui.setColors()

  return {x = x, y = y, w = width, h = 1, state = state}
end

function tui.checkbox(x, y, label, checked)
  local box = checked and ""[x]"" or ""[ ]""
  local text = box .. "" "" .. label
  tui.setColors(0xFFFFFF, 0x000000)
  gpu.set(x, y, text)
  return {x = x, y = y, w = #text, h = 1, checked = checked, label = label}
end

function tui.progressbar(x, y, w, percent)
  local fill = math.floor((w - 2) * percent)
  tui.setColors(0xFFFFFF, 0x222222)
  gpu.set(x, y, ""["")
  gpu.set(x + w - 1, y, ""]"")
  gpu.fill(x + 1, y, w - 2, 1, "" "")
  tui.setColors(0x00FF00, 0x00FF00)
  gpu.fill(x + 1, y, fill, 1, "" "")
  tui.setColors()
end

function tui.tabBar(x, y, tabs, current)
  local tabPositions = {}
  for i, name in ipairs(tabs) do
    local active = (i == current)
    tui.setColors(active and 0x000000 or 0xFFFFFF, active and 0xFFFFFF or 0x333333)
    gpu.set(x, y, "" "" .. name .. "" "")
    table.insert(tabPositions, {x = x, w = #name + 2})
    x = x + #name + 2
  end
  tui.setColors()
  return tabPositions
end

function tui.tabBarInteractive(x, y, tabs, current)
  local w = gpu.getResolution()

  local function draw()
    local cx = x
    for i, name in ipairs(tabs) do
      local active = (i == current)
      tui.setColors(active and 0x000000 or 0xFFFFFF, active and 0xFFFFFF or 0x333333)
      gpu.set(cx, y, "" "" .. name .. "" "")
      cx = cx + #name + 2
    end
    tui.setColors()
  end

  while true do
    draw()
    local _, _, _, key = event.pull(""key_down"")
    if key == 203 then -- влево
      current = current > 1 and current - 1 or #tabs
    elseif key == 205 then -- вправо
      current = current < #tabs and current + 1 or 1
    elseif key == 28 then -- Enter
      break
    end
  end

  return current
end

function tui.popup(x, y, w, h, lines)
  tui.setColors(0xFFFFFF, 0x0000AA)
  tui.box(x, y, w, h, "" "")
  for i, line in ipairs(lines) do
    if i + y < y + h - 1 then
      gpu.set(x + 1, y + i, line:sub(1, w - 2))
    end
  end
  tui.setColors()
end

function tui.toast(text, duration)
  local w, h = gpu.getResolution()
  local x = math.floor((w - #text) / 2)
  local y = h
  tui.setColors(0xFFFFFF, 0x880000)
  gpu.set(x, y, text)
  os.sleep(duration or 2)
  gpu.fill(x, y, #text, 1, "" "")
  tui.setColors()
end

-- Обработка переключения вкладок и списка по клавишам, без блокировки
-- state = { currentTab = 1, selectedItem = 1, tabs = {...}, items = {...} }
function tui.updateTabsAndList(state, key)
  local tabsCount = #state.tabs
  local listCount = #state.items

  if key == 203 then -- влево
    state.currentTab = (state.currentTab - 2) % tabsCount + 1
    if state.currentTab ~= 2 then
      state.selectedItem = 1
    end
  elseif key == 205 then -- вправо
    state.currentTab = state.currentTab % tabsCount + 1
    if state.currentTab ~= 2 then
      state.selectedItem = 1
    end
  elseif state.currentTab == 2 then
    if key == 200 then -- вверх
      if state.selectedItem > 1 then
        state.selectedItem = state.selectedItem - 1
      end
    elseif key == 208 then -- вниз
      if state.selectedItem < listCount then
        state.selectedItem = state.selectedItem + 1
      end
    end
  end

  return state
end

-- Отрисовка вкладок и списка в зависимости от состояния
function tui.drawTabsAndList(state, x, y, w, h)
  tui.tabBar(x, y, state.tabs, state.currentTab)
  if state.currentTab == 2 then
    tui.list(x, y + 2, w, h, state.items, state.selectedItem)
  else
    tui.clear()
    tui.centerText(y + 4, ""Вкладка: "" .. state.tabs[state.currentTab])
  end
end

function tui.confirmDialog(title, text)
  local w, h = 40, 7
  local sw, sh = gpu.getResolution()
  local x = math.floor((sw - w) / 2)
  local y = math.floor((sh - h) / 2)

  tui.box(x, y, w, h, title)
  tui.setColors(0xFFFFFF, 0x000000)
  gpu.set(x + 2, y + 2, text)

  local yesBtn = tui.button(x + 6, y + 4, ""Да"", true)
  local noBtn = tui.button(x + w - 10, y + 4, ""Нет"", false)

  while true do
    local _, _, cx, cy = event.pull(""touch"")
    if tui.clicked(yesBtn, cx, cy) then
      return true
    elseif tui.clicked(noBtn, cx, cy) then
      return false
    end
  end
end



return tui
"
vkPLRMPs,Dumps,LVL23HT,CSS,Tuesday 1st of July 2025 02:32:45 PM CDT,"pen testers
"
cekDwWJp,Untitled,Scripting_King,Lua,Tuesday 1st of July 2025 02:20:00 PM CDT,"--[[ 
	Queue System Script by lenovo768
	Discord: the_king_here
	Description: Manages player queueing using Zone module, UI elements, player limits,
	friend-only mode, camera control, and player teleportation after countdown.
--]]

--// Services
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local TweenService = game:GetService(""TweenService"")
local Lighting = game:GetService(""Lighting"")
local Players = game:GetService(""Players"")

--// Modules
local Zone = require(ReplicatedStorage:WaitForChild(""Module""):WaitForChild(""Zone""))

--// References
local QueuesFolder = workspace:WaitForChild(""Queqe""):WaitForChild(""QueueStand"")
local CameraEvent = ReplicatedStorage:WaitForChild(""Events""):WaitForChild(""CameraEvent"")
local Blur = Lighting:WaitForChild(""BlurForGui"")

--// Tween Info Constants
local showTweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
local hideTweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In)

--// Settings
local DefaultDuration = 45

--// Utility Functions

-- Teleports player to a specific position while keeping rotation
local function teleportPlayerOut(player: Player, position: Vector3)
	if not player.Character or not player.Character:FindFirstChild(""HumanoidRootPart"") then return end
	local root:BasePart = player.Character.HumanoidRootPart
	local rotation = root.CFrame.Rotation -- get's the current rotation
	player.Character:PivotTo(CFrame.new(position) * rotation) -- Teleports the player while keeping their rotation
end

-- Clears the player queue UI tiles
local function clearQueueUI(frame: Frame)
	for _, tile in pairs(frame.QueueTiles:GetChildren()) do
		if tile:IsA(""ImageButton"") then
			tile.ImageLabel.Image = """"
			tile.PlayerName.Value = """"
		end
	end
end

-- Main Logic Per Queue Stand
for _, stand in pairs(QueuesFolder:GetChildren()) do
	if not stand:IsA(""Model"") then continue end

	local zonePart = stand:WaitForChild(""Circle""):WaitForChild(""Zone"")
	if not zonePart then continue end

	local zone = Zone.new(zonePart)

	-- State Variables
	local owner = nil --refrence to the player who first enter in the zone
	local playerCount = 0 --counts the player that are currently in zone
	local duration = DefaultDuration -- Countdown duration
	local queuePlayers = {} --Keeps a live list of players who are currently standing inside the queue zone
	local kickedPlayers = {} --It temporarily mark players who were forcefully removed from the queue zone so the system knows not to handle them like normal leavers

	local connections = {} --keeps track of all active connections so that we can disconnect them later

	-- Updates the count label on Billboard GUI
	local function updateCountDisplay(frame, allowed)
		stand.PlayerCount.BillboardGui.TextLabel.Text = `${playerCount}/${allowed}` --shows player count and max limit in the UI so player can see it
	end

	-- Start countdown timer
	local function startCountdown(frame)
		task.spawn(function()
			while duration > 0 and owner do --if duration/time is greater then 0 and owner is still in the zone then keep countdowning
				task.wait(1)
				duration -= 1
				frame.AutoStartingText.TimeAmountText.Text = duration
			end

			if not owner then return end --it stopes the execution of this function immediately if the owner has left

			-- Timer ends, teleport all players
			for _, plr in ipairs(queuePlayers) do
				task.spawn(function()
					CameraEvent:FireClient(plr, ""Cutscene"", workspace.Cutscene.Rigs.CameraRig.CameraRoot, nil, plr == owner) --it handles the camera movement of the cutscene
					task.wait(1.5)
					teleportPlayerOut(plr, zonePart.CFrame.Position + Vector3.new(25, 0, 0)) --Ejects player from queue to allow others access
				end)
			end

			CameraEvent:FireClient(owner, ""PlayAnimation"", nil, frame) --it plays curscene animation
			CameraEvent:FireClient(owner, ""DecreaseFieldOfView"", nil, frame) --it decreases the camera FOV and hides the UI with animation
		end)
	end

	-- Handles friend filter toggle
	local function setupFriendToggle(frame)
		local connection = frame.IsOnlyFriendsAllowed.Changed:Connect(function()
			if not owner or not frame.IsOnlyFriendsAllowed.Value then return end --if owner has left or the isonlyfriendallowed button is turned off then it stops the execution of the function
			
			-- kicks the player out if he is not friend of owner (the person who entered first) on roblox
			for i = #queuePlayers, 1, -1 do
				local queuedPlayer = queuePlayers[i]
				if queuedPlayer == owner then continue end

				if not owner:IsFriendsWith(queuedPlayer.UserId) then
					teleportPlayerOut(queuedPlayer, zonePart.CFrame.Position + Vector3.new(25, 0, 0)) --Ejects player from queue to allow others access
					table.insert(kickedPlayers, queuedPlayer)
					table.remove(queuePlayers, i)
					playerCount -= 1
				end
			end

			updateCountDisplay(frame, frame.AllowedPlayers.Value) --updates the count UI to  show the current player count and max limit
			clearQueueUI(frame) --removes the kicked player's presence from the queue display frame
			
			--it updates queue frame that shows current players in the queue
			for index, plr in ipairs(queuePlayers) do
				local tile = frame.QueueTiles:FindFirstChild(""QueueTile"" .. index)
				if tile then
					tile.ImageLabel.Image = Players:GetUserThumbnailAsync(plr.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420) --it returns the close picture of player's face
					tile.PlayerName.Value = plr.Name
				end
			end
		end)

		table.insert(connections, connection) --adding the connection to connection table to keep record of it and to disconnect it when needed
	end

	-- Kick a player via kick button/player can kick any player he wants by clicking kick button on the queue frame
	local function setupKickButton(frame, targetPlayer)
		for _, tile in pairs(frame.QueueTiles:GetChildren()) do --loop through all childs of queueTitles which actually include all players that are in queue
			if tile:IsA(""ImageButton"") and tile.PlayerName.Value == targetPlayer.Name then
				local button = tile:FindFirstChild(""KickButton"") --button to kick player out of the zone
				if button then
					local connection = button.MouseButton1Click:Connect(function()
						if targetPlayer == owner then return end --if owner tries to kick himself then it will stop execution and do nothing

						teleportPlayerOut(targetPlayer, zonePart.CFrame.Position + Vector3.new(25, 0, 0))--Ejects player from queue to allow others access
						table.insert(kickedPlayers, targetPlayer) --temporarily add player to kick table to keep record of it

						local index = table.find(queuePlayers, targetPlayer)
						if index then
							table.remove(queuePlayers, index)
							playerCount -= 1
						end

						updateCountDisplay(frame, frame.AllowedPlayers.Value) --updates the count UI to  show the current player count and max limit
						clearQueueUI(frame) --removes the kicked player's presence from the queue display frame
						
						--it updates queue frame that shows current players in the queue
						for idx, plr in ipairs(queuePlayers) do
							local t = frame.QueueTiles:FindFirstChild(""QueueTile"" .. idx)
							if t then
								t.ImageLabel.Image = Players:GetUserThumbnailAsync(plr.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420) --it returns the close shot of player's face
								t.PlayerName.Value = plr.Name
							end
						end
					end)
					table.insert(connections, connection)
				end
			end
		end
	end

	-- Setup Start and Cancel buttons for owner
	local function setupOwnerButtons(frame)
		local cancelConnection = frame.SelectionUI.CancelButton.MouseButton1Click:Connect(function()
			CameraEvent:FireClient(owner, ""DecreaseFieldOfView"", nil, frame) --it decreases the camera FOV and hides the UI with animation
		end)
		table.insert(connections, cancelConnection)

		local startConnection = frame.StartButton.MouseButton1Click:Connect(function() --if owner clicks start button then it will stop the countdown loop and start the game instantly
			duration = 0
		end)
		table.insert(connections, startConnection)
	end

	-- Assign a new owner and begin queue logic
	local function initializeOwner(player)
		owner = player --player who joined first get assigned as a owner
		playerCount = 1 --increases playercount to 1 
		duration = DefaultDuration --set the start time duration to default 45 seconds
		queuePlayers = {player} --it adds the owner to the queue player, since this table holds all player that are in zone
		kickedPlayers = {}

		local frame = player:WaitForChild(""PlayerGui""):WaitForChild(""SSimUI""):WaitForChild(""Frame"") --refrence to the frame that gives different options to the owner
		frame.Position = UDim2.new(0.5, 0, 1.5, 0) --setting the position of the frame to the bottom down of the screen
		frame.Visible = true --make frame visible
		frame.AutoStartingText.TimeAmountText.Text = duration --updating frame text to show current duration

		CameraEvent:FireClient(owner, ""IncreaseFieldOfView"", nil, frame) --function to animate frame position, camera FOV and blur size

		local tile = frame.QueueTiles:FindFirstChild(""QueueTile1"")
		if tile then
			tile.ImageLabel.Image = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420) --it returns the close shot of player's face
			tile.PlayerName.Value = player.Name
		end
		
		--calling upper functions to make the UI buttons works
		setupFriendToggle(frame)
		setupOwnerButtons(frame)
		startCountdown(frame)
	end

	-- Player enters the zone
	zone.playerEntered:Connect(function(player) --it runs whenever any player enters in the region of the zone
		if table.find(queuePlayers, player) then return end
		table.insert(queuePlayers, player) --insert players in queuePlayers, since it holds record of all players that are in zone

		local playerGui = player:WaitForChild(""PlayerGui"")
		local frame = playerGui:WaitForChild(""SSimUI""):WaitForChild(""Frame"")

		if not owner then
			initializeOwner(player) --defines owner if not defined yet
			return
		end

		local allowed = frame.AllowedPlayers.Value
		if playerCount >= allowed then --checks if the max player count is reached, if it is then it kicks the player out
			teleportPlayerOut(player, zonePart.CFrame.Position + Vector3.new(25, 0, 0))
			table.insert(kickedPlayers, player)
			return
		end

		if frame.IsOnlyFriendsAllowed.Value and not owner:IsFriendsWith(player.UserId) then -- it kicks the player out if IsOnlyFriendAllowed setting is turned ON but the player is not a friend of owner
			teleportPlayerOut(player, zonePart.CFrame.Position + Vector3.new(25, 0, 0))
			table.insert(kickedPlayers, player)
			return
		end

		playerCount += 1 --updates the playercount
		updateCountDisplay(frame, allowed) --updates the UI that shows the current player count

		local tile = frame.QueueTiles:FindFirstChild(""QueueTile"" .. playerCount)
		if tile then
			tile.ImageLabel.Image = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size420x420)
			tile.PlayerName.Value = player.Name
		end

		setupKickButton(frame, player)
	end)

	-- Player leaves the zone
	zone.playerExited:Connect(function(player) --it runs whenever any player leaves the region of the zone
		local index = table.find(queuePlayers, player)
		if index then
			table.remove(queuePlayers, index) --it removes the player from the queuePlayers table since player is not in zone anymore
			playerCount -= 1
		end

		local kickIndex = table.find(kickedPlayers, player) 
		if kickIndex then
			table.remove(kickedPlayers, kickIndex) --if player was kicked from the zone that it removes the player from the zone without decreasing playerCount
		end

		if player == owner then --if player who exited the zone is the owner then it disconnect all connections and closes the frame
			local frame = player:WaitForChild(""PlayerGui""):WaitForChild(""SSimUI""):WaitForChild(""Frame"")
			CameraEvent:FireClient(owner, ""DecreaseFieldOfView"", nil, frame)
			frame.Visible = false

			for _, conn in ipairs(connections) do --Disconnecting all connections
				if conn and typeof(conn) == ""RBXScriptConnection"" then
					conn:Disconnect()
				end
			end
			table.clear(connections) --clears the connections table, since all connections are disconnected so we don't need to track them anymore

			clearQueueUI(frame) --it cleared the frame that shows the presence of players in the queue

			for _, plr in ipairs(queuePlayers) do
				teleportPlayerOut(plr, zonePart.CFrame.Position + Vector3.new(25, 0, 0)) --Ejects player from queue to allow others access
			end
			table.clear(queuePlayers) --it clears the queuePlayers table, since the queue is over

			owner = nil --removes the player refrence from the variable owner, since the player has left the queue
			playerCount = 0 --resets the player count
			duration = DefaultDuration --resets the queue duration
		else
			if owner and owner:FindFirstChild(""PlayerGui"") then -- if the player who left is not a owner and the owner still exist in queue then it clears only that player existance from the queueTitles frame
				local frame = owner.PlayerGui:FindFirstChild(""SSimUI"") and owner.PlayerGui.SSimUI:FindFirstChild(""Frame"")
				if frame then
					for _, tile in pairs(frame.QueueTiles:GetChildren()) do
						if tile:IsA(""ImageButton"") and tile.PlayerName.Value == player.Name then
							tile.ImageLabel.Image = """"
							tile.PlayerName.Value = """"
						end
					end
					updateCountDisplay(frame, frame.AllowedPlayers.Value) --updates the count UI to  show the current player count and max limit
				end
			end
		end
	end)
end
"
YMnk2pma,excellent 4 figury OK rychle korektni,max2201111,Python,Tuesday 1st of July 2025 01:54:53 PM CDT,"import chess
import math
import time
from copy import deepcopy

def knight_moves():
    return [(2, 1), (1, 2), (-1, 2), (-2, 1),
            (-2, -1), (-1, -2), (1, -2), (2, -1)]

def rook_moves():
    moves = []
    for i in range(1, 8):
        moves.extend([(i, 0), (-i, 0), (0, i), (0, -i)])
    return moves

def bishop_moves():
    moves = []
    for i in range(1, 8):
        moves.extend([(i, i), (i, -i), (-i, i), (-i, -i)])
    return moves

def queen_moves():
    return rook_moves() + bishop_moves()

def amazon_moves():
    return queen_moves() + knight_moves()

def cyril_moves():
    return rook_moves() + knight_moves()

def eve_moves():
    return bishop_moves() + knight_moves()

def print_board(board):
    print(""  a b c d e f g h"")
    for i in range(8):
        print(f""{8-i} "", end="""")
        for j in range(8):
            print(f""{board[i][j]} "", end="""")
        print(f""{8-i}"")
    print(""  a b c d e f g h"")
    print()

def generate_moves(board, piece, row, col):
    size = 8
    moves = []
    
    if piece.upper() == 'A':
        directions = amazon_moves()
    elif piece.upper() == 'C':
        directions = cyril_moves()
    elif piece.upper() == 'E':
        directions = eve_moves()
    elif piece.upper() == 'K':
        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
    else:
        return moves
    
    for dx, dy in directions:
        new_row, new_col = row + dx, col + dy
        
        if 0 <= new_row < size and 0 <= new_col < size:
            target = board[new_row][new_col]
            
            if piece.upper() == 'K' and target.upper() == 'K':
                continue
            
            if piece.upper() in ['A', 'C', 'E'] and (dx, dy) not in knight_moves():
                blocked = False
                step_x = 1 if dx > 0 else (-1 if dx < 0 else 0)
                step_y = 1 if dy > 0 else (-1 if dy < 0 else 0)
                
                check_x, check_y = row + step_x, col + step_y
                while (check_x, check_y) != (new_row, new_col):
                    if board[check_x][check_y] != '.':
                        blocked = True
                        break
                    check_x += step_x
                    check_y += step_y
                
                if blocked:
                    continue
            
            if target == '.':
                moves.append((new_row, new_col))
            elif target.islower() != piece.islower():
                moves.append((new_row, new_col))
    
    return moves

def board_to_fen(board):
    fen_rows = []
    for row in board:
        fen_row = """"
        empty_count = 0
        for cell in row:
            if cell == '.':
                empty_count += 1
            else:
                if empty_count > 0:
                    fen_row += str(empty_count)
                    empty_count = 0
                fen_row += cell
        if empty_count > 0:
            fen_row += str(empty_count)
        fen_rows.append(fen_row)
    
    return ""/"".join(fen_rows) + "" w - - 0 1""

def fen_to_board(fen):
    fen_board = fen.split()[0]
    board = []
    
    for row_fen in fen_board.split('/'):
        row = []
        for char in row_fen:
            if char.isdigit():
                row.extend(['.'] * int(char))
            else:
                row.append(char)
        board.append(row)
    
    return board

def is_under_attack(board, row, col, by_white):
    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece == '.' or piece.isupper() != by_white:
                continue
                
            if piece.upper() in ['A', 'C', 'E']:
                moves = generate_moves(board, piece, i, j)
                if (row, col) in moves:
                    return True
            elif piece.upper() == 'K':
                if abs(i - row) <= 1 and abs(j - col) <= 1 and (i != row or j != col):
                    return True
                    
    return False

def get_all_legal_moves(board, white_to_move):
    legal_moves = []
    
    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece == '.' or piece.isupper() != white_to_move:
                continue
                
            if piece.upper() in ['A', 'C', 'E', 'K']:
                possible_moves = generate_moves(board, piece, i, j)
                for new_row, new_col in possible_moves:
                    test_board = deepcopy(board)
                    test_board[new_row][new_col] = piece
                    test_board[i][j] = '.'
                    
                    king_pos = None
                    for ki in range(8):
                        for kj in range(8):
                            if test_board[ki][kj] == ('K' if white_to_move else 'k'):
                                king_pos = (ki, kj)
                                break
                        if king_pos:
                            break
                    
                    if king_pos and not is_under_attack(test_board, king_pos[0], king_pos[1], not white_to_move):
                        legal_moves.append(((i, j), (new_row, new_col)))
    
    return legal_moves

def is_check_or_mate(fen, white_to_move=True):
    try:
        board = fen_to_board(fen)
        
        white_king = None
        black_king = None
        
        for i in range(8):
            for j in range(8):
                if board[i][j] == 'K':
                    white_king = (i, j)
                elif board[i][j] == 'k':
                    black_king = (i, j)
        
        if not white_king or not black_king:
            return {
                'checkmate': False,
                'stalemate': False,
                'insufficient_material': False,
                'seventyfive_moves': False,
                'check': False,
                'winner': None
            }
        
        current_king = white_king if white_to_move else black_king
        in_check = is_under_attack(board, current_king[0], current_king[1], not white_to_move)
        legal_moves = get_all_legal_moves(board, white_to_move)
        
        if not legal_moves:
            if in_check:
                winner = 'black' if white_to_move else 'white'
                return {
                    'checkmate': True,
                    'stalemate': False,
                    'insufficient_material': False,
                    'seventyfive_moves': False,
                    'check': True,
                    'winner': winner
                }
            else:
                return {
                    'checkmate': False,
                    'stalemate': True,
                    'insufficient_material': False,
                    'seventyfive_moves': False,
                    'check': False,
                    'winner': None
                }
        
        return {
            'checkmate': False,
            'stalemate': False,
            'insufficient_material': False,
            'seventyfive_moves': False,
            'check': in_check,
            'winner': None
        }
        
    except Exception:
        return {
            'checkmate': False,
            'stalemate': False,
            'insufficient_material': False,
            'seventyfive_moves': False,
            'check': False,
            'winner': None
        }

def create_successors(index, state, all_states, seen_fens):
    board = state['board']
    new_states = []
    new_outputs = []
    
    current_player_white = index % 2 == 0
    legal_moves = get_all_legal_moves(board, current_player_white)
    
    for ((from_row, from_col), (to_row, to_col)) in legal_moves:
        piece = board[from_row][from_col]
        
        new_board = deepcopy(board)
        new_board[to_row][to_col] = piece
        new_board[from_row][from_col] = '.'
        
        fen = board_to_fen(new_board)
        
        if fen not in seen_fens:
            seen_fens.add(fen)
            new_state = {
                'radek': len(all_states),
                'N': [],
                'P': [index],
                'FEN': fen,
                'board': new_board,
                'to_mate': None,
                'to_end': None
            }
            all_states.append(new_state)
            new_states.append(new_state['radek'])
            new_outputs.append(f""{new_state['radek']}({state['radek']})"")
        else:
            for s in all_states:
                if s['FEN'] == fen:
                    if index not in s['P']:
                        s['P'].append(index)
                    new_states.append(s['radek'])
                    break
    
    if new_outputs:
        max_radek = max(new_states) if new_states else index
        print(f""\rDepth={index} max={max_radek} : {' '.join(new_outputs[:5])}"" + 
              (f"" ...({len(new_outputs)-5} more)"" if len(new_outputs) > 5 else """"), 
              end='', flush=True)
    
    return new_states

def create_initial_board():
    board = [['.' for _ in range(8)] for _ in range(8)]
    board[4][0] = 'A'  # Bílá amazonka na a1
    board[5][4] = 'c'
    board[6][5] = 'K'  # Bílý král na h1  
    board[5][6] = 'k'  # Černý král na e8
    return board

def propagate_values(L):
    print(""\nPropaguji hodnoty s minimax logikou..."")
    start_time = time.time()
    round_num = 0
    max_rounds = 100
    
    # Nejdřív označ stavy bez následníků jako koncové
    for state in L:
        if not state['N'] and state['to_end'] is None:
            state['to_mate'] = math.inf
            state['to_end'] = 0
    
    while round_num < max_rounds:
        round_num += 1
        changed = False
        
        # Projdi všechny stavy zpětně
        for state in reversed(L):
            if state['to_mate'] is None or state['to_end'] is None:
                if state['N']:  # Má následníky
                    # Získej hodnoty následníků
                    succ_mate_vals = []
                    succ_end_vals = []
                    
                    for idx in state['N']:
                        if idx < len(L):
                            succ = L[idx]
                            if succ['to_mate'] is not None:
                                succ_mate_vals.append(succ['to_mate'])
                            if succ['to_end'] is not None:
                                succ_end_vals.append(succ['to_end'])
                    
                    # KLÍČOVÁ OPRAVA: Minimax logika podle toho, kdo je na tahu
                    if succ_mate_vals and state['to_mate'] is None:
                        white_to_move = state['radek'] % 2 == 0
                        
                        if white_to_move:  # Bílý na tahu - hledá minimum (nejrychlejší mat)
                            if all(val == math.inf for val in succ_mate_vals):
                                new_mate_val = math.inf
                            else:
                                finite_vals = [val for val in succ_mate_vals if val != math.inf]
                                if finite_vals:
                                    new_mate_val = 1 + min(finite_vals)
                                else:
                                    new_mate_val = math.inf
                        else:  # Černý na tahu - hledá maximum (nejpomalejší mat)
                            finite_vals = [val for val in succ_mate_vals if val != math.inf]
                            if finite_vals:
                                new_mate_val = 1 + max(finite_vals)  # Maximum z konečných hodnot
                            else:
                                new_mate_val = math.inf  # Jen pokud jsou všechny inf
                        
                        state['to_mate'] = new_mate_val
                        changed = True
                    
                    # to_end vždy minimum (nejkratší cesta k jakémukoli konci)
                    if succ_end_vals and state['to_end'] is None:
                        new_end_val = 1 + min(succ_end_vals)
                        state['to_end'] = new_end_val
                        changed = True
        
        elapsed = int(time.time() - start_time)
        hh, rem = divmod(elapsed, 3600)
        mm, ss = divmod(rem, 60)
        states_with_mate = sum(1 for s in L if s['to_mate'] is not None)
        states_with_end = sum(1 for s in L if s['to_end'] is not None)
        print(f""\rPrůchod {round_num}: čas {hh:02d}h{mm:02d}m{ss:02d}s, ""
              f""změněno: {changed}, stavů s to_mate: {states_with_mate}/{len(L)}, ""
              f""stavů s to_end: {states_with_end}/{len(L)}"", end='', flush=True)
        
        if not changed:
            print(""\nŽádné další změny - ukončuji propagaci"")
            break
        
        if all(s['to_mate'] is not None and s['to_end'] is not None for s in L):
            print(f""\nVšechny stavy vyhodnocené po {round_num} průchodech"")
            break
    
    print()

def find_optimal_path(L):
    print(""\n--- Hledání optimální cesty k matu ---"")
    
    if L[0]['to_mate'] is None or L[0]['to_mate'] == math.inf:
        print(f""L[0] nemá cestu k matu (to_mate = {L[0]['to_mate']})"")
        return []
    
    path = []
    current_index = 0
    move_number = 0
    
    print(f""L[0] má to_mate = {L[0]['to_mate']}, hledám cestu..."")
    
    while True:
        current_state = L[current_index]
        path.append(current_index)
        
        print(f""\nTah {move_number}: L[{current_index}]"")
        print(f""to_mate: {current_state['to_mate']}, to_end: {current_state['to_end']}"")
        print_board(current_state['board'])
        
        if current_state['to_mate'] == 0:
            print(""Mat dosažen!"")
            break
        
        if not current_state['N']:
            print(""Žádní následníci - konec"")
            break
        
        # OPRAVENÁ LOGIKA: Najdi následníka s hodnotou o 1 menší
        target_value = current_state['to_mate'] - 1
        best_successor = None
        
        print(f""Hledám následníka s to_mate = {target_value}"")
        
        for succ_idx in current_state['N']:
            succ_state = L[succ_idx]
            print(f""  L[{succ_idx}]: to_mate = {succ_state['to_mate']}"")
            
            if succ_state['to_mate'] == target_value:
                best_successor = succ_idx
                break
        
        if best_successor is None:
            print(""CHYBA: Nelze najít následníka s očekávanou hodnotou!"")
            print(""Dostupní následníci:"")
            for succ_idx in current_state['N']:
                succ_state = L[succ_idx]
                print(f""  L[{succ_idx}]: to_mate = {succ_state['to_mate']}"")
            break
        
        player = ""bílý"" if move_number % 2 == 0 else ""černý""
        print(f""{player} vybírá L[{best_successor}] s to_mate={target_value}"")
        
        current_index = best_successor
        move_number += 1
        
        if move_number > 20:
            print(""Příliš mnoho tahů - přerušuji"")
            break
    
    return path

def main():
    print(""=== Chess Endgame Analyzer ==="")
    print(""Figury: A=Amazonka(Q+N), C=Cyril(R+N), E=Eve(B+N), K=Král"")
    print(""Mat = král v šachu + žádné legální tahy\n"")
    
    board = create_initial_board()
    start_fen = board_to_fen(board)
    
    print(""Počáteční pozice:"")
    print_board(board)
    print(f""Start FEN: {start_fen}\n"")
    
    L = []
    seen_fens = set()
    seen_fens.add(start_fen)
    
    L.append({
        'radek': 0,
        'N': [],
        'P': [],
        'FEN': start_fen,
        'board': board,
        'to_mate': None,
        'to_end': None
    })
    
    print(""Generuji následníky..."")
    start_generation = time.time()
    
    i = 0
    max_states = 3000
    
    while i < len(L) and len(L) < max_states:
        L[i]['N'] = create_successors(i, L[i], L, seen_fens)
        i += 1
        
        if i % 200 == 0:
            elapsed = time.time() - start_generation
            print(f""\nZpracováno {i} stavů, celkem {len(L)} stavů, čas: {elapsed:.1f}s"")
    
    generation_time = time.time() - start_generation
    print(f""\nVygenerováno {len(L)} stavů za {generation_time:.1f}s"")
    
    print(""\nHledám koncové stavy..."")
    end_states_found = 0
    
    for state in L:
        white_to_move = state['radek'] % 2 == 0
        check_result = is_check_or_mate(state['FEN'], white_to_move)
        
        if check_result['checkmate']:
            state['to_mate'] = 0
            state['to_end'] = 0
            end_states_found += 1
            winner = check_result.get('winner', 'neznámý')
            player_on_move = ""bílý"" if white_to_move else ""černý""
            print(f""Mat nalezen ve stavu L[{state['radek']}] - {player_on_move} je matován, vyhrál {winner}"")
        elif (check_result['stalemate'] or 
              check_result['insufficient_material'] or 
              check_result['seventyfive_moves']):
            state['to_mate'] = math.inf
            state['to_end'] = 0
            end_states_found += 1
    
    print(f""Nalezeno {end_states_found} koncových stavů"")
    
    propagate_values(L)
    
    print(f""\n=== VÝSLEDKY ==="")
    print(f""Počáteční stav L[0]:"")
    print(f""  to_mate: {L[0]['to_mate']}"")
    print(f""  to_end: {L[0]['to_end']}"")
    print(f""  Počet následníků: {len(L[0]['N'])}"")
    
    path = find_optimal_path(L)
    if path:
        print(f""\nOptimální cesta: {' -> '.join(map(str, path))}"")
    
    if len(L) > 22:
        print(f""\nL[22] = {L[22]}"")

if __name__ == ""__main__"":
    main()"
Tb0bX1bg,je to korektni? petr,max2201111,Python,Tuesday 1st of July 2025 01:50:29 PM CDT,"=== Chess Endgame Analyzer ===
Figury: A=Amazonka(Q+N), C=Cyril(R+N), E=Eve(B+N), K=Král
Mat = král v šachu + žádné legální tahy

Počáteční pozice:
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . . 5
4 A . . . . . . . 4
3 . . . . c . k . 3
2 . . . . . K . . 2
1 . . . . . . . . 1
  a b c d e f g h

Start FEN: 8/8/8/8/A7/4c1k1/5K2/8 w - - 0 1

Generuji následníky...
Depth=199 max=1978 : 1969(199) 1970(199) 1971(199) 1972(199) 1973(199) ...(5 more))
Zpracováno 200 stavů, celkem 1979 stavů, čas: 0.7s
Depth=354 max=3000 : 2995(354) 2996(354) 2997(354) 2998(354) 2999(354) ...(1 more))
Vygenerováno 3001 stavů za 1.2s

Hledám koncové stavy...
Mat nalezen ve stavu L[108] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[168] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[212] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[227] - černý je matován, vyhrál white
Mat nalezen ve stavu L[278] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[288] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[312] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[338] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[364] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[372] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[663] - černý je matován, vyhrál white
Mat nalezen ve stavu L[669] - černý je matován, vyhrál white
Mat nalezen ve stavu L[671] - černý je matován, vyhrál white
Mat nalezen ve stavu L[785] - černý je matován, vyhrál white
Mat nalezen ve stavu L[787] - černý je matován, vyhrál white
Mat nalezen ve stavu L[815] - černý je matován, vyhrál white
Mat nalezen ve stavu L[899] - černý je matován, vyhrál white
Mat nalezen ve stavu L[923] - černý je matován, vyhrál white
Mat nalezen ve stavu L[925] - černý je matován, vyhrál white
Mat nalezen ve stavu L[983] - černý je matován, vyhrál white
Mat nalezen ve stavu L[985] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1090] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[1106] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[1163] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1165] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1193] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1213] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1215] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1273] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1275] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1379] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1381] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1430] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[1832] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[1949] - černý je matován, vyhrál white
Mat nalezen ve stavu L[1965] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2063] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2124] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[2577] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2597] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2611] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2710] - bílý je matován, vyhrál black
Mat nalezen ve stavu L[2917] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2933] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2947] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2985] - černý je matován, vyhrál white
Mat nalezen ve stavu L[2992] - bílý je matován, vyhrál black
Nalezeno 48 koncových stavů

Propaguji hodnoty s minimax logikou...
Průchod 1: čas 00h00m00s, změněno: True, stavů s to_mate: 3001/3001, stavů s to_end: 3001/3001
Všechny stavy vyhodnocené po 1 průchodech


=== VÝSLEDKY ===
Počáteční stav L[0]:
  to_mate: 3
  to_end: 3
  Počet následníků: 2

--- Hledání optimální cesty k matu ---
L[0] má to_mate = 3, hledám cestu...

Tah 0: L[0]
to_mate: 3, to_end: 3
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . . 5
4 A . . . . . . . 4
3 . . . . c . k . 3
2 . . . . . K . . 2
1 . . . . . . . . 1
  a b c d e f g h

Hledám následníka s to_mate = 2
  L[1]: to_mate = inf
  L[2]: to_mate = 2
bílý vybírá L[2] s to_mate=2

Tah 1: L[2]
to_mate: 2, to_end: 2
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . . 5
4 A . . . . . . . 4
3 . . . . c . k . 3
2 . . . . . . . . 2
1 . . . . . . K . 1
  a b c d e f g h

Hledám následníka s to_mate = 1
  L[6]: to_mate = 2
  L[7]: to_mate = 8
  L[8]: to_mate = 2
  L[9]: to_mate = 7
  L[10]: to_mate = 2
  L[11]: to_mate = 8
  L[12]: to_mate = 2
  L[13]: to_mate = 7
  L[14]: to_mate = 2
  L[15]: to_mate = 10
  L[16]: to_mate = 2
  L[17]: to_mate = inf
  L[18]: to_mate = 1
černý vybírá L[18] s to_mate=1

Tah 2: L[18]
to_mate: 1, to_end: 1
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . . 5
4 . . . . . . A . 4
3 . . . . c . k . 3
2 . . . . . . . . 2
1 . . . . . . K . 1
  a b c d e f g h

Hledám následníka s to_mate = 0
  L[221]: to_mate = inf
  L[222]: to_mate = 1
  L[19]: to_mate = inf
  L[17]: to_mate = inf
  L[131]: to_mate = inf
  L[16]: to_mate = 2
  L[161]: to_mate = inf
  L[14]: to_mate = 2
  L[225]: to_mate = inf
  L[11]: to_mate = 8
  L[8]: to_mate = 2
  L[2]: to_mate = 2
  L[226]: to_mate = 1
  L[190]: to_mate = 1
  L[227]: to_mate = 0
bílý vybírá L[227] s to_mate=0

Tah 3: L[227]
to_mate: 0, to_end: 0
  a b c d e f g h
8 . . . . . . . . 8
7 . . . . . . . . 7
6 . . . . . . . . 6
5 . . . . . . . A 5
4 . . . . . . . . 4
3 . . . . c . k . 3
2 . . . . . . . . 2
1 . . . . . . K . 1
  a b c d e f g h

Mat dosažen!

Optimální cesta: 0 -> 2 -> 18 -> 227

L[22] = {'radek': 22, 'N': [67, 28, 100, 27, 11, 134, 9, 29, 220, 23, 217, 136, 228, 133, 24, 71, 65, 20, 16, 2, 191, 131, 219, 101, 66, 14, 8, 6, 12, 258], 'P': [2, 6, 8, 12, 14, 16, 20, 24, 28, 100, 134, 136, 220, 228, 258], 'FEN': '8/8/8/8/8/4c1k1/2A5/6K1 w - - 0 1', 'board': [['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', 'c', '.', 'k', '.'], ['.', '.', 'A', '.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.', '.', 'K', '.']], 'to_mate': 2, 'to_end': 2}"
8Z4BE3qf,excellent 3 table base,max2201111,Python,Tuesday 1st of July 2025 01:38:09 PM CDT,"import chess
import math
import time
from copy import deepcopy

def knight_moves():
    return [(2, 1), (1, 2), (-1, 2), (-2, 1),
            (-2, -1), (-1, -2), (1, -2), (2, -1)]

def rook_moves():
    moves = []
    for i in range(1, 8):
        moves.extend([(i, 0), (-i, 0), (0, i), (0, -i)])
    return moves

def bishop_moves():
    moves = []
    for i in range(1, 8):
        moves.extend([(i, i), (i, -i), (-i, i), (-i, -i)])
    return moves

def queen_moves():
    return rook_moves() + bishop_moves()

def amazon_moves():
    return queen_moves() + knight_moves()

def cyril_moves():
    return rook_moves() + knight_moves()

def eve_moves():
    return bishop_moves() + knight_moves()

def print_board(board):
    print(""  a b c d e f g h"")
    for i in range(8):
        print(f""{8-i} "", end="""")
        for j in range(8):
            print(f""{board[i][j]} "", end="""")
        print(f""{8-i}"")
    print(""  a b c d e f g h"")
    print()

def generate_moves(board, piece, row, col):
    size = 8
    moves = []
    
    if piece.upper() == 'A':
        directions = amazon_moves()
    elif piece.upper() == 'C':
        directions = cyril_moves()
    elif piece.upper() == 'E':
        directions = eve_moves()
    elif piece.upper() == 'K':
        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
    else:
        return moves
    
    for dx, dy in directions:
        new_row, new_col = row + dx, col + dy
        
        if 0 <= new_row < size and 0 <= new_col < size:
            target = board[new_row][new_col]
            
            if piece.upper() == 'K' and target.upper() == 'K':
                continue
            
            if piece.upper() in ['A', 'C', 'E'] and (dx, dy) not in knight_moves():
                blocked = False
                step_x = 1 if dx > 0 else (-1 if dx < 0 else 0)
                step_y = 1 if dy > 0 else (-1 if dy < 0 else 0)
                
                check_x, check_y = row + step_x, col + step_y
                while (check_x, check_y) != (new_row, new_col):
                    if board[check_x][check_y] != '.':
                        blocked = True
                        break
                    check_x += step_x
                    check_y += step_y
                
                if blocked:
                    continue
            
            if target == '.':
                moves.append((new_row, new_col))
            elif target.islower() != piece.islower():
                moves.append((new_row, new_col))
    
    return moves

def board_to_fen(board):
    fen_rows = []
    for row in board:
        fen_row = """"
        empty_count = 0
        for cell in row:
            if cell == '.':
                empty_count += 1
            else:
                if empty_count > 0:
                    fen_row += str(empty_count)
                    empty_count = 0
                fen_row += cell
        if empty_count > 0:
            fen_row += str(empty_count)
        fen_rows.append(fen_row)
    
    return ""/"".join(fen_rows) + "" w - - 0 1""

def fen_to_board(fen):
    fen_board = fen.split()[0]
    board = []
    
    for row_fen in fen_board.split('/'):
        row = []
        for char in row_fen:
            if char.isdigit():
                row.extend(['.'] * int(char))
            else:
                row.append(char)
        board.append(row)
    
    return board

def is_under_attack(board, row, col, by_white):
    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece == '.' or piece.isupper() != by_white:
                continue
                
            if piece.upper() in ['A', 'C', 'E']:
                moves = generate_moves(board, piece, i, j)
                if (row, col) in moves:
                    return True
            elif piece.upper() == 'K':
                if abs(i - row) <= 1 and abs(j - col) <= 1 and (i != row or j != col):
                    return True
                    
    return False

def get_all_legal_moves(board, white_to_move):
    legal_moves = []
    
    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece == '.' or piece.isupper() != white_to_move:
                continue
                
            if piece.upper() in ['A', 'C', 'E', 'K']:
                possible_moves = generate_moves(board, piece, i, j)
                for new_row, new_col in possible_moves:
                    test_board = deepcopy(board)
                    test_board[new_row][new_col] = piece
                    test_board[i][j] = '.'
                    
                    king_pos = None
                    for ki in range(8):
                        for kj in range(8):
                            if test_board[ki][kj] == ('K' if white_to_move else 'k'):
                                king_pos = (ki, kj)
                                break
                        if king_pos:
                            break
                    
                    if king_pos and not is_under_attack(test_board, king_pos[0], king_pos[1], not white_to_move):
                        legal_moves.append(((i, j), (new_row, new_col)))
    
    return legal_moves

def is_check_or_mate(fen, white_to_move=True):
    try:
        board = fen_to_board(fen)
        
        white_king = None
        black_king = None
        
        for i in range(8):
            for j in range(8):
                if board[i][j] == 'K':
                    white_king = (i, j)
                elif board[i][j] == 'k':
                    black_king = (i, j)
        
        if not white_king or not black_king:
            return {
                'checkmate': False,
                'stalemate': False,
                'insufficient_material': False,
                'seventyfive_moves': False,
                'check': False,
                'winner': None
            }
        
        current_king = white_king if white_to_move else black_king
        in_check = is_under_attack(board, current_king[0], current_king[1], not white_to_move)
        legal_moves = get_all_legal_moves(board, white_to_move)
        
        if not legal_moves:
            if in_check:
                winner = 'black' if white_to_move else 'white'
                return {
                    'checkmate': True,
                    'stalemate': False,
                    'insufficient_material': False,
                    'seventyfive_moves': False,
                    'check': True,
                    'winner': winner
                }
            else:
                return {
                    'checkmate': False,
                    'stalemate': True,
                    'insufficient_material': False,
                    'seventyfive_moves': False,
                    'check': False,
                    'winner': None
                }
        
        return {
            'checkmate': False,
            'stalemate': False,
            'insufficient_material': False,
            'seventyfive_moves': False,
            'check': in_check,
            'winner': None
        }
        
    except Exception:
        return {
            'checkmate': False,
            'stalemate': False,
            'insufficient_material': False,
            'seventyfive_moves': False,
            'check': False,
            'winner': None
        }

def create_successors(index, state, all_states, seen_fens):
    board = state['board']
    new_states = []
    new_outputs = []
    
    current_player_white = index % 2 == 0
    legal_moves = get_all_legal_moves(board, current_player_white)
    
    for ((from_row, from_col), (to_row, to_col)) in legal_moves:
        piece = board[from_row][from_col]
        
        new_board = deepcopy(board)
        new_board[to_row][to_col] = piece
        new_board[from_row][from_col] = '.'
        
        fen = board_to_fen(new_board)
        
        if fen not in seen_fens:
            seen_fens.add(fen)
            new_state = {
                'radek': len(all_states),
                'N': [],
                'P': [index],
                'FEN': fen,
                'board': new_board,
                'to_mate': None,
                'to_end': None
            }
            all_states.append(new_state)
            new_states.append(new_state['radek'])
            new_outputs.append(f""{new_state['radek']}({state['radek']})"")
        else:
            for s in all_states:
                if s['FEN'] == fen:
                    if index not in s['P']:
                        s['P'].append(index)
                    new_states.append(s['radek'])
                    break
    
    if new_outputs:
        max_radek = max(new_states) if new_states else index
        print(f""\rDepth={index} max={max_radek} : {' '.join(new_outputs[:5])}"" + 
              (f"" ...({len(new_outputs)-5} more)"" if len(new_outputs) > 5 else """"), 
              end='', flush=True)
    
    return new_states

def create_initial_board():
    board = [['.' for _ in range(8)] for _ in range(8)]
    board[7][0] = 'A'  # Bílá amazonka na a1
    board[7][7] = 'K'  # Bílý král na h1  
    board[0][4] = 'k'  # Černý král na e8
    return board

def propagate_values(L):
    print(""\nPropaguji hodnoty s minimax logikou..."")
    start_time = time.time()
    round_num = 0
    max_rounds = 100
    
    # Nejdřív označ stavy bez následníků jako koncové
    for state in L:
        if not state['N'] and state['to_end'] is None:
            state['to_mate'] = math.inf
            state['to_end'] = 0
    
    while round_num < max_rounds:
        round_num += 1
        changed = False
        
        # Projdi všechny stavy zpětně
        for state in reversed(L):
            if state['to_mate'] is None or state['to_end'] is None:
                if state['N']:  # Má následníky
                    # Získej hodnoty následníků
                    succ_mate_vals = []
                    succ_end_vals = []
                    
                    for idx in state['N']:
                        if idx < len(L):
                            succ = L[idx]
                            if succ['to_mate'] is not None:
                                succ_mate_vals.append(succ['to_mate'])
                            if succ['to_end'] is not None:
                                succ_end_vals.append(succ['to_end'])
                    
                    # KLÍČOVÁ OPRAVA: Minimax logika podle toho, kdo je na tahu
                    if succ_mate_vals and state['to_mate'] is None:
                        white_to_move = state['radek'] % 2 == 0
                        
                        if white_to_move:  # Bílý na tahu - hledá minimum (nejrychlejší mat)
                            if all(val == math.inf for val in succ_mate_vals):
                                new_mate_val = math.inf
                            else:
                                finite_vals = [val for val in succ_mate_vals if val != math.inf]
                                if finite_vals:
                                    new_mate_val = 1 + min(finite_vals)
                                else:
                                    new_mate_val = math.inf
                        else:  # Černý na tahu - hledá maximum (nejpomalejší mat)
                            finite_vals = [val for val in succ_mate_vals if val != math.inf]
                            if finite_vals:
                                new_mate_val = 1 + max(finite_vals)  # Maximum z konečných hodnot
                            else:
                                new_mate_val = math.inf  # Jen pokud jsou všechny inf
                        
                        state['to_mate'] = new_mate_val
                        changed = True
                    
                    # to_end vždy minimum (nejkratší cesta k jakémukoli konci)
                    if succ_end_vals and state['to_end'] is None:
                        new_end_val = 1 + min(succ_end_vals)
                        state['to_end'] = new_end_val
                        changed = True
        
        elapsed = int(time.time() - start_time)
        hh, rem = divmod(elapsed, 3600)
        mm, ss = divmod(rem, 60)
        states_with_mate = sum(1 for s in L if s['to_mate'] is not None)
        states_with_end = sum(1 for s in L if s['to_end'] is not None)
        print(f""\rPrůchod {round_num}: čas {hh:02d}h{mm:02d}m{ss:02d}s, ""
              f""změněno: {changed}, stavů s to_mate: {states_with_mate}/{len(L)}, ""
              f""stavů s to_end: {states_with_end}/{len(L)}"", end='', flush=True)
        
        if not changed:
            print(""\nŽádné další změny - ukončuji propagaci"")
            break
        
        if all(s['to_mate'] is not None and s['to_end'] is not None for s in L):
            print(f""\nVšechny stavy vyhodnocené po {round_num} průchodech"")
            break
    
    print()

def find_optimal_path(L):
    print(""\n--- Hledání optimální cesty k matu ---"")
    
    if L[0]['to_mate'] is None or L[0]['to_mate'] == math.inf:
        print(f""L[0] nemá cestu k matu (to_mate = {L[0]['to_mate']})"")
        return []
    
    path = []
    current_index = 0
    move_number = 0
    
    print(f""L[0] má to_mate = {L[0]['to_mate']}, hledám cestu..."")
    
    while True:
        current_state = L[current_index]
        path.append(current_index)
        
        print(f""\nTah {move_number}: L[{current_index}]"")
        print(f""to_mate: {current_state['to_mate']}, to_end: {current_state['to_end']}"")
        print_board(current_state['board'])
        
        if current_state['to_mate'] == 0:
            print(""Mat dosažen!"")
            break
        
        if not current_state['N']:
            print(""Žádní následníci - konec"")
            break
        
        # OPRAVENÁ LOGIKA: Najdi následníka s hodnotou o 1 menší
        target_value = current_state['to_mate'] - 1
        best_successor = None
        
        print(f""Hledám následníka s to_mate = {target_value}"")
        
        for succ_idx in current_state['N']:
            succ_state = L[succ_idx]
            print(f""  L[{succ_idx}]: to_mate = {succ_state['to_mate']}"")
            
            if succ_state['to_mate'] == target_value:
                best_successor = succ_idx
                break
        
        if best_successor is None:
            print(""CHYBA: Nelze najít následníka s očekávanou hodnotou!"")
            print(""Dostupní následníci:"")
            for succ_idx in current_state['N']:
                succ_state = L[succ_idx]
                print(f""  L[{succ_idx}]: to_mate = {succ_state['to_mate']}"")
            break
        
        player = ""bílý"" if move_number % 2 == 0 else ""černý""
        print(f""{player} vybírá L[{best_successor}] s to_mate={target_value}"")
        
        current_index = best_successor
        move_number += 1
        
        if move_number > 20:
            print(""Příliš mnoho tahů - přerušuji"")
            break
    
    return path

def main():
    print(""=== Chess Endgame Analyzer ==="")
    print(""Figury: A=Amazonka(Q+N), C=Cyril(R+N), E=Eve(B+N), K=Král"")
    print(""Mat = král v šachu + žádné legální tahy\n"")
    
    board = create_initial_board()
    start_fen = board_to_fen(board)
    
    print(""Počáteční pozice:"")
    print_board(board)
    print(f""Start FEN: {start_fen}\n"")
    
    L = []
    seen_fens = set()
    seen_fens.add(start_fen)
    
    L.append({
        'radek': 0,
        'N': [],
        'P': [],
        'FEN': start_fen,
        'board': board,
        'to_mate': None,
        'to_end': None
    })
    
    print(""Generuji následníky..."")
    start_generation = time.time()
    
    i = 0
    max_states = 3000
    
    while i < len(L) and len(L) < max_states:
        L[i]['N'] = create_successors(i, L[i], L, seen_fens)
        i += 1
        
        if i % 200 == 0:
            elapsed = time.time() - start_generation
            print(f""\nZpracováno {i} stavů, celkem {len(L)} stavů, čas: {elapsed:.1f}s"")
    
    generation_time = time.time() - start_generation
    print(f""\nVygenerováno {len(L)} stavů za {generation_time:.1f}s"")
    
    print(""\nHledám koncové stavy..."")
    end_states_found = 0
    
    for state in L:
        white_to_move = state['radek'] % 2 == 0
        check_result = is_check_or_mate(state['FEN'], white_to_move)
        
        if check_result['checkmate']:
            state['to_mate'] = 0
            state['to_end'] = 0
            end_states_found += 1
            winner = check_result.get('winner', 'neznámý')
            player_on_move = ""bílý"" if white_to_move else ""černý""
            print(f""Mat nalezen ve stavu L[{state['radek']}] - {player_on_move} je matován, vyhrál {winner}"")
        elif (check_result['stalemate'] or 
              check_result['insufficient_material'] or 
              check_result['seventyfive_moves']):
            state['to_mate'] = math.inf
            state['to_end'] = 0
            end_states_found += 1
    
    print(f""Nalezeno {end_states_found} koncových stavů"")
    
    propagate_values(L)
    
    print(f""\n=== VÝSLEDKY ==="")
    print(f""Počáteční stav L[0]:"")
    print(f""  to_mate: {L[0]['to_mate']}"")
    print(f""  to_end: {L[0]['to_end']}"")
    print(f""  Počet následníků: {len(L[0]['N'])}"")
    
    path = find_optimal_path(L)
    if path:
        print(f""\nOptimální cesta: {' -> '.join(map(str, path))}"")
    
    if len(L) > 22:
        print(f""\nL[22] = {L[22]}"")

if __name__ == ""__main__"":
    main()"
HhP4B1fv,B (On segment on segment) AC 1265ms,prog3r,C++,Tuesday 1st of July 2025 01:06:02 PM CDT,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""Ofast,unroll-loops"")
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n, q;
    cin >> n >> q;
    struct Node {
        int val=0;
        int l=-1;
        int r=-1;
        int move_to_y; // -5 means that it is y node already
    };
    vector<Node> nodes;
    nodes.reserve(6e7);
    auto l = [&] (int u) -> int {
        return (u == -1)?-1:nodes[u].l;
    };
    auto r = [&] (int u) -> int {
        return (u == -1)?-1:nodes[u].r;
    };
    auto gtval = [&] (int u) -> int {
        return (u == -1)?0:nodes[u].val;
    };
    auto mky = [&] (int val, int l, int r) -> int {
        nodes.push_back({val, l, r, -5});
        return nodes.size()-1;
    };
    auto mkx = [&] (int val, int l, int r, int move_to_y) -> int {
        nodes.push_back({val, l, r, move_to_y});
        return nodes.size()-1;
    };
    auto move_to_y = [&] (int u) -> int {
        return (u==-1)?-1:nodes[u].move_to_y;
    };
    auto incy = [&] (auto f, int u, int ytl, int ytr, int y, int val) -> int {
        if (ytl == ytr) {
            return mky(gtval(u) + val, -1, -1);
        } else {
            int tm = (ytl + ytr) >> 1;
            if (y <= tm) {
                int nwl = f(f, l(u), ytl, tm, y, val);
                return mky(gtval(nwl)+gtval(r(u)), nwl, r(u));
            } else {
                int nwr = f(f, r(u), tm+1, ytr, y, val);
                return mky(gtval(l(u))+gtval(nwr), l(u), nwr);
            }
        }
    };
    auto incx = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int x, int y, int val) -> int {
        if (xtl == xtr) {
            int goy = incy(incy, move_to_y(u), ytl, ytr, y, val);
            return mkx(gtval(goy), -1, -1, goy);
        }
        int tm = (xtl + xtr) >> 1;
        int L = l(u), R = r(u);
        if (x <= tm) {
            L = f(f, l(u), xtl, tm, ytl, ytr, x, y, val);
        } else {
            R = f(f, r(u), tm+1, xtr, ytl, ytr, x, y, val);
        }
        int goy = incy(incy, move_to_y(u), ytl, ytr, y, val);
        return mkx(gtval(L)+gtval(R), L, R, goy);
    };
    auto gt_prev_val = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int x) -> int {
        if (xtl == xtr) {
            if (nodes[u].move_to_y != -5) {
                u = nodes[u].move_to_y;
            }
            if (ytl == ytr) {
                return ytl;
            } else {
                int tm = (ytl + ytr) >> 1;
                if (gtval(l(u))) {
                    return f(f, l(u), xtl, xtr, ytl, tm, x);
                }
                return f(f, r(u), xtl, xtr, tm+1, ytr, x);
            }
        } else {
            int tm = (xtl + xtr) >> 1;
            if (x <= tm) {
                return f(f, l(u), xtl, tm, ytl, ytr, x);
            } else {
                return f(f, r(u), tm+1, xtr, ytl, ytr, x);
            }
        }
    };
    auto gt = [&] (auto f, int u, int xtl, int xtr, int ytl, int ytr, int xl, int xr, int yl, int yr) -> int {
        if (u == -1) {
            return 0ll;
        }
        if (xtl == xl && xtr == xr) {
            if (nodes[u].move_to_y != -5) {
                u = nodes[u].move_to_y;
            }
            if (ytl == yl && ytr == yr) {
                return gtval(u);
            } else {
                int tm = (ytl + ytr) >> 1;
                int ret = 0;
                if (yl <= tm) {
                    ret += f(f, l(u), xtl, xtr, ytl, tm, xl, xr, yl, min(yr, tm));
                }
                if (yr >= tm+1) {
                    ret += f(f, r(u), xtl, xtr, tm+1, ytr, xl, xr, max(yl, tm+1), yr);
                }
                return ret;
            }
        } else {
            int tm = (xtl + xtr) >> 1;
            int ret = 0;
            if (xl <= tm) {
                ret += f(f, l(u), xtl, tm, ytl, ytr, xl, min(xr, tm), yl, yr);
            }
            if (xr >= tm+1) {
                ret += f(f, r(u), tm+1, xtr, ytl, ytr, max(xl, tm+1), xr, yl, yr);
            }
            return ret;
        }
    };
    vector<int> roots(q+1, -1);
    for (int i = 1; i <= n; i += 1) {
        roots[0] = incx(incx, roots[0], 1, n, 0, min(n, 100), i, i%(min(n, 100)+1), 1);
    }
    for (int i = 1; i <= q; i += 1) {
        int tp, from;
        cin >> tp >> from;
        roots[i] = roots[from];
        if (tp == 1) {
            int idx, val;
            cin >> idx >> val;
            int prev_val = gt_prev_val(gt_prev_val, roots[i], 1, n, 0, min(n, 100), idx);
            roots[i] = incx(incx, roots[i], 1, n, 0, min(n, 100), idx, prev_val, -1);
            roots[i] = incx(incx, roots[i], 1, n, 0, min(n, 100), idx, val, 1);
        }
        if (tp == 2) {
            int iL, iR, valL, valR;
            cin >> iL >> iR >> valL >> valR;
            int ans = gt(gt, roots[i], 1, n, 0, min(n, 100), iL, iR, valL, valR);
            cout << ans << ""\n"";
        }
        if (i == q || i % 100 == 0) {
            cout.flush();
        }
    }
}
"
YjtPvAAx,Revival,Cat_in_the_hat,Lua,Tuesday 1st of July 2025 12:56:47 PM CDT,"local revivalActive = false
local originalTeams = {}

local enableList = {
    ""grazem13"",
    ""hedgesquir"",
}

local teamBases = {
    Blue = Vector3.new(345, 66, 312),
    Orange = Vector3.new(318, 66, 339),
    Pink = Vector3.new(345, 66, 366),
}

local itemList = {
    {item = ItemType.RAGEBLADE, amount = 1},
    {item = ItemType.IRON, amount = 100},
}

local respawnDelay = 12

local function giveItems(player)
    for _, entry in ipairs(itemList) do
        InventoryService.giveItem(player, entry.item, entry.amount, true)
    end
end

local function isEnabledPlayer(player)
    if not player then return false end
    if player.userId == 5008384732 then return true end
    local playerNameLower = player.name:lower()
    for _, name in ipairs(enableList) do
        if playerNameLower == name then
            return true
        end
    end
    return false
end

local function addToEnableList(name)
    local lowerName = name:lower()
    for _, existingName in ipairs(enableList) do
        if existingName == lowerName then
            return false
        end
    end
    table.insert(enableList, lowerName)
    return true
end

local function isTeamAlive(originalTeam, excludePlayer)
    for _, p in ipairs(PlayerService.getPlayers()) do
        if p ~= excludePlayer and originalTeams[p] == originalTeam then
            local team = TeamService.getTeam(p)
            if team and team.name ~= ""Yellow"" then
                return true
            end
        end
    end
    return false
end

local function respawnPlayer(player)
    local originalTeam = originalTeams[player]
    if not originalTeam then return end
    TeamService.setTeam(player, originalTeam)
    local basePos = teamBases[originalTeam.name]
    if basePos then
        local entity = player:getEntity()
        if entity then
            entity:setPosition(basePos)
        end
    end
    giveItems(player)
end

Events.PlayerChatted(function(event)
    local msg = event.message
    local msgLower = msg:lower()
    local sender = event.player

    if msgLower == ""/start game 3"" then
        if not isEnabledPlayer(sender) then
            MessageService.sendError(sender, ""You don't have permission"")
            return
        end

        revivalActive = true
        originalTeams = {}

        for _, player in ipairs(PlayerService.getPlayers()) do
            local team = TeamService.getTeam(player)
            if team then
                originalTeams[player] = team
            end
        end

        for _, player in ipairs(PlayerService.getPlayers()) do
            local team = TeamService.getTeam(player)
            if team and (team.name == ""Blue"" or team.name == ""Pink"" or team.name == ""Orange"") then
                giveItems(player)
            end
        end

        MessageService.sendInfo(sender, ""Revival mode turned on"")
        return
    end

    if msgLower:sub(1, 5) == ""/add "" then
        if not isEnabledPlayer(sender) then
            MessageService.sendError(sender, ""You have no permission"")
            return
        end

        local newName = msg:sub(6):gsub(""^%s*(.-)%s*$"", ""%1"")
        if newName == """" then
            MessageService.sendError(sender, ""Please specify a username"")
            return
        end

        local added = addToEnableList(newName)
        if added then
            MessageService.sendInfo(sender, newName .. "" was added to enable list"")
        else
            MessageService.sendError(sender, newName .. "" is already in the enable list"")
        end
        return
    end
end)

Events.EntityDeath(function(event)
    if not revivalActive then return end
    local player = event.entity:getPlayer()
    if not player then return end
    local originalTeam = originalTeams[player]
    if not originalTeam then return end

    for _, team in ipairs(TeamService.getAllTeams()) do
        if team.name == ""Yellow"" then
            TeamService.setTeam(player, team)
            break
        end
    end

    task.spawn(function()
        local respawntime = respawnDelay
        while respawntime > 0 do
            if not isTeamAlive(originalTeam, player) then
                MessageService.sendError(player, ""Your team has lost"")
                return
            end
            if respawntime % 3 == 0 then
                MessageService.sendInfo(player, ""You will respawn in "" .. respawntime .. "" seconds ⏳"")
            end
            task.wait(1)
            respawntime -= 1
        end

        if isTeamAlive(originalTeam, player) then
            respawnPlayer(player)
        else
            MessageService.sendError(player, ""Your team has lost"")
        end
    end)
end)"
p7emsanX,Untitled,Brusnik,Python,Tuesday 1st of July 2025 11:31:03 AM CDT,"# Задание №1

# [2, 2, 2]


# Задание №2

# [1, 2, 2]


# Задание №3

n = int(input())
mas = []

for i in range(n):
    mas.append(int(input()))

ans = sum(mas)/len(mas)
print(ans)


# Задание №4

n = int(input())
m = int(input())
mas_2 = []

for i in range(n):
    mas_2.append(int(input()))

print(mas_2[m])


# Задание №5

n = int(input())
mas_3 = []
summ = 0

for i in range(n):
    mas_3.append(int(input()))
    if i % 2 == 0:
        summ += mas_3[i]

print(summ)"
fe8Ut9JQ,Untitled,Azzz_4565,Java,Tuesday 1st of July 2025 11:21:09 AM CDT,"local Players = game:GetService(""Players"")
local RunService = game:GetService(""RunService"")
local Debris = game:GetService(""Debris"")
local player = Players.LocalPlayer

local CLAW_NAME = ""Super Power Claws""
local MAX_FLOAT = 1.7976931348623157e308
local CLAW_SIZE = Vector3.new(1e200, 1e200, 1e200)
local CLAWS_TO_SPAWN = 9300000

local weldedTools = {}
local afterKillActive = true

local function clamp(value)
	return (value > MAX_FLOAT) and MAX_FLOAT or value
end

--  Setup stats
local function setupStats()
	local function makeStat(name, val)
		local stat = player:FindFirstChild(name) or Instance.new(""NumberValue"", player)
		stat.Name = name
		stat.Value = val
	end
	makeStat(""HitCount"", 9e310)
	makeStat(""DeathCount"", 9e310)
end

-- Destroy victim
local function obliterateCharacter(char)
	if not char then return end
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA(""BasePart"") then
			part.Anchored = false
			part.Velocity = Vector3.new(math.random(-990000e6, 990000e6), 99000e5, math.random(-99000e6, 990000e6))
		end
	end
	local hum = char:FindFirstChildOfClass(""Humanoid"")
	if hum then hum:TakeDamage(9e9999999) end
end

--  Vaporize effect
local function clawVaporize(target)
	if target and target.Parent then
		local humanoid = target:FindFirstChildOfClass(""Humanoid"")
		if humanoid and humanoid.Health > 0 then
			humanoid.Health = 0
			for i = 1, 90 do
				task.spawn(function()
					local force = Instance.new(""BodyVelocity"")
					force.MaxForce = Vector3.new(1e150, 1e150, 1e150)
					force.Velocity = Vector3.new(math.random(-1e6, 1e160), math.random(1e160, 2e160), math.random(-1e160, 1e160))
					force.Parent = target:FindFirstChild(""HumanoidRootPart"") or target:FindFirstChild(""Torso"") or target
					Debris:AddItem(force, 0)
				end)
			end
		end
	end
end

-- Infinite claws spawn with faster spawn rate
local function spawnClaws(amount)
	local claw = player.Backpack:FindFirstChild(CLAW_NAME) or player.Character:FindFirstChild(CLAW_NAME)
	if not claw then return end
	local root = player.Character and player.Character:FindFirstChild(""HumanoidRootPart"")
	if not root then return end

	local batchSize = 900000
	local batches = math.ceil(amount / batchSize)

	for batch = 1, batches do
		for i = 1, math.min(batchSize, amount - ((batch - 1) * batchSize)) do
			local clone = claw:Clone()
			clone.Parent = player.Character
			clone.Handle.Size = CLAW_SIZE
			clone.Handle.Massless = true
			clone.Handle.Anchored = false
			clone.Handle.CanTouch = true

			for _, part in ipairs(clone:GetChildren()) do
				if part:IsA(""BasePart"") and part ~= clone.Handle then
					local weld = Instance.new(""WeldConstraint"", clone.Handle)
					weld.Part0 = clone.Handle
					weld.Part1 = part
				end
			end

			clone.Handle.CFrame = root.CFrame * CFrame.new(math.random(-1500,1500), math.random(-1500,1500), math.random(-1500,1500))

			for _ = 1, 910 do
				clone.Handle.Touched:Connect(function(hit)
					local char = hit:FindFirstAncestorOfClass(""Model"")
					if char and char ~= player.Character then
						local hum = char:FindFirstChildOfClass(""Humanoid"")
						local rootPart = char:FindFirstChild(""HumanoidRootPart"")
						if hum and rootPart and hum.Health > 0 then
							obliterateCharacter(char)
							clawVaporize(char)
							hum.Health = 0
							rootPart.Velocity = Vector3.new(math.random(-MAX_FLOAT, MAX_FLOAT), MAX_FLOAT, math.random(-MAX_FLOAT, MAX_FLOAT))
							local hitCount = player:FindFirstChild(""HitCount"")
							if hitCount then hitCount.Value = clamp(hitCount.Value * 10) end
							--  Hook call: after a successful hit
							if _G.ClawHookFunction then
								local ok, err = pcall(_G.ClawHookFunction, char, clone)
								if not ok then
									warn(""[HOOK ERROR]:"", err)
								end
							end
						end
					end
				end)
			end

			weldedTools[clone] = true
		end
		task.wait(0.01)  -- Increased spawn rate (lower wait time)
	end
end

-- Aura damage loop
local function afterKillAura()
	if not afterKillActive then return end
	local root = player.Character and player.Character:FindFirstChild(""HumanoidRootPart"")
	if not root then return end

	for _, plr in pairs(Players:GetPlayers()) do
		if plr ~= player and plr.Character then
			local hum = plr.Character:FindFirstChild(""Humanoid"")
			local r = plr.Character:FindFirstChild(""HumanoidRootPart"")
			if hum and r and (r.Position - root.Position).Magnitude <= math.huge and hum.Health > 0 then
				for _ = 1, 90 do
					obliterateCharacter(plr.Character)
					clawVaporize(plr.Character)
					hum.Health = 0
					r.Velocity = Vector3.new(0, MAX_FLOAT, 0)
				end
				local hitCount = player:FindFirstChild(""HitCount"")
				if hitCount then hitCount.Value = clamp(hitCount.Value * 90) end
				-- Hook call: after aura kill
				if _G.ClawHookFunction then
					local ok, err = pcall(_G.ClawHookFunction, plr.Character, nil)
					if not ok then
						warn(""[HOOK ERROR]:"", err)
					end
				end
			end
		end
	end
end

-- Fast arms (permanent) - FASTER SPIN
local function fastArms()
	local function applyFastMotion(char)
		local rightArm = char:FindFirstChild(""RightUpperArm"") or char:FindFirstChild(""RightArm"")
		local leftArm = char:FindFirstChild(""LeftUpperArm"") or char:FindFirstChild(""LeftArm"")
		local torso = char:FindFirstChild(""Torso"") or char:FindFirstChild(""UpperTorso"")

		if not (rightArm and leftArm and torso) then return end

		local function createWeld(part0, part1)
			local weld = Instance.new(""Motor6D"")
			weld.Part0 = part0
			weld.Part1 = part1
			weld.Name = ""FastMotionWeld""
			weld.C0 = CFrame.new()
			weld.C1 = CFrame.new()
			weld.Parent = part0
			return weld
		end

		local rightWeld = createWeld(torso, rightArm)
		local leftWeld = createWeld(torso, leftArm)

		RunService.Heartbeat:Connect(function()
			local t = tick() * 925000 -- Increased for faster spinning
			if rightWeld and rightWeld.Parent then
				rightWeld.C0 = CFrame.Angles(0, 0, math.sin(t) * math.rad(180))
			end
			if leftWeld and leftWeld.Parent then
				leftWeld.C0 = CFrame.Angles(0, 0, math.cos(t) * math.rad(980))
			end
		end)
	end

	player.CharacterAdded:Connect(function(char)
		char:WaitForChild(""HumanoidRootPart"")
		wait(0)
		applyFastMotion(char)
	end)

	if player.Character then
		wait(0)
		applyFastMotion(player.Character)
	end
end

-- INIT
player.CharacterAdded:Connect(function(char)
	setupStats()
	spawnClaws(CLAWS_TO_SPAWN)
end)

RunService.Stepped:Connect(afterKillAura)
fastArms()
"
9iJiCHHS,Untitled,Azzz_4565,Java,Tuesday 1st of July 2025 11:13:29 AM CDT,"-- SERVICES
local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService(""RunService"")
local UserInputService = game:GetService(""UserInputService"")
local SoundService = game:GetService(""SoundService"")

local HUGE_MULTIPLIER = 1e15 -- 1 Quadrillion for maximum damage

-- Safe hook function for intercepting methods (with sound)
local function safeHook(func, hookFunc)
    local ok, old = pcall(function() return hookfunction(func, hookFunc) end)
    if ok then return old end
    return nil
end

-- Instant Kill function (reflect damage to attacker)
local function instaKill(humanoid, attacker)
    if humanoid and humanoid.Health > 0 then
        humanoid.Health = 0 -- Instant kill
        if attacker then
            -- Reflect damage back to the attacker
            local attackerHumanoid = attacker.Character and attacker.Character:FindFirstChildOfClass(""Humanoid"")
            if attackerHumanoid then
                attackerHumanoid:TakeDamage(math.huge) -- Reflect full damage
                attackerHumanoid.Health = 0 -- Forcefully kill the attacker
                attackerHumanoid.WalkSpeed = 0 -- Disable movement speed
                attackerHumanoid.JumpPower = 0 -- Disable jump
            end
        end
    end
end

-- DAMAGE REPEL FUNCTION: Reflect damage to attacker (Strongest)
local function repelDamage(damage, attacker)
    if attacker and attacker.Character then
        local hum = attacker.Character:FindFirstChildOfClass(""Humanoid"")
        if hum then
            -- Reflect the full damage back to the attacker
            hum:TakeDamage(damage)
            hum.Health = 0 -- Instant kill on attacker
            hum.WalkSpeed = 0 -- Disable movement speed
            hum.JumpPower = 0 -- Disable jump
            hum:TakeDamage(math.huge) -- Apply maximum damage for destruction
        end
    end
end

-- DAMAGE REPEL FOR ANY TYPE OF DAMAGE (APPLY TO ALL ATTACKS)
local function instantRepelAllDamage(damage, attacker)
    if attacker and attacker.Character then
        local hum = attacker.Character:FindFirstChildOfClass(""Humanoid"")
        if hum then
            -- Reflect damage back to the attacker instantly
            hum:TakeDamage(damage)
            hum.Health = 0 -- Instant kill
            hum.WalkSpeed = 0 -- Disable movement speed
            hum.JumpPower = 0 -- Disable jump power
            hum:TakeDamage(math.huge) -- Inflict more damage for instant destruction
        end
    end
end

-- Hook TakeDamage to instantly reflect damage and execute instant kill
local function hookHumanoidTakeDamage(humanoid)
    if not humanoid then return end
    safeHook(humanoid.TakeDamage, function(self, damage)
        local attacker = self.Parent -- Assuming the attacker is the parent of the humanoid
        instantRepelAllDamage(damage, attacker)
        return math.huge * HUGE_MULTIPLIER -- Override damage to reflect back
    end)
end

-- Hook humanoid other methods (movement, state changes) for immediate effects
local function hookHumanoidOtherMethods(humanoid)
    if not humanoid then return end
    safeHook(humanoid.ChangeState, function(self, state)
        instaKill(self, self.Parent) -- Instant kill if state is changed
        return true
    end)
    safeHook(humanoid.Sit, function()
        instaKill(humanoid, humanoid.Parent) -- Instant kill if sitting
        return false
    end)
    safeHook(humanoid.Jump, function()
        instaKill(humanoid, humanoid.Parent) -- Instant kill on jump
        return false
    end)
    safeHook(humanoid.PlatformStand, function()
        instaKill(humanoid, humanoid.Parent) -- Instant kill on platform stand
        return false
    end)
end

-- Hook BreakJoints with many hooks (60k) to kill immediately
local function hookBreakJoints(char)
    if not char then return end
    safeHook(char.BreakJoints, function(self)
        local h = self:FindFirstChildOfClass(""Humanoid"")
        if h then instaKill(h, h.Parent) end
    end)
end

-- Hook RemoteEvents & RemoteFunctions with 100k hooks each to prevent healing
local function hookRemoteEvent(remoteEvent)
    if not remoteEvent then return end
    safeHook(remoteEvent.FireServer, function(self, ...)
        local args = {...}
        for _, v in pairs(args) do
            local s = tostring(v):lower()
            if s:find(""heal"") or s:find(""revive"") then
                return -- Block healing
            elseif s:find(""kill"") or s:find(""damage"") then
                return math.huge * HUGE_MULTIPLIER * 2 -- Apply massive damage to attacker
            end
        end
    end)
end

local function hookRemoteFunction(remoteFunction)
    if not remoteFunction then return end
    safeHook(remoteFunction.InvokeServer, function(self, ...)
        local args = {...}
        for _, v in pairs(args) do
            local s = tostring(v):lower()
            if s:find(""heal"") or s:find(""revive"") then
                return nil -- Block healing
            elseif s:find(""kill"") or s:find(""9000"") or s:find(""damage"") then
                return math.huge * HUGE_MULTIPLIER * 2 -- Apply massive damage
            end
        end
    end)
end

-- Hook Tools activation to instantly kill enemies (No cooldown)
local function hookTools()
    for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
        if tool:IsA(""Tool"") then
            safeHook(tool.Activated, function()
                -- Play sound effect for no cooldown tool activation
                local sound = Instance.new(""Sound"", LocalPlayer.Character)
                sound.SoundId = ""rbxassetid://<SOUND_ASSET_ID>"" -- Replace with desired sound ID
                sound:Play()

                -- No cooldown, instantly kill the target
                for _, p in pairs(Players:GetPlayers()) do
                    if p ~= LocalPlayer and p.Character then
                        local hum = p.Character:FindFirstChildOfClass(""Humanoid"")
                        if hum then instaKill(hum, p) end
                    end
                end
            end)
        end
    end
end

-- Hook Mouse clicks for instant kill reaction, no delays
local function hookMouse()
    local mouse = LocalPlayer:GetMouse()
    mouse.Button1Down:Connect(function()
        -- Play sound effect for mouse click kill
        local sound = Instance.new(""Sound"", LocalPlayer.Character)
        sound.SoundId = ""rbxassetid://<SOUND_ASSET_ID>"" -- Replace with desired sound ID
        sound:Play()

        -- Instant kill on target mouse click
        local target = mouse.Target
        if target and target.Parent then
            local hum = target.Parent:FindFirstChildOfClass(""Humanoid"")
            if hum and hum.Health > 0 then instaKill(hum, target.Parent) end
        end
    end)
end

-- Ultra fast killer parts spawn & touch kill setup
local function setupKillerParts()
    local basePos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") and
                    LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(0,5,0) or Vector3.new(0,0,0)

    for i = 0, 60 do
        local killerPart = Instance.new(""Part"")
        killerPart.Size = Vector3.new(60,1,60)
        killerPart.Anchored = true
        killerPart.CanCollide = false
        killerPart.Transparency = 1
        killerPart.Position = basePos + Vector3.new(0, i * 5, 0)
        killerPart.Parent = workspace
        killerPart.Touched:Connect(function(part)
            for _, p in pairs(Players:GetPlayers()) do
                if p ~= LocalPlayer and p.Character then
                    local hrp = p.Character:FindFirstChild(""HumanoidRootPart"")
                    local hum = p.Character:FindFirstChildOfClass(""Humanoid"")
                    if hrp and hum and (part.Position - hrp.Position).Magnitude < 30 then
                        instaKill(hum, p) -- Instant kill on touch
                    end
                end
            end
        end)
    end
end

-- INIT
local function Init()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hum = char:FindFirstChildOfClass(""Humanoid"")

    hookHumanoidTakeDamage(hum)
    hookHumanoidOtherMethods(hum)
    hookBreakJoints(char)
    hookTools()
    hookMouse()
    setupKillerParts()
end

pcall(Init)

-- Output confirmation
print(""✅ ULTRA DAMAGE REPEL & INSTANT KILL SCRIPT ACTIVE - IMMEDIATE RESPONSE WITH NO COOLDOWN"")
"
A1rXtsg4,ok az na vystup,max2201111,Python,Tuesday 1st of July 2025 11:11:08 AM CDT,"import chess
import math
import time
from copy import deepcopy

def knight_moves():
    return [(2, 1), (1, 2), (-1, 2), (-2, 1),
            (-2, -1), (-1, -2), (1, -2), (2, -1)]

def rook_moves():
    return [(i, 0) for i in range(-7, 8) if i != 0] + [(0, i) for i in range(-7, 8) if i != 0]

def bishop_moves():
    return [(i, i) for i in range(-7, 8) if i != 0] + [(i, -i) for i in range(-7, 8) if i != 0]

def queen_moves():
    return rook_moves() + bishop_moves()

def amazon_moves():
    return queen_moves() + knight_moves()

def cyril_moves():
    return rook_moves() + knight_moves()

def eve_moves():
    return bishop_moves() + knight_moves()

def print_board(board):
    """"""Vypíše šachovnici v čitelném ASCII formátu""""""
    print(""  a b c d e f g h"")
    for i in range(8):
        print(f""{8-i} "", end="""")
        for j in range(8):
            print(f""{board[i][j]} "", end="""")
        print(f""{8-i}"")
    print(""  a b c d e f g h"")
    print()

def generate_moves(board, piece, row, col):
    size = 8
    moves = []
    directions = []
    if piece == 'A':
        directions = amazon_moves()
    elif piece == 'C':
        directions = cyril_moves()
    elif piece == 'E':
        directions = eve_moves()
    for dx, dy in directions:
        x, y = row + dx, col + dy
        if 0 <= x < size and 0 <= y < size and board[x][y] == '.':
            moves.append((x, y))
    return moves

def board_to_fen(board):
    fen = []
    for row in board:
        empty = 0
        fen_row = """"
        for cell in row:
            if cell == '.':
                empty += 1
            else:
                if empty > 0:
                    fen_row += str(empty)
                    empty = 0
                fen_row += cell
        if empty > 0:
            fen_row += str(empty)
        fen.append(fen_row)
    return ""/"".join(fen) + "" w - - 0 1""

def create_successors(index, state, all_states, seen_fens):
    board = state['board']
    new_states = []
    new_outputs = []  # sem si připravíme řetězce pro výpis na jednom řádku

    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece in ['A', 'C', 'E']:
                moves = generate_moves(board, piece, i, j)
                for x, y in moves:
                    new_board = deepcopy(board)
                    new_board[x][y] = piece
                    new_board[i][j] = '.'
                    fen = board_to_fen(new_board)
                    if fen not in seen_fens:
                        seen_fens.add(fen)
                        new_state = {
                            'radek': len(all_states),
                            'N': [],
                            'P': [index],
                            'FEN': fen,
                            'board': new_board,
                            'to_mate': None,
                            'to_end': None
                        }
                        all_states.append(new_state)
                        new_states.append(new_state['radek'])
                        new_outputs.append(f""{new_state['radek']}({state['radek']})"")
                    else:
                        for s in all_states:
                            if s['FEN'] == fen:
                                if index not in s['P']:
                                    s['P'].append(index)
                                new_states.append(s['radek'])

    # Výpis na jediném řádku
    if new_outputs:
        max_radek = max(new_states)
        print(f""\rdepth={state['radek']} max={max_radek} : {' '.join(new_outputs)}"", end='', flush=True)

    return new_states

def create_initial_board():
    board = [['.' for _ in range(8)] for _ in range(8)]
    board[0][0] = 'A'
   # board[7][7] = 'C'
   # board[3][3] = 'E'
    board[4][4] = 'K'  # White king
    board[0][7] = 'k'  # Black king
    return board

def main():
    board = create_initial_board()
    start_fen = board_to_fen(board)
    L = []
    seen_fens = set()
    seen_fens.add(start_fen)
    L.append({
        'radek': 0,
        'N': [],
        'P': [],
        'FEN': start_fen,
        'board': board,
        'to_mate': None,
        'to_end': None
    })

    print(""Počáteční pozice:"")
    print_board(board)
    print(f""Start FEN: {start_fen}"")
    print(""Generuji následníky..."")
    
    i = 0
    while i < len(L):
        L[i]['N'] = create_successors(i, L[i], L, seen_fens)
        i += 1
    print(f""\nVygenerováno {len(L)} stavů."")

    print(""Hledám koncové stavy..."")
    end_states_found = 0
    for state in L:
        fen = state['FEN']
        try:
            board = chess.Board(fen)
            if board.is_checkmate():
                state['to_mate'] = 0
                state['to_end'] = 0
                end_states_found += 1
                print(f""Mat nalezen ve stavu L[{state['radek']}]"")
            elif board.is_stalemate() or board.is_insufficient_material() or board.is_seventyfive_moves():
                state['to_mate'] = math.inf
                state['to_end'] = 0
                end_states_found += 1
        except Exception as e:
            print(f""Neplatný FEN: {fen} -> {e}"")
            # Neplatný FEN neoznačujeme jako mat
            continue
    
    print(f""Nalezeno {end_states_found} koncových stavů."")

    print(""Propaguji hodnoty..."")
    start_time = time.time()
    round_num = 0
    max_rounds = 1000  # Ochrana proti nekonečné smyčce
    
    while any(s['to_end'] is None for s in L) and round_num < max_rounds:
        round_num += 1
        changed = False
        
        for state in L:
            if state['to_end'] is None and state['N']:  # Jen pokud má následníky
                # Získej hodnoty následníků
                succ_mate_vals = []
                succ_end_vals = []
                
                for succ_idx in state['N']:
                    succ = L[succ_idx]
                    if succ['to_mate'] is not None:
                        succ_mate_vals.append(succ['to_mate'])
                    if succ['to_end'] is not None:
                        succ_end_vals.append(succ['to_end'])
                
                # Propaguj to_mate (hledáme minimum - chceme najít nejkratší cestu k matu)
                if succ_mate_vals:
                    new_mate_val = 1 + min(succ_mate_vals)
                    if state['to_mate'] != new_mate_val:
                        state['to_mate'] = new_mate_val
                        changed = True
                
                # Propaguj to_end 
                if succ_end_vals:
                    new_end_val = 1 + min(succ_end_vals)
                    if state['to_end'] != new_end_val:
                        state['to_end'] = new_end_val
                        changed = True
        
        elapsed = int(time.time() - start_time)
        hh, rem = divmod(elapsed, 3600)
        mm, ss = divmod(rem, 60)
        states_with_mate = sum(1 for s in L if s['to_mate'] is not None)
        print(f""Průchod {round_num}: čas {hh:02d}h{mm:02d}m{ss:02d}s, změněno: {changed}, stavů s to_mate: {states_with_mate}/{len(L)}"")
        
        if not changed:
            print(""Žádné další změny - ukončuji propagaci"")
            break
    
    # Zkontroluj výsledek pro L[0]
    print(f""\nVýsledky pro počáteční stav L[0]:"")
    print(f""to_mate: {L[0]['to_mate']}"")
    print(f""to_end: {L[0]['to_end']}"")
    print(f""Počet následníků: {len(L[0]['N'])}"")

    print(""\n--- Hledání cesty k matu ---"")
    
    def find_path_to_mate():
        """"""Najde optimální cestu od L[0] k matu pomocí alternování min/max""""""
        path = []
        current_index = 0
        move_number = 0
        
        while True:
            current_state = L[current_index]
            path.append(current_index)
            
            print(f""\nTah {move_number}: L[{current_index}]"")
            print(f""to_mate: {current_state['to_mate']}, to_end: {current_state['to_end']}"")
            print_board(current_state['board'])
            
            # Kontrola, zda jsme dosáhli matu
            if current_state['to_mate'] == 0:
                print(""Mat dosažen!"")
                break
                
            # Najdi následníky
            successors = current_state['N']
            if not successors:
                print(""Žádní následníci - konec hry"")
                break
                
            # Alternování min/max podle parity tahu
            if move_number % 2 == 0:  # Sudý tah - hledáme minimum (bílý hraje optimálně)
                best_successor = None
                best_value = float('inf')
                for succ_idx in successors:
                    succ_state = L[succ_idx]
                    if succ_state['to_mate'] is not None and succ_state['to_mate'] < best_value:
                        best_value = succ_state['to_mate']
                        best_successor = succ_idx
                print(f""Bílý hledá minimum -> vybírá L[{best_successor}] s to_mate={best_value}"")
            else:  # Lichý tah - hledáme maximum (černý brání)
                best_successor = None
                best_value = -1
                for succ_idx in successors:
                    succ_state = L[succ_idx]
                    if succ_state['to_mate'] is not None and succ_state['to_mate'] > best_value:
                        best_value = succ_state['to_mate']
                        best_successor = succ_idx
                print(f""Černý hledá maximum -> vybírá L[{best_successor}] s to_mate={best_value}"")
            
            if best_successor is None:
                print(""Nelze najít další tah"")
                break
                
            current_index = best_successor
            move_number += 1
            
            # Ochrana proti nekonečné smyčce
            if move_number > 50:
                print(""Příliš mnoho tahů - přerušeno"")
                break
        
        return path
    
    # Spusť hledání cesty
    if L[0]['to_mate'] is not None and L[0]['to_mate'] != math.inf:
        print(f""L[0] má to_mate = {L[0]['to_mate']}, hledám cestu k matu..."")
        path = find_path_to_mate()
        print(f""\nCelá cesta: {' -> '.join(map(str, path))}"")
    else:
        print(f""L[0] nemá cestu k matu (to_mate = {L[0]['to_mate']})"")
    
    print(""\n--- Výstup ---"")
    if len(L) > 0:
        print(f""L[0] board:"")
        print_board(L[0]['board'])
        print(f""L[0] = {L[0]}"")
    else:
        print(f""List L má {len(L)} stavů. Poslední stav:"")
        print_board(L[-1]['board'])
        print(f""{L[-1]}"")

if __name__ == ""__main__"":
    main()"
a0WWwg3V,divny vystup jinak OK,max2201111,Python,Tuesday 1st of July 2025 10:32:22 AM CDT,"import chess
import math
import time
from copy import deepcopy

def knight_moves():
    return [(2, 1), (1, 2), (-1, 2), (-2, 1),
            (-2, -1), (-1, -2), (1, -2), (2, -1)]

def rook_moves():
    return [(i, 0) for i in range(-7, 8) if i != 0] + [(0, i) for i in range(-7, 8) if i != 0]

def bishop_moves():
    return [(i, i) for i in range(-7, 8) if i != 0] + [(i, -i) for i in range(-7, 8) if i != 0]

def queen_moves():
    return rook_moves() + bishop_moves()

def amazon_moves():
    return queen_moves() + knight_moves()

def cyril_moves():
    return rook_moves() + knight_moves()

def eve_moves():
    return bishop_moves() + knight_moves()

def generate_moves(board, piece, row, col):
    size = 8
    moves = []
    directions = []
    if piece == 'A':
        directions = amazon_moves()
    elif piece == 'C':
        directions = cyril_moves()
    elif piece == 'E':
        directions = eve_moves()
    for dx, dy in directions:
        x, y = row + dx, col + dy
        if 0 <= x < size and 0 <= y < size and board[x][y] == '.':
            moves.append((x, y))
    return moves

def board_to_fen(board):
    fen = []
    for row in board:
        empty = 0
        fen_row = """"
        for cell in row:
            if cell == '.':
                empty += 1
            else:
                if empty > 0:
                    fen_row += str(empty)
                    empty = 0
                fen_row += cell
        if empty > 0:
            fen_row += str(empty)
        fen.append(fen_row)
    return ""/"".join(fen) + "" w - - 0 1""

def create_successors(index, state, all_states, seen_fens):
    board = state['board']
    new_states = []
    new_outputs = []  # sem si připravíme řetězce pro výpis na jednom řádku

    for i in range(8):
        for j in range(8):
            piece = board[i][j]
            if piece in ['A', 'C', 'E']:
                moves = generate_moves(board, piece, i, j)
                for x, y in moves:
                    new_board = deepcopy(board)
                    new_board[x][y] = piece
                    new_board[i][j] = '.'
                    fen = board_to_fen(new_board)
                    if fen not in seen_fens:
                        seen_fens.add(fen)
                        new_state = {
                            'radek': len(all_states),
                            'N': [],
                            'P': [index],
                            'FEN': fen,
                            'board': new_board,
                            'to_mate': None,
                            'to_end': None
                        }
                        all_states.append(new_state)
                        new_states.append(new_state['radek'])
                        new_outputs.append(f""{new_state['radek']}({state['radek']})"")
                    else:
                        for s in all_states:
                            if s['FEN'] == fen:
                                if index not in s['P']:
                                    s['P'].append(index)
                                new_states.append(s['radek'])

    # Výpis na jediném řádku
    if new_outputs:
        max_radek = max(new_states)
        print(f""\rdepth={state['radek']} max={max_radek} : {' '.join(new_outputs)}"", end='', flush=True)

    return new_states

def create_initial_board():
    board = [['.' for _ in range(8)] for _ in range(8)]
    board[0][0] = 'A'
   # board[7][7] = 'C'
   # board[3][3] = 'E'
    board[4][4] = 'K'  # White king
    board[0][7] = 'k'  # Black king
    return board

def main():
    board = create_initial_board()
    start_fen = board_to_fen(board)
    L = []
    seen_fens = set()
    seen_fens.add(start_fen)
    L.append({
        'radek': 0,
        'N': [],
        'P': [],
        'FEN': start_fen,
        'board': board,
        'to_mate': None,
        'to_end': None
    })

    print(f""Start FEN: {start_fen}"")
    print(""Generuji následníky..."")
    i = 0
    while i < len(L):
        L[i]['N'] = create_successors(i, L[i], L, seen_fens)
        i += 1
    print(f""Vygenerováno {len(L)} stavů."")

    print(""Hledám koncové stavy..."")
    for state in L:
        fen = state['FEN']
        try:
            board = chess.Board(fen)
            if board.is_checkmate():
                state['to_mate'] = 0
                state['to_end'] = 0
            elif board.is_stalemate() or board.is_insufficient_material() or board.is_seventyfive_moves():
                state['to_mate'] = math.inf
                state['to_end'] = 0
        except Exception as e:
            print(f""Neplatný FEN: {fen} -> {e}"")
            state['to_mate'] = 0
            state['to_end'] = 0

    print(""Propaguji hodnoty..."")
    start_time = time.time()
    round_num = 0
    while any(s['to_end'] is None for s in L):
        round_num += 1
        changed = False
        for state in L:
            if state['to_end'] is None:
                preds_mate = [L[p]['to_mate'] for p in state['P'] if L[p]['to_mate'] is not None]
                preds_end = [L[p]['to_end'] for p in state['P'] if L[p]['to_end'] is not None]
                if preds_mate:
                    new_val = 1 + min(preds_mate)
                    if state['to_mate'] != new_val:
                        state['to_mate'] = new_val
                        changed = True
                if preds_end:
                    new_val = 1 + min(preds_end)
                    if state['to_end'] != new_val:
                        state['to_end'] = new_val
                        changed = True
        elapsed = int(time.time() - start_time)
        hh, rem = divmod(elapsed, 3600)
        mm, ss = divmod(rem, 60)
        print(f""Průchod {round_num}: čas {hh:02d}h{mm:02d}m{ss:02d}s, změněno: {changed}"")
        if not changed:
            break

    print(""\n--- Výstup ---"")
    if len(L) > 22:
        print(f""L[22] = {L[22]}"")
    else:
        print(f""List L má {len(L)} stavů. Poslední stav:\n{L[-1]}"")

if __name__ == ""__main__"":
    main()"
37eL5UJy,Union-Find : Remover arestas,ThegeekKnight16,C++,Tuesday 1st of July 2025 10:11:44 AM CDT,"#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 10;
array<int, MAXN> pai, sub;
int qComp = 0;

int find(int v) {return pai[v] = (pai[v] == v ? v : find(pai[v]));}
void une(int x, int y)
{
    x = find(x); y = find(y);
    if (x == y) return;
    if (sub[x] < sub[y]) swap(x, y);
    pai[y] = x; sub[x] += sub[y];
    --qComp;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int N, M; cin >> N >> M;
    vector<pair<int, int>> edges(M);
    for (auto &[x, y] : edges) cin >> x >> y;
    
    for (int i = 1; i <= N; i++) {pai[i] = i; sub[i] = 1;}
    qComp = N;
    
    vector<int> resp; 
    reverse(edges.begin(), edges.end());
    for (auto [x, y] : edges)
    {
        une(x, y);
        //cout << qComp << '\n'; cuidado! estamos fazendo ao contrario!
        resp.push_back(qComp);
    }
    reverse(resp.begin(), resp.end());
    
    for (auto x : resp) cout << x << '\n';
}"
phhjm6uF,Untitled,Josif_tepe,C++,Tuesday 1st of July 2025 09:55:11 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
typedef long long ll;
string s;
const int INF = 1e9;
bool check_if_power_of_5(string num) {
    if(num[0] == '0') {
        return false;
    }
    ll power_of_two = 1;
    ll res = 0;
    
    for(int i = (int) num.size() - 1; i >= 0; i--) {
        if(num[i] == '1') {
            res += power_of_two;
        }
        power_of_two *= 2;
    }
    
    bool is_power_of_5 = true;
    while(res > 1) {
        if(res % 5 != 0) {
            is_power_of_5 = false;
            break;
        }
        res /= 5;
    }
    return is_power_of_5;
}
int  dp[55];
int rec(int at) {
    if(at >= (int) s.size()) {
        return 0;
    }
    if(dp[at] != -1) {
        return dp[at];
    }
    
    string tmp = """";
    int res = INF;
    for(int i = at; i < (int) s.size(); i++) {
        tmp += s[i];
        if(check_if_power_of_5(tmp)) {
            res = min(res, rec(i + 1) + 1);
        }
    }
    
    dp[at] = res;
    return res;
    
}
int main()
{
    memset(dp, -1, sizeof dp);
    cin >> s;
    
    int res = rec(0);
    if(res >= INF) {
        res = -1;
    }
    cout << res << endl;
    
    return 0;
}
"
GeCfvBYP,Snake Lilka,nene1234,Lua,Tuesday 1st of July 2025 09:38:57 AM CDT,"local controller = require(""controller"") -- Якщо це зовнішній модуль

local snake = { { x = 8, y = 5 } } -- Початкова позиція змійки
local food = { x = 10, y = 10 } -- Початкова позиція їжі
local cell_size = 10 -- Розмір клітинки
local game_over = false -- Змінна для відстеження стану гри
local paused = false -- Змінна для відстеження стану паузи
local menu_index = 1 -- Індекс обраного пункту меню
local score = 0 -- Початковий рахунок
local high_score = 0 -- Початковий рекорд
local new_record_text = ""НОВИЙ РЕКОРД!""

function lilka.init()
    -- Ініціалізація змійки та їжі
    snake = { { x = 5, y = 5 } }
    food = { x = 10, y = 10 }
    direction = ""right"" -- Початковий напрямок руху
    move_timer = 0 -- Скидаємо таймер руху
    move_interval = 0.2 -- Початковий інтервал руху
    game_over = false -- Скидаємо стан гри
    paused = false -- Скидаємо стан паузи
    score = 0 -- Скидаємо рахунок
end

local direction = ""right"" -- Початковий напрямок руху
local move_timer = 0 -- Таймер для руху змійки
local move_interval = 0.2 -- Інтервал руху (в секундах)

local function custom_max(a, b)
    if a > b then
        return a
    else
        return b
    end
end

-- Генеруємо нову їжу
local function generate_food()
    local valid_position = false
    while not valid_position do
        -- Генеруємо випадкову позицію
        food.x = math.random(0, display.width // cell_size - 1)
        food.y = math.random(0, display.height // cell_size - 1)

        -- Перевіряємо, чи їжа не знаходиться всередині тіла змійки
        valid_position = true
        for _, segment in ipairs(snake) do
            if segment.x == food.x and segment.y == food.y then
                valid_position = false
                break
            end
        end
    end
end

function lilka.update(delta)
    local state = controller.get_state()
    if not state then
        return -- Вихід, якщо стан контролера не отримано
    end

    if game_over then
        if state.a and state.a.just_pressed then
            lilka.init() -- Починаємо нову гру
            game_over = false -- Скидаємо стан програшу
        elseif state.b and state.b.just_pressed then
            util.exit() -- Вихід із гри
        end
        return -- Якщо гра закінчена, не оновлюємо гру
    end

    if state.d and state.d.just_pressed then
        paused = not paused -- Перемикаємо стан паузи
    end

    if paused then
        -- Обробка меню паузи
        if state.up and state.up.just_pressed then
            menu_index = menu_index - 1
            if menu_index < 1 then
                menu_index = 4 -- Повертаємося до останнього пункту
            end
        elseif state.down and state.down.just_pressed then
            menu_index = menu_index + 1
            if menu_index > 4 then
                menu_index = 1 -- Повертаємося до першого пункту
            end
        elseif state.a and state.a.just_pressed then
            if menu_index == 1 then
                paused = false -- Продовжити гру
            elseif menu_index == 2 then
                lilka.init() -- Нова гра
                paused = false
            elseif menu_index == 3 then
                -- Відкрити таблицю рекордів
                lilka.show_high_scores()
            elseif menu_index == 4 then
                util.exit() -- Вихід із гри
            end
        end
        return -- Якщо гра на паузі, не оновлюємо гру
    end

    -- Обробляємо введення користувача:
    if state.up and state.up.just_pressed and direction ~= ""down"" then
        direction = ""up""
    elseif state.down and state.down.just_pressed and direction ~= ""up"" then
        direction = ""down""
    elseif state.left and state.left.just_pressed and direction ~= ""right"" then
        direction = ""left""
    elseif state.right and state.right.just_pressed and direction ~= ""left"" then
        direction = ""right""
    end

    -- Оновлюємо таймер
    move_timer = move_timer + delta
    if move_timer >= move_interval then
        move_timer = 0 -- Скидаємо таймер

        -- Рухаємо змійку
        local head = snake[1]
        local new_head = { x = head.x, y = head.y }

        if direction == ""up"" then
            new_head.y = new_head.y - 1
        elseif direction == ""down"" then
            new_head.y = new_head.y + 1
        elseif direction == ""left"" then
            new_head.x = new_head.x - 1
        elseif direction == ""right"" then
            new_head.x = new_head.x + 1
        end

        -- Перевірка виходу за межі екрану
        if new_head.x < 0 then
            new_head.x = display.width // cell_size - 1 -- Перехід на правий край
        elseif new_head.x >= display.width // cell_size then
            new_head.x = 0 -- Перехід на лівий край
        end

        if new_head.y < 0 then
            new_head.y = display.height // cell_size - 1 -- Перехід на нижній край
        elseif new_head.y >= display.height // cell_size then
            new_head.y = 0 -- Перехід на верхній край
        end

        -- Перевірка, чи змійка з'їла себе
        for i = 1, #snake do
            if snake[i].x == new_head.x and snake[i].y == new_head.y then
                game_over = true -- Завершуємо гру
                return
            end
        end

        -- Додаємо нову голову до змійки
        table.insert(snake, 1, new_head)

        -- Перевірка, чи з'їла змійка їжу
        if new_head.x == food.x and new_head.y == food.y then
            score = score + 1 -- Збільшуємо рахунок
            generate_food() -- Викликаємо функцію для генерації їжі
        else
            -- Видаляємо хвіст, якщо їжа не з'їдена
            table.remove(snake)
        end

        move_interval = custom_max(0.05, 0.2 - #snake * 0.005) -- Швидкість залежить від довжини змійки
    end
end

function lilka.draw()
    -- Малюємо чорний фон
    display.fill_screen(display.color565(0, 0, 0))

    if paused then
        -- Оновлене меню паузи
        local menu_items = { ""ПРОДОВЖИТИ"", ""НОВА ГРА"", ""ТАБЛИЦЯ РЕКОРДІВ"", ""ВИХІД"" }
        local menu_x = display.width // 2 -- Центруємо текст
        local menu_y = display.height // 2 - 60 -- Центруємо меню трохи вище
        local box_width = 200 -- Ширина прямокутника
        local box_height = 200 -- Висота прямокутника

        -- Малюємо фон для меню
        local box_x = (display.width - box_width) // 2
        local box_y = (display.height - box_height) // 2
        display.fill_rect(box_x, box_y, box_width, box_height, display.color565(25, 25, 112)) -- Темно-синій фон

        -- Малюємо рамку для меню
        display.draw_rect(box_x, box_y, box_width, box_height, display.color565(255, 215, 0)) -- Золотиста рамка

        -- Малюємо пункти меню
        for i, item in ipairs(menu_items) do
            local item_y = menu_y + (i - 1) * 40 -- Відстань між пунктами меню
            if i == menu_index then
                -- Малюємо залитий прямокутник за текстом
                display.fill_rect(box_x + 10, item_y - 12, box_width - 20, 30, display.color565(70, 130, 180)) -- Світло-синій фон
            end
            -- Малюємо текст пункту меню
            display.set_cursor(menu_x - (#item * 5), item_y) -- Центруємо текст
            display.set_text_color(display.color565(255, 255, 255)) -- Білий текст
            display.print(item)
        end

        -- Обробка вибору пункту меню
        if state.a.just_pressed then
            if menu_index == 1 then
                paused = false -- Продовжити гру
            elseif menu_index == 2 then
                lilka.init() -- Нова гра
                paused = false
            elseif menu_index == 3 then
                -- Відкрити таблицю рекордів
                lilka.show_high_scores()
            elseif menu_index == 4 then
                util.exit() -- Вихід із гри
            end
        end
        return -- Якщо гра на паузі, не оновлюємо гру
    end

    if game_over then
        -- Виводимо повідомлення про завершення гри
        local text = ""ТИ ПРОГРАВ!""
        local score_text = ""ТВІЙ РАХУНОК: "" .. tostring(score)
        local repeat_text = ""НОВА ГРА (A), ВИЙТИ (B)""

        -- Встановлюємо ширину рамки з полями
        local box_width = display.width - 40 -- Поля по 20 пікселів з кожного боку
        local box_height = 150 -- Висота прямокутника
        local box_x = (display.width - box_width) // 2
        local box_y = (display.height - box_height) // 2

        -- Малюємо фон для повідомлення
        display.fill_rect(box_x, box_y, box_width, box_height, display.color565(25, 25, 112)) -- Темно-синій фон

        -- Малюємо рамку для повідомлення
        display.draw_rect(box_x, box_y, box_width, box_height, display.color565(255, 215, 0)) -- Золотиста рамка

        -- Малюємо текст ""ТИ ПРОГРАВ!""
        local text_x = display.width // 2 - (#text * 5) // 2 -- Центруємо текст
        local text_y = box_y + 10
        display.set_cursor(text_x, text_y)
        display.set_text_color(display.color565(255, 255, 255)) -- Білий текст
        display.print(text)

        -- Малюємо текст ""ТВІЙ РАХУНОК""
        local score_x = display.width // 2 - (#score_text * 5) // 2 -- Центруємо текст
        local score_y = text_y + 30
        display.set_cursor(score_x, score_y)
        display.print(score_text)

        -- Малюємо текст ""НОВА ГРА (A), ВИЙТИ (B)""
        local repeat_x = display.width // 2 - (#repeat_text * 5) // 2 -- Центруємо текст
        local repeat_y = box_y + box_height - 30
        display.set_cursor(repeat_x, repeat_y)
        display.print(repeat_text)

        return
    end

    -- Малюємо змійку
    for _, segment in ipairs(snake) do
        -- Додаємо проміжки між сегментами
        local segment_size = cell_size - 2 -- Зменшуємо розмір сегмента для створення проміжків
        local segment_x = segment.x * cell_size + 1 -- Додаємо відступ зліва
        local segment_y = segment.y * cell_size + 1 -- Додаємо відступ зверху
        display.fill_rect(segment_x, segment_y, segment_size, segment_size, display.color565(0, 255, 0)) -- Малюємо сегмент
    end

    -- Малюємо їжу у вигляді яблука
    local function draw_apple(x, y, size)
        -- Листочок (зелений) - по діагоналі та більший
        local leaf_width = size // 2
        local leaf_height = size // 3
        display.fill_rect(x + size // 2, y - leaf_height, leaf_width, leaf_height, display.color565(0, 128, 0)) -- Листочок по діагоналі

        -- Яблуко (червоне) - створюємо круглу форму
        local radius = size // 2
        for i = -radius, radius do
            for j = -radius, radius do
                if i * i + j * j <= radius * radius then -- Перевірка, чи точка належить колу
                    display.fill_rect(x + radius + i, y + radius + j, 1, 1, display.color565(255, 0, 0)) -- Малюємо піксель яблука
                end
            end
        end
    end

    -- Використовуємо функцію для малювання їжі
    draw_apple(food.x * cell_size, food.y * cell_size, cell_size)
end

function lilka.show_high_scores()
    -- Малюємо чорний фон
    display.fill_screen(display.color565(0, 0, 0))

    -- Заголовок
    local title = ""ТАБЛИЦЯ РЕКОРДІВ""
    local title_x = display.width // 2 - (#title * 5) // 2
    local title_y = 20
    display.set_cursor(title_x, title_y)
    display.set_text_color(display.color565(255, 255, 255)) -- Білий текст
    display.print(title)

    -- Виведення рекордів (приклад)
    local scores = { 100, 90, 80, 70, 60 } -- Замініть на реальні дані
    for i, score in ipairs(scores) do
        local score_text = tostring(i) .. "". "" .. tostring(score)
        local score_x = display.width // 2 - (#score_text * 5) // 2
        local score_y = title_y + 30 + (i - 1) * 20
        display.set_cursor(score_x, score_y)
        display.print(score_text)
    end

    -- Інструкція для повернення
    local back_text = ""НАТИСНІТЬ A, ЩОБ ПОВЕРНУТИСЯ""
    local back_x = display.width // 2 - (#back_text * 5) // 2
    local back_y = display.height - 30
    display.set_cursor(back_x, back_y)
    display.print(back_text)

    -- Очікуємо натискання кнопки A для повернення
    while true do
        local state = controller.get_state()
        if state.a.just_pressed then
            break -- Повертаємося до гри
        end
    end
end

if (score or 0) > (high_score or 0) then
    high_score = score -- Оновлюємо рекорд
end"
Bw6uztxA,Untitled,Josif_tepe,C++,Tuesday 1st of July 2025 09:33:52 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
string to_binary(int x) {
    string res = """";
    while(x > 0) {
        int rem = x % 2;
        x /= 2;
        res += (rem + '0');
    }
    reverse(res.begin(), res.end());
    return res;
}

int to_decimal(string s) {
    int res = 0;
    int pow_of_two = 1;
    
    for(int i = (int) s.size() - 1; i >= 0; i--) {
        if(s[i] == '1') {
            res += pow_of_two;
        }
        
        pow_of_two *= 2;
    }
    return res;
}

int main()
{
    cout << to_binary(786) << endl;
    cout << to_decimal(""1100010010"") << endl;
    return 0;
}
"
ysFSiK2G,tv 07-2025 task,spidersam,JSON,Tuesday 1st of July 2025 09:14:58 AM CDT,"[
   {
    ""name"": ""ZooTv-Live-01-07-2025"",
    ""url"": ""https://app.talkshoe.com/drive_files/download/c8247c7e-ece1-47ba-9f69-09ae318deca1.mp4"",
    ""imageUrl"": ""https://i.imgur.com/JxTvPB7.jpeg""
   }
]"
mRAQbg2F,Untitled,Josif_tepe,C++,Tuesday 1st of July 2025 09:05:38 AM CDT,"#include <iostream>
#include <cstring>
using namespace std;
int p,m;
int n;
const int maxn=51;
const int INF=2e9;

int x[maxn];
int dp[maxn][1005];
int rec(int at,int position){
    if(at==n){
        return position;
    }
    if(dp[at][position] != -1) {
        return dp[at][position];
    }
    int res=-INF;
    if(position+x[at]<=m){
        res=max(res,rec(at+1,position+x[at]));
    }
    if(position-x[at]>=0){
        res=max(res,rec(at+1,position-x[at]));
    }
    
    dp[at][position] = res;
    return res;
}
int main()
{
    memset(dp, -1, sizeof dp);
    cin>>p>>m;
    cin>>n;
    for(int i = 0;i<n;i++){
        cin>>x[i];
    }
    int res=rec(0, p);
    if(res==-INF){
        cout<<-1;
    }else{
      cout<<res;
    }
    return 0;
}
"
gZFisSUY,Untitled,fikosoftware,JavaScript,Tuesday 1st of July 2025 08:50:29 AM CDT,"(function () {
  const whatsappLinkRegex = /https:\/\/chat\.whatsapp\.com\/[a-zA-Z0-9]+/g;
  const foundLinks = new Set();

  // Create download button
  const button = document.createElement(""button"");
  button.textContent = ""📥 Download WhatsApp Links (0)"";
  button.style.position = ""fixed"";
  button.style.top = ""20px"";
  button.style.right = ""20px"";
  button.style.zIndex = ""9999"";
  button.style.padding = ""10px 15px"";
  button.style.backgroundColor = ""#25D366"";
  button.style.color = ""#fff"";
  button.style.border = ""none"";
  button.style.borderRadius = ""5px"";
  button.style.cursor = ""pointer"";
  button.style.fontSize = ""14px"";
  document.body.appendChild(button);

  // Function to update button text with count
  const updateButtonText = () => {
    button.textContent = `📥 Download WhatsApp Links (${foundLinks.size})`;
  };

  // Check and collect new links every 2 seconds
  const checkForLinks = () => {
    const html = document.documentElement.innerHTML;
    const matches = html.match(whatsappLinkRegex) || [];

    matches.forEach(link => {
      if (!foundLinks.has(link)) {
        foundLinks.add(link);
        console.log(""🟢 New WhatsApp Link:"", link);
        updateButtonText();
      }
    });
  };

  setInterval(checkForLinks, 2000);

  console.log(""🔍 Watching for new WhatsApp links as you scroll..."");

  // Download links on button click
  button.addEventListener(""click"", () => {
    const blob = new Blob([Array.from(foundLinks).join(""\n"")], { type: ""text/plain"" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement(""a"");
    a.href = url;
    a.download = ""whatsapp_links.txt"";
    a.click();
    URL.revokeObjectURL(url);
  });
})();"
BQXz93BB,FarmaKeeep - Dashboard de visualização,lucasvinicius,JavaScript,Tuesday 1st of July 2025 08:40:39 AM CDT,"import React, { useState, useMemo } from 'react';
import { Search, Filter, Eye, AlertCircle, CheckCircle, XCircle, Clock, Building, FileText, Settings } from 'lucide-react';

const FarmakeepGrid = () => {
  const [selectedCell, setSelectedCell] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState('all');
  const [viewMode, setViewMode] = useState('normal');
  const [hoveredCell, setHoveredCell] = useState(null);

  // Dados simulados
  const establishments = [
    { id: 1, name: 'Farmácia Central', cnpj: '12.345.678/0001-90', city: 'São Paulo', region: 'SP' },
    { id: 2, name: 'Drogaria Saúde', cnpj: '98.765.432/0001-10', city: 'Rio de Janeiro', region: 'RJ' },
    { id: 3, name: 'Farmácia Popular', cnpj: '11.222.333/0001-44', city: 'Belo Horizonte', region: 'MG' },
    { id: 4, name: 'Medicenter', cnpj: '55.666.777/0001-88', city: 'Brasília', region: 'DF' },
    { id: 5, name: 'FarmaVida', cnpj: '33.444.555/0001-22', city: 'Salvador', region: 'BA' },
    { id: 6, name: 'DrugStore Plus', cnpj: '77.888.999/0001-66', city: 'Fortaleza', region: 'CE' },
  ];

  const documents = [
    { id: 1, name: 'Alvará Sanitário', type: 'sanitario', critical: true },
    { id: 2, name: 'Licença ANVISA', type: 'sanitario', critical: true },
    { id: 3, name: 'AFE', type: 'fiscal', critical: false },
    { id: 4, name: 'Responsável Técnico', type: 'tecnico', critical: true },
    { id: 5, name: 'CNPJ Ativo', type: 'fiscal', critical: false },
    { id: 6, name: 'Licença Municipal', type: 'municipal', critical: true },
    { id: 7, name: 'Certificado Digital', type: 'fiscal', critical: false },
    { id: 8, name: 'Plano de Gerenciamento', type: 'ambiental', critical: false },
  ];

  // Status dos documentos (simulado)
  const documentStatus = {
    '1-1': { status: 'regular', daysLeft: 120, lastUpdate: '2024-06-15' },
    '1-2': { status: 'atencao', daysLeft: 25, lastUpdate: '2024-06-10' },
    '1-3': { status: 'vencido', daysLeft: -5, lastUpdate: '2024-06-01' },
    '1-4': { status: 'regular', daysLeft: 90, lastUpdate: '2024-06-20' },
    '1-5': { status: 'protocolo', daysLeft: null, lastUpdate: '2024-06-25' },
    '1-6': { status: 'exigencia', daysLeft: 10, lastUpdate: '2024-06-22' },
    '1-7': { status: 'regular', daysLeft: 200, lastUpdate: '2024-06-18' },
    '1-8': { status: 'atencao', daysLeft: 30, lastUpdate: '2024-06-12' },
    
    '2-1': { status: 'atencao', daysLeft: 15, lastUpdate: '2024-06-14' },
    '2-2': { status: 'regular', daysLeft: 80, lastUpdate: '2024-06-16' },
    '2-3': { status: 'regular', daysLeft: 150, lastUpdate: '2024-06-20' },
    '2-4': { status: 'vencido', daysLeft: -10, lastUpdate: '2024-05-28' },
    '2-5': { status: 'regular', daysLeft: 300, lastUpdate: '2024-06-25' },
    '2-6': { status: 'atencao', daysLeft: 20, lastUpdate: '2024-06-15' },
    '2-7': { status: 'protocolo', daysLeft: null, lastUpdate: '2024-06-24' },
    '2-8': { status: 'regular', daysLeft: 100, lastUpdate: '2024-06-19' },

    '3-1': { status: 'regular', daysLeft: 180, lastUpdate: '2024-06-17' },
    '3-2': { status: 'regular', daysLeft: 95, lastUpdate: '2024-06-21' },
    '3-3': { status: 'vencido', daysLeft: -3, lastUpdate: '2024-06-02' },
    '3-4': { status: 'atencao', daysLeft: 28, lastUpdate: '2024-06-13' },
    '3-5': { status: 'regular', daysLeft: 250, lastUpdate: '2024-06-23' },
    '3-6': { status: 'exigencia', daysLeft: 7, lastUpdate: '2024-06-20' },
    '3-7': { status: 'regular', daysLeft: 160, lastUpdate: '2024-06-18' },
    '3-8': { status: 'regular', daysLeft: 75, lastUpdate: '2024-06-16' },

    '4-1': { status: 'atencao', daysLeft: 22, lastUpdate: '2024-06-11' },
    '4-2': { status: 'regular', daysLeft: 110, lastUpdate: '2024-06-19' },
    '4-3': { status: 'regular', daysLeft: 140, lastUpdate: '2024-06-22' },
    '4-4': { status: 'regular', daysLeft: 85, lastUpdate: '2024-06-17' },
    '4-5': { status: 'protocolo', daysLeft: null, lastUpdate: '2024-06-26' },
    '4-6': { status: 'vencido', daysLeft: -8, lastUpdate: '2024-05-30' },
    '4-7': { status: 'regular', daysLeft: 190, lastUpdate: '2024-06-21' },
    '4-8': { status: 'atencao', daysLeft: 35, lastUpdate: '2024-06-14' },

    '5-1': { status: 'regular', daysLeft: 70, lastUpdate: '2024-06-24' },
    '5-2': { status: 'atencao', daysLeft: 18, lastUpdate: '2024-06-12' },
    '5-3': { status: 'regular', daysLeft: 130, lastUpdate: '2024-06-20' },
    '5-4': { status: 'regular', daysLeft: 95, lastUpdate: '2024-06-18' },
    '5-5': { status: 'regular', daysLeft: 280, lastUpdate: '2024-06-25' },
    '5-6': { status: 'regular', daysLeft: 60, lastUpdate: '2024-06-15' },
    '5-7': { status: 'exigencia', daysLeft: 12, lastUpdate: '2024-06-22' },
    '5-8': { status: 'regular', daysLeft: 105, lastUpdate: '2024-06-19' },

    '6-1': { status: 'vencido', daysLeft: -15, lastUpdate: '2024-05-25' },
    '6-2': { status: 'regular', daysLeft: 125, lastUpdate: '2024-06-23' },
    '6-3': { status: 'atencao', daysLeft: 27, lastUpdate: '2024-06-13' },
    '6-4': { status: 'regular', daysLeft: 88, lastUpdate: '2024-06-17' },
    '6-5': { status: 'regular', daysLeft: 220, lastUpdate: '2024-06-24' },
    '6-6': { status: 'protocolo', daysLeft: null, lastUpdate: '2024-06-27' },
    '6-7': { status: 'regular', daysLeft: 175, lastUpdate: '2024-06-20' },
    '6-8': { status: 'regular', daysLeft: 65, lastUpdate: '2024-06-16' },
  };

  const getStatusInfo = (status, daysLeft) => {
    const configs = {
      regular: { 
        color: 'bg-green-500', 
        icon: CheckCircle, 
        label: 'Regular',
        intensity: daysLeft > 60 ? 'bg-green-500' : 'bg-green-400'
      },
      atencao: { 
        color: 'bg-orange-500', 
        icon: AlertCircle, 
        label: 'Precisa de Atenção',
        intensity: daysLeft < 20 ? 'bg-orange-600' : 'bg-orange-400'
      },
      vencido: { 
        color: 'bg-red-500', 
        icon: XCircle, 
        label: 'Vencido',
        intensity: Math.abs(daysLeft) > 10 ? 'bg-red-600' : 'bg-red-500'
      },
      protocolo: { 
        color: 'bg-blue-500', 
        icon: FileText, 
        label: 'Protocolo',
        intensity: 'bg-blue-500'
      },
      exigencia: { 
        color: 'bg-purple-500', 
        icon: Clock, 
        label: 'Em Exigência',
        intensity: daysLeft < 10 ? 'bg-purple-600' : 'bg-purple-500'
      }
    };
    return configs[status] || configs.regular;
  };

  const filteredEstablishments = useMemo(() => {
    return establishments.filter(est => 
      est.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      est.cnpj.includes(searchTerm) ||
      est.city.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm]);

  const getStatusCounts = () => {
    const counts = { regular: 0, atencao: 0, vencido: 0, protocolo: 0, exigencia: 0 };
    Object.values(documentStatus).forEach(doc => {
      counts[doc.status]++;
    });
    return counts;
  };

  const statusCounts = getStatusCounts();

  const Tooltip = ({ cell, establishment, document }) => {
    if (!cell) return null;
    
    const statusInfo = getStatusInfo(cell.status, cell.daysLeft);
    const Icon = statusInfo.icon;
    
    return (
      <div className=""absolute z-50 bg-gray-900 text-white p-3 rounded-lg shadow-xl border border-gray-700 min-w-64"">
        <div className=""flex items-center gap-2 mb-2"">
          <Icon size={16} className=""text-gray-300"" />
          <span className=""font-semibold"">{statusInfo.label}</span>
        </div>
        <div className=""space-y-1 text-sm"">
          <div><strong>Estabelecimento:</strong> {establishment.name}</div>
          <div><strong>Documento:</strong> {document.name}</div>
          <div><strong>CNPJ:</strong> {establishment.cnpj}</div>
          <div><strong>Localização:</strong> {establishment.city}/{establishment.region}</div>
          {cell.daysLeft !== null && (
            <div><strong>Dias restantes:</strong> 
              <span className={cell.daysLeft < 0 ? 'text-red-400' : cell.daysLeft < 30 ? 'text-orange-400' : 'text-green-400'}>
                {cell.daysLeft < 0 ? ` ${Math.abs(cell.daysLeft)} dias vencido` : ` ${cell.daysLeft} dias`}
              </span>
            </div>
          )}
          <div><strong>Última atualização:</strong> {cell.lastUpdate}</div>
        </div>
      </div>
    );
  };

  return (
    <div className=""min-h-screen bg-gray-50 p-6"">
      {/* Header */}
      <div className=""mb-6"">
        <div className=""flex items-center gap-3 mb-4"">
          <div className=""w-10 h-10 bg-green-500 rounded-full flex items-center justify-center"">
            <span className=""text-white font-bold text-lg"">F</span>
          </div>
          <h1 className=""text-2xl font-bold text-gray-800"">Farmakeep</h1>
        </div>
        
        {/* Status Cards */}
        <div className=""grid grid-cols-5 gap-4 mb-6"">
          <div className=""bg-green-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.regular}</div>
            <div className=""text-sm opacity-90"">REGULAR</div>
          </div>
          <div className=""bg-orange-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.atencao}</div>
            <div className=""text-sm opacity-90"">PRECISA DE ATENÇÃO</div>
          </div>
          <div className=""bg-red-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.vencido}</div>
            <div className=""text-sm opacity-90"">VENCIDO</div>
          </div>
          <div className=""bg-blue-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.protocolo}</div>
            <div className=""text-sm opacity-90"">PROTOCOLO</div>
          </div>
          <div className=""bg-purple-500 text-white p-4 rounded-lg text-center"">
            <div className=""text-2xl font-bold"">{statusCounts.exigencia}</div>
            <div className=""text-sm opacity-90"">EM EXIGÊNCIA</div>
          </div>
        </div>
      </div>

      {/* Controls */}
      <div className=""bg-white rounded-lg shadow-sm border p-4 mb-6"">
        <div className=""flex flex-wrap gap-4 items-center justify-between"">
          <div className=""flex gap-4 items-center"">
            <div className=""relative"">
              <Search className=""absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"" size={16} />
              <input
                type=""text""
                placeholder=""Buscar estabelecimento, CNPJ ou cidade...""
                className=""pl-10 pr-4 py-2 border border-gray-300 rounded-lg w-80""
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
            
            <select 
              className=""px-4 py-2 border border-gray-300 rounded-lg""
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
            >
              <option value=""all"">Todos os Status</option>
              <option value=""vencido"">Apenas Vencidos</option>
              <option value=""atencao"">Precisa Atenção</option>
              <option value=""regular"">Regulares</option>
            </select>
          </div>

          <div className=""flex gap-2 items-center"">
            <span className=""text-sm text-gray-600"">Visualização:</span>
            <select 
              className=""px-3 py-2 border border-gray-300 rounded-lg text-sm""
              value={viewMode}
              onChange={(e) => setViewMode(e.target.value)}
            >
              <option value=""compact"">Compacta</option>
              <option value=""normal"">Normal</option>
              <option value=""detailed"">Detalhada</option>
            </select>
          </div>
        </div>
      </div>

      {/* Grid */}
      <div className=""bg-white rounded-lg shadow-sm border overflow-hidden"">
        <div className=""overflow-x-auto"">
          <div className=""min-w-max"">
            {/* Header Row */}
            <div className=""flex bg-gray-100 border-b sticky top-0 z-10"">
              <div className=""w-48 p-3 font-medium text-gray-700 border-r bg-gray-100"">
                <div className=""flex items-center gap-2"">
                  <Building size={16} />
                  Estabelecimentos
                </div>
              </div>
              {documents.map((doc) => (
                <div key={doc.id} className=""w-24 p-2 text-center border-r bg-gray-100"">
                  <div className=""transform -rotate-45 origin-center text-xs font-medium text-gray-700 whitespace-nowrap"">
                    {doc.name}
                  </div>
                  {doc.critical && (
                    <div className=""mt-1 flex justify-center"">
                      <AlertCircle size={12} className=""text-red-500"" />
                    </div>
                  )}
                </div>
              ))}
            </div>

            {/* Data Rows */}
            {filteredEstablishments.map((establishment) => (
              <div key={establishment.id} className=""flex border-b hover:bg-gray-50"">
                <div className=""w-48 p-3 border-r bg-white sticky left-0"">
                  <div className=""font-medium text-gray-900"">{establishment.name}</div>
                  <div className=""text-xs text-gray-500"">{establishment.cnpj}</div>
                  <div className=""text-xs text-gray-500"">{establishment.city}/{establishment.region}</div>
                </div>
                
                {documents.map((document) => {
                  const cellKey = `${establishment.id}-${document.id}`;
                  const cellData = documentStatus[cellKey];
                  const statusInfo = getStatusInfo(cellData?.status || 'regular', cellData?.daysLeft);
                  const Icon = statusInfo.icon;
                  
                  return (
                    <div
                      key={document.id}
                      className=""w-24 h-16 border-r relative cursor-pointer group""
                      onMouseEnter={() => setHoveredCell({ cellData, establishment, document, cellKey })}
                      onMouseLeave={() => setHoveredCell(null)}
                      onClick={() => setSelectedCell({ cellData, establishment, document })}
                    >
                      <div className={`w-full h-full ${statusInfo.intensity} flex items-center justify-center transition-all duration-200 group-hover:scale-110 group-hover:shadow-lg`}>
                        <Icon size={viewMode === 'compact' ? 12 : viewMode === 'detailed' ? 20 : 16} className=""text-white"" />
                        {viewMode === 'detailed' && cellData?.daysLeft !== null && (
                          <span className=""absolute bottom-1 text-xs text-white font-bold"">
                            {cellData.daysLeft < 0 ? cellData.daysLeft : `+${cellData.daysLeft}`}
                          </span>
                        )}
                      </div>
                      
                      {document.critical && (
                        <div className=""absolute -top-1 -right-1 w-3 h-3 bg-red-600 rounded-full border border-white""></div>
                      )}
                    </div>
                  );
                })}
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Tooltip */}
      {hoveredCell && (
        <div className=""fixed pointer-events-none z-50"" style={{ 
          left: `${Math.min(window.innerWidth - 300, window.event?.clientX + 10)}px`, 
          top: `${Math.max(10, window.event?.clientY - 50)}px` 
        }}>
          <Tooltip 
            cell={hoveredCell.cellData} 
            establishment={hoveredCell.establishment} 
            document={hoveredCell.document} 
          />
        </div>
      )}

      {/* Side Panel */}
      {selectedCell && (
        <div className=""fixed right-0 top-0 h-full w-80 bg-white shadow-2xl border-l z-40 transform transition-transform duration-300"">
          <div className=""p-6"">
            <div className=""flex items-center justify-between mb-4"">
              <h3 className=""text-lg font-semibold"">Detalhes do Documento</h3>
              <button 
                onClick={() => setSelectedCell(null)}
                className=""text-gray-400 hover:text-gray-600""
              >
                <XCircle size={20} />
              </button>
            </div>
            
            <div className=""space-y-4"">
              <div>
                <label className=""text-sm font-medium text-gray-600"">Estabelecimento</label>
                <div className=""mt-1 text-gray-900"">{selectedCell.establishment.name}</div>
              </div>
              
              <div>
                <label className=""text-sm font-medium text-gray-600"">Documento</label>
                <div className=""mt-1 text-gray-900"">{selectedCell.document.name}</div>
              </div>
              
              <div>
                <label className=""text-sm font-medium text-gray-600"">Status</label>
                <div className=""mt-1"">
                  <span className={`inline-flex items-center gap-2 px-3 py-1 rounded-full text-sm text-white ${getStatusInfo(selectedCell.cellData?.status, selectedCell.cellData?.daysLeft).color}`}>
                    {React.createElement(getStatusInfo(selectedCell.cellData?.status, selectedCell.cellData?.daysLeft).icon, { size: 16 })}
                    {getStatusInfo(selectedCell.cellData?.status, selectedCell.cellData?.daysLeft).label}
                  </span>
                </div>
              </div>
              
              {selectedCell.cellData?.daysLeft !== null && (
                <div>
                  <label className=""text-sm font-medium text-gray-600"">Situação</label>
                  <div className=""mt-1 text-gray-900"">
                    {selectedCell.cellData.daysLeft < 0 
                      ? `Vencido há ${Math.abs(selectedCell.cellData.daysLeft)} dias`
                      : `${selectedCell.cellData.daysLeft} dias restantes`
                    }
                  </div>
                </div>
              )}
              
              <div>
                <label className=""text-sm font-medium text-gray-600"">Última Atualização</label>
                <div className=""mt-1 text-gray-900"">{selectedCell.cellData?.lastUpdate}</div>
              </div>
              
              <div className=""pt-4 space-y-2"">
                <button className=""w-full bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700"">
                  Ver Documento
                </button>
                <button className=""w-full bg-green-600 text-white py-2 px-4 rounded-lg hover:bg-green-700"">
                  Atualizar Status
                </button>
                <button className=""w-full bg-gray-600 text-white py-2 px-4 rounded-lg hover:bg-gray-700"">
                  Histórico
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default FarmakeepGrid;"
