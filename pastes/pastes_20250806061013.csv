id,title,username,language,date,content
aiESk9zf,Untitled,hnzbyte,PHP,Wednesday 6th of August 2025 12:08:50 AM CDT,"<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Illuminate\Database\Console\Seeds\WithoutModelEvents;

class UpdatedDataParameterSeeder extends Seeder
{
    /**
     * Run the database seeds.
     * Data berdasarkan tabel Excel yang telah diperbaharui
     *
     * @return void
     */
    public function run()
    {
        // Hapus data lama
        DB::table('data_parameter')->truncate();
        
        DB::table('data_parameter')->insert([
            // ============ BIOTA LAUT ============
            
            // 1. Kecerahan - ID 1 (No formula in SoT)
            [
                'id_parameter' => 1,
                'satuan' => 'm',
                'baku_mutu' => '6',
                'nilai' => '6',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 2. Kekeruhan - ID 2 (SoT #23)
            [
                'id_parameter' => 2,
                'satuan' => 'NTU',
                'baku_mutu' => '5',
                'nilai' => '5',
                'coefficient_a' => 100,
                'coefficient_b' => -0.04463,
                'y0' => 80,
            ],
            
            // 3. Kebauan - ID 3 (No formula in SoT)
            [
                'id_parameter' => 3,
                'satuan' => '',
                'baku_mutu' => 'Alami',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 4. Padatan Tersuspensi Total (TSS) - ID 4 (SoT #24)
            [
                'id_parameter' => 4,
                'satuan' => 'mg/L',
                'baku_mutu' => '20',
                'nilai' => '20',
                'coefficient_a' => 100,
                'coefficient_b' => -0.01116,
                'y0' => 80,
            ],
            
            // 5. Sampah - ID 5 (No formula in SoT)
            [
                'id_parameter' => 5,
                'satuan' => '',
                'baku_mutu' => 'Nihil',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 6. Suhu - ID 6 (SoT #7)
            [
                'id_parameter' => 6,
                'satuan' => '°C',
                'baku_mutu' => '29',
                'nilai' => '29',
                'coefficient_a' => 100,
                'coefficient_b' => -0.00769,
                'y0' => 80,
            ],
            
            // 7. Lapisan Minyak - ID 7 (No formula in SoT)
            [
                'id_parameter' => 7,
                'satuan' => '',
                'baku_mutu' => 'Nihil',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 8. pH - ID 8 (No formula in SoT)
            [
                'id_parameter' => 8,
                'satuan' => '',
                'baku_mutu' => '7-8.5',
                'nilai' => '7.75',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 9. Salinitas - ID 9 (SoT #8)
            [
                'id_parameter' => 9,
                'satuan' => '‰',
                'baku_mutu' => '33.5',
                'nilai' => '33.5',
                'coefficient_a' => 100,
                'coefficient_b' => -0.00666,
                'y0' => 80,
            ],
            
            // 10. Oksigen Terlarut (DO) - ID 10 (No formula in SoT)
            [
                'id_parameter' => 10,
                'satuan' => 'mg/L',
                'baku_mutu' => '>5',
                'nilai' => '5',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 11. BOD5 - BIOTA LAUT - ID 11 (SoT #1)
            [
                'id_parameter' => 11,
                'satuan' => 'mg/L',
                'baku_mutu' => '20',
                'nilai' => '20',
                'coefficient_a' => 100,
                'coefficient_b' => -0.01116,
                'y0' => 80,
            ],
            
            // 12. Amonia total (NH3-N) - BIOTA LAUT - ID 12 (SoT #2)
            [
                'id_parameter' => 12,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.3',
                'nilai' => '0.3',
                'coefficient_a' => 100,
                'coefficient_b' => -0.74381,
                'y0' => 80,
            ],
            
            // 13. Ortofosfat (PO4-P) - BIOTA LAUT - ID 13 (SoT #3)
            [
                'id_parameter' => 13,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.015',
                'nilai' => '0.015',
                'coefficient_a' => 100,
                'coefficient_b' => -14.87624,
                'y0' => 80,
            ],
            
            // 14. Nitrat (NO3-N) - BIOTA LAUT - ID 14 (SoT #4)
            [
                'id_parameter' => 14,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.06',
                'nilai' => '0.06',
                'coefficient_a' => 100,
                'coefficient_b' => -3.71906,
                'y0' => 80,
            ],
            
            // 15. Sianida (CN-) - BIOTA LAUT - ID 15 (SoT #5)
            [
                'id_parameter' => 15,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.5',
                'nilai' => '0.5',
                'coefficient_a' => 100,
                'coefficient_b' => -0.44629,
                'y0' => 80,
            ],
            
            // 16. Sulfida (H2S) - BIOTA LAUT - ID 16 (SoT #6)
            [
                'id_parameter' => 16,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.01',
                'nilai' => '0.01',
                'coefficient_a' => 100,
                'coefficient_b' => -22.31436,
                'y0' => 80,
            ],
            
            // 17. Hidrokarbon Petroleum Total (TPH) - BIOTA LAUT - ID 17 (SoT #9)
            [
                'id_parameter' => 17,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.02',
                'nilai' => '0.02',
                'coefficient_a' => 100,
                'coefficient_b' => -11.15718,
                'y0' => 80,
            ],
            
            // 18. Fenol total - BIOTA LAUT - ID 18 (SoT #10)
            [
                'id_parameter' => 18,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.002',
                'nilai' => '0.002',
                'coefficient_a' => 100,
                'coefficient_b' => -111.57178,
                'y0' => 80,
            ],
            
            // 19. PAH - BIOTA LAUT - ID 19 (SoT #11)
            [
                'id_parameter' => 19,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.003',
                'nilai' => '0.003',
                'coefficient_a' => 100,
                'coefficient_b' => -74.38118,
                'y0' => 80,
            ],
            
            // 20. PCB - BIOTA LAUT - ID 20 (SoT #12)
            [
                'id_parameter' => 20,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.01',
                'nilai' => '0.01',
                'coefficient_a' => 100,
                'coefficient_b' => -22.31436,
                'y0' => 80,
            ],
            
            // 21. Surfaktan (MBAS) - BIOTA LAUT - ID 21 (SoT #13)
            [
                'id_parameter' => 21,
                'satuan' => 'mg/L',
                'baku_mutu' => '1',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => -0.22314,
                'y0' => 80,
            ],
            
            // 22. Minyak dan Lemak - BIOTA LAUT - ID 22 (SoT #14)
            [
                'id_parameter' => 22,
                'satuan' => 'mg/L',
                'baku_mutu' => '1',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => -0.22314,
                'y0' => 80,
            ],
            
            // 23-27. Pestisida (BHC, DDT, Endrin, Toxaphan, TBT) - No formulas in SoT
            [
                'id_parameter' => 23, // BHC
                'satuan' => 'mg/L',
                'baku_mutu' => '0.0001',
                'nilai' => '0.0001',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 24, // DDT
                'satuan' => 'mg/L',
                'baku_mutu' => '0.0001',
                'nilai' => '0.0001',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 25, // Endrin
                'satuan' => 'mg/L',
                'baku_mutu' => '0.0001',
                'nilai' => '0.0001',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 26, // Toxaphan
                'satuan' => 'mg/L',
                'baku_mutu' => '0.0001',
                'nilai' => '0.0001',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 27, // TBT
                'satuan' => 'mg/L',
                'baku_mutu' => '0.0001',
                'nilai' => '0.0001',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 28. Raksa (Hg) - BIOTA LAUT - ID 28 (SoT #15)
            [
                'id_parameter' => 28,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.001',
                'nilai' => '0.001',
                'coefficient_a' => 100,
                'coefficient_b' => -223.14355,
                'y0' => 80,
            ],
            
            // 29. Kromium heksavalen (Cr(VI)) - BIOTA LAUT - ID 29 (SoT #16)
            [
                'id_parameter' => 29,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.005',
                'nilai' => '0.005',
                'coefficient_a' => 100,
                'coefficient_b' => -44.62871,
                'y0' => 80,
            ],
            
            // 30. Arsen (As) - BIOTA LAUT - ID 30 (SoT #17)
            [
                'id_parameter' => 30,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.012',
                'nilai' => '0.012',
                'coefficient_a' => 100,
                'coefficient_b' => -18.59530,
                'y0' => 80,
            ],
            
            // 31. Kadmium (Cd) - BIOTA LAUT - ID 31 (SoT #18)
            [
                'id_parameter' => 31,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.001',
                'nilai' => '0.001',
                'coefficient_a' => 100,
                'coefficient_b' => -223.14355,
                'y0' => 80,
            ],
            
            // 32. Tembaga (Cu) - BIOTA LAUT - ID 32 (SoT #19)
            [
                'id_parameter' => 32,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.008',
                'nilai' => '0.008',
                'coefficient_a' => 100,
                'coefficient_b' => -27.89294,
                'y0' => 80,
            ],
            
            // 33. Timbal (Pb) - BIOTA LAUT - ID 33 (SoT #20)
            [
                'id_parameter' => 33,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.008',
                'nilai' => '0.008',
                'coefficient_a' => 100,
                'coefficient_b' => -27.89294,
                'y0' => 80,
            ],
            
            // 34. Seng (Zn) - BIOTA LAUT - ID 34 (SoT #21)
            [
                'id_parameter' => 34,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.05',
                'nilai' => '0.05',
                'coefficient_a' => 100,
                'coefficient_b' => -4.46287,
                'y0' => 80,
            ],
            
            // 35. Nikel (Ni) - BIOTA LAUT - ID 35 (SoT #22)
            [
                'id_parameter' => 35,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.05',
                'nilai' => '0.05',
                'coefficient_a' => 100,
                'coefficient_b' => -4.46287,
                'y0' => 80,
            ],
            
            // 36. Coliform Total - BIOTA LAUT - ID 36 (SoT #26)
            [
                'id_parameter' => 36,
                'satuan' => 'MPN/100ml',
                'baku_mutu' => '1000',
                'nilai' => '1000',
                'coefficient_a' => 100,
                'coefficient_b' => -0.00022,
                'y0' => 80,
            ],
            
            // 37. Patogen - ID 37 (No formula in SoT)
            [
                'id_parameter' => 37,
                'satuan' => '',
                'baku_mutu' => 'Nihil',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 38. Fitoplankton - BIOTA LAUT - ID 38 (SoT #27)
            [
                'id_parameter' => 38,
                'satuan' => 'sel/L',
                'baku_mutu' => '1000',
                'nilai' => '1000',
                'coefficient_a' => 100,
                'coefficient_b' => -0.00022,
                'y0' => 80,
            ],
            
            // 39. Radioaktivitas - BIOTA LAUT - ID 39 (SoT #28)
            [
                'id_parameter' => 39,
                'satuan' => 'Bq/L',
                'baku_mutu' => '4',
                'nilai' => '4',
                'coefficient_a' => 100,
                'coefficient_b' => -0.05579,
                'y0' => 80,
            ],
            
            // ============ WISATA BAHARI ============
            
            // 40. Warna - ID 40 (No formula in SoT)
            [
                'id_parameter' => 40,
                'satuan' => 'Pt-Co',
                'baku_mutu' => '15',
                'nilai' => '15',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 41. Kecerahan - ID 41 (No formula in SoT)
            [
                'id_parameter' => 41,
                'satuan' => 'm',
                'baku_mutu' => '6',
                'nilai' => '6',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 42. Kekeruhan - ID 42 (No specific formula for wisata in SoT)
            [
                'id_parameter' => 42,
                'satuan' => 'NTU',
                'baku_mutu' => '5',
                'nilai' => '5',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 43. Kebauan - ID 43 (No formula in SoT)
            [
                'id_parameter' => 43,
                'satuan' => '',
                'baku_mutu' => 'Alami',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 44. Padatan tersuspensi total - ID 44 (No specific formula for wisata in SoT)
            [
                'id_parameter' => 44,
                'satuan' => 'mg/L',
                'baku_mutu' => '20',
                'nilai' => '20',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 45. Sampah - ID 45 (No formula in SoT)
            [
                'id_parameter' => 45,
                'satuan' => '',
                'baku_mutu' => 'Nihil',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 46. Suhu - ID 46 (No specific formula for wisata in SoT)
            [
                'id_parameter' => 46,
                'satuan' => '°C',
                'baku_mutu' => '28-30',
                'nilai' => '29',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 47. Lapisan Minyak - ID 47 (No formula in SoT)
            [
                'id_parameter' => 47,
                'satuan' => '',
                'baku_mutu' => 'Nihil',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 48. pH - ID 48 (No formula in SoT)
            [
                'id_parameter' => 48,
                'satuan' => '',
                'baku_mutu' => '7-8.5',
                'nilai' => '7.75',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 49. Salinitas - ID 49 (No specific formula for wisata in SoT)
            [
                'id_parameter' => 49,
                'satuan' => '‰',
                'baku_mutu' => 'Alami',
                'nilai' => '33.5',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 50. Oksigen terlarut - ID 50 (No formula in SoT)
            [
                'id_parameter' => 50,
                'satuan' => 'mg/L',
                'baku_mutu' => '>5',
                'nilai' => '5',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 51. BOD5 - WISATA BAHARI - ID 51 (SoT #1)
            [
                'id_parameter' => 51,
                'satuan' => 'mg/L',
                'baku_mutu' => '10',
                'nilai' => '10',
                'coefficient_a' => 100,
                'coefficient_b' => -0.02231,
                'y0' => 80,
            ],
            
            // 52. Amonia total (NH3-N) - WISATA BAHARI - ID 52 (SoT #2)
            [
                'id_parameter' => 52,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.02',
                'nilai' => '0.02',
                'coefficient_a' => 100,
                'coefficient_b' => -11.15718,
                'y0' => 80,
            ],
            
            // 53. Ortofosfat (PO4-P) - WISATA BAHARI - ID 53 (Same as biota - SoT #3)
            [
                'id_parameter' => 53,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.015',
                'nilai' => '0.015',
                'coefficient_a' => 100,
                'coefficient_b' => -14.87624,
                'y0' => 80,
            ],
            
            // 54. Nitrat (NO3-N) - WISATA BAHARI - ID 54 (Same as biota - SoT #4)
            [
                'id_parameter' => 54,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.06',
                'nilai' => '0.06',
                'coefficient_a' => 100,
                'coefficient_b' => -3.71906,
                'y0' => 80,
            ],
            
            // 55. Sulfida (H2S) - WISATA BAHARI - ID 55 (SoT #6)
            [
                'id_parameter' => 55,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.002',
                'nilai' => '0.002',
                'coefficient_a' => 100,
                'coefficient_b' => -111.57178,
                'y0' => 80,
            ],
            
            // 56. Fenol total - WISATA BAHARI - ID 56 (SoT #10)
            [
                'id_parameter' => 56,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.001',
                'nilai' => '0.001',
                'coefficient_a' => 100,
                'coefficient_b' => -223.14355,
                'y0' => 80,
            ],
            
            // 57. PAH - WISATA BAHARI - ID 57 (SoT #11)
            [
                'id_parameter' => 57,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.003',
                'nilai' => '0.003',
                'coefficient_a' => 100,
                'coefficient_b' => -74.38118,
                'y0' => 80,
            ],
            
            // 58. PCB - WISATA BAHARI - ID 58 (SoT #12)
            [
                'id_parameter' => 58,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.005',
                'nilai' => '0.005',
                'coefficient_a' => 100,
                'coefficient_b' => -44.62871,
                'y0' => 80,
            ],
            
            // 59. Surfaktan (MBAS) - WISATA BAHARI - ID 59 (SoT #13)
            [
                'id_parameter' => 59,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.001',
                'nilai' => '0.001',
                'coefficient_a' => 100,
                'coefficient_b' => -223.14355,
                'y0' => 80,
            ],
            
            // 60. Minyak dan Lemak - WISATA BAHARI - ID 60 (No formula in SoT)
            [
                'id_parameter' => 60,
                'satuan' => 'mg/L',
                'baku_mutu' => '1',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 61-69. Pestisida - No formulas in SoT
            [
                'id_parameter' => 61, // BHC
                'satuan' => 'mg/L',
                'baku_mutu' => '0.006',
                'nilai' => '0.006',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 62, // Aldrin/Dieldrin
                'satuan' => 'mg/L',
                'baku_mutu' => '0.0017',
                'nilai' => '0.0017',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 63, // Chlordane
                'satuan' => 'mg/L',
                'baku_mutu' => '0.0043',
                'nilai' => '0.0043',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 64, // DDT
                'satuan' => 'mg/L',
                'baku_mutu' => '0.001',
                'nilai' => '0.001',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 65, // Heptachlor
                'satuan' => 'mg/L',
                'baku_mutu' => '0.0036',
                'nilai' => '0.0036',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 66, // Lindane
                'satuan' => 'mg/L',
                'baku_mutu' => '0.095',
                'nilai' => '0.095',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 67, // Methoxy-chlor
                'satuan' => 'mg/L',
                'baku_mutu' => '0.035',
                'nilai' => '0.035',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 68, // Endrin
                'satuan' => 'mg/L',
                'baku_mutu' => '0.037',
                'nilai' => '0.037',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            [
                'id_parameter' => 69, // Toxaphan
                'satuan' => 'mg/L',
                'baku_mutu' => '0.005',
                'nilai' => '0.005',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 70. Hg - WISATA BAHARI - ID 70 (SoT #15)
            [
                'id_parameter' => 70,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.002',
                'nilai' => '0.002',
                'coefficient_a' => 100,
                'coefficient_b' => -111.57178,
                'y0' => 80,
            ],
            
            // 71. Cr(VI) - WISATA BAHARI - ID 71 (SoT #16)
            [
                'id_parameter' => 71,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.002',
                'nilai' => '0.002',
                'coefficient_a' => 100,
                'coefficient_b' => -111.57178,
                'y0' => 80,
            ],
            
            // 72. As - WISATA BAHARI - ID 72 (SoT #17)
            [
                'id_parameter' => 72,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.025',
                'nilai' => '0.025',
                'coefficient_a' => 100,
                'coefficient_b' => -8.92574,
                'y0' => 80,
            ],
            
            // 73. Cd - WISATA BAHARI - ID 73 (SoT #18)
            [
                'id_parameter' => 73,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.002',
                'nilai' => '0.002',
                'coefficient_a' => 100,
                'coefficient_b' => -111.57178,
                'y0' => 80,
            ],
            
            // 74. Cu - WISATA BAHARI - ID 74 (SoT #19)
            [
                'id_parameter' => 74,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.05',
                'nilai' => '0.05',
                'coefficient_a' => 100,
                'coefficient_b' => -4.46287,
                'y0' => 80,
            ],
            
            // 75. Pb - WISATA BAHARI - ID 75 (SoT #20)
            [
                'id_parameter' => 75,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.005',
                'nilai' => '0.005',
                'coefficient_a' => 100,
                'coefficient_b' => -44.62871,
                'y0' => 80,
            ],
            
            // 76. Zn - WISATA BAHARI - ID 76 (SoT #21)
            [
                'id_parameter' => 76,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.095',
                'nilai' => '0.095',
                'coefficient_a' => 100,
                'coefficient_b' => -2.34888,
                'y0' => 80,
            ],
            
            // 77. Ni - WISATA BAHARI - ID 77 (SoT #22)
            [
                'id_parameter' => 77,
                'satuan' => 'mg/L',
                'baku_mutu' => '0.075',
                'nilai' => '0.075',
                'coefficient_a' => 100,
                'coefficient_b' => -2.97525,
                'y0' => 80,
            ],
            
            // 78. Fecal Coliform - WISATA BAHARI - ID 78 (SoT #25)
            [
                'id_parameter' => 78,
                'satuan' => 'MPN/100ml',
                'baku_mutu' => '200',
                'nilai' => '200',
                'coefficient_a' => 100,
                'coefficient_b' => -0.00112,
                'y0' => 80,
            ],
            
            // 79. Coliform Total - WISATA BAHARI - ID 79 (SoT #26 - same as biota)
            [
                'id_parameter' => 79,
                'satuan' => 'MPN/100ml',
                'baku_mutu' => '1000',
                'nilai' => '1000',
                'coefficient_a' => 100,
                'coefficient_b' => -0.00022,
                'y0' => 80,
            ],
            
            // 80. Patogen - ID 80 (No formula in SoT)
            [
                'id_parameter' => 80,
                'satuan' => '',
                'baku_mutu' => 'Nihil',
                'nilai' => '1',
                'coefficient_a' => 100,
                'coefficient_b' => null,
                'y0' => 80,
            ],
            
            // 81. Fitoplankton - WISATA BAHARI - ID 81 (SoT #27 - same as biota)
            [
                'id_parameter' => 81,
                'satuan' => 'sel/L',
                'baku_mutu' => '1000',
                'nilai' => '1000',
                'coefficient_a' => 100,
                'coefficient_b' => -0.00022,
                'y0' => 80,
            ],
            
            // 82. Radioaktivitas - WISATA BAHARI - ID 82 (SoT #28 - same as biota)
            [
                'id_parameter' => 82,
                'satuan' => 'Bq/L',
                'baku_mutu' => '4',
                'nilai' => '4',
                'coefficient_a' => 100,
                'coefficient_b' => -0.05579,
                'y0' => 80,
            ],
        ]);
    }
}
"
sNC1FTa0,Adapter,shivam197,Java,Tuesday 5th of August 2025 10:54:37 PM CDT,"/**
 * A simple adapter class that converts between input and output POJOs
 * All classes are contained within this single file for simplicity
 */
public class PojoAdapter {
    
    /**
     * Sample Input POJO representing user data from an external system
     */
    public static class InputPojo {
        private String firstName;
        private String lastName;
        private int age;
        private String emailAddress;
        private String phoneNumber;
        
        // Constructors
        public InputPojo() {}
        
        public InputPojo(String firstName, String lastName, int age, String emailAddress, String phoneNumber) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.age = age;
            this.emailAddress = emailAddress;
            this.phoneNumber = phoneNumber;
        }
        
        // Getters and Setters
        public String getFirstName() { return firstName; }
        public void setFirstName(String firstName) { this.firstName = firstName; }
        
        public String getLastName() { return lastName; }
        public void setLastName(String lastName) { this.lastName = lastName; }
        
        public int getAge() { return age; }
        public void setAge(int age) { this.age = age; }
        
        public String getEmailAddress() { return emailAddress; }
        public void setEmailAddress(String emailAddress) { this.emailAddress = emailAddress; }
        
        public String getPhoneNumber() { return phoneNumber; }
        public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
        
        @Override
        public String toString() {
            return ""InputPojo{"" +
                    ""firstName='"" + firstName + '\'' +
                    "", lastName='"" + lastName + '\'' +
                    "", age="" + age +
                    "", emailAddress='"" + emailAddress + '\'' +
                    "", phoneNumber='"" + phoneNumber + '\'' +
                    '}';
        }
    }
    
    /**
     * Sample Output POJO representing user data for internal system
     */
    public static class OutputPojo {
        private String fullName;
        private String ageCategory;
        private String email;
        private String contact;
        private boolean isAdult;
        
        // Constructors
        public OutputPojo() {}
        
        public OutputPojo(String fullName, String ageCategory, String email, String contact, boolean isAdult) {
            this.fullName = fullName;
            this.ageCategory = ageCategory;
            this.email = email;
            this.contact = contact;
            this.isAdult = isAdult;
        }
        
        // Getters and Setters
        public String getFullName() { return fullName; }
        public void setFullName(String fullName) { this.fullName = fullName; }
        
        public String getAgeCategory() { return ageCategory; }
        public void setAgeCategory(String ageCategory) { this.ageCategory = ageCategory; }
        
        public String getEmail() { return email; }
        public void setEmail(String email) { this.email = email; }
        
        public String getContact() { return contact; }
        public void setContact(String contact) { this.contact = contact; }
        
        public boolean isAdult() { return isAdult; }
        public void setAdult(boolean adult) { isAdult = adult; }
        
        @Override
        public String toString() {
            return ""OutputPojo{"" +
                    ""fullName='"" + fullName + '\'' +
                    "", ageCategory='"" + ageCategory + '\'' +
                    "", email='"" + email + '\'' +
                    "", contact='"" + contact + '\'' +
                    "", isAdult="" + isAdult +
                    '}';
        }
    }
    
    /**
     * Adapter method that converts InputPojo to OutputPojo
     * @param input The input POJO to convert
     * @return The converted output POJO
     */
    public static OutputPojo adaptInputToOutput(InputPojo input) {
        if (input == null) {
            return null;
        }
        
        OutputPojo output = new OutputPojo();
        
        // Combine first and last name into full name
        output.setFullName(input.getFirstName() + "" "" + input.getLastName());
        
        // Categorize age
        output.setAgeCategory(categorizeAge(input.getAge()));
        
        // Map email address to email
        output.setEmail(input.getEmailAddress());
        
        // Map phone number to contact
        output.setContact(input.getPhoneNumber());
        
        // Determine if adult (18 or older)
        output.setAdult(input.getAge() >= 18);
        
        return output;
    }
    
    /**
     * Helper method to categorize age into groups
     * @param age The age to categorize
     * @return The age category as a string
     */
    private static String categorizeAge(int age) {
        if (age < 13) {
            return ""Child"";
        } else if (age < 18) {
            return ""Teenager"";
        } else if (age < 65) {
            return ""Adult"";
        } else {
            return ""Senior"";
        }
    }
    
    /**
     * Reverse adapter method that converts OutputPojo back to InputPojo
     * Note: Some data loss may occur due to different field structures
     * @param output The output POJO to convert
     * @return The converted input POJO
     */
    public static InputPojo adaptOutputToInput(OutputPojo output) {
        if (output == null) {
            return null;
        }
        
        InputPojo input = new InputPojo();
        
        // Split full name back to first and last name (simple approach)
        String[] nameParts = output.getFullName().split("" "", 2);
        input.setFirstName(nameParts.length > 0 ? nameParts[0] : """");
        input.setLastName(nameParts.length > 1 ? nameParts[1] : """");
        
        // Age cannot be precisely determined from category, so we'll use defaults
        input.setAge(getDefaultAgeForCategory(output.getAgeCategory()));
        
        // Map email back to email address
        input.setEmailAddress(output.getEmail());
        
        // Map contact back to phone number
        input.setPhoneNumber(output.getContact());
        
        return input;
    }
    
    /**
     * Helper method to get a default age for an age category
     * @param category The age category
     * @return A default age for that category
     */
    private static int getDefaultAgeForCategory(String category) {
        switch (category) {
            case ""Child"": return 10;
            case ""Teenager"": return 16;
            case ""Adult"": return 30;
            case ""Senior"": return 70;
            default: return 25;
        }
    }
    
    /**
     * Main method to demonstrate the adapter functionality
     */
    public static void main(String[] args) {
        // Create a sample input POJO
        InputPojo input = new InputPojo(""John"", ""Doe"", 25, ""john.doe@email.com"", ""+1-555-123-4567"");
        
        System.out.println(""Original Input POJO:"");
        System.out.println(input);
        System.out.println();
        
        // Adapt input to output
        OutputPojo output = adaptInputToOutput(input);
        
        System.out.println(""Adapted Output POJO:"");
        System.out.println(output);
        System.out.println();
        
        // Adapt output back to input (demonstrating reverse adaptation)
        InputPojo reversedInput = adaptOutputToInput(output);
        
        System.out.println(""Reverse Adapted Input POJO:"");
        System.out.println(reversedInput);
        System.out.println();
        
        // Test with different age categories
        System.out.println(""Testing different age categories:"");
        
        InputPojo child = new InputPojo(""Alice"", ""Smith"", 8, ""alice@email.com"", ""555-0001"");
        System.out.println(""Child: "" + adaptInputToOutput(child));
        
        InputPojo teenager = new InputPojo(""Bob"", ""Johnson"", 16, ""bob@email.com"", ""555-0002"");
        System.out.println(""Teenager: "" + adaptInputToOutput(teenager));
        
        InputPojo senior = new InputPojo(""Carol"", ""Williams"", 70, ""carol@email.com"", ""555-0003"");
        System.out.println(""Senior: "" + adaptInputToOutput(senior));
    }
}"
8jah3XFu,Samson_CSharp_Act,Ramirez_RD,C#,Tuesday 5th of August 2025 10:09:41 PM CDT,"using System;
using System.Collections.Generic;
class Samson_Act
    {
        static void Main(string[] args)
        {
            List<int> nums = new List<int>();
            int input;
            Console.WriteLine(""Enter numbers one by one (enter 0 to finish):"");
            do
            {
                Console.Write(""Enter a number: "");
                string userInput = Console.ReadLine();

                if (int.TryParse(userInput, out input))
                {
                    if (input != 0)
                    {
                        nums.Add(input);
                    }
                }
                else
                {
                    Console.WriteLine(""Invalid input. Please enter a valid number."");
                    input = -1;
                }
            } while (input != 0);
            if (nums.Count > 0)
            {
                int smallest = nums[0];
                int largest = nums[0];
                foreach (int num in nums)
                {
                    if (num < smallest)
                        smallest = num;
                    if (num > largest)
                        largest = num;
                }

                Console.WriteLine($""\nSmallest number: {smallest}"");
                Console.WriteLine($""Largest number: {largest}"");
            }
            else
            {
                Console.WriteLine(""\nNo numbers were entered."");
            }
        }
}"
xMXfyxCy,binkies3d change for app,petar_bonov,JavaScript,Tuesday 5th of August 2025 05:23:52 AM CDT,"document.addEventListener(""DOMContentLoaded"", function () {
    if (document.body.classList.contains(""app"")) {
        const fullscreenButtons = document.querySelectorAll("".binkies-fullscreen-button"");
        if (fullscreenButtons.length > 0) fullscreenButtons[1].click();
    }
});"
cTZssPEZ,Untitled,Goriec,HTML,Tuesday 5th of August 2025 05:09:05 AM CDT,"                         <size=55><color=#ff0000>[</color><color=#ffffff>P</color><color=#ff0000>L</color><color=#ffffff>]</color> </size><b><size=55><color=#ffb300>P</color><color=#ffb300>o</color><color=#ff8c00>l</color><color=#ff8c00>i</color><color=#ff8c00>g</color><color=#ff4d00>o</color><color=#ff4d00>n</color>
_________________________
             <size=200%><color=blue>INFORMACJE</color>
     <size=150%>Discord <link=""https://discord.gg/xPnUYTaJ7c""><color=red><u>Poligon HardRP</u></color></link></size>
     <size=150%>Regulamin <link=""https://docs.google.com/document/d/1v84WhsXl7k_CPzqIrPAqeumhx7DjUUfH7u_jSXI8jt8/edit?tab=t.0#heading=h.tluzatcj8c8""><color=#00ff00><u>Google Docs</u></color></link></size>
     <size=150%>Kontakt:<color=yellow> t48970990@gmail.com</color>
 
======================================"
GcX9DJHY,Untitled,armedjack,C#,Tuesday 5th of August 2025 04:34:51 AM CDT,"Filternot behaves like Single entity filter: Leopotam.EcsLite.EcsFilter. There is more than one instance at a time
UnityEngine.Debug:LogError (object)
CyberTemple.DarkSwitch.EcsExtensions:GetSingle (Leopotam.EcsLite.EcsFilter) (at Assets/CyberTemple/DarkSwitch/Runtime/Common/Utils/EcsExtensions.cs:35)
CyberTemple.DarkSwitch.CoreGame.Buildings.RayNetwork.RayNetworkRendererSystem:UpdateConstructionPreviewRay () (at Assets/CyberTemple/DarkSwitch/Runtime/CoreGame/RayNetwork/RayNetworkRendererSystem.cs:131)
CyberTemple.DarkSwitch.CoreGame.Buildings.RayNetwork.RayNetworkRendererSystem:FixedTick () (at Assets/CyberTemple/DarkSwitch/Runtime/CoreGame/RayNetwork/RayNetworkRendererSystem.cs:124)
Zenject.FixedTickablesTaskUpdater:UpdateItem (Zenject.IFixedTickable) (at ./Packages/one.cyber-temple.zenject/Runtime/Managers/T askUpdater.cs:195)
Zenject.TaskUpdater`1<Zenject.IFixedTickable>:UpdateRange (int,int) (at ./Packages/one.cyber-temple.zenject/Runtime/Managers/TaskUpdater.cs:75)
Zenject.TaskUpdater`1<Zenject.IFixedTickable>:UpdateAll () (at ./Packages/one.cyber-temple.zenject/Runtime/Managers/TaskUpdater.cs:59)
Zenject.TickableManager:Update () (at ./Packages/one.cyber-temple.zenject/Runtime/Managers/TickableManager.cs:210)
Zenject.MonoKernel:Update () (at ./Packages/one.cyber-temple.zenject/Runtime/Kernels/MonoKernel.cs:69)


Exception: Cant touch destroyed entity.
CyberTemple.DarkSwitch.CoreGame.Buildings.RayNetwork.RayNetworkRendererSystem.UpdateConstructionPreviewRay () (at Assets/CyberTemple/DarkSwitch/Runtime/CoreGame/RayNetwork/RayNetworkRendererSystem.cs:181)
CyberTemple.DarkSwitch.CoreGame.Buildings.RayNetwork.RayNetworkRendererSystem.FixedTick () (at Assets/CyberTemple/DarkSwitch/Runtime/CoreGame/RayNetwork/RayNetworkRendererSystem.cs:124)
Zenject.FixedTickablesTaskUpdater.UpdateItem (Zenject.IFixedTickable task) (at ./Packages/one.cyber-temple.zenject/Runtime/Managers/TaskUpdater.cs:195)
Zenject.TaskUpdater`1[TTask].UpdateRange (System.Int32 minPriority, System.Int32 maxPriority) (at ./Packages/one.cyber-temple.zenject/Runtime/Managers/TaskUpdater.cs:75)
Zenject.TaskUpdater`1[TTask].UpdateAll () (at ./Packages/one.cyber-temple.zenject/Runtime/Managers/TaskUpdater.cs:59)
Zenject.TickableManager.Update () (at ./Packages/one.cyber-temple.zenject/Runtime/Managers/TickableManager.cs:210)
Zenject.MonoKernel.Update () (at ./Packages/one.cyber-temple.zenject/Runtime/Kernels/MonoKernel.cs:69)

"
GTCtyQTZ,Install GTM,victoriaSD,JavaScript,Tuesday 5th of August 2025 04:16:53 AM CDT,"//Install Google Tag Manager
//Copy the code below and paste it onto every page of your website.
//1. Paste this code as high in the <head> of the page as possible:
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MDXR2DP5');</script>
<!-- End Google Tag Manager -->

//2. Paste this code immediately after the opening <body> tag:

<!-- Google Tag Manager (noscript) -->
<noscript><iframe src=""https://www.googletagmanager.com/ns.html?id=GTM-MDXR2DP5""
height=""0"" width=""0"" style=""display:none;visibility:hidden""></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->"
rWWdf3kV,vpn,Sn0wBaall,Bash,Tuesday 5th of August 2025 03:48:55 AM CDT,"#!/bin/bash

## COLOURS

greenColour=""\e[0;32m""
endColour=""\033[0m\e[0m""
redColour=""\e[0;31m""
blueColour=""\e[0;34m""
yellowColour=""\e[0;33m""
purpleColour=""\e[0;35m""
turquoiseColour=""\e[0;36m""
grayColour=""\e[0;37m""

## BOLD COLOURS

BgreenColour=""\e[1;32m""
BendColour=""\033[0m\e[0m""
BredColour=""\e[1;31m""
BblueColour=""\e[1;34m""
ByellowColour=""\e[1;33m""
BpurpleColour=""\e[1;35m""
BturquoiseColour=""\e[1;36m""
BgrayColour=""\e[1;37m""

if [ $(id -u) != 0 ];then

	echo -e ""\n${BredColour}[!] Run the script with root privileges!!!${endColour}\n""
  exit 1
fi

if [ ""$1"" == ""c"" ];then
  openvpn /home/user/Vpn/vpn.ovpn &>/dev/null & disown
elif [ ""$1"" == ""d"" ];then
  pkill openvpn
else
  echo -e ""\n${BgreenColour}[~]${endColour}${grayColour} Usage:${endColour}""
  echo -e ""\t ${BpurpleColour}$0${endColour}${BgreenColour} [c]${endColour}${greenColour}onnect${endColour}${BredColour} [d]${endColour}${redColour}isconnect${endColour}\n""
fi"
tTPDDueh,TextToSpeech.ps1,Combreal,PowerShell,Tuesday 5th of August 2025 03:24:58 AM CDT,"Add-Type –AssemblyName ""System.Speech""
$SpeechSynthesizer = New-Object –TypeName ""System.Speech.Synthesis.SpeechSynthesizer""
$SpeechSynthesizer.SetOutputToWaveFile('C:\Temp\jure.wav')
$SpeechSynthesizer.Speak(""J'ai juré."")"
jWHfNANB,resp-izin,tamami,JSON,Tuesday 5th of August 2025 02:46:48 AM CDT,"{
    ""Message"": ""Izin Reklame created successfully"",
    ""Data"": {
        ""Id"": ""113d07f7-aad8-4bd9-5373-08ddd3f3fbe3"",
        ""IzinReklamePerpanjangan"": 0,
        ""AtasNama"": ""Tester Bapenda"",
        ""Lokasi"": ""Brebes uji coba"",
        ""Jumlah"": 1,
        ""UkuranTinggi"": 240,
        ""UkuranLebar"": 140,
        ""Jenis"": ""Reklame"",
        ""Materi"": ""Materi uji coba"",
        ""Retribusi"": 0,
        ""Izin"": {
            ""Id"": ""9b4e1898-797c-4548-357f-08ddd3f3fbd4"",
            ""Nomor"": ""TempWAzbQaVQSwF6xLQ"",
            ""TempNomor"": ""ql9ONbemosg6REA"",
            ""TglTerbit"": ""0001-01-01"",
            ""TglBerakhir"": ""0001-01-01"",
            ""TglVerifikasi"": ""0001-01-01"",
            ""FileName"": """",
            ""Signed"": false,
            ""DownloadCode"": ""jAw63Npb"",
            ""Usaha"": {
                ""Id"": ""53333fcd-6a76-4403-2c71-08dd65fe87c0"",
                ""Nib"": ""1111111111111111111111111"",
                ""Nama"": ""BAPENDA"",
                ""NoTelpon"": ""085786509374"",
                ""Email"": ""hendrawan.ashari@gmail.com"",
                ""Alamat"": ""Brebes"",
                ""Rt"": 1,
                ""Rw"": 1,
                ""Desa"": null,
                ""PenanggungJawab"": null,
                ""PenanggungJawabId"": ""3d166eb0-e761-41aa-1284-08dd65fe63ed"",
                ""LegalPath"": ""Legal_iEsDbMFUEIwzV6e_200.2.2 e-179 POLPUM  Rakor Bela Negara.pdf"",
                ""DesaId"": ""7237d685-6c73-4226-8641-08dd65f824ef""
            },
            ""UsahaId"": ""53333fcd-6a76-4403-2c71-08dd65fe87c0"",
            ""JenisIzin"": {
                ""Id"": ""eac1e625-f5e6-4a85-0700-08dd7b2b9e15"",
                ""Kode"": ""RKLME"",
                ""Nama"": ""REKLAME"",
                ""PemohonEditPath"": """",
                ""PendaftaranEditPath"": ""/PendaftaranIzinReklame/EditIzin"",
                ""VerifikasiEditPath"": ""/VerifikasiIzinReklame/VerifikasiIzin"",
                ""PencetakanEditPath"": ""/PencetakanIzinReklame/SetNumber"",
                ""PencetakanIzinPath"": ""/PencetakanIzinReklame/PrintIzin""
            },
            ""JenisIzinId"": ""eac1e625-f5e6-4a85-0700-08dd7b2b9e15"",
            ""Terbit"": false
        },
        ""IzinId"": ""9b4e1898-797c-4548-357f-08ddd3f3fbd4"",
        ""IzinReklameLampiran"": []
    }
}"
ugd8MQ6w,Untitled,FlyingFrog,Lua,Tuesday 5th of August 2025 02:35:43 AM CDT,"local PushHandler = {}

local Debris = game:GetService(""Debris"")
local Players = game:GetService(""Players"")
local Ragdoll = require(game.ServerScriptService:WaitForChild(""RagdollModule""))

function PushHandler.PushPlayer(tool, player, target, mouseCFrame, damage, reload, ragdollReload)
	if not tool.Enabled then return end
	tool.Enabled = false

	local targetChar = target and target.Parent
	if not targetChar then return end

	local humanoid = targetChar:FindFirstChildWhichIsA(""Humanoid"")
	local root = targetChar:FindFirstChild(""HumanoidRootPart"")

	if humanoid and root and humanoid.Health > 0 then
		local force = tool:FindFirstChild(""PushForce"") and tool.PushForce.Value or 100

		
		root:SetNetworkOwner(nil)
		root.Velocity = mouseCFrame.LookVector * force
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)

		
		local animate = targetChar:FindFirstChild(""Animate"")
		if animate then
			animate.Disabled = true
		end

		
		humanoid:ChangeState(Enum.HumanoidStateType.Physics)

		
		Ragdoll.EnableRagdoll(targetChar)

		
		task.delay(ragdollReload.Value, function()
			Ragdoll.DisableRagdoll(targetChar)
		end)

		local animate = targetChar:FindFirstChild(""Animate"")
		if animate then
			animate.Disabled = false
		end

		
		local tag = Instance.new(""ObjectValue"")
		tag.Name = ""creator""
		tag.Value = player
		tag.Parent = humanoid
		Debris:AddItem(tag, 5)

		
		if not humanoid:FindFirstChild(""DiedConnected"") then
			local diedFlag = Instance.new(""BoolValue"")
			diedFlag.Name = ""DiedConnected""
			diedFlag.Parent = humanoid

			humanoid.Died:Connect(function()
				local killerTag = humanoid:FindFirstChild(""creator"")
				if killerTag and killerTag.Value and killerTag.Value:FindFirstChild(""leaderstats"") then
					local killer = killerTag.Value
					local kills = killer.leaderstats:FindFirstChild(""Kills"")
					local achievements = killer:FindFirstChild(""Achievements"")

					if kills and achievements then
						kills.Value += 1

						for _, achievement in ipairs(achievements:GetChildren()) do
							local match = string.match(achievement.Name, ""^Убить (%d+) человек$"")
							if match then
								local requiredKills = tonumber(match)
								if requiredKills and kills.Value >= requiredKills and achievement:IsA(""BoolValue"") and not achievement.Value then
									achievement.Value = true
								end
							end
						end
					end
				end
			end)
		end

		
		humanoid:TakeDamage(damage.Value)

		
		local targetPlayer = Players:GetPlayerFromCharacter(targetChar)
		if targetPlayer then
			root:SetNetworkOwner(targetPlayer)
		end

		
		local sounds = tool:FindFirstChild(""PushSounds"")
		if sounds and #sounds:GetChildren() > 0 then
			local chosen = sounds:GetChildren()[math.random(1, #sounds:GetChildren())]:Clone()
			chosen.Parent = player.Character:FindFirstChild(""HumanoidRootPart"")
			chosen.PlayOnRemove = true
			chosen:Destroy()
		end

		
		local pushes = player:FindFirstChild(""leaderstats"") and player.leaderstats:FindFirstChild(""pushed"")
		if pushes then
			pushes.Value += 1
		end
	end
	print(reload.Value)
	task.delay(reload.Value, function()
		tool.Enabled = true
	end)
end

return PushHandler
"
6VNE7N8f,req-izin,tamami,JSON,Tuesday 5th of August 2025 02:34:14 AM CDT,"{
    ""IzinReklamePerpanjangan"":0,
    ""Nomor"":""Temp01"",
    ""Nib"":""1111111111111111111111111"",
    ""Jenis"": ""Reklame"",
    ""Lokasi"": ""Brebes uji coba"",
    ""Materi"": ""Materi uji coba"",
    ""UrlKtp"": ""default.png"",
    ""AtasNama"": ""Tester Bapenda"",
    ""UrlLegal"": ""default.pdf"",
    ""UrlLampiran"": ""default.pdf"",
    ""Jumlah"": 1,
    ""UkuranTinggi"": 240,
    ""UkuranLebar"": 140
}"
TtjsFtBq,Zane Hub,ZenoDX12,Lua,Monday 4th of August 2025 11:29:02 PM CDT,"-- Zane Hub | Grow a Garden (Fully Ready)
-- UI Rayfield – ChatGPT edition

loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Rayfield/main/source'))()

local rs = game:GetService(""ReplicatedStorage"")
local Window = Rayfield:CreateWindow({
   Name = ""Zane Hub | Grow a Garden"",
   LoadingTitle = ""Zane Hub"",
   LoadingSubtitle = ""By ChatGPT"",
   ConfigurationSaving = { Enabled = true, FolderName = ""ZaneHub"", FileName = ""GrowAGarden"" },
   Discord = { Enabled = false },
   KeySystem = false,
})

-- Main Tab: Farming
local MainTab = Window:CreateTab(""Main"", 4483362458)
MainTab:CreateToggle({
   Name = ""Auto Water"",
   CurrentValue = false,
   Callback = function(state)
      getgenv().AutoWater = state
      while getgenv().AutoWater do
         pcall(function()
            rs.Events.WaterPlant:FireServer()
         end)
         task.wait(0.5)
      end
   end,
})

-- Pets Tab: Hatch Basic/Middle/Legendary
local PetTab = Window:CreateTab(""🐾 Pets"", 4483362458)
for _, tier in ipairs({""Basic"", ""Middle"", ""Legendary""}) do
   PetTab:CreateToggle({
      Name = ""Auto Hatch "" .. tier .. "" Pet"",
      CurrentValue = false,
      Callback = function(value)
         getgenv()[""Auto"" .. tier .. ""Pet""] = value
         while getgenv()[""Auto"" .. tier .. ""Pet""] do
            pcall(function()
               rs.Events.HatchPet:InvokeServer(tier)
            end)
            task.wait(1.5)
         end
      end,
   })
end

-- Shop Tab: Auto Buy Items
local ShopTab = Window:CreateTab(""🛒 Shop"", 4483362458)
local shopList = {
   {Name = ""Seed"", Event = ""BuySeed""},
   {Name = ""Gear"", Event = ""BuyGear""},
   {Name = ""Egg"", Event = ""BuyEgg""},
   {Name = ""Cosmetic"", Event = ""BuyCosmetic""},
   {Name = ""Traveling Merchant"", Event = ""BuyFromMerchant""}
}
for _, item in ipairs(shopList) do
   ShopTab:CreateToggle({
      Name = ""Auto Buy "" .. item.Name,
      CurrentValue = false,
      Callback = function(value)
         getgenv()[""AutoBuy"" .. item.Name] = value
         while getgenv()[""AutoBuy"" .. item.Name] do
            pcall(function()
               rs.Events[item.Event]:FireServer()
            end)
            task.wait(1.5)
         end
      end,
   })
end

print(""✅ Zane Hub Loaded Successfully"")"
t27Cneun,add custom menu with custom url to jnews acocunt left menu,arie_cristianD,PHP,Monday 4th of August 2025 09:08:26 PM CDT,"add_filter(
	'jnews_account_page_endpoint',
	'j_add_custom_account_menu',
	99
);

function j_add_custom_account_menu( $enpoint ) {

	/* add custom menu on account menu item  */
	$enpoint['custom_account_menu'] = array(
		'slug'  => 'custom-menu',  /* custom menu slug */
		'label' => 'custom_menu',
		'title' => esc_html__( 'Custom Menu', 'jnews' ),  /* custom menu Title */
	);

	return $enpoint;
}


add_action( 'jnews_account_right_content', 'j_custom_account_menu' );

function j_custom_account_menu() {
	global $wp;

	if ( is_user_logged_in() ) {
		if ( isset( $wp->query_vars['account'] ) && ! empty( $wp->query_vars['account'] ) ) {
			$query_vars = explode( '/', $wp->query_vars['account'] );

			if ( 'custom-menu' === $query_vars[0] ) {  /* check menu slug */
				wp_redirect( 'https://jnews.io/' );
			}
		}
	}
}
"
bG7atmF9,show premium post lists,arie_cristianD,MySQL,Monday 4th of August 2025 08:39:14 PM CDT,"SELECT p.ID, p.post_title, p.post_date
FROM wp_posts p
INNER JOIN wp_postmeta pm 
    ON p.ID = pm.post_id
WHERE p.post_type = 'post'
  AND p.post_status = 'publish'
  AND pm.meta_key = 'jnews_paywall_metabox'
  AND pm.meta_value LIKE '%""enable_premium_post"";s:1:""1""%'
ORDER BY p.post_date DESC
"
rukQevm5,Sensor Controller rev_02,pleasedontcode,Arduino,Monday 4th of August 2025 06:35:41 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Sensor Controller
	- Source Code compiled for: Arduino Opta WiFi
	- Source Code created on: 2025-08-04 23:34:26

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Implement a gas detection alert system on Arduino */
	/* Opta WiFi, utilizing MQ3 sensor for alcohol */
	/* detection and potentiometer for sensitivity */
	/* adjustment, with RGB LED indicators for alert */
	/* status. */
/****** END SYSTEM REQUIREMENTS *****/


/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
// No external libraries are used in this project.

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void updateOutputs();

// ***** DEFINITION OF ANALOG INPUT PINS *****
const uint8_t mq3_MQ3_AOUT_PIN_A0 = A0;
const uint8_t pot_Potentiometer_Vout_PIN_A2 = A2;

// ***** DEFINITION OF DIGITAL OUTPUT PINS *****
const uint8_t led_LEDRGB_Red_PIN_D0 = 0;
const uint8_t led_LEDRGB_Green_PIN_D1 = 1;
const uint8_t led_LEDRGB_Blue_PIN_D2 = 2;

// ***** DEFINITION OF OUTPUT RAW VARIABLES *****
/***** used to store raw data *****/
bool led_LEDRGB_Red_PIN_D0_rawData = 0;
bool led_LEDRGB_Green_PIN_D1_rawData = 0;
bool led_LEDRGB_Blue_PIN_D2_rawData = 0;

// ***** DEFINITION OF OUTPUT PHYSICAL VARIABLES *****
/***** used to store data after characteristic curve transformation *****/
float led_LEDRGB_Red_PIN_D0_phyData = 0.0;
float led_LEDRGB_Green_PIN_D1_phyData = 0.0;
float led_LEDRGB_Blue_PIN_D2_phyData = 0.0;

// Additional variables for gas detection
float gasThreshold = 0.5; // Default threshold, can be adjusted via potentiometer
float gasSensorValue = 0.0;

void setup(void)
{
  // Initialize serial communication for debugging
  Serial.begin(9600);

  // Configure pins
  pinMode(mq3_MQ3_AOUT_PIN_A0, INPUT);
  pinMode(pot_Potentiometer_Vout_PIN_A2, INPUT);

  pinMode(led_LEDRGB_Red_PIN_D0, OUTPUT);
  pinMode(led_LEDRGB_Green_PIN_D1, OUTPUT);
  pinMode(led_LEDRGB_Blue_PIN_D2, OUTPUT);
}

void loop(void)
{
  // Read the potentiometer for sensitivity adjustment
  int potValue = analogRead(pot_Potentiometer_Vout_PIN_A2);
  // Map potentiometer value (0-1023) to a threshold range (e.g., 0.1 to 1.0)
  gasThreshold = map(potValue, 0, 1023, 10, 100) / 100.0;

  // Read the MQ3 sensor value
  int sensorReading = analogRead(mq3_MQ3_AOUT_PIN_A0);
  // Convert sensor reading to voltage (assuming 5V ADC reference)
  float sensorVoltage = sensorReading * (5.0 / 1023.0);

  // For simplicity, normalize sensor voltage to a 0-1 range
  gasSensorValue = sensorVoltage / 5.0;

  // Determine if gas level exceeds threshold
  if (gasSensorValue >= gasThreshold)
  {
    // Gas detected - turn on red LED
    led_LEDRGB_Red_PIN_D0_rawData = HIGH;
    led_LEDRGB_Green_PIN_D1_rawData = LOW;
    led_LEDRGB_Blue_PIN_D2_rawData = LOW;
  }
  else
  {
    // No gas detected - turn on green LED
    led_LEDRGB_Red_PIN_D0_rawData = LOW;
    led_LEDRGB_Green_PIN_D1_rawData = HIGH;
    led_LEDRGB_Blue_PIN_D2_rawData = LOW;
  }

  // Update physical data if needed (here we directly use rawData for simplicity)
  updateOutputs();

  // Optional: print values for debugging
  Serial.print(""Gas Sensor Value: "");
  Serial.print(gasSensorValue);
  Serial.print("" Threshold: "");
  Serial.println(gasThreshold);

  delay(200); // Delay for stability
}

void updateOutputs()
{
  digitalWrite(led_LEDRGB_Red_PIN_D0, led_LEDRGB_Red_PIN_D0_rawData);
  digitalWrite(led_LEDRGB_Green_PIN_D1, led_LEDRGB_Green_PIN_D1_rawData);
  digitalWrite(led_LEDRGB_Blue_PIN_D2, led_LEDRGB_Blue_PIN_D2_rawData);
}
"
L0Gwyrnf,Sensor Controller rev_01,pleasedontcode,Arduino,Monday 4th of August 2025 06:33:57 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Sensor Controller
	- Source Code NOT compiled for: Arduino Opta WiFi
	- Source Code created on: 2025-08-04 23:33:46

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Implement a gas detection alert system on Arduino */
	/* Opta WiFi, utilizing MQ3 sensor for alcohol */
	/* detection and potentiometer for sensitivity */
	/* adjustment, with RGB LED indicators for alert */
	/* status. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
// No external libraries are used in this project.

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void updateOutputs();

// ***** DEFINITION OF ANALOG INPUT PINS *****
const uint8_t mq3_MQ3_AOUT_PIN_A0 = A0;
const uint8_t pot_Potentiometer_Vout_PIN_A2 = A2;

// ***** DEFINITION OF DIGITAL OUTPUT PINS *****
const uint8_t led_LEDRGB_Red_PIN_D0 = 0;
const uint8_t led_LEDRGB_Green_PIN_D1 = 1;
const uint8_t led_LEDRGB_Blue_PIN_D2 = 2;

// ***** DEFINITION OF OUTPUT RAW VARIABLES *****
/***** used to store raw data *****/
bool led_LEDRGB_Red_PIN_D0_rawData = 0;
bool led_LEDRGB_Green_PIN_D1_rawData = 0;
bool led_LEDRGB_Blue_PIN_D2_rawData = 0;

// ***** DEFINITION OF OUTPUT PHYSICAL VARIABLES *****
/***** used to store data after characteristic curve transformation *****/
float led_LEDRGB_Red_PIN_D0_phyData = 0.0;
float led_LEDRGB_Green_PIN_D1_phyData = 0.0;
float led_LEDRGB_Blue_PIN_D2_phyData = 0.0;

// Additional variables for gas detection
float gasThreshold = 0.5; // Default threshold, can be adjusted via potentiometer
float gasSensorValue = 0.0;

void setup(void)
{
  // Initialize serial communication for debugging
  Serial.begin(9600);

  // Configure pins
  pinMode(mq3_MQ3_AOUT_PIN_A0, INPUT);
  pinMode(pot_Potentiometer_Vout_PIN_A2, INPUT);

  pinMode(led_LEDRGB_Red_PIN_D0, OUTPUT);
  pinMode(led_LEDRGB_Green_PIN_D1, OUTPUT);
  pinMode(led_LEDRGB_Blue_PIN_D2, OUTPUT);
}

void loop(void)
{
  // Read the potentiometer for sensitivity adjustment
  int potValue = analogRead(pot_Potentiometer_Vout_PIN_A2);
  // Map potentiometer value (0-1023) to a threshold range (e.g., 0.1 to 1.0)
  gasThreshold = map(potValue, 0, 1023, 10, 100) / 100.0;

  // Read the MQ3 sensor value
  int sensorReading = analogRead(mq3_MQ3_AOUT_PIN_A0);
  // Convert sensor reading to voltage (assuming 5V ADC reference)
  float sensorVoltage = sensorReading * (5.0 / 1023.0);

  // For simplicity, normalize sensor voltage to a 0-1 range
  gasSensorValue = sensorVoltage / 5.0;

  // Determine if gas level exceeds threshold
  if (gasSensorValue >= gasThreshold)
  {
    // Gas detected - turn on red LED
    led_LEDRGB_Red_PIN_D0_rawData = HIGH;
    led_LEDRGB_Green_PIN_D1_rawData = LOW;
    led_LEDRGB_Blue_PIN_D2_rawData = LOW;
  }
  else
  {
    // No gas detected - turn on green LED
    led_LEDRGB_Red_PIN_D0_rawData = LOW;
    led_LEDRGB_Green_PIN_D1_rawData = HIGH;
    led_LEDRGB_Blue_PIN_D2_rawData = LOW;
  }

  // Update physical data if needed (here we directly use rawData for simplicity)
  updateOutputs();

  // Optional: print values for debugging
  Serial.print(""Gas Sensor Value: "");
  Serial.print(gasSensorValue);
  Serial.print("" Threshold: "");
  Serial.println(gasThreshold);

  delay(200); // Delay for stability
}

void updateOutputs()
{
  digitalWrite(led_LEDRGB_Red_PIN_D0, led_LEDRGB_Red_PIN_D0_rawData);
  digitalWrite(led_LEDRGB_Green_PIN_D1, led_LEDRGB_Green_PIN_D1_rawData);
  digitalWrite(led_LEDRGB_Blue_PIN_D2, led_LEDRGB_Blue_PIN_D2_rawData);
}
"
guKaAX25,Drug Lab2 Novi mod,cccc69,Pawn,Monday 4th of August 2025 06:13:08 PM CDT,"//Map Exported with Texture Studio By: [uL]Pottus, Crayder, Svyatoy, encoder, devhub/////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Map Information////////////////////////////////////////////////////////////////////////////////////////////////
/*
	Exported on ""2025-08-05 01:11:30"" by ""Candy""
	Created by ""Candy""
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Objects////////////////////////////////////////////////////////////////////////////////////////////////////////
new tmpobjid, object_world = -1, object_int = -1;
tmpobjid = CreateDynamicObject(8661, 1620.873413, 996.642211, 1474.628295, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""ab_stripped_floor"", 0xFFCCCCCC);
tmpobjid = CreateDynamicObject(19445, 1639.806152, 998.867431, 1473.589233, 180.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1637.058837, 1001.137634, 1476.368896, 0.000007, 0.000000, 89.999977, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1639.790649, 989.368713, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19445, 1630.176757, 989.367004, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(8661, 1617.063720, 996.642211, 1478.728271, 180.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""carp20S"", 0xFFCCCCCC);
tmpobjid = CreateDynamicObject(19445, 1627.438842, 1001.137634, 1476.368896, 0.000014, 0.000000, 89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1620.546752, 989.367004, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18980, 1635.047485, 997.283874, 1478.607788, 89.999992, 89.999992, -89.999992, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18980, 1635.052490, 997.283874, 1478.602783, 89.999992, 89.999992, -89.999992, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFAAAAAA);
tmpobjid = CreateDynamicObject(18980, 1626.177124, 1001.201293, 1478.605834, 89.999992, 166.631469, -76.631500, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18980, 1626.177124, 1001.206298, 1478.600830, 89.999992, 166.631469, -76.631500, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFAAAAAA);
tmpobjid = CreateDynamicObject(18980, 1626.177124, 989.335021, 1478.605834, 89.999992, 11.617459, -101.617469, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18980, 1626.177124, 989.330017, 1478.600830, 89.999992, 11.617459, -101.617469, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFAAAAAA);
tmpobjid = CreateDynamicObject(19480, 1625.029907, 994.565185, 1474.633300, -0.000022, 270.000000, -89.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1613, ""alleyprop"", ""stuffdirtcol"", 0x00000000);
tmpobjid = CreateDynamicObject(945, 1633.148803, 999.939392, 1484.959594, 0.000000, 0.000045, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 16640, ""a51"", ""Metal3_128"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 3, 14651, ""ab_trukstpd"", ""Bow_bar_metal_cabinet"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.088623, 999.728454, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.088623, 1000.028625, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.088623, 1000.198791, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.158691, 999.948547, 1478.708618, -89.999992, 90.000045, 89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 2589, ""ab_ab"", ""ab_sheetSteel"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1630.176757, 1000.557739, 1475.088867, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 10852, ""dockroad_sfse"", ""dt_bmx_grass"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1649.426269, 998.867431, 1473.589233, 180.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19480, 1625.029907, 994.565185, 1474.633300, -0.000022, 270.000000, -89.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1613, ""alleyprop"", ""stuffdirtcol"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1639.765502, 1000.557739, 1475.088867, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 10852, ""dockroad_sfse"", ""dt_bmx_grass"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18066, 1633.228759, 999.728454, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.228759, 1000.028625, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.228759, 1000.198791, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1630.186767, 998.867431, 1473.589233, 180.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1630.186767, 1000.968139, 1473.589233, 180.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1625.446411, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1634.875854, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(945, 1630.148803, 999.939392, 1484.959594, 0.000000, 0.000045, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 16640, ""a51"", ""Metal3_128"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 3, 14651, ""ab_trukstpd"", ""Bow_bar_metal_cabinet"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.088623, 999.728454, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.088623, 1000.028625, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.088623, 1000.198791, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.158691, 999.948547, 1478.708618, -89.999992, 90.000045, 89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 2589, ""ab_ab"", ""ab_sheetSteel"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1649.395019, 1000.557739, 1475.088867, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 10852, ""dockroad_sfse"", ""dt_bmx_grass"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1659.026611, 998.867431, 1473.589233, 180.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18066, 1630.228759, 999.728454, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.228759, 1000.028625, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.228759, 1000.198791, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(945, 1627.148803, 999.939392, 1484.959594, 0.000000, 0.000045, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 16640, ""a51"", ""Metal3_128"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 3, 14651, ""ab_trukstpd"", ""Bow_bar_metal_cabinet"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.088623, 999.728454, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.088623, 1000.028625, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.088623, 1000.198791, 1477.688598, 89.999992, 90.000045, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.158691, 999.948547, 1478.708618, -89.999992, 90.000045, 89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 2589, ""ab_ab"", ""ab_sheetSteel"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1638.446289, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1648.207885, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18066, 1627.228759, 999.728454, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.228759, 1000.028625, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.228759, 1000.198791, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1628.766357, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1631.776123, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1659.858642, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1659.858642, 986.896667, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1641.897338, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(937, 1618.898193, 997.813903, 1475.074829, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12992, ""ce_oldbridge"", ""Gen_Rusty_Poll"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 8618, ""ceasersign"", ""ceaserspillar01_128"", 0x00000000);
tmpobjid = CreateDynamicObject(19092, 1619.474121, 997.445861, 1475.949829, 0.042989, 80.000022, -1.247107, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
tmpobjid = CreateDynamicObject(1551, 1620.581054, 997.645935, 1475.790649, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1546, 1622.557128, 997.699890, 1475.640258, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 1, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(19063, 1618.674072, 998.038879, 1475.965454, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
tmpobjid = CreateDynamicObject(936, 1620.805175, 997.820861, 1475.074829, 0.000007, -0.000020, 179.999725, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12992, ""ce_oldbridge"", ""Gen_Rusty_Poll"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 8618, ""ceasersign"", ""ceaserspillar01_128"", 0x00000000);
tmpobjid = CreateDynamicObject(2108, 1621.091064, 997.559875, 1473.787719, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xF6D6978A);
SetDynamicObjectMaterial(tmpobjid, 2, 3850, ""carshowglass_sfsx"", ""ws_carshowwin1"", 0xEFF86B78);
tmpobjid = CreateDynamicObject(1551, 1621.880126, 998.221862, 1476.393188, -73.134956, 186.907943, -147.636047, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1551, 1622.026123, 998.240905, 1476.819946, -69.488983, 182.136947, 178.750686, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19063, 1622.102050, 998.630920, 1475.965454, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
tmpobjid = CreateDynamicObject(19468, 1621.417236, 998.204895, 1475.637329, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(19092, 1622.122070, 1000.184875, 1475.949829, 0.037989, 79.996025, -1.247107, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
tmpobjid = CreateDynamicObject(1551, 1620.648193, 998.065856, 1476.196899, -0.000007, 90.000022, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1551, 1620.862060, 998.068908, 1475.917602, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1551, 1620.862060, 998.068908, 1475.510375, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(936, 1622.326171, 998.165832, 1475.074829, 0.000020, 0.000007, 89.999855, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12992, ""ce_oldbridge"", ""Gen_Rusty_Poll"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 8618, ""ceasersign"", ""ceaserspillar01_128"", 0x00000000);
tmpobjid = CreateDynamicObject(2002, 1622.088134, 1000.365905, 1474.358032, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, -1, ""none"", ""none"", 0xFFFC6C8D);
tmpobjid = CreateDynamicObject(936, 1622.322998, 1000.046936, 1475.074829, 0.000020, 0.000007, 89.999855, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12992, ""ce_oldbridge"", ""Gen_Rusty_Poll"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 8618, ""ceasersign"", ""ceaserspillar01_128"", 0x00000000);
tmpobjid = CreateDynamicObject(19092, 1620.053222, 998.081848, 1475.949829, 0.037989, 79.996025, -1.247107, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(1650, 1622.606201, 1000.736877, 1475.858032, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFC9E79EA);
tmpobjid = CreateDynamicObject(1644, 1621.831054, 999.925842, 1475.575805, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(1954, 1619.461181, 997.975891, 1475.657836, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xECBCB780);
SetDynamicObjectMaterial(tmpobjid, 2, -1, ""none"", ""none"", 0xFC9E79EA);
tmpobjid = CreateDynamicObject(2108, 1619.396240, 997.934875, 1473.863891, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 2, 3850, ""carshowglass_sfsx"", ""ws_carshowwin1"", 0x00000000);
tmpobjid = CreateDynamicObject(2002, 1621.633056, 997.281921, 1474.358032, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(937, 1621.110107, 992.602783, 1475.076782, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12992, ""ce_oldbridge"", ""Gen_Rusty_Poll"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 8618, ""ceasersign"", ""ceaserspillar01_128"", 0x00000000);
tmpobjid = CreateDynamicObject(19092, 1620.534179, 992.970825, 1475.951782, 0.042989, 80.000022, 178.752746, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
tmpobjid = CreateDynamicObject(1551, 1619.427246, 992.770751, 1475.792602, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1546, 1622.557128, 989.879333, 1475.640258, -0.000007, 0.000029, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 1, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(19063, 1621.334228, 992.377807, 1475.967407, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
tmpobjid = CreateDynamicObject(936, 1619.203125, 992.595825, 1475.076782, 0.000007, -0.000020, -0.000334, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12992, ""ce_oldbridge"", ""Gen_Rusty_Poll"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 8618, ""ceasersign"", ""ceaserspillar01_128"", 0x00000000);
tmpobjid = CreateDynamicObject(2108, 1618.917236, 992.856811, 1473.789672, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xF6D6978A);
SetDynamicObjectMaterial(tmpobjid, 2, 3850, ""carshowglass_sfsx"", ""ws_carshowwin1"", 0xEFF86B78);
tmpobjid = CreateDynamicObject(19445, 1630.135498, 991.637573, 1473.589233, 0.000014, 360.000000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1630.135498, 989.536865, 1473.589233, 0.000014, 360.000000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19063, 1622.102050, 990.810363, 1475.965454, -0.000007, 0.000029, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
tmpobjid = CreateDynamicObject(19468, 1621.842285, 990.221740, 1475.637329, 0.000000, 0.000058, 29.999897, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(19092, 1622.122070, 992.364318, 1475.949829, 0.037989, 79.996032, -1.247107, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
tmpobjid = CreateDynamicObject(1551, 1619.360107, 992.350830, 1476.198852, -0.000006, 90.000022, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1551, 1619.146240, 992.347778, 1475.919555, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1551, 1619.146240, 992.347778, 1475.512329, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(936, 1622.326171, 990.345275, 1475.074829, 0.000029, 0.000007, 89.999832, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12992, ""ce_oldbridge"", ""Gen_Rusty_Poll"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 8618, ""ceasersign"", ""ceaserspillar01_128"", 0x00000000);
tmpobjid = CreateDynamicObject(2002, 1622.088134, 992.545349, 1474.358032, -0.000007, 0.000029, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, -1, ""none"", ""none"", 0xFFFC6C8D);
tmpobjid = CreateDynamicObject(936, 1622.322998, 992.226379, 1475.074829, 0.000029, 0.000007, 89.999832, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12992, ""ce_oldbridge"", ""Gen_Rusty_Poll"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 8618, ""ceasersign"", ""ceaserspillar01_128"", 0x00000000);
tmpobjid = CreateDynamicObject(19092, 1619.955078, 992.334838, 1475.951782, 0.037989, 79.996025, 178.752746, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(1650, 1622.606201, 992.916320, 1475.858032, -0.000007, 0.000029, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFC9E79EA);
tmpobjid = CreateDynamicObject(1644, 1621.831054, 992.105285, 1475.575805, -0.000007, 0.000029, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(1954, 1620.547119, 992.440795, 1475.659790, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xECBCB780);
SetDynamicObjectMaterial(tmpobjid, 2, -1, ""none"", ""none"", 0xFC9E79EA);
tmpobjid = CreateDynamicObject(2108, 1620.612060, 992.481811, 1473.865844, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 2, 3850, ""carshowglass_sfsx"", ""ws_carshowwin1"", 0x00000000);
tmpobjid = CreateDynamicObject(2002, 1618.375244, 993.134765, 1474.359985, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1634.875854, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1625.416381, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1631.555908, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1628.546142, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1630.176757, 989.927551, 1475.088867, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 10852, ""dockroad_sfse"", ""dt_bmx_grass"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(945, 1633.148803, 990.647338, 1484.959594, 0.000000, 0.000052, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 16640, ""a51"", ""Metal3_128"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 3, 14651, ""ab_trukstpd"", ""Bow_bar_metal_cabinet"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.088623, 990.436401, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.088623, 990.736572, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.088623, 990.906738, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.158691, 990.656494, 1478.708618, -89.999992, 90.000061, 89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 2589, ""ab_ab"", ""ab_sheetSteel"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1646.679199, 1001.137390, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1651.418090, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18066, 1633.228759, 990.436401, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.228759, 990.736572, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1633.228759, 990.906738, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(945, 1630.148803, 990.647338, 1484.959594, 0.000000, 0.000052, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 16640, ""a51"", ""Metal3_128"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 3, 14651, ""ab_trukstpd"", ""Bow_bar_metal_cabinet"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.088623, 990.436401, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.088623, 990.736572, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.088623, 990.906738, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.158691, 990.656494, 1478.708618, -89.999992, 90.000061, 89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 2589, ""ab_ab"", ""ab_sheetSteel"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1655.497802, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1645.057128, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18066, 1630.228759, 990.436401, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.228759, 990.736572, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1630.228759, 990.906738, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(945, 1627.148803, 990.647338, 1484.959594, 0.000000, 0.000052, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 16640, ""a51"", ""Metal3_128"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 3, 14651, ""ab_trukstpd"", ""Bow_bar_metal_cabinet"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.088623, 990.436401, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.088623, 990.736572, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.088623, 990.906738, 1477.688598, 89.999992, 90.000061, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.158691, 990.656494, 1478.708618, -89.999992, 90.000061, 89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 2589, ""ab_ab"", ""ab_sheetSteel"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1639.816772, 1000.968139, 1473.589233, 180.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18066, 1627.228759, 990.436401, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.228759, 990.736572, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(18066, 1627.228759, 990.906738, 1477.688598, 89.999992, 90.000076, -89.999961, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""lightblue"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1620.505737, 989.407531, 1478.868530, 0.000000, 179.999984, 179.999984, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1620.505737, 997.257263, 1478.868530, 0.000000, 179.999984, 179.999984, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1620.503784, 992.119140, 1480.957397, 630.000000, 360.000000, 360.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1619.464721, 989.407531, 1478.868530, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1619.464721, 997.257263, 1478.868530, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1619.463256, 997.570007, 1480.957397, -89.999992, 450.000000, 89.999992, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1631.629272, 995.786132, 1478.868530, -0.000014, 179.999984, -89.999969, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1623.779418, 995.784118, 1478.866577, -0.000014, 179.999984, -89.999969, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1631.629272, 994.745117, 1478.868530, -0.000014, 179.999984, -89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1623.779418, 994.743103, 1478.866577, -0.000014, 179.999984, -89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1617.808837, 1001.137634, 1476.368896, 0.000014, 0.000000, 89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1610.916748, 989.367004, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(3761, 1614.638427, 990.859741, 1475.828735, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 3, 16640, ""a51"", ""sw_olddrum1"", 0x00000000);
tmpobjid = CreateDynamicObject(19399, 1613.827270, 998.507446, 1476.368896, 0.000000, 0.000007, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19445, 1613.827270, 988.897949, 1476.368896, 0.000000, 0.000007, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19383, 1613.827270, 995.307922, 1476.368896, 0.000000, 0.000007, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19445, 1613.827270, 1004.907958, 1476.368896, 0.000000, 0.000007, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19480, 1625.029907, 994.565185, 1474.633300, -0.000022, 270.000000, -89.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1613, ""alleyprop"", ""stuffdirtcol"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1608.919799, 996.248291, 1476.368896, 0.000000, 0.000022, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19445, 1608.919799, 986.628479, 1476.368896, 0.000000, 0.000022, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(2236, 1616.294921, 998.010314, 1474.628295, 0.000000, 0.000000, 85.199996, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 16640, ""a51"", ""sw_olddrum1"", 0x00000000);
tmpobjid = CreateDynamicObject(930, 1614.642211, 1000.558532, 1475.098754, 0.000000, 0.000000, 6.399999, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 16640, ""a51"", ""sw_olddrum1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 1736, ""cj_ammo"", ""CJ_Black_metal"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 16640, ""a51"", ""sw_olddrum1"", 0x00000000);
tmpobjid = CreateDynamicObject(18980, 1613.862060, 997.283874, 1478.607788, 89.999992, 179.950531, 0.049417, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18980, 1613.857055, 997.283874, 1478.602783, 89.999992, 179.950531, 0.049417, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFAAAAAA);
tmpobjid = CreateDynamicObject(19092, 1614.824829, 991.078552, 1476.659057, 0.037989, 79.996025, 178.752746, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(19092, 1614.638183, 991.542724, 1476.658203, 0.037989, 79.996025, 178.752746, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(1551, 1615.077026, 990.700805, 1474.844482, -0.000006, 0.000014, 179.999710, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1551, 1615.287231, 990.490722, 1474.864501, -0.000006, 0.000014, 179.999710, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1551, 1615.287231, 989.670471, 1474.864501, -0.000006, 0.000014, 179.999710, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14581, ""ab_mafiasuitea"", ""barbersmir1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1650, 1614.945434, 989.866088, 1475.737915, -0.000007, 0.000029, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFC9E79EA);
tmpobjid = CreateDynamicObject(1650, 1614.945434, 990.126342, 1475.737915, -0.000007, 0.000029, 23.899898, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFC9E79EA);
tmpobjid = CreateDynamicObject(1650, 1614.987670, 990.352600, 1475.737915, -0.000007, 0.000029, 23.899898, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFC9E79EA);
tmpobjid = CreateDynamicObject(19468, 1615.203857, 993.017578, 1477.097534, 0.000000, 0.000058, 29.999897, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(19468, 1614.953613, 993.450927, 1477.097534, 0.000000, 0.000058, 29.999897, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(19468, 1614.893066, 993.115478, 1477.097534, 0.000000, 0.000058, 29.999897, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 11301, ""carshow_sfse"", ""ws_carshowdoor1"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1664.752319, 996.826660, 1476.368896, 0.000000, 0.000000, 270.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19482, 1613.865234, 1000.337585, 1476.537963, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18996, ""mattextures"", ""safetymesh"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1499, 1613.879028, 994.570129, 1474.628295, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12805, ""ce_loadbay"", ""sw_waredoor"", 0x00000000);
tmpobjid = CreateDynamicObject(3109, 1660.023925, 995.091430, 1475.828491, 0.000000, 0.000022, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12805, ""ce_loadbay"", ""sw_waredoor"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(3761, 1610.649414, 991.970764, 1475.828735, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 3, 16640, ""a51"", ""sw_olddrum1"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1608.925659, 991.117370, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1649.446411, 1000.968139, 1473.589233, 180.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1579, 1609.405883, 991.744628, 1477.043823, -0.000007, 0.000036, -0.000097, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs1"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1610.439819, 991.576660, 1477.043823, -0.000029, 0.000018, -46.000011, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs1"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1609.905883, 991.559570, 1477.043823, -0.000036, -0.000003, -87.005836, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs1"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1610.439819, 992.259948, 1477.043823, -0.000006, 0.000019, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs1"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1609.405883, 992.427917, 1477.043823, -0.000018, 0.000009, 133.999969, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs1"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1609.939819, 992.445007, 1477.043823, -0.000019, -0.000003, 92.994056, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs1"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1612.355834, 991.744628, 1477.043823, -0.000007, 0.000050, -0.000097, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs2"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1613.389770, 991.576660, 1477.043823, -0.000040, 0.000029, -46.000011, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs2"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1612.855834, 991.559570, 1477.043823, -0.000050, -0.000003, -87.005790, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs2"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1613.389770, 992.259948, 1477.043823, -0.000006, 0.000006, 179.999664, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs2"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1612.355834, 992.427917, 1477.043823, -0.000009, 0.000000, 133.999969, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs2"", 0x00000000);
tmpobjid = CreateDynamicObject(1579, 1612.889770, 992.445007, 1477.043823, -0.000006, -0.000006, 92.994010, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1575, ""dyn_drugs"", ""drugs2"", 0x00000000);
tmpobjid = CreateDynamicObject(2901, 1613.107421, 992.296508, 1475.857788, 0.000007, 0.000000, 89.999977, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1448, 1612.805053, 992.089904, 1475.508178, 0.000007, 0.000000, 89.999977, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1355, ""break_s_bins"", ""CJ_WOOD_DARK"", 0x00000000);
tmpobjid = CreateDynamicObject(2901, 1612.516967, 992.296508, 1475.857788, 0.000007, 0.000000, 89.999977, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(2901, 1611.686523, 992.296508, 1475.857788, 0.000014, 0.000000, 89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1448, 1611.384155, 992.089904, 1475.508178, 0.000014, 0.000000, 89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1355, ""break_s_bins"", ""CJ_WOOD_DARK"", 0x00000000);
tmpobjid = CreateDynamicObject(2901, 1611.096069, 992.296508, 1475.857788, 0.000014, 0.000000, 89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(2901, 1610.146606, 992.296508, 1475.857788, 0.000022, 0.000000, 89.999931, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1448, 1609.844238, 992.089904, 1475.508178, 0.000022, 0.000000, 89.999931, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1355, ""break_s_bins"", ""CJ_WOOD_DARK"", 0x00000000);
tmpobjid = CreateDynamicObject(2901, 1609.556152, 992.296508, 1475.857788, 0.000022, 0.000000, 89.999931, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, -1, ""none"", ""none"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1715, 1611.380859, 1000.280029, 1474.628295, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 1, 1746, ""cj_sofa"", ""cj_fab3"", 0x00000000);
tmpobjid = CreateDynamicObject(2263, 1611.891845, 998.906921, 1475.651245, 0.000007, -0.000020, -149.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 16640, ""a51"", ""a51_monitors"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""grey-90-percent"", 0x00000000);
tmpobjid = CreateDynamicObject(2263, 1612.361083, 998.022644, 1475.651245, -0.000007, 0.000020, 30.000003, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19787, ""samplcdtvs1"", ""samplcdtv1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 18646, ""matcolours"", ""grey-80-percent"", 0x00000000);
tmpobjid = CreateDynamicObject(19829, 1612.119750, 998.465454, 1475.565307, -89.999992, 231.895919, 81.895912, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18646, ""matcolours"", ""grey-90-percent"", 0x00000000);
tmpobjid = CreateDynamicObject(19829, 1612.124755, 998.456726, 1475.645385, 0.000000, -0.000020, -149.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18646, ""matcolours"", ""grey-93-percent"", 0x00000000);
tmpobjid = CreateDynamicObject(8661, 1593.812622, 996.642211, 1478.097656, 180.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""carp20S"", 0xFFCCCCCC);
tmpobjid = CreateDynamicObject(19483, 1609.025268, 995.357971, 1476.348999, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 3077, ""blkbrdx"", ""WCTitle"", 0x00000000);
tmpobjid = CreateDynamicObject(19399, 1611.426513, 1001.134277, 1476.375732, 0.000014, 0.000007, 89.999885, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(11708, 1612.037353, 1001.177612, 1475.895507, 0.000007, -0.000007, 179.999908, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1611.477294, 1001.177612, 1475.895507, 0.000007, -0.000007, 179.999908, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.916992, 1001.177612, 1475.895507, 0.000007, -0.000007, 179.999908, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.366577, 1001.177612, 1475.895507, 0.000007, -0.000007, 179.999908, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1612.287475, 1001.177612, 1476.070800, 0.000014, -0.000007, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.616821, 1001.177612, 1476.070800, 0.000014, -0.000007, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1612.037353, 1001.177612, 1476.245849, 0.000014, -0.000007, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1612.046508, 1001.177612, 1476.586181, 0.000020, -0.000007, 179.999862, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.916992, 1001.177612, 1476.245849, 0.000014, -0.000007, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.366577, 1001.177612, 1476.245849, 0.000014, -0.000007, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1612.287475, 1001.177612, 1476.421142, 0.000020, -0.000007, 179.999862, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.616821, 1001.177612, 1476.421142, 0.000020, -0.000007, 179.999862, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.366577, 1001.177612, 1476.586181, 0.000020, -0.000007, 179.999862, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1612.287475, 1001.177612, 1476.761474, 0.000029, -0.000007, 179.999832, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1611.727416, 1001.177612, 1476.761474, 0.000029, -0.000007, 179.999832, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.616821, 1001.177612, 1476.761474, 0.000029, -0.000007, 179.999832, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1612.037353, 1001.177612, 1476.936523, 0.000036, -0.000007, 179.999816, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.916992, 1001.177612, 1476.936523, 0.000036, -0.000007, 179.999816, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.366577, 1001.177612, 1476.936523, 0.000036, -0.000007, 179.999816, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1612.287475, 1001.177612, 1477.111816, 0.000044, -0.000007, 179.999786, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1611.727416, 1001.177612, 1477.111816, 0.000044, -0.000007, 179.999786, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1611.167114, 1001.177612, 1477.111816, 0.000044, -0.000007, 179.999786, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.616821, 1001.177612, 1477.111816, 0.000044, -0.000007, 179.999786, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1612.287475, 1001.177612, 1477.281982, 0.000051, -0.000007, 179.999771, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1611.727416, 1001.177612, 1477.281982, 0.000051, -0.000007, 179.999771, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1611.167114, 1001.177612, 1477.281982, 0.000051, -0.000007, 179.999771, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(11708, 1610.616821, 1001.177612, 1477.281982, 0.000051, -0.000007, 179.999771, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(19483, 1611.514282, 1001.039428, 1475.414550, 0.000007, 0.000007, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14612, ""ab_abattoir_box"", ""ab_walldamage"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19426, 1611.421264, 1001.925415, 1475.793701, 0.000007, 0.000014, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1736, ""cj_ammo"", ""CJ_Black_metal"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19426, 1610.551147, 1001.895385, 1475.793701, 0.000007, -0.000007, 179.999908, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1736, ""cj_ammo"", ""CJ_Black_metal"", 0xFF808080);
tmpobjid = CreateDynamicObject(19426, 1612.300781, 1002.085571, 1475.793701, 0.000014, -0.000007, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1736, ""cj_ammo"", ""CJ_Black_metal"", 0xFF808080);
tmpobjid = CreateDynamicObject(19426, 1611.421264, 1003.016357, 1477.135009, -0.000007, 270.000000, -89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1736, ""cj_ammo"", ""CJ_Black_metal"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(1897, 1610.982788, 1001.828002, 1476.187988, 0.000007, 0.000020, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFF808080);
tmpobjid = CreateDynamicObject(1897, 1612.072875, 1001.828002, 1476.187988, 0.000007, 0.000020, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFF808080);
tmpobjid = CreateDynamicObject(1897, 1611.692504, 1001.828002, 1475.787597, 89.999992, 135.000000, -44.999992, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFF808080);
tmpobjid = CreateDynamicObject(1897, 1611.992797, 1001.828002, 1476.948486, 89.999992, 135.000000, -44.999992, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFF808080);
tmpobjid = CreateDynamicObject(1897, 1611.582397, 1001.848022, 1476.157470, 44.999980, 179.999954, -89.999893, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFF808080);
tmpobjid = CreateDynamicObject(1897, 1611.285278, 1001.848022, 1476.454833, -44.999996, 179.999954, -90.000030, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFF808080);
tmpobjid = CreateDynamicObject(19426, 1611.421264, 1003.026367, 1475.823730, 0.000007, 90.000015, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1736, ""cj_ammo"", ""CJ_Black_metal"", 0xFFD9D9D9);
tmpobjid = CreateDynamicObject(1897, 1610.752563, 1001.828002, 1476.187988, 0.000007, 0.000020, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFF808080);
tmpobjid = CreateDynamicObject(1897, 1612.312377, 1001.828002, 1476.187988, 0.000007, 0.000020, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 1560, ""7_11_door"", ""cj_sheetmetal2"", 0xFF808080);
tmpobjid = CreateDynamicObject(852, 1611.679809, 1001.313781, 1474.614257, 0.000007, -0.000007, 179.999908, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 12855, ""cunte_cop"", ""sw_brick05"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1605.028808, 1001.137634, 1476.368896, 0.000014, 0.000000, 89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(2257, 1610.039550, 1000.731079, 1475.645751, -16.900003, 0.500001, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14737, ""whorewallstuff"", ""ah_painting2"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 14737, ""whorewallstuff"", ""ah_painting2"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1608.955078, 993.097534, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19477, 1611.454101, 998.716064, 1474.633300, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 17588, ""lae2coast_alpha"", ""LAShad1"", 0x00000000);
tmpobjid = CreateDynamicObject(2667, 1613.751098, 993.631652, 1476.908813, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 15042, ""svsfsm"", ""GB_rapposter03"", 0x00000000);
tmpobjid = CreateDynamicObject(2667, 1613.751098, 996.861450, 1476.398315, 0.000000, -1.899999, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14802, ""lee_bdupsflat"", ""Bdup_Poster"", 0x00000000);
tmpobjid = CreateDynamicObject(2667, 1613.751098, 993.631652, 1475.518432, 0.000000, 1.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 14742, ""mp3"", ""GB_rapposter02"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1659.015380, 1000.557739, 1475.088867, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 10852, ""dockroad_sfse"", ""dt_bmx_grass"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1659.075805, 1000.968139, 1473.589233, 180.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1656.289184, 1001.137390, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1664.752319, 991.924804, 1476.368896, 0.000000, 0.000000, 270.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(3109, 1660.023925, 993.620544, 1475.828491, 0.000000, 0.000022, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12805, ""ce_loadbay"", ""sw_waredoor"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1660.147583, 1003.598388, 1473.591186, 180.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(2611, 1620.131103, 1000.977355, 1476.197875, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 3, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 5, 16377, ""des_byofficeint"", ""hectics_text"", 0x00000000);
tmpobjid = CreateDynamicObject(2612, 1620.324951, 989.520568, 1476.419067, 0.000000, 0.000000, 179.999893, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 3017, ""arch_plx"", ""arch_plans"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 3, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1660.019165, 1003.149169, 1476.368896, 0.000000, 0.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(8661, 1660.863281, 996.642211, 1474.628295, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""ab_stripped_floor"", 0xFFCCCCCC);
tmpobjid = CreateDynamicObject(19445, 1639.784790, 991.637573, 1473.589233, 0.000014, 360.000000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1649.414794, 991.637573, 1473.589233, 0.000014, 360.000000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1659.014892, 991.637573, 1473.589233, 0.000014, 360.000000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1639.746826, 989.536865, 1473.589233, 0.000014, 360.000000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1649.356811, 989.536865, 1473.589233, 0.000014, 360.000000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1658.975952, 989.536865, 1473.589233, 0.000014, 360.000000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1639.796142, 989.927551, 1475.088867, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 10852, ""dockroad_sfse"", ""dt_bmx_grass"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1649.405761, 989.927551, 1475.088867, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 10852, ""dockroad_sfse"", ""dt_bmx_grass"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1659.045166, 989.927551, 1475.088867, 0.000000, 90.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 10852, ""dockroad_sfse"", ""dt_bmx_grass"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1638.227294, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1641.869384, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18980, 1636.032592, 997.283874, 1478.602783, 89.999992, 89.999992, -89.999992, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFAAAAAA);
tmpobjid = CreateDynamicObject(18880, 1631.538452, 993.655883, 1474.628295, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1645.420654, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18880, 1631.538452, 996.906005, 1474.628295, 0.000000, 0.000007, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
tmpobjid = CreateDynamicObject(18880, 1628.807861, 996.906005, 1474.628295, 0.000000, 0.000007, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 1, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
SetDynamicObjectMaterial(tmpobjid, 2, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
tmpobjid = CreateDynamicObject(1715, 1610.479980, 997.459899, 1474.628295, 0.000000, 0.000000, 108.500015, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 1, 1746, ""cj_sofa"", ""cj_fab3"", 0x00000000);
tmpobjid = CreateDynamicObject(19552, 1614.411743, 987.381286, 1474.638916, 180.000000, 360.000000, 270.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 19962, ""samproadsigns"", ""materialtext1"", 0x00000000);
tmpobjid = CreateDynamicObject(19445, 1649.171875, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1652.881347, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1656.760864, 986.906616, 1473.591186, 0.000000, 0.000000, 179.999877, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 13364, ""cetown3cs_t"", ""sw_wall03"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(19445, 1649.390258, 989.368713, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19445, 1659.009887, 989.368713, 1476.368896, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19445, 1660.012207, 988.101196, 1476.368896, 0.000000, 0.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFBBBBBB);
tmpobjid = CreateDynamicObject(19445, 1660.039184, 993.524902, 1476.368896, 0.000000, 0.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""mp_gun_wall"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(2653, 1640.387817, 995.786132, 1478.868530, -0.000014, 179.999984, -89.999969, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(8661, 1656.987548, 996.642211, 1478.728271, 180.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""carp20S"", 0xFFCCCCCC);
tmpobjid = CreateDynamicObject(18980, 1651.071655, 1001.196105, 1478.607788, 89.999992, 89.999992, 0.000007, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(18980, 1651.120849, 989.352600, 1478.607788, 89.999992, 89.999992, 0.000007, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(2653, 1648.233154, 995.786132, 1478.868530, -0.000014, 179.999984, -89.999969, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1656.120849, 995.786132, 1478.868530, -0.000014, 179.999984, -89.999969, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(18980, 1660.008178, 997.246826, 1478.597778, 89.999992, 89.999992, 90.000007, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 18065, ""ab_sfammumain"", ""breezewall5"", 0xFFFFFFFF);
tmpobjid = CreateDynamicObject(2653, 1640.457397, 994.745117, 1478.868530, -0.000014, 179.999984, -89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1648.332641, 994.745117, 1478.868530, -0.000014, 179.999984, -89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1656.189208, 994.745117, 1478.868530, -0.000014, 179.999984, -89.999954, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1638.818115, 1000.130004, 1478.878540, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1638.818115, 990.465637, 1478.878540, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1644.693359, 990.465637, 1478.878540, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1644.693359, 1000.096313, 1478.878540, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1650.798950, 1000.096313, 1478.878540, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1650.798950, 990.455017, 1478.878540, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1659.076293, 990.455017, 1478.878540, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
tmpobjid = CreateDynamicObject(2653, 1659.076293, 1000.117126, 1478.878540, 0.000000, 179.999984, 179.999938, object_world, object_int, -1, 300.00, 300.00); 
SetDynamicObjectMaterial(tmpobjid, 0, 12978, ""ce_payspray"", ""spraypipegz1"", 0xFFFFFFFF);
SetDynamicObjectMaterial(tmpobjid, 1, 12978, ""ce_payspray"", ""spraypipegz1"", 0x00000000);
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
tmpobjid = CreateDynamicObject(19552, 1635.550659, 1016.431091, 1474.628295, 90.000000, 180.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19552, 1646.550537, 1063.576538, 1474.628295, 90.000000, 180.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19552, 1608.240600, 953.111389, 1474.628295, 90.000000, 180.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19552, 1574.461547, 987.381286, 1474.628295, 90.000000, 180.000000, 270.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19552, 1614.411743, 987.381286, 1494.628295, 180.000000, 360.000000, 270.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19552, 1614.411743, 987.381286, 1458.628295, 180.000000, 360.000000, 270.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19472, 1620.289794, 997.369201, 1475.593383, 8.099007, -94.598983, 119.299980, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1621.502197, 997.639953, 1476.016235, 0.000020, 0.000007, 87.999855, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19472, 1622.737060, 998.410949, 1475.584594, 23.999977, 0.000023, -0.000087, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1665, 1622.659179, 998.731872, 1475.570922, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2076, 1619.453125, 997.951965, 1476.888305, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1619.055175, 998.029846, 1476.446899, 11.500018, 0.000007, 87.993865, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18693, 1619.430175, 997.943908, 1474.072875, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(14807, 1618.703125, 1001.876892, 1475.873657, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1622.091064, 998.637878, 1476.346313, 86.502006, 180.000335, -11.011395, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1621.687988, 998.430969, 1476.167602, 0.000020, -0.000004, 123.993919, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1620.406250, 998.078918, 1476.167602, 0.000020, 0.000007, 87.993858, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2709, 1620.409179, 998.154846, 1475.691040, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2690, 1622.057128, 997.083862, 1474.959594, -0.000007, 0.000019, -0.000097, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2060, 1621.437255, 1000.360900, 1474.757446, -0.000022, -0.000003, -82.598876, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2057, 1622.166992, 999.329895, 1475.722290, 0.000003, 0.000023, 26.000040, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(334, 1622.141113, 1000.253967, 1476.106079, 0.021020, 95.000007, 96.747947, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1618.375244, 997.964904, 1474.751586, -0.000007, 0.000020, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1619.409179, 997.796936, 1474.751586, -0.000019, 0.000009, -46.000011, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1618.875244, 997.779846, 1474.751586, -0.000020, -0.000004, -87.005882, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1619.062255, 998.001892, 1475.157836, -0.000020, -0.000004, -87.006858, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1618.476074, 997.818908, 1475.157836, -0.000020, 0.000007, -53.006992, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(3016, 1622.645019, 997.426940, 1475.697875, -0.000000, 0.000022, 11.500061, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19472, 1619.718505, 993.047485, 1475.595336, 8.099006, -94.598983, -60.700023, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1618.506103, 992.776733, 1476.018188, 0.000020, 0.000007, -92.000114, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19472, 1622.737060, 990.590393, 1475.584594, 23.999977, 0.000030, -0.000090, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1665, 1622.659179, 990.911315, 1475.570922, -0.000007, 0.000029, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2076, 1620.555175, 992.464721, 1476.890258, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1620.953125, 992.386840, 1476.448852, 11.500015, 0.000007, -92.006103, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18693, 1620.578125, 992.472778, 1474.074829, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1621.963623, 990.552795, 1476.167602, 0.000047, -0.000031, 153.993774, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(18633, 1619.602050, 992.337768, 1476.169555, 0.000020, 0.000007, -92.006111, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2709, 1619.599121, 992.261840, 1475.692993, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2690, 1622.057128, 993.173400, 1474.959594, -0.000007, 0.000029, -0.000098, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2060, 1617.616455, 992.689514, 1474.757446, -0.000029, -0.000001, -82.598854, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2057, 1622.166992, 991.509338, 1475.722290, 0.000006, 0.000029, 26.000040, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(334, 1622.141113, 992.433410, 1476.106079, 0.021028, 95.000007, 96.747924, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1621.633056, 992.451782, 1474.753540, -0.000006, 0.000020, 179.999755, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1620.599121, 992.619750, 1474.753540, -0.000019, 0.000009, 133.999969, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1621.133056, 992.636840, 1474.753540, -0.000020, -0.000004, 92.994056, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1620.946044, 992.414794, 1475.159790, -0.000020, -0.000004, 92.993080, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1621.532226, 992.597778, 1475.159790, -0.000020, 0.000007, 126.992919, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(3016, 1622.645019, 989.606384, 1475.697875, 0.000000, 0.000029, 11.500061, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1609.405883, 991.744628, 1476.243041, -0.000007, 0.000029, -0.000097, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2986, 1621.004638, 992.462463, 1476.978027, 180.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2986, 1619.964111, 997.913330, 1476.978027, 0.000000, 179.999984, -179.999984, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1628.409179, 997.343322, 1478.708374, 0.000000, 0.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1632.409179, 997.343322, 1478.708374, 0.000000, 0.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1624.409179, 997.343322, 1478.708374, 0.000000, 0.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1628.409179, 993.253295, 1478.708374, 0.000000, -0.000007, 179.999954, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1632.409179, 993.253295, 1478.708374, 0.000000, -0.000007, 179.999954, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1624.409179, 993.253295, 1478.708374, 0.000000, -0.000007, 179.999954, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1761, 1614.401855, 997.543701, 1474.628295, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2847, 1616.281860, 998.038391, 1474.628295, 0.000000, 0.000000, 85.799957, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1520, 1615.798217, 998.538574, 1475.188598, 0.000000, 0.000000, 21.399999, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1520, 1615.670532, 997.972778, 1475.188598, 0.000000, 0.000000, -29.299997, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1665, 1615.577392, 998.166687, 1475.148803, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2057, 1614.862548, 991.885620, 1475.612182, 0.000006, 0.000029, 26.000040, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2057, 1614.869506, 991.211059, 1475.612182, 0.000006, 0.000029, 72.400039, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2057, 1614.728271, 992.722534, 1475.612182, 0.000006, 0.000029, -57.399959, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2060, 1614.301513, 992.647338, 1474.767456, -0.000022, -0.000003, -82.598876, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2060, 1614.773437, 993.242797, 1474.767456, -0.000022, -0.000003, -35.998886, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1897, 1613.807739, 997.561828, 1476.338989, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1897, 1613.807739, 998.472167, 1477.109741, 90.000000, 360.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1897, 1613.807739, 998.472167, 1475.748413, 90.000000, 360.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1897, 1613.807739, 999.261779, 1476.338989, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1610.439819, 991.576660, 1476.243041, -0.000024, 0.000014, -46.000011, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1609.905883, 991.559570, 1476.243041, -0.000029, -0.000003, -87.005859, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1610.439819, 992.259948, 1476.243041, -0.000007, 0.000029, 179.999801, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1609.405883, 992.427917, 1476.243041, -0.000024, 0.000014, 133.999969, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1609.939819, 992.445007, 1476.243041, -0.000029, -0.000003, 92.994079, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2205, 1612.066894, 998.685363, 1474.628295, 0.000000, 0.000000, 180.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19808, 1611.798828, 998.796081, 1475.578247, 0.000000, 0.000000, -161.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2196, 1610.619873, 999.032531, 1475.558227, 0.000000, 0.000000, 34.699993, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2059, 1611.291137, 998.591796, 1475.578247, 0.000000, 0.000000, 92.399955, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2059, 1610.767700, 998.795715, 1475.578247, 0.000000, 0.000000, -62.200042, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(3077, 1609.002319, 995.639099, 1474.628295, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1781, 1613.002075, 991.974426, 1476.258666, 0.000000, 0.000000, -169.700012, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1550, 1611.133178, 1001.523559, 1476.268066, 0.000004, 0.000015, 75.899963, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1550, 1611.984741, 1001.558471, 1476.268066, 0.000007, 0.000014, 89.299949, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1575, 1611.552856, 1001.594848, 1475.885742, 0.000007, 0.000007, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1576, 1611.576171, 1001.644897, 1476.041748, 0.000006, 0.000007, 81.599952, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1579, 1611.587524, 1001.573242, 1476.208007, 0.000004, 0.000009, 76.999961, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(355, 1610.974731, 1001.446533, 1476.221679, 0.000007, -84.500000, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(355, 1611.475708, 1001.641601, 1476.187255, -8.300006, -86.200004, -8.999995, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(348, 1611.389770, 1001.185424, 1476.100097, 0.000007, 51.500011, 89.999946, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1611.848876, 996.682922, 1478.588256, 0.000000, -0.000007, 179.999954, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1611.848876, 999.682922, 1478.588256, 0.000000, -0.000007, 179.999954, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1611.848876, 993.682922, 1478.588256, 0.000000, -0.000007, 179.999954, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(11289, 1615.416015, 990.923278, 1476.837890, 0.000000, 0.000000, 90.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2986, 1609.026000, 999.286315, 1477.799316, 180.000000, 90.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2200, 1613.643554, 1001.663391, 1474.628295, 0.000000, 0.000000, -90.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2200, 1613.643554, 1002.763244, 1474.628295, 0.000000, 0.000000, -90.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(349, 1613.517333, 999.875915, 1474.887695, 180.000000, 90.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19805, 1620.204956, 1001.062011, 1476.198120, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2673, 1615.134887, 996.786987, 1474.728393, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(19805, 1620.209594, 989.436706, 1476.198120, 0.000000, 0.000000, 179.999893, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(2674, 1615.817993, 1000.155029, 1474.648315, 0.000000, 0.000000, 0.000000, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1617.214599, 997.343322, 1478.708374, 0.000000, -0.000007, 179.999954, object_world, object_int, -1, 300.00, 300.00); 
tmpobjid = CreateDynamicObject(1893, 1617.214599, 993.253295, 1478.708374, 0.000000, -0.000014, 179.999908, object_world, object_int, -1, 300.00, 300.00); 
"
L0zbP675,Relay Monitor rev_09,pleasedontcode,Arduino,Monday 4th of August 2025 04:57:29 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Relay Monitor
	- Source Code compiled for: Arduino Opta WiFi
	- Source Code created on: 2025-08-04 21:56:00

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Toggle relay 1 and its associated LED every 3 */
	/* seconds using the connected relay (pin D0) and LED */
	/* component (pin LED_D0) on the Arduino Opta WiFi */
	/* board. */
/****** END SYSTEM REQUIREMENTS *****/


/********* User code review feedback **********
#### Feedback 1 ####
- add information on serial
********* User code review feedback **********/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);

const int relayPin = D0;      // Pin connected to relay 1
const int ledPin = LED_D0;    // Pin connected to LED associated with relay 1

void setup(void)
{
  // Initialize serial communication at 9600 baud rate
  Serial.begin(9600);
  Serial.println(""System initialized. Starting relay toggle loop."");

  // Initialize relay and LED pins as outputs
  pinMode(relayPin, OUTPUT);
  pinMode(ledPin, OUTPUT);
}

void loop(void)
{
  static bool relayState = LOW; // Keep track of relay and LED state

  // Toggle relay and LED state
  relayState = !relayState;
  digitalWrite(relayPin, relayState);
  digitalWrite(ledPin, relayState);

  // Send status message over serial
  if (relayState)
  {
    Serial.println(""Relay and LED turned ON"");
  }
  else
  {
    Serial.println(""Relay and LED turned OFF"");
  }

  delay(3000); // Wait for 3 seconds
}
"
w6Zxui0g,Serial Toggle rev_08,pleasedontcode,Arduino,Monday 4th of August 2025 04:55:47 PM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Serial Toggle
	- Source Code NOT compiled for: Arduino Opta WiFi
	- Source Code created on: 2025-08-04 21:55:35

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Toggle relay 1 and its associated LED every 3 */
	/* seconds using the connected relay (pin D0) and LED */
	/* component (pin LED_D0) on the Arduino Opta WiFi */
	/* board. */
/****** END SYSTEM REQUIREMENTS *****/


/********* User code review feedback **********
#### Feedback 1 ####
- add information on serial
********* User code review feedback **********/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);

const int relayPin = D0;      // Pin connected to relay 1
const int ledPin = LED_D0;    // Pin connected to LED associated with relay 1

void setup(void)
{
  // Initialize serial communication at 9600 baud rate
  Serial.begin(9600);
  Serial.println(""System initialized. Starting relay toggle loop."");

  // Initialize relay and LED pins as outputs
  pinMode(relayPin, OUTPUT);
  pinMode(ledPin, OUTPUT);
}

void loop(void)
{
  static bool relayState = LOW; // Keep track of relay and LED state

  // Toggle relay and LED state
  relayState = !relayState;
  digitalWrite(relayPin, relayState);
  digitalWrite(ledPin, relayState);

  // Send status message over serial
  if (relayState)
  {
    Serial.println(""Relay and LED turned ON"");
  }
  else
  {
    Serial.println(""Relay and LED turned OFF"");
  }

  delay(3000); // Wait for 3 seconds
}
"
Dzp49PNq,Rollchest command structures,LNXS,JSON,Monday 4th of August 2025 04:04:39 PM CDT,"[
  {""name"": ""Ancient City"", ""url"": ""https://gist.githubusercontent.com/LNXSeus/d53c7e7c57c2627a8e105a310dd4d060/raw/5c5850a2a0f56d57fa9b0563c659f61b4107622b/ancient_city.js""},
  {""name"": ""Bastion Treasure"", ""url"": ""https://gist.githubusercontent.com/LNXSeus/679718eff7ca16361f939708bd1c390a/raw/cf93e670fbc3267a8fddd69b0640808ffa848f9e/bastion_treasure.js""}
]
"
DbksK45f,Urbam Dictionizer,evilone89,Bash,Monday 4th of August 2025 03:57:02 PM CDT,"ud_perfectish () 
{ 
    term=""$@"";
    sterm=$(echo $term | sed -e 's/ /%20/g');
    jq_icase_filter=$(generate_permutations ""${sterm}"" | tr '{}' '[]' | tr -d ',');
    function get_count () 
    { 
        export num=0 check=""init"";
        until [[ -z ""${check}"" ]]; do
            let num++;
            export cpage=""&page=${num}"";
            export check=""$(curl -skL ""https://api.urbandictionary.com/v0/define?term=${sterm}${cpage}"" | jq -M -r '.list[]')"";
        done && export num=$((${num}-1))
    };
    get_count;
    ( p=0;
    l=-1;
    declare -a ud_list;
    for i in $(seq 1 1 ${num});
    do
        let p++;
        if [[ $p -gt 1 ]]; then
            export pg=""&page=${i}"";
        fi;
        curl ""https://api.urbandictionary.com/v0/define?term=${sterm}${pg}"" -s | jq -M -r '.list[] |select(.word|match(""^'${jq_icase_filter}'$"")) | (.defid|tostring) + "" "" + (.thumbs_up|tostring) + "" "" + (.thumbs_down|tostring) + "" "" + .word';
    done ) | cat -n | sort -nk 3 | egrep -i ""\b${term}\b$"" | tail -1 | while read pnum defid tup tdwn rterm; do
        let l++;
        ud_list[${l}]=$(declare -p pnum defid tup tdwn rterm);
        declare -p ud_list;
        if [[ $tup -gt $tdwn ]] && [[ -n $(echo ""${term}"" | grep -i ""${rterm}"") ]]; then
            curl -skL ""https://api.urbandictionary.com/v0/define?defid=$defid"" | jq -r -M '.list[].definition';
            declare -p pnum defid tup tdwn rterm;
        else
            if [[ ${tup} -gt ${tdwn} ]]; then
                echo ""${Yellow}Warning:${White} logic caused definition selected based on number of thumbs ups not to be a perfect match.  Definition for ${Cyan}${rterm}:${White}"";
                curl -skL ""https://api.urbandictionary.com/v0/define?defid=$defid"" | jq -r -M '.list[].definition';
            else
                echo ""Thumbsdown outweigh thumbs up or rterm doesnt match term, please verify manually."";
                echo -e ""${pnum} ${defid} ${tup} ${tdwn} ${rterm}"";
                echo -e ""term is $(printf ""%s\n"" ""${term}"")\nrterm is $(printf ""%s\n"" ""${rterm}"")"";
                echo -e ""Here is the list of definitions you must sort through."";
                set +x;
                p=0;
                for fail in $(seq 1 1 ${num});
                do
                    let p++;
                    if [[ $p -gt 1 ]]; then
                        export pg=""&page=${fail}"";
                    fi;
                    curl ""https://api.urbandictionary.com/v0/define?term=${sterm}${pg}"" -s | jq -M -r '.list[] |select(.word|match(""^'${jq_icase_filter}'$"")) | ""https://api.urbandictionary.com/v0/define?defid="" + (.defid|tostring) + "" "" + (.thumbs_up|tostring) + "" "" + (.thumbs_down|tostring) + "" "" + .word';
                done;
                set +x;
            fi;
        fi;
    done;
    set +x
}
"
4HMsF0WC,DFS,Fastrail08,C++,Monday 4th of August 2025 03:04:56 PM CDT,"#include <bits/stdc++.h>
using namespace std;

void dfs(int source, vector<bool> &visited, vector<vector<int> > &adj){
    
    //level = source
    //options = neighbours of source
    
    //mark source visited
    visited[source] = true;
    cout << source << "" "";
    for(int i = 0; i < adj[source].size(); i++){
        int node = adj[source][i];
        if(!visited[node]){
            dfs(node, visited, adj);
        }
    }
    
}

int main() {
	// your code goes here
    int n, m;
    cin >> n >> m;
    
    vector<vector<int> > adj(n + 1, vector<int>());
    
    for(int i = 0; i < n; i++){
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    vector<bool> visited(n + 1, false);
    int source = 1;
    dfs(source, visited, adj);
}
"
D5Wbmc8Y,GTA SA stripped main + Life is Beach Mission for SB 3.9.1,Zarkongo,Batch,Monday 4th of August 2025 02:49:31 PM CDT,"DEFINE OBJECTS 2
DEFINE OBJECT ZAZ     
DEFINE OBJECT DYN_WOODPILE2            // Object number -1

DEFINE MISSIONS  1
DEFINE MISSION 0 AT @MUSIC1 // Life's a Beach

DEFINE EXTERNAL_SCRIPTS  1
DEFINE SCRIPT DANCE AT @DANCE          // 0 // 35

DEFINE UNKNOWN_EMPTY_SEGMENT  0

DEFINE UNKNOWN_THREADS_MEMORY  0

//-------------MAIN---------------


:MAIN_1
03A4: name_thread 'MAIN'
016A: fade  0 (in)  0 ms
042C: set_total_missions_to  0
030D: set_total_mission_points_to  0
01F0: set_max_wanted_level_to  6
0111: set_wasted_busted_check_to  0 (disabled)
00C0: set_current_time  7  0
04E4: unknown_refresh_game_renderer_at  817.7 -1624.1
03CB: set_camera  817.7 -1624.1 13.6
0053: $PLAYER_CHAR = create_player #NULL at  817.7 -1624.1 13.6
07AF: $PLAYER_GROUP = player $PLAYER_CHAR group
01F5: $PLAYER_ACTOR = create_emulated_actor_from_player $PLAYER_CHAR
0173: set_actor $PLAYER_ACTOR z_angle_to  145.4
0373: set_camera_directly_behind_player
070D: $PLAYER_CHAR
0629: change_stat  181 (islands unlocked) to  4  // integer see statdisp.dat
01B6: set_weather  1
04BB: select_interior  0  // select render area
01B7: release_weather
016C: restart_if_wasted_at 817.7 -1624.1 13.6 angle 180.0 town_number 0 
016D: restart_if_busted_at 817.7 -1624.1 13.6 angle 180.0 town_number 0 
016C: restart_if_wasted_at 817.7 -1624.1 13.6 angle 180.0 town_number 1 
016D: restart_if_busted_at 817.7 -1624.1 13.6 angle 180.0 town_number 1 
016C: restart_if_wasted_at 817.7 -1624.1 13.6 angle 180.0 town_number 2 
016D: restart_if_busted_at 817.7 -1624.1 13.6 angle 180.0 town_number 2
0629: change_stat  181 (islands unlocked) to  4  // integer see statdisp.dat
0998: add_respect 1000
062A: change_stat 165 (energy) to 800.0 // float
062A: change_stat 23 (muscle) to 800.0 // float
062A: change_stat 21 (fat) to 200.0 // float
062A: change_float_stat 160 (driving skill) to  1000.0  // float
062A: change_float_stat 223 (pilot skill) to  1000.0  // float
062A: change_float_stat 229 (bike skill) to  1000.0  // float
062A: change_float_stat 230 (cycling skill) to  1000.0  // float
0629: change_integer_stat 225 (lung capasity) to  1000  // integer see statdisp.dat
0629: change_integer_stat 22 (stamina) to  1000  // integer see statdisp.dat
0629: change_integer_stat 156 (dance skill) to  1000  // integer see statdisp.dat
062A: change_float_stat  81 (gambling skill) to  1000.0  // integer see statdisp.dat
0629: change_integer_stat  64 (respect) to  1000  // integer see statdisp.dat
0629: change_integer_stat  65 (GF Respect) to  1000  // GF Respect
062A: change_float_stat  69 (Weap skill: pistol) to  1000.0  // float
062A: change_float_stat  70 (Weap skill: silence) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  71 (Weap skill: desert ) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  72 (Weap skill: shotgun) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  73 (Weap skill: sawn of) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  74 (Weap skill: combat ) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  75 (Weap skill: machine) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  76 (Weap skill: smg) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  77 (Weap skill: ak47) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  78 (Weap skill: m4) to  1000.0  // integer see statdisp.dat
062A: change_float_stat  79 (Weap skill: rifle) to  1000.0  // integer see statdisp.dat 
0629: change_stat  181 (islands unlocked) to  4  // integer see statdisp.dat
0A1F: increase_float_stat 24 by 500.0
087B: set_player $PLAYER_CHAR clothes_texture ""HAWAIIRED"" model ""HAWAII"" body_part 0
087B: set_player $PLAYER_CHAR clothes_texture ""mohawk"" model ""mohawk"" body_part  1 
087B: set_player $PLAYER_CHAR clothes_texture ""BASK2HEATBAND"" model ""BASK1"" body_part 3 
087B: set_player $PLAYER_CHAR clothes_texture ""LEATHERTR"" model ""LEATHERTR"" body_part 2 
070D: rebuild_player $PLAYER_CHAR
055E: set_player $PLAYER_CHAR max_health += 150 
055F: set_player $PLAYER_CHAR max_armour += 150 
0223: set_actor $PLAYER_ACTOR health_to 250 
035F: actor $PLAYER_ACTOR armour += 250 
0330: set_player $PLAYER_CHAR infinite_run 1 
07FE: set_actor $PLAYER_ACTOR fighting_style_to 6 6 
0109: player $PLAYER_CHAR money += 350000
016A: fade  1 (out)  1000 ms
0001: wait  100 ms
03E6: remove_text_box
0180: set_on_mission_flag_to $ONMISSION // Note: your missions have to use the variable defined here
01B4: set_player $PLAYER_CHAR can_move True

004F: create_thread @MissionStart1
032B: 1@ = create_weapon_pickup #MP5LNG 15 ammo 30000 at 813.5 -1626.1 13.5
014B: 2@ = init_parked_car_generator #NRG500 color -1 -1 1 alarm 0 door_lock 0 0 10000 at 807.1 -1640.9 13.6 angle 167.0 
014C: set_parked_car_generator 2@ cars_to_generate_to 101

:MAIN_3
wait 2500
//end_thread
jump @MAIN_3






:MissionStart1
thread 'MST'

:MissionStart2
wait  0
if
0256:   player $PLAYER_CHAR defined
jf @MissionStart2
if
$ONMISSION ==  0  // integer values
else_jump @MissionStart2
if
00FF:   actor $PLAYER_ACTOR  1 (in-sphere)near_point_on_foot 790.54 -1627.91 12.39 radius  1.2 1.2 2.0
jf @MissionStart2
$ONMISSION =  1  // integer values
0417: start_mission  0   // originally: TestMission
jump @MissionStart2





//------------//------------//------------//------------




//------------//------------//------------//------------





:BDISPLY
03A4: script_name 'BDISPLY'
00D6: if 
0038:   $1048 == 0
004D: jump_if_false @BDISPLY_43
0004: $1048 = 1
0004: $1044 = 0

:BDISPLY_43
03F0: enable_text_draw 1
0390: load_txd_dictionary 'LD_BEAT'
038F: load_texture ""DOWN"" as 1  // Load dictionary with 0390 first
038F: load_texture ""LEFT"" as 2  // Load dictionary with 0390 first
038F: load_texture ""UP"" as 3  // Load dictionary with 0390 first
038F: load_texture ""RIGHT"" as 4  // Load dictionary with 0390 first
038F: load_texture ""UP"" as 13  // Load dictionary with 0390 first
038F: load_texture ""DOWN"" as 14  // Load dictionary with 0390 first
038F: load_texture ""RIGHT"" as 10  // Load dictionary with 0390 first
038F: load_texture ""LEFT"" as 9  // Load dictionary with 0390 first
038F: load_texture ""UPR"" as 11  // Load dictionary with 0390 first
038F: load_texture ""DOWNR"" as 16  // Load dictionary with 0390 first
038F: load_texture ""DOWNL"" as 12  // Load dictionary with 0390 first
038F: load_texture ""UPL"" as 15  // Load dictionary with 0390 first
038F: load_texture ""CRING"" as 17  // Load dictionary with 0390 first
038F: load_texture ""CHIT"" as 18  // Load dictionary with 0390 first
0004: $1036 = 4500
0004: $1037 = 800
0005: $1038 = 265.0
0005: $1039 = 390.0
0005: $1040 = 355.0
0005: $1041 = 32.0
0005: $1042 = 32.0
0007: 19@ = 64.0
0007: 20@ = 64.0
0007: 22@ = 64.0
0007: 21@ = 64.0
01BD: 16@ = current_time_in_ms
0001: wait 1000 ms

:BDISPLY_313
0001: wait 0 ms
00D6: if 
09FA:   is_menu_closed
004D: jump_if_false @BDISPLY_344
0004: $1043 = 0
0006: 23@ = 0

:BDISPLY_344
0953: get_soundtrack_status_to 0@
00D6: if 
04A4:   0@ == 3  //  == constant
004D: jump_if_false @BDISPLY_1198
01BD: 15@ = current_time_in_ms
0085: 17@ = 15@  // (int)
0062: 17@ -= 16@  // (int)
0085: 16@ = 15@  // (int)
008B: 0@ = $1037  // (int)
005C: 0@ += $1036  // (int)
0093: 5@ = integer 0@ to_float
008F: 6@ = integer $1037 to_float
0073: 6@ /= 5@  // (float)
006F: 6@ *= $1040  // (float)
0086: $tempvar_Float_1 = $1038  // (float)
005F: $tempvar_Float_1 += 6@  // (float)
0086: $tempvar_Float_2 = $1039  // (float)
03E3: set_texture_to_be_drawn_antialiased 1
038D: draw_texture 17 position $tempvar_Float_1 $tempvar_Float_2 size 20@ 19@ RGBA 128 128 128 255
01BD: $1047 = current_time_in_ms
0060: $1047 -= $1046  // (int)
0006: 0@ = 1

:BDISPLY_520
00D6: if 
001B:   11 > 0@
004D: jump_if_false @BDISPLY_846
07B1: unknown_get_dance_track 0@ store_to 8@ 10@ 12@
00D6: if 
8039:   not 10@ == 0
004D: jump_if_false @BDISPLY_832
00D6: if 
001E:   $1036 > 8@  // (int)
004D: jump_if_false @BDISPLY_832
0050: gosub @BDISPLY_1266
008B: 3@ = $1037  // (int)
005C: 3@ += $1036  // (int)
0085: 4@ = 8@  // (int)
005C: 4@ += $1037  // (int)
0093: 5@ = integer 4@ to_float
0093: 6@ = integer 3@ to_float
0073: 5@ /= 6@  // (float)
006F: 5@ *= $1040  // (float)
0086: $tempvar_Float_1 = $1038  // (float)
005F: $tempvar_Float_1 += 5@  // (float)
0086: $tempvar_Float_2 = $1039  // (float)
0093: 5@ = integer 8@ to_float
008F: 6@ = integer $1036 to_float
0073: 5@ /= 6@  // (float)
0013: 5@ *= -1.0
000B: 5@ += 1.0
00D6: if 
001B:   0 > 8@
004D: jump_if_false @BDISPLY_756
0007: 5@ = 1.0

:BDISPLY_756
0013: 5@ *= 255.0
0092: 4@ = float 5@ to_integer
00D6: if 
8039:   not 18@ == 0
004D: jump_if_false @BDISPLY_832
0050: gosub @BDISPLY_1575
03E3: set_texture_to_be_drawn_antialiased 1
038D: draw_texture 18@ position $tempvar_Float_1 $tempvar_Float_2 size $1042 $1041 RGBA 128 128 128 4@

:BDISPLY_832
000A: 0@ += 1
0002: jump @BDISPLY_520

:BDISPLY_846
00D6: if 
0038:   $1045 == 0
004D: jump_if_false @BDISPLY_1191
0006: 0@ = -1

:BDISPLY_871
00D6: if 
0019:   0@ > -11
004D: jump_if_false @BDISPLY_1191
07B1: unknown_get_dance_track 0@ store_to 8@ 10@ 12@
0012: 8@ *= -1
00D6: if 
8039:   not 10@ == 0
004D: jump_if_false @BDISPLY_1177
00D6: if 
001E:   $1037 > 8@  // (int)
004D: jump_if_false @BDISPLY_1177
0050: gosub @BDISPLY_1266
0085: 4@ = 8@  // (int)
0012: 4@ *= -1
005C: 4@ += $1037  // (int)
008B: 3@ = $1037  // (int)
005C: 3@ += $1036  // (int)
0093: 5@ = integer 4@ to_float
0093: 6@ = integer 3@ to_float
0073: 5@ /= 6@  // (float)
006F: 5@ *= $1040  // (float)
0086: $tempvar_Float_1 = $1038  // (float)
005F: $tempvar_Float_1 += 5@  // (float)
0086: $tempvar_Float_2 = $1039  // (float)
0093: 5@ = integer 4@ to_float
008F: 6@ = integer $1037 to_float
0073: 5@ /= 6@  // (float)
00D6: if 
001B:   0 > 8@
004D: jump_if_false @BDISPLY_1101
0007: 5@ = 1.0

:BDISPLY_1101
0013: 5@ *= 255.0
0092: 4@ = float 5@ to_integer
00D6: if 
8039:   not 18@ == 0
004D: jump_if_false @BDISPLY_1177
0050: gosub @BDISPLY_1575
03E3: set_texture_to_be_drawn_antialiased 1
038D: draw_texture 18@ position $tempvar_Float_1 $tempvar_Float_2 size $1042 $1041 RGBA 128 128 128 4@

:BDISPLY_1177
000E: 0@ -= 1
0002: jump @BDISPLY_871

:BDISPLY_1191
0002: jump @BDISPLY_1205

:BDISPLY_1198
0002: jump @BDISPLY_1244

:BDISPLY_1205
00D6: if 
0038:   $1044 == 0
004D: jump_if_false @BDISPLY_1237
0002: jump @BDISPLY_313
0002: jump @BDISPLY_1244

:BDISPLY_1237
0002: jump @BDISPLY_1244

:BDISPLY_1244
0004: $1044 = 0
0004: $1048 = 0
03F0: enable_text_draw 0
0391: release_textures
004E: terminate_this_script

:BDISPLY_1266
0006: 18@ = 0
00D6: if 
0039:   10@ == 1
004D: jump_if_false @BDISPLY_1298
0006: 18@ = 1

:BDISPLY_1298
00D6: if 
0039:   10@ == 2
004D: jump_if_false @BDISPLY_1323
0006: 18@ = 2

:BDISPLY_1323
00D6: if 
0039:   10@ == 3
004D: jump_if_false @BDISPLY_1348
0006: 18@ = 3

:BDISPLY_1348
00D6: if 
0039:   10@ == 4
004D: jump_if_false @BDISPLY_1373
0006: 18@ = 4

:BDISPLY_1373
00D6: if 
0039:   10@ == 9
004D: jump_if_false @BDISPLY_1398
0006: 18@ = 9

:BDISPLY_1398
00D6: if 
0039:   10@ == 10
004D: jump_if_false @BDISPLY_1423
0006: 18@ = 10

:BDISPLY_1423
00D6: if 
0039:   10@ == 11
004D: jump_if_false @BDISPLY_1448
0006: 18@ = 11

:BDISPLY_1448
00D6: if 
0039:   10@ == 12
004D: jump_if_false @BDISPLY_1473
0006: 18@ = 12

:BDISPLY_1473
00D6: if 
0039:   10@ == 13
004D: jump_if_false @BDISPLY_1498
0006: 18@ = 13

:BDISPLY_1498
00D6: if 
0039:   10@ == 14
004D: jump_if_false @BDISPLY_1523
0006: 18@ = 14

:BDISPLY_1523
00D6: if 
0039:   10@ == 15
004D: jump_if_false @BDISPLY_1548
0006: 18@ = 15

:BDISPLY_1548
00D6: if 
0039:   10@ == 16
004D: jump_if_false @BDISPLY_1573
0006: 18@ = 16

:BDISPLY_1573
0051: return

:BDISPLY_1575
00D6: if and
0018:   $1043 > 0
0039:   23@ == 0
004D: jump_if_false @BDISPLY_1627
07B1: unknown_get_dance_track 0 store_to 1@ 1@ 25@
000A: 25@ += 1
0006: 23@ = 1

:BDISPLY_1627
0085: 13@ = 12@  // (int)
005A: 13@ += 0@  // (int)
00D6: if 
001B:   0 > 0@
004D: jump_if_false @BDISPLY_1675
0012: 8@ *= -1
000A: 13@ += 1

:BDISPLY_1675
00D6: if 
003B:   13@ == 25@  // (int)
004D: jump_if_false @BDISPLY_1756
00D6: if and
002B:   3000 >= 8@
0019:   8@ > -400
004D: jump_if_false @BDISPLY_1735
0050: gosub @BDISPLY_1765
0002: jump @BDISPLY_1749

:BDISPLY_1735
0006: 23@ = 0
0004: $1043 = 0

:BDISPLY_1749
0002: jump @BDISPLY_1763

:BDISPLY_1756
0004: $1043 = 0

:BDISPLY_1763
0051: return

:BDISPLY_1765
0871: init_jump_table 23@ total_jumps 3 default_jump 0 @BDISPLY_2214 jumps 1 @BDISPLY_1828 2 @BDISPLY_2001 3 @BDISPLY_2105 -1 @BDISPLY_2214 -1 @BDISPLY_2214 -1 @BDISPLY_2214 -1 @BDISPLY_2214

:BDISPLY_1828
00D6: if 
0038:   $1043 == 1
004D: jump_if_false @BDISPLY_1867
0006: 26@ = 90
0006: 27@ = 100
0002: jump @BDISPLY_1940

:BDISPLY_1867
00D6: if 
0038:   $1043 == 2
004D: jump_if_false @BDISPLY_1907
0006: 26@ = 190
0006: 27@ = 80
0002: jump @BDISPLY_1940

:BDISPLY_1907
00D6: if 
0038:   $1043 == 3
004D: jump_if_false @BDISPLY_1940
0006: 26@ = 255
0006: 27@ = 25

:BDISPLY_1940
0085: 24@ = 26@  // (int)
0006: TIMERB = 0
03E3: set_texture_to_be_drawn_antialiased 1
038D: draw_texture 18 position $tempvar_Float_1 $tempvar_Float_2 size 21@ 22@ RGBA 128 128 128 24@
000A: 23@ += 1
0002: jump @BDISPLY_2214

:BDISPLY_2001
00D6: if 
001D:   27@ > TIMERB  // (int)
004D: jump_if_false @BDISPLY_2059
03E3: set_texture_to_be_drawn_antialiased 1
038D: draw_texture 18 position $tempvar_Float_1 $tempvar_Float_2 size 21@ 22@ RGBA 128 128 128 24@
0002: jump @BDISPLY_2098

:BDISPLY_2059
03E3: set_texture_to_be_drawn_antialiased 1
038D: draw_texture 18 position $tempvar_Float_1 $tempvar_Float_2 size 21@ 22@ RGBA 128 128 128 24@
000A: 23@ += 1

:BDISPLY_2098
0002: jump @BDISPLY_2214

:BDISPLY_2105
0085: 1@ = 26@  // (int)
0072: 1@ /= 17@  // (int)
0012: 1@ *= 4
0062: 24@ -= 1@  // (int)
00D6: if 
002B:   0 >= 24@
004D: jump_if_false @BDISPLY_2175
0006: 24@ = 0
0006: 23@ = 0
0004: $1043 = 0

:BDISPLY_2175
03E3: set_texture_to_be_drawn_antialiased 1
038D: draw_texture 18 position $tempvar_Float_1 $tempvar_Float_2 size 21@ 22@ RGBA 128 128 128 24@
0002: jump @BDISPLY_2214

:BDISPLY_2214
0051: return




//------------//------------//------------//------------




//------------//------------//------------//------------












//-------------Mission 0---------------
//-------------Mission 31---------------
// Originally: Life's a Beach

:MUSIC1
03A4: script_name 'MUSIC1'
03A4: script_name 'MUSIC1'
0050: gosub @MUSIC1_47
00D6: if 
0112:   wasted_or_busted // mission only
004D: jump_if_false @MUSIC1_38
0050: gosub @MUSIC1_15556

:MUSIC1_38
0050: gosub @MUSIC1_15629
004E: terminate_this_script

:MUSIC1_47
0317: increment_mission_attempts
054C: use_GXT_table 'STRAP1'
0004: $ONMISSION = 1
0001: wait 0 ms
0007: 34@ = 526.84
0007: 35@ = -1885.19
0007: 36@ = 2.4
0087: 39@ = 34@  // (float)
000B: 39@ += 2.5
0087: 40@ = 35@  // (float)
000B: 40@ += 3.5
0007: 41@ = 2.79
0087: 42@ = 34@  // (float)
000F: 42@ -= 7.0
0087: 43@ = 35@  // (float)
000F: 43@ -= 9.8
0007: 44@ = 2.06
0087: 48@ = 39@  // (float)
000B: 48@ += 9.0
0087: 49@ = 40@  // (float)
000B: 49@ += 4.0
0087: 50@ = 41@  // (float)
0007: 51@ = 340.0
0007: 52@ = 1643.42
0007: 53@ = -1524.69
0007: 54@ = 12.61
0087: 56@ = 48@  // (float)
000F: 56@ -= 1.08
0087: 57@ = 49@  // (float)
000F: 57@ -= 3.05
0087: 58@ = 56@  // (float)
000F: 58@ -= 0.54
0087: 59@ = 57@  // (float)
000F: 59@ -= 1.53
0007: 60@ = 3.14
0006: 61@ = 21
0087: 83@ = 39@  // (float)
000B: 83@ += 10.0
0087: 104@ = 40@  // (float)
000F: 104@ -= 6.0
0007: 125@ = 300.0
0087: 84@ = 83@  // (float)
000B: 84@ += 3.0
0087: 105@ = 104@  // (float)
0087: 126@ = 125@  // (float)
000B: 126@ += 120.0
0087: 85@ = 83@  // (float)
000B: 85@ += 3.0
0087: 106@ = 104@  // (float)
000B: 106@ += 3.0
0087: 127@ = 125@  // (float)
000B: 127@ += 240.0
0087: 86@ = 34@  // (float)
000B: 86@ += 17.5
0087: 107@ = 35@  // (float)
000B: 107@ += 3.0
0007: 128@ = 270.0
0087: 87@ = 86@  // (float)
000B: 87@ += 1.0
0087: 108@ = 107@  // (float)
0087: 129@ = 128@  // (float)
000F: 129@ -= 180.0
0087: 88@ = 39@  // (float)
000F: 88@ -= 2.0
0087: 109@ = 40@  // (float)
000F: 109@ -= 8.0
0007: 130@ = 315.0
0087: 89@ = 88@  // (float)
000B: 89@ += 2.5
0087: 110@ = 109@  // (float)
0087: 131@ = 130@  // (float)
000B: 131@ += 90.0
0087: 90@ = 88@  // (float)
000B: 90@ += 2.5
0087: 111@ = 109@  // (float)
000B: 111@ += 2.5
0087: 132@ = 130@  // (float)
000B: 132@ += 180.0
0087: 91@ = 88@  // (float)
0087: 112@ = 109@  // (float)
000B: 112@ += 2.5
0087: 133@ = 130@  // (float)
000B: 133@ += 270.0
0087: 92@ = 34@  // (float)
000B: 92@ += 12.0
0087: 113@ = 35@  // (float)
000F: 113@ -= 9.5
0007: 134@ = 0.0
0087: 93@ = 92@  // (float)
000F: 93@ -= 0.5
0087: 114@ = 113@  // (float)
000B: 114@ += 1.5
0087: 135@ = 134@  // (float)
000B: 135@ += 180.0
0087: 94@ = 42@  // (float)
0087: 115@ = 43@  // (float)
000B: 115@ += 5.0
0007: 136@ = 200.0
0087: 95@ = 42@  // (float)
000B: 95@ += 3.0
0087: 116@ = 43@  // (float)
000B: 116@ += 3.5
0007: 137@ = 170.0
0087: 96@ = 42@  // (float)
000B: 96@ += 4.0
0087: 117@ = 43@  // (float)
0007: 138@ = 0.0
0087: 97@ = 42@  // (float)
000B: 97@ += 5.0
0087: 118@ = 43@  // (float)
000B: 118@ += 2.0
0007: 139@ = 270.0
0087: 98@ = 39@  // (float)
000B: 98@ += 1.0
0087: 119@ = 40@  // (float)
000B: 119@ += 6.0
0007: 140@ = 270.0
0087: 99@ = 98@  // (float)
000B: 99@ += 1.5
0087: 120@ = 119@  // (float)
000B: 120@ += 1.5
0087: 141@ = 140@  // (float)
000F: 141@ -= 90.0
0087: 100@ = 98@  // (float)
000B: 100@ += 3.0
0087: 121@ = 119@  // (float)
0087: 142@ = 140@  // (float)
000F: 142@ -= 180.0
0087: 101@ = 98@  // (float)
000B: 101@ += 1.5
0087: 122@ = 119@  // (float)
000F: 122@ -= 1.5
0087: 143@ = 140@  // (float)
000F: 143@ -= 270.0
0087: 102@ = 48@  // (float)
000F: 102@ -= 3.0
0087: 123@ = 49@  // (float)
000F: 123@ -= 1.0
0007: 144@ = 0.0
0087: 103@ = 102@  // (float)
0087: 124@ = 123@  // (float)
000B: 124@ += 1.0
0087: 145@ = 144@  // (float)
000B: 145@ += 180.0
0007: 162@ = 20.0
0087: 163@ = 162@  // (float)
0013: 163@ *= 4.0
0006: 146@ = 7
0050: gosub @MUSIC1_13984
0006: 187@ = 0
0006: 188@ = 0
0006: 190@ = 0
0006: 192@ = 0
0006: 193@ = 0
0006: 194@ = 0
0006: 195@ = 0
0006: 197@ = 0
0006: 198@ = 0
0006: 199@ = 0
0006: 200@ = 0
0006: 201@ = 0
0006: 202@ = 0
0006: 203@ = 0
0006: 204@ = 0
0006: 207@ = 0
0006: 208@ = 0
0006: 205@ = 0
0006: 206@ = 0
0006: 209@ = 0
0006: 267@ = 0
0006: 268@ = 0
0006: 269@ = 0
0006: 231@ = 0
0006: 170@ = 0

:MUSIC1_1557
00D6: if 
001D:   61@ > 170@  // (int)
004D: jump_if_false @MUSIC1_1653
0006: 210@(170@,21i) = 0
0006: 232@(170@,21i) = 0
00D6: if 
001D:   146@ > 170@  // (int)
004D: jump_if_false @MUSIC1_1639
0006: 253@(170@,7i) = 0
0006: 260@(170@,7i) = 0

:MUSIC1_1639
000A: 170@ += 1
0002: jump @MUSIC1_1557

:MUSIC1_1653
0169: set_fade_color_RGB 0 0 0
016A: fade 0 time 2000

:MUSIC1_1668
00D6: if 
016B:   fading
004D: jump_if_false @MUSIC1_1692
0001: wait 0 ms
0002: jump @MUSIC1_1668

:MUSIC1_1692
0395: clear_area 0 at 809.5818 -1630.573 12.5469 radius 100.0
03CB: set_rendering_origin_at 809.5818 -1630.573 12.5469
08F5: save_player_group
02E4: load_cutscene_data 'STRAP1A'

:MUSIC1_1746
00D6: if 
86B9:   not cutscene_data_loaded
004D: jump_if_false @MUSIC1_1770
0001: wait 0 ms
0002: jump @MUSIC1_1746

:MUSIC1_1770
02E7: start_cutscene
016A: fade 1 time 1000

:MUSIC1_1779
00D6: if 
82E9:   not cutscene_reached_end
004D: jump_if_false @MUSIC1_1803
0001: wait 0 ms
0002: jump @MUSIC1_1779

:MUSIC1_1803
016A: fade 0 time 0

:MUSIC1_1809
00D6: if 
016B:   fading
004D: jump_if_false @MUSIC1_1833
0001: wait 0 ms
0002: jump @MUSIC1_1809

:MUSIC1_1833
02EA: end_cutscene
01B4: set_player $PLAYER_CHAR can_move False
08F6: restore_player_group
0247: load_model #VOODOO
0247: load_model #ESPERANT
0247: load_model #OCEANIC
0247: load_model #PONY
0247: load_model #MP5LNG
0247: load_model #BFYST
0247: load_model #WFYST
0247: load_model #BMYST
0247: load_model #WMYRO
0247: load_model #WFYCLOT
0247: load_model #WMYST
0247: load_model #WMYCLOT
0247: load_model #BMYDJ
0247: load_model #WFYRI
0247: load_model #OFYRI
06E9: load_car_component #WHEEL_OR1
08A9: load_external_script 0 (DANCE)
038B: load_requested_models

:MUSIC1_1922
00D6: if or
8248:   not model #VOODOO available
8248:   not model #ESPERANT available
8248:   not model #OCEANIC available
8248:   not model #PONY available
8248:   not model #MP5LNG available
004D: jump_if_false @MUSIC1_1969
0001: wait 0 ms
0002: jump @MUSIC1_1922

:MUSIC1_1969
00D6: if 
8248:   not model #BFYST available
004D: jump_if_false @MUSIC1_1995
0001: wait 0 ms
0002: jump @MUSIC1_1969

:MUSIC1_1995
00D6: if or
8248:   not model #WFYST available
8248:   not model #BMYST available
8248:   not model #WMYRO available
8248:   not model #WFYCLOT available
8248:   not model #WMYST available
8248:   not model #WMYCLOT available
004D: jump_if_false @MUSIC1_2043
0001: wait 0 ms
0002: jump @MUSIC1_1995

:MUSIC1_2043
00D6: if or
8248:   not model #BMYDJ available
8248:   not model #WFYRI available
8248:   not model #OFYRI available
004D: jump_if_false @MUSIC1_2077
0001: wait 0 ms
0002: jump @MUSIC1_2043

:MUSIC1_2077
00D6: if or
86EA:   not car_component #WHEEL_OR1 available
88AB:   not external_script 0 (DANCE) loaded
004D: jump_if_false @MUSIC1_2108
0001: wait 0 ms
0002: jump @MUSIC1_2077

:MUSIC1_2108
02FA: set_garage 'MUL_LAN' type 19
022B: create_forbidden_for_peds_cube_cornerA 502.15 -1913.39 -5.0 cornerB 558.86 -1838.87 10.0
03CB: set_rendering_origin_at 809.5818 -1630.573 12.5469
01B6: set_weather 1
00A1: put_actor $PLAYER_ACTOR at 809.5818 -1630.573 12.5469
0173: set_actor $PLAYER_ACTOR Z_angle_to 176.0
0373: set_camera_directly_behind_player
02EB: restore_camera_with_jumpcut
0169: set_fade_color_RGB 0 0 0
0001: wait 500 ms
016A: fade 1 time 1500
01B4: set_player $PLAYER_CHAR can_move True
018A: 271@ = create_checkpoint_at 58@ 59@ 60@
00BC: show_text_highpriority GXT 'MUS1_5' time 10000 flag 0 // ~s~Go to the ~y~beach party~s~.
00D6: if 
0039:   192@ == 1
004D: jump_if_false @MUSIC1_2489
00A5: 47@ = create_car #PONY at 0.0 0.0 -100.0
0186: 272@ = create_marker_above_car 47@
009A: 55@ = create_actor_pedtype 24 model #BFYST at 0.0 0.0 -100.0
0615: define_AS_pack_begin 181@
05BA: AS_actor -1 move_mouth -2 ms
0616: define_AS_pack_end 181@
0006: 170@ = 0

:MUSIC1_2361
00D6: if 
001D:   61@ > 170@  // (int)
004D: jump_if_false @MUSIC1_2422
009A: 62@(170@,21i) = create_actor_pedtype 24 model #BFYST at 0.0 0.0 -100.0
000A: 170@ += 1
0002: jump @MUSIC1_2361

:MUSIC1_2422
0006: 170@ = 0

:MUSIC1_2429
00D6: if 
001D:   146@ > 170@  // (int)
004D: jump_if_false @MUSIC1_2489
00A5: 147@(170@,7i) = create_car #VOODOO at 0.0 0.0 -100.0
000A: 170@ += 1
0002: jump @MUSIC1_2429

:MUSIC1_2489
0001: wait 0 ms
00D6: if 
0735: is_keyboard_key_pressed 83
004D: jump_if_false @MUSIC1_2515
0002: jump @MUSIC1_15574

:MUSIC1_2515
01B6: set_weather 1
00D6: if 
8039:   not 193@ == 1
004D: jump_if_false @MUSIC1_2925
00D6: if 
00EC:   actor $PLAYER_ACTOR sphere 0 near_point 34@ 35@ radius 200.0 200.0
004D: jump_if_false @MUSIC1_2925
0395: clear_area 0 at 34@ 35@ 36@ radius 100.0
0050: gosub @MUSIC1_6819
0087: 274@ = 39@  // (float)
000B: 274@ += 0.15
0087: 275@ = 40@  // (float)
000B: 275@ += 0.15
029B: 45@ = init_object #DYN_WOODPILE2 at 274@ 275@ 2.6
0087: 274@ = 42@  // (float)
000B: 274@ += 0.15
0087: 275@ = 43@  // (float)
000B: 275@ += 0.15
029B: 46@ = init_object #DYN_WOODPILE2 at 274@ 275@ 2.31
08D2: object 45@ scale_model 0.5
08D2: object 46@ scale_model 0.5
07F7: set_object 45@ destructible False
07F7: set_object 46@ destructible False
0917: audio_zone 'BEACH' enable_sound 1
0001: wait 1500 ms
0050: gosub @MUSIC1_8085
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_2788
04D7: set_actor 55@ locked True

:MUSIC1_2788
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_2811
0519: set_car 47@ locked True

:MUSIC1_2811
00D6: if 
03CA:   object 45@ exists
004D: jump_if_false @MUSIC1_2834
0550: keep_object 45@ in_memory True

:MUSIC1_2834
00D6: if 
03CA:   object 46@ exists
004D: jump_if_false @MUSIC1_2857
0550: keep_object 46@ in_memory True

:MUSIC1_2857
064B: 37@ = create_particle ""FIRE"" at 39@ 40@ 41@ type 1
064B: 38@ = create_particle ""FIRE"" at 42@ 43@ 44@ type 1
064C: make_particle 37@ visible
064C: make_particle 38@ visible
0006: 270@ = 1
0006: 193@ = 1

:MUSIC1_2925
00D6: if 
0039:   193@ == 1
004D: jump_if_false @MUSIC1_6812
00BF: 175@ = current_time_hours, 176@ = current_time_minutes
00D6: if and
0029:   175@ >= 6
001B:   22 > 175@
004D: jump_if_false @MUSIC1_3018
00D6: if 
0039:   270@ == 1
004D: jump_if_false @MUSIC1_3011
064E: stop_particle 37@
064E: stop_particle 38@
0006: 270@ = 0

:MUSIC1_3011
0002: jump @MUSIC1_3053

:MUSIC1_3018
00D6: if 
0039:   270@ == 0
004D: jump_if_false @MUSIC1_3053
064C: make_particle 37@ visible
064C: make_particle 38@ visible
0006: 270@ = 1

:MUSIC1_3053
00D6: if and
8039:   not 194@ == 1
00EC:   actor $PLAYER_ACTOR sphere 0 near_point 34@ 35@ radius 50.0 50.0
004D: jump_if_false @MUSIC1_3108
0050: gosub @MUSIC1_14856
0006: 194@ = 1

:MUSIC1_3108
00D6: if 
0039:   203@ == 0
004D: jump_if_false @MUSIC1_6025
00D6: if and
8039:   not 195@ == 1
8039:   not 197@ == 1
8039:   not 199@ == 1
004D: jump_if_false @MUSIC1_3314
00D6: if and
8118:   not actor 55@ dead
00FF:   actor $PLAYER_ACTOR sphere 1 in_sphere 58@ 59@ 60@ radius 1.2 1.2 2.0 on_foot
004D: jump_if_false @MUSIC1_3314
0164: disable_marker 271@
0687: clear_actor 55@ task
0173: set_actor 55@ Z_angle_to 110.0
0050: gosub @MUSIC1_12841
03E5: show_text_box 'TALK_1' // To reply negatively press ~k~~CONVERSATION_NO~~n~To reply positively press ~k~~CONVERSATION_YES~
0006: 195@ = 1
0006: 196@ = 0
01B4: set_player $PLAYER_CHAR can_move False
00A1: put_actor $PLAYER_ACTOR at 58@ 59@ 2.3
0173: set_actor $PLAYER_ACTOR Z_angle_to 290.0
0A25: set_camera_on_players_X_angle 0.031 Z_angle -2.152
0001: wait 1000 ms
01B4: set_player $PLAYER_CHAR can_move True

:MUSIC1_3314
00D6: if and
0039:   195@ == 1
8039:   not 197@ == 1
004D: jump_if_false @MUSIC1_4324
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_4324
00D6: if 
071A:   actor 55@ current_dialogue_text == 287@s
004D: jump_if_false @MUSIC1_4018
01B4: set_player $PLAYER_CHAR can_move False
00D6: if 
88AB:   not external_script 0 (DANCE) loaded
004D: jump_if_false @MUSIC1_3400
08A9: load_external_script 0 (DANCE)

:MUSIC1_3400
016A: fade 0 time 1000

:MUSIC1_3407
00D6: if or
016B:   fading
88AB:   not external_script 0 (DANCE) loaded
004D: jump_if_false @MUSIC1_3435
0001: wait 0 ms
0002: jump @MUSIC1_3407

:MUSIC1_3435
03E6: remove_text_box
00D6: if 
00DF:   actor $PLAYER_ACTOR driving
004D: jump_if_false @MUSIC1_3480
0362: remove_actor $PLAYER_ACTOR from_car_and_place_at 533.81 -1891.64 -100.0
0002: jump @MUSIC1_3500

:MUSIC1_3480
00A1: put_actor $PLAYER_ACTOR at 533.81 -1891.64 -100.0

:MUSIC1_3500
01B9: set_actor $PLAYER_ACTOR armed_weapon_to 0
0395: clear_area 0 at 533.81 -1891.64 2.27 radius 10.0
0006: 170@ = 0

:MUSIC1_3538
00D6: if 
001D:   146@ > 170@  // (int)
004D: jump_if_false @MUSIC1_3668
00D6: if 
8119:   not car 147@(170@,7i) wrecked
004D: jump_if_false @MUSIC1_3645
00D6: if 
01AF:   car 147@(170@,7i) sphere 0 in_sphere 533.81 -1891.64 2.27 radius 10.0 10.0 10.0
004D: jump_if_false @MUSIC1_3638
00A6: destroy_car 147@(170@,7i)

:MUSIC1_3638
0002: jump @MUSIC1_3654

:MUSIC1_3645
00A6: destroy_car 147@(170@,7i)

:MUSIC1_3654
000A: 170@ += 1
0002: jump @MUSIC1_3538

:MUSIC1_3668
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_3774
08ED: remove_actor 55@ from_dialogue_mode
0792: disembark_instantly_actor 55@
0173: set_actor 55@ Z_angle_to 110.0
0615: define_AS_pack_begin 182@
0605: actor -1 perform_animation ""DAN_LOOP_A"" IFP ""DANCING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 182@ loop 1
0616: define_AS_pack_end 182@
0618: assign_actor 55@ to_AS_pack 182@
061B: remove_references_to_AS_pack 182@

:MUSIC1_3774
0917: audio_zone 'BEACH' enable_sound 0
00D6: if 
8118:   not actor 65@ dead
004D: jump_if_false @MUSIC1_3808
0792: disembark_instantly_actor 65@

:MUSIC1_3808
00D6: if 
8118:   not actor 66@ dead
004D: jump_if_false @MUSIC1_3829
0792: disembark_instantly_actor 66@

:MUSIC1_3829
00BE: text_clear_all
00BC: show_text_highpriority GXT 'MUS1_4' time 10000 flag 0 // ~s~Get a score of 2500 or greater to gain access to the sound van.
0006: 170@ = 0

:MUSIC1_3854
00D6: if 
001B:   5 > 170@
004D: jump_if_false @MUSIC1_3970
0005: $5315(170@,5f) = 531.18
0005: $5320(170@,5f) = -1893.8
0005: $5325(170@,5f) = 3.45
0005: $5330(170@,5f) = 533.94
0005: $5335(170@,5f) = -1891.82
0005: $5340(170@,5f) = 3.44
000A: 170@ += 1
0002: jump @MUSIC1_3854

:MUSIC1_3970
08BA: set $5295 bit 31
0913: run_external_script 0 (DANCE) 533.81 -1891.64 -100.0 51@ 1 -1 
0006: 197@ = 1
0002: jump @MUSIC1_4324

:MUSIC1_4018
00D6: if 
8039:   not 196@ == 1
004D: jump_if_false @MUSIC1_4215
00D6: if or
071A:   actor 55@ current_dialogue_text == 285@s
071A:   actor 55@ current_dialogue_text == 289@s
004D: jump_if_false @MUSIC1_4077
0006: 196@ = 1
0002: jump @MUSIC1_4208

:MUSIC1_4077
00D6: if 
00F2:   actor $PLAYER_ACTOR near_actor 55@ radius 5.0 5.0 0
004D: jump_if_false @MUSIC1_4122
0006: TIMERB = 0
0002: jump @MUSIC1_4208

:MUSIC1_4122
00D6: if 
0019:   TIMERB > 3000
004D: jump_if_false @MUSIC1_4208
08ED: remove_actor 55@ from_dialogue_mode
03E6: remove_text_box
00A1: put_actor 55@ at 56@ 57@ -100.0
0173: set_actor 55@ Z_angle_to 51@
0618: assign_actor 55@ to_AS_pack 181@
0006: 195@ = 0
0006: 196@ = 0
018A: 271@ = create_checkpoint_at 58@ 59@ 60@

:MUSIC1_4208
0002: jump @MUSIC1_4324

:MUSIC1_4215
00D6: if 
80FF:   not actor $PLAYER_ACTOR sphere 0 in_sphere 58@ 59@ 60@ radius 1.2 1.2 2.0 on_foot
004D: jump_if_false @MUSIC1_4324
0006: 196@ = 0
08ED: remove_actor 55@ from_dialogue_mode
03E6: remove_text_box
00A1: put_actor 55@ at 56@ 57@ -100.0
0173: set_actor 55@ Z_angle_to 51@
0618: assign_actor 55@ to_AS_pack 181@
0006: 195@ = 0
018A: 271@ = create_checkpoint_at 58@ 59@ 60@

:MUSIC1_4324
00D6: if and
0039:   197@ == 1
8039:   not 199@ == 1
004D: jump_if_false @MUSIC1_4626
00D6: if and
88B4:   not test $5295 bit 31
8039:   not 198@ == 1
004D: jump_if_false @MUSIC1_4510
01B4: set_player $PLAYER_CHAR can_move True
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_4402
0792: disembark_instantly_actor 55@

:MUSIC1_4402
00BE: text_clear_all
00D6: if 
0028:   $DANCE_SCORE >= 2500
004D: jump_if_false @MUSIC1_4482
0917: audio_zone 'BEACH' enable_sound 1
0050: gosub @MUSIC1_13655
03E5: show_text_box 'TALK_1' // To reply negatively press ~k~~CONVERSATION_NO~~n~To reply positively press ~k~~CONVERSATION_YES~
0006: 199@ = 1
0006: 200@ = 1
0006: 196@ = 0
0002: jump @MUSIC1_4510

:MUSIC1_4482
0006: 191@ = 1
0050: gosub @MUSIC1_15131
0006: TIMERA = 0
0006: 198@ = 1

:MUSIC1_4510
00D6: if 
0039:   198@ == 1
004D: jump_if_false @MUSIC1_4626
00D6: if and
001D:   189@ > 188@  // (int)
0039:   191@ == 1
004D: jump_if_false @MUSIC1_4584
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_4577
0050: gosub @MUSIC1_15302

:MUSIC1_4577
0002: jump @MUSIC1_4626

:MUSIC1_4584
00D6: if 
0019:   TIMERA > 1000
004D: jump_if_false @MUSIC1_4626
00BC: show_text_highpriority GXT 'MUS1_8' time 5000 flag 0 // ~r~You need more practice!
0002: jump @MUSIC1_15556

:MUSIC1_4626
00D6: if and
0039:   199@ == 1
8039:   not 201@ == 1
004D: jump_if_false @MUSIC1_5227
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_5227
00D6: if 
8039:   not 200@ == 1
004D: jump_if_false @MUSIC1_4786
00D6: if 
00FF:   actor $PLAYER_ACTOR sphere 1 in_sphere 58@ 59@ 60@ radius 1.2 1.2 2.0 on_foot
004D: jump_if_false @MUSIC1_4779
0164: disable_marker 271@
0687: clear_actor 55@ task
0173: set_actor 55@ Z_angle_to 110.0
0050: gosub @MUSIC1_13655
03E5: show_text_box 'TALK_1' // To reply negatively press ~k~~CONVERSATION_NO~~n~To reply positively press ~k~~CONVERSATION_YES~
0006: 200@ = 1
0006: 196@ = 0

:MUSIC1_4779
0002: jump @MUSIC1_5227

:MUSIC1_4786
00D6: if or
071A:   actor 55@ current_dialogue_text == 'VYES1' // ~z~C'mon, homeboy.
071A:   actor 55@ current_dialogue_text == 'VYES2' // ~z~Let me take you into my office...
004D: jump_if_false @MUSIC1_4923
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_4916
08ED: remove_actor 55@ from_dialogue_mode
03E6: remove_text_box
07A1: set_walk_speed 4
04D7: set_actor 55@ locked False
05CA: AS_actor 55@ enter_car 47@ passenger_seat 0 time -1
0186: 272@ = create_marker_above_car 47@
07E0: set_marker 272@ type_to 1
0006: 200@ = 0
0006: 201@ = 1
00BB: show_text_lowpriority GXT 'MUS1_7' time 10000 flag 0 // ~s~Steal the ~b~sound van.

:MUSIC1_4916
0002: jump @MUSIC1_5227

:MUSIC1_4923
00D6: if 
8039:   not 196@ == 1
004D: jump_if_false @MUSIC1_5118
00D6: if 
071A:   actor 55@ current_dialogue_text == 'VLATE' // ~z~Well, I'm here for a while, if you change your mind!
004D: jump_if_false @MUSIC1_4980
0006: 196@ = 1
0002: jump @MUSIC1_5111

:MUSIC1_4980
00D6: if 
00F2:   actor $PLAYER_ACTOR near_actor 55@ radius 5.0 5.0 0
004D: jump_if_false @MUSIC1_5025
0006: TIMERB = 0
0002: jump @MUSIC1_5111

:MUSIC1_5025
00D6: if 
0019:   TIMERB > 3000
004D: jump_if_false @MUSIC1_5111
08ED: remove_actor 55@ from_dialogue_mode
03E6: remove_text_box
00A1: put_actor 55@ at 56@ 57@ -100.0
0173: set_actor 55@ Z_angle_to 51@
0618: assign_actor 55@ to_AS_pack 181@
0006: 200@ = 0
0006: 196@ = 0
018A: 271@ = create_checkpoint_at 58@ 59@ 60@

:MUSIC1_5111
0002: jump @MUSIC1_5227

:MUSIC1_5118
00D6: if 
80FF:   not actor $PLAYER_ACTOR sphere 0 in_sphere 58@ 59@ 60@ radius 1.2 1.2 2.0 on_foot
004D: jump_if_false @MUSIC1_5227
0006: 196@ = 0
08ED: remove_actor 55@ from_dialogue_mode
03E6: remove_text_box
00A1: put_actor 55@ at 56@ 57@ -100.0
0173: set_actor 55@ Z_angle_to 51@
0618: assign_actor 55@ to_AS_pack 181@
0006: 200@ = 0
018A: 271@ = create_checkpoint_at 58@ 59@ 60@

:MUSIC1_5227
00D6: if and
0039:   201@ == 1
8039:   not 202@ == 1
8118:   not actor 55@ dead
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_5330
00D6: if 
00DB:   actor 55@ in_car 47@
004D: jump_if_false @MUSIC1_5330
020A: set_car 47@ door_status_to 1
095E: set_car 47@ door 4 unlatch 1 angle -1.0
095E: set_car 47@ door 5 unlatch 1 angle -1.0
0852: set_car 47@ damages_visible 1
0006: 202@ = 1

:MUSIC1_5330
00D6: if 
8039:   not 268@ == 1
004D: jump_if_false @MUSIC1_5770
00D6: if and
00EC:   actor $PLAYER_ACTOR sphere 0 near_point 34@ 35@ radius 162@ 162@
02E0:   actor $PLAYER_ACTOR firing_weapon
004D: jump_if_false @MUSIC1_5397
0006: 268@ = 1
0002: jump @MUSIC1_5571

:MUSIC1_5397
00D6: if 
0118:   actor 55@ dead
004D: jump_if_false @MUSIC1_5427
0006: 268@ = 1
0002: jump @MUSIC1_5460

:MUSIC1_5427
00D6: if or
051A:   actor 55@ damaged_by_actor $PLAYER_ACTOR
074F:   actor 55@ ped_event == 31
004D: jump_if_false @MUSIC1_5460
0006: 268@ = 1

:MUSIC1_5460
0006: 170@ = 0

:MUSIC1_5467
00D6: if and
001D:   61@ > 170@  // (int)
8039:   not 268@ == 1
004D: jump_if_false @MUSIC1_5571
00D6: if 
0118:   actor 62@(170@,21i) dead
004D: jump_if_false @MUSIC1_5527
0006: 268@ = 1
0002: jump @MUSIC1_5557

:MUSIC1_5527
00D6: if 
051A:   actor 62@(170@,21i) damaged_by_actor $PLAYER_ACTOR
004D: jump_if_false @MUSIC1_5557
0006: 268@ = 1

:MUSIC1_5557
000A: 170@ += 1
0002: jump @MUSIC1_5467

:MUSIC1_5571
00D6: if 
0039:   268@ == 1
004D: jump_if_false @MUSIC1_5738
040D: unload_wav 1
00BE: text_clear_all
00D6: if 
8039:   not 202@ == 1
004D: jump_if_false @MUSIC1_5634
0050: gosub @MUSIC1_10052
0050: gosub @MUSIC1_10452
0002: jump @MUSIC1_5718

:MUSIC1_5634
00D6: if 
8039:   not 209@ == 1
004D: jump_if_false @MUSIC1_5666
0050: gosub @MUSIC1_10726
0006: 209@ = 1

:MUSIC1_5666
00D6: if and
8118:   not actor 55@ dead
8039:   not 231@ == 1
004D: jump_if_false @MUSIC1_5718
01B9: set_actor 55@ armed_weapon_to 29
05E2: AS_actor 55@ kill_actor $PLAYER_ACTOR
0006: 231@ = 1
0961: set_actor 55@ keep_tasks_after_cleanup 1

:MUSIC1_5718
0917: audio_zone 'BEACH' enable_sound 0
0002: jump @MUSIC1_5770

:MUSIC1_5738
00D6: if or
8039:   not 197@ == 1
0039:   199@ == 1
004D: jump_if_false @MUSIC1_5770
0050: gosub @MUSIC1_9958

:MUSIC1_5770
00D6: if and
0039:   202@ == 1
0039:   268@ == 1
004D: jump_if_false @MUSIC1_5827
00D6: if and
0039:   209@ == 1
8039:   not 269@ == 1
004D: jump_if_false @MUSIC1_5827
0050: gosub @MUSIC1_11354

:MUSIC1_5827
00D6: if and
8039:   not 207@ == 1
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_5927
00D6: if 
00DB:   actor $PLAYER_ACTOR in_car 47@
004D: jump_if_false @MUSIC1_5927
0164: disable_marker 272@
0006: 207@ = 1
0006: 208@ = 1
0519: set_car 47@ locked False
0373: set_camera_directly_behind_player
00BC: show_text_highpriority GXT 'MUS1_19' time 7000 flag 0 // ~s~Get the van back to the ~y~garage.
018A: 273@ = create_checkpoint_at 52@ 53@ 54@

:MUSIC1_5927
00D6: if 
0039:   207@ == 1
004D: jump_if_false @MUSIC1_6025
0050: gosub @MUSIC1_14690
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_6025
00D6: if 
81AD:   not car 47@ sphere 0 near_point 34@ 35@ radius 162@ 162@
004D: jump_if_false @MUSIC1_6025
02AA: set_car 47@ immune_to_nonplayer False
0006: 203@ = 1
0917: audio_zone 'BEACH' enable_sound 0

:MUSIC1_6025
00D6: if 
0039:   203@ == 1
004D: jump_if_false @MUSIC1_6555
00D6: if and
8039:   not 204@ == 1
8118:   not actor 55@ dead
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_6115
0615: define_AS_pack_begin 177@
0622: AS_actor -1 bail_car 47@
05E2: AS_actor -1 kill_actor $PLAYER_ACTOR
0616: define_AS_pack_end 177@
0618: assign_actor 55@ to_AS_pack 177@
061B: remove_references_to_AS_pack 177@
0006: 204@ = 1

:MUSIC1_6115
00D6: if and
0039:   204@ == 1
8118:   not actor 55@ dead
8039:   not 205@ == 1
004D: jump_if_false @MUSIC1_6228
062E: get_actor 55@ task 1560 status_store_to 178@ // ret 7 if not found
00D6: if 
84A4:   not 178@ == 7  //  == constant
004D: jump_if_false @MUSIC1_6228
0646: unknown_get_actor 55@ task_1560_status_store_to 179@ // similar to 062E
00D6: if 
0029:   179@ >= 0
004D: jump_if_false @MUSIC1_6228
0006: 191@ = 0
0050: gosub @MUSIC1_15131
01B9: set_actor 55@ armed_weapon_to 29
0006: 205@ = 1

:MUSIC1_6228
00D6: if and
0039:   205@ == 1
8039:   not 206@ == 1
004D: jump_if_false @MUSIC1_6336
00D6: if and
001D:   189@ > 188@  // (int)
0039:   191@ == 0
004D: jump_if_false @MUSIC1_6329
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_6309
0050: gosub @MUSIC1_15302
0002: jump @MUSIC1_6322

:MUSIC1_6309
040D: unload_wav 1
00BE: text_clear_all
0006: 206@ = 1

:MUSIC1_6322
0002: jump @MUSIC1_6336

:MUSIC1_6329
0006: 206@ = 1

:MUSIC1_6336
00D6: if 
8039:   not 209@ == 1
004D: jump_if_false @MUSIC1_6368
0050: gosub @MUSIC1_10726
0006: 209@ = 1

:MUSIC1_6368
00D6: if 
8039:   not 269@ == 1
004D: jump_if_false @MUSIC1_6393
0050: gosub @MUSIC1_11354

:MUSIC1_6393
00D6: if and
0039:   209@ == 1
8039:   not 267@ == 1
004D: jump_if_false @MUSIC1_6462
00D6: if 
80EC:   not actor $PLAYER_ACTOR sphere 0 near_point 34@ 35@ radius 163@ 163@
004D: jump_if_false @MUSIC1_6462
0050: gosub @MUSIC1_10228
0006: 267@ = 1

:MUSIC1_6462
00D6: if and
0039:   209@ == 1
8119:   not car 47@ wrecked
8039:   not 269@ == 1
004D: jump_if_false @MUSIC1_6548
00D6: if and
00DB:   actor $PLAYER_ACTOR in_car 47@
00EE:   actor $PLAYER_ACTOR sphere 0 near_point 52@ 53@ radius 50.0 50.0 in_car
004D: jump_if_false @MUSIC1_6548
0050: gosub @MUSIC1_11771
0006: 269@ = 1

:MUSIC1_6548
0050: gosub @MUSIC1_14690

:MUSIC1_6555
00D6: if 
8039:   not 202@ == 1
004D: jump_if_false @MUSIC1_6664
00D6: if 
0118:   actor 55@ dead
004D: jump_if_false @MUSIC1_6621
00BE: text_clear_all
00BC: show_text_highpriority GXT 'MUS1_18' time 5000 flag 0 // ~r~The DJ died!
0002: jump @MUSIC1_15556
0002: jump @MUSIC1_6664

:MUSIC1_6621
00D6: if 
0039:   268@ == 1
004D: jump_if_false @MUSIC1_6664
00BE: text_clear_all
00BC: show_text_highpriority GXT 'MUS1_21' time 5000 flag 0 // ~r~You wrecked the party!
0002: jump @MUSIC1_15556

:MUSIC1_6664
00D6: if 
0119:   car 47@ wrecked
004D: jump_if_false @MUSIC1_6712
00BE: text_clear_all
00BC: show_text_highpriority GXT 'MUS1_20' time 5000 flag 0 // ~r~The van was destroyed!
0002: jump @MUSIC1_15556
0002: jump @MUSIC1_6812

:MUSIC1_6712
00D6: if 
0039:   207@ == 1
004D: jump_if_false @MUSIC1_6812
00D6: if 
00DB:   actor $PLAYER_ACTOR in_car 47@
004D: jump_if_false @MUSIC1_6812
00D6: if 
01AF:   car 47@ sphere 1 in_sphere 52@ 53@ 54@ radius 4.0 4.0 2.0
004D: jump_if_false @MUSIC1_6812
01B4: set_player $PLAYER_CHAR can_move False
0050: gosub @MUSIC1_11889
0002: jump @MUSIC1_15574

:MUSIC1_6812
0002: jump @MUSIC1_2489

:MUSIC1_6819
0006: 170@ = 0
0007: 164@ = -30.0

:MUSIC1_6836
00D6: if 
001D:   146@ > 170@  // (int)
004D: jump_if_false @MUSIC1_7108
02F7: 165@ = cosine 164@ // (float)
02F6: 166@ = sine 164@ // (float)
006B: 165@ *= 162@  // (float)
006B: 166@ *= 162@  // (float)
005B: 165@ += 34@  // (float)
005B: 166@ += 35@  // (float)
00D6: if or
0039:   170@ == 0
0039:   170@ == 3
0039:   170@ == 6
004D: jump_if_false @MUSIC1_6965
00A5: 147@(170@,7i) = create_car #VOODOO at 165@ 166@ -100.0
0002: jump @MUSIC1_7043

:MUSIC1_6965
00D6: if or
0039:   170@ == 1
0039:   170@ == 7
004D: jump_if_false @MUSIC1_7020
00A5: 147@(170@,7i) = create_car #OCEANIC at 165@ 166@ -100.0
0002: jump @MUSIC1_7043

:MUSIC1_7020
00A5: 147@(170@,7i) = create_car #ESPERANT at 165@ 166@ -100.0

:MUSIC1_7043
0007: 168@ = 90.0
005B: 168@ += 164@  // (float)
0175: set_car 147@(170@,7i) Z_angle_to 168@
020A: set_car 147@(170@,7i) door_status_to 2
000B: 164@ += 37.0
000A: 170@ += 1
0002: jump @MUSIC1_6836

:MUSIC1_7108
0506: set_car_model #PONY next_variation 0 0 // first param is useless
00A5: 47@ = create_car #PONY at 48@ 49@ 50@
06E7: 276@ = add_car_component #WHEEL_OR1 to_car 47@
0175: set_car 47@ Z_angle_to 51@
00A9: set_car 47@ to_normal_driver
02AA: set_car 47@ immune_to_nonplayer True
0224: set_car 47@ health_to 5000
0229: set_car 47@ primary_color_to 4 secondary_color_to 4
053F: set_car 47@ tires_vulnerability 0
0423: set_car 47@ improved_handling_to 2.0 // (float)
0657: car 47@ open_door 4
0657: car 47@ open_door 5
020A: set_car 47@ door_status_to 3
0852: set_car 47@ damages_visible 0
0001: wait 1000 ms
009A: 55@ = create_actor_pedtype 24 model #BFYST at 56@ 57@ -100.0
0173: set_actor 55@ Z_angle_to 51@
02A9: set_actor 55@ immune_to_nonplayer 1
01B2: give_actor 55@ weapon 29 ammo 99999  // Load the weapon model before using this
01B9: set_actor 55@ armed_weapon_to 0
0006: 231@ = 0
07E5: copy_decision_maker 65542 to 180@
0709: set_decision_maker 180@ on_event 31 taskID 413 respect 100.0 hate 100.0 like 100.0 dislike 100.0 in_car 0 on_foot 1 // see *.ped files
060B: set_actor 55@ decision_maker_to 180@
0006: 170@ = 0

:MUSIC1_7352
00D6: if 
001D:   61@ > 170@  // (int)
004D: jump_if_false @MUSIC1_8025
00D6: if or
0039:   170@ == 0
0039:   170@ == 4
0039:   170@ == 7
0039:   170@ == 11
004D: jump_if_false @MUSIC1_7449
009A: 62@(170@,21i) = create_actor_pedtype 24 model #BMYST at 83@(170@,21f) 104@(170@,21f) -100.0
0002: jump @MUSIC1_7945

:MUSIC1_7449
00D6: if or
0039:   170@ == 6
0039:   170@ == 3
0039:   170@ == 2
004D: jump_if_false @MUSIC1_7520
009A: 62@(170@,21i) = create_actor_pedtype 24 model #WMYST at 83@(170@,21f) 104@(170@,21f) -100.0
0002: jump @MUSIC1_7945

:MUSIC1_7520
00D6: if or
0039:   170@ == 9
0039:   170@ == 14
0039:   170@ == 17
0039:   170@ == 19
004D: jump_if_false @MUSIC1_7599
009A: 62@(170@,21i) = create_actor_pedtype 24 model #WFYCLOT at 83@(170@,21f) 104@(170@,21f) -100.0
0002: jump @MUSIC1_7945

:MUSIC1_7599
00D6: if 
0039:   170@ == 12
004D: jump_if_false @MUSIC1_7656
009A: 62@(170@,21i) = create_actor_pedtype 24 model #WMYRO at 83@(170@,21f) 104@(170@,21f) -100.0
0002: jump @MUSIC1_7945

:MUSIC1_7656
00D6: if or
0039:   170@ == 16
0039:   170@ == 10
004D: jump_if_false @MUSIC1_7720
009A: 62@(170@,21i) = create_actor_pedtype 24 model #WFYST at 83@(170@,21f) 104@(170@,21f) -100.0
0002: jump @MUSIC1_7945

:MUSIC1_7720
00D6: if or
0039:   170@ == 5
0039:   170@ == 15
004D: jump_if_false @MUSIC1_7785
009A: 62@(170@,21i) = create_actor_pedtype 24 model #WMYCLOT at 83@(170@,21f) 104@(170@,21f) -100.0
0002: jump @MUSIC1_7945

:MUSIC1_7785
00D6: if or
0039:   170@ == 8
0039:   170@ == 13
004D: jump_if_false @MUSIC1_7849
009A: 62@(170@,21i) = create_actor_pedtype 24 model #BMYDJ at 83@(170@,21f) 104@(170@,21f) -100.0
0002: jump @MUSIC1_7945

:MUSIC1_7849
00D6: if or
0039:   170@ == 1
0039:   170@ == 20
004D: jump_if_false @MUSIC1_7913
009A: 62@(170@,21i) = create_actor_pedtype 24 model #OFYRI at 83@(170@,21f) 104@(170@,21f) -100.0
0002: jump @MUSIC1_7945

:MUSIC1_7913
009A: 62@(170@,21i) = create_actor_pedtype 24 model #WFYRI at 83@(170@,21f) 104@(170@,21f) -100.0

:MUSIC1_7945
0173: set_actor 62@(170@,21i) Z_angle_to 125@(170@,21f)
01B2: give_actor 62@(170@,21i) weapon 29 ammo 99999  // Load the weapon model before using this
01B9: set_actor 62@(170@,21i) armed_weapon_to 0
060B: set_actor 62@(170@,21i) decision_maker_to 180@
0006: 210@(170@,21i) = 0
000A: 170@ += 1
0002: jump @MUSIC1_7352

:MUSIC1_8025
0249: release_model #VOODOO
0249: release_model #ESPERANT
0249: release_model #OCEANIC
0249: release_model #WFYST
0249: release_model #BMYST
0249: release_model #WMYRO
0249: release_model #WFYCLOT
0249: release_model #WMYST
0249: release_model #WMYCLOT
0249: release_model #BMYDJ
0249: release_model #WFYRI
0249: release_model #OFYRI
06EB: release_car_component #WHEEL_OR1
0051: return

:MUSIC1_8085
04ED: load_animation ""BAR""
04ED: load_animation ""DANCING""
04ED: load_animation ""BEACH""
04ED: load_animation ""SCRATCHING""

:MUSIC1_8126
00D6: if or
84EE:   not animation ""BAR"" loaded
84EE:   not animation ""DANCING"" loaded
84EE:   not animation ""BEACH"" loaded
84EE:   not animation ""SCRATCHING"" loaded
004D: jump_if_false @MUSIC1_8189
0001: wait 0 ms
0002: jump @MUSIC1_8126

:MUSIC1_8189
0615: define_AS_pack_begin 181@
0605: actor -1 perform_animation ""SCLNG_R"" IFP ""SCRATCHING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 181@ loop 1
0616: define_AS_pack_end 181@
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_8270
0618: assign_actor 55@ to_AS_pack 181@

:MUSIC1_8270
00D6: if 
8118:   not actor 62@ dead
004D: jump_if_false @MUSIC1_8354
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""DNCE_M_A"" IFP ""DANCING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 62@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_8354
00D6: if 
8118:   not actor 63@ dead
004D: jump_if_false @MUSIC1_8438
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""DNCE_M_B"" IFP ""DANCING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 63@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_8438
00D6: if 
8118:   not actor 64@ dead
004D: jump_if_false @MUSIC1_8522
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""DNCE_M_D"" IFP ""DANCING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 64@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_8522
00D6: if and
8118:   not actor 65@ dead
8118:   not actor 66@ dead
004D: jump_if_false @MUSIC1_8567
0677: AS_actor 65@ chat_with_actor 66@ lead_speaker_flag 1 unknown_flag 1
0677: AS_actor 66@ chat_with_actor 65@ lead_speaker_flag 0 unknown_flag 1

:MUSIC1_8567
00D6: if 
8118:   not actor 67@ dead
004D: jump_if_false @MUSIC1_8653
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""LAY_BAC_LOOP"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 67@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_8653
00D6: if 
8118:   not actor 68@ dead
004D: jump_if_false @MUSIC1_8741
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""PARKSIT_M_LOOP"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 68@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_8741
00D6: if 
8118:   not actor 69@ dead
004D: jump_if_false @MUSIC1_8827
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""LAY_BAC_LOOP"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 69@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_8827
00D6: if 
8118:   not actor 70@ dead
004D: jump_if_false @MUSIC1_8915
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""PARKSIT_M_LOOP"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 70@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_8915
00D6: if 
8118:   not actor 71@ dead
004D: jump_if_false @MUSIC1_9003
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""PARKSIT_W_LOOP"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 71@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9003
00D6: if 
8118:   not actor 72@ dead
004D: jump_if_false @MUSIC1_9091
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""PARKSIT_M_LOOP"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 72@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9091
00D6: if 
8118:   not actor 73@ dead
004D: jump_if_false @MUSIC1_9179
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""PARKSIT_M_LOOP"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 73@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9179
00D6: if 
8118:   not actor 74@ dead
004D: jump_if_false @MUSIC1_9265
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""LAY_BAC_LOOP"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 74@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9265
00D6: if 
8118:   not actor 75@ dead
004D: jump_if_false @MUSIC1_9345
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""BATHER"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 75@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9345
00D6: if 
8118:   not actor 76@ dead
004D: jump_if_false @MUSIC1_9434
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""SITNWAIT_LOOP_W"" IFP ""BEACH"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 76@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9434
00D6: if 
8118:   not actor 77@ dead
004D: jump_if_false @MUSIC1_9518
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""DNCE_M_B"" IFP ""DANCING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 77@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9518
00D6: if 
8118:   not actor 78@ dead
004D: jump_if_false @MUSIC1_9602
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""DNCE_M_C"" IFP ""DANCING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 78@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9602
00D6: if 
8118:   not actor 79@ dead
004D: jump_if_false @MUSIC1_9686
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""DNCE_M_D"" IFP ""DANCING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 79@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9686
00D6: if 
8118:   not actor 80@ dead
004D: jump_if_false @MUSIC1_9770
0615: define_AS_pack_begin 183@
0605: actor -1 perform_animation ""DNCE_M_E"" IFP ""DANCING"" framedelta 4.0 loop 1 lockX 0 lockY 0 lockF 0 time -1
0643: set_AS_pack 183@ loop 1
0616: define_AS_pack_end 183@
0618: assign_actor 80@ to_AS_pack 183@
061B: remove_references_to_AS_pack 183@

:MUSIC1_9770
00D6: if 
8118:   not actor 81@ dead
004D: jump_if_false @MUSIC1_9863
0615: define_AS_pack_begin 173@
0605: actor -1 perform_animation ""DNK_STNDF_LOOP"" IFP ""BAR"" framedelta 4.0 loop 0 lockX 0 lockY 0 lockF 1 time -1
05B9: AS_actor -1 stay_idle 4000 ms
0643: set_AS_pack 173@ loop 1
0616: define_AS_pack_end 173@
0618: assign_actor 81@ to_AS_pack 173@
061B: remove_references_to_AS_pack 173@

:MUSIC1_9863
00D6: if 
8118:   not actor 82@ dead
004D: jump_if_false @MUSIC1_9956
0615: define_AS_pack_begin 174@
0605: actor -1 perform_animation ""DNK_STNDF_LOOP"" IFP ""BAR"" framedelta 4.0 loop 0 lockX 0 lockY 0 lockF 1 time -1
05B9: AS_actor -1 stay_idle 2200 ms
0643: set_AS_pack 174@ loop 1
0616: define_AS_pack_end 174@
0618: assign_actor 82@ to_AS_pack 174@
061B: remove_references_to_AS_pack 174@

:MUSIC1_9956
0051: return

:MUSIC1_9958
00D6: if and
8118:   not actor 65@ dead
8118:   not actor 66@ dead
004D: jump_if_false @MUSIC1_10050
062E: get_actor 65@ task 1655 status_store_to 277@ // ret 7 if not found
062E: get_actor 66@ task 1655 status_store_to 278@ // ret 7 if not found
00D6: if and
04A4:   277@ == 7  //  == constant
04A4:   278@ == 7  //  == constant
004D: jump_if_false @MUSIC1_10050
0677: AS_actor 65@ chat_with_actor 66@ lead_speaker_flag 1 unknown_flag 1
0677: AS_actor 66@ chat_with_actor 65@ lead_speaker_flag 0 unknown_flag 1

:MUSIC1_10050
0051: return

:MUSIC1_10052
0006: 170@ = 5

:MUSIC1_10059
00D6: if 
002B:   8 >= 170@
004D: jump_if_false @MUSIC1_10167
00D6: if and
8118:   not actor 62@(170@,21i) dead
0039:   210@(170@,21i) == 0
004D: jump_if_false @MUSIC1_10153
01B9: set_actor 62@(170@,21i) armed_weapon_to 29
05E2: AS_actor 62@(170@,21i) kill_actor $PLAYER_ACTOR
0006: 210@(170@,21i) = 1
0961: set_actor 62@(170@,21i) keep_tasks_after_cleanup 1

:MUSIC1_10153
000A: 170@ += 1
0002: jump @MUSIC1_10059

:MUSIC1_10167
00D6: if and
8118:   not actor 55@ dead
0039:   231@ == 0
004D: jump_if_false @MUSIC1_10226
01B9: set_actor 55@ armed_weapon_to 29
04D7: set_actor 55@ locked False
05E2: AS_actor 55@ kill_actor $PLAYER_ACTOR
0006: 231@ = 1
0961: set_actor 55@ keep_tasks_after_cleanup 1

:MUSIC1_10226
0051: return

:MUSIC1_10228
0006: 170@ = 0

:MUSIC1_10235
00D6: if 
001D:   61@ > 170@  // (int)
004D: jump_if_false @MUSIC1_10339
00D6: if 
8039:   not 232@(170@,21i) == 1
004D: jump_if_false @MUSIC1_10325
00D6: if 
8118:   not actor 62@(170@,21i) dead
004D: jump_if_false @MUSIC1_10325
00D6: if 
82CB:   not actor 62@(170@,21i) bounding_sphere_visible
004D: jump_if_false @MUSIC1_10325
009B: destroy_actor 62@(170@,21i)

:MUSIC1_10325
000A: 170@ += 1
0002: jump @MUSIC1_10235

:MUSIC1_10339
0006: 170@ = 0

:MUSIC1_10346
00D6: if 
001D:   146@ > 170@  // (int)
004D: jump_if_false @MUSIC1_10450
00D6: if 
8039:   not 253@(170@,7i) == 1
004D: jump_if_false @MUSIC1_10436
00D6: if 
8119:   not car 147@(170@,7i) wrecked
004D: jump_if_false @MUSIC1_10436
00D6: if 
82CA:   not car 147@(170@,7i) bounding_sphere_visible
004D: jump_if_false @MUSIC1_10436
00A6: destroy_car 147@(170@,7i)

:MUSIC1_10436
000A: 170@ += 1
0002: jump @MUSIC1_10346

:MUSIC1_10450
0051: return

:MUSIC1_10452
0006: 170@ = 0

:MUSIC1_10459
00D6: if 
001D:   61@ > 170@  // (int)
004D: jump_if_false @MUSIC1_10570
00D6: if 
8118:   not actor 62@(170@,21i) dead
004D: jump_if_false @MUSIC1_10556
00D6: if or
001B:   5 > 170@
0019:   170@ > 8
004D: jump_if_false @MUSIC1_10556
05DD: AS_actor 62@(170@,21i) flee_from_actor $PLAYER_ACTOR from_origin_radius 400.0 timelimit 9999999
0961: set_actor 62@(170@,21i) keep_tasks_after_cleanup 1

:MUSIC1_10556
000A: 170@ += 1
0002: jump @MUSIC1_10459

:MUSIC1_10570
00D6: if 
8119:   not car 148@ wrecked
004D: jump_if_false @MUSIC1_10647
020A: set_car 148@ door_status_to 3
00D6: if 
8118:   not actor 77@ dead
004D: jump_if_false @MUSIC1_10619
05CB: AS_actor 77@ enter_car 148@ as_driver -1 ms

:MUSIC1_10619
00D6: if 
8118:   not actor 78@ dead
004D: jump_if_false @MUSIC1_10647
05CA: AS_actor 78@ enter_car 148@ passenger_seat 0 time -1

:MUSIC1_10647
00D6: if 
8119:   not car 149@ wrecked
004D: jump_if_false @MUSIC1_10724
020A: set_car 149@ door_status_to 3
00D6: if 
8118:   not actor 79@ dead
004D: jump_if_false @MUSIC1_10696
05CB: AS_actor 79@ enter_car 149@ as_driver -1 ms

:MUSIC1_10696
00D6: if 
8118:   not actor 80@ dead
004D: jump_if_false @MUSIC1_10724
05CA: AS_actor 80@ enter_car 149@ passenger_seat 0 time -1

:MUSIC1_10724
0051: return

:MUSIC1_10726
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_11352
0006: 169@ = 0
0006: 172@ = 0

:MUSIC1_10756
00D6: if 
001D:   146@ > 172@  // (int)
004D: jump_if_false @MUSIC1_11063
00D6: if 
8119:   not car 147@(172@,7i) wrecked
004D: jump_if_false @MUSIC1_11049
046C: 161@ = car 147@(172@,7i) driver
00D6: if and
0039:   161@ == -1
8039:   not 253@(172@,7i) == 1
001B:   2 > 169@
004D: jump_if_false @MUSIC1_11049
0006: 171@ = 0

:MUSIC1_10850
00D6: if 
001D:   61@ > 171@  // (int)
004D: jump_if_false @MUSIC1_11049
00D6: if and
8118:   not actor 62@(171@,21i) dead
8039:   not 232@(171@,21i) == 1
004D: jump_if_false @MUSIC1_11035
020A: set_car 147@(172@,7i) door_status_to 3
06E1: AS_actor 62@(171@,21i) using_car 147@(172@,7i) target_car -1 with_order 2 max_speed 30.0 traffic_flag 2
0085: 154@(172@,7i) = 62@(171@,21i)  // (int)
0006: 260@(172@,7i) = 1
01EC: make_car 147@(172@,7i) very_heavy 1
03AB: set_car 147@(172@,7i) strong 1
02AA: set_car 147@(172@,7i) immune_to_nonplayer True
0006: 232@(171@,21i) = 1
0006: 253@(172@,7i) = 1
000A: 169@ += 1
0085: 171@ = 61@  // (int)

:MUSIC1_11035
000A: 171@ += 1
0002: jump @MUSIC1_10850

:MUSIC1_11049
000A: 172@ += 1
0002: jump @MUSIC1_10756

:MUSIC1_11063
065C: release_decision_maker 180@
07E5: copy_decision_maker -1 to 180@
0708: reset_decision_maker 180@ event 7
0006: 170@ = 0

:MUSIC1_11089
00D6: if 
001D:   61@ > 170@  // (int)
004D: jump_if_false @MUSIC1_11328
00D6: if 
8118:   not actor 62@(170@,21i) dead
004D: jump_if_false @MUSIC1_11314
00D6: if 
8039:   not 232@(170@,21i) == 1
004D: jump_if_false @MUSIC1_11291
00D6: if and
0029:   170@ >= 5
002B:   8 >= 170@
004D: jump_if_false @MUSIC1_11251
0350: set_actor 62@(170@,21i) maintain_position_when_attacked 1
01B9: set_actor 62@(170@,21i) armed_weapon_to 29
05E2: AS_actor 62@(170@,21i) kill_actor $PLAYER_ACTOR
0006: 210@(170@,21i) = 1
0961: set_actor 62@(170@,21i) keep_tasks_after_cleanup 1
077A: set_actor 62@(170@,21i) acquaintance 4 to_actors_pedtype 0 // see ped.dat
0002: jump @MUSIC1_11284

:MUSIC1_11251
05DD: AS_actor 62@(170@,21i) flee_from_actor $PLAYER_ACTOR from_origin_radius 400.0 timelimit 9999999
0961: set_actor 62@(170@,21i) keep_tasks_after_cleanup 1

:MUSIC1_11284
0002: jump @MUSIC1_11302

:MUSIC1_11291
0961: set_actor 62@(170@,21i) keep_tasks_after_cleanup 0

:MUSIC1_11302
060B: set_actor 62@(170@,21i) decision_maker_to 180@

:MUSIC1_11314
000A: 170@ += 1
0002: jump @MUSIC1_11089

:MUSIC1_11328
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_11352
060B: set_actor 55@ decision_maker_to 180@

:MUSIC1_11352
0051: return

:MUSIC1_11354
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_11586
0006: 172@ = 0

:MUSIC1_11377
00D6: if 
001D:   146@ > 172@  // (int)
004D: jump_if_false @MUSIC1_11586
00D6: if and
8119:   not car 147@(172@,7i) wrecked
0039:   253@(172@,7i) == 1
004D: jump_if_false @MUSIC1_11572
00D6: if 
8118:   not actor 154@(172@,7i) dead
004D: jump_if_false @MUSIC1_11572
00D6: if and
80DB:   not actor 154@(172@,7i) in_car 147@(172@,7i)
0039:   260@(172@,7i) == 0
004D: jump_if_false @MUSIC1_11523
06E1: AS_actor 154@(172@,7i) using_car 147@(172@,7i) target_car -1 with_order 2 max_speed 30.0 traffic_flag 2
0006: 260@(172@,7i) = 1

:MUSIC1_11523
00D6: if and
00DB:   actor 154@(172@,7i) in_car 147@(172@,7i)
0039:   260@(172@,7i) == 1
004D: jump_if_false @MUSIC1_11572
0006: 260@(172@,7i) = 0

:MUSIC1_11572
000A: 172@ += 1
0002: jump @MUSIC1_11377

:MUSIC1_11586
0051: return
0006: 170@ = 0

:MUSIC1_11595
00D6: if 
001D:   146@ > 170@  // (int)
004D: jump_if_false @MUSIC1_11769
00D6: if and
8119:   not car 147@(170@,7i) wrecked
0039:   253@(170@,7i) == 1
004D: jump_if_false @MUSIC1_11755
046C: 161@ = car 147@(170@,7i) driver
00D6: if and
82CA:   not car 147@(170@,7i) bounding_sphere_visible
8039:   not 161@ == -1
8202:   not actor $PLAYER_ACTOR near_car 147@(170@,7i) radius 100.0 100.0 sphere 0
004D: jump_if_false @MUSIC1_11755
04C4: store_coords_to 165@ 166@ 167@ from_actor $PLAYER_ACTOR with_offset 0.0 -10.0 -1.0
00AB: put_car 147@(170@,7i) at 165@ 166@ 167@

:MUSIC1_11755
000A: 170@ += 1
0002: jump @MUSIC1_11595

:MUSIC1_11769
0051: return

:MUSIC1_11771
0006: 172@ = 0

:MUSIC1_11778
00D6: if 
001D:   146@ > 172@  // (int)
004D: jump_if_false @MUSIC1_11887
00D6: if and
8119:   not car 147@(172@,7i) wrecked
8118:   not actor 154@(172@,7i) dead
0039:   253@(172@,7i) == 1
004D: jump_if_false @MUSIC1_11873
05D1: AS_actor 154@(172@,7i) drive_car 147@(172@,7i) to 34@ 35@ 36@ speed 30.0 0 model #NULL  2

:MUSIC1_11873
000A: 172@ += 1
0002: jump @MUSIC1_11778

:MUSIC1_11887
0051: return

:MUSIC1_11889
016A: fade 0 time 1000

:MUSIC1_11896
00D6: if 
016B:   fading
004D: jump_if_false @MUSIC1_11920
0001: wait 0 ms
0002: jump @MUSIC1_11896

:MUSIC1_11920
0360: open_garage 'MUL_LAN'

:MUSIC1_11931
00D6: if 
83B0:   not garage 'MUL_LAN' door_open
004D: jump_if_false @MUSIC1_11964
0001: wait 0 ms
0002: jump @MUSIC1_11931

:MUSIC1_11964
00D6: if 
0119:   car 47@ wrecked
004D: jump_if_false @MUSIC1_12005
00BE: text_clear_all
00BC: show_text_highpriority GXT 'MUS1_20' time 5000 flag 0 // ~r~The van was destroyed!
0002: jump @MUSIC1_15556

:MUSIC1_12005
0395: clear_area 0 at 52@ 53@ 54@ radius 50.0
0006: 172@ = 0

:MUSIC1_12030
00D6: if 
001D:   146@ > 172@  // (int)
004D: jump_if_false @MUSIC1_12103
00D6: if 
0039:   253@(172@,7i) == 1
004D: jump_if_false @MUSIC1_12089
009B: destroy_actor 154@(172@,7i)
00A6: destroy_car 147@(172@,7i)

:MUSIC1_12089
000A: 172@ += 1
0002: jump @MUSIC1_12030

:MUSIC1_12103
01B4: set_player $PLAYER_CHAR can_move False
02A3: enable_widescreen 1
06AB: set_actor $PLAYER_ACTOR all_weapons_hidden 1
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_12185
00AB: put_car 47@ at 52@ 53@ 54@
0175: set_car 47@ Z_angle_to 0.0
00D6: if 
80DF:   not actor $PLAYER_ACTOR driving
004D: jump_if_false @MUSIC1_12185
036A: put_actor $PLAYER_ACTOR in_car 47@

:MUSIC1_12185
0001: wait 500 ms
015F: set_camera_position 1640.75 -1528.1 14.25 rotation 0.0 0.0 0.0
0160: set_camera_point_at 1642.49 -1522.89 14.11 switchstyle 2
016A: fade 1 time 500

:MUSIC1_12248
00D6: if 
016B:   fading
004D: jump_if_false @MUSIC1_12272
0001: wait 0 ms
0002: jump @MUSIC1_12248

:MUSIC1_12272
00D6: if 
0119:   car 47@ wrecked
004D: jump_if_false @MUSIC1_12313
00BE: text_clear_all
00BC: show_text_highpriority GXT 'MUS1_20' time 5000 flag 0 // ~r~The van was destroyed!
0002: jump @MUSIC1_15556

:MUSIC1_12313
0006: 279@ = 1
0707: start_scene_skip_to @MUSIC1_12579
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_12452
0615: define_AS_pack_begin 280@
05D1: AS_actor -1 drive_car 47@ to 1643.48 -1515.73 13.82 speed 5.0 1 model #NULL  2
05CD: AS_actor -1 exit_car 47@
05D3: AS_actor -1 goto_point 1641.91 -1517.64 12.62 mode 4 time -1 ms // versionA
05D3: AS_actor -1 goto_point 1641.91 -1522.36 12.61 mode 4 time -1 ms // versionA
0616: define_AS_pack_end 280@
0618: assign_actor $PLAYER_ACTOR to_AS_pack 280@
061B: remove_references_to_AS_pack 280@

:MUSIC1_12452
0001: wait 1000 ms
062E: get_actor $PLAYER_ACTOR task 1560 status_store_to 178@ // ret 7 if not found
00D6: if 
84A4:   not 178@ == 7  //  == constant
004D: jump_if_false @MUSIC1_12567
0646: unknown_get_actor $PLAYER_ACTOR task_1560_status_store_to 179@ // similar to 062E

:MUSIC1_12494
00D6: if and
002B:   1 >= 179@
84A4:   not 178@ == 7  //  == constant
004D: jump_if_false @MUSIC1_12567
0001: wait 0 ms
062E: get_actor $PLAYER_ACTOR task 1560 status_store_to 178@ // ret 7 if not found
00D6: if 
84A4:   not 178@ == 7  //  == constant
004D: jump_if_false @MUSIC1_12560
0646: unknown_get_actor $PLAYER_ACTOR task_1560_status_store_to 179@ // similar to 062E

:MUSIC1_12560
0002: jump @MUSIC1_12494

:MUSIC1_12567
0001: wait 2000 ms
0006: 279@ = 0

:MUSIC1_12579
0701: end_scene_skip
00D6: if 
0039:   279@ == 1
004D: jump_if_false @MUSIC1_12599

:MUSIC1_12599
016A: fade 0 time 500

:MUSIC1_12606
00D6: if 
016B:   fading
004D: jump_if_false @MUSIC1_12630
0001: wait 0 ms
0002: jump @MUSIC1_12606

:MUSIC1_12630
0361: close_garage 'MUL_LAN'

:MUSIC1_12641
00D6: if 
83B1:   not garage 'MUL_LAN' door_closed
004D: jump_if_false @MUSIC1_12674
0001: wait 0 ms
0002: jump @MUSIC1_12641

:MUSIC1_12674
00D6: if 
0119:   car 47@ wrecked
004D: jump_if_false @MUSIC1_12715
00BE: text_clear_all
00BC: show_text_highpriority GXT 'MUS1_20' time 5000 flag 0 // ~r~The van was destroyed!
0002: jump @MUSIC1_15556

:MUSIC1_12715
06AB: set_actor $PLAYER_ACTOR all_weapons_hidden 0
0792: disembark_instantly_actor $PLAYER_ACTOR
00D6: if 
00DF:   actor $PLAYER_ACTOR driving
004D: jump_if_false @MUSIC1_12764
0362: remove_actor $PLAYER_ACTOR from_car_and_place_at 52@ 53@ 54@
0002: jump @MUSIC1_12778

:MUSIC1_12764
00A1: put_actor $PLAYER_ACTOR at 52@ 53@ 54@

:MUSIC1_12778
0173: set_actor $PLAYER_ACTOR Z_angle_to 180.0
00A6: destroy_car 47@
02A3: enable_widescreen 0
0373: set_camera_directly_behind_player
02EB: restore_camera_with_jumpcut
01B4: set_player $PLAYER_CHAR can_move True
016A: fade 1 time 500

:MUSIC1_12815
00D6: if 
016B:   fading
004D: jump_if_false @MUSIC1_12839
0001: wait 0 ms
0002: jump @MUSIC1_12815

:MUSIC1_12839
0051: return

:MUSIC1_12841
0717: assign_actor 55@ to_dialogue_mode
0209: $6900 = random_int_in_ranges 0 2
0209: $6901 = random_int_in_ranges 0 3
00D6: if 
0038:   $6900 == 0
004D: jump_if_false @MUSIC1_13094
0871: init_jump_table $6901 total_jumps 3 default_jump 1 @MUSIC1_13080 jumps 0 @MUSIC1_12945 1 @MUSIC1_12990 2 @MUSIC1_13035 -1 @MUSIC1_13087 -1 @MUSIC1_13087 -1 @MUSIC1_13087 -1 @MUSIC1_13087

:MUSIC1_12945
05AA: 281@s = 'HI1'  // @s = 'short' // ~z~Hey, what's poppin'?
04AF: 291@ = 21420  //  = constant
04AF: 292@ = 21422  //  = constant
04AF: 293@ = 21421  //  = constant
0002: jump @MUSIC1_13087

:MUSIC1_12990
05AA: 281@s = 'HI3'  // @s = 'short' // ~z~Whassup?
04AF: 291@ = 21426  //  = constant
04AF: 292@ = 21428  //  = constant
04AF: 293@ = 21427  //  = constant
0002: jump @MUSIC1_13087

:MUSIC1_13035
05AA: 281@s = 'HI5'  // @s = 'short' // ~z~Hey, what's crackin'?
04AF: 291@ = 21432  //  = constant
04AF: 292@ = 21434  //  = constant
04AF: 293@ = 21433  //  = constant
0002: jump @MUSIC1_13087

:MUSIC1_13080
0002: jump @MUSIC1_13087

:MUSIC1_13087
0002: jump @MUSIC1_13299

:MUSIC1_13094
0871: init_jump_table $6901 total_jumps 3 default_jump 1 @MUSIC1_13292 jumps 0 @MUSIC1_13157 1 @MUSIC1_13202 2 @MUSIC1_13247 -1 @MUSIC1_13299 -1 @MUSIC1_13299 -1 @MUSIC1_13299 -1 @MUSIC1_13299

:MUSIC1_13157
05AA: 281@s = 'HI2'  // @s = 'short' // ~z~Hey, what's poppin'?
04AF: 291@ = 21423  //  = constant
04AF: 292@ = 21425  //  = constant
04AF: 293@ = 21424  //  = constant
0002: jump @MUSIC1_13299

:MUSIC1_13202
05AA: 281@s = 'HI4'  // @s = 'short' // ~z~Whassup?
04AF: 291@ = 21429  //  = constant
04AF: 292@ = 21431  //  = constant
04AF: 293@ = 21430  //  = constant
0002: jump @MUSIC1_13299

:MUSIC1_13247
05AA: 281@s = 'HI6'  // @s = 'short' // ~z~Hey, what's crackin'?
04AF: 291@ = 21435  //  = constant
04AF: 292@ = 21437  //  = constant
04AF: 293@ = 21436  //  = constant
0002: jump @MUSIC1_13299

:MUSIC1_13292
0002: jump @MUSIC1_13299

:MUSIC1_13299
0209: $6900 = random_int_in_ranges 0 2
00D6: if 
0038:   $6900 == 0
004D: jump_if_false @MUSIC1_13371
05AA: 283@s = 'DOFFE1'  // @s = 'short' // ~z~Well why don't you come and dance?
04AF: 294@ = 21404  //  = constant
04AF: 295@ = 21406  //  = constant
04AF: 296@ = 21405  //  = constant
0002: jump @MUSIC1_13409

:MUSIC1_13371
05AA: 283@s = 'DOFFE3'  // @s = 'short' // ~z~Well, hey, let's dance, sugar!
04AF: 294@ = 21410  //  = constant
04AF: 295@ = 21412  //  = constant
04AF: 296@ = 21411  //  = constant

:MUSIC1_13409
0209: $6900 = random_int_in_ranges 0 2
00D6: if 
0038:   $6900 == 0
004D: jump_if_false @MUSIC1_13465
05AA: 285@s = 'BEXIT1'  // @s = 'short' // ~z~Suit yourself.
04AF: 297@ = 21400  //  = constant
0002: jump @MUSIC1_13487

:MUSIC1_13465
05AA: 285@s = 'BEXIT2'  // @s = 'short' // ~z~Whatever. See you 'round.
04AF: 297@ = 21401  //  = constant

:MUSIC1_13487
05AA: 287@s = 'DSTAR2'  // @s = 'short' // ~z~Let's see what you got...
04AF: 298@ = 21417  //  = constant
0209: $6900 = random_int_in_ranges 0 2
00D6: if 
0038:   $6900 == 0
004D: jump_if_false @MUSIC1_13565
05AA: 289@s = 'GEXIT1'  // @s = 'short' // ~z~Well, come on back when you ain't so rushed.
04AF: 299@ = 21418  //  = constant
0002: jump @MUSIC1_13587

:MUSIC1_13565
05AA: 289@s = 'GEXIT2'  // @s = 'short' // ~z~If you change your mind you know where to find me.
04AF: 299@ = 21419  //  = constant

:MUSIC1_13587
0A18: set_dialogue_classA_question_GXT 281@s answer_yes_GXT 283@s answer_no_GXT 285@s question_WAV 291@ answer_yes_WAV 292@ answer_no_WAV 293@
0A3C: set_dialogue_classA_end_GXT 285@s WAV 297@
0A18: set_dialogue_classA_question_GXT 283@s answer_yes_GXT 287@s answer_no_GXT 289@s question_WAV 294@ answer_yes_WAV 295@ answer_no_WAV 296@
0A3C: set_dialogue_classA_end_GXT 287@s WAV 298@
0A3C: set_dialogue_classA_end_GXT 289@s WAV 299@
0719: enable_dialogue_mode
0051: return

:MUSIC1_13655
0717: assign_actor 55@ to_dialogue_mode
0209: $6900 = random_int_in_ranges 0 2
00D6: if 
0038:   $6900 == 0
004D: jump_if_false @MUSIC1_13732
05AA: 300@s = 'VOFFE1'  // @s = 'short' // ~z~You got some moves, wanna come and chat?
04AF: 304@ = 21443  //  = constant
04AF: 305@ = 21445  //  = constant
04AF: 306@ = 21444  //  = constant
0002: jump @MUSIC1_13770

:MUSIC1_13732
05AA: 300@s = 'VOFFE2'  // @s = 'short' // ~z~You got some moves, wanna come and chat?
04AF: 304@ = 21446  //  = constant
04AF: 305@ = 21448  //  = constant
04AF: 306@ = 21447  //  = constant

:MUSIC1_13770
0209: $6900 = random_int_in_ranges 0 2
00D6: if 
0038:   $6900 == 0
004D: jump_if_false @MUSIC1_13842
05AA: 302@s = 'VSURE1'  // @s = 'short' // ~z~You sure?
04AF: 307@ = 21449  //  = constant
04AF: 308@ = 21451  //  = constant
04AF: 309@ = 21450  //  = constant
0002: jump @MUSIC1_13880

:MUSIC1_13842
05AA: 302@s = 'VSURE2'  // @s = 'short' // ~z~You sure?
04AF: 307@ = 21452  //  = constant
04AF: 308@ = 21454  //  = constant
04AF: 309@ = 21453  //  = constant

:MUSIC1_13880
0A18: set_dialogue_classA_question_GXT 300@s answer_yes_GXT 'VYES2' answer_no_GXT 302@s question_WAV 304@ answer_yes_WAV 305@ answer_no_WAV 306@ // ~z~Let me take you into my office...
0A3C: set_dialogue_classA_end_GXT 'VYES2' WAV 21456 // ~z~Let me take you into my office...
0A18: set_dialogue_classA_question_GXT 302@s answer_yes_GXT 'VLATE' answer_no_GXT 'VYES1' question_WAV 307@ answer_yes_WAV 308@ answer_no_WAV 309@ // ~z~Well, I'm here for a while, if you change your mind! // ~z~C'mon, homeboy.
0A3C: set_dialogue_classA_end_GXT 'VLATE' WAV 21442 // ~z~Well, I'm here for a while, if you change your mind!
0A3C: set_dialogue_classA_end_GXT 'VYES1' WAV 21455 // ~z~C'mon, homeboy.
0719: enable_dialogue_mode
0051: return

:MUSIC1_13984
0087: 310@ = 39@  // (float)
0063: 310@ -= 34@  // (float)
0087: 311@ = 40@  // (float)
0063: 311@ -= 35@  // (float)
0050: gosub @MUSIC1_14436
0087: 39@ = 312@  // (float)
0087: 40@ = 313@  // (float)
0007: 41@ = 2.68
0087: 310@ = 42@  // (float)
0063: 310@ -= 34@  // (float)
0087: 311@ = 43@  // (float)
0063: 311@ -= 35@  // (float)
0050: gosub @MUSIC1_14436
0087: 42@ = 312@  // (float)
0087: 43@ = 313@  // (float)
0007: 44@ = 2.39
0087: 310@ = 48@  // (float)
0063: 310@ -= 34@  // (float)
0087: 311@ = 49@  // (float)
0063: 311@ -= 35@  // (float)
0050: gosub @MUSIC1_14436
0087: 48@ = 312@  // (float)
0087: 49@ = 313@  // (float)
0007: 50@ = 3.42
000F: 51@ -= 51.0
0087: 310@ = 56@  // (float)
0063: 310@ -= 34@  // (float)
0087: 311@ = 57@  // (float)
0063: 311@ -= 35@  // (float)
0050: gosub @MUSIC1_14436
0087: 56@ = 312@  // (float)
0087: 57@ = 313@  // (float)
0087: 310@ = 58@  // (float)
0063: 310@ -= 34@  // (float)
0087: 311@ = 59@  // (float)
0063: 311@ -= 35@  // (float)
0050: gosub @MUSIC1_14436
0087: 58@ = 312@  // (float)
0087: 59@ = 313@  // (float)
0007: 60@ = 2.31
0006: 170@ = 0

:MUSIC1_14316
00D6: if 
001D:   61@ > 170@  // (int)
004D: jump_if_false @MUSIC1_14434
0087: 310@ = 83@(170@,21f)  // (float)
0063: 310@ -= 34@  // (float)
0087: 311@ = 104@(170@,21f)  // (float)
0063: 311@ -= 35@  // (float)
0050: gosub @MUSIC1_14436
0087: 83@(170@,21f) = 312@  // (float)
0087: 104@(170@,21f) = 313@  // (float)
000F: 125@(170@,21f) -= 51.0
000A: 170@ += 1
0002: jump @MUSIC1_14316

:MUSIC1_14434
0051: return

:MUSIC1_14436
0087: 314@ = 310@  // (float)
006B: 314@ *= 310@  // (float)
0087: 315@ = 311@  // (float)
006B: 315@ *= 311@  // (float)
0087: 317@ = 314@  // (float)
005B: 317@ += 315@  // (float)
01FB: 316@ = square_root 317@
0087: 318@ = 311@  // (float)
0073: 318@ /= 316@  // (float)
0087: 319@ = 310@  // (float)
0073: 319@ /= 316@  // (float)
02F7: 320@ = cosine 51.0 // (float)
02F6: 321@ = sine 51.0 // (float)
0087: 322@ = 318@  // (float)
006B: 322@ *= 320@  // (float)
0087: 323@ = 319@  // (float)
006B: 323@ *= 321@  // (float)
0087: 324@ = 319@  // (float)
006B: 324@ *= 320@  // (float)
0087: 325@ = 318@  // (float)
006B: 325@ *= 321@  // (float)
0087: 326@ = 322@  // (float)
0063: 326@ -= 323@  // (float)
0087: 327@ = 324@  // (float)
005B: 327@ += 325@  // (float)
0087: 312@ = 316@  // (float)
006B: 312@ *= 327@  // (float)
0087: 313@ = 316@  // (float)
006B: 313@ *= 326@  // (float)
005B: 312@ += 34@  // (float)
005B: 313@ += 35@  // (float)
0051: return

:MUSIC1_14690
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_14854
00D6: if 
0039:   208@ == 1
004D: jump_if_false @MUSIC1_14793
00D6: if 
80DB:   not actor $PLAYER_ACTOR in_car 47@
004D: jump_if_false @MUSIC1_14786
0164: disable_marker 273@
0186: 272@ = create_marker_above_car 47@
07E0: set_marker 272@ type_to 1
00BC: show_text_highpriority GXT 'MUS1_6' time 7000 flag 0 // ~s~Get back into the ~b~sound van~s~.
0006: 208@ = 0

:MUSIC1_14786
0002: jump @MUSIC1_14854

:MUSIC1_14793
00D6: if 
00DB:   actor $PLAYER_ACTOR in_car 47@
004D: jump_if_false @MUSIC1_14854
0164: disable_marker 272@
018A: 273@ = create_checkpoint_at 52@ 53@ 54@
00BC: show_text_highpriority GXT 'MUS1_19' time 7000 flag 0 // ~s~Get the van back to the ~y~garage.
0006: 208@ = 1

:MUSIC1_14854
0051: return

:MUSIC1_14856
01B4: set_player $PLAYER_CHAR can_move False
02A3: enable_widescreen 1
00BE: text_clear_all
00BC: show_text_highpriority GXT 'MUS1_2' time 10000 flag 0 // ~s~When you get to the beach party, go and talk to the ~y~DJ~s~.
015F: set_camera_position 532.87 -1893.69 3.29 rotation 0.0 0.0 0.0
0160: set_camera_point_at 533.97 -1892.67 3.3 switchstyle 2
00A0: store_actor $PLAYER_ACTOR position_to $tempvar_X_coord $tempvar_Y_coord $tempvar_Z_coord
00A1: put_actor $PLAYER_ACTOR at $tempvar_X_coord $tempvar_Y_coord -100.0
0087: 328@ = 34@  // (float)
0065: 328@ -= $tempvar_X_coord  // (float)
0087: 329@ = 35@  // (float)
0065: 329@ -= $tempvar_Y_coord  // (float)
0604: get_Z_angle_for_point 328@ 329@ store_to $tempvar_Angle
00D6: if 
80DF:   not actor $PLAYER_ACTOR driving
004D: jump_if_false @MUSIC1_15040
0173: set_actor $PLAYER_ACTOR Z_angle_to $tempvar_Angle
0002: jump @MUSIC1_15061

:MUSIC1_15040
03C0: 330@ = actor $PLAYER_ACTOR car
00A9: set_car 330@ to_normal_driver
0175: set_car 330@ Z_angle_to $tempvar_Angle

:MUSIC1_15061
0001: wait 2000 ms
0006: 279@ = 1
0707: start_scene_skip_to @MUSIC1_15092
0001: wait 8000 ms
0006: 279@ = 0

:MUSIC1_15092
0701: end_scene_skip
00D6: if 
0039:   279@ == 1
004D: jump_if_false @MUSIC1_15112

:MUSIC1_15112
00BE: text_clear_all
02A3: enable_widescreen 0
0373: set_camera_directly_behind_player
02EB: restore_camera_with_jumpcut
01B4: set_player $PLAYER_CHAR can_move True
0051: return

:MUSIC1_15131
0871: init_jump_table 191@ total_jumps 2 default_jump 1 @MUSIC1_15266 jumps 0 @MUSIC1_15194 1 @MUSIC1_15230 -1 @MUSIC1_15273 -1 @MUSIC1_15273 -1 @MUSIC1_15273 -1 @MUSIC1_15273 -1 @MUSIC1_15273

:MUSIC1_15194
05AA: 184@s = 'LOC1_YT'  // @s = 'short' // ~z~He's stealing the sounds!
04AF: 186@ = 21656  //  = constant
0006: 189@ = 1
0002: jump @MUSIC1_15273

:MUSIC1_15230
05AA: 184@s = 'DNCEF1'  // @s = 'short' // ~z~You need to put more time in on the dance floor!
04AF: 186@ = 21402  //  = constant
0006: 189@ = 1
0002: jump @MUSIC1_15273

:MUSIC1_15266
0002: jump @MUSIC1_15273

:MUSIC1_15273
0006: 187@ = 0
0006: 188@ = 0
0006: 190@ = 0
040D: unload_wav 1
00BE: text_clear_all
0051: return

:MUSIC1_15302
00D6: if or
0039:   187@ == 0
0039:   187@ == 1
004D: jump_if_false @MUSIC1_15372
00D6: if 
001D:   189@ > 188@  // (int)
004D: jump_if_false @MUSIC1_15372
00D6: if 
0019:   TIMERA > 1000
004D: jump_if_false @MUSIC1_15372
0050: gosub @MUSIC1_15430

:MUSIC1_15372
00D6: if 
0039:   187@ == 2
004D: jump_if_false @MUSIC1_15428
00D6: if 
03D2:   wav 1 ended
004D: jump_if_false @MUSIC1_15428
0006: 187@ = 0
000A: 188@ += 1
00BE: text_clear_all
0006: TIMERA = 0

:MUSIC1_15428
0051: return

:MUSIC1_15430
00D6: if 
0039:   187@ == 0
004D: jump_if_false @MUSIC1_15466
03CF: load_wav 186@(188@,1i) as 1
0006: 187@ = 1

:MUSIC1_15466
00D6: if 
0039:   187@ == 1
004D: jump_if_false @MUSIC1_15554
00D6: if 
03D0:   wav 1 loaded
004D: jump_if_false @MUSIC1_15554
00BC: show_text_highpriority GXT 184@(188@,1s) time 10000 flag 1
00D6: if and
0039:   191@ == 1
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_15543
0949: link_wav 1 to_actor 55@

:MUSIC1_15543
03D1: play_wav 1
0006: 187@ = 2

:MUSIC1_15554
0051: return

:MUSIC1_15556
00BA: show_text_styled GXT 'M_FAIL' time 5000 style 1 // ~r~MISSION FAILED!
0051: return

:MUSIC1_15574
0008: $OG_Loc_Total_Passed_Missions += 1
0318: set_latest_mission_passed 'STRAP_1' // Life's a Beach
030C: progress_made = 1
01E3: show_text_1number_styled GXT 'M_PASSR' number 3 time 5000 style 1 // MISSION PASSED!~n~~w~RESPECT +
0998: add_respect 3
0110: clear_player $PLAYER_CHAR wanted_level
0394: play_music 1
0051: return

:MUSIC1_15629
0249: release_model #VOODOO
0249: release_model #ESPERANT
0249: release_model #OCEANIC
0249: release_model #PONY
0249: release_model #MP5LNG
0249: release_model #BFYST
0249: release_model #WFYST
0249: release_model #BMYST
0249: release_model #WMYRO
0249: release_model #WFYCLOT
0249: release_model #WMYST
0249: release_model #WMYCLOT
0249: release_model #BMYDJ
0249: release_model #WFYRI
0249: release_model #OFYRI
06EB: release_car_component #WHEEL_OR1
01C4: remove_references_to_object 45@  // This object will now disappear when the player looks away
01C4: remove_references_to_object 46@  // This object will now disappear when the player looks away
090F: end_external_script 0 (DANCE)
04EF: release_animation ""BAR""
04EF: release_animation ""DANCING""
04EF: release_animation ""BEACH""
04EF: release_animation ""SCRATCHING""
0164: disable_marker 271@
0164: disable_marker 272@
0164: disable_marker 273@
0650: destroy_particle 37@
0650: destroy_particle 38@
061B: remove_references_to_AS_pack 173@
061B: remove_references_to_AS_pack 174@
061B: remove_references_to_AS_pack 177@
061B: remove_references_to_AS_pack 280@
061B: remove_references_to_AS_pack 181@
061B: remove_references_to_AS_pack 182@
061B: remove_references_to_AS_pack 183@
00D6: if 
0256:   player $PLAYER_CHAR defined
004D: jump_if_false @MUSIC1_15839
06AB: set_actor $PLAYER_ACTOR all_weapons_hidden 0

:MUSIC1_15839
00D6: if 
8118:   not actor 55@ dead
004D: jump_if_false @MUSIC1_15867
08ED: remove_actor 55@ from_dialogue_mode
04D7: set_actor 55@ locked False

:MUSIC1_15867
00D6: if 
8119:   not car 47@ wrecked
004D: jump_if_false @MUSIC1_15890
0852: set_car 47@ damages_visible 1

:MUSIC1_15890
065C: release_decision_maker 180@
03E6: remove_text_box
0917: audio_zone 'BEACH' enable_sound 0
091E: create_forbidden_for_boats_cube_cornerA 502.15 -1913.39 -5.0 cornerB 558.86 -1838.87 10.0
01BD: $Current_Time_in_ms = current_time_in_ms
0004: $ONMISSION = 0
00D8: mission_cleanup
0051: return


//------------//------------//------------//------------




//------------//------------//------------//------------










//------------//------------//------------//------------





//-------------External script 0 (DANCE)---------------
//-------------External script 35 (DANCE)---------------

:DANCE
03A4: script_name 'DANCE'
08BA: set $5295 bit 31
09BD: allow_other_scripts_to_display_text_boxes 1
03F0: enable_text_draw 1
09EE: set_status_text_stay_on_screen 1
00D6: if 
0019:   13@ > 0
004D: jump_if_false @DANCE_72
009A: 5@ = create_actor_pedtype 5 model 0 at 0.0 0.0 0.0

:DANCE_72
0006: 18@ = 5
0006: 23@ = 5
0006: 16@ = -1
0006: 24@ = -1
0006: 17@ = -1
0006: 13@ = 0
0004: $DANCE_SCORE = 0
0004: $9528 = 0
0004: $9527 = -1
0004: $9529 = 1
0006: 22@ = 5
0006: TIMERA = 10000

:DANCE_157
0001: wait 0 ms
00D6: if 
0256:   player $PLAYER_CHAR defined
004D: jump_if_false @DANCE_367
00D6: if 
0019:   6@ > 0
004D: jump_if_false @DANCE_353
00D6: if 
0038:   $5298 == 1
004D: jump_if_false @DANCE_245
00D6: if 
8039:   not 6@ == 2
004D: jump_if_false @DANCE_245
0006: 6@ = 2
0006: 7@ = 0

:DANCE_245
00D6: if 
0039:   5@ == -1
004D: jump_if_false @DANCE_302
00D6: if 
8039:   not 22@ == 5
004D: jump_if_false @DANCE_288
0050: gosub @DANCE_9479

:DANCE_288
0050: gosub @DANCE_381
0002: jump @DANCE_346

:DANCE_302
00D6: if 
8118:   not actor 5@ dead
004D: jump_if_false @DANCE_339
0050: gosub @DANCE_9479
0050: gosub @DANCE_381
0002: jump @DANCE_346

:DANCE_339
0050: gosub @DANCE_16653

:DANCE_346
0002: jump @DANCE_360

:DANCE_353
0050: gosub @DANCE_381

:DANCE_360
0002: jump @DANCE_374

:DANCE_367
0050: gosub @DANCE_16653

:DANCE_374
0002: jump @DANCE_157

:DANCE_381
0871: init_jump_table 6@ total_jumps 4 default_jump 0 @DANCE_500 jumps 0 @DANCE_444 1 @DANCE_458 2 @DANCE_472 3 @DANCE_486 -1 @DANCE_500 -1 @DANCE_500 -1 @DANCE_500

:DANCE_444
0050: gosub @DANCE_502
0002: jump @DANCE_500

:DANCE_458
0050: gosub @DANCE_1090
0002: jump @DANCE_500

:DANCE_472
0050: gosub @DANCE_2086
0002: jump @DANCE_500

:DANCE_486
0050: gosub @DANCE_2412
0002: jump @DANCE_500

:DANCE_500
0051: return

:DANCE_502
0871: init_jump_table 7@ total_jumps 4 default_jump 0 @DANCE_1088 jumps 0 @DANCE_565 1 @DANCE_646 2 @DANCE_803 3 @DANCE_948 -1 @DANCE_1088 -1 @DANCE_1088 -1 @DANCE_1088

:DANCE_565
01B4: set_player $PLAYER_CHAR can_move False
01B9: set_actor $PLAYER_ACTOR armed_weapon_to 0
06AB: set_actor $PLAYER_ACTOR all_weapons_hidden 1
03BF: set_player $PLAYER_CHAR ignored_by_everyone 1
03F4: set_all_cars_apply_damage_rules 0
0826: enable_hud 0
0581: enable_radar 0
00D6: if 
8039:   not 5@ == -1
004D: jump_if_false @DANCE_625
0253: save_current_time

:DANCE_625
016A: fade 0 time 500
000A: 7@ += 1
0002: jump @DANCE_1088

:DANCE_646
00D6: if 
816B:   not fading
004D: jump_if_false @DANCE_796
0050: gosub @DANCE_2764
04ED: load_animation v$DANCE_ANIM_IFP
00D6: if 
84EE:   not animation v$DANCE_ANIM_IFP loaded
004D: jump_if_false @DANCE_694
0002: jump @DANCE_1088

:DANCE_694
00D6: if 
8039:   not 5@ == -1
004D: jump_if_false @DANCE_718
00C0: set_current_time_hours_to 0 minutes_to 0

:DANCE_718
0792: disembark_instantly_actor $PLAYER_ACTOR
0395: clear_area 1 at 0@ 1@ 2@ radius 1.5
00A1: put_actor $PLAYER_ACTOR at 0@ 1@ 2@
0173: set_actor $PLAYER_ACTOR Z_angle_to 3@
0050: gosub @DANCE_6883
0050: gosub @DANCE_5828
0006: 17@ = 0
0952: load_soundtrack 4@
000A: 7@ += 1

:DANCE_796
0002: jump @DANCE_1088

:DANCE_803
0953: get_soundtrack_status_to 13@
00D6: if 
04A4:   13@ == 2  //  == constant
004D: jump_if_false @DANCE_941
0954: start_playing_loaded_soundtrack
0812: AS_actor $PLAYER_ACTOR perform_animation ""DANCE_LOOP"" IFP v$DANCE_ANIM_IFP framedelta 99.0 loopA 1 lockX 0 lockY 0 lockF 1 time 1215752191 // versionB
00D6: if 
8118:   not actor 5@ dead
004D: jump_if_false @DANCE_920
0812: AS_actor 5@ perform_animation ""DANCE_LOOP"" IFP v$DANCE_ANIM_IFP framedelta 99.0 loopA 1 lockX 0 lockY 0 lockF 1 time 1215752191 // versionB

:DANCE_920
016A: fade 1 time 500
0006: TIMERB = 0
000A: 7@ += 1

:DANCE_941
0002: jump @DANCE_1088

:DANCE_948
00D6: if 
816B:   not fading
004D: jump_if_false @DANCE_1081
00D6: if 
0039:   5@ == -1
004D: jump_if_false @DANCE_1043
00D6: if 
0029:   TIMERB >= 10000
004D: jump_if_false @DANCE_1036
004F: start_new_script @BDISPLY 
03C4: set_status_text $DANCE_SCORE type 0 GXT 'DNC_001' // global_variable
0006: 6@ = 1
0006: 7@ = 1

:DANCE_1036
0002: jump @DANCE_1081

:DANCE_1043
004F: start_new_script @BDISPLY 
03C4: set_status_text $DANCE_SCORE type 0 GXT 'DNC_001' // global_variable
0006: 6@ = 1
0006: 7@ = 1

:DANCE_1081
0002: jump @DANCE_1088

:DANCE_1088
0051: return

:DANCE_1090
0871: init_jump_table 7@ total_jumps 1 default_jump 0 @DANCE_2084 jumps 1 @DANCE_1153 -1 @DANCE_2084 -1 @DANCE_2084 -1 @DANCE_2084 -1 @DANCE_2084 -1 @DANCE_2084 -1 @DANCE_2084

:DANCE_1153
0050: gosub @DANCE_5692
0050: gosub @DANCE_8068
0050: gosub @DANCE_5723
0050: gosub @DANCE_5504
0050: gosub @DANCE_2932
00D6: if 
0039:   6@ == 3
004D: jump_if_false @DANCE_1213
0002: jump @DANCE_2084

:DANCE_1213
0050: gosub @DANCE_3662
0050: gosub @DANCE_5367
0050: gosub @DANCE_5828
0050: gosub @DANCE_8952
0050: gosub @DANCE_9617
00D6: if 
0039:   22@ == 3
004D: jump_if_false @DANCE_1387
00D6: if 
001A:   99999999 > $DANCE_SCORE
004D: jump_if_false @DANCE_1341
00D6: if 
0039:   29@ == 2
004D: jump_if_false @DANCE_1334
0006: 30@ = 10
0012: 30@ *= 2
005E: $DANCE_SCORE += 30@  // (int)
0002: jump @DANCE_1341

:DANCE_1334
0008: $DANCE_SCORE += 10

:DANCE_1341
000A: 26@ += 1
0050: gosub @DANCE_8131
00D6: if 
8039:   not 31@ == -1
004D: jump_if_false @DANCE_1380
0050: gosub @DANCE_4113

:DANCE_1380
0002: jump @DANCE_2084

:DANCE_1387
00D6: if 
0039:   22@ == 1
004D: jump_if_false @DANCE_1526
00D6: if 
001A:   99999999 > $DANCE_SCORE
004D: jump_if_false @DANCE_1480
00D6: if 
0039:   29@ == 2
004D: jump_if_false @DANCE_1473
0006: 30@ = 50
0012: 30@ *= 2
005E: $DANCE_SCORE += 30@  // (int)
0002: jump @DANCE_1480

:DANCE_1473
0008: $DANCE_SCORE += 50

:DANCE_1480
000A: 28@ += 1
0050: gosub @DANCE_8131
00D6: if 
8039:   not 31@ == -1
004D: jump_if_false @DANCE_1519
0050: gosub @DANCE_4113

:DANCE_1519
0002: jump @DANCE_2084

:DANCE_1526
00D6: if 
0039:   22@ == 2
004D: jump_if_false @DANCE_1665
00D6: if 
001A:   99999999 > $DANCE_SCORE
004D: jump_if_false @DANCE_1619
00D6: if 
0039:   29@ == 2
004D: jump_if_false @DANCE_1612
0006: 30@ = 20
0012: 30@ *= 2
005E: $DANCE_SCORE += 30@  // (int)
0002: jump @DANCE_1619

:DANCE_1612
0008: $DANCE_SCORE += 20

:DANCE_1619
000A: 26@ += 1
0050: gosub @DANCE_8131
00D6: if 
8039:   not 31@ == -1
004D: jump_if_false @DANCE_1658
0050: gosub @DANCE_4113

:DANCE_1658
0002: jump @DANCE_2084

:DANCE_1665
00D6: if 
0039:   22@ == 0
004D: jump_if_false @DANCE_1768
00D6: if 
0018:   $DANCE_SCORE > 0
004D: jump_if_false @DANCE_1715
000C: $DANCE_SCORE -= 0
0002: jump @DANCE_1722

:DANCE_1715
0004: $DANCE_SCORE = 0

:DANCE_1722
000A: 27@ += 1
0050: gosub @DANCE_8131
00D6: if 
8039:   not 31@ == -1
004D: jump_if_false @DANCE_1761
0050: gosub @DANCE_4740

:DANCE_1761
0002: jump @DANCE_2084

:DANCE_1768
00D6: if 
0039:   22@ == 4
004D: jump_if_false @DANCE_1871
00D6: if 
0018:   $DANCE_SCORE > 0
004D: jump_if_false @DANCE_1818
000C: $DANCE_SCORE -= 0
0002: jump @DANCE_1825

:DANCE_1818
0004: $DANCE_SCORE = 0

:DANCE_1825
000A: 27@ += 1
0050: gosub @DANCE_8131
00D6: if 
8039:   not 31@ == -1
004D: jump_if_false @DANCE_1864
0050: gosub @DANCE_4740

:DANCE_1864
0002: jump @DANCE_2084

:DANCE_1871
00D6: if 
0039:   22@ == 10
004D: jump_if_false @DANCE_1974
00D6: if 
0018:   $DANCE_SCORE > 0
004D: jump_if_false @DANCE_1921
000C: $DANCE_SCORE -= 0
0002: jump @DANCE_1928

:DANCE_1921
0004: $DANCE_SCORE = 0

:DANCE_1928
000A: 27@ += 1
0050: gosub @DANCE_8131
00D6: if 
8039:   not 31@ == -1
004D: jump_if_false @DANCE_1967
0050: gosub @DANCE_4740

:DANCE_1967
0002: jump @DANCE_2084

:DANCE_1974
00D6: if 
0039:   22@ == 11
004D: jump_if_false @DANCE_2077
00D6: if 
0018:   $DANCE_SCORE > 0
004D: jump_if_false @DANCE_2024
000C: $DANCE_SCORE -= 0
0002: jump @DANCE_2031

:DANCE_2024
0004: $DANCE_SCORE = 0

:DANCE_2031
000A: 27@ += 1
0050: gosub @DANCE_8131
00D6: if 
8039:   not 31@ == -1
004D: jump_if_false @DANCE_2070
0050: gosub @DANCE_4740

:DANCE_2070
0002: jump @DANCE_2084

:DANCE_2077
0002: jump @DANCE_2084

:DANCE_2084
0051: return

:DANCE_2086
0871: init_jump_table 7@ total_jumps 4 default_jump 0 @DANCE_2410 jumps 0 @DANCE_2149 1 @DANCE_2170 2 @DANCE_2222 3 @DANCE_2396 -1 @DANCE_2410 -1 @DANCE_2410 -1 @DANCE_2410

:DANCE_2149
016A: fade 0 time 500
000A: 7@ += 1
0002: jump @DANCE_2410

:DANCE_2170
00D6: if 
816B:   not fading
004D: jump_if_false @DANCE_2215
0953: get_soundtrack_status_to 13@
00D6: if 
04A4:   13@ == 3  //  == constant
004D: jump_if_false @DANCE_2208
0955: end_playing_loaded_soundtrack

:DANCE_2208
000A: 7@ += 1

:DANCE_2215
0002: jump @DANCE_2410

:DANCE_2222
0151: remove_status_text $DANCE_SCORE
06AB: set_actor $PLAYER_ACTOR all_weapons_hidden 0
03F4: set_all_cars_apply_damage_rules 1
0826: enable_hud 1
0581: enable_radar 1
03E6: remove_text_box
0373: set_camera_directly_behind_player
02EB: restore_camera_with_jumpcut
03BF: set_player $PLAYER_CHAR ignored_by_everyone 0
0792: disembark_instantly_actor $PLAYER_ACTOR
0812: AS_actor $PLAYER_ACTOR perform_animation ""DANCE_LOOP"" IFP v$DANCE_ANIM_IFP framedelta 16.0 loopA 0 lockX 0 lockY 0 lockF 0 time 0 // versionB
00D6: if 
8118:   not actor 5@ dead
004D: jump_if_false @DANCE_2355
0792: disembark_instantly_actor 5@
0812: AS_actor 5@ perform_animation ""DANCE_LOOP"" IFP v$DANCE_ANIM_IFP framedelta 16.0 loopA 0 lockX 0 lockY 0 lockF 0 time 0 // versionB

:DANCE_2355
00D6: if 
8039:   not 5@ == -1
004D: jump_if_false @DANCE_2375
0254: restore_current_time

:DANCE_2375
016A: fade 1 time 1500
000A: 7@ += 1
0002: jump @DANCE_2410

:DANCE_2396
0050: gosub @DANCE_16653
0002: jump @DANCE_2410

:DANCE_2410
0051: return

:DANCE_2412
0871: init_jump_table 7@ total_jumps 2 default_jump 0 @DANCE_2762 jumps 0 @DANCE_2475 1 @DANCE_2567 -1 @DANCE_2762 -1 @DANCE_2762 -1 @DANCE_2762 -1 @DANCE_2762 -1 @DANCE_2762

:DANCE_2475
0991: set_soundtrack_paused 1
00D6: if 
0611:   actor $PLAYER_ACTOR performing_animation v$DANCE_ANIM
004D: jump_if_false @DANCE_2508
0612: set_actor $PLAYER_ACTOR animation v$DANCE_ANIM paused 0

:DANCE_2508
00D6: if 
8118:   not actor 5@ dead
004D: jump_if_false @DANCE_2553
00D6: if 
0611:   actor 5@ performing_animation v$5303
004D: jump_if_false @DANCE_2553
0612: set_actor 5@ animation v$5303 paused 0

:DANCE_2553
000A: 7@ += 1
0002: jump @DANCE_2762

:DANCE_2567
0050: gosub @DANCE_2932
00D6: if 
0039:   18@ == 100
004D: jump_if_false @DANCE_2620
0004: $DANCE_SCORE = 0
0006: 6@ = 2
0006: 7@ = 0
0002: jump @DANCE_2762

:DANCE_2620
00D6: if 
0039:   18@ == 99
004D: jump_if_false @DANCE_2755
00D6: if 
0019:   6@ > 0
004D: jump_if_false @DANCE_2755
0991: set_soundtrack_paused 0
00D6: if 
0611:   actor $PLAYER_ACTOR performing_animation v$DANCE_ANIM
004D: jump_if_false @DANCE_2689
0612: set_actor $PLAYER_ACTOR animation v$DANCE_ANIM paused 1

:DANCE_2689
00D6: if 
8118:   not actor 5@ dead
004D: jump_if_false @DANCE_2734
00D6: if 
0611:   actor 5@ performing_animation v$5303
004D: jump_if_false @DANCE_2734
0612: set_actor 5@ animation v$5303 paused 1

:DANCE_2734
0006: 6@ = 1
0006: 7@ = 1
0002: jump @DANCE_2762

:DANCE_2755
0002: jump @DANCE_2762

:DANCE_2762
0051: return

:DANCE_2764
0871: init_jump_table 4@ total_jumps 4 default_jump 1 @DANCE_2906 jumps 1 @DANCE_2827 2 @DANCE_2846 3 @DANCE_2865 4 @DANCE_2889 -1 @DANCE_2930 -1 @DANCE_2930 -1 @DANCE_2930

:DANCE_2827
06D1: v$DANCE_ANIM_IFP = ""GFUNK"" // v$ = string
0002: jump @DANCE_2930

:DANCE_2846
06D1: v$DANCE_ANIM_IFP = ""GFUNK"" // v$ = string
0002: jump @DANCE_2930

:DANCE_2865
06D1: v$DANCE_ANIM_IFP = ""RUNNINGMAN"" // v$ = string
0002: jump @DANCE_2930

:DANCE_2889
06D1: v$DANCE_ANIM_IFP = ""WOP"" // v$ = string
0002: jump @DANCE_2930

:DANCE_2906
06D1: v$DANCE_ANIM_IFP = ""WOP"" // v$ = string
0006: 4@ = 4
0002: jump @DANCE_2930

:DANCE_2930
0051: return

:DANCE_2932
0050: gosub @DANCE_16964
0871: init_jump_table 23@ total_jumps 7 default_jump 0 @DANCE_3660 jumps 1 @DANCE_3386 2 @DANCE_3340 3 @DANCE_3294 4 @DANCE_3248 5 @DANCE_3002 99 @DANCE_3432 100 @DANCE_3615

:DANCE_3002
00D6: if 
0038:   $9534 == 10
004D: jump_if_false @DANCE_3041
0006: 18@ = 4
0006: 23@ = 4
0002: jump @DANCE_3660

:DANCE_3041
00D6: if 
0038:   $9534 == 13
004D: jump_if_false @DANCE_3080
0006: 18@ = 3
0006: 23@ = 3
0002: jump @DANCE_3660

:DANCE_3080
00D6: if 
0038:   $9534 == 9
004D: jump_if_false @DANCE_3119
0006: 18@ = 2
0006: 23@ = 2
0002: jump @DANCE_3660

:DANCE_3119
00D6: if 
0038:   $9534 == 14
004D: jump_if_false @DANCE_3158
0006: 18@ = 1
0006: 23@ = 1
0002: jump @DANCE_3660

:DANCE_3158
00D6: if 
00E1:   player 0 pressed_key 15
004D: jump_if_false @DANCE_3203
0006: 18@ = 99
0006: 23@ = 99
0006: TIMERB = 0
0002: jump @DANCE_3660

:DANCE_3203
00D6: if 
00E1:   player 0 pressed_key 16
004D: jump_if_false @DANCE_3241
0006: 18@ = 100
0006: 23@ = 100
0002: jump @DANCE_3660

:DANCE_3241
0002: jump @DANCE_3660

:DANCE_3248
0006: 18@ = 5
00D6: if 
0038:   $9534 == 0
004D: jump_if_false @DANCE_3287
0006: 23@ = 5
0002: jump @DANCE_3660

:DANCE_3287
0002: jump @DANCE_3660

:DANCE_3294
0006: 18@ = 5
00D6: if 
0038:   $9534 == 0
004D: jump_if_false @DANCE_3333
0006: 23@ = 5
0002: jump @DANCE_3660

:DANCE_3333
0002: jump @DANCE_3660

:DANCE_3340
0006: 18@ = 5
00D6: if 
0038:   $9534 == 0
004D: jump_if_false @DANCE_3379
0006: 23@ = 5
0002: jump @DANCE_3660

:DANCE_3379
0002: jump @DANCE_3660

:DANCE_3386
0006: 18@ = 5
00D6: if 
0038:   $9534 == 0
004D: jump_if_false @DANCE_3425
0006: 23@ = 5
0002: jump @DANCE_3660

:DANCE_3425
0002: jump @DANCE_3660

:DANCE_3432
0006: 18@ = 5
00D6: if 
80E1:   not player 0 pressed_key 15
004D: jump_if_false @DANCE_3477
0006: 23@ = 5
0002: jump @DANCE_3660
0002: jump @DANCE_3608

:DANCE_3477
00D6: if 
0039:   5@ == -1
004D: jump_if_false @DANCE_3564
00D6: if 
8039:   not 22@ == 5
004D: jump_if_false @DANCE_3557
00D6: if and
8039:   not 6@ == 3
0029:   TIMERB >= 800
004D: jump_if_false @DANCE_3557
03E6: remove_text_box
0006: 6@ = 3
0006: 7@ = 0
0051: return

:DANCE_3557
0002: jump @DANCE_3608

:DANCE_3564
00D6: if and
8039:   not 6@ == 3
0029:   TIMERB >= 800
004D: jump_if_false @DANCE_3608
03E6: remove_text_box
0006: 6@ = 3
0006: 7@ = 0
0051: return

:DANCE_3608
0002: jump @DANCE_3660

:DANCE_3615
0006: 18@ = 5
00D6: if 
80E1:   not player 0 pressed_key 16
004D: jump_if_false @DANCE_3653
0006: 23@ = 5
0002: jump @DANCE_3660

:DANCE_3653
0002: jump @DANCE_3660

:DANCE_3660
0051: return

:DANCE_3662
07B1: unknown_get_dance_track 0 store_to 14@ 13@ 15@
00D6: if 
0019:   14@ > 3000
004D: jump_if_false @DANCE_3708
0006: 22@ = 5
0002: jump @DANCE_4111

:DANCE_3708
00D6: if 
001D:   15@ > 16@  // (int)
004D: jump_if_false @DANCE_4022
00D6: if 
0039:   18@ == 5
004D: jump_if_false @DANCE_3787
00D6: if 
001B:   -110 > 14@
004D: jump_if_false @DANCE_3780
0006: 22@ = 0
0085: 16@ = 15@  // (int)
0051: return

:DANCE_3780
0002: jump @DANCE_4015

:DANCE_3787
0004: $1043 = 1
00D6: if 
003B:   18@ == 13@  // (int)
004D: jump_if_false @DANCE_3998
00D6: if and
002B:   35 >= 14@
0029:   14@ >= -35
004D: jump_if_false @DANCE_3869
0006: 22@ = 1
0004: $1043 = 3
0085: 16@ = 15@  // (int)
0051: return
0002: jump @DANCE_3991

:DANCE_3869
00D6: if and
002B:   60 >= 14@
0029:   14@ >= -60
004D: jump_if_false @DANCE_3925
0006: 22@ = 2
0004: $1043 = 2
0085: 16@ = 15@  // (int)
0051: return
0002: jump @DANCE_3991

:DANCE_3925
00D6: if and
002B:   110 >= 14@
0029:   14@ >= -110
004D: jump_if_false @DANCE_3974
0006: 22@ = 3
0085: 16@ = 15@  // (int)
0051: return
0002: jump @DANCE_3991

:DANCE_3974
0006: 22@ = 11
0085: 16@ = 15@  // (int)
0051: return

:DANCE_3991
0002: jump @DANCE_4015

:DANCE_3998
0006: 22@ = 10
0085: 16@ = 15@  // (int)
0051: return

:DANCE_4015
0002: jump @DANCE_4111

:DANCE_4022
00D6: if or
0039:   22@ == 1
0039:   22@ == 2
0039:   22@ == 3
004D: jump_if_false @DANCE_4063
0006: 22@ = 8
0051: return

:DANCE_4063
00D6: if or
0039:   22@ == 0
0039:   22@ == 4
0039:   22@ == 10
0039:   22@ == 11
004D: jump_if_false @DANCE_4111
0006: 22@ = 9
0051: return

:DANCE_4111
0051: return

:DANCE_4113
0871: init_jump_table 17@ total_jumps 15 default_jump 1 @DANCE_4241 jumps 2 @DANCE_4270 3 @DANCE_4299 4 @DANCE_4328 5 @DANCE_4357 6 @DANCE_4386 7 @DANCE_4415 8 @DANCE_4444
0872: jump_table_jumps 9 @DANCE_4473 10 @DANCE_4502 11 @DANCE_4532 12 @DANCE_4562 13 @DANCE_4592 14 @DANCE_4622 15 @DANCE_4652 16 @DANCE_4682 -1 @DANCE_4712

:DANCE_4241
06D1: v$DANCE_ANIM = ""DANCE_G1"" // v$ = string
0006: 17@ = 2
0002: jump @DANCE_4712

:DANCE_4270
06D1: v$DANCE_ANIM = ""DANCE_G2"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4299
06D1: v$DANCE_ANIM = ""DANCE_G3"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4328
06D1: v$DANCE_ANIM = ""DANCE_G4"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4357
06D1: v$DANCE_ANIM = ""DANCE_G5"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4386
06D1: v$DANCE_ANIM = ""DANCE_G6"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4415
06D1: v$DANCE_ANIM = ""DANCE_G7"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4444
06D1: v$DANCE_ANIM = ""DANCE_G8"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4473
06D1: v$DANCE_ANIM = ""DANCE_G9"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4502
06D1: v$DANCE_ANIM = ""DANCE_G10"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4532
06D1: v$DANCE_ANIM = ""DANCE_G11"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4562
06D1: v$DANCE_ANIM = ""DANCE_G12"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4592
06D1: v$DANCE_ANIM = ""DANCE_G13"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4622
06D1: v$DANCE_ANIM = ""DANCE_G14"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4652
06D1: v$DANCE_ANIM = ""DANCE_G15"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4682
06D1: v$DANCE_ANIM = ""DANCE_G16"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_4712

:DANCE_4712
0812: AS_actor $PLAYER_ACTOR perform_animation v$DANCE_ANIM IFP v$DANCE_ANIM_IFP framedelta 4.0 loopA 0 lockX 0 lockY 0 lockF 0 time 0 // versionB
0051: return

:DANCE_4740
0871: init_jump_table 17@ total_jumps 15 default_jump 1 @DANCE_4868 jumps 2 @DANCE_4897 3 @DANCE_4926 4 @DANCE_4955 5 @DANCE_4984 6 @DANCE_5013 7 @DANCE_5042 8 @DANCE_5071
0872: jump_table_jumps 9 @DANCE_5100 10 @DANCE_5129 11 @DANCE_5159 12 @DANCE_5189 13 @DANCE_5219 14 @DANCE_5249 15 @DANCE_5279 16 @DANCE_5309 -1 @DANCE_5339

:DANCE_4868
06D1: v$DANCE_ANIM = ""DANCE_B1"" // v$ = string
0006: 17@ = 2
0002: jump @DANCE_5339

:DANCE_4897
06D1: v$DANCE_ANIM = ""DANCE_B2"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_4926
06D1: v$DANCE_ANIM = ""DANCE_B3"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_4955
06D1: v$DANCE_ANIM = ""DANCE_B4"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_4984
06D1: v$DANCE_ANIM = ""DANCE_B5"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5013
06D1: v$DANCE_ANIM = ""DANCE_B6"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5042
06D1: v$DANCE_ANIM = ""DANCE_B7"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5071
06D1: v$DANCE_ANIM = ""DANCE_B8"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5100
06D1: v$DANCE_ANIM = ""DANCE_B9"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5129
06D1: v$DANCE_ANIM = ""DANCE_B10"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5159
06D1: v$DANCE_ANIM = ""DANCE_B11"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5189
06D1: v$DANCE_ANIM = ""DANCE_B12"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5219
06D1: v$DANCE_ANIM = ""DANCE_B13"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5249
06D1: v$DANCE_ANIM = ""DANCE_B14"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5279
06D1: v$DANCE_ANIM = ""DANCE_B15"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5309
06D1: v$DANCE_ANIM = ""DANCE_B16"" // v$ = string
000A: 17@ += 1
0002: jump @DANCE_5339

:DANCE_5339
0812: AS_actor $PLAYER_ACTOR perform_animation v$DANCE_ANIM IFP v$DANCE_ANIM_IFP framedelta 4.0 loopA 0 lockX 0 lockY 0 lockF 0 time 0 // versionB
0051: return

:DANCE_5367
00D6: if 
0611:   actor $PLAYER_ACTOR performing_animation v$DANCE_ANIM
004D: jump_if_false @DANCE_5493
061A: get_actor $PLAYER_ACTOR animation v$DANCE_ANIM total_time_to 12@
0613: 11@ = actor $PLAYER_ACTOR animation v$DANCE_ANIM time
0093: 8@ = integer 21@ to_float
0087: 0@ = 8@  // (float)
0073: 0@ /= 12@  // (float)
005B: 11@ += 0@  // (float)
00D6: if 
0031:   11@ >= 1.0
004D: jump_if_false @DANCE_5477
0006: 31@ = 1
0051: return
0002: jump @DANCE_5486

:DANCE_5477
0006: 31@ = -1
0051: return

:DANCE_5486
0002: jump @DANCE_5502

:DANCE_5493
0006: 31@ = 0
0051: return

:DANCE_5502
0051: return

:DANCE_5504
00D6: if 
0019:   5@ > -1
004D: jump_if_false @DANCE_5690
00D6: if 
0611:   actor 5@ performing_animation v$5303
004D: jump_if_false @DANCE_5632
061A: get_actor 5@ animation v$5303 total_time_to 12@
0613: 11@ = actor 5@ animation v$5303 time
0093: 8@ = integer 21@ to_float
0087: 0@ = 8@  // (float)
0073: 0@ /= 12@  // (float)
005B: 11@ += 0@  // (float)
00D6: if 
0031:   11@ >= 1.0
004D: jump_if_false @DANCE_5625
0050: gosub @DANCE_7066
0051: return

:DANCE_5625
0002: jump @DANCE_5690

:DANCE_5632
07B1: unknown_get_dance_track 0 store_to 14@ 13@ 15@
00D6: if 
0039:   15@ == 0
004D: jump_if_false @DANCE_5690
00D6: if 
002B:   25 >= 14@
004D: jump_if_false @DANCE_5690
0050: gosub @DANCE_7066
0051: return

:DANCE_5690
0051: return

:DANCE_5692
01BD: 19@ = current_time_in_ms
0085: 21@ = 19@  // (int)
0062: 21@ -= 20@  // (int)
0085: 20@ = 19@  // (int)
0051: return

:DANCE_5723
0050: gosub @DANCE_5367
00D6: if 
0039:   31@ == 1
004D: jump_if_false @DANCE_5826
00D6: if or
0039:   22@ == 1
0039:   22@ == 2
0039:   22@ == 3
0039:   22@ == 8
004D: jump_if_false @DANCE_5810
0050: gosub @DANCE_4113
0006: 31@ = -1
0051: return
0002: jump @DANCE_5826

:DANCE_5810
0050: gosub @DANCE_4740
0006: 31@ = -1
0051: return

:DANCE_5826
0051: return

:DANCE_5828
0871: init_jump_table 17@ total_jumps 5 default_jump 0 @DANCE_6881 jumps -1 @DANCE_5891 4 @DANCE_6089 8 @DANCE_6287 12 @DANCE_6485 16 @DANCE_6683 -1 @DANCE_6881 -1 @DANCE_6881

:DANCE_5891
00D6: if and
0039:   5@ == -1
0020:   $5315[0] > 0.0
004D: jump_if_false @DANCE_5965
015F: set_camera_position $5315[0] $5320[0] $5325[0] rotation 0.0 0.0 0.0
0160: set_camera_point_at $5330[0] $5335[0] $5340[0] switchstyle 2
0002: jump @DANCE_6082

:DANCE_5965
04C4: store_coords_to 8@ 9@ 10@ from_actor $PLAYER_ACTOR with_offset -2.3176 0.9635 0.5141
04C4: store_coords_to 0@ 1@ 2@ from_actor $PLAYER_ACTOR with_offset -1.3381 0.8235 0.6587
000F: 10@ -= 1.0
000F: 2@ -= 1.0
015F: set_camera_position 8@ 9@ 10@ rotation 0.0 0.0 0.0
0160: set_camera_point_at 0@ 1@ 2@ switchstyle 2

:DANCE_6082
0002: jump @DANCE_6881

:DANCE_6089
00D6: if and
0039:   5@ == -1
0020:   $5315[1] > 0.0
004D: jump_if_false @DANCE_6163
015F: set_camera_position $5315[1] $5320[1] $5325[1] rotation 0.0 0.0 0.0
0160: set_camera_point_at $5330[1] $5335[1] $5340[1] switchstyle 2
0002: jump @DANCE_6280

:DANCE_6163
04C4: store_coords_to 8@ 9@ 10@ from_actor $PLAYER_ACTOR with_offset 3.5814 0.8987 0.6651
04C4: store_coords_to 0@ 1@ 2@ from_actor $PLAYER_ACTOR with_offset 2.6071 0.853 0.8857
000F: 10@ -= 1.0
000F: 2@ -= 1.0
015F: set_camera_position 8@ 9@ 10@ rotation 0.0 0.0 0.0
0160: set_camera_point_at 0@ 1@ 2@ switchstyle 2

:DANCE_6280
0002: jump @DANCE_6881

:DANCE_6287
00D6: if and
0039:   5@ == -1
0020:   $5315[2] > 0.0
004D: jump_if_false @DANCE_6361
015F: set_camera_position $5315[2] $5320[2] $5325[2] rotation 0.0 0.0 0.0
0160: set_camera_point_at $5330[2] $5335[2] $5340[2] switchstyle 2
0002: jump @DANCE_6478

:DANCE_6361
04C4: store_coords_to 8@ 9@ 10@ from_actor $PLAYER_ACTOR with_offset 0.3843 2.9502 1.8476
04C4: store_coords_to 0@ 1@ 2@ from_actor $PLAYER_ACTOR with_offset 0.461 2.0089 1.5188
000F: 10@ -= 1.0
000F: 2@ -= 1.0
015F: set_camera_position 8@ 9@ 10@ rotation 0.0 0.0 0.0
0160: set_camera_point_at 0@ 1@ 2@ switchstyle 2

:DANCE_6478
0002: jump @DANCE_6881

:DANCE_6485
00D6: if and
0039:   5@ == -1
0020:   $5315[3] > 0.0
004D: jump_if_false @DANCE_6559
015F: set_camera_position $5315[3] $5320[3] $5325[3] rotation 0.0 0.0 0.0
0160: set_camera_point_at $5330[3] $5335[3] $5340[3] switchstyle 2
0002: jump @DANCE_6676

:DANCE_6559
04C4: store_coords_to 8@ 9@ 10@ from_actor $PLAYER_ACTOR with_offset -2.2621 0.1226 0.6863
04C4: store_coords_to 0@ 1@ 2@ from_actor $PLAYER_ACTOR with_offset -1.2706 0.1649 0.8096
000F: 10@ -= 1.0
000F: 2@ -= 1.0
015F: set_camera_position 8@ 9@ 10@ rotation 0.0 0.0 0.0
0160: set_camera_point_at 0@ 1@ 2@ switchstyle 2

:DANCE_6676
0002: jump @DANCE_6881

:DANCE_6683
00D6: if and
0039:   5@ == -1
0020:   $5315[4] > 0.0
004D: jump_if_false @DANCE_6757
015F: set_camera_position $5315[4] $5320[4] $5325[4] rotation 0.0 0.0 0.0
0160: set_camera_point_at $5330[4] $5335[4] $5340[4] switchstyle 2
0002: jump @DANCE_6874

:DANCE_6757
04C4: store_coords_to 8@ 9@ 10@ from_actor $PLAYER_ACTOR with_offset -1.6647 1.7322 2.3217
04C4: store_coords_to 0@ 1@ 2@ from_actor $PLAYER_ACTOR with_offset -0.8677 1.3108 1.889
000F: 10@ -= 1.0
000F: 2@ -= 1.0
015F: set_camera_position 8@ 9@ 10@ rotation 0.0 0.0 0.0
0160: set_camera_point_at 0@ 1@ 2@ switchstyle 2

:DANCE_6874
0002: jump @DANCE_6881

:DANCE_6881
0051: return

:DANCE_6883
00D6: if 
8039:   not 5@ == -1
004D: jump_if_false @DANCE_7064
04C4: store_coords_to 8@ 9@ 10@ from_actor $PLAYER_ACTOR with_offset 1.0 1.3 0.0
02CE: 10@ = ground_z_at 8@ 9@ 10@
00D6: if 
0118:   actor 5@ dead
004D: jump_if_false @DANCE_6974
0050: gosub @DANCE_7709
0002: jump @DANCE_7017

:DANCE_6974
00D6: if 
06EE:   actor 5@ in_group $PLAYER_GROUP
004D: jump_if_false @DANCE_6998
06C9: remove_actor 5@ from_group

:DANCE_6998
0792: disembark_instantly_actor 5@
00A1: put_actor 5@ at 8@ 9@ 10@

:DANCE_7017
00D6: if and
8118:   not actor 5@ dead
8118:   not actor $PLAYER_ACTOR dead
004D: jump_if_false @DANCE_7064
0172: 11@ = actor $PLAYER_ACTOR Z_angle
000B: 11@ += 180.0
0173: set_actor 5@ Z_angle_to 11@

:DANCE_7064
0051: return

:DANCE_7066
0871: init_jump_table 25@ total_jumps 15 default_jump 1 @DANCE_7194 jumps 2 @DANCE_7223 3 @DANCE_7252 4 @DANCE_7281 5 @DANCE_7310 6 @DANCE_7339 7 @DANCE_7368 8 @DANCE_7397
0872: jump_table_jumps 9 @DANCE_7426 10 @DANCE_7455 11 @DANCE_7485 12 @DANCE_7515 13 @DANCE_7545 14 @DANCE_7575 15 @DANCE_7605 16 @DANCE_7635 -1 @DANCE_7665

:DANCE_7194
06D1: v$5303 = ""DANCE_G1"" // v$ = string
0006: 25@ = 2
0002: jump @DANCE_7665

:DANCE_7223
06D1: v$5303 = ""DANCE_G2"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7252
06D1: v$5303 = ""DANCE_G3"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7281
06D1: v$5303 = ""DANCE_G4"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7310
06D1: v$5303 = ""DANCE_G5"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7339
06D1: v$5303 = ""DANCE_G6"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7368
06D1: v$5303 = ""DANCE_G7"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7397
06D1: v$5303 = ""DANCE_G8"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7426
06D1: v$5303 = ""DANCE_G9"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7455
06D1: v$5303 = ""DANCE_G10"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7485
06D1: v$5303 = ""DANCE_G11"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7515
06D1: v$5303 = ""DANCE_G12"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7545
06D1: v$5303 = ""DANCE_G13"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7575
06D1: v$5303 = ""DANCE_G14"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7605
06D1: v$5303 = ""DANCE_G15"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7635
06D1: v$5303 = ""DANCE_G16"" // v$ = string
000A: 25@ += 1
0002: jump @DANCE_7665

:DANCE_7665
00D6: if 
8118:   not actor 5@ dead
004D: jump_if_false @DANCE_7707
0812: AS_actor 5@ perform_animation v$5303 IFP v$DANCE_ANIM_IFP framedelta 4.0 loopA 0 lockX 0 lockY 0 lockF 0 time 0 // versionB

:DANCE_7707
0051: return

:DANCE_7709
0209: 13@ = random_int_in_ranges 1 5
0871: init_jump_table 13@ total_jumps 5 default_jump 0 @DANCE_8066 jumps 1 @DANCE_7781 2 @DANCE_7838 3 @DANCE_7895 4 @DANCE_7952 5 @DANCE_8009 -1 @DANCE_8066 -1 @DANCE_8066

:DANCE_7781
00D6: if 
8248:   not model 12 available
004D: jump_if_false @DANCE_7811
0247: load_model 12
0001: wait 0 ms
0002: jump @DANCE_7781

:DANCE_7811
009A: 5@ = create_actor_pedtype 5 model 12 at 8@ 9@ 10@
0051: return
0002: jump @DANCE_8066

:DANCE_7838
00D6: if 
8248:   not model 56 available
004D: jump_if_false @DANCE_7868
0247: load_model 56
0001: wait 0 ms
0002: jump @DANCE_7838

:DANCE_7868
009A: 5@ = create_actor_pedtype 5 model 56 at 8@ 9@ 10@
0051: return
0002: jump @DANCE_8066

:DANCE_7895
00D6: if 
8248:   not model 93 available
004D: jump_if_false @DANCE_7925
0247: load_model 93
0001: wait 0 ms
0002: jump @DANCE_7895

:DANCE_7925
009A: 5@ = create_actor_pedtype 5 model 93 at 8@ 9@ 10@
0051: return
0002: jump @DANCE_8066

:DANCE_7952
00D6: if 
8248:   not model 40 available
004D: jump_if_false @DANCE_7982
0247: load_model 40
0001: wait 0 ms
0002: jump @DANCE_7952

:DANCE_7982
009A: 5@ = create_actor_pedtype 5 model 40 at 8@ 9@ 10@
0051: return
0002: jump @DANCE_8066

:DANCE_8009
00D6: if 
8248:   not model 91 available
004D: jump_if_false @DANCE_8039
0247: load_model 91
0001: wait 0 ms
0002: jump @DANCE_8009

:DANCE_8039
009A: 5@ = create_actor_pedtype 5 model 91 at 8@ 9@ 10@
0051: return
0002: jump @DANCE_8066

:DANCE_8066
0051: return

:DANCE_8068
00D6: if 
8846:   not string v$DANCE_ANIM empty // v$
004D: jump_if_false @DANCE_8129
07B1: unknown_get_dance_track 0 store_to 14@ 13@ 15@
00D6: if 
0039:   13@ == 33
004D: jump_if_false @DANCE_8129
0006: 6@ = 2
0006: 7@ = 0

:DANCE_8129
0051: return

:DANCE_8131
0871: init_jump_table 24@ total_jumps 2 default_jump 1 @DANCE_8194 jumps 2 @DANCE_8446 3 @DANCE_8698 -1 @DANCE_8950 -1 @DANCE_8950 -1 @DANCE_8950 -1 @DANCE_8950 -1 @DANCE_8950

:DANCE_8194
00D6: if 
0039:   22@ == 1
004D: jump_if_false @DANCE_8228
00BA: show_text_styled GXT 'DNC_005' time 1000 style 5

:DANCE_8228
00D6: if 
0039:   22@ == 2
004D: jump_if_false @DANCE_8262
00BA: show_text_styled GXT 'DNC_006' time 1000 style 5

:DANCE_8262
00D6: if 
0039:   22@ == 3
004D: jump_if_false @DANCE_8296
00BA: show_text_styled GXT 'DNC_007' time 1000 style 5

:DANCE_8296
00D6: if 
0039:   22@ == 0
004D: jump_if_false @DANCE_8330
00BA: show_text_styled GXT 'DNC_008' time 1000 style 5

:DANCE_8330
00D6: if 
0039:   22@ == 4
004D: jump_if_false @DANCE_8364
00BA: show_text_styled GXT 'DNC_009' time 1000 style 5

:DANCE_8364
00D6: if 
0039:   22@ == 10
004D: jump_if_false @DANCE_8398
00BA: show_text_styled GXT 'DNC_010' time 1000 style 5

:DANCE_8398
00D6: if 
0039:   22@ == 11
004D: jump_if_false @DANCE_8432
00BA: show_text_styled GXT 'DNC_011' time 1000 style 5

:DANCE_8432
0006: 24@ = 2
0002: jump @DANCE_8950

:DANCE_8446
00D6: if 
0039:   22@ == 1
004D: jump_if_false @DANCE_8480
00BA: show_text_styled GXT 'DNC_012' time 1000 style 5

:DANCE_8480
00D6: if 
0039:   22@ == 2
004D: jump_if_false @DANCE_8514
00BA: show_text_styled GXT 'DNC_013' time 1000 style 5

:DANCE_8514
00D6: if 
0039:   22@ == 3
004D: jump_if_false @DANCE_8548
00BA: show_text_styled GXT 'DNC_014' time 1000 style 5

:DANCE_8548
00D6: if 
0039:   22@ == 0
004D: jump_if_false @DANCE_8582
00BA: show_text_styled GXT 'DNC_015' time 1000 style 5

:DANCE_8582
00D6: if 
0039:   22@ == 4
004D: jump_if_false @DANCE_8616
00BA: show_text_styled GXT 'DNC_016' time 1000 style 5

:DANCE_8616
00D6: if 
0039:   22@ == 10
004D: jump_if_false @DANCE_8650
00BA: show_text_styled GXT 'DNC_017' time 1000 style 5

:DANCE_8650
00D6: if 
0039:   22@ == 11
004D: jump_if_false @DANCE_8684
00BA: show_text_styled GXT 'DNC_018' time 1000 style 5

:DANCE_8684
000A: 24@ += 1
0002: jump @DANCE_8950

:DANCE_8698
00D6: if 
0039:   22@ == 1
004D: jump_if_false @DANCE_8732
00BA: show_text_styled GXT 'DNC_019' time 1000 style 5

:DANCE_8732
00D6: if 
0039:   22@ == 2
004D: jump_if_false @DANCE_8766
00BA: show_text_styled GXT 'DNC_020' time 1000 style 5

:DANCE_8766
00D6: if 
0039:   22@ == 3
004D: jump_if_false @DANCE_8800
00BA: show_text_styled GXT 'DNC_021' time 1000 style 5

:DANCE_8800
00D6: if 
0039:   22@ == 0
004D: jump_if_false @DANCE_8834
00BA: show_text_styled GXT 'DNC_022' time 1000 style 5

:DANCE_8834
00D6: if 
0039:   22@ == 4
004D: jump_if_false @DANCE_8868
00BA: show_text_styled GXT 'DNC_023' time 1000 style 5

:DANCE_8868
00D6: if 
0039:   22@ == 10
004D: jump_if_false @DANCE_8902
00BA: show_text_styled GXT 'DNC_024' time 1000 style 5

:DANCE_8902
00D6: if 
0039:   22@ == 11
004D: jump_if_false @DANCE_8936
00BA: show_text_styled GXT 'DNC_025' time 1000 style 5

:DANCE_8936
000A: 24@ += 1
0002: jump @DANCE_8950

:DANCE_8950
0051: return

:DANCE_8952
0085: 13@ = 26@  // (int)
005A: 13@ += 27@  // (int)
005A: 13@ += 28@  // (int)
00D6: if 
0019:   13@ > 0
004D: jump_if_false @DANCE_9477
00D6: if 
0029:   13@ >= 4
004D: jump_if_false @DANCE_9477
00D6: if 
0039:   28@ == 4
004D: jump_if_false @DANCE_9147
00D6: if or
0039:   29@ == 1
0039:   29@ == 2
004D: jump_if_false @DANCE_9101
0004: $9527 = 2
0006: TIMERA = 0
00BA: show_text_styled GXT 'DNC_002' time 50000 style 7
0006: 29@ = 2
0002: jump @DANCE_9140

:DANCE_9101
0004: $9527 = 2
0006: TIMERA = 0
00BA: show_text_styled GXT 'DNC_004' time 50000 style 7
0006: 29@ = 1

:DANCE_9140
0002: jump @DANCE_9456

:DANCE_9147
00D6: if 
001D:   26@ > 27@  // (int)
004D: jump_if_false @DANCE_9270
00D6: if 
8039:   not 29@ == 1
004D: jump_if_false @DANCE_9205
0004: $9527 = 4
0006: TIMERA = 0
0002: jump @DANCE_9238

:DANCE_9205
00D6: if 
0029:   TIMERA >= 10000
004D: jump_if_false @DANCE_9238
0004: $9527 = 4
0006: TIMERA = 0

:DANCE_9238
00BA: show_text_styled GXT 'DNC_004' time 50000 style 7
0006: 29@ = 1
0002: jump @DANCE_9456

:DANCE_9270
00D6: if 
0039:   29@ == 2
004D: jump_if_false @DANCE_9334
0004: $9527 = 3
0006: TIMERA = 0
00BA: show_text_styled GXT 'DNC_004' time 50000 style 7
0006: 29@ = 1
0002: jump @DANCE_9456

:DANCE_9334
00D6: if 
0039:   29@ == 1
004D: jump_if_false @DANCE_9398
0004: $9527 = 5
0006: TIMERA = 0
00BA: show_text_styled GXT 'DNC_003' time 50000 style 7
0006: 29@ = 0
0002: jump @DANCE_9456

:DANCE_9398
00D6: if 
0029:   TIMERA >= 10000
004D: jump_if_false @DANCE_9431
0004: $9527 = 5
0006: TIMERA = 0

:DANCE_9431
00BA: show_text_styled GXT 'DNC_003' time 50000 style 7
0006: 29@ = 0

:DANCE_9456
0006: 28@ = 0
0006: 26@ = 0
0006: 27@ = 0

:DANCE_9477
0051: return

:DANCE_9479
03E4: set_text_draw_align_right 0
0348: enable_text_draw_proportional 1
0345: enable_text_draw_background 1
033F: set_text_draw_letter_size 0.5014 1.8889
081C: draw_text_outline 2 RGBA 0 0 0 255
00D6: if 
0039:   6@ == 3
004D: jump_if_false @DANCE_9569
0343: set_text_draw_linewidth 240.0
033E: set_draw_text_position 32.0 32.0 GXT 'DNC_H2'
0002: jump @DANCE_9615

:DANCE_9569
00D6: if 
8039:   not 6@ == 2
004D: jump_if_false @DANCE_9615
0343: set_text_draw_linewidth 220.0
033E: set_draw_text_position 32.0 32.0 GXT 'DNC_H1'

:DANCE_9615
0051: return

:DANCE_9617
0871: init_jump_table $9528 total_jumps 6 default_jump 0 @DANCE_10043 jumps 0 @DANCE_9680 1 @DANCE_10003 6 @DANCE_9843 8 @DANCE_9883 9 @DANCE_9923 10 @DANCE_9963 -1 @DANCE_10043

:DANCE_9680
00D6: if 
0038:   $9527 == 2
004D: jump_if_false @DANCE_9719
0004: $9528 = 6
0004: $9527 = -1
0002: jump @DANCE_10043

:DANCE_9719
00D6: if 
0038:   $9527 == 3
004D: jump_if_false @DANCE_9758
0004: $9528 = 8
0004: $9527 = -1
0002: jump @DANCE_10043

:DANCE_9758
00D6: if 
0038:   $9527 == 4
004D: jump_if_false @DANCE_9797
0004: $9528 = 9
0004: $9527 = -1
0002: jump @DANCE_10043

:DANCE_9797
00D6: if 
0038:   $9527 == 5
004D: jump_if_false @DANCE_9836
0004: $9528 = 10
0004: $9527 = -1
0002: jump @DANCE_10043

:DANCE_9836
0002: jump @DANCE_10043

:DANCE_9843
00D6: if 
03D2:   wav 4 ended
004D: jump_if_false @DANCE_9876
040D: unload_wav 4
0050: gosub @DANCE_10045
0004: $9528 = 1

:DANCE_9876
0002: jump @DANCE_10043

:DANCE_9883
00D6: if 
03D2:   wav 4 ended
004D: jump_if_false @DANCE_9916
040D: unload_wav 4
0050: gosub @DANCE_11697
0004: $9528 = 1

:DANCE_9916
0002: jump @DANCE_10043

:DANCE_9923
00D6: if 
03D2:   wav 4 ended
004D: jump_if_false @DANCE_9956
040D: unload_wav 4
0050: gosub @DANCE_13349
0004: $9528 = 1

:DANCE_9956
0002: jump @DANCE_10043

:DANCE_9963
00D6: if 
03D2:   wav 4 ended
004D: jump_if_false @DANCE_9996
040D: unload_wav 4
0050: gosub @DANCE_15001
0004: $9528 = 1

:DANCE_9996
0002: jump @DANCE_10043

:DANCE_10003
00D6: if 
03D0:   wav 4 loaded
004D: jump_if_false @DANCE_10036
0949: link_wav 4 to_actor $PLAYER_ACTOR
03D1: play_wav 4
0004: $9528 = 0

:DANCE_10036
0002: jump @DANCE_10043

:DANCE_10043
0051: return

:DANCE_10045
0871: init_jump_table $9529 total_jumps 56 default_jump 1 @DANCE_10498 jumps 1 @DANCE_10519 2 @DANCE_10540 3 @DANCE_10561 4 @DANCE_10582 5 @DANCE_10603 6 @DANCE_10624 7 @DANCE_10645
0872: jump_table_jumps 8 @DANCE_10666 9 @DANCE_10687 10 @DANCE_10708 11 @DANCE_10729 12 @DANCE_10750 13 @DANCE_10771 14 @DANCE_10792 15 @DANCE_10813 16 @DANCE_10834
0872: jump_table_jumps 17 @DANCE_10855 18 @DANCE_10876 19 @DANCE_10897 20 @DANCE_10918 21 @DANCE_10939 22 @DANCE_10960 23 @DANCE_10981 24 @DANCE_11002 25 @DANCE_11023
0872: jump_table_jumps 26 @DANCE_11044 27 @DANCE_11065 28 @DANCE_11086 29 @DANCE_11107 30 @DANCE_11128 31 @DANCE_11149 32 @DANCE_11170 33 @DANCE_11191 34 @DANCE_11212
0872: jump_table_jumps 35 @DANCE_11233 36 @DANCE_11254 37 @DANCE_11275 38 @DANCE_11296 39 @DANCE_11317 40 @DANCE_11338 41 @DANCE_11359 42 @DANCE_11380 43 @DANCE_11401
0872: jump_table_jumps 44 @DANCE_11422 45 @DANCE_11443 46 @DANCE_11464 47 @DANCE_11485 48 @DANCE_11506 49 @DANCE_11527 50 @DANCE_11548 51 @DANCE_11569 52 @DANCE_11590
0872: jump_table_jumps 53 @DANCE_11611 54 @DANCE_11632 55 @DANCE_11653 56 @DANCE_11674 -1 @DANCE_11695 -1 @DANCE_11695 -1 @DANCE_11695 -1 @DANCE_11695 -1 @DANCE_11695

:DANCE_10498
03CF: load_wav 11455 as 4
0004: $9529 = 1
0002: jump @DANCE_11695

:DANCE_10519
03CF: load_wav 11400 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10540
03CF: load_wav 11401 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10561
03CF: load_wav 11402 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10582
03CF: load_wav 11403 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10603
03CF: load_wav 11404 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10624
03CF: load_wav 11405 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10645
03CF: load_wav 11406 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10666
03CF: load_wav 11407 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10687
03CF: load_wav 11408 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10708
03CF: load_wav 11409 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10729
03CF: load_wav 11410 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10750
03CF: load_wav 11411 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10771
03CF: load_wav 11412 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10792
03CF: load_wav 11413 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10813
03CF: load_wav 11414 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10834
03CF: load_wav 11415 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10855
03CF: load_wav 11416 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10876
03CF: load_wav 11417 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10897
03CF: load_wav 11418 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10918
03CF: load_wav 11419 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10939
03CF: load_wav 11420 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10960
03CF: load_wav 11421 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_10981
03CF: load_wav 11422 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11002
03CF: load_wav 11423 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11023
03CF: load_wav 11424 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11044
03CF: load_wav 11425 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11065
03CF: load_wav 11426 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11086
03CF: load_wav 11427 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11107
03CF: load_wav 11428 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11128
03CF: load_wav 11429 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11149
03CF: load_wav 11430 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11170
03CF: load_wav 11431 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11191
03CF: load_wav 11432 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11212
03CF: load_wav 11433 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11233
03CF: load_wav 11434 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11254
03CF: load_wav 11435 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11275
03CF: load_wav 11436 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11296
03CF: load_wav 11437 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11317
03CF: load_wav 11438 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11338
03CF: load_wav 11439 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11359
03CF: load_wav 11440 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11380
03CF: load_wav 11441 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11401
03CF: load_wav 11442 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11422
03CF: load_wav 11443 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11443
03CF: load_wav 11444 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11464
03CF: load_wav 11445 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11485
03CF: load_wav 11446 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11506
03CF: load_wav 11447 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11527
03CF: load_wav 11448 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11548
03CF: load_wav 11449 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11569
03CF: load_wav 11450 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11590
03CF: load_wav 11451 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11611
03CF: load_wav 11452 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11632
03CF: load_wav 11453 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11653
03CF: load_wav 11454 as 4
0008: $9529 += 1
0002: jump @DANCE_11695

:DANCE_11674
03CF: load_wav 11455 as 4
0004: $9529 = 1
0002: jump @DANCE_11695

:DANCE_11695
0051: return

:DANCE_11697
0871: init_jump_table $9529 total_jumps 56 default_jump 1 @DANCE_12150 jumps 1 @DANCE_12171 2 @DANCE_12192 3 @DANCE_12213 4 @DANCE_12234 5 @DANCE_12255 6 @DANCE_12276 7 @DANCE_12297
0872: jump_table_jumps 8 @DANCE_12318 9 @DANCE_12339 10 @DANCE_12360 11 @DANCE_12381 12 @DANCE_12402 13 @DANCE_12423 14 @DANCE_12444 15 @DANCE_12465 16 @DANCE_12486
0872: jump_table_jumps 17 @DANCE_12507 18 @DANCE_12528 19 @DANCE_12549 20 @DANCE_12570 21 @DANCE_12591 22 @DANCE_12612 23 @DANCE_12633 24 @DANCE_12654 25 @DANCE_12675
0872: jump_table_jumps 26 @DANCE_12696 27 @DANCE_12717 28 @DANCE_12738 29 @DANCE_12759 30 @DANCE_12780 31 @DANCE_12801 32 @DANCE_12822 33 @DANCE_12843 34 @DANCE_12864
0872: jump_table_jumps 35 @DANCE_12885 36 @DANCE_12906 37 @DANCE_12927 38 @DANCE_12948 39 @DANCE_12969 40 @DANCE_12990 41 @DANCE_13011 42 @DANCE_13032 43 @DANCE_13053
0872: jump_table_jumps 44 @DANCE_13074 45 @DANCE_13095 46 @DANCE_13116 47 @DANCE_13137 48 @DANCE_13158 49 @DANCE_13179 50 @DANCE_13200 51 @DANCE_13221 52 @DANCE_13242
0872: jump_table_jumps 53 @DANCE_13263 54 @DANCE_13284 55 @DANCE_13305 56 @DANCE_13326 -1 @DANCE_13347 -1 @DANCE_13347 -1 @DANCE_13347 -1 @DANCE_13347 -1 @DANCE_13347

:DANCE_12150
03CF: load_wav 11655 as 4
0004: $9529 = 1
0002: jump @DANCE_13347

:DANCE_12171
03CF: load_wav 11600 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12192
03CF: load_wav 11601 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12213
03CF: load_wav 11602 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12234
03CF: load_wav 11603 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12255
03CF: load_wav 11604 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12276
03CF: load_wav 11605 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12297
03CF: load_wav 11606 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12318
03CF: load_wav 11607 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12339
03CF: load_wav 11608 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12360
03CF: load_wav 11609 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12381
03CF: load_wav 11610 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12402
03CF: load_wav 11611 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12423
03CF: load_wav 11612 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12444
03CF: load_wav 11613 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12465
03CF: load_wav 11614 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12486
03CF: load_wav 11615 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12507
03CF: load_wav 11616 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12528
03CF: load_wav 11617 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12549
03CF: load_wav 11618 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12570
03CF: load_wav 11619 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12591
03CF: load_wav 11620 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12612
03CF: load_wav 11621 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12633
03CF: load_wav 11622 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12654
03CF: load_wav 11623 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12675
03CF: load_wav 11624 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12696
03CF: load_wav 11625 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12717
03CF: load_wav 11626 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12738
03CF: load_wav 11627 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12759
03CF: load_wav 11628 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12780
03CF: load_wav 11629 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12801
03CF: load_wav 11630 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12822
03CF: load_wav 11631 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12843
03CF: load_wav 11632 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12864
03CF: load_wav 11633 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12885
03CF: load_wav 11634 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12906
03CF: load_wav 11635 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12927
03CF: load_wav 11636 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12948
03CF: load_wav 11637 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12969
03CF: load_wav 11638 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_12990
03CF: load_wav 11639 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13011
03CF: load_wav 11640 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13032
03CF: load_wav 11641 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13053
03CF: load_wav 11642 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13074
03CF: load_wav 11643 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13095
03CF: load_wav 11644 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13116
03CF: load_wav 11645 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13137
03CF: load_wav 11646 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13158
03CF: load_wav 11647 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13179
03CF: load_wav 11648 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13200
03CF: load_wav 11649 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13221
03CF: load_wav 11650 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13242
03CF: load_wav 11651 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13263
03CF: load_wav 11652 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13284
03CF: load_wav 11653 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13305
03CF: load_wav 11654 as 4
0008: $9529 += 1
0002: jump @DANCE_13347

:DANCE_13326
03CF: load_wav 11655 as 4
0004: $9529 = 1
0002: jump @DANCE_13347

:DANCE_13347
0051: return

:DANCE_13349
0871: init_jump_table $9529 total_jumps 56 default_jump 1 @DANCE_13802 jumps 1 @DANCE_13823 2 @DANCE_13844 3 @DANCE_13865 4 @DANCE_13886 5 @DANCE_13907 6 @DANCE_13928 7 @DANCE_13949
0872: jump_table_jumps 8 @DANCE_13970 9 @DANCE_13991 10 @DANCE_14012 11 @DANCE_14033 12 @DANCE_14054 13 @DANCE_14075 14 @DANCE_14096 15 @DANCE_14117 16 @DANCE_14138
0872: jump_table_jumps 17 @DANCE_14159 18 @DANCE_14180 19 @DANCE_14201 20 @DANCE_14222 21 @DANCE_14243 22 @DANCE_14264 23 @DANCE_14285 24 @DANCE_14306 25 @DANCE_14327
0872: jump_table_jumps 26 @DANCE_14348 27 @DANCE_14369 28 @DANCE_14390 29 @DANCE_14411 30 @DANCE_14432 31 @DANCE_14453 32 @DANCE_14474 33 @DANCE_14495 34 @DANCE_14516
0872: jump_table_jumps 35 @DANCE_14537 36 @DANCE_14558 37 @DANCE_14579 38 @DANCE_14600 39 @DANCE_14621 40 @DANCE_14642 41 @DANCE_14663 42 @DANCE_14684 43 @DANCE_14705
0872: jump_table_jumps 44 @DANCE_14726 45 @DANCE_14747 46 @DANCE_14768 47 @DANCE_14789 48 @DANCE_14810 49 @DANCE_14831 50 @DANCE_14852 51 @DANCE_14873 52 @DANCE_14894
0872: jump_table_jumps 53 @DANCE_14915 54 @DANCE_14936 55 @DANCE_14957 56 @DANCE_14978 -1 @DANCE_14999 -1 @DANCE_14999 -1 @DANCE_14999 -1 @DANCE_14999 -1 @DANCE_14999

:DANCE_13802
03CF: load_wav 11855 as 4
0004: $9529 = 1
0002: jump @DANCE_14999

:DANCE_13823
03CF: load_wav 11800 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_13844
03CF: load_wav 11801 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_13865
03CF: load_wav 11802 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_13886
03CF: load_wav 11803 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_13907
03CF: load_wav 11804 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_13928
03CF: load_wav 11805 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_13949
03CF: load_wav 11806 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_13970
03CF: load_wav 11807 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_13991
03CF: load_wav 11808 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14012
03CF: load_wav 11809 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14033
03CF: load_wav 11810 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14054
03CF: load_wav 11811 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14075
03CF: load_wav 11812 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14096
03CF: load_wav 11813 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14117
03CF: load_wav 11814 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14138
03CF: load_wav 11815 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14159
03CF: load_wav 11816 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14180
03CF: load_wav 11817 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14201
03CF: load_wav 11818 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14222
03CF: load_wav 11819 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14243
03CF: load_wav 11820 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14264
03CF: load_wav 11821 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14285
03CF: load_wav 11822 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14306
03CF: load_wav 11823 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14327
03CF: load_wav 11824 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14348
03CF: load_wav 11825 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14369
03CF: load_wav 11826 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14390
03CF: load_wav 11827 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14411
03CF: load_wav 11828 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14432
03CF: load_wav 11829 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14453
03CF: load_wav 11830 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14474
03CF: load_wav 11831 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14495
03CF: load_wav 11832 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14516
03CF: load_wav 11833 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14537
03CF: load_wav 11834 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14558
03CF: load_wav 11835 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14579
03CF: load_wav 11836 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14600
03CF: load_wav 11837 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14621
03CF: load_wav 11838 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14642
03CF: load_wav 11839 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14663
03CF: load_wav 11840 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14684
03CF: load_wav 11841 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14705
03CF: load_wav 11842 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14726
03CF: load_wav 11843 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14747
03CF: load_wav 11844 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14768
03CF: load_wav 11845 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14789
03CF: load_wav 11846 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14810
03CF: load_wav 11847 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14831
03CF: load_wav 11848 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14852
03CF: load_wav 11849 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14873
03CF: load_wav 11850 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14894
03CF: load_wav 11851 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14915
03CF: load_wav 11852 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14936
03CF: load_wav 11853 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14957
03CF: load_wav 11854 as 4
0008: $9529 += 1
0002: jump @DANCE_14999

:DANCE_14978
03CF: load_wav 11855 as 4
0004: $9529 = 1
0002: jump @DANCE_14999

:DANCE_14999
0051: return

:DANCE_15001
0871: init_jump_table $9529 total_jumps 56 default_jump 1 @DANCE_15454 jumps 1 @DANCE_15475 2 @DANCE_15496 3 @DANCE_15517 4 @DANCE_15538 5 @DANCE_15559 6 @DANCE_15580 7 @DANCE_15601
0872: jump_table_jumps 8 @DANCE_15622 9 @DANCE_15643 10 @DANCE_15664 11 @DANCE_15685 12 @DANCE_15706 13 @DANCE_15727 14 @DANCE_15748 15 @DANCE_15769 16 @DANCE_15790
0872: jump_table_jumps 17 @DANCE_15811 18 @DANCE_15832 19 @DANCE_15853 20 @DANCE_15874 21 @DANCE_15895 22 @DANCE_15916 23 @DANCE_15937 24 @DANCE_15958 25 @DANCE_15979
0872: jump_table_jumps 26 @DANCE_16000 27 @DANCE_16021 28 @DANCE_16042 29 @DANCE_16063 30 @DANCE_16084 31 @DANCE_16105 32 @DANCE_16126 33 @DANCE_16147 34 @DANCE_16168
0872: jump_table_jumps 35 @DANCE_16189 36 @DANCE_16210 37 @DANCE_16231 38 @DANCE_16252 39 @DANCE_16273 40 @DANCE_16294 41 @DANCE_16315 42 @DANCE_16336 43 @DANCE_16357
0872: jump_table_jumps 44 @DANCE_16378 45 @DANCE_16399 46 @DANCE_16420 47 @DANCE_16441 48 @DANCE_16462 49 @DANCE_16483 50 @DANCE_16504 51 @DANCE_16525 52 @DANCE_16546
0872: jump_table_jumps 53 @DANCE_16567 54 @DANCE_16588 55 @DANCE_16609 56 @DANCE_16630 -1 @DANCE_16651 -1 @DANCE_16651 -1 @DANCE_16651 -1 @DANCE_16651 -1 @DANCE_16651

:DANCE_15454
03CF: load_wav 12055 as 4
0004: $9529 = 1
0002: jump @DANCE_16651

:DANCE_15475
03CF: load_wav 12000 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15496
03CF: load_wav 12001 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15517
03CF: load_wav 12002 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15538
03CF: load_wav 12003 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15559
03CF: load_wav 12004 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15580
03CF: load_wav 12005 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15601
03CF: load_wav 12006 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15622
03CF: load_wav 12007 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15643
03CF: load_wav 12008 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15664
03CF: load_wav 12009 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15685
03CF: load_wav 12010 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15706
03CF: load_wav 12011 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15727
03CF: load_wav 12012 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15748
03CF: load_wav 12013 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15769
03CF: load_wav 12014 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15790
03CF: load_wav 12015 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15811
03CF: load_wav 12016 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15832
03CF: load_wav 12017 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15853
03CF: load_wav 12018 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15874
03CF: load_wav 12019 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15895
03CF: load_wav 12020 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15916
03CF: load_wav 12021 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15937
03CF: load_wav 12022 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15958
03CF: load_wav 12023 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_15979
03CF: load_wav 12024 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16000
03CF: load_wav 12025 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16021
03CF: load_wav 12026 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16042
03CF: load_wav 12027 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16063
03CF: load_wav 12028 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16084
03CF: load_wav 12029 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16105
03CF: load_wav 12030 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16126
03CF: load_wav 12031 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16147
03CF: load_wav 12032 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16168
03CF: load_wav 12033 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16189
03CF: load_wav 12034 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16210
03CF: load_wav 12035 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16231
03CF: load_wav 12036 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16252
03CF: load_wav 12037 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16273
03CF: load_wav 12038 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16294
03CF: load_wav 12039 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16315
03CF: load_wav 12040 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16336
03CF: load_wav 12041 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16357
03CF: load_wav 12042 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16378
03CF: load_wav 12043 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16399
03CF: load_wav 12044 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16420
03CF: load_wav 12045 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16441
03CF: load_wav 12046 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16462
03CF: load_wav 12047 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16483
03CF: load_wav 12048 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16504
03CF: load_wav 12049 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16525
03CF: load_wav 12050 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16546
03CF: load_wav 12051 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16567
03CF: load_wav 12052 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16588
03CF: load_wav 12053 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16609
03CF: load_wav 12054 as 4
0008: $9529 += 1
0002: jump @DANCE_16651

:DANCE_16630
03CF: load_wav 12055 as 4
0004: $9529 = 1
0002: jump @DANCE_16651

:DANCE_16651
0051: return

:DANCE_16653
0004: $1044 = 1
0004: $5298 = 0
04EF: release_animation v$DANCE_ANIM_IFP
00BE: text_clear_all
00D6: if 
8118:   not actor 5@ dead
004D: jump_if_false @DANCE_16767
00D6: if and
82F2:   not actor 5@ model == 195
82F2:   not actor 5@ model == 192
82F2:   not actor 5@ model == 191
82F2:   not actor 5@ model == 190
82F2:   not actor 5@ model == 193
82F2:   not actor 5@ model == 194
004D: jump_if_false @DANCE_16767
0665: get_actor 5@ model_to 13@
0249: release_model 13@
009B: destroy_actor 5@

:DANCE_16767
0953: get_soundtrack_status_to 13@
00D6: if 
04A4:   13@ == 3  //  == constant
004D: jump_if_false @DANCE_16792
0955: end_playing_loaded_soundtrack

:DANCE_16792
0006: 13@ = 0

:DANCE_16799
0005: $5315(13@,5f) = 0.0
0005: $5320(13@,5f) = 0.0
0005: $5325(13@,5f) = 0.0
0005: $5330(13@,5f) = 0.0
0005: $5335(13@,5f) = 0.0
0005: $5340(13@,5f) = 0.0
000A: 13@ += 1
0029:   13@ >= 5
004D: jump_if_false @DANCE_16799
09EE: set_status_text_stay_on_screen 0
03F0: enable_text_draw 0
00D6: if 
0028:   $DANCE_SCORE >= 0
004D: jump_if_false @DANCE_16938
0629: change_integer_stat 156 to $DANCE_SCORE

:DANCE_16938
040D: unload_wav 4
01B4: set_player $PLAYER_CHAR can_move True
08C0: clear $5295 bit 31
09BD: allow_other_scripts_to_display_text_boxes 0
004E: terminate_this_script
0051: return

:DANCE_16964
0494: get_joystick 0 direction_offset_to $9530 $9531 $9532 $9533
008D: $9535 = integer $9530 to_float
0086: $9536 = $9535  // (float)
008D: $9535 = integer $9531 to_float
0086: $9537 = $9535  // (float)
0509: $9535 = distance_between_XY 0.0 0.0 and_XY $9536 $9537
0004: $9534 = 0
00D6: if 
0020:   $9535 > 64.0
004D: jump_if_false @DANCE_17325
05A4: get_angle_between_vectors_origin_to $9536 $9537 and_origin_to 0.0 -1.0 store_to $9535
00D6: if 
0022:   15.0 > $9535
004D: jump_if_false @DANCE_17117
0004: $9534 = 13
0002: jump @DANCE_17325

:DANCE_17117
00D6: if 
0022:   75.0 > $9535
004D: jump_if_false @DANCE_17184
00D6: if 
0018:   $9530 > 0
004D: jump_if_false @DANCE_17170
0004: $9534 = 11
0002: jump @DANCE_17177

:DANCE_17170
0004: $9534 = 15

:DANCE_17177
0002: jump @DANCE_17325

:DANCE_17184
00D6: if 
0022:   105.0 > $9535
004D: jump_if_false @DANCE_17251
00D6: if 
0018:   $9530 > 0
004D: jump_if_false @DANCE_17237
0004: $9534 = 10
0002: jump @DANCE_17244

:DANCE_17237
0004: $9534 = 9

:DANCE_17244
0002: jump @DANCE_17325

:DANCE_17251
00D6: if 
0022:   165.0 > $9535
004D: jump_if_false @DANCE_17318
00D6: if 
0018:   $9530 > 0
004D: jump_if_false @DANCE_17304
0004: $9534 = 16
0002: jump @DANCE_17311

:DANCE_17304
0004: $9534 = 12

:DANCE_17311
0002: jump @DANCE_17325

:DANCE_17318
0004: $9534 = 14

:DANCE_17325
0051: return
0662: printstring v$DANCE_ANIM
07B1: unknown_get_dance_track 1 store_to 13@ 13@ 13@
0663: printint ""NEXT_BEAT_NUMBER"" 13@
0051: return
004E: terminate_this_script






"
b0SQjJ34,Modlist_200804,Shikareth,XML,Monday 4th of August 2025 01:50:34 PM CDT,"<?xml version=""1.0"" encoding=""utf-8""?>
<ModList>
	<Name>tmp4d390b47</Name>
	<modIds>
		<li>brrainz.harmony</li>
		<li>mlie.modmanager</li>
		<li>ludeon.rimworld</li>
		<li>ludeon.rimworld.royalty</li>
		<li>ludeon.rimworld.ideology</li>
		<li>ludeon.rimworld.biotech</li>
		<li>ludeon.rimworld.anomaly</li>
		<li>ludeon.rimworld.odyssey</li>
		<li>adaptive.storage.framework</li>
		<li>oskarpotocki.vanillafactionsexpanded.core</li>
		<li>frozensnowfox.filthvanisheswithrainandtime</li>
		<li>brrainz.cameraplus</li>
		<li>jia.center.marker</li>
		<li>crashm.colorcodedmoodbar.11</li>
		<li>coolnether123.chronospointer</li>
		<li>syrus.colonistbaradjuster</li>
		<li>countmymods.1trickpwnyta</li>
		<li>dubwise.dubsmintminimap</li>
		<li>dubwise.dubsmintmenus</li>
		<li>nalzurin.entitycodexfixed</li>
		<li>kirisenko.textures.kirihairstyles</li>
		<li>m00nl1ght.mappreview</li>
		<li>ferny.moreorders</li>
		<li>ferny.moveyourmonolith</li>
		<li>andromeda.nicehealthtab</li>
		<li>kraxous.pawnmarker</li>
		<li>usagirei.pocketsand</li>
		<li>mastertea.randomplus</li>
		<li>chaoticenrico.researchpapers</li>
		<li>rimfridge.kv.rw</li>
		<li>crtdgd.roomqualitycolors</li>
		<li>dhultgren.smarterconstruction</li>
		<li>tradingcontrol.tad.rimworld.core</li>
		<li>visiblewealth.1trickpwnyta</li>
		<li>imranfish.xmlextensions</li>
		<li>victor.wallsaresolid</li>
		<li>fluffy.worktab</li>
		<li>co.uk.epicguru.whatsthatmod</li>
		<li>tixiv.whoshotmylegoff</li>
		<li>theocean.grudges</li>
		<li>tixiv.biocodecracker</li>
		<li>automatic.bionicicons</li>
		<li>blues.breaker</li>
		<li>kirrencooper.circuitbreakerretexture</li>
		<li>jaxe.collapser</li>
		<li>petetimessix.deathacidifiest</li>
		<li>avilmask.commonsense</li>
		<li>dracoix.doormat.r12a</li>
		<li>deadbeat.medicalcabinet</li>
		<li>superniquito.modoptionssort</li>
		<li>kaitorisenkou.modularweapons2</li>
		<li>me.customideostyle</li>
		<li>vanillaexpanded.vmemese</li>
		<li>toastyman.moreritualseats</li>
		<li>smashphil.dropspot</li>
		<li>buhgunger.wallmountedfirefoampopper</li>
		<li>exploriters.siiftun1857.launchintoemptyspace</li>
		<li>nozome.mapmodeframework</li>
		<li>mehni.pickupandhaul</li>
		<li>lotusland.weaponupgrade</li>
		<li>lke.applypressure</li>
		<li>lingluo.pawncuter</li>
		<li>zal.statueofanimal</li>
		<li>vanillaexpanded.vfecore</li>
		<li>vanillaexpanded.vfearchitect</li>
		<li>vanillaexpanded.vfeart</li>
		<li>vanillaexpanded.vfepropsanddecor</li>
		<li>vanillaexpanded.vfefarming</li>
		<li>vanillaexpanded.vfemedical</li>
		<li>vanillaexpanded.vfepower</li>
		<li>vanillaexpanded.vfeproduction</li>
		<li>vanillaexpanded.vfespacer</li>
		<li>sbz.neatstorage</li>
		<li>rebuild.cotr.doorsandcorners</li>
		<li>rebuild.embrasures</li>
		<li>vanillaexpanded.vieat</li>
		<li>vanillaexpanded.ideo.dryads</li>
		<li>vanillaexpanded.viehar</li>
		<li>vanillaexpanded.ideo.iconsandsymbols</li>
		<li>vanillaexpanded.ideo.relicsandartifacts</li>
		<li>vanillaexpanded.ideo.sophianstyle</li>
		<li>vanillaexpanded.viesas</li>
	</modIds>
	<modNames>
		<li>Harmony</li>
		<li>Mod Manager (Continued)</li>
		<li>Core</li>
		<li>Royalty</li>
		<li>Ideology</li>
		<li>Biotech</li>
		<li>Anomaly</li>
		<li>Odyssey</li>
		<li>Adaptive Storage Framework</li>
		<li>Vanilla Expanded Framework</li>
		<li>[FSF] Filth Vanishes With Rain And Time</li>
		<li>Camera+</li>
		<li>Center Marker</li>
		<li>CM Color Coded Mood Bar [1.1+]</li>
		<li>Chronos Pointer - Schedule Menu Enhancement</li>
		<li>Colonist Bar Adjuster</li>
		<li>Count My Mods</li>
		<li>Dubs Mint Minimap</li>
		<li>Dubs Mint Menus</li>
		<li>Fixed! - Entity Codex</li>
		<li>Kiri Senko's Hairstyles</li>
		<li>Map Preview</li>
		<li>More Orders</li>
		<li>Move Your Monolith</li>
		<li>Nice Health Tab</li>
		<li>Pawn Marker</li>
		<li>Pocket Sand</li>
		<li>RandomPlus</li>
		<li>Research Papers</li>
		<li>RimFridge: Now with Shelves!</li>
		<li>Room Quality Colors</li>
		<li>Smarter Construction</li>
		<li>Trading Control</li>
		<li>Visible Wealth</li>
		<li>XML Extensions</li>
		<li>Walls are solid</li>
		<li>Work Tab</li>
		<li>What's That Mod</li>
		<li>Who shot my leg off?</li>
		<li>Grudges!</li>
		<li>Biocode Cracker</li>
		<li>Bionic icons</li>
		<li>Circuit Breaker</li>
		<li>Circuit Breaker Retexture</li>
		<li>Collapser</li>
		<li>Death Acidifiest</li>
		<li>Common Sense</li>
		<li>Door Mat</li>
		<li>Medical Cabinet</li>
		<li>Mod Options Sort</li>
		<li>ModularWeapons 2</li>
		<li>Monastic Ideology Style</li>
		<li>Vanilla Ideology Expanded - Memes and Structures</li>
		<li>More Ritual Seats</li>
		<li>Trade Ships Drop Spot</li>
		<li>Wall Mounted Firefoam</li>
		<li>Launch into empty space</li>
		<li>Map Mode Framework</li>
		<li>Pick Up And Haul</li>
		<li>Weapon Upgrade</li>
		<li>ApplyPressure</li>
		<li>Auto Dissector</li>
		<li>Statue of Animal (Continued)</li>
		<li>Vanilla Furniture Expanded</li>
		<li>Vanilla Furniture Expanded - Architect</li>
		<li>Vanilla Furniture Expanded - Art</li>
		<li>Vanilla Furniture Expanded - Props and Decor</li>
		<li>Vanilla Furniture Expanded - Farming</li>
		<li>Vanilla Furniture Expanded - Medical Module</li>
		<li>Vanilla Furniture Expanded - Power</li>
		<li>Vanilla Furniture Expanded - Production</li>
		<li>Vanilla Furniture Expanded - Spacer Module</li>
		<li>[sbz] Neat Storage</li>
		<li>ReBuild: Doors and Corners</li>
		<li>Rebuild: Embrasures</li>
		<li>Vanilla Ideology Expanded - Anima Theme</li>
		<li>Vanilla Ideology Expanded - Dryads</li>
		<li>Vanilla Ideology Expanded - Hats and Rags</li>
		<li>Vanilla Ideology Expanded - Icons and Symbols</li>
		<li>Vanilla Ideology Expanded - Relics and Artifacts</li>
		<li>Vanilla Ideology Expanded - Sophian Style</li>
		<li>Vanilla Ideology Expanded - Splits and Schisms</li>
	</modNames>
	<modSteamWorkshopIds>
		<li>2009463077</li>
		<li>3306654341</li>
		<li>0</li>
		<li>0</li>
		<li>0</li>
		<li>0</li>
		<li>0</li>
		<li>0</li>
		<li>3033901359</li>
		<li>2023507013</li>
		<li>1508341791</li>
		<li>867467808</li>
		<li>3460401995</li>
		<li>2006605356</li>
		<li>3408065390</li>
		<li>2673413930</li>
		<li>3353974251</li>
		<li>1662119905</li>
		<li>1446523594</li>
		<li>3392453152</li>
		<li>3446262215</li>
		<li>2800857642</li>
		<li>3462617228</li>
		<li>3221480525</li>
		<li>3328729902</li>
		<li>3438560816</li>
		<li>2226330302</li>
		<li>1434137894</li>
		<li>3492739424</li>
		<li>2898411376</li>
		<li>3407965871</li>
		<li>2202185773</li>
		<li>2007107588</li>
		<li>3461137081</li>
		<li>2574315206</li>
		<li>2896548513</li>
		<li>3453549086</li>
		<li>2258431182</li>
		<li>3491552121</li>
		<li>3491693870</li>
		<li>3453757175</li>
		<li>1677616980</li>
		<li>3367738537</li>
		<li>3369617480</li>
		<li>1499847220</li>
		<li>2835241835</li>
		<li>1561769193</li>
		<li>1505423207</li>
		<li>3530475266</li>
		<li>2910865748</li>
		<li>3497834944</li>
		<li>3487031024</li>
		<li>2636329500</li>
		<li>3411913071</li>
		<li>1969732297</li>
		<li>3452778089</li>
		<li>3532333408</li>
		<li>3296654393</li>
		<li>1279012058</li>
		<li>3395769930</li>
		<li>3293665943</li>
		<li>3438175685</li>
		<li>3407427159</li>
		<li>1718190143</li>
		<li>2608762624</li>
		<li>1968134023</li>
		<li>2102143149</li>
		<li>1957158779</li>
		<li>1718191613</li>
		<li>2062943477</li>
		<li>1880253632</li>
		<li>2028381079</li>
		<li>3416243474</li>
		<li>3262718980</li>
		<li>3500482839</li>
		<li>2666998627</li>
		<li>2720631512</li>
		<li>2567387768</li>
		<li>2552609458</li>
		<li>2564895018</li>
		<li>3194606539</li>
		<li>2573138902</li>
	</modSteamWorkshopIds>
</ModList>"
QvnurCY7,new 11,Doremon1Q12,C,Monday 4th of August 2025 01:14:33 PM CDT,"#1 Simple Calculator

#include<stdio.h> #include<stdlib.h> void main( )
{
int a, b, res; char op;
printf(“\n Enter a simple arithmetic expression”); scanf(“%d %c %d”, &a, &op, &b);
switch(op)
{
case ‘+’: res = a + b;
break; case ‘-’: res = a - b;
break; case ‘*’: res = a * b;
break; case ‘/’: if(b!=0)
res = a / b;
 
else
 

{
printf(“division by zero is not possible”); exit(0);
}
 
break;
case %’: if(b!=0)
res = a % b;
				else
				{
printf(“division by zero is not possible”); exit(0);
}
break;
default: printf(“illegal operator”); exit(0);
}
printf(“\n %d %c %d = %d”, a, op ,b, res); 
}

# 2. Quadratic roots

#include<stdio.h> #include<stdlib.h> #include<math.h> int main( )
{
float a, b, c, d, root1, root2, real, imag; printf(“Enter the three coefficients:\n”); scanf(“%f %f %f”, &a, &b, &c);
if(a = = 0)
{
printf(“Invalid coefficients”); exit(0);
}
d = (b * b) - (4 * a * c); if(d > 0)
{
root1= (-b + (sqrt(d))) / (2.0 * a);
root2 = (-b - (sqrt(d))) / (2.0 * a); printf(“The roots are real and distinct	\n”);
printf(“root1=%f \n root2=%f \n”, root1, root2);
}
else if(d = = 0)
{
}
else
{

} 
root1= root2 = -b / (2.0 * a);
printf(“The roots are real and equal	\n”);
printf(“root1 = %f \n root2 = %f \n”,root1, root2);



real = -b / (2.0 * a);
imag = sqrt(fabs(d)) / (2.0 * a);
printf(“The roots are complex and imaginary	\n”);
printf(“root1 = %f + i %f \n root2 = %f - i %f”,real, imag, real, imag);
 
return 0;
}


#3 Electricty bill

#include<stdio.h> 
int main( )
{
	char name[20]; 
	int units;
	float rupees=0;
	printf(""\n enter the name of the user :"");
             gets(name);     
     	printf(""\n enter number of units consumed :""); 
	scanf(""%d"",&units);
if(units<=200)
	rupees=units*0.80+100;  
else if(units<=300 && units>200)
	     rupees=200*0.80+(units-200)*0.90+100;
else
        rupees=200*0.80+100*0.90+(units-300)*1.00+100; 
if(rupees>400)
	rupees=rupees+0.15*rupees;
printf(""%s has to pay rupees %f"",name,rupees);
}

#4 Taylor series

#include<stdio.h>
#include<math.h> #define PI 3.142 int main( )
{
int i,degree; 
float x,sum=0,term,nume,deno; printf(“enter the value of degree”); scanf(“%d”,&degree);
x=degree * (PI/180); nume=x;
deno=1; i=2;
do
{
term = nume/deno; nume = - nume*x*x; deno = deno*i*(i+1);
 sum = sum+term;
 i=i+2;
}while(fabs(term)>=0.00001);                                        printf(“\nThe   sine   of   %d   is   %f”,degree,sum); printf(“\nThe sine function of %d is %f using library function”,degree,sin(x)); return 0;
}


#5 Bubble sort

#include<stdio.h> int main( )
{
int n,i,j,a[10],temp;  
printf(“\n enter the number of elements”); scanf(“%d”,&n);              printf(“Enter the array elements\n”); for(i=0;i<n;i++)
{
scanf(“%d”,&a[i]);
}
printf(“Original elements are \n”); for(i=0;i<n;i++)
{
printf(“%d\t”,a[i]);
}
for(i=0;i<n-1;i++)
{
for(j=0;j<n-1-i;j++)
if(a[j]<a[j+1])
{
temp=a[j]; a[j]=a[j+1]; a[j+1]=temp;
}
}
printf(“\nThe sorted elements are\n”); for(i=0;i<n;i++)
printf(“%d\n”,a[i]); return 0;
}


#6 Binary search


#include<stdio.h> #include<string.h> int main( )
{
int a[10],key;
int n,i,low,high,mid;
printf(“enter the number of numbers to read\n”); scanf(“%d”,&n);                          printf(“enter the numbers in ascending order\n”); for(i=0;i<n;i++)
scanf(“%d”,&a[i]);
printf(“enter the number to search\n”); scanf(“%d”,&key);
low=0; high=n-1;
while(low<=high)
{
mid=(low+high)/2; if(a[mid] = = key)
printf(“Element found at %d position”,mid+1;);
return 0;
else if(a[mid]<key)
low=mid+1;
 
else

}
 

high=mid-1;
 
return 0;
}


#7  String 

#include<stdio.h>
int strlength(char s[50]);
void strconcat(char s1[50],char s2[50]); 
void strcomp(char s1[10], char s2[10]);
int main()
{
char s1[50],s2[50];
int length1,length2,k; 
printf(""\n Enter the source string 1:""); 
gets(s1); 
printf(""\n Enter the source string 2:"");
gets(s2); 
length1=strlength(s1); 
length2=strlength(s2);
printf(""string length of string 1 is %d\n"",length1); 
printf("" string length of string 2 is %d\n"",length2);
strconcat(s1,s2);
strcomp(s1,s2);
}
int strlength(char s1[50])
{
int i=0;
while(s1[i]!='\0')
i++;
return i;
}
void strconcat(char s1[50],char s2[50])
{
char s3[50];
int i=0,j=0;
while(s1[i]!='\0')
{
s3[i]=s1[i];
i++;
}
while(s2[j]!='\0')
{
s3[i+j]=s2[j];
j++;
}
s3[i+j]='\0';
 printf(""string concatenation : %s\n"",s3);
}
void strcomp(char s1[10], char s2[10])
{
int i=0;
while(s1[i]==s2[i] && s1[i]!='\0' && s2[i]!='\0')
{
i++;
}
if(s1[i]=='\0'&& s2[i]=='\0')
printf(""strings are same"");
else
printf(""strings are different"");
}


#8 Standerd DEv

#include<stdio.h>
#include<math.h>
intmain()
{
float a[10],*ptr,mean,std,sum=0,sumstd=0;
intn,i; 
printf(“\n Enter the number of elements”);
scanf(“%d”,&n); 
printf(‘\n Enter the array elements”);
for(i=0;i<n;i++)
{
scanf(‘%f”,&a[i]);
}
ptr=a;
for(i=0;i<n;i++)
{
sum=sum+*ptr;
ptr++;
}
mean=sum/n;
ptr=a;
for(i=0;i<n;i++)
{
sumstd=sumstd+pow((*ptr-mean),2);
ptr++;
}
std=sqrt(sumstd/n);
printf(“Sum=%f\n”,sum);
printf(“Mean=%f\n”,mean);
printf(“Standard Deviation=%f\n”,std);
return 0;
}

#9 File Handling


#include <stdio.h>

void main() 
{
    FILE *sourceFile, *targetFile;
    char sourcePath[100], targetPath[100];
    char ch;

    // Get the source file path from the user
    printf(""Enter the source file path: "");
    scanf(""%s"", sourcePath);

    // Get the target file path from the user
    printf(""Enter the target file path: "");
    scanf(""%s"", targetPath);

    // Open the source file in read mode
    sourceFile = fopen(sourcePath, ""r"");

    if (sourceFile == NULL) {
        printf(""Unable to open source file.\n"");
        return 1;
    }

    // Open the target file in write mode
    targetFile = fopen(targetPath, ""w"");

    if (targetFile == NULL) {
        printf(""Unable to open target file.\n"");
        fclose(sourceFile);
        return 1;
    }

    // Copy contents from source file to target file
    while ((ch = fgetc(sourceFile)) != EOF) {
        fputc(ch, targetFile);
    }

    printf(""File copied successfully.\n"");

    // Close the files
    fclose(sourceFile);
    fclose(targetFile);

    return 0;
}


#10 Structure

#include<stdio.h> 
#include<string.h> 
struct student
{
	int rollno;
	char name[20]; 
	float marks;
};
int main()
{
int i,n;
struct student s[10]; 
float sum=0,average;
printf(""\nEnter the number of student details""); 
scanf(""%d"",&n);
for(i=0;i<n;i++)
{
printf(""\n enter roll number:""); 
scanf(""%d"",&s[i].rollno);        
printf(""\n enter student name""); 
scanf(""%s"",s[i].name);           
printf(""\n enter the marks:""); 
scanf(""%f"",&s[i].marks);
}
printf(""\nStudent details are\n""); 
printf(""\nRollno\t\tName\t\tMarks\n""); 
for(i=0;i<n;i++)
printf(""%d\t\t%s\t\t%f\n"",s[i].rollno,s[i].name,s[i].marks); 
for(i=0;i<n;i++)
sum=sum+s[i].marks; 
average=sum/n;
printf(""\nAVERAGE=%f"",average);
printf(""\n students scoring above average\n"");
for(i=0;i<n;i++)
{
	if(s[i].marks>=average)
		printf(""%s has scored above average \n"",s[i].name);
	else
		printf(""%s has scored below average "",s[i].name);
}

return 0;
}
"
yb7S1yVD,BFS,Fastrail08,C++,Monday 4th of August 2025 11:48:30 AM CDT,"#include <bits/stdc++.h>
using namespace std;

void bfs(vector<vector<int> > &adj){
    vector<int> visited(adj.size(), false);
    queue<int> q;
    
    int source = 1;
    q.push(source);
    visited[source] = true;
    
    while(!q.empty()){
        //take out the front node in queue
        int front = q.front();
        
        //pop the front
        q.pop();
        
        //print
        cout << front << "" "";
        
        for(int i = 0; i < adj[front].size(); i++){
            int node = adj[front][i];
            if(!visited[node]){
                q.push(node);
                visited[node] = true;
            }
        }
        
    }
}

int main() {
	// your code goes here
    int n, m;
    cin >> n >> m;
    
   vector<vector<int> > adj(n + 1, vector<int>());
   
   for(int i = 0; i < m; i++){
       int u, v;
       cin >> u >> v;
       adj[u].push_back(v);
       adj[v].push_back(u);
   }
   
   bfs(adj);
   
}
"
ZSxDjcjG,Publisher,fyrkantis,Lua,Monday 4th of August 2025 11:20:44 AM CDT,"PAGE_WIDTH = 25
PAGE_HEIGHT = 21

strings = require ""cc.strings""

root = fs.getDir(shell.getRunningProgram())
function toAbsolutePath(relativePath) return root..""/""..relativePath end

args = {...}

local logo_file = fs.open(""disk/logo.txt"", ""r"")--args[2]), ""r"")
logo = logo_file.readAll():gsub(""\r"", """")
logo_file.close()
text_lines = strings.wrap(logo, PAGE_WIDTH)
local lines_len = #text_lines
pages_len = 1

local text_file = fs.open(""disk/news/Nyheter_2025-08.txt"", ""r"")--args[1]), ""r"")
text = text_file.readAll():gsub(""\r"", """")
text_file.close()
for i, line in ipairs(strings.wrap(text, PAGE_WIDTH)) do
    if i % (PAGE_HEIGHT - 1) == PAGE_HEIGHT - 2 then
        if pages_len > 1 then
            lines_len = lines_len + 1
            text_lines[lines_len] = ""   -------- ""..pages_len.."" --------""
        end
        pages_len = pages_len + 1
    end
    lines_len = lines_len + 1
	text_lines[lines_len] = line
end

local redstone_file = fs.open(""redstone.txt"", ""r"")
redstone_side = redstone_file.readLine()
redstone_file.close()

monitor = peripheral.find(""monitor"")
printer = peripheral.find(""printer"")
speaker = peripheral.find(""speaker"")

page_index = 1
scroll = 0

function renderPage(monitor)
    if monitor.setTextScale ~= nil then monitor.setTextScale(0.5) end
    monitor.setBackgroundColor(colors.black)
    monitor.setTextColor(colors.white)
    monitor.clear()
    monitor.setBackgroundColor(colors.white)
    monitor.setTextColor(colors.black)
    local w, h = monitor.getSize()
    local min_x = 1 + (w - PAGE_WIDTH) / 2
	for y=1, PAGE_HEIGHT+2 do
    	monitor.setCursorPos(min_x - 1, y)
        for _=1, PAGE_WIDTH + 2 do monitor.write("" "") end
    end
    
    local page_start_index = (page_index - 1) * PAGE_HEIGHT
    for y=1, PAGE_HEIGHT do
		local line = text_lines[page_start_index + y]
		if line ~= nil then
        	monitor.setCursorPos(min_x, y + 1)
        	monitor.write(line)
		end
    end
	monitor.setBackgroundColor(colors.black)
    monitor.setTextColor(colors.white)
end
function renderMonitorButtons(monitor, buttons)
    monitor.setBackgroundColor(colors.black)
    monitor.setTextColor(colors.yellow)
    for _, button in ipairs(buttons) do
        local x, y, _w, s, _f = unpack(button)
        monitor.setCursorPos(x, y)
        monitor.write(s)
    end
    monitor.setTextColor(colors.white)
end

function renderButtons()
   	renderMonitorButtons(term, term_buttons)
    if monitor ~= nil then renderMonitorButtons(monitor, monitor_buttons) end
end
function renderPages()
    renderPage(term)
    if monitor ~= nil then renderPage(monitor) end
end
function renderPagesAndButtons()
    renderPages()
    renderButtons()
end

function previousPage()
    if page_index > 1 then
        page_index = page_index - 1
        renderPagesAndButtons()
    end
end
function nextPage()
    if page_index < pages_len then
        page_index = page_index + 1
        renderPagesAndButtons()
    end
end
function printPages()
    renderPages()
    term.setCursorPos(1, 1)
    term.write(""Printing..."")
    if monitor ~= nil then
        monitor.setCursorPos(1, 1)
        monitor.write(""Printing..."")
    end
    for i=1, pages_len do
        local page_start_index = (i - 1) * PAGE_HEIGHT
        printer.newPage()
        for y=1, PAGE_HEIGHT do
            local line = text_lines[page_start_index + y]
            if line ~= nil then
            	printer.setCursorPos(1, y)
            	printer.write(line)
            end
        end
        if i == 1 then printer.setPageTitle(""FF Nytt 2025-08"")
        else printer.setPageTitle(""FF Nytt 2025-08 (sida ""..i.."")"") end
        printer.endPage()
        if i < pages_len then
        	if speaker ~= nil then speaker.playNote(""chime"", 3, 0) end
        	sleep(0.5)
        end
    end
     if speaker ~= nil then speaker.playNote(""chime"", 3, 12) end
    renderPagesAndButtons()
end

local term_x, term_y = term.getSize()
term_buttons = {
	{1, term_y, 10, ""[Previous]"", previousPage},
    {term_x - 5, term_y, 6, ""[Next]"", nextPage},
    {term_x - 6, 1, 7, ""[Print]"", printPages},
}
if monitor ~= nil then
	local mon_x, mon_y = monitor.getSize()
	monitor_buttons = {
		{1, mon_y, 10, ""[Previous]"", previousPage},
	    {mon_x - 5, mon_y, 6, ""[Next]"", nextPage},
	}
end

renderPagesAndButtons()

function detectButton(t_x, t_y, buttons)
    for _, button in ipairs(buttons) do
        local x, y, w, _s, f = unpack(button)
        if t_y == y and t_x >= x and t_x < x + w then f() end
    end
end

while true do
    local eventData = {os.pullEvent()}
    local event = eventData[1]
    if event == ""mouse_click"" then
        local _event, _button, x, y = unpack(eventData)
        detectButton(x, y, term_buttons)
    elseif event == ""monitor_touch"" then
        local _event, _side, x, y = unpack(eventData)
        if monitor ~= nil then detectButton(x, y, monitor_buttons) end
    elseif event == ""key"" then
        local _event, key, held = unpack(eventData)
        if not held then
            if key == keys.left and page_index > 1 then previousPage()
            elseif key == keys.right and page_index < pages_len then nextPage() end
        end
    end
end"
6heix1gw,Untitled,iamrealnurs,Python,Monday 4th of August 2025 10:17:33 AM CDT,"import requests
import threading
import time
import json
import websocket  # pip install websocket-client
import random
from pprint import pprint

# 🔐 Настройки авторизации для Employee
BASE_URL_EMPLOYEE = ""http://127.0.0.1:8000/api/v1/employee_endpoints/authentication""
WS_URL = ""ws://127.0.0.1:8000/ws/notifications/""
USERNAME = ""svetlana_62""
PASSWORD = ""string""

# 🌐 Настройки API для пациента
BASE_URL_PATIENT = ""http://127.0.0.1:8000/api/v1/patients_endpoints""
AUTH_URL = f""{BASE_URL_PATIENT}/authentication""
VISIT_URL = f""{BASE_URL_PATIENT}/visits/create-visit/""
DOCTORS_URL = f""{BASE_URL_PATIENT}/city_id:1/all-doctors/""

# 👤 Тестовые пользователи
USERS = [
    {
        ""phone_number"": ""+7 (768) 045-3987"",
        ""password"": ""string"",
        ""authenticated"": True
    },
    {
        ""phone_number"": ""+7 579 730 93 15"",
        ""first_name"": ""Тест"",
        ""last_name"": ""Тестович"",
        ""authenticated"": False
    }
]

MAX_RETRIES = 3
TIMEOUT_SECONDS = 30


# 📤 Универсальный отправщик запросов
def send_request(name, url, method, data=None, headers=None):
    pprint(f""\n🟡 {name}"")
    pprint(f""➡️ URL: {url}"")
    pprint(f""➡️ Метод: {method}"")
    pprint(f""➡️ Данные: {data}"")

    request_func = requests.get if method == ""GET"" else requests.post
    headers = headers or {}

    for attempt in range(1, MAX_RETRIES + 1):
        try:
            response = request_func(url, json=data, headers=headers, timeout=TIMEOUT_SECONDS)
            pprint(f""📥 Ответ: {response.status_code} (Попытка {attempt}/{MAX_RETRIES})"")

            if response.status_code in [200, 201]:
                try:
                    return response.json()
                except Exception:
                    pprint(""⚠️ Ошибка парсинга JSON"")
                    return None
            else:
                pprint(f""❌ Ошибка: {response.text}"")
                return None
        except requests.exceptions.Timeout:
            pprint(f""⚠️ Тайм-аут (Попытка {attempt}) - ожидание 5 сек..."")
            time.sleep(5)
        except requests.exceptions.RequestException as e:
            pprint(f""❌ Ошибка соединения: {e}"")
            return None
    return None


# 🩺 Получение списка врачей
def get_doctors():
    return send_request(""📍 Получение врачей"", DOCTORS_URL, ""GET"")


# 📲 Авторизация пациента
def login(phone, password):
    data = {""phone_number"": phone, ""password"": password}
    response = send_request(""📲 Авторизация пациента"", f""{AUTH_URL}/login/"", ""POST"", data)
    return response.get(""access"") if response else None


# 👤 Получение профиля пациента
def get_profile(access_token):
    headers = {""Authorization"": f""Bearer {access_token}""}
    return send_request(""👤 Получение профиля"", f""{AUTH_URL}/me/"", ""GET"", headers=headers)


# 📝 Создание визита
def create_visit(user, doctor, procedure, clinic, visit_date, time_slot_id):
    scenario = ""Авторизованный"" if user[""authenticated""] else ""Неавторизованный""
    visit_data = {
        ""doctor_id"": doctor[""id""],
        ""procedure_id"": str(procedure[""medical_procedure_id""]),
        ""clinic_id"": int(clinic[""clinic_id""]),
        ""date"": visit_date,
        ""time_slot_id"": time_slot_id
    }

    headers = {}
    if user[""authenticated""]:
        if ""profile"" in user:
            visit_data.update({
                ""first_name"": user[""profile""][""first_name""],
                ""last_name"": user[""profile""][""last_name""],
                ""phone_number"": user[""profile""][""phone_number""]
            })
        if ""access_token"" in user:
            headers[""Authorization""] = f""Bearer {user['access_token']}""
    else:
        visit_data.update({
            ""first_name"": user[""first_name""],
            ""last_name"": user[""last_name""],
            ""phone_number"": user[""phone_number""]
        })

    pprint(f""📘 {scenario} пользователь создает визит"")
    return send_request(""📝 Создание визита"", VISIT_URL, ""POST"", visit_data, headers=headers)


# 🎧 Подключение к WebSocket для уведомлений
def listen_notifications(token):
    def on_message(ws, message):
        pprint(f""🔔 Уведомление: {message}"")

    def on_error(ws, error):
        pprint(f""❌ Ошибка WebSocket: {error}"")

    def on_close(ws, code, msg):
        pprint(""🔌 WebSocket отключен"")

    def on_open(ws):
        pprint(""🟢 WebSocket подключен"")

    ws = websocket.WebSocketApp(
        WS_URL,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close,
        on_open=on_open,
        header=[f""Authorization: Bearer {token}""]
    )
    ws.run_forever()


# 👨‍⚕️ Имитация создания визита от пациента
def simulate_patient_visit():
    doctors_data = get_doctors()
    if not doctors_data:
        return
    doctors = doctors_data.get(""results"", [])
    if not doctors:
        return

    doctor = doctors[0]
    procedures = doctor.get(""procedures"", [])
    weekly_schedule = doctor.get(""weekly_schedule"", [])
    if not procedures or not weekly_schedule:
        return

    schedule_block = weekly_schedule[0]
    schedules = schedule_block.get(""schedules"", [])
    if not schedules:
        return

    schedule = schedules[0]
    working_hours = schedule.get(""working_hours_list"", [])
    if not working_hours:
        return

    procedure = random.choice(procedures)
    time_slot = random.choice(working_hours)
    clinic = {
        ""clinic_id"": schedule[""clinic_id""],
        ""clinic_title"": schedule[""clinic_title""]
    }
    visit_date = schedule[""date""]

    user = USERS[0]
    if user[""authenticated""]:
        access_token = login(user[""phone_number""], user[""password""])
        if not access_token:
            pprint(""❌ Не удалось авторизоваться пациентом"")
            return
        user[""access_token""] = access_token
        user[""profile""] = get_profile(access_token)

    create_visit(user, doctor, procedure, clinic, visit_date, time_slot[""time_slot_id""])


# 🧑‍💼 Получение токена для сотрудника
def get_employee_token():
    login_data = {""username"": USERNAME, ""password"": PASSWORD}
    response = requests.post(f""{BASE_URL_EMPLOYEE}/login/"", json=login_data)
    return response.json().get(""access"") if response.ok else None


# 🧪 Запуск теста
if __name__ == ""__main__"":
    pprint(""🚀 Запуск теста уведомлений при создании визита"")
    token = get_employee_token()
    if not token:
        pprint(""⛔ Не удалось авторизовать сотрудника"")
        exit()

    # 🔌 Запуск WebSocket клиента
    t = threading.Thread(target=listen_notifications, args=(token,))
    t.start()

    pprint(""⏳ Ждем 10 секунд перед созданием визита пациентом..."")
    time.sleep(10)

    # 🧑‍⚕️ Создание визита пациентом
    simulate_patient_visit()

    time.sleep(10)  # Подождать для получения уведомления
    pprint(""🏁 Тест завершен"")

"
9yBD1fnP,send php smart,MChaos,PHP,Monday 4th of August 2025 10:07:34 AM CDT,"$url = 'invoice';
            $data_send = array();
            $data_send['companyVatCode'] = $this->companyVatCode;
            $data_send['issueDate'] = date('Y-m-d');
            $data_send['seriesName'] = 'RO-SRV';

            $amount = number_format((int)$order['amount'] / 1.21, 2);

            if ($user_info['judet'] == 'Bucureşti'){
                $sector = ', '.$user_info['sector'];
            } else {
                $sector = '';
            }
            if ($user_info['legal'] == 1) {
                $data_send['client'] = array(
                    'name' => transliteration_text($user_info['companiei']),
                    ""vatCode"" => $user_info['CUI'],
                    'address' => transliteration_text($user_info['address']),
                    'email' => $user_info['email'],
                    'country' => ""Romania"",
                    'county' => transliteration_text($user_info['judet']),
                    'city' => transliteration_text($user_info['city']),
                    'phone' => $user_info['phone'],
                    ""isTaxPayer"" => true
                );
            } else {
                $data_send['client'] = array(
                    'name' => transliteration_text($user_info['name']),
                    'email' => $user_info['email'],
                    'address' => transliteration_text($user_info['address']),
                    'country' => ""Romania"",
                    'county' => transliteration_text($user_info['judet']),
                    'city' => transliteration_text($user_info['city']),
                    'phone' => $user_info['phone'],
                    'vatCode' => ""-"",
                    ""isTaxPayer"" => false
                );
 
            }

            $data_send['products'][] = array(
                ""name"" => 'Plata pentru serviciile de acces la stații de alimentare a bateriilor  vehiculelor electrice',
                ""code"" => 1,
                ""measuringUnitName"" => ""buc"",
                ""currency"" => ""RON"",
                ""quantity"" => 1,
                ""price"" => $amount,
                ""taxPercentage"" => 21
            );

            $json_send = json_encode($data_send);

            $response = $this->curl_init($url, 'POST', $json_send);"
sZXbBV6L,Untitled,Noalj,Python,Monday 4th of August 2025 10:01:53 AM CDT,"import random, requests,sys,time

from user_agent import generate_user_agent as gg
chart = '.qwertyuio.pa.sd_fghj_klzx.cv_bnm1234567890_'
rq = requests.session()
Y = '\033[1;33m' #اصفر
G = '\033[2;32m' #اخضر
B = '\033[2;34m'#ازرق
W  = ""\033[1;97m"" #ابيض
C  = '\033[2;36m'#سمائي
R = '\033[1;31m' #احمر
G2 = '\033[1;90m'  #رمادي

btn = ''
if btn == '':
    while True:
        user = str(''.join((random.choice(chart) for _ in range(5))))
        trl = f""https://www.tiktok.com/@{user}?""
        hdr = {'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9', 
         'User-Agent':gg(), 
         'Connection':'close', 
         'Host':'www.tiktok.com', 
         'Accept-Encoding':'gzip, deflate', 
         'Cache-Control':'max-age=0'}
        rqs = rq.get(trl, headers=hdr).status_code
        if rqs == 404:
            print(f'{G2}[{G}+{G2}] {Y}=>  {G}' + user)
            bot = f""https://api.telegram.org/bot{T}/sendMessage?chat_id={I}&text=TikTok user: {user}\n by @s7_bb""
            rq.get(bot)
        else:
            print(f'{G2}[{R}-{G2}] {Y}=>  {R}' + user)"
CY09Bf0M,Untitled,Noalj,Python,Monday 4th of August 2025 10:00:20 AM CDT,"Y = '\033[1;33m'  # اصفر
G = '\033[2;32m'  # اخضر
B = '\033[2;34m'  # ازرق
W = ""\033[1;97m""  # ابيض
C = '\033[2;36m'  # سمائي
R = '\033[1;31m'  # احمر
G2 = '\033[1;90m'  # رمادي
P = '\033[1;35m'  # بنفسجي

import random
import requests
import string
import time
import concurrent.futures
import threading
import queue

# إعدادات البوت المحددة
TOKEN = ""8202203541:AAGmN9EZqn6hSWSh2orVJR-MSz5_0mjiBhc""
CHAT_ID = ""1167681002""

# تعريف المجموعات
LETTERS = string.ascii_lowercase  # الحروف الصغيرة (a-z)
DIGITS = string.digits  # الأرقام (0-9)
UNDERSCORE = '_'
ALL_CHARS = LETTERS + DIGITS + UNDERSCORE  # كل الأحرف المسموحة

# قائمة بالكلمات المميزة القصيرة (5 أحرف)
SPECIAL_WORDS = [
    ""king"", ""star"", ""boss"", ""cool"", ""love"", ""gold"", ""dark"", ""soul"", ""moon"", ""sun"",
    ""lion"", ""wolf"", ""fire"", ""ice"", ""snow"", ""rain"", ""wind"", ""sky"", ""sea"", ""fish"",
    ""bird"", ""bear"", ""cat"", ""dog"", ""god"", ""vip"", ""pro"", ""best"", ""top"", ""win"",
    ""lucky"", ""charm"", ""magic"", ""power"", ""force"", ""speed"", ""alpha"", ""beta"", ""gamma"", ""delta"",
    ""omega"", ""sigma"", ""ultra"", ""mega"", ""giga"", ""tera"", ""nova"", ""tech"", ""cyber"", ""bit"",
    ""byte"", ""code"", ""data"", ""net"", ""web"", ""ai"", ""epic"", ""rare"", ""royal"", ""elite""
]

# جلسات HTTP للتوازي
sessions = [requests.Session() for _ in range(20)]
session_lock = threading.Lock()
session_index = 0

# طابور لإرسال اليوزرات إلى البوت
telegram_queue = queue.Queue()

# إحصائيات
stats = {
    ""total_checked"": 0,
    ""available_count"": 0,
    ""fragment_blocked"": 0,
    ""sent_to_telegram"": 0,
    ""speed"": 0
}
stats_lock = threading.Lock()

# توليد يوزر مميز مكون من 5 خانات فقط
def generate_5char_username():
    # اختيار عشوائي بين عدة أنماط
    pattern = random.randint(1, 6)
    
    if pattern == 1:  # كلمات مميزة (5 أحرف)
        return random.choice(SPECIAL_WORDS)
    
    elif pattern == 2:  # حرف + رقم + حرف + رقم + حرف (a1b2c)
        return f""{random.choice(LETTERS)}{random.choice(DIGITS)}{random.choice(LETTERS)}{random.choice(DIGITS)}{random.choice(LETTERS)}""
    
    elif pattern == 3:  # حرف + حرف + رقم + رقم + حرف (ab12c)
        return f""{random.choice(LETTERS)}{random.choice(LETTERS)}{random.choice(DIGITS)}{random.choice(DIGITS)}{random.choice(LETTERS)}""
    
    elif pattern == 4:  # حرف + رقم + رقم + رقم + حرف (a123b)
        return f""{random.choice(LETTERS)}{random.choice(DIGITS)}{random.choice(DIGITS)}{random.choice(DIGITS)}{random.choice(LETTERS)}""
    
    elif pattern == 5:  # حرف + شرطة سفلية + حرف + رقم (a_b1)
        # سنضيف حرف إضافي في النهاية لتصبح 5 خانات
        return f""{random.choice(LETTERS)}_{random.choice(LETTERS)}{random.choice(DIGITS)}{random.choice(LETTERS)}""
    
    else:  # توليد عشوائي سريع (5 أحرف)
        return ''.join(random.choices(ALL_CHARS, k=5))

# التحقق من وجود اليوزر في fragment.com بسرعة
def check_fragment(username):
    global session_index
    
    with session_lock:
        session = sessions[session_index]
        session_index = (session_index + 1) % len(sessions)
    
    url = f""https://fragment.com/username/{username}""
    
    try:
        response = session.head(url, timeout=3, allow_redirects=False)
        return response.status_code != 404
    except:
        return False

# التحقق من تليجرام بسرعة
def check_telegram(username):
    global session_index
    
    with session_lock:
        session = sessions[session_index]
        session_index = (session_index + 1) % len(sessions)
    
    url = f""https://t.me/{username}""
    
    try:
        response = session.head(url, timeout=3, allow_redirects=False)
        # إذا كان اليوزر متاحاً، تليجرام يعيد 404
        return response.status_code == 404
    except:
        return False

# إرسال النتيجة إلى بوت تلغرام (وظيفة منفصلة)
def telegram_sender():
    while True:
        username = telegram_queue.get()
        if username == ""STOP"":
            break
            
        url = f""https://api.telegram.org/bot{TOKEN}/sendMessage""
        payload = {
            ""chat_id"": CHAT_ID,
            ""text"": f""✨ **يوزر مميز مكون من 5 خانات!** ✨\n\n""
                    f""👑 اليوزر: `@{username}`\n""
                    f""🔗 الرابط: https://t.me/{username}\n\n""
                    f""📅 {time.strftime('%Y-%m-%d %H:%M:%S')}\n""
                    f""#Telegram #5Chars"",
            ""parse_mode"": ""Markdown""
        }
        
        try:
            response = requests.post(url, json=payload, timeout=5)
            if response.status_code == 200:
                with stats_lock:
                    stats[""sent_to_telegram""] += 1
        except:
            pass
            
        telegram_queue.task_done()

# العملية الرئيسية للتحقق من اليوزرات
def check_username(_):
    last_time = time.time()
    count = 0
    
    while True:
        try:
            # توليد يوزر مميز من 5 خانات
            user = generate_5char_username()
            
            # تحديث الإحصائيات
            with stats_lock:
                stats[""total_checked""] += 1
                count += 1
                
            # التحقق من تليجرام
            if not check_telegram(user):
                continue
                
            # التحقق من fragment.com
            if check_fragment(user):
                with stats_lock:
                    stats[""fragment_blocked""] += 1
                continue
                
            # اليوزر متاح!
            with stats_lock:
                stats[""available_count""] += 1
                
            # إرساله إلى طابور التليجرام
            telegram_queue.put(user)
            
            # حساب السرعة كل 100 عملية
            if count >= 100:
                elapsed = time.time() - last_time
                with stats_lock:
                    stats[""speed""] = count / elapsed
                last_time = time.time()
                count = 0
                
        except Exception as e:
            continue

# وظيفة لعرض الإحصائيات
def stats_display():
    while True:
        time.sleep(1)
        with stats_lock:
            total = stats[""total_checked""]
            available = stats[""available_count""]
            fragment = stats[""fragment_blocked""]
            sent = stats[""sent_to_telegram""]
            speed = stats[""speed""]
        
        print(f""\n{P}══╣ إحصائيات يوزرات 5 خانات ╠══"")
        print(f""{W}السرعة: {G}{speed:.1f} يوزر/ثانية"")
        print(f""{W}المجموع: {G}{total}"")
        print(f""{W}المتاحة: {G}{available}"")
        print(f""{W}المحجوزة في fragment: {R}{fragment}"")
        print(f""{W}المرسلة إلى البوت: {C}{sent}"")
        print(f""{P}═══════════════════════════"")

# بدء البرنامج
def main():
    print(f""\n{P}╔═════════════════════════════════════╗"")
    print(f""{P}║   توليد يوزرات 5 خانات فائق السرعة   ║"")
    print(f""{P}╚═════════════════════════════════════╝"")
    print(f""{W}تم تطوير الأداة بواسطة @S7_Bb\n"")
    print(f""{G2}Token: {W}{TOKEN}"")
    print(f""{G2}Chat ID: {W}{CHAT_ID}\n"")
    print(f""{C}┌{'─'*45}┐"")
    print(f""{C}│ {W}يتم توليد يوزرات مميزة من 5 خانات فقط بسرعة عالية {C}│"")
    print(f""{C}└{'─'*45}┘\n"")
    
    # بدء خيط إرسال التليجرام
    threading.Thread(target=telegram_sender, daemon=True).start()
    
    # بدء خيط عرض الإحصائيات
    threading.Thread(target=stats_display, daemon=True).start()
    
    # استخدام كل أنوية المعالج للتحقق
    workers = 100  # عدد كبير من العمال للسرعة القصوى
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=workers) as executor:
        executor.map(check_username, range(workers))
    
    # إبقاء البرنامج يعمل
    while True:
        time.sleep(1)

if __name__ == ""__main__"":
    main()"
zWL7ZT8r,Esempio presentazione beamer,pfizerpflanze,Latex,Monday 4th of August 2025 09:57:57 AM CDT,"\documentclass[aspectratio=43,xcolor=dvipsnames]{beamer}
\usepackage[italian]{babel}
\definecolor{unired}{HTML}{9B0014} % forse serve xcolor
\beamertemplatenavigationsymbolsempty
\usetheme{Berlin} % Antibes, Darmstadt, JuanLesPins, CambridgeUS, ecc.
\usecolortheme[named=unired]{structure}

% ... continua preambolo con i pacchetti che ti servono

% un po' 
% nelle parentesi quadre è un'abbreviazione che viene mostrata nelle eventuali intestazioni/piè di pagina

\title[Anomaly Detection in Time Series with the Prophet Model]{\Large\bfseries Anomaly Detection in Time Series\\ with the Prophet Model}
\subtitle{\normalfont\small Discussione relazione finale
}
% \subtitle{Discussione di tesi triennale in Statistica per le Tecnologie e le Scienze}
\author[Giovanni Zedda]{Laureando: Giovanni Zedda (matricola 20828879)}
\titlegraphic{\includegraphics[width=2cm]{logo-unipd2.png}}
\institute[Università degli Studi di Padova]
{  
    \normalsize Università degli Studi di Padova \\
    Dipartimento di Scienze Statistiche \\
    \small Corso di Laurea Triennale in
    Statistica per le Tecnologie e le Scienze % Your institution for the title page
}
\date[A.A. 2024/25]{\small Anno Accademico 2024/2025} % Date, can be changed to a custom date


\begin{document}
% Slide personalizzata del titolo
\begin{frame}[label=cover, plain]
    \centering
  % Logo in alto
  % Titolo in un box colorato
  \begin{beamercolorbox}[rounded=true, shadow=true, center, wd=\textwidth]{title}
    \usebeamerfont{title}%
    {\color{white}\inserttitle}\\[0.2cm]
    \usebeamerfont{subtitle}%
    {\normalsize Discussione relazione finale}
  \end{beamercolorbox}
    \vspace{0.75em}
    \includegraphics[width=0.2\textwidth]{logo-unipd2.png}
  \vspace{0.75em}

  % Autore
  {\large\textbf{Giovanni Zedda}} \\[1em]
  {\small Corso di Laurea Triennale in Statistica per le Tecnologie e le Scienze} \\[0.2em]
  {Dipartimento di Scienze Statistiche} \\[1em]

  % Relatori incolonnati
  \begin{columns}[t]
    \column{0.45\textwidth}
    \raggedright
    \textbf{Relatore}\\
    Prof. Matteo Ceccarello

    \column{0.45\textwidth}
    \raggedleft
    %\textbf{Correlatore:}\\
    %Prof. Nome Correlatore
  \end{columns}

  \vfill
  {\small A.A. 2024/25}
\end{frame}

\begin{frame}{Sommario}
    % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation
    \tableofcontents
\end{frame}

%------------------------------------------------
\section[abbreviazione]{Statistica bayesiana}
%------------------------------------------------

\begin{frame}{Due approcci alla statistica}
\begin{columns}[t]
    \column{0.45\textwidth}
    \textbf{Approccio frequentista}
    \begin{itemize}
        \item La probabilità è un limite di una frequenza relativa.
        \item \uline{Il parametro è ignoto, ma ha un unico valore.}
        \item Stimatori, intervalli di confidenza e test statistici.
        \item Massima verosimiglianza e altri metodi.
    \end{itemize}
    \column{0.45\textwidth}
    \textbf{Approccio bayesiano}
    \begin{itemize}
        \item La probabilità è un grado di fiducia.
        \item \uline{Il parametro è una variabile casuale.}
        \item Intervalli \emph{di credibilità}.
        \item No test statistici tradizionali.
        \item Distribuzione \emph{a posteriori} del parametro con il teorema di Bayes.
    \end{itemize}
    
\end{columns}
\end{frame}

% ...

\end{document}
"
3tWU5S7V,Sensor Publisher rev_03,pleasedontcode,Arduino,Monday 4th of August 2025 09:11:21 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Sensor Publisher
	- Source Code NOT compiled for: Arduino Nano ESP32
	- Source Code created on: 2025-08-04 14:11:00

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Enviar los datos del sensor DHT22 (temperatura y */
	/* humedad) y MAX30100 (frecuencia cardíaca y SpO2) */
	/* mediante MQTT usando la librería PubSubClient en */
	/* un Arduino Nano ESP32 conectado a los componentes */
	/* listados. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
#include <WiFi.h>
#include <PubSubClient.h>
#include <DHT.h>
#include <Ultrasonic.h>
//#include <MAX30100.h> // Uncomment if MAX30100 library is available

/****** WIFI AND MQTT CONFIGURATION *****/
const char* ssid = ""YOUR_SSID"";
const char* password = ""YOUR_PASSWORD"";
const char* mqtt_server = ""YOUR_MQTT_BROKER_IP"";

WiFiClient espClient;
PubSubClient client(espClient);

/****** SENSOR PINS AND INSTANCES *****/
const uint8_t temphum_DHT22_DOUT_PIN_D2 = 2;
const uint8_t Distancia_HC_SR04_Echo_PIN_D5 = 5;
const uint8_t Distancia_HC_SR04_Trigger_PIN_D4 = 4;

DHT dht(temphum_DHT22_DOUT_PIN_D2, DHT22);

// Placeholder variables for MAX30100 sensor data
float heartRate = 0.0;
float SpO2 = 0.0;

/****** Ultrasonic Sensor Instance *****/
Ultrasonic ultrasonic(Distancia_HC_SR04_Trigger_PIN_D4, Distancia_HC_SR04_Echo_PIN_D5);

/****** Function Prototypes *****/
void setup_wifi();
void reconnect();
void setup(void);
void loop(void);
void publishSensorData();

void setup() {
  // Initialize serial communication
  Serial.begin(9600);

  // Initialize sensors
  pinMode(Distancia_HC_SR04_Trigger_PIN_D4, OUTPUT);
  pinMode(Distancia_HC_SR04_Echo_PIN_D5, INPUT_PULLUP);
  pinMode(temphum_DHT22_DOUT_PIN_D2, INPUT_PULLUP);
  dht.begin();

  // Connect to WiFi
  setup_wifi();

  // Setup MQTT server
  client.setServer(mqtt_server, 1883);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  publishSensorData();

  delay(2000); // Delay between readings
}

void setup_wifi() {
  delay(10);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }
  Serial.println(""WiFi connected"");
}

void reconnect() {
  while (!client.connected()) {
    if (client.connect(""ESP32Client"")) {
      // Connected
    } else {
      delay(5000);
    }
  }
}

void publishSensorData() {
  // Read DHT22 temperature and humidity
  float temperature = dht.readTemperature();
  float humidity = dht.readHumidity();

  // Check if reads are valid
  if (isnan(temperature) || isnan(humidity)) {
    Serial.println(""Failed to read DHT22 sensor"");
    return;
  }

  // Read ultrasonic distance in centimeters
  float distance_cm = ultrasonic.read();

  // Placeholder: Read MAX30100 sensor data
  // Replace with actual MAX30100 library calls
  // e.g., heartRate = max30100.getHeartRate();
  //       SpO2 = max30100.getSpO2();
  heartRate = 75.0; // Example value
  SpO2 = 98.0;      // Example value

  // Publish DHT22 data
  char tempStr[8];
  dtostrf(temperature, 6, 2, tempStr);
  client.publish(""sensor/dht/temperature"", tempStr);

  char humStr[8];
  dtostrf(humidity, 6, 2, humStr);
  client.publish(""sensor/dht/humidity"", humStr);

  // Publish MAX30100 data
  char hrStr[8];
  dtostrf(heartRate, 6, 2, hrStr);
  client.publish(""sensor/max30100/heart_rate"", hrStr);

  char spo2Str[8];
  dtostrf(SpO2, 6, 2, spo2Str);
  client.publish(""sensor/max30100/spo2"", spo2Str);

  // Publish ultrasonic distance
  char distStr[8];
  dtostrf(distance_cm, 6, 2, distStr);
  client.publish(""sensor/ultrasonic/distance_cm"", distStr);
}
"
LZqXi4nA,Sensor Publisher rev_03,pleasedontcode,Arduino,Monday 4th of August 2025 08:43:19 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Sensor Publisher
	- Source Code NOT compiled for: Arduino Nano ESP32
	- Source Code created on: 2025-08-04 13:43:02

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Publicar las variables de temperatura y humedad en */
	/* formato JSON mediante MQTT, usando la librería DHT */
	/* y el pin D2 del Arduino Nano ESP32. */
/****** SYSTEM REQUIREMENT 2 *****/
	/* Ensure MQTT publishes temperature and humidity in */
	/* JSON format using the DHT sensor on pin D2 of the */
	/* Arduino Nano ESP32, with WiFi connectivity for */
	/* real-time data transmission. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
#include <DHT.h>                 // https://github.com/adafruit/DHT-sensor-library
#include <WiFi.h>                // WiFi library for ESP32
#include <PubSubClient.h>        // MQTT client library

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void reconnectMQTT(void);
void publishSensorData(void);

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t TempHum_DHT22_DOUT_PIN_D2 = 2;

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
DHT dht(TempHum_DHT22_DOUT_PIN_D2, DHT22);

// WiFi credentials
const char* ssid = ""your_SSID"";             // Replace with your WiFi SSID
const char* password = ""your_PASSWORD"";     // Replace with your WiFi password

// MQTT broker details
const char* mqtt_server = ""broker.hivemq.com""; // Replace with your MQTT broker address
const int mqtt_port = 1883;                     // MQTT port
const char* mqtt_topic = ""sensor/temperature_humidity""; // MQTT topic

WiFiClient espClient;
PubSubClient client(espClient);

unsigned long lastPublishTime = 0;
const unsigned long publishInterval = 5000; // Publish every 5 seconds

void setup(void)
{
  // Initialize serial communication
  Serial.begin(9600);

  // Initialize DHT sensor
  dht.begin();

  // Configure WiFi connection
  WiFi.begin(ssid, password);
  Serial.print(""Connecting to WiFi"");
  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    Serial.print(""."");
  }
  Serial.println(""\nWiFi connected"");

  // Configure MQTT server
  client.setServer(mqtt_server, mqtt_port);
}

void loop(void)
{
  if (!client.connected())
  {
    reconnectMQTT();
  }
  client.loop();

  unsigned long currentMillis = millis();
  if (currentMillis - lastPublishTime >= publishInterval)
  {
    lastPublishTime = currentMillis;
    publishSensorData();
  }
}

void reconnectMQTT()
{
  // Loop until reconnected
  while (!client.connected())
  {
    Serial.print(""Attempting MQTT connection..."");
    // Create a client ID
    String clientId = ""ESP32Client-"";
    clientId += String(random(0xffff), HEX);
    // Attempt to connect
    if (client.connect(clientId.c_str()))
    {
      Serial.println(""connected"");
    }
    else
    {
      Serial.print(""failed, rc="");
      Serial.print(client.state());
      Serial.println("" try again in 5 seconds"");
      delay(5000);
    }
  }
}

void publishSensorData()
{
  // Read temperature and humidity
  float humidity = dht.readHumidity();
  float temperature = dht.readTemperature();

  // Check if reads are valid
  if (isnan(humidity) || isnan(temperature))
  {
    Serial.println(""Failed to read from DHT sensor"");
    return;
  }

  // Create JSON payload
  String payload = ""{"";
  payload += ""\""temperature\"": "" + String(temperature, 2) + "","";
  payload += ""\""humidity\"": "" + String(humidity, 2);
  payload += ""}"";

  // Publish JSON payload
  if (client.publish(mqtt_topic, payload.c_str()))
  {
    Serial.println(""Published data: "" + payload);
  }
  else
  {
    Serial.println(""Failed to publish data"");
  }
}
"
yVTZGhLn,Sensor Publisher rev_02,pleasedontcode,Arduino,Monday 4th of August 2025 08:34:12 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Sensor Publisher
	- Source Code NOT compiled for: Arduino Nano ESP32
	- Source Code created on: 2025-08-04 13:33:56

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Publicar las variables de temperatura y humedad en */
	/* formato JSON mediante MQTT, usando la librería DHT */
	/* y el pin D2 del Arduino Nano ESP32. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
#include <DHT.h>  // https://github.com/adafruit/DHT-sensor-library

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void publishSensorData(float temperature, float humidity);

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t TempHum_DHT22_DOUT_PIN_D2 = 2;

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
DHT dht(TempHum_DHT22_DOUT_PIN_D2, DHT22);

// Placeholder for MQTT client object
// Include your MQTT client library and instantiate the client here
// For example:
// #include <PubSubClient.h>
// WiFiClient espClient;
// PubSubClient mqttClient(espClient);

void setup(void)
{
    // put your setup code here, to run once:
    pinMode(TempHum_DHT22_DOUT_PIN_D2, INPUT_PULLUP);
    dht.begin();

    // Initialize MQTT connection here
    // For example:
    // mqttClient.setServer(mqtt_server, mqtt_port);
    // connectMQTT();
}

void loop(void)
{
    // put your main code here, to run repeatedly:
    // Read temperature and humidity
    float temperature = dht.readTemperature(); // Celsius
    float humidity = dht.readHumidity();

    // Check if any reads failed and handle errors
    if (isnan(temperature) || isnan(humidity)) {
        // Handle sensor read error
        return;
    }

    // Publish sensor data in JSON format
    publishSensorData(temperature, humidity);

    // Delay between readings, e.g., 2 seconds
    delay(2000);
}

void publishSensorData(float temperature, float humidity)
{
    // Format JSON string
    char jsonBuffer[128];
    snprintf(jsonBuffer, sizeof(jsonBuffer), ""{\""temperature\"":%.2f,\""humidity\"":%.2f}"", temperature, humidity);

    // Publish via MQTT
    // Replace 'mqttClient' with your MQTT client object
    // Example:
    // if (mqttClient.connected()) {
    //     mqttClient.publish(""sensor/data"", jsonBuffer);
    // }
    // For this example, we'll just print to Serial
    Serial.println(jsonBuffer);
}
"
WG3FpVXS,Sensor Publisher rev_02,pleasedontcode,Arduino,Monday 4th of August 2025 08:30:32 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Sensor Publisher
	- Source Code NOT compiled for: Arduino Nano ESP32
	- Source Code created on: 2025-08-04 13:28:15

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Enviar los datos del sensor DHT22 (temperatura y */
	/* humedad) y MAX30100 (frecuencia cardíaca y SpO2) */
	/* mediante MQTT usando la librería PubSubClient en */
	/* un Arduino Nano ESP32 conectado a los componentes */
	/* listados. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
#include <Wire.h>
#include <DHT.h> //https://github.com/adafruit/DHT-sensor-library
#include <MAX30100_PulseOximeter.h> //https://github.com/gabriel-milan/Arduino-MAX30100
#include <WiFi.h>
#include <PubSubClient.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void reconnect(void);
void publishSensorData(void);

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t temphum_DHT22_DOUT_PIN_D2 = 2;
const uint8_t bmp_MAX30100_INT_PIN_D3 = 3;

/***** DEFINITION OF I2C PINS *****/
const uint8_t bmp_MAX30100_I2C_PIN_SDA_A4 = A4;
const uint8_t bmp_MAX30100_I2C_PIN_SCL_A5 = A5;

/***** MQTT CONFIGURATION *****/
// Replace with your network credentials
const char* ssid = ""YOUR_SSID"";
const char* password = ""YOUR_PASSWORD"";
// Replace with your MQTT broker address
const char* mqtt_server = ""broker.hivemq.com""; // example public broker

// MQTT topics
const char* dht_temperature_topic = ""sensor/dht22/temperature"";
const char* dht_humidity_topic = ""sensor/dht22/humidity"";
const char* max30100_hr_topic = ""sensor/max30100/heart_rate"";
const char* max30100_spo2_topic = ""sensor/max30100/spo2"";

WiFiClient espClient;
PubSubClient client(espClient);

/****** LIBRARIES CLASS INSTANCES****/
DHT dht(temphum_DHT22_DOUT_PIN_D2, DHT22);
MAX30100_PulseOximeter max30100;

// Variables to hold sensor data
float dht_temperature = 0.0;
float dht_humidity = 0.0;
int max30100_heart_rate = 0;
int max30100_SpO2 = 0;

unsigned long lastPublishTime = 0;
const unsigned long publishInterval = 2000; // 2 seconds

/********* CALLBACK for MAX30100 *********/
void onBeatDetected()
{
  Serial.println(""Beat detected!"");
}

void setup()
{
  Serial.begin(115200);

  // Initialize DHT22
  dht.begin();

  // Initialize MAX30100
  pinMode(bmp_MAX30100_INT_PIN_D3, INPUT_PULLUP);
  if (!max30100.begin()) {
    Serial.println(""MAX30100 init failed"");
  } else {
    Serial.println(""MAX30100 initialized"");
  }
  max30100.setMode(MAX30100_MODE_SPO2_HR);
  max30100.setLedsCurrent(MAX30100_LED_CURR_50MA, MAX30100_LED_CURR_50MA);
  max30100.setLedsPulseWidth(MAX30100_SPC_PW_1600US_16BITS);
  max30100.setSamplingRate(MAX30100_SAMPRATE_100HZ);
  max30100.setHighresModeEnabled(true);
  max30100.setOnBeatDetectedCallback(onBeatDetected);

  // Setup WiFi
  WiFi.begin(ssid, password);
  Serial.print(""Connecting to WiFi"");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }
  Serial.println("" connected"");

  // Setup MQTT
  client.setServer(mqtt_server, 1883);
}

void loop()
{
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  unsigned long currentMillis = millis();
  if (currentMillis - lastPublishTime >= publishInterval)
  {
    // Read DHT22 sensor
    dht_temperature = dht.readTemperature();
    dht_humidity = dht.readHumidity();

    // Read MAX30100 sensor
    max30100.update();
    if (max30100.getHeartRate() > 0)
      max30100_heart_rate = max30100.getHeartRate();
    if (max30100.getSpO2() > 0)
      max30100_SpO2 = max30100.getSpO2();

    // Publish the data
    publishSensorData();

    lastPublishTime = currentMillis;
  }
}

void reconnect()
{
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print(""Attempting MQTT connection..."");
    // Create a random client ID
    String clientId = ""ESP32Client-"";
    clientId += String(random(0xffff), HEX);
    // Attempt to connect
    if (client.connect(clientId.c_str())) {
      Serial.println(""connected"");
    } else {
      Serial.print(""failed, rc="");
      Serial.print(client.state());
      Serial.println("" try again in 5 seconds"");
      delay(5000);
    }
  }
}

void publishSensorData()
{
  char buffer[10];

  // Publish DHT22 temperature
  dtostrf(dht_temperature, 4, 2, buffer);
  client.publish(dht_temperature_topic, buffer);

  // Publish DHT22 humidity
  dtostrf(dht_humidity, 4, 2, buffer);
  client.publish(dht_humidity_topic, buffer);

  // Publish MAX30100 Heart Rate
  dtostrf((float)max30100_heart_rate, 3, 0, buffer);
  client.publish(max30100_hr_topic, buffer);

  // Publish MAX30100 SpO2
  dtostrf((float)max30100_SpO2, 3, 0, buffer);
  client.publish(max30100_spo2_topic, buffer);
}
"
6YPe2Vgg,Sensor Publisher rev_01,pleasedontcode,Arduino,Monday 4th of August 2025 08:12:00 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Sensor Publisher
	- Source Code NOT compiled for: Arduino Nano ESP32
	- Source Code created on: 2025-08-04 13:11:08

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Send the MAX30100 sensor's SpO2 and heart rate */
	/* variables via MQTT to a specified broker, ensuring */
	/* data is transmitted only when new readings are */
	/* available, using the MAX30100_milan library */
	/* functions. */
/****** END SYSTEM REQUIREMENTS *****/

/* START CODE */
/****** DEFINITION OF LIBRARIES *****/
#include <Wire.h>
#include <MAX30100_milan.h>       // Using the MAX30100_milan library
#include <WiFi.h>
#include <PubSubClient.h>         // MQTT library

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void reconnect(); // MQTT reconnect function

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t BMP_MAX30100_INT_PIN_D2 = 2;

/***** DEFINITION OF I2C PINS *****/
const uint8_t BMP_MAX30100_I2C_PIN_SDA_A4 = A4;
const uint8_t BMP_MAX30100_I2C_PIN_SCL_A5 = A5;

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
MAX30100_milan max30100Sensor;  // Instantiate MAX30100 sensor object

// MQTT broker details
const char* mqtt_server = ""your.mqtt.broker.address""; // Replace with your broker address
const int mqtt_port = 1883; // Default MQTT port
const char* mqtt_user = ""your_username""; // If needed
const char* mqtt_password = ""your_password""; // If needed

WiFiClient espClient;
PubSubClient client(espClient);

// Variables to hold sensor data
volatile bool newDataAvailable = false;
uint16_t lastSpO2 = 0;
uint16_t lastHeartRate = 0;

// Callback when a beat is detected
void onBeatDetected() {
  Serial.println(""Beat detected"");
}

// Connect to WiFi network
void setup_wifi() {
  delay(10);
  Serial.println();
  Serial.print(""Connecting to WiFi..."");
  WiFi.begin(""your_SSID"", ""your_PASSWORD""); // Replace with your WiFi credentials

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }

  Serial.println(""WiFi connected"");
  Serial.print(""IP address: "");
  Serial.println(WiFi.localIP());
}

// Reconnect to MQTT broker
void reconnect() {
  // Loop until reconnected
  while (!client.connected()) {
    Serial.print(""Attempting MQTT connection..."");
    // Attempt to connect
    if (client.connect(""ESP32Client"", mqtt_user, mqtt_password)) {
      Serial.println(""connected"");
    } else {
      Serial.print(""failed, rc="");
      Serial.print(client.state());
      Serial.println("" try again in 5 seconds"");
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  pinMode(BMP_MAX30100_INT_PIN_D2, INPUT_PULLUP);

  // Initialize WiFi
  setup_wifi();

  // Initialize MQTT
  client.setServer(mqtt_server, mqtt_port);

  // Initialize MAX30100 sensor
  if (!max30100Sensor.begin()) {
    Serial.println(""Failed to initialize MAX30100 sensor"");
    while (1);
  }
  max30100Sensor.setMode(MAX30100_MODE_SPO2_HR);
  max30100Sensor.setLedsCurrent(MAX30100_LED_CURR_50MA, MAX30100_LED_CURR_50MA);
  max30100Sensor.setOnBeatDetectedCallback(onBeatDetected);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  max30100Sensor.update();

  uint16_t ir, red;
  if (max30100Sensor.getRawValues(&ir, &red)) {
    // Read SpO2 and Heart Rate
    uint16_t currentSpO2 = max30100Sensor.getSpO2();
    uint16_t currentHR = max30100Sensor.getHeartRate();

    // Check if new data is different from last sent data
    if (currentSpO2 != lastSpO2 || currentHR != lastHeartRate) {
      lastSpO2 = currentSpO2;
      lastHeartRate = currentHR;

      // Prepare JSON payload
      String payload = ""{"";
      payload += ""\""SpO2\"": "" + String(currentSpO2) + "","";
      payload += ""\""HeartRate\"": "" + String(currentHR);
      payload += ""}"";

      // Publish to MQTT topic
      if (client.publish(""sensor/heart_rate_spo2"", payload.c_str())) {
        Serial.println(""Data sent: "" + payload);
      } else {
        Serial.println(""Failed to send data"");
      }
    }
  }

  delay(100); // Adjust delay as needed
}
"
5P0HRNwk,Untitled,brunadamaceno,C,Monday 4th of August 2025 08:09:39 AM CDT,"url:https://slack.agiteste.com
email:jose.miranda2@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda3@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda4@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda5@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda6@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda7@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda8@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda9@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda10@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda11@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda12@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda13@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda14@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda15@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda16@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda17@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda18@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda19@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda20@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda21@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda22@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda23@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda24@agiteste.com
sehha:abc123

url:https://slack.agiteste.com
email:jose.miranda25@agiteste.com
sehha:abc123"
z0P2ihAW,BlocSelector example,hottabych,Dart,Monday 4th of August 2025 07:39:46 AM CDT,"import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';

/// Represents the data model for a user profile.
/// Uses Equatable for value equality comparison, which is useful for Bloc states.
class UserProfile extends Equatable {
  final String name;
  final int age;
  final bool isPremiumUser;

  const UserProfile({
    required this.name,
    required this.age,
    required this.isPremiumUser,
  });

  /// Creates a copy of this UserProfile with new values for specified properties.
  UserProfile copyWith({
    String? name,
    int? age,
    bool? isPremiumUser,
  }) {
    return UserProfile(
      name: name ?? this.name,
      age: age ?? this.age,
      isPremiumUser: isPremiumUser ?? this.isPremiumUser,
    );
  }

  @override
  List<Object> get props => [name, age, isPremiumUser];
}

/// Represents the state of the UserProfileBloc.
/// Contains the current UserProfile.
class UserProfileState extends Equatable {
  final UserProfile userProfile;

  const UserProfileState(this.userProfile);

  @override
  List<Object> get props => [userProfile];
}

/// Abstract base class for all UserProfile events.
abstract class UserProfileEvent extends Equatable {
  const UserProfileEvent();

  @override
  List<Object> get props => [];
}

/// Event to change the user's name.
class ChangeNameEvent extends UserProfileEvent {
  final String newName;
  const ChangeNameEvent(this.newName);

  @override
  List<Object> get props => [newName];
}

/// Event to increment the user's age.
class IncrementAgeEvent extends UserProfileEvent {
  const IncrementAgeEvent();
}

/// Event to toggle the user's premium status.
class TogglePremiumEvent extends UserProfileEvent {
  const TogglePremiumEvent();
}

/// Bloc responsible for managing the UserProfileState.
class UserProfileBloc extends Bloc<UserProfileEvent, UserProfileState> {
  UserProfileBloc()
      : super(
          UserProfileState(
            UserProfile(name: 'Alice Smith', age: 30, isPremiumUser: false),
          ),
        ) {
    on<ChangeNameEvent>((event, emit) {
      emit(UserProfileState(state.userProfile.copyWith(name: event.newName)));
    });

    on<IncrementAgeEvent>((event, emit) {
      emit(UserProfileState(state.userProfile.copyWith(age: state.userProfile.age + 1)));
    });

    on<TogglePremiumEvent>((event, emit) {
      emit(UserProfileState(state.userProfile.copyWith(isPremiumUser: !state.userProfile.isPremiumUser)));
    });
  }
}

void main() {
  runApp(const UserProfileApp());
}

/// The root widget of the application.
/// Provides the UserProfileBloc to its descendants using BlocProvider.
class UserProfileApp extends StatelessWidget {
  const UserProfileApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'User Profile Manager',
      theme: ThemeData(
        primarySwatch: Colors.blueGrey,
        visualDensity: VisualDensity.adaptivePlatformDensity,
        useMaterial3: true,
      ),
      home: BlocProvider<UserProfileBloc>(
        create: (context) => UserProfileBloc(),
        child: const UserProfileScreen(),
      ),
    );
  }
}

/// A screen to display and interact with a user's profile.
/// Uses BlocSelector to selectively rebuild parts of the UI based on state changes.
class UserProfileScreen extends StatelessWidget {
  const UserProfileScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('User Profile'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: <Widget>[
            // Display User Name using BlocSelector
            BlocSelector<UserProfileBloc, UserProfileState, String>(
              selector: (UserProfileState state) => state.userProfile.name,
              builder: (BuildContext context, String name) {
                // This widget rebuilds ONLY when the user's name changes.
                debugPrint('Rebuilding Name Widget: $name');
                return Card(
                  elevation: 2,
                  margin: const EdgeInsets.symmetric(vertical: 8),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Row(
                      children: <Widget>[
                        const Icon(Icons.person, color: Colors.blueGrey),
                        const SizedBox(width: 16),
                        Expanded(
                          child: Text(
                            'Name: $name',
                            style: Theme.of(context).textTheme.headlineSmall,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
            const SizedBox(height: 10),

            // Display User Age using BlocSelector
            BlocSelector<UserProfileBloc, UserProfileState, int>(
              selector: (UserProfileState state) => state.userProfile.age,
              builder: (BuildContext context, int age) {
                // This widget rebuilds ONLY when the user's age changes.
                debugPrint('Rebuilding Age Widget: $age');
                return Card(
                  elevation: 2,
                  margin: const EdgeInsets.symmetric(vertical: 8),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Row(
                      children: <Widget>[
                        const Icon(Icons.cake, color: Colors.blueGrey),
                        const SizedBox(width: 16),
                        Text(
                          'Age: $age',
                          style: Theme.of(context).textTheme.headlineSmall,
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
            const SizedBox(height: 10),

            // Display Premium Status using BlocSelector
            BlocSelector<UserProfileBloc, UserProfileState, bool>(
              selector: (UserProfileState state) => state.userProfile.isPremiumUser,
              builder: (BuildContext context, bool isPremium) {
                // This widget rebuilds ONLY when the user's premium status changes.
                debugPrint('Rebuilding Premium Status Widget: $isPremium');
                return Card(
                  elevation: 2,
                  margin: const EdgeInsets.symmetric(vertical: 8),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Row(
                      children: <Widget>[
                        Icon(
                          isPremium ? Icons.star : Icons.star_border,
                          color: isPremium ? Colors.amber : Colors.blueGrey,
                        ),
                        const SizedBox(width: 16),
                        Text(
                          'Premium User: ${isPremium ? ""Yes"" : ""No""}',
                          style: Theme.of(context).textTheme.headlineSmall,
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
            const SizedBox(height: 20),

            // Control Buttons
            Center(
              child: Column(
                children: <Widget>[
                  ElevatedButton.icon(
                    onPressed: () {
                      context.read<UserProfileBloc>().add(const ChangeNameEvent('Bob Johnson'));
                    },
                    icon: const Icon(Icons.edit),
                    label: const Text('Change Name'),
                  ),
                  const SizedBox(height: 10),
                  ElevatedButton.icon(
                    onPressed: () {
                      context.read<UserProfileBloc>().add(const IncrementAgeEvent());
                    },
                    icon: const Icon(Icons.add),
                    label: const Text('Increment Age'),
                  ),
                  const SizedBox(height: 10),
                  ElevatedButton.icon(
                    onPressed: () {
                      context.read<UserProfileBloc>().add(const TogglePremiumEvent());
                    },
                    icon: const Icon(Icons.toggle_on),
                    label: const Text('Toggle Premium Status'),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}"
i7W02vCT,Docker Unbound update script,AndrewBeasley,Bash,Monday 4th of August 2025 06:54:50 AM CDT,"# Update the DNS root servers for Unbound

BckLog=""/srv/docker/unbound/upddns.log""
cd  /srv/docker/unbound/data
curl -so root.new https://www.internic.net/domain/named.root > $BckLog 2>&1
chmod 777 root.new
rm root.old >> $BckLog 2>&1
mv root.hints root.old >> $BckLog 2>&1
mv root.new root.hints >> $BckLog 2>&1
cd ..
docker container restart unbound >> $BckLog 2>&1
"
eAqyH2FL,Untitled,retroman,FreeBasic,Monday 4th of August 2025 06:52:26 AM CDT,"#Include ""fbgfx.bi""
Using FB

ScreenRes 640, 480, 32
Const PI = 3.14159

Type Vec3D
    As Single x, y, z
End Type

' === Basic 3D rotation ===
Function RotateY(v As Vec3D, angle As Single) As Vec3D
    Dim As Vec3D o
    o.x = v.x * Cos(angle) + v.z * Sin(angle)
    o.z = -v.x * Sin(angle) + v.z * Cos(angle)
    o.y = v.y
    Return o
End Function

Function RotateX(v As Vec3D, angle As Single) As Vec3D
    Dim As Vec3D o
    o.y = v.y * Cos(angle) - v.z * Sin(angle)
    o.z = v.y * Sin(angle) + v.z * Cos(angle)
    o.x = v.x
    Return o
End Function

Function Project(v As Vec3D) As Vec3D
    Dim As Single scale = 400 / (v.z + 4)
    Dim As Vec3D o
    o.x = v.x * scale + 320
    o.y = v.y * scale + 240
    Return o
End Function

' Cube vertices
Dim Shared As Vec3D cube(0 To 7) = { _
    (-1, -1, -1), (1, -1, -1), (1, 1, -1), (-1, 1, -1), _
    (-1, -1, 1), (1, -1, 1), (1, 1, 1), (-1, 1, 1) }

Dim As Integer face(0 To 5, 0 To 3) = { _
    {0,1,2,3}, {4,5,6,7}, {0,1,5,4}, _
    {2,3,7,6}, {0,3,7,4}, {1,2,6,5} }

' Create striped background
For y As Integer = 0 To 479
    For x As Integer = 0 To 639
        If (y \ 10) Mod 2 = 0 Then
            PSet (x, y), RGB(50, 50, 50)
        Else
            PSet (x, y), RGB(120, 120, 120)
        End If
    Next
Next

' Store background
Dim As Any Ptr bg = ImageCreate(640, 480)
Get (0,0)-(639,479), bg

Dim As Single angle = 0

Do
    ScreenLock
    Put (0,0), bg, PSet

    ' Rotate + project cube
    Dim As Vec3D p(7)
    For i As Integer = 0 To 7
        Dim As Vec3D r = RotateX(cube(i), angle)
        r = RotateY(r, angle * 1.3)
        p(i) = Project(r)
    Next

    ' Draw cube faces with stealth effect
    For f As Integer = 0 To 5
        ' Backface culling
        Dim As Single ax = p(face(f,1)).x - p(face(f,0)).x
        Dim As Single ay = p(face(f,1)).y - p(face(f,0)).y
        Dim As Single bx = p(face(f,2)).x - p(face(f,1)).x
        Dim As Single by = p(face(f,2)).y - p(face(f,1)).y
        If (ax*by - ay*bx) < 0 Then Continue For

        ' Bounding box
        Dim As Integer minX = 640, minY = 480, maxX = 0, maxY = 0
        For i As Integer = 0 To 3
            Dim px as integer = CInt(p(face(f,i)).x)
            Dim py as integer = CInt(p(face(f,i)).y)
            If px < minX Then minX = px
            If px > maxX Then maxX = px
            If py < minY Then minY = py
            If py > maxY Then maxY = py
        Next

        ' Clip
        minX = IIf(minX < 0, 0, minX)
        minY = IIf(minY < 0, 0, minY)
        maxX = IIf(maxX > 639, 639, maxX)
        maxY = IIf(maxY > 479, 479, maxY)

        ' Draw distorted face
        For y As Integer = minY To maxY
            For x As Integer = minX To maxX
                ' Simple point-in-quad via winding number or barycentric test
                ' We cheat here for demo: just draw inside bbox with distortion
                Dim col as long = Point(x, y)
                Dim r as ubyte = (col Shr 16 And 255) + 30 : If r > 255 Then r = 255
                Dim g as ubyte = (col Shr 8 And 255) + 30 : If g > 255 Then g = 255
                Dim b as ubyte = (col And 255) + 30 : If b > 255 Then b = 255
                PSet (x, y), RGB(r, g, b)
            Next
        Next
    Next

    ScreenUnLock

    angle += 0.01
    Sleep 16
Loop Until InKey = Chr(27)
ImageDestroy bg
"
eneeKUGN,URVI-POST-PLI,fjaroli,JSON,Monday 4th of August 2025 06:51:40 AM CDT,"{""actor"":{""actorId"":""103241143373605156"",""actorType"":""ACTOR_TYPE.IE"",""id"":0},""appId"":""f168fef0-f3eb-4a12-addf-0d9a76d59cec"",""appMillMetadata"":{""ie_appId"":""2acdbfeb-e835-4e8e-9a78-2cd9ca6a8cde""},""id"":1624291,""ownerEntityType"":{""code"":""ENTITY_TYPE.IE"",""refClass"":{""code"":""TREF.ENTITY_TYPE""}},""owningEntityId"":""103241143373605156"",""portfolioLineItemList"":[{""appCreatedAt"":""1749717831689"",""appId"":""f0c36c5c-7ad1-4cc0-851c-27920e51e62b"",""appLastModifiedAt"":""1749717831689"",""asset"":""2acdbfeb-e835-4e8e-9a78-2cd9ca6a8cde_interior_Sheshagiri_inturi_Indira_భూమి__స్వంత_భూమి_సాగునీటి__1114749"",""createdByApp"":22099,""createdFromDevice"":""QP1A.190711.020_Xiaomi_M2006C3MII_22099"",""currentSeason"":""KHARIF_25_26_20250410"",""geoFenceAttachments"":[],""id"":0,""isActive"":true,""isEditable"":false,""isLinkedToCompactBlock"":false,""isPresentInDifferentCB"":false,""isSelected"":false,""lastModifiedByApp"":22099,""lastUpdatedFromDevice"":""QP1A.190711.020_Xiaomi_M2006C3MII_22099"",""portfolioId"":""f168fef0-f3eb-4a12-addf-0d9a76d59cec"",""portfolioLineItemType"":""PORTFOLIO_LINE_ITEM.SEASON_ACTUAL"",""portfolioProductLineItemList"":[{""actualEndDate"":""2025-06-01"",""actualStartDate"":""2025-06-01"",""appCreatedAt"":""1749717831689"",""appId"":""0b1e21b0-0cb2-4612-a46d-83c2e6521544"",""appLastModifiedAt"":""1749717831689"",""assetProportion"":{""id"":0,""uoM"":{""code"":""UOM.AREA.ACRE"",""description"":""Area in Acre"",""labels"":[],""measurementType"":{""code"":""MEASUREMENT_TYPE.AREA"",""description"":""Reference code for Area"",""globalRefClass"":{""code"":""GREF.MEASUREMENT_TYPE"",""description"":""This code represents measurement type"",""name"":""Measurement type""},""name"":""Area""},""name"":""Acre"",""symbol"":""Acre""},""value"":1.0},""createdAt"":""1747064155563"",""genericProduct"":""AP_GOV_RDS"",""id"":0,""isMajorCrop"":false,""lastModifiedAt"":""1747064155563"",""plannedEndDate"":""2025-06-01"",""plannedStartDate"":""2025-06-01"",""portfolioLineItemId"":""f0c36c5c-7ad1-4cc0-851c-27920e51e62b"",""syncStatus"":""SYNC_DONE"",""uuid"":""77931716-1d71-4a02-a637-2c94b1996ba8""}],""practiceMasterCodes"":[],""syncStatus"":""SYNC_DONE"",""titleId"":""620ac313-db98-442b-be61-b5e00ac6ca43"",""uuid"":""fb9a52e0-dbfe-4875-8931-c0a90dc251d5""}],""syncStatus"":""SYNC_DONE"",""uuid"":""2acdbfeb-e835-4e8e-9a78-2cd9ca6a8cde""}"
gKkeaw9V,Untitled,hazzyyyy,Lua,Monday 4th of August 2025 06:42:37 AM CDT,"-- search 'Exzite Scripts' on Google to find more scripts!

loadstring(game:HttpGet(""https://raw.githubusercontent.com/fuckg1thub/NeptX/refs/heads/main/Troll%20Tower%202/source""))()"
4enk4Khy,Docker Unbound,AndrewBeasley,YAML,Monday 4th of August 2025 06:39:55 AM CDT,"version: ""3""

services:
    unbound:
        image: klutchell/unbound
        container_name: unbound
        restart: unless-stopped
        volumes:
            - /srv/docker/unbound/data:/etc/unbound/custom.conf.d
        ports:
            - 53:53/tcp
            - 53:53/udp
        cap_add:
          - NET_ADMIN        
        networks:
          vlan:
            ipv4_address: 10.21.1.20

networks:
  vlan:
    driver: macvlan
    driver_opts:
      parent: eth0
    ipam:
      config:
        - subnet: ""10.21.1.0/24""
          ip_range: ""10.21.1.20/32""
          gateway: ""10.21.1.1"""
1J8Q6Kc7,2D StickPool C++ D2D (Added Hot Swappable 5 Table Colors Presets GUI !!),alien_fx_fiend,C++,Monday 4th of August 2025 05:58:15 AM CDT,"==++ Here's the full source for (file 1/3 (No OOP-based)) ""Pool-Game-CloneV18.cpp""::: ++==
```Pool-Game-CloneV18.cpp
    #define WIN32_LEAN_AND_MEAN
    #define NOMINMAX
    #include <windows.h>
    #include <d2d1.h>
    #include <dwrite.h>
    #include <fstream> // For file I/O
    #include <iostream> // For some basic I/O, though not strictly necessary for just file ops
    #include <vector>
    #include <cmath>
    #include <string>
    #include <sstream> // Required for wostringstream
    #include <algorithm> // Required for std::max, std::min
    #include <ctime>    // Required for srand, time
    #include <cstdlib> // Required for srand, rand (often included by others, but good practice)
    #include <commctrl.h> // Needed for radio buttons etc. in dialog (if using native controls)
    #include <mmsystem.h> // For PlaySound
    #include <tchar.h> //midi func
    #include <thread>
    #include <atomic>
    #include ""resource.h""

    #ifndef HAS_STD_CLAMP
    template <typename T>
    T clamp(const T& v, const T& lo, const T& hi)
    {
        return (v < lo) ? lo : (v > hi) ? hi : v;
    }
    namespace std { using ::clamp; }   // inject into std:: for seamless use
    #define HAS_STD_CLAMP
    #endif

    #pragma comment(lib, ""Comctl32.lib"") // Link against common controls library
    #pragma comment(lib, ""d2d1.lib"")
    #pragma comment(lib, ""dwrite.lib"")
    #pragma comment(lib, ""Winmm.lib"") // Link against Windows Multimedia library

    // --- Constants ---
    const float PI = 3.1415926535f;
    const float BALL_RADIUS = 10.0f;
    const float TABLE_LEFT = 100.0f;
    const float TABLE_TOP = 100.0f;
    const float TABLE_WIDTH = 700.0f;
    const float TABLE_HEIGHT = 350.0f;
    const float TABLE_RIGHT = TABLE_LEFT + TABLE_WIDTH;
    const float TABLE_BOTTOM = TABLE_TOP + TABLE_HEIGHT;
    const float CUSHION_THICKNESS = 20.0f;
    const float HOLE_VISUAL_RADIUS = 22.0f; // Visual size of the hole
    const float POCKET_RADIUS = HOLE_VISUAL_RADIUS * 1.05f; // Make detection radius slightly larger // Make detection radius match visual size (or slightly larger)
    const float MAX_SHOT_POWER = 15.0f;
    const float FRICTION = 0.985f; // Friction factor per frame
    const float MIN_VELOCITY_SQ = 0.01f * 0.01f; // Stop balls below this squared velocity
    const float HEADSTRING_X = TABLE_LEFT + TABLE_WIDTH * 0.30f; // 30% line
    const float RACK_POS_X = TABLE_LEFT + TABLE_WIDTH * 0.65f; // 65% line for rack apex
    const float RACK_POS_Y = TABLE_TOP + TABLE_HEIGHT / 2.0f;
    const UINT ID_TIMER = 1;
    const int TARGET_FPS = 60; // Target frames per second for timer

    // --- Enums ---
    // --- MODIFIED/NEW Enums ---
    enum GameState {
        SHOWING_DIALOG,     // NEW: Game is waiting for initial dialog input
        PRE_BREAK_PLACEMENT,// Player placing cue ball for break
        BREAKING,           // Player is aiming/shooting the break shot
        CHOOSING_POCKET_P1, // NEW: Player 1 needs to call a pocket for the 8-ball
        CHOOSING_POCKET_P2, // NEW: Player 2 needs to call a pocket for the 8-ball
        AIMING,             // Player is aiming
        AI_THINKING,        // NEW: AI is calculating its move
        SHOT_IN_PROGRESS,   // Balls are moving
        ASSIGNING_BALLS,    // Turn after break where ball types are assigned
        PLAYER1_TURN,
        PLAYER2_TURN,
        BALL_IN_HAND_P1,
        BALL_IN_HAND_P2,
        GAME_OVER
    };

    enum BallType {
        NONE,
        SOLID,  // Yellow (1-7)
        STRIPE, // Red (9-15)
        EIGHT_BALL, // Black (8)
        CUE_BALL // White (0)
    };

    // NEW Enums for Game Mode and AI Difficulty
    enum GameMode {
        HUMAN_VS_HUMAN,
        HUMAN_VS_AI
    };

    enum AIDifficulty {
        EASY,
        MEDIUM,
        HARD
    };

    enum OpeningBreakMode {
        CPU_BREAK,
        P1_BREAK,
        FLIP_COIN_BREAK
    };

    // NEW: Enum and arrays for table color options
    enum TableColor {
        INDIGO,
        TAN,
        TEAL,
        GREEN,
        RED        
    };

    // --- Structs ---
    struct Ball {
        int id;             // 0=Cue, 1-7=Solid, 8=Eight, 9-15=Stripe
        BallType type;
        float x, y;
        float vx, vy;
        D2D1_COLOR_F color;
        bool isPocketed;
    };

    struct PlayerInfo {
        BallType assignedType;
        int ballsPocketedCount;
        std::wstring name;
    };

    // --- Global Variables ---

    // Direct2D & DirectWrite
    ID2D1Factory* pFactory = nullptr;
    //ID2D1Factory* g_pD2DFactory = nullptr;
    ID2D1HwndRenderTarget* pRenderTarget = nullptr;
    IDWriteFactory* pDWriteFactory = nullptr;
    IDWriteTextFormat* pTextFormat = nullptr;
    IDWriteTextFormat* pLargeTextFormat = nullptr; // For ""Foul!""
    IDWriteTextFormat* pBallNumFormat = nullptr;

    // Game State
    HWND hwndMain = nullptr;
    GameState currentGameState = SHOWING_DIALOG; // Start by showing dialog
    std::vector<Ball> balls;
    int currentPlayer = 1; // 1 or 2
    PlayerInfo player1Info = { BallType::NONE, 0, L""Vince Woods""/*""Player 1""*/ };
    PlayerInfo player2Info = { BallType::NONE, 0, L""Virtus Pro""/*""CPU""*/ }; // Default P2 name
    bool foulCommitted = false;
    std::wstring gameOverMessage = L"""";
    bool firstBallPocketedAfterBreak = false;
    std::vector<int> pocketedThisTurn;
    // --- NEW: 8-Ball Pocket Call Globals ---
    int calledPocketP1 = -1; // Pocket index (0-5) called by Player 1 for the 8-ball. -1 means not called.
    int calledPocketP2 = -1; // Pocket index (0-5) called by Player 2 for the 8-ball.
    int currentlyHoveredPocket = -1; // For visual feedback on which pocket is being hovered
    std::wstring pocketCallMessage = L""""; // Message like ""Choose a pocket...""
         // --- NEW: Remember which pocket the 8?ball actually went into last shot
    int lastEightBallPocketIndex = -1;
    //int lastPocketedIndex = -1; // pocket index (0–5) of the last ball pocketed
    int called = -1;
    bool cueBallPocketed = false;

    // --- NEW: Foul Tracking Globals ---
    int firstHitBallIdThisShot = -1;      // ID of the first object ball hit by cue ball (-1 if none)
    bool cueHitObjectBallThisShot = false; // Did cue ball hit an object ball this shot?
    bool railHitAfterContact = false;     // Did any ball hit a rail AFTER cue hit an object ball?
    // --- End New Foul Tracking Globals ---

    // NEW Game Mode/AI Globals
    GameMode gameMode = HUMAN_VS_HUMAN; // Default mode
    AIDifficulty aiDifficulty = MEDIUM; // Default difficulty
    OpeningBreakMode openingBreakMode = CPU_BREAK; // Default opening break mode
    bool isPlayer2AI = false;           // Is Player 2 controlled by AI?
    bool aiTurnPending = false;         // Flag: AI needs to take its turn when possible
    // bool aiIsThinking = false;       // Replaced by AI_THINKING game state
    // NEW: Flag to indicate if the current shot is the opening break of the game
    bool isOpeningBreakShot = false;

    // NEW: For AI shot planning and visualization
    struct AIPlannedShot {
        float angle;
        float power;
        float spinX;
        float spinY;
        bool isValid; // Is there a valid shot planned?
    };
    AIPlannedShot aiPlannedShotDetails; // Stores the AI's next shot
    bool aiIsDisplayingAim = false;    // True when AI has decided a shot and is in ""display aim"" mode
    int aiAimDisplayFramesLeft = 0;  // How many frames left to display AI aim
    const int AI_AIM_DISPLAY_DURATION_FRAMES = 45; // Approx 0.75 seconds at 60 FPS, adjust as needed

    // Input & Aiming
    POINT ptMouse = { 0, 0 };
    bool isAiming = false;
    bool isDraggingCueBall = false;
    // --- ENSURE THIS LINE EXISTS HERE ---
    bool isDraggingStick = false; // True specifically when drag initiated on the stick graphic
    // --- End Ensure ---
    bool isSettingEnglish = false;
    D2D1_POINT_2F aimStartPoint = { 0, 0 };
    float cueAngle = 0.0f;
    float shotPower = 0.0f;
    float cueSpinX = 0.0f; // Range -1 to 1
    float cueSpinY = 0.0f; // Range -1 to 1
    float pocketFlashTimer = 0.0f;
    bool cheatModeEnabled = false; // Cheat Mode toggle (G key)
    int draggingBallId = -1;
    bool keyboardAimingActive = false; // NEW FLAG: true when arrow keys modify aim/power
    MCIDEVICEID midiDeviceID = 0; //midi func
    std::atomic<bool> isMusicPlaying(false); //midi func
    std::thread musicThread; //midi func
    void StartMidi(HWND hwnd, const TCHAR* midiPath);
    void StopMidi();

    // NEW: Global for selected table color and definitions
    TableColor selectedTableColor = INDIGO; // Default color
    const WCHAR * tableColorNames[] = { L""Indigo"", L""Tan"", L""Teal"", L""Green"", L""Red"" };
    const D2D1_COLOR_F tableColorValues[] = {
    D2D1::ColorF(0.05f, 0.09f, 0.28f),       // Indigo
    D2D1::ColorF(0.3529f, 0.3137f, 0.2196f), // Tan
    D2D1::ColorF(0.0f, 0.4f, 0.4392f),       // Teal
    D2D1::ColorF(0.1608f, 0.4000f, 0.1765f), // Green
    D2D1::ColorF(0.3882f, 0.1059f, 0.10196f) // Red
    };

    // UI Element Positions
    D2D1_RECT_F powerMeterRect = { TABLE_RIGHT + CUSHION_THICKNESS + 10, TABLE_TOP, TABLE_RIGHT + CUSHION_THICKNESS + 40, TABLE_BOTTOM };
    D2D1_RECT_F spinIndicatorRect = { TABLE_LEFT - CUSHION_THICKNESS - 60, TABLE_TOP + 20, TABLE_LEFT - CUSHION_THICKNESS - 20, TABLE_TOP + 60 }; // Circle area
    D2D1_POINT_2F spinIndicatorCenter = { spinIndicatorRect.left + (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f, spinIndicatorRect.top + (spinIndicatorRect.bottom - spinIndicatorRect.top) / 2.0f };
    float spinIndicatorRadius = (spinIndicatorRect.right - spinIndicatorRect.left) / 2.0f;
    D2D1_RECT_F pocketedBallsBarRect = { TABLE_LEFT, TABLE_BOTTOM + CUSHION_THICKNESS + 30, TABLE_RIGHT, TABLE_BOTTOM + CUSHION_THICKNESS + 70 };

    // Corrected Pocket Center Positions (aligned with table corners/edges)
    const D2D1_POINT_2F pocketPositions[6] = {
        {TABLE_LEFT, TABLE_TOP},                           // Top-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_TOP},      // Top-Middle
        {TABLE_RIGHT, TABLE_TOP},                          // Top-Right
        {TABLE_LEFT, TABLE_BOTTOM},                        // Bottom-Left
        {TABLE_LEFT + TABLE_WIDTH / 2.0f, TABLE_BOTTOM},   // Bottom-Middle
        {TABLE_RIGHT, TABLE_BOTTOM}                        // Bottom-Right
    };

    // Colors
    //const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.5f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f) (uncomment this l8r if needbe)
    // This is now a variable that can be changed, not a constant.
    D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.05f, 0.09f, 0.28f); // Default to Indigo
    //const D2D1_COLOR_F TABLE_COLOR = D2D1::ColorF(0.0f, 0.5f, 0.1f); // Darker Green NEWCOLOR (0.0f, 0.5f, 0.1f) => (0.1608f, 0.4000f, 0.1765f)
    /*
    MPool: *Darker tan= (0.3529f, 0.3137f, 0.2196f) *Indigo= (0.05f, 0.09f, 0.28f) xPurple= (0.1922f, 0.2941f, 0.4118f); xTan= (0.5333f, 0.4706f, 0.3569f); (Red= (0.3882f, 0.1059f, 0.10196f); *Green(default)= (0.1608f, 0.4000f, 0.1765f); *Teal= (0.0f, 0.4f, 0.4392f) + Teal40%reduction= (0.0f, 0.3333f, 0.4235f);
    Hex: Teal=#00abc2 Tan=#7c6d53 Teal2=#03adc2 xPurple=#314b69 ?Tan=#88785b Red=#631b1a
    */
    const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF(0.3608f, 0.0275f, 0.0078f)); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    //const D2D1_COLOR_F CUSHION_COLOR = D2D1::ColorF(D2D1::ColorF::Red); // NEWCOLOR ::Red => (0.3608f, 0.0275f, 0.0078f)
    const D2D1_COLOR_F POCKET_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F CUE_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::White);
    const D2D1_COLOR_F EIGHT_BALL_COLOR = D2D1::ColorF(D2D1::ColorF::Black);
    const D2D1_COLOR_F SOLID_COLOR = D2D1::ColorF(D2D1::ColorF::Goldenrod); // Solids = Yellow Goldenrod
    const D2D1_COLOR_F STRIPE_COLOR = D2D1::ColorF(D2D1::ColorF::DarkOrchid);   // Stripes = Red DarkOrchid
    const D2D1_COLOR_F AIM_LINE_COLOR = D2D1::ColorF(D2D1::ColorF::White, 0.7f); // Semi-transparent white
    const D2D1_COLOR_F FOUL_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(0.1333f, 0.7294f, 0.7490f); //NEWCOLOR 0.1333f, 0.7294f, 0.7490f => ::Blue
    //const D2D1_COLOR_F TURN_ARROW_COLOR = D2D1::ColorF(D2D1::ColorF::Blue);
    const D2D1_COLOR_F ENGLISH_DOT_COLOR = D2D1::ColorF(D2D1::ColorF::Red);
    const D2D1_COLOR_F UI_TEXT_COLOR = D2D1::ColorF(D2D1::ColorF::Black);

    // --------------------------------------------------------------------
//  Realistic colours for each id (0-15)
//  0 = cue-ball (white) | 1-7 solids | 8 = eight-ball | 9-15 stripes
// --------------------------------------------------------------------
    static const D2D1_COLOR_F BALL_COLORS[16] =
    {
        D2D1::ColorF(D2D1::ColorF::White),          // 0  cue
        D2D1::ColorF(1.00f, 0.85f, 0.00f),          // 1  yellow
        D2D1::ColorF(0.05f, 0.30f, 1.00f),          // 2  blue
        D2D1::ColorF(0.90f, 0.10f, 0.10f),          // 3  red
        D2D1::ColorF(0.55f, 0.25f, 0.85f),          // 4  purple
        D2D1::ColorF(1.00f, 0.55f, 0.00f),          // 5  orange
        D2D1::ColorF(0.00f, 0.60f, 0.30f),          // 6  green
        D2D1::ColorF(0.50f, 0.05f, 0.05f),          // 7  maroon / burgundy
        D2D1::ColorF(D2D1::ColorF::Black),          // 8  black
        D2D1::ColorF(1.00f, 0.85f, 0.00f),          // 9  (yellow stripe)
        D2D1::ColorF(0.05f, 0.30f, 1.00f),          // 10 blue stripe
        D2D1::ColorF(0.90f, 0.10f, 0.10f),          // 11 red stripe
        D2D1::ColorF(0.55f, 0.25f, 0.85f),          // 12 purple stripe
        D2D1::ColorF(1.00f, 0.55f, 0.00f),          // 13 orange stripe
        D2D1::ColorF(0.00f, 0.60f, 0.30f),          // 14 green stripe
        D2D1::ColorF(0.50f, 0.05f, 0.05f)           // 15 maroon stripe
    };

    // Quick helper
    inline D2D1_COLOR_F GetBallColor(int id)
    {
        return (id >= 0 && id < 16) ? BALL_COLORS[id]
            : D2D1::ColorF(D2D1::ColorF::White);
    }

    // --- Forward Declarations ---
    HRESULT CreateDeviceResources();
    void DiscardDeviceResources();
    void OnPaint();
    void OnResize(UINT width, UINT height);
    void InitGame();
    void GameUpdate();
    void UpdatePhysics();
    void CheckCollisions();
    bool CheckPockets(); // Returns true if any ball was pocketed
    void ProcessShotResults();
    void ApplyShot(float power, float angle, float spinX, float spinY);
    void RespawnCueBall(bool behindHeadstring);
    bool AreBallsMoving();
    void SwitchTurns();
    //bool AssignPlayerBallTypes(BallType firstPocketedType);
    bool AssignPlayerBallTypes(BallType firstPocketedType,
        bool creditShooter = true);
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed);
    Ball* GetBallById(int id);
    Ball* GetCueBall();
    //void PlayGameMusic(HWND hwnd); //midi func
    void AIBreakShot();

    // Drawing Functions
    void DrawScene(ID2D1RenderTarget* pRT);
    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory);
    void DrawBalls(ID2D1RenderTarget* pRT);
    void DrawCueStick(ID2D1RenderTarget* pRT);
    void DrawAimingAids(ID2D1RenderTarget* pRT);
    void DrawUI(ID2D1RenderTarget* pRT);
    void DrawPowerMeter(ID2D1RenderTarget* pRT);
    void DrawSpinIndicator(ID2D1RenderTarget* pRT);
    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT);
    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT);
    // NEW
    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT);

    // Helper Functions
    float GetDistance(float x1, float y1, float x2, float y2);
    float GetDistanceSq(float x1, float y1, float x2, float y2);
    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring);
    template <typename T> void SafeRelease(T** ppT);
    // --- NEW HELPER FORWARD DECLARATIONS ---
    bool IsPlayerOnEightBall(int player);
    void CheckAndTransitionToPocketChoice(int playerID);
    // --- ADD FORWARD DECLARATION FOR NEW HELPER HERE ---
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b);
    // --- End Forward Declaration ---
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection); // Keep this if present

    // --- NEW Forward Declarations ---

    // AI Related
    struct AIShotInfo; // Define below
    void TriggerAIMove();
    void AIMakeDecision();
    void AIPlaceCueBall();
    AIShotInfo AIFindBestShot();
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex);
    bool IsPathClear(D2D1_POINT_2F start, D2D1_POINT_2F end, int ignoredBallId1, int ignoredBallId2);
    Ball* FindFirstHitBall(D2D1_POINT_2F start, float angle, float& hitDistSq); // Added hitDistSq output
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist);
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex);
    bool IsValidAIAimAngle(float angle); // Basic check

    // Dialog Related
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void ShowNewGameDialog(HINSTANCE hInstance);
    void LoadSettings(); // For deserialization
    void SaveSettings(); // For serialization
    const std::wstring SETTINGS_FILE_NAME = L""Pool-Settings.txt"";
    void ResetGame(HINSTANCE hInstance); // Function to handle F2 reset

    // --- Forward Declaration for Window Procedure --- <<< Add this line HERE
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // --- NEW Struct for AI Shot Evaluation ---
    struct AIShotInfo {
        bool possible = false;          // Is this shot considered viable?
        Ball* targetBall = nullptr;     // Which ball to hit
        int pocketIndex = -1;           // Which pocket to aim for (0-5)
        D2D1_POINT_2F ghostBallPos = { 0,0 }; // Where cue ball needs to hit target ball
        float angle = 0.0f;             // Calculated shot angle
        float power = 0.0f;             // Calculated shot power
        float score = -1.0f;            // Score for this shot (higher is better)
        bool involves8Ball = false;     // Is the target the 8-ball?
        float spinX = 0.0f;
        float spinY = 0.0f;
    };

    /*
    table = TABLE_COLOR new: #29662d (0.1608, 0.4000, 0.1765) => old: (0.0f, 0.5f, 0.1f)
    rail CUSHION_COLOR = #5c0702 (0.3608, 0.0275, 0.0078) => ::Red
    gap = #e99d33 (0.9157, 0.6157, 0.2000) => ::Orange
    winbg = #5e8863 (0.3686, 0.5333, 0.3882) => 1.0f, 1.0f, 0.803f
    headstring = #47742f (0.2784, 0.4549, 0.1843) => ::White
    bluearrow = #08b0a5 (0.0314, 0.6902, 0.6471) *#22babf (0.1333,0.7294,0.7490) => ::Blue
    */

    // --- NEW Settings Serialization Functions ---
    void SaveSettings() {
        std::ofstream outFile(SETTINGS_FILE_NAME);
        if (outFile.is_open()) {
            outFile << static_cast<int>(gameMode) << std::endl;
            outFile << static_cast<int>(aiDifficulty) << std::endl;
            outFile << static_cast<int>(openingBreakMode) << std::endl;
            outFile << static_cast<int>(selectedTableColor) << std::endl;
            outFile.close();
        }
        // else: Handle error, e.g., log or silently fail
    }

    void LoadSettings() {
        std::ifstream inFile(SETTINGS_FILE_NAME);
        if (inFile.is_open()) {
            int gm, aid, obm;
            if (inFile >> gm) {
                gameMode = static_cast<GameMode>(gm);
            }
            if (inFile >> aid) {
                aiDifficulty = static_cast<AIDifficulty>(aid);
            }
            if (inFile >> obm) {
                openingBreakMode = static_cast<OpeningBreakMode>(obm);
            }
            int tc;
            if (inFile >> tc) {
                selectedTableColor = static_cast<TableColor>(tc);
            }
            inFile.close();

            // Validate loaded settings (optional, but good practice)
            if (gameMode < HUMAN_VS_HUMAN || gameMode > HUMAN_VS_AI) gameMode = HUMAN_VS_HUMAN; // Default
            if (aiDifficulty < EASY || aiDifficulty > HARD) aiDifficulty = MEDIUM; // Default
            if (openingBreakMode < CPU_BREAK || openingBreakMode > FLIP_COIN_BREAK) openingBreakMode = CPU_BREAK; // Default
        }
        // else: File doesn't exist or couldn't be opened, use defaults (already set in global vars)
    }
    // --- End Settings Serialization Functions ---

    // --- NEW Dialog Procedure ---
    INT_PTR CALLBACK NewGameDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
        switch (message) {
        case WM_INITDIALOG:
        {
            // --- ACTION 4: Center Dialog Box ---
    // Optional: Force centering if default isn't working
            RECT rcDlg, rcOwner, rcScreen;
            HWND hwndOwner = GetParent(hDlg); // GetParent(hDlg) might be better if hwndMain is passed
            if (hwndOwner == NULL) hwndOwner = GetDesktopWindow();

            GetWindowRect(hwndOwner, &rcOwner);
            GetWindowRect(hDlg, &rcDlg);
            CopyRect(&rcScreen, &rcOwner); // Use owner rect as reference bounds

            // Offset the owner rect relative to the screen if it's not the desktop
            if (GetParent(hDlg) != NULL) { // If parented to main window (passed to DialogBoxParam)
                OffsetRect(&rcOwner, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcDlg, -rcScreen.left, -rcScreen.top);
                OffsetRect(&rcScreen, -rcScreen.left, -rcScreen.top);
            }


            // Calculate centered position
            int x = rcOwner.left + (rcOwner.right - rcOwner.left - (rcDlg.right - rcDlg.left)) / 2;
            int y = rcOwner.top + (rcOwner.bottom - rcOwner.top - (rcDlg.bottom - rcDlg.top)) / 2;

            // Ensure it stays within screen bounds (optional safety)
            x = std::max(static_cast<int>(rcScreen.left), x);
            y = std::max(static_cast<int>(rcScreen.top), y);
            if (x + (rcDlg.right - rcDlg.left) > rcScreen.right)
                x = rcScreen.right - (rcDlg.right - rcDlg.left);
            if (y + (rcDlg.bottom - rcDlg.top) > rcScreen.bottom)
                y = rcScreen.bottom - (rcDlg.bottom - rcDlg.top);


            // Set the dialog position
            SetWindowPos(hDlg, HWND_TOP, x, y, 0, 0, SWP_NOSIZE);

            // --- End Centering Code ---

            // Set initial state based on current global settings (or defaults)
            CheckRadioButton(hDlg, IDC_RADIO_2P, IDC_RADIO_CPU, (gameMode == HUMAN_VS_HUMAN) ? IDC_RADIO_2P : IDC_RADIO_CPU);

            CheckRadioButton(hDlg, IDC_RADIO_EASY, IDC_RADIO_HARD,
                (aiDifficulty == EASY) ? IDC_RADIO_EASY : ((aiDifficulty == MEDIUM) ? IDC_RADIO_MEDIUM : IDC_RADIO_HARD));

            // Enable/Disable AI group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), gameMode == HUMAN_VS_AI);
            // Set initial state for Opening Break Mode
            CheckRadioButton(hDlg, IDC_RADIO_CPU_BREAK, IDC_RADIO_FLIP_BREAK,
                (openingBreakMode == CPU_BREAK) ? IDC_RADIO_CPU_BREAK : ((openingBreakMode == P1_BREAK) ? IDC_RADIO_P1_BREAK : IDC_RADIO_FLIP_BREAK));
            // Enable/Disable Opening Break group based on initial mode
            EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), gameMode == HUMAN_VS_AI);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), gameMode == HUMAN_VS_AI);
            // --- NEW: Populate the Table Color ComboBox ---
            HWND hCombo = GetDlgItem(hDlg, IDC_COMBO_TABLECOLOR);
            for (int i = 0; i < 5; ++i) {
                SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)tableColorNames[i]);
            }
            // Set the initial selection based on the loaded/default setting
            SendMessage(hCombo, CB_SETCURSEL, (WPARAM)selectedTableColor, 0);
        }
        return (INT_PTR)TRUE;

        case WM_COMMAND:
        { // Add an opening brace to create a new scope for the entire case.
            HWND hCombo;
            int selectedIndex;
            switch (LOWORD(wParam)) {
            case IDC_RADIO_2P:
            case IDC_RADIO_CPU:
            {
                bool isCPU = IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED;
                // Enable/Disable AI group controls based on selection
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_AI), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_EASY), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MEDIUM), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_HARD), isCPU);
                // Also enable/disable Opening Break Mode group
                EnableWindow(GetDlgItem(hDlg, IDC_GROUP_BREAK_MODE), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_CPU_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_P1_BREAK), isCPU);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_FLIP_BREAK), isCPU);
            }
            return (INT_PTR)TRUE;

            case IDOK:
                // Retrieve selected options and store in global variables
                if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU) == BST_CHECKED) {
                    gameMode = HUMAN_VS_AI;
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_EASY) == BST_CHECKED) aiDifficulty = EASY;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_MEDIUM) == BST_CHECKED) aiDifficulty = MEDIUM;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_HARD) == BST_CHECKED) aiDifficulty = HARD;

                    if (IsDlgButtonChecked(hDlg, IDC_RADIO_CPU_BREAK) == BST_CHECKED) openingBreakMode = CPU_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_P1_BREAK) == BST_CHECKED) openingBreakMode = P1_BREAK;
                    else if (IsDlgButtonChecked(hDlg, IDC_RADIO_FLIP_BREAK) == BST_CHECKED) openingBreakMode = FLIP_COIN_BREAK;
                }
                else {
                    gameMode = HUMAN_VS_HUMAN;
                    // openingBreakMode doesn't apply to HvsH, can leave as is or reset
                }

                // --- NEW: Retrieve selected table color ---
                hCombo = GetDlgItem(hDlg, IDC_COMBO_TABLECOLOR);
                selectedIndex = (int)SendMessage(hCombo, CB_GETCURSEL, 0, 0);
                if (selectedIndex != CB_ERR) {
                    selectedTableColor = static_cast<TableColor>(selectedIndex);
                }

                SaveSettings(); // Save settings when OK is pressed
                EndDialog(hDlg, IDOK); // Close dialog, return IDOK
                return (INT_PTR)TRUE;

            case IDCANCEL: // Handle Cancel or closing the dialog
                // Optionally, could reload settings here if you want cancel to revert to previously saved state
                EndDialog(hDlg, IDCANCEL);
                return (INT_PTR)TRUE;
            }
        } // Add a closing brace for the new scope.
        break; // End WM_COMMAND
        }
        return (INT_PTR)FALSE; // Default processing
    }

    // --- NEW Helper to Show Dialog ---
    void ShowNewGameDialog(HINSTANCE hInstance) {
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), hwndMain, NewGameDialogProc, 0) == IDOK) {
            // User clicked Start, reset game with new settings
            isPlayer2AI = (gameMode == HUMAN_VS_AI); // Update AI flag
            if (isPlayer2AI) {
                switch (aiDifficulty) {
                case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
                case MEDIUM: player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
                case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
                }
            }
            else {
                player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
            }
            // Update window title
            std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
            if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
            else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";
            SetWindowText(hwndMain, windowTitle.c_str());

            // --- NEW: Apply the selected table color ---
                TABLE_COLOR = tableColorValues[selectedTableColor];

            InitGame(); // Re-initialize game logic & board
            InvalidateRect(hwndMain, NULL, TRUE); // Force redraw
        }
        else {
            // User cancelled dialog - maybe just resume game? Or exit?
            // For simplicity, we do nothing, game continues as it was.
            // To exit on cancel from F2, would need more complex state management.
        }
    }

    // --- NEW Reset Game Function ---
    void ResetGame(HINSTANCE hInstance) {
        // Call the helper function to show the dialog and re-init if OK clicked
        ShowNewGameDialog(hInstance);
    }

    // --- WinMain ---
    int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int nCmdShow) {
        if (FAILED(CoInitialize(NULL))) {
            MessageBox(NULL, L""COM Initialization Failed."", L""Error"", MB_OK | MB_ICONERROR);
            return -1;
        }

        // --- NEW: Load settings at startup ---
        LoadSettings();

        // --- NEW: Show configuration dialog FIRST ---
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_NEWGAMEDLG), NULL, NewGameDialogProc, 0) != IDOK) {
            // User cancelled the dialog
            CoUninitialize();
            return 0; // Exit gracefully if dialog cancelled
        }
        // Global gameMode and aiDifficulty are now set by the DialogProc

        // --- Apply the selected table color to the global before anything else draws ---
        TABLE_COLOR = tableColorValues[selectedTableColor];

        // Set AI flag based on game mode
        isPlayer2AI = (gameMode == HUMAN_VS_AI);
        if (isPlayer2AI) {
            switch (aiDifficulty) {
            case EASY: player2Info.name = L""Virtus Pro (Easy)""/*""CPU (Easy)""*/; break;
            case MEDIUM:player2Info.name = L""Virtus Pro (Medium)""/*""CPU (Medium)""*/; break;
            case HARD: player2Info.name = L""Virtus Pro (Hard)""/*""CPU (Hard)""*/; break;
            }
        }
        else {
            player2Info.name = L""Billy Ray Cyrus""/*""Player 2""*/;
        }
        // --- End of Dialog Logic ---


        WNDCLASS wc = { };
        wc.lpfnWndProc = WndProc;
        wc.hInstance = hInstance;
        wc.lpszClassName = L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Use your actual icon ID here

        if (!RegisterClass(&wc)) {
            MessageBox(NULL, L""Window Registration Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // --- ACTION 4: Calculate Centered Window Position ---
        const int WINDOW_WIDTH = 1000; // Define desired width
        const int WINDOW_HEIGHT = 700; // Define desired height
        int screenWidth = GetSystemMetrics(SM_CXSCREEN);
        int screenHeight = GetSystemMetrics(SM_CYSCREEN);
        int windowX = (screenWidth - WINDOW_WIDTH) / 2;
        int windowY = (screenHeight - WINDOW_HEIGHT) / 2;

        // --- Change Window Title based on mode ---
        std::wstring windowTitle = L""Midnight Pool 4""/*""Direct2D 8-Ball Pool""*/;
        if (gameMode == HUMAN_VS_HUMAN) windowTitle += L"" (Human vs Human)"";
        else windowTitle += L"" (Human vs "" + player2Info.name + L"")"";

        DWORD dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX; // No WS_THICKFRAME, No WS_MAXIMIZEBOX

        hwndMain = CreateWindowEx(
            0, L""BLISS_GameEngine""/*""Direct2D_8BallPool""*/, windowTitle.c_str(), dwStyle,
            windowX, windowY, WINDOW_WIDTH, WINDOW_HEIGHT,
            NULL, NULL, hInstance, NULL
        );

        if (!hwndMain) {
            MessageBox(NULL, L""Window Creation Failed."", L""Error"", MB_OK | MB_ICONERROR);
            CoUninitialize();
            return -1;
        }

        // Initialize Direct2D Resources AFTER window creation
        if (FAILED(CreateDeviceResources())) {
            MessageBox(NULL, L""Failed to create Direct2D resources."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        InitGame(); // Initialize game state AFTER resources are ready & mode is set
        Sleep(500); // Allow window to fully initialize before starting the countdown //midi func
        StartMidi(hwndMain, TEXT(""BSQ.MID"")); // Replace with your MIDI filename
        //PlayGameMusic(hwndMain); //midi func

        ShowWindow(hwndMain, nCmdShow);
        UpdateWindow(hwndMain);

        if (!SetTimer(hwndMain, ID_TIMER, 1000 / TARGET_FPS, NULL)) {
            MessageBox(NULL, L""Could not SetTimer()."", L""Error"", MB_OK | MB_ICONERROR);
            DestroyWindow(hwndMain);
            CoUninitialize();
            return -1;
        }

        MSG msg = { };
        // --- Modified Main Loop ---
        // Handles the case where the game starts in SHOWING_DIALOG state (handled now before loop)
        // or gets reset to it via F2. The main loop runs normally once game starts.
        while (GetMessage(&msg, NULL, 0, 0)) {
            // We might need modeless dialog handling here if F2 shows dialog
            // while window is active, but DialogBoxParam is modal.
            // Let's assume F2 hides main window, shows dialog, then restarts game loop.
            // Simpler: F2 calls ResetGame which calls DialogBoxParam (modal) then InitGame.
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }


        KillTimer(hwndMain, ID_TIMER);
        DiscardDeviceResources();
        SaveSettings(); // Save settings on exit
        CoUninitialize();

        return (int)msg.wParam;
    }

    // --- WndProc ---
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        // Declare cueBall pointer once at the top, used in multiple cases
        // For clarity, often better to declare within each case where needed.
        Ball* cueBall = nullptr; // Initialize to nullptr
        switch (msg) {
        case WM_CREATE:
            // Resources are now created in WinMain after CreateWindowEx
            return 0;

        case WM_PAINT:
            OnPaint();
            // Validate the entire window region after painting
            ValidateRect(hwnd, NULL);
            return 0;

        case WM_SIZE: {
            UINT width = LOWORD(lParam);
            UINT height = HIWORD(lParam);
            OnResize(width, height);
            return 0;
        }

        case WM_TIMER:
            if (wParam == ID_TIMER) {
                GameUpdate(); // Update game logic and physics
                InvalidateRect(hwnd, NULL, FALSE); // Request redraw
            }
            return 0;

            // --- NEW: Handle F2 Key for Reset ---
            // --- MODIFIED: Handle More Keys ---
        case WM_KEYDOWN:
        { // Add scope for variable declarations

            // --- FIX: Get Cue Ball pointer for this scope ---
            cueBall = GetCueBall();
            // We might allow some keys even if cue ball is gone (like F1/F2), but actions need it
            // --- End Fix ---

            // Check which player can interact via keyboard (Humans only)
            bool canPlayerControl = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P1 || currentGameState == PRE_BREAK_PLACEMENT)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT)));

            // --- F1 / F2 Keys (Always available) ---
            if (wParam == VK_F2) {
                HINSTANCE hInstance = (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
                ResetGame(hInstance); // Call reset function
                return 0; // Indicate key was processed
            }
            else if (wParam == VK_F1) {
                MessageBox(hwnd,
                    L""Direct2D-based StickPool game made in C++ from scratch (4827+ lines of code)\n"" // Update line count if needed {2764+ lines}
                    L""First successful Clone in C++ (no other sites or projects were there to glean from.) Made /w AI assist\n""
                    L""(others were in JS/ non-8-Ball in C# etc.) w/o OOP and Graphics Frameworks all in a Single file.\n""
                    L""Copyright (C) 2025 Evans Thorpemorton, Entisoft Solutions. Midnight Pool 4. 'BLISS' Game Engine.\n""
                    L""Includes AI Difficulty Modes, Aim-Trajectory For Table Rails + Hard Angles TipShots. || F2=New Game"",
                    L""About This Game"", MB_OK | MB_ICONINFORMATION);
                return 0; // Indicate key was processed
            }

            // Check for 'M' key (uppercase or lowercase)
                // Toggle music with ""M""
            if (wParam == 'M' || wParam == 'm') {
                //static bool isMusicPlaying = false;
                if (isMusicPlaying) {
                    // Stop the music
                    StopMidi();
                    isMusicPlaying = false;
                }
                else {
                    // Build the MIDI file path
                    TCHAR midiPath[MAX_PATH];
                    GetModuleFileName(NULL, midiPath, MAX_PATH);
                    // Keep only the directory part
                    TCHAR* lastBackslash = _tcsrchr(midiPath, '\\');
                    if (lastBackslash != NULL) {
                        *(lastBackslash + 1) = '\0';
                    }
                    // Append the MIDI filename
                    _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID"")); // Adjust filename if needed

                    // Start playing MIDI
                    StartMidi(hwndMain, midiPath);
                    isMusicPlaying = true;
                }
            }


            // --- Player Interaction Keys (Only if allowed) ---
            if (canPlayerControl) {
                // --- Get Shift Key State ---
                bool shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
                float angleStep = shiftPressed ? 0.05f : 0.01f; // Base step / Faster step (Adjust as needed) // Multiplier was 5x
                float powerStep = 0.2f; // Power step (Adjust as needed)

                switch (wParam) {
                case VK_LEFT: // Rotate Cue Stick Counter-Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle -= angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle < 0) cueAngle += 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_RIGHT: // Rotate Cue Stick Clockwise
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        cueAngle += angleStep;
                        // Normalize angle (keep between 0 and 2*PI)
                        if (cueAngle >= 2 * PI) cueAngle -= 2 * PI;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_UP: // Decrease Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower -= powerStep;
                        if (shotPower < 0.0f) shotPower = 0.0f;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true; // Keyboard adjust doesn't use mouse aiming state
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_DOWN: // Increase Shot Power
                    if (currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
                        shotPower += powerStep;
                        if (shotPower > MAX_SHOT_POWER) shotPower = MAX_SHOT_POWER;
                        // Ensure state shows aiming visuals if turn just started
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN) currentGameState = AIMING;
                        isAiming = true;
                        isDraggingStick = false;
                        keyboardAimingActive = true;
                    }
                    break;

                case VK_SPACE: // Trigger Shot
                    if ((currentGameState == AIMING || currentGameState == BREAKING || currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING)
                    {
                        if (shotPower > 0.15f) { // Use same threshold as mouse
                           // Reset foul flags BEFORE applying shot
                            firstHitBallIdThisShot = -1;
                            cueHitObjectBallThisShot = false;
                            railHitAfterContact = false;

                            // Play sound & Apply Shot
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                            ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);

                            // Update State
                            currentGameState = SHOT_IN_PROGRESS;
                            foulCommitted = false;
                            pocketedThisTurn.clear();
                            shotPower = 0; // Reset power after shooting
                            isAiming = false; isDraggingStick = false; // Reset aiming flags
                            keyboardAimingActive = false;
                        }
                    }
                    break;

                case VK_ESCAPE: // Cancel Aim/Shot Setup
                    if ((currentGameState == AIMING || currentGameState == BREAKING) || shotPower > 0)
                    {
                        shotPower = 0.0f;
                        isAiming = false;
                        isDraggingStick = false;
                        keyboardAimingActive = false;
                        // Revert to basic turn state if not breaking
                        if (currentGameState != BREAKING) {
                            currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        }
                        //if (currentPlayer == 1) calledPocketP1 = -1;
                        //else                  calledPocketP2 = -1;
                    }
                    break;

                case 'G': // Toggle Cheat Mode
                    cheatModeEnabled = !cheatModeEnabled;
                    if (cheatModeEnabled)
                        MessageBeep(MB_ICONEXCLAMATION); // Play a beep when enabling
                    else
                        MessageBeep(MB_OK); // Play a different beep when disabling
                    break;

                default:
                    // Allow default processing for other keys if needed
                    // return DefWindowProc(hwnd, msg, wParam, lParam); // Usually not needed for WM_KEYDOWN
                    break;
                } // End switch(wParam) for player controls
                return 0; // Indicate player control key was processed
            } // End if(canPlayerControl)
        } // End scope for WM_KEYDOWN case
        // If key wasn't F1/F2 and player couldn't control, maybe allow default processing?
        // return DefWindowProc(hwnd, msg, wParam, lParam); // Or just return 0
        return 0;

        case WM_MOUSEMOVE: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- NEW LOGIC: Handle Pocket Hover ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {
                int oldHover = currentlyHoveredPocket;
                currentlyHoveredPocket = -1; // Reset
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        currentlyHoveredPocket = i;
                        break;
                    }
                }
                if (oldHover != currentlyHoveredPocket) {
                    InvalidateRect(hwnd, NULL, FALSE);
                }
                // Do NOT return 0 here, allow normal mouse angle update to continue
            }
            // --- END NEW LOGIC ---


            cueBall = GetCueBall(); // Declare and get cueBall pointer

            if (isDraggingCueBall && cheatModeEnabled && draggingBallId != -1) {
                Ball* ball = GetBallById(draggingBallId);
                if (ball) {
                    ball->x = (float)ptMouse.x;
                    ball->y = (float)ptMouse.y;
                    ball->vx = ball->vy = 0.0f;
                }
                return 0;
            }

            if (!cueBall) return 0;

            // Update Aiming Logic (Check player turn)
            if (isDraggingCueBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (!isPlayer2AI && currentPlayer == 2 && currentGameState == BALL_IN_HAND_P2) ||
                    currentGameState == PRE_BREAK_PLACEMENT))
            {
                bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                // Tentative position update
                cueBall->x = (float)ptMouse.x;
                cueBall->y = (float)ptMouse.y;
                cueBall->vx = cueBall->vy = 0;
            }
            else if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                //NEW2 MOUSEBOUND CODE = START
                    /*// Clamp mouse inside table bounds during aiming
                    if (ptMouse.x < TABLE_LEFT) ptMouse.x = TABLE_LEFT;
                if (ptMouse.x > TABLE_RIGHT) ptMouse.x = TABLE_RIGHT;
                if (ptMouse.y < TABLE_TOP) ptMouse.y = TABLE_TOP;
                if (ptMouse.y > TABLE_BOTTOM) ptMouse.y = TABLE_BOTTOM;*/
                //NEW2 MOUSEBOUND CODE = END
                // Aiming drag updates angle and power
                float dx = (float)ptMouse.x - cueBall->x;
                float dy = (float)ptMouse.y - cueBall->y;
                if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                //float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                //shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                if (!keyboardAimingActive) { // Only update shotPower if NOT keyboard aiming
                    float pullDist = GetDistance((float)ptMouse.x, (float)ptMouse.y, aimStartPoint.x, aimStartPoint.y);
                    shotPower = std::min(pullDist / 10.0f, MAX_SHOT_POWER);
                }
            }
            else if (isSettingEnglish &&
                ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == PLAYER2_TURN || currentGameState == AIMING || currentGameState == BREAKING))))
            {
                // Setting English
                float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                float dist = GetDistance(dx, dy, 0, 0);
                if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                cueSpinX = dx / spinIndicatorRadius;
                cueSpinY = dy / spinIndicatorRadius;
            }
            else {
                //DISABLE PERM AIMING = START
                /*// Update visual angle even when not aiming/dragging (Check player turn)
                bool canUpdateVisualAngle = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BALL_IN_HAND_P1)) ||
                    (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BALL_IN_HAND_P2)) ||
                    currentGameState == PRE_BREAK_PLACEMENT || currentGameState == BREAKING || currentGameState == AIMING);

                if (canUpdateVisualAngle && !isDraggingCueBall && !isAiming && !isDraggingStick && !keyboardAimingActive) // NEW: Prevent mouse override if keyboard aiming
                {
                    // NEW MOUSEBOUND CODE = START
                        // Only update cue angle if mouse is inside the playable table area
                    if (ptMouse.x >= TABLE_LEFT && ptMouse.x <= TABLE_RIGHT &&
                        ptMouse.y >= TABLE_TOP && ptMouse.y <= TABLE_BOTTOM)
                    {
                        // NEW MOUSEBOUND CODE = END
                        Ball* cb = cueBall; // Use function-scope cueBall // Already got cueBall above
                        if (cb) {
                            float dx = (float)ptMouse.x - cb->x;
                            float dy = (float)ptMouse.y - cb->y;
                            if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                        }
                    } //NEW MOUSEBOUND CODE LINE = DISABLE
                }*/
                //DISABLE PERM AIMING = END
            }
            return 0;
        } // End WM_MOUSEMOVE

        case WM_LBUTTONDOWN: {
            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            // --- FOOLPROOF FIX: This block implements the two-stage pocket selection ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // STAGE 1, STEP 1: Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // STAGE 1, STEP 2: Player clicked on a pocket. Update the choice.
                    // We DO NOT change the game state here. This allows re-selection.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and stay in CHOOSING_POCKET state.
                }

                // STAGE 2, STEP 1: Check if the player is clicking the cue ball to confirm.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // STAGE 2, STEP 2: A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to a generic aiming state.
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message.
                    isAiming = true; // Prepare for aiming.
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable.
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }

            /*// --- FOOLPROOF FIX: This block handles re-selectable pocket choice ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) { // Player clicked on a pocket
                    // FIX: Update the called pocket, but DO NOT change the game state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show updated arrow
                    return 0; // Consume the click and stay in CHOOSING_POCKET state
                }

                // FIX: Add new logic to CONFIRM the choice by clicking the cue ball.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = AIMING; // Go to aiming, not PLAYER1_TURN
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }*/

            /*// --- handle pocket re-selection when choosing 8-ball pocket ---
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1)
                || (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI))
            {
                POINT pt = { LOWORD(lParam), HIWORD(lParam) };
                for (int i = 0; i < 6; ++i) {
                    float dx = pt.x - pocketPositions[i].x;
                    float dy = pt.y - pocketPositions[i].y;
                    if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                        // 1) Record the call
                        if (currentPlayer == 1) calledPocketP1 = i;
                        else                  calledPocketP2 = i;
                        // 2) Clear any prompt text
                        pocketCallMessage.clear();
                        // 3) Return to normal aiming state
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        // 4) Redraw (arrow stays because calledPocketP* >= 0)
                        InvalidateRect(hwnd, NULL, FALSE);
                        return 0; // consume click
                    }
                }
                return 0; // clicked outside ? stay in pocket?call until a valid pocket is chosen
            }*/

            // … rest of your click?to?aim logic …

            //replaced /w new code
            /*
            // --- FIX: Add this entire block at the top of WM_LBUTTONDOWN ---
    // This handles input specifically for the pocket selection state.
            if ((currentGameState == CHOOSING_POCKET_P1 && currentPlayer == 1) ||
                (currentGameState == CHOOSING_POCKET_P2 && currentPlayer == 2 && !isPlayer2AI)) {

                int clickedPocketIndex = -1;
                // Check if the click was on any of the 6 pockets
                for (int i = 0; i < 6; ++i) {
                    if (GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, pocketPositions[i].x, pocketPositions[i].y) < HOLE_VISUAL_RADIUS * HOLE_VISUAL_RADIUS * 2.25f) {
                        clickedPocketIndex = i;
                        break;
                    }
                }

                if (clickedPocketIndex != -1) {
                    // A pocket was clicked. Update the selection but STAY in the choosing state.
                    // This allows the player to click another pocket to change their mind.
                    if (currentPlayer == 1) calledPocketP1 = clickedPocketIndex;
                    else calledPocketP2 = clickedPocketIndex;
                    InvalidateRect(hwnd, NULL, FALSE); // Redraw to show the arrow has moved.
                    return 0; // Consume the click and wait for the next action.
                }

                // If the player clicks the CUE BALL, that confirms their pocket selection.
                Ball* cueBall = GetCueBall();
                int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
                if (cueBall && calledPocket != -1 && GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y) < BALL_RADIUS * BALL_RADIUS * 25) {
                    // A pocket has been selected, and the player now clicks the cue ball.
                    // NOW we transition to the normal aiming state.
                    currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                    pocketCallMessage = L""""; // Clear the ""Choose a pocket..."" message
                    isAiming = true; // Prepare for aiming
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y); // Use your existing aim start variable
                    return 0;
                }

                // If they click anywhere else (not a pocket, not the cue ball), do nothing.
                return 0;
            }
            // --- END OF THE NEW BLOCK ---
            */
            //new code ends here

            if (cheatModeEnabled) {
                // Allow dragging any ball freely
                for (Ball& ball : balls) {
                    float distSq = GetDistanceSq(ball.x, ball.y, (float)ptMouse.x, (float)ptMouse.y);
                    if (distSq <= BALL_RADIUS * BALL_RADIUS * 4) { // Click near ball
                        isDraggingCueBall = true;
                        draggingBallId = ball.id;
                        if (ball.id == 0) {
                            // If dragging cue ball manually, ensure we stay in Ball-In-Hand state
                            if (currentPlayer == 1)
                                currentGameState = BALL_IN_HAND_P1;
                            else if (currentPlayer == 2 && !isPlayer2AI)
                                currentGameState = BALL_IN_HAND_P2;
                        }
                        return 0;
                    }
                }
            }

            Ball* cueBall = GetCueBall(); // Declare and get cueBall pointer            

            // Check which player is allowed to interact via mouse click
            bool canPlayerClickInteract = ((currentPlayer == 1) || (currentPlayer == 2 && !isPlayer2AI));
            // Define states where interaction is generally allowed
            bool canInteractState = (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == AIMING || currentGameState == BREAKING ||
                currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT);

            // Check Spin Indicator first (Allow if player's turn/aim phase)
            if (canPlayerClickInteract && canInteractState) {
                float spinDistSq = GetDistanceSq((float)ptMouse.x, (float)ptMouse.y, spinIndicatorCenter.x, spinIndicatorCenter.y);
                if (spinDistSq < spinIndicatorRadius * spinIndicatorRadius * 1.2f) {
                    isSettingEnglish = true;
                    float dx = (float)ptMouse.x - spinIndicatorCenter.x;
                    float dy = (float)ptMouse.y - spinIndicatorCenter.y;
                    float dist = GetDistance(dx, dy, 0, 0);
                    if (dist > spinIndicatorRadius) { dx *= spinIndicatorRadius / dist; dy *= spinIndicatorRadius / dist; }
                    cueSpinX = dx / spinIndicatorRadius;
                    cueSpinY = dy / spinIndicatorRadius;
                    isAiming = false; isDraggingStick = false; isDraggingCueBall = false;
                    return 0;
                }
            }

            if (!cueBall) return 0;

            // Check Ball-in-Hand placement/drag
            bool isPlacingBall = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
            bool isPlayerAllowedToPlace = (isPlacingBall &&
                ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                    (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                    (currentGameState == PRE_BREAK_PLACEMENT))); // Allow current player in break setup

            if (isPlayerAllowedToPlace) {
                float distSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                if (distSq < BALL_RADIUS * BALL_RADIUS * 9.0f) {
                    isDraggingCueBall = true;
                    isAiming = false; isDraggingStick = false;
                }
                else {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition((float)ptMouse.x, (float)ptMouse.y, behindHeadstring)) {
                        cueBall->x = (float)ptMouse.x; cueBall->y = (float)ptMouse.y;
                        cueBall->vx = 0; cueBall->vy = 0;
                        isDraggingCueBall = false;
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                    }
                }
                return 0;
            }

            // Check for starting Aim (Cue Ball OR Stick)
            bool canAim = ((currentPlayer == 1 && (currentGameState == PLAYER1_TURN || currentGameState == BREAKING)) ||
                (currentPlayer == 2 && !isPlayer2AI && (currentGameState == PLAYER2_TURN || currentGameState == BREAKING)));

            if (canAim) {
                const float stickDrawLength = 150.0f * 1.4f;
                float currentStickAngle = cueAngle + PI;
                D2D1_POINT_2F currentStickEnd = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * stickDrawLength, cueBall->y + sinf(currentStickAngle) * stickDrawLength);
                D2D1_POINT_2F currentStickTip = D2D1::Point2F(cueBall->x + cosf(currentStickAngle) * 5.0f, cueBall->y + sinf(currentStickAngle) * 5.0f);
                float distToStickSq = PointToLineSegmentDistanceSq(D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y), currentStickTip, currentStickEnd);
                float stickClickThresholdSq = 36.0f;
                float distToCueBallSq = GetDistanceSq(cueBall->x, cueBall->y, (float)ptMouse.x, (float)ptMouse.y);
                float cueBallClickRadiusSq = BALL_RADIUS * BALL_RADIUS * 25;

                bool clickedStick = (distToStickSq < stickClickThresholdSq);
                bool clickedCueArea = (distToCueBallSq < cueBallClickRadiusSq);

                if (clickedStick || clickedCueArea) {
                    isDraggingStick = clickedStick && !clickedCueArea;
                    isAiming = clickedCueArea;
                    aimStartPoint = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
                    shotPower = 0;
                    float dx = (float)ptMouse.x - cueBall->x;
                    float dy = (float)ptMouse.y - cueBall->y;
                    if (dx != 0 || dy != 0) cueAngle = atan2f(dy, dx);
                    if (currentGameState != BREAKING) currentGameState = AIMING;
                }
            }
            return 0;
        } // End WM_LBUTTONDOWN


        case WM_LBUTTONUP: {
            // --- FOOLPROOF FIX for Cheat Mode Scoring ---
            if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- This is the new, ""smarter"" logic ---
                            b->isPocketed = true; // Pocket the ball visually.

                            // If the table is open, assign types based on this cheated ball.
                            if (player1Info.assignedType == BallType::NONE && b->id != 0 && b->id != 8) {
                                AssignPlayerBallTypes(b->type, false);
                            }

                            // Now, correctly update the score for the right player.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            break; // Stop checking pockets.
                        }
                    }
                }
            }

            /*if (cheatModeEnabled && draggingBallId != -1) {
                Ball* b = GetBallById(draggingBallId);
                if (b) {
                    for (int p = 0; p < 6; ++p) {
                        float dx = b->x - pocketPositions[p].x;
                        float dy = b->y - pocketPositions[p].y;
                        if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                            // --- Assign ball type on first cheat-pocket if table still open ---
                            if (player1Info.assignedType == BallType::NONE
                                && player2Info.assignedType == BallType::NONE
                                && (b->type == BallType::SOLID || b->type == BallType::STRIPE))
                            {
                                // In cheat mode, let's just assign to the current player
                                AssignPlayerBallTypes(b->type);
                            }
                            b->isPocketed = true;
                            pocketedThisTurn.push_back(b->id);

                            // --- FIX FOR CHEAT MODE SCORING ---
                            // Immediately increment the correct player's count based on ball type,
                            // not whose turn it is.
                            if (b->id != 0 && b->id != 8) {
                                if (b->type == player1Info.assignedType) {
                                    player1Info.ballsPocketedCount++;
                                }
                                else if (b->type == player2Info.assignedType) {
                                    player2Info.ballsPocketedCount++;
                                }
                            }
                            // --- END FIX ---
                            // --- NEW: If this was the 7th ball, trigger the arrow call UI ---
                            if (b->id != 8) {
                                PlayerInfo& shooter = (currentPlayer == 1 ? player1Info : player2Info);
                                if (shooter.ballsPocketedCount >= 7
                                    && calledPocketP1 < 0
                                    && calledPocketP2 < 0)
                                {
                                    currentGameState = (currentPlayer == 1)
                                        ? CHOOSING_POCKET_P1
                                        : CHOOSING_POCKET_P2;
                                }
                                else {
                                    // For any other cheat?pocket, keep the turn so you can continue aiming
                                    currentGameState = (currentPlayer == 1)
                                        ? PLAYER1_TURN
                                        : PLAYER2_TURN;
                                }
                            }
                            // --- NEW: If it was the 8-Ball, award instant victory ---
                            else {
                                currentGameState = GAME_OVER;
                                gameOverMessage = (currentPlayer == 1 ? player1Info.name : player2Info.name)
                                    + std::wstring(L"" Wins!"");
                            }
                            break;
                        }
                    }
                }
            }*/

            ptMouse.x = LOWORD(lParam);
            ptMouse.y = HIWORD(lParam);

            Ball* cueBall = GetCueBall(); // Get cueBall pointer

            // Check for releasing aim drag (Stick OR Cue Ball)
            if ((isAiming || isDraggingStick) &&
                ((currentPlayer == 1 && (currentGameState == AIMING || currentGameState == BREAKING)) ||
                    (!isPlayer2AI && currentPlayer == 2 && (currentGameState == AIMING || currentGameState == BREAKING))))
            {
                bool wasAiming = isAiming;
                bool wasDraggingStick = isDraggingStick;
                isAiming = false; isDraggingStick = false;

                if (shotPower > 0.15f) { // Check power threshold
                    if (currentGameState != AI_THINKING) {
                        firstHitBallIdThisShot = -1; cueHitObjectBallThisShot = false; railHitAfterContact = false; // Reset foul flags
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
                        ApplyShot(shotPower, cueAngle, cueSpinX, cueSpinY);
                        currentGameState = SHOT_IN_PROGRESS;
                        foulCommitted = false; pocketedThisTurn.clear();
                    }
                }
                else if (currentGameState != AI_THINKING) { // Revert state if power too low
                    if (currentGameState == BREAKING) { /* Still breaking */ }
                    else {
                        currentGameState = (currentPlayer == 1) ? PLAYER1_TURN : PLAYER2_TURN;
                        if (currentPlayer == 2 && isPlayer2AI) aiTurnPending = false;
                    }
                }
                shotPower = 0; // Reset power indicator regardless
            }

            // Handle releasing cue ball drag (placement)
            if (isDraggingCueBall) {
                isDraggingCueBall = false;
                // Check player allowed to place
                bool isPlacingState = (currentGameState == BALL_IN_HAND_P1 || currentGameState == BALL_IN_HAND_P2 || currentGameState == PRE_BREAK_PLACEMENT);
                bool isPlayerAllowed = (isPlacingState &&
                    ((currentPlayer == 1 && currentGameState == BALL_IN_HAND_P1) ||
                        (currentPlayer == 2 && !isPlayer2AI && currentGameState == BALL_IN_HAND_P2) ||
                        (currentGameState == PRE_BREAK_PLACEMENT)));

                if (isPlayerAllowed && cueBall) {
                    bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
                    if (IsValidCueBallPosition(cueBall->x, cueBall->y, behindHeadstring)) {
                        // Finalize position already set by mouse move
                        // Transition state
                        if (currentGameState == PRE_BREAK_PLACEMENT) currentGameState = BREAKING;
                        else if (currentGameState == BALL_IN_HAND_P1) currentGameState = PLAYER1_TURN;
                        else if (currentGameState == BALL_IN_HAND_P2) currentGameState = PLAYER2_TURN;
                        cueAngle = 0.0f;
                        /* ----------------------------------------------------
                        If the player who now has the turn is already on the
                        8-ball, immediately switch to pocket-selection state.
                        ---------------------------------------------------- */
                        if (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN)
                        {
                            CheckAndTransitionToPocketChoice(currentPlayer);
                        }
                    }
                    else { /* Stay in BALL_IN_HAND state if final pos invalid */ }
                }
            }

            // Handle releasing english setting
            if (isSettingEnglish) {
                isSettingEnglish = false;
            }
            return 0;
        } // End WM_LBUTTONUP

        case WM_DESTROY:
            isMusicPlaying = false;
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
                SaveSettings(); // Save settings on exit
            }
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
        return 0;
    }

    // --- Direct2D Resource Management ---

    HRESULT CreateDeviceResources() {
        HRESULT hr = S_OK;

        // Create Direct2D Factory
        if (!pFactory) {
            hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &pFactory);
            if (FAILED(hr)) return hr;
        }

        // Create DirectWrite Factory
        if (!pDWriteFactory) {
            hr = DWriteCreateFactory(
                DWRITE_FACTORY_TYPE_SHARED,
                __uuidof(IDWriteFactory),
                reinterpret_cast<IUnknown**>(&pDWriteFactory)
            );
            if (FAILED(hr)) return hr;
        }

        // Create Text Formats
        if (!pTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                16.0f, L""en-us"", &pTextFormat
            );
            if (FAILED(hr)) return hr;
            // Center align text
            pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
            pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }
        if (!pLargeTextFormat && pDWriteFactory) {
            hr = pDWriteFactory->CreateTextFormat(
                L""Impact"", NULL, DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                48.0f, L""en-us"", &pLargeTextFormat
            );
            if (FAILED(hr)) return hr;
            pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING); // Align left
            pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        }

        if (!pBallNumFormat && pDWriteFactory)
        {
            hr = pDWriteFactory->CreateTextFormat(
                L""Segoe UI"", nullptr,
                DWRITE_FONT_WEIGHT_BOLD, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL,
                10.0f,                       // << small size for ball decals
                L""en-us"",
                &pBallNumFormat);
            if (SUCCEEDED(hr))
            {
                pBallNumFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pBallNumFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
            }
        }


        // Create Render Target (needs valid hwnd)
        if (!pRenderTarget && hwndMain) {
            RECT rc;
            GetClientRect(hwndMain, &rc);
            D2D1_SIZE_U size = D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top);

            hr = pFactory->CreateHwndRenderTarget(
                D2D1::RenderTargetProperties(),
                D2D1::HwndRenderTargetProperties(hwndMain, size),
                &pRenderTarget
            );
            if (FAILED(hr)) {
                // If failed, release factories if they were created in this call
                SafeRelease(&pTextFormat);
                SafeRelease(&pLargeTextFormat);
                SafeRelease(&pDWriteFactory);
                SafeRelease(&pFactory);
                pRenderTarget = nullptr; // Ensure it's null on failure
                return hr;
            }
        }

        return hr;
    }

    void DiscardDeviceResources() {
        SafeRelease(&pRenderTarget);
        SafeRelease(&pTextFormat);
        SafeRelease(&pLargeTextFormat);
        SafeRelease(&pBallNumFormat);            // NEW
        SafeRelease(&pDWriteFactory);
        // Keep pFactory until application exit? Or release here too? Let's release.
        SafeRelease(&pFactory);
    }

    void OnResize(UINT width, UINT height) {
        if (pRenderTarget) {
            D2D1_SIZE_U size = D2D1::SizeU(width, height);
            pRenderTarget->Resize(size); // Ignore HRESULT for simplicity here
        }
    }

    // --- Game Initialization ---
    void InitGame() {
        srand((unsigned int)time(NULL)); // Seed random number generator
        isOpeningBreakShot = true; // This is the start of a new game, so the next shot is an opening break.
        aiPlannedShotDetails.isValid = false; // Reset AI planned shot
        aiIsDisplayingAim = false;
        aiAimDisplayFramesLeft = 0;
        // ... (rest of InitGame())

        // --- Ensure pocketed list is clear from the absolute start ---
        pocketedThisTurn.clear();

        balls.clear(); // Clear existing balls

        // Reset Player Info (Names should be set by Dialog/wWinMain/ResetGame)
        player1Info.assignedType = BallType::NONE;
        player1Info.ballsPocketedCount = 0;
        // Player 1 Name usually remains ""Player 1""
        player2Info.assignedType = BallType::NONE;
        player2Info.ballsPocketedCount = 0;
        // Player 2 Name is set based on gameMode in ShowNewGameDialog
            // --- Reset any 8?Ball call state on new game ---
        lastEightBallPocketIndex = -1;
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage = L"""";
        aiPlannedShotDetails.isValid = false; // THIS IS THE CRITICAL FIX: Reset the AI's plan.

        // Create Cue Ball (ID 0)
        // Initial position will be set during PRE_BREAK_PLACEMENT state
        balls.push_back({ 0, BallType::CUE_BALL, TABLE_LEFT + TABLE_WIDTH * 0.15f, RACK_POS_Y, 0, 0, CUE_BALL_COLOR, false });

        // --- Create Object Balls (Temporary List) ---
        std::vector<Ball> objectBalls;
        // Solids (1-7, Yellow)
        for (int i = 1; i <= 7; ++i) {
            //objectBalls.push_back({ i, BallType::SOLID, 0, 0, 0, 0, SOLID_COLOR, false });
            objectBalls.push_back({ i, BallType::SOLID, 0,0,0,0,
                        GetBallColor(i), false });
        }
        // Stripes (9-15, Red)
        for (int i = 9; i <= 15; ++i) {
            //objectBalls.push_back({ i, BallType::STRIPE, 0, 0, 0, 0, STRIPE_COLOR, false });
            objectBalls.push_back({ i, BallType::STRIPE, 0,0,0,0,
                        GetBallColor(i), false });
        }
        // 8-Ball (ID 8) - Add it to the list to be placed
        //objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false });
        objectBalls.push_back({ 8, BallType::EIGHT_BALL, 0,0,0,0,
              GetBallColor(8), false });


        // --- Racking Logic (Improved) ---
        float spacingX = BALL_RADIUS * 2.0f * 0.866f; // cos(30) for horizontal spacing
        float spacingY = BALL_RADIUS * 2.0f * 1.0f;   // Vertical spacing

        // Define rack positions (0-14 indices corresponding to triangle spots)
        D2D1_POINT_2F rackPositions[15];
        int rackIndex = 0;
        for (int row = 0; row < 5; ++row) {
            for (int col = 0; col <= row; ++col) {
                if (rackIndex >= 15) break;
                float x = RACK_POS_X + row * spacingX;
                float y = RACK_POS_Y + (col - row / 2.0f) * spacingY;
                rackPositions[rackIndex++] = D2D1::Point2F(x, y);
            }
        }

        // Separate 8-ball
        Ball eightBall;
        std::vector<Ball> otherBalls; // Solids and Stripes
        bool eightBallFound = false;
        for (const auto& ball : objectBalls) {
            if (ball.id == 8) {
                eightBall = ball;
                eightBallFound = true;
            }
            else {
                otherBalls.push_back(ball);
            }
        }
        // Ensure 8 ball was actually created (should always be true)
        if (!eightBallFound) {
            // Handle error - perhaps recreate it? For now, proceed.
            eightBall = { 8, BallType::EIGHT_BALL, 0, 0, 0, 0, EIGHT_BALL_COLOR, false };
        }


        // Shuffle the other 14 balls
        // Use std::shuffle if available (C++11 and later) for better randomness
        // std::random_device rd;
        // std::mt19937 g(rd());
        // std::shuffle(otherBalls.begin(), otherBalls.end(), g);
        std::random_shuffle(otherBalls.begin(), otherBalls.end()); // Using deprecated for now

        // --- Place balls into the main 'balls' vector in rack order ---
        // Important: Add the cue ball (already created) first.
        // (Cue ball added at the start of the function now)

        // 1. Place the 8-ball in its fixed position (index 4 for the 3rd row center)
        int eightBallRackIndex = 4;
        eightBall.x = rackPositions[eightBallRackIndex].x;
        eightBall.y = rackPositions[eightBallRackIndex].y;
        eightBall.vx = 0;
        eightBall.vy = 0;
        eightBall.isPocketed = false;
        balls.push_back(eightBall); // Add 8 ball to the main vector

        // 2. Place the shuffled Solids and Stripes in the remaining spots
        size_t otherBallIdx = 0;
        //int otherBallIdx = 0;
        for (int i = 0; i < 15; ++i) {
            if (i == eightBallRackIndex) continue; // Skip the 8-ball spot

            if (otherBallIdx < otherBalls.size()) {
                Ball& ballToPlace = otherBalls[otherBallIdx++];
                ballToPlace.x = rackPositions[i].x;
                ballToPlace.y = rackPositions[i].y;
                ballToPlace.vx = 0;
                ballToPlace.vy = 0;
                ballToPlace.isPocketed = false;
                balls.push_back(ballToPlace); // Add to the main game vector
            }
        }
        // --- End Racking Logic ---


        // --- Determine Who Breaks and Initial State ---
        if (isPlayer2AI) {
            /*// AI Mode: Randomly decide who breaks
            if ((rand() % 2) == 0) {
                // AI (Player 2) breaks
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT; // AI needs to place ball first
                aiTurnPending = true; // Trigger AI logic
            }
            else {
                // Player 1 (Human) breaks
                currentPlayer = 1;
                currentGameState = PRE_BREAK_PLACEMENT; // Human places cue ball
                aiTurnPending = false;*/
            switch (openingBreakMode) {
            case CPU_BREAK:
                currentPlayer = 2; // AI breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            case P1_BREAK:
                currentPlayer = 1; // Player 1 breaks
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = false;
                break;
            case FLIP_COIN_BREAK:
                if ((rand() % 2) == 0) { // 0 for AI, 1 for Player 1
                    currentPlayer = 2; // AI breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = true;
                }
                else {
                    currentPlayer = 1; // Player 1 breaks
                    currentGameState = PRE_BREAK_PLACEMENT;
                    aiTurnPending = false;
                }
                break;
            default: // Fallback to CPU break
                currentPlayer = 2;
                currentGameState = PRE_BREAK_PLACEMENT;
                aiTurnPending = true;
                break;
            }
        }
        else {
            // Human vs Human, Player 1 always breaks (or could add a flip coin for HvsH too if desired)
            currentPlayer = 1;
            currentGameState = PRE_BREAK_PLACEMENT;
            aiTurnPending = false; // No AI involved
        }

        // Reset other relevant game state variables
        foulCommitted = false;
        gameOverMessage = L"""";
        firstBallPocketedAfterBreak = false;
        // pocketedThisTurn cleared at start
        // Reset shot parameters and input flags
        shotPower = 0.0f;
        cueSpinX = 0.0f;
        cueSpinY = 0.0f;
        isAiming = false;
        isDraggingCueBall = false;
        isSettingEnglish = false;
        cueAngle = 0.0f; // Reset aim angle
    }


    // --------------------------------------------------------------------------------
    // Full GameUpdate(): integrates AI call?pocket ? aim ? shoot (no omissions)
    // --------------------------------------------------------------------------------
    void GameUpdate() {
        // --- 1) Handle an in?flight shot ---
        if (currentGameState == SHOT_IN_PROGRESS) {
            UpdatePhysics();
            // ? clear old 8?ball pocket info before any new pocket checks
            //lastEightBallPocketIndex = -1;
            CheckCollisions();
            CheckPockets(); // FIX: This line was missing. It's essential to check for pocketed balls every frame.

            if (AreBallsMoving()) {
                isAiming = false;
                aiIsDisplayingAim = false;
            }

            if (!AreBallsMoving()) {
                ProcessShotResults();
            }
            return;
        }

        // --- 2) CPU’s turn (table is static) ---
        if (isPlayer2AI && currentPlayer == 2 && !AreBallsMoving()) {
            // ??? If we've just auto?entered AI_THINKING for the 8?ball call, actually make the decision ???
            if (currentGameState == AI_THINKING && aiTurnPending) {
                aiTurnPending = false;        // consume the pending flag
                AIMakeDecision();             // CPU calls its pocket or plans its shot
                return;                       // done this tick
            }

            // ??? Automate the AI pocket?selection click ???
            if (currentGameState == CHOOSING_POCKET_P2) {
                // AI immediately confirms its call and moves to thinking/shooting
                currentGameState = AI_THINKING;
                aiTurnPending = true;
                return; // process on next tick
            }
            // 2A) If AI is displaying its aim line, count down then shoot
            if (aiIsDisplayingAim) {
                aiAimDisplayFramesLeft--;
                if (aiAimDisplayFramesLeft <= 0) {
                    aiIsDisplayingAim = false;
                    if (aiPlannedShotDetails.isValid) {
                        firstHitBallIdThisShot = -1;
                        cueHitObjectBallThisShot = false;
                        railHitAfterContact = false;
                        std::thread([](const TCHAR* soundName) {
                            PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT);
                            }, TEXT(""cue.wav"")).detach();

                            ApplyShot(
                                aiPlannedShotDetails.power,
                                aiPlannedShotDetails.angle,
                                aiPlannedShotDetails.spinX,
                                aiPlannedShotDetails.spinY
                            );
                            aiPlannedShotDetails.isValid = false;
                    }
                    currentGameState = SHOT_IN_PROGRESS;
                    foulCommitted = false;
                    pocketedThisTurn.clear();
                }
                return;
            }

            // 2B) Immediately after calling pocket, transition into AI_THINKING
            if (currentGameState == CHOOSING_POCKET_P2 && aiTurnPending) {
                // Start thinking/shooting right away—no human click required
                currentGameState = AI_THINKING;
                aiTurnPending = false;
                AIMakeDecision();
                return;
            }

            // 2C) If AI has pending actions (break, ball?in?hand, or normal turn)
            if (aiTurnPending) {
                if (currentGameState == BALL_IN_HAND_P2) {
                    AIPlaceCueBall();
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                else if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
                    AIBreakShot();
                }
                else if (currentGameState == PLAYER2_TURN || currentGameState == BREAKING) {
                    currentGameState = AI_THINKING;
                    aiTurnPending = false;
                    AIMakeDecision();
                }
                return;
            }
        }
    }


    // --- Physics and Collision ---
    void UpdatePhysics() {
        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b = balls[i];
            if (!b.isPocketed) {
                b.x += b.vx;
                b.y += b.vy;

                // Apply friction
                b.vx *= FRICTION;
                b.vy *= FRICTION;

                // Stop balls if velocity is very low
                if (GetDistanceSq(b.vx, b.vy, 0, 0) < MIN_VELOCITY_SQ) {
                    b.vx = 0;
                    b.vy = 0;
                }

                /* -----------------------------------------------------------------
       Additional clamp to guarantee the ball never escapes the table.
       The existing wall–collision code can momentarily disable the
       reflection test while the ball is close to a pocket mouth;
       that rare case allowed it to ‘slide’ through the cushion and
       leave the board.  We therefore enforce a final boundary check
       after the normal physics step.
       ----------------------------------------------------------------- */
                const float leftBound = TABLE_LEFT + BALL_RADIUS;
                const float rightBound = TABLE_RIGHT - BALL_RADIUS;
                const float topBound = TABLE_TOP + BALL_RADIUS;
                const float bottomBound = TABLE_BOTTOM - BALL_RADIUS;

                if (b.x < leftBound) { b.x = leftBound;   b.vx = fabsf(b.vx); }
                if (b.x > rightBound) { b.x = rightBound;  b.vx = -fabsf(b.vx); }
                if (b.y < topBound) { b.y = topBound;    b.vy = fabsf(b.vy); }
                if (b.y > bottomBound) { b.y = bottomBound; b.vy = -fabsf(b.vy); }
            }
        }
    }

    void CheckCollisions() {
        float left = TABLE_LEFT;
        float right = TABLE_RIGHT;
        float top = TABLE_TOP;
        float bottom = TABLE_BOTTOM;
        const float pocketMouthCheckRadiusSq = (POCKET_RADIUS + BALL_RADIUS) * (POCKET_RADIUS + BALL_RADIUS) * 1.1f;

        // --- Reset Per-Frame Sound Flags ---
        bool playedWallSoundThisFrame = false;
        bool playedCollideSoundThisFrame = false;
        // ---

        for (size_t i = 0; i < balls.size(); ++i) {
            Ball& b1 = balls[i];
            if (b1.isPocketed) continue;

            bool nearPocket[6];
            for (int p = 0; p < 6; ++p) {
                nearPocket[p] = GetDistanceSq(b1.x, b1.y, pocketPositions[p].x, pocketPositions[p].y) < pocketMouthCheckRadiusSq;
            }
            bool nearTopLeftPocket = nearPocket[0];
            bool nearTopMidPocket = nearPocket[1];
            bool nearTopRightPocket = nearPocket[2];
            bool nearBottomLeftPocket = nearPocket[3];
            bool nearBottomMidPocket = nearPocket[4];
            bool nearBottomRightPocket = nearPocket[5];

            bool collidedWallThisBall = false;

            // --- Ball-Wall Collisions ---
            // (Check logic unchanged, added sound calls and railHitAfterContact update)
            // Left Wall
            if (b1.x - BALL_RADIUS < left) {
                if (!nearTopLeftPocket && !nearBottomLeftPocket) {
                    b1.x = left + BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Right Wall
            if (b1.x + BALL_RADIUS > right) {
                if (!nearTopRightPocket && !nearBottomRightPocket) {
                    b1.x = right - BALL_RADIUS; b1.vx *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Top Wall
            if (b1.y - BALL_RADIUS < top) {
                if (!nearTopLeftPocket && !nearTopMidPocket && !nearTopRightPocket) {
                    b1.y = top + BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }
            // Bottom Wall
            if (b1.y + BALL_RADIUS > bottom) {
                if (!nearBottomLeftPocket && !nearBottomMidPocket && !nearBottomRightPocket) {
                    b1.y = bottom - BALL_RADIUS; b1.vy *= -1.0f; collidedWallThisBall = true;
                    if (!playedWallSoundThisFrame) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""wall.wav"")).detach();
                        playedWallSoundThisFrame = true;
                    }
                    if (cueHitObjectBallThisShot) railHitAfterContact = true; // Track rail hit after contact
                }
            }

            // Spin effect (Unchanged)
            if (collidedWallThisBall) {
                if (b1.x <= left + BALL_RADIUS || b1.x >= right - BALL_RADIUS) { b1.vy += cueSpinX * b1.vx * 0.05f; }
                if (b1.y <= top + BALL_RADIUS || b1.y >= bottom - BALL_RADIUS) { b1.vx -= cueSpinY * b1.vy * 0.05f; }
                cueSpinX *= 0.7f; cueSpinY *= 0.7f;
            }


            // --- Ball-Ball Collisions ---
            for (size_t j = i + 1; j < balls.size(); ++j) {
                Ball& b2 = balls[j];
                if (b2.isPocketed) continue;

                float dx = b2.x - b1.x; float dy = b2.y - b1.y;
                float distSq = dx * dx + dy * dy;
                float minDist = BALL_RADIUS * 2.0f;

                if (distSq > 1e-6 && distSq < minDist * minDist) {
                    float dist = sqrtf(distSq);
                    float overlap = minDist - dist;
                    float nx = dx / dist; float ny = dy / dist;

                    // Separation (Unchanged)
                    b1.x -= overlap * 0.5f * nx; b1.y -= overlap * 0.5f * ny;
                    b2.x += overlap * 0.5f * nx; b2.y += overlap * 0.5f * ny;

                    float rvx = b1.vx - b2.vx; float rvy = b1.vy - b2.vy;
                    float velAlongNormal = rvx * nx + rvy * ny;

                    if (velAlongNormal > 0) { // Colliding
                        // --- Play Ball Collision Sound ---
                        if (!playedCollideSoundThisFrame) {
                            std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""poolballhit.wav"")).detach();
                            playedCollideSoundThisFrame = true; // Set flag
                        }
                        // --- End Sound ---

                        // --- NEW: Track First Hit and Cue/Object Collision ---
                        if (firstHitBallIdThisShot == -1) { // If first hit hasn't been recorded yet
                            if (b1.id == 0) { // Cue ball hit b2 first
                                firstHitBallIdThisShot = b2.id;
                                cueHitObjectBallThisShot = true;
                            }
                            else if (b2.id == 0) { // Cue ball hit b1 first
                                firstHitBallIdThisShot = b1.id;
                                cueHitObjectBallThisShot = true;
                            }
                            // If neither is cue ball, doesn't count as first hit for foul purposes
                        }
                        else if (b1.id == 0 || b2.id == 0) {
                            // Track subsequent cue ball collisions with object balls
                            cueHitObjectBallThisShot = true;
                        }
                        // --- End First Hit Tracking ---


                        // Impulse (Unchanged)
                        float impulse = velAlongNormal;
                        b1.vx -= impulse * nx; b1.vy -= impulse * ny;
                        b2.vx += impulse * nx; b2.vy += impulse * ny;

                        // Spin Transfer (Unchanged)
                        if (b1.id == 0 || b2.id == 0) {
                            float spinEffectFactor = 0.08f;
                            b1.vx += (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b1.vy += (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            b2.vx -= (cueSpinY * ny - cueSpinX * nx) * spinEffectFactor;
                            b2.vy -= (cueSpinY * nx + cueSpinX * ny) * spinEffectFactor;
                            cueSpinX *= 0.85f; cueSpinY *= 0.85f;
                        }
                    }
                }
            } // End ball-ball loop
        } // End ball loop
    } // End CheckCollisions


    bool CheckPockets() {
        bool anyPocketed = false;
        // FIX: Declare a local flag to ensure the sound only plays ONCE per function call.
        bool ballPocketedThisCheck = false;
        // For each ball not already pocketed:
        for (auto& b : balls) {
            if (b.isPocketed)
                continue;

            // Check against each pocket
            for (int p = 0; p < 6; ++p) {
                float dx = b.x - pocketPositions[p].x;
                float dy = b.y - pocketPositions[p].y;
                if (dx * dx + dy * dy <= POCKET_RADIUS * POCKET_RADIUS) {
                    // It's in the pocket—remove it from play
                    // If it's the 8?ball, remember which pocket it went into
                    if (b.id == 8) {
                        lastEightBallPocketIndex = p;   // <-- Must set here!
                    }
                    b.isPocketed = true;
                    b.vx = b.vy = 0.0f;           // kill any movement
                    pocketedThisTurn.push_back(b.id);
                    anyPocketed = true;

                    // --- FIX: Insert your sound logic here ---
                    // The 'if' guard prevents multiple sounds on a multi-ball break.
                    if (!ballPocketedThisCheck) {
                        std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""pocket.wav"")).detach();
                        ballPocketedThisCheck = true;
                    }
                    // --- End Sound Fix ---

                    break;  // no need to check other pockets for this ball
                }
            }
        }
        return anyPocketed;
    }

    bool AreBallsMoving() {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (!balls[i].isPocketed && (balls[i].vx != 0 || balls[i].vy != 0)) {
                return true;
            }
        }
        return false;
    }

    void RespawnCueBall(bool behindHeadstring) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {
            // Determine the initial target position
            float targetX, targetY;
            if (behindHeadstring) {
                targetX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }
            else {
                targetX = TABLE_LEFT + TABLE_WIDTH / 2.0f;
                targetY = TABLE_TOP + TABLE_HEIGHT / 2.0f;
            }

            // FOOLPROOF FIX: Check if the target spot is valid. If not, nudge it until it is.
            int attempts = 0;
            while (!IsValidCueBallPosition(targetX, targetY, behindHeadstring) && attempts < 100) {
                // If the spot is occupied, try nudging the ball slightly.
                targetX += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                targetY += (static_cast<float>(rand() % 100 - 50) / 50.0f) * BALL_RADIUS;
                // Clamp to stay within reasonable bounds
                targetX = std::max(TABLE_LEFT + BALL_RADIUS, std::min(targetX, TABLE_RIGHT - BALL_RADIUS));
                targetY = std::max(TABLE_TOP + BALL_RADIUS, std::min(targetY, TABLE_BOTTOM - BALL_RADIUS));
                attempts++;
            }

            // Set the final, valid position.
            cueBall->x = targetX;
            cueBall->y = targetY;
            cueBall->vx = 0;
            cueBall->vy = 0;
            cueBall->isPocketed = false;

            // Set the correct game state for ball-in-hand.
            if (currentPlayer == 1) {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else {
                currentGameState = BALL_IN_HAND_P2;
                if (isPlayer2AI) {
                    aiTurnPending = true;
                }
            }
        }
    }


    // --- Game Logic ---

    void ApplyShot(float power, float angle, float spinX, float spinY) {
        Ball* cueBall = GetCueBall();
        if (cueBall) {

            // --- Play Cue Strike Sound (Threaded) ---
            if (power > 0.1f) { // Only play if it's an audible shot
                std::thread([](const TCHAR* soundName) { PlaySound(soundName, NULL, SND_FILENAME | SND_NODEFAULT); }, TEXT(""cue.wav"")).detach();
            }
            // --- End Sound ---

            cueBall->vx = cosf(angle) * power;
            cueBall->vy = sinf(angle) * power;

            // Apply English (Spin) - Simplified effect (Unchanged)
            cueBall->vx += sinf(angle) * spinY * 0.5f;
            cueBall->vy -= cosf(angle) * spinY * 0.5f;
            cueBall->vx -= cosf(angle) * spinX * 0.5f;
            cueBall->vy -= sinf(angle) * spinX * 0.5f;

            // Store spin (Unchanged)
            cueSpinX = spinX;
            cueSpinY = spinY;

            // --- Reset Foul Tracking flags for the new shot ---
            // (Also reset in LBUTTONUP, but good to ensure here too)
            firstHitBallIdThisShot = -1;      // No ball hit yet
            cueHitObjectBallThisShot = false; // Cue hasn't hit anything yet
            railHitAfterContact = false;     // No rail hit after contact yet
            // --- End Reset ---

                    // If this was the opening break shot, clear the flag
            if (isOpeningBreakShot) {
                isOpeningBreakShot = false; // Mark opening break as taken
            }
        }
    }


    // ---------------------------------------------------------------------
    //  ProcessShotResults()
    // ---------------------------------------------------------------------
    void ProcessShotResults() {
        bool cueBallPocketed = false;
        bool eightBallPocketed = false;
        bool playerContinuesTurn = false;

        // --- Step 1: Update Ball Counts FIRST (THE CRITICAL FIX) ---
        // We must update the score before any other game logic runs.
        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        int ownBallsPocketedThisTurn = 0;

        for (int id : pocketedThisTurn) {
            Ball* b = GetBallById(id);
            if (!b) continue;

            if (b->id == 0) {
                cueBallPocketed = true;
            }
            else if (b->id == 8) {
                eightBallPocketed = true;
            }
            else {
                // This is a numbered ball. Update the pocketed count for the correct player.
                if (b->type == player1Info.assignedType && player1Info.assignedType != BallType::NONE) {
                    player1Info.ballsPocketedCount++;
                }
                else if (b->type == player2Info.assignedType && player2Info.assignedType != BallType::NONE) {
                    player2Info.ballsPocketedCount++;
                }

                if (b->type == shootingPlayer.assignedType) {
                    ownBallsPocketedThisTurn++;
                }
            }
        }

        if (ownBallsPocketedThisTurn > 0) {
            playerContinuesTurn = true;
        }

        // --- Step 2: Handle Game-Ending 8-Ball Shot ---
        // Now that the score is updated, this check will have the correct information.
        if (eightBallPocketed) {
            CheckGameOverConditions(true, cueBallPocketed);
            if (currentGameState == GAME_OVER) {
                pocketedThisTurn.clear();
                return;
            }
        }

        // --- Step 3: Check for Fouls ---
        bool turnFoul = false;
        if (cueBallPocketed) {
            turnFoul = true;
        }
        else {
            Ball* firstHit = GetBallById(firstHitBallIdThisShot);
            if (!firstHit) { // Rule: Hitting nothing is a foul.
                turnFoul = true;
            }
            else { // Rule: Hitting the wrong ball type is a foul.
                if (player1Info.assignedType != BallType::NONE) { // Colors are assigned.
                    // We check if the player WAS on the 8-ball BEFORE this shot.
                    bool wasOnEightBall = (shootingPlayer.assignedType != BallType::NONE && (shootingPlayer.ballsPocketedCount - ownBallsPocketedThisTurn) >= 7);
                    if (wasOnEightBall) {
                        if (firstHit->id != 8) turnFoul = true;
                    }
                    else {
                        if (firstHit->type != shootingPlayer.assignedType) turnFoul = true;
                    }
                }
            }
        } //reenable below disabled for debugging
        //if (!turnFoul && cueHitObjectBallThisShot && !railHitAfterContact && pocketedThisTurn.empty()) {
            //turnFoul = true;
        //}
        foulCommitted = turnFoul;

        // --- Step 4: Final State Transition ---
        if (foulCommitted) {
            SwitchTurns();
            RespawnCueBall(false);
        }
        else if (player1Info.assignedType == BallType::NONE && !pocketedThisTurn.empty() && !cueBallPocketed) {
            // Assign types on the break.
            for (int id : pocketedThisTurn) {
                Ball* b = GetBallById(id);
                if (b && b->type != BallType::EIGHT_BALL) {
                    AssignPlayerBallTypes(b->type);
                    break;
                }
            }
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else if (playerContinuesTurn) {
            // The player's turn continues. Now the check will work correctly.
            CheckAndTransitionToPocketChoice(currentPlayer);
        }
        else {
            SwitchTurns();
        }

        pocketedThisTurn.clear();
    }

    /*
    // --- Step 3: Final State Transition ---
    if (foulCommitted) {
        SwitchTurns();
        RespawnCueBall(false);
    }
    else if (playerContinuesTurn) {
        CheckAndTransitionToPocketChoice(currentPlayer);
    }
    else {
        SwitchTurns();
    }

    pocketedThisTurn.clear();
    } */

    //  Assign groups AND optionally give the shooter his first count.
    bool AssignPlayerBallTypes(BallType firstPocketedType, bool creditShooter /*= true*/)
    {
        if (firstPocketedType != SOLID && firstPocketedType != STRIPE)
            return false;                                 // safety

        /* ---------------------------------------------------------
           1.  Decide the groups
        --------------------------------------------------------- */
        if (currentPlayer == 1)
        {
            player1Info.assignedType = firstPocketedType;
            player2Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }
        else
        {
            player2Info.assignedType = firstPocketedType;
            player1Info.assignedType =
                (firstPocketedType == SOLID) ? STRIPE : SOLID;
        }

        /* ---------------------------------------------------------
           2.  Count the very ball that made the assignment
        --------------------------------------------------------- */
        if (creditShooter)
        {
            if (currentPlayer == 1)
                ++player1Info.ballsPocketedCount;
            else
                ++player2Info.ballsPocketedCount;
        }
        return true;
    }

    /*bool AssignPlayerBallTypes(BallType firstPocketedType) {
        if (firstPocketedType == BallType::SOLID || firstPocketedType == BallType::STRIPE) {
            if (currentPlayer == 1) {
                player1Info.assignedType = firstPocketedType;
                player2Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            else {
                player2Info.assignedType = firstPocketedType;
                player1Info.assignedType = (firstPocketedType == BallType::SOLID) ? BallType::STRIPE : BallType::SOLID;
            }
            return true; // Assignment was successful
        }
        return false; // No assignment made (e.g., 8-ball was pocketed on break)
    }*/
    // If 8-ball was first (illegal on break generally), rules vary.
    // Here, we might ignore assignment until a solid/stripe is pocketed legally.
    // Or assign based on what *else* was pocketed, if anything.
    // Simplification: Assignment only happens on SOLID or STRIPE first pocket.


    // --- Called in ProcessShotResults() after pocket detection ---
    void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        // Only care if the 8?ball really went in:
        if (!eightBallPocketed) return;

        // Who’s shooting now?
        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        // Which pocket did we CALL?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did it ACTUALLY fall into?
        int actual = lastEightBallPocketIndex;

        // Check legality: must have called a pocket ?0, must match actual,
        // must have pocketed all 7 of your balls first, and must not have scratched.
        bool legal = (called >= 0)
            && (called == actual)
            && (shooter.ballsPocketedCount >= 7)
            && (!cueBallPocketed);

        // Build a message that shows both values for debugging/tracing:
        if (legal) {
            gameOverMessage = shooter.name
                + L"" Wins! ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name
                + L"" Wins! (Illegal 8-Ball) ""
                + L""(Called: "" + std::to_wstring(called)
                + L"", Actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }



    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return;

        PlayerInfo& shootingPlayer = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponentPlayer = (currentPlayer == 1) ? player2Info : player1Info;

        // Handle 8-ball on break: re-spot and continue.
        if (player1Info.assignedType == BallType::NONE) {
            Ball* b = GetBallById(8);
            if (b) { b->isPocketed = false; b->x = RACK_POS_X; b->y = RACK_POS_Y; b->vx = b->vy = 0; }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // --- FOOLPROOF WIN/LOSS LOGIC ---
        bool wasOnEightBall = IsPlayerOnEightBall(currentPlayer);
        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = -1;

        // Find which pocket the 8-ball actually went into.
        for (int id : pocketedThisTurn) {
            if (id == 8) {
                Ball* b = GetBallById(8); // This ball is already marked as pocketed, but we need its last coords.
                if (b) {
                    for (int p_idx = 0; p_idx < 6; ++p_idx) {
                        // Check last known position against pocket centers
                        if (GetDistanceSq(b->x, b->y, pocketPositions[p_idx].x, pocketPositions[p_idx].y) < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                            actualPocket = p_idx;
                            break;
                        }
                    }
                }
                break;
            }
        }

        // Evaluate win/loss based on a clear hierarchy of rules.
        if (!wasOnEightBall) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball Pocketed Early)"";
        }
        else if (cueBallPocketed) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Scratched on 8-Ball)"";
        }
        else if (calledPocket == -1) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (Pocket Not Called)"";
        }
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponentPlayer.name + L"" Wins! (8-Ball in Wrong Pocket)"";
        }
        else {
            // WIN! All loss conditions failed, this must be a legal win.
            gameOverMessage = shootingPlayer.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    }*/

    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        // Which pocket did we call?
        int called = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        // Which pocket did the ball really fall into?
        int actual = lastEightBallPocketIndex;

        // Legal victory only if:
        //  1) Shooter had already pocketed 7 of their object balls,
        //  2) They called a pocket,
        //  3) The 8?ball actually fell into that same pocket,
        //  4) They did not scratch on the 8?ball.
        bool legal =
            (shooter.ballsPocketedCount >= 7) &&
            (called >= 0) &&
            (called == actual) &&
            (!cueBallPocketed);

        if (legal) {
            gameOverMessage = shooter.name + L"" Wins! ""
                L""(called: "" + std::to_wstring(called) +
                L"", actual: "" + std::to_wstring(actual) + L"")"";
        }
        else {
            gameOverMessage = opponent.name + L"" Wins! (illegal 8-ball) ""
            // For debugging you can append:
            + L"" (called: "" + std::to_wstring(called)
            + L"", actual: "" + std::to_wstring(actual) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    // ????????????????????????????????????????????????????????????????
    //  CheckGameOverConditions()
    //     – Called when the 8-ball has fallen.
    //     – Decides who wins and builds the gameOverMessage.
    // ????????????????????????????????????????????????????????????????
    /*void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed)
    {
        if (!eightBallPocketed) return;                     // safety

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;

        int calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int actualPocket = lastEightBallPocketIndex;

        bool clearedSeven = (shooter.ballsPocketedCount >= 7);
        bool noScratch = !cueBallPocketed;
        bool callMade = (calledPocket >= 0);

        // helper ? turn “-1” into ""None"" for readability
        auto pocketToStr = [](int idx) -> std::wstring
        {
            return (idx >= 0) ? std::to_wstring(idx) : L""None"";
        };

        if (clearedSeven && noScratch && callMade && actualPocket == calledPocket)
        {
            // legitimate win
            gameOverMessage =
                shooter.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }
        else
        {
            // wrong pocket, scratch, or early 8-ball
            gameOverMessage =
                opponent.name +
                L"" Wins! (Called pocket: "" + pocketToStr(calledPocket) +
                L"", Actual pocket: "" + pocketToStr(actualPocket) + L"")"";
        }

        currentGameState = GAME_OVER;
    }*/

    /* void CheckGameOverConditions(bool eightBallPocketed, bool cueBallPocketed) {
        if (!eightBallPocketed) return; // Only when 8-ball actually pocketed

        PlayerInfo& shooter = (currentPlayer == 1) ? player1Info : player2Info;
        PlayerInfo& opponent = (currentPlayer == 1) ? player2Info : player1Info;
        bool      onEightRoll = IsPlayerOnEightBall(currentPlayer);
        int       calledPocket = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        int       actualPocket = -1;
        Ball* bEight = GetBallById(8);

        // locate which hole the 8-ball went into
        if (bEight) {
            for (int i = 0; i < 6; ++i) {
                if (GetDistanceSq(bEight->x, bEight->y,
                    pocketPositions[i].x, pocketPositions[i].y)
                    < POCKET_RADIUS * POCKET_RADIUS * 1.5f) {
                    actualPocket = i; break;
                }
            }
        }

        // 1) On break / pre-assignment: re-spot & continue
        if (player1Info.assignedType == BallType::NONE) {
            if (bEight) {
                bEight->isPocketed = false;
                bEight->x = RACK_POS_X; bEight->y = RACK_POS_Y;
                bEight->vx = bEight->vy = 0;
            }
            if (cueBallPocketed) foulCommitted = true;
            return;
        }

        // 2) Loss if pocketed 8 early
        if (!onEightRoll) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" pocketed 8-ball early)"";
        }
        // 3) Loss if scratched
        else if (cueBallPocketed) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" scratched on 8-ball)"";
        }
        // 4) Loss if no pocket call
        else if (calledPocket < 0) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" did not call a pocket)"";
        }
        // 5) Loss if in wrong pocket
        else if (actualPocket != calledPocket) {
            gameOverMessage = opponent.name + L"" Wins! ("" + shooter.name + L"" 8-ball in wrong pocket)"";
        }
        // 6) Otherwise, valid win
        else {
            gameOverMessage = shooter.name + L"" Wins!"";
        }

        currentGameState = GAME_OVER;
    } */


    // Switch the shooter, handle fouls and decide what state we go to next.
    // ────────────────────────────────────────────────────────────────
    //  SwitchTurns – final version (arrow–leak bug fixed)
    // ────────────────────────────────────────────────────────────────
    void SwitchTurns()
    {
        /* --------------------------------------------------------- */
        /* 1.  Hand the table over to the other player               */
        /* --------------------------------------------------------- */
        currentPlayer = (currentPlayer == 1) ? 2 : 1;

        /* --------------------------------------------------------- */
        /* 2.  Generic per–turn resets                               */
        /* --------------------------------------------------------- */
        isAiming = false;
        shotPower = 0.0f;
        currentlyHoveredPocket = -1;

        /* --------------------------------------------------------- */
        /* 3.  Wipe every previous pocket call                       */
        /*    (the new shooter will choose again if needed)          */
        /* --------------------------------------------------------- */
        calledPocketP1 = -1;
        calledPocketP2 = -1;
        pocketCallMessage.clear();

        /* --------------------------------------------------------- */
        /* 4.  Handle fouls — cue-ball in hand overrides everything  */
        /* --------------------------------------------------------- */
        if (foulCommitted)
        {
            if (currentPlayer == 1)            // human
            {
                currentGameState = BALL_IN_HAND_P1;
                aiTurnPending = false;
            }
            else                               // P2
            {
                currentGameState = BALL_IN_HAND_P2;
                aiTurnPending = isPlayer2AI;   // AI will place cue-ball
            }

            foulCommitted = false;
            return;                            // we're done for this frame
        }

        /* --------------------------------------------------------- */
        /* 5.  Normal flow                                           */
        /*    Will put us in  ∘ PLAYER?_TURN                         */
        /*                    ∘ CHOOSING_POCKET_P?                   */
        /*                    ∘ AI_THINKING  (for CPU)               */
        /* --------------------------------------------------------- */
        CheckAndTransitionToPocketChoice(currentPlayer);
    }


    void AIBreakShot() {
        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        // This function is called when it's AI's turn for the opening break and state is PRE_BREAK_PLACEMENT.
        // AI will place the cue ball and then plan the shot.
        if (isOpeningBreakShot && currentGameState == PRE_BREAK_PLACEMENT) {
            // Place cue ball in the kitchen randomly
            /*float kitchenMinX = TABLE_LEFT + BALL_RADIUS; // [cite: 1071, 1072, 1587]
            float kitchenMaxX = HEADSTRING_X - BALL_RADIUS; // [cite: 1072, 1078, 1588]
            float kitchenMinY = TABLE_TOP + BALL_RADIUS; // [cite: 1071, 1072, 1588]
            float kitchenMaxY = TABLE_BOTTOM - BALL_RADIUS; // [cite: 1072, 1073, 1589]*/

            // --- AI Places Cue Ball for Break ---
    // Decide if placing center or side. For simplicity, let's try placing slightly off-center
    // towards one side for a more angled break, or center for direct apex hit.
    // A common strategy is to hit the second ball of the rack.

            float placementY = RACK_POS_Y; // Align vertically with the rack center
            float placementX;

            // Randomly choose a side or center-ish placement for variation.
            int placementChoice = rand() % 3; // 0: Left-ish, 1: Center-ish, 2: Right-ish in kitchen

            if (placementChoice == 0) { // Left-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) - (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the left within kitchen
            }
            else if (placementChoice == 2) { // Right-ish
                placementX = HEADSTRING_X - (TABLE_WIDTH * 0.05f) + (BALL_RADIUS * (1 + (rand() % 3))); // Place slightly to the right within kitchen
            }
            else { // Center-ish
                placementX = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // Roughly center of kitchen
            }
            placementX = std::max(TABLE_LEFT + BALL_RADIUS + 1.0f, std::min(placementX, HEADSTRING_X - BALL_RADIUS - 1.0f)); // Clamp within kitchen X

            bool validPos = false;
            int attempts = 0;
            while (!validPos && attempts < 100) {
                /*cueBall->x = kitchenMinX + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxX - kitchenMinX)); // [cite: 1589]
                cueBall->y = kitchenMinY + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX) / (kitchenMaxY - kitchenMinY)); // [cite: 1590]
                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1591]
                    validPos = true; // [cite: 1591]*/
                    // Try the chosen X, but vary Y slightly to find a clear spot
                cueBall->x = placementX;
                cueBall->y = placementY + (static_cast<float>(rand() % 100 - 50) / 100.0f) * BALL_RADIUS * 2.0f; // Vary Y a bit
                cueBall->y = std::max(TABLE_TOP + BALL_RADIUS + 1.0f, std::min(cueBall->y, TABLE_BOTTOM - BALL_RADIUS - 1.0f)); // Clamp Y

                if (IsValidCueBallPosition(cueBall->x, cueBall->y, true /* behind headstring */)) {
                    validPos = true;
                }
                attempts++; // [cite: 1592]
            }
            if (!validPos) {
                // Fallback position
                /*cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.5f; // [cite: 1071, 1078, 1593]
                cueBall->y = (TABLE_TOP + TABLE_BOTTOM) * 0.5f; // [cite: 1071, 1073, 1594]
                if (!IsValidCueBallPosition(cueBall->x, cueBall->y, true)) { // [cite: 1594]
                    cueBall->x = HEADSTRING_X - BALL_RADIUS * 2; // [cite: 1072, 1078, 1594]
                    cueBall->y = RACK_POS_Y; // [cite: 1080, 1595]
                }
            }
            cueBall->vx = 0; // [cite: 1595]
            cueBall->vy = 0; // [cite: 1596]

            // Plan a break shot: aim at the center of the rack (apex ball)
            float targetX = RACK_POS_X; // [cite: 1079] Aim for the apex ball X-coordinate
            float targetY = RACK_POS_Y; // [cite: 1080] Aim for the apex ball Y-coordinate

            float dx = targetX - cueBall->x; // [cite: 1599]
            float dy = targetY - cueBall->y; // [cite: 1600]
            float shotAngle = atan2f(dy, dx); // [cite: 1600]
            float shotPowerValue = MAX_SHOT_POWER; // [cite: 1076, 1600] Use MAX_SHOT_POWER*/

                cueBall->x = TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) * 0.75f; // A default safe spot in kitchen
                cueBall->y = RACK_POS_Y;
            }
            cueBall->vx = 0; cueBall->vy = 0;

            // --- AI Plans the Break Shot ---
            float targetX, targetY;
            // If cue ball is near center of kitchen width, aim for apex.
            // Otherwise, aim for the second ball on the side the cue ball is on (for a cut break).
            float kitchenCenterRegion = (HEADSTRING_X - TABLE_LEFT) * 0.3f; // Define a ""center"" region
            if (std::abs(cueBall->x - (TABLE_LEFT + (HEADSTRING_X - TABLE_LEFT) / 2.0f)) < kitchenCenterRegion / 2.0f) {
                // Center-ish placement: Aim for the apex ball (ball ID 1 or first ball in rack)
                targetX = RACK_POS_X; // Apex ball X
                targetY = RACK_POS_Y; // Apex ball Y
            }
            else {
                // Side placement: Aim to hit the ""second"" ball of the rack for a wider spread.
                // This is a simplification. A more robust way is to find the actual second ball.
                // For now, aim slightly off the apex towards the side the cue ball is on.
                targetX = RACK_POS_X + BALL_RADIUS * 2.0f * 0.866f; // X of the second row of balls
                targetY = RACK_POS_Y + ((cueBall->y > RACK_POS_Y) ? -BALL_RADIUS : BALL_RADIUS); // Aim at the upper or lower of the two second-row balls
            }

            float dx = targetX - cueBall->x;
            float dy = targetY - cueBall->y;
            float shotAngle = atan2f(dy, dx);
            float shotPowerValue = MAX_SHOT_POWER * (0.9f + (rand() % 11) / 100.0f); // Slightly vary max power

            // Store planned shot details for the AI
            /*aiPlannedShotDetails.angle = shotAngle; // [cite: 1102, 1601]
            aiPlannedShotDetails.power = shotPowerValue; // [cite: 1102, 1601]
            aiPlannedShotDetails.spinX = 0.0f; // [cite: 1102, 1601] No spin for a standard power break
            aiPlannedShotDetails.spinY = 0.0f; // [cite: 1103, 1602]
            aiPlannedShotDetails.isValid = true; // [cite: 1103, 1602]*/

            aiPlannedShotDetails.angle = shotAngle;
            aiPlannedShotDetails.power = shotPowerValue;
            aiPlannedShotDetails.spinX = 0.0f; // No spin for break usually
            aiPlannedShotDetails.spinY = 0.0f;
            aiPlannedShotDetails.isValid = true;

            // Update global cue parameters for immediate visual feedback if DrawAimingAids uses them
            /*::cueAngle = aiPlannedShotDetails.angle;      // [cite: 1109, 1603] Update global cueAngle
            ::shotPower = aiPlannedShotDetails.power;     // [cite: 1109, 1604] Update global shotPower
            ::cueSpinX = aiPlannedShotDetails.spinX;    // [cite: 1109]
            ::cueSpinY = aiPlannedShotDetails.spinY;    // [cite: 1110]*/

            ::cueAngle = aiPlannedShotDetails.angle;
            ::shotPower = aiPlannedShotDetails.power;
            ::cueSpinX = aiPlannedShotDetails.spinX;
            ::cueSpinY = aiPlannedShotDetails.spinY;

            // Set up for AI display via GameUpdate
            /*aiIsDisplayingAim = true;                   // [cite: 1104] Enable AI aiming visualization
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES; // [cite: 1105] Set duration for display

            currentGameState = AI_THINKING; // [cite: 1081] Transition to AI_THINKING state.
                                            // GameUpdate will handle the aiAimDisplayFramesLeft countdown
                                            // and then execute the shot using aiPlannedShotDetails.
                                            // isOpeningBreakShot will be set to false within ApplyShot.

            // No immediate ApplyShot or sound here; GameUpdate's AI execution logic will handle it.*/

            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;
            currentGameState = AI_THINKING; // State changes to AI_THINKING, GameUpdate will handle shot execution after display
            aiTurnPending = false;

            return; // The break shot is now planned and will be executed by GameUpdate
        }

        // 2. If not in PRE_BREAK_PLACEMENT (e.g., if this function were called at other times,
        //    though current game logic only calls it for PRE_BREAK_PLACEMENT)
        //    This part can be extended if AIBreakShot needs to handle other scenarios.
        //    For now, the primary logic is above.
    }

    // --- Helper Functions ---

    Ball* GetBallById(int id) {
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id == id) {
                return &balls[i];
            }
        }
        return nullptr;
    }

    Ball* GetCueBall() {
        return GetBallById(0);
    }

    float GetDistance(float x1, float y1, float x2, float y2) {
        return sqrtf(GetDistanceSq(x1, y1, x2, y2));
    }

    float GetDistanceSq(float x1, float y1, float x2, float y2) {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    bool IsValidCueBallPosition(float x, float y, bool checkHeadstring) {
        // Basic bounds check (inside cushions)
        float left = TABLE_LEFT + CUSHION_THICKNESS + BALL_RADIUS;
        float right = TABLE_RIGHT - CUSHION_THICKNESS - BALL_RADIUS;
        float top = TABLE_TOP + CUSHION_THICKNESS + BALL_RADIUS;
        float bottom = TABLE_BOTTOM - CUSHION_THICKNESS - BALL_RADIUS;

        if (x < left || x > right || y < top || y > bottom) {
            return false;
        }

        // Check headstring restriction if needed
        if (checkHeadstring && x >= HEADSTRING_X) {
            return false;
        }

        // Check overlap with other balls
        for (size_t i = 0; i < balls.size(); ++i) {
            if (balls[i].id != 0 && !balls[i].isPocketed) { // Don't check against itself or pocketed balls
                if (GetDistanceSq(x, y, balls[i].x, balls[i].y) < (BALL_RADIUS * 2.0f) * (BALL_RADIUS * 2.0f)) {
                    return false; // Overlapping another ball
                }
            }
        }

        return true;
    }

    // --- NEW HELPER FUNCTION IMPLEMENTATIONS ---

    // Checks if a player has pocketed all their balls and is now on the 8-ball.
    bool IsPlayerOnEightBall(int player) {
        PlayerInfo& playerInfo = (player == 1) ? player1Info : player2Info;
        if (playerInfo.assignedType != BallType::NONE && playerInfo.assignedType != BallType::EIGHT_BALL && playerInfo.ballsPocketedCount >= 7) {
            Ball* eightBall = GetBallById(8);
            return (eightBall && !eightBall->isPocketed);
        }
        return false;
    }

    void CheckAndTransitionToPocketChoice(int playerID) {
        bool needsToCall = IsPlayerOnEightBall(playerID);

        if (needsToCall) {
            if (playerID == 1) { // Human Player 1
                currentGameState = CHOOSING_POCKET_P1;
                pocketCallMessage = player1Info.name + L"": Choose a pocket for the 8-Ball..."";
                if (calledPocketP1 == -1) calledPocketP1 = 2; // Default to bottom-right
            }
            else { // Player 2
                if (isPlayer2AI) {
                    // FOOLPROOF FIX: AI doesn't choose here. It transitions to a thinking state.
                    // AIMakeDecision will handle the choice and the pocket call.
                    currentGameState = AI_THINKING;
                    aiTurnPending = true; // Signal the main loop to run AIMakeDecision
                }
                else { // Human Player 2
                    currentGameState = CHOOSING_POCKET_P2;
                    pocketCallMessage = player2Info.name + L"": Choose a pocket for the 8-Ball..."";
                    if (calledPocketP2 == -1) calledPocketP2 = 2; // Default to bottom-right
                }
            }
        }
        else {
            // Player does not need to call a pocket, proceed to normal turn.
            pocketCallMessage = L"""";
            currentGameState = (playerID == 1) ? PLAYER1_TURN : PLAYER2_TURN;
            if (playerID == 2 && isPlayer2AI) {
                aiTurnPending = true;
            }
        }
    }


    template <typename T>
    void SafeRelease(T** ppT) {
        if (*ppT) {
            (*ppT)->Release();
            *ppT = nullptr;
        }
    }

    // --- CPU Ball?in?Hand Placement --------------------------------
    // Moves the cue ball to a legal ""ball in hand"" position for the AI.
    void AIPlaceCueBall() {
        Ball* cue = GetCueBall();
        if (!cue) return;

        // Simple strategy: place back behind the headstring at the standard break spot
        cue->x = TABLE_LEFT + TABLE_WIDTH * 0.15f;
        cue->y = RACK_POS_Y;
        cue->vx = cue->vy = 0.0f;
    }

    // --- Helper Function for Line Segment Intersection ---
    // Finds intersection point of line segment P1->P2 and line segment P3->P4
    // Returns true if they intersect, false otherwise. Stores intersection point in 'intersection'.
    bool LineSegmentIntersection(D2D1_POINT_2F p1, D2D1_POINT_2F p2, D2D1_POINT_2F p3, D2D1_POINT_2F p4, D2D1_POINT_2F& intersection)
    {
        float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);

        // Check if lines are parallel or collinear
        if (fabs(denominator) < 1e-6) {
            return false;
        }

        float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

        // Check if intersection point lies on both segments
        if (ua >= 0.0f && ua <= 1.0f && ub >= 0.0f && ub <= 1.0f) {
            intersection.x = p1.x + ua * (p2.x - p1.x);
            intersection.y = p1.y + ua * (p2.y - p1.y);
            return true;
        }

        return false;
    }

    // --- INSERT NEW HELPER FUNCTION HERE ---
    // Calculates the squared distance from point P to the line segment AB.
    float PointToLineSegmentDistanceSq(D2D1_POINT_2F p, D2D1_POINT_2F a, D2D1_POINT_2F b) {
        float l2 = GetDistanceSq(a.x, a.y, b.x, b.y);
        if (l2 == 0.0f) return GetDistanceSq(p.x, p.y, a.x, a.y); // Segment is a point
        // Consider P projecting onto the line AB infinite line
        // t = [(P-A) . (B-A)] / |B-A|^2
        float t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
        t = std::max(0.0f, std::min(1.0f, t)); // Clamp t to the segment [0, 1]
        // Projection falls on the segment
        D2D1_POINT_2F projection = D2D1::Point2F(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
        return GetDistanceSq(p.x, p.y, projection.x, projection.y);
    }
    // --- End New Helper ---

    // --- NEW AI Implementation Functions ---

    void AIMakeDecision() {
        // Start with a clean slate for the AI's plan.
        aiPlannedShotDetails.isValid = false;
        Ball* cueBall = GetCueBall();
        if (!cueBall || !isPlayer2AI || currentPlayer != 2) return;

        // Ask the ""expert"" (AIFindBestShot) for the best possible shot.
        AIShotInfo bestShot = AIFindBestShot();

        if (bestShot.possible) {
            // A good shot was found.
            // If it's an 8-ball shot, ""call"" the pocket.
            if (bestShot.involves8Ball) {
                calledPocketP2 = bestShot.pocketIndex;
            }
            else {
                calledPocketP2 = -1; // Ensure no pocket is called on a normal shot.
            }

            // Commit the details of the best shot to the AI's plan.
            aiPlannedShotDetails.angle = bestShot.angle;
            aiPlannedShotDetails.power = bestShot.power;
            aiPlannedShotDetails.spinX = bestShot.spinX;
            aiPlannedShotDetails.spinY = bestShot.spinY;
            aiPlannedShotDetails.isValid = true;

        }
        else {
            // No good offensive shot found, must play a safe defensive shot.
            // (This is a fallback and your current AIFindBestShot should prevent this)
            aiPlannedShotDetails.isValid = false;
        }

        // --- FOOLPROOF FIX: Trigger the Aim Display ---
        // If any valid plan was made, update the visuals and start the display pause.
        if (aiPlannedShotDetails.isValid) {

            // STEP 1: Copy the AI's plan into the global variables used for drawing.
            // This is the critical missing link.
            cueAngle = aiPlannedShotDetails.angle;
            shotPower = aiPlannedShotDetails.power;

            // STEP 2: Trigger the visual display pause.
            // These are the two lines you correctly identified.
            aiIsDisplayingAim = true;
            aiAimDisplayFramesLeft = AI_AIM_DISPLAY_DURATION_FRAMES;

        }
        else {
            // Absolute fallback: If no plan could be made, switch turns to prevent a freeze.
            SwitchTurns();
        }
    }


    AIShotInfo AIFindBestShot()
    {
        AIShotInfo best;                       // .possible == false
        Ball* cue = GetCueBall();
        if (!cue) return best;

        const bool on8 = IsPlayerOnEightBall(2);
        const BallType wantType = player2Info.assignedType;

        for (Ball& b : balls)
        {
            if (b.isPocketed || b.id == 0) continue;

            // decide if this ball is a legal/interesting target
            bool ok =
                on8 ? (b.id == 8) :
                ((wantType == BallType::NONE) || (b.type == wantType));

            if (!ok) continue;

            for (int p = 0; p < 6; ++p)
            {
                AIShotInfo cand = EvaluateShot(&b, p);
                if (cand.possible &&
                    (!best.possible || cand.score > best.score))
                    best = cand;
            }
        }

        // fall-back: tap cue ball forward (safety) if no potting line exists
        if (!best.possible && cue)
        {
            best.possible = true;
            best.angle = static_cast<float>(rand()) / RAND_MAX * 2.0f * PI;
            best.power = MAX_SHOT_POWER * 0.30f;
            best.spinX = best.spinY = 0.0f;
            best.targetBall = nullptr;
            best.score = -99999.0f;
            best.pocketIndex = -1;
        }
        return best;
    }


    // Evaluate a potential shot at a specific target ball towards a specific pocket
    AIShotInfo EvaluateShot(Ball* targetBall, int pocketIndex) {
        AIShotInfo shotInfo; // Defaults to not possible
        shotInfo.targetBall = targetBall;
        shotInfo.pocketIndex = pocketIndex;
        shotInfo.involves8Ball = (targetBall && targetBall->id == 8);

        Ball* cueBall = GetCueBall();
        if (!cueBall || !targetBall) return shotInfo;

        // 1. Calculate Ghost Ball position (where cue must hit target)
        shotInfo.ghostBallPos = CalculateGhostBallPos(targetBall, pocketIndex);

        // 2. Check Path: Cue Ball -> Ghost Ball Position
        if (!IsPathClear(D2D1::Point2F(cueBall->x, cueBall->y), shotInfo.ghostBallPos, cueBall->id, targetBall->id)) {
            return shotInfo; // Path blocked, shot is impossible.
        }

        // 3. Calculate Angle and Power
        float dx = shotInfo.ghostBallPos.x - cueBall->x;
        float dy = shotInfo.ghostBallPos.y - cueBall->y;
        shotInfo.angle = atan2f(dy, dx);

        float cueToGhostDist = GetDistance(cueBall->x, cueBall->y, shotInfo.ghostBallPos.x, shotInfo.ghostBallPos.y);
        float targetToPocketDist = GetDistance(targetBall->x, targetBall->y, pocketPositions[pocketIndex].x, pocketPositions[pocketIndex].y);
        shotInfo.power = CalculateShotPower(cueToGhostDist, targetToPocketDist);

        // 4. Score the shot (simple scoring: closer and straighter is better)
        shotInfo.score = 1000.0f - (cueToGhostDist + targetToPocketDist);

        // If we reached here, the shot is geometrically possible.
        shotInfo.possible = true;
        return shotInfo;
    }


    //  Estimate the power that will carry the cue-ball to the ghost position
    //  *and* push the object-ball the remaining distance to the pocket.
    //
    //  • cueToGhostDist    – pixels from cue to ghost-ball centre
    //  • targetToPocketDist– pixels from object-ball to chosen pocket
    //
    //  The function is fully deterministic (good for AI search) yet produces
    //  human-looking power levels.
    //
    float CalculateShotPower(float cueToGhostDist, float targetToPocketDist)
    {
        // Total distance the *energy* must cover (cue path + object-ball path)
        float totalDist = cueToGhostDist + targetToPocketDist;

        // Typical diagonal of the playable area (approx.) – used for scaling
        constexpr float TABLE_DIAG = 900.0f;

        // 1.  Convert distance to a 0-1 number (0: tap-in, 1: table length)
        float norm = std::clamp(totalDist / TABLE_DIAG, 0.0f, 1.0f);

        // 2.  Ease-in curve (smoothstep) for nicer progression
        norm = norm * norm * (3.0f - 2.0f * norm);

        // 3.  Blend between a gentle minimum and the absolute maximum
        const float MIN_POWER = MAX_SHOT_POWER * 0.18f;     // just enough to move
        float power = MIN_POWER + norm * (MAX_SHOT_POWER - MIN_POWER);

        // 4.  Safety clamp (also screens out degenerate calls)
        power = std::clamp(power, 0.15f, MAX_SHOT_POWER);

        return power;
    }

    // ------------------------------------------------------------------
    //  Return the ghost-ball centre needed for the target ball to roll
    //  straight into the chosen pocket.
    // ------------------------------------------------------------------
    D2D1_POINT_2F CalculateGhostBallPos(Ball* targetBall, int pocketIndex)
    {
        if (!targetBall) return D2D1::Point2F(0, 0);

        D2D1_POINT_2F P = pocketPositions[pocketIndex];

        float vx = P.x - targetBall->x;
        float vy = P.y - targetBall->y;
        float L = sqrtf(vx * vx + vy * vy);
        if (L < 1.0f) L = 1.0f;                // safety

        vx /= L;   vy /= L;

        return D2D1::Point2F(
            targetBall->x - vx * (BALL_RADIUS * 2.0f),
            targetBall->y - vy * (BALL_RADIUS * 2.0f));
    }

    // Calculate the position the cue ball needs to hit for the target ball to go towards the pocket
    // ────────────────────────────────────────────────────────────────
    //   2.  Shot evaluation & search
    // ────────────────────────────────────────────────────────────────

    //  Calculate ghost-ball position so that cue hits target towards pocket
    static inline D2D1_POINT_2F GhostPos(const Ball* tgt, int pocketIdx)
    {
        D2D1_POINT_2F P = pocketPositions[pocketIdx];
        float vx = P.x - tgt->x;
        float vy = P.y - tgt->y;
        float L = sqrtf(vx * vx + vy * vy);
        vx /= L;  vy /= L;
        return D2D1::Point2F(tgt->x - vx * (BALL_RADIUS * 2.0f),
            tgt->y - vy * (BALL_RADIUS * 2.0f));
    }

    //  Heuristic: shorter + straighter + proper group = higher score
    static inline float ScoreShot(float cue2Ghost,
        float tgt2Pocket,
        bool  correctGroup,
        bool  involves8)
    {
        float base = 2000.0f - (cue2Ghost + tgt2Pocket);   // prefer close shots
        if (!correctGroup)  base -= 400.0f;                  // penalty
        if (involves8)      base += 150.0f;                  // a bit more desirable
        return base;
    }

    // Checks if line segment is clear of obstructing balls
    // ────────────────────────────────────────────────────────────────
    //   1.  Low-level helpers – IsPathClear & FindFirstHitBall
    // ────────────────────────────────────────────────────────────────

    //  Test if the capsule [ start … end ] (radius = BALL_RADIUS)
    //  intersects any ball except the ids we want to ignore.
    bool IsPathClear(D2D1_POINT_2F start,
        D2D1_POINT_2F end,
        int ignoredBallId1,
        int ignoredBallId2)
    {
        float dx = end.x - start.x;
        float dy = end.y - start.y;
        float lenSq = dx * dx + dy * dy;
        if (lenSq < 1e-3f) return true;             // degenerate → treat as clear

        for (const Ball& b : balls)
        {
            if (b.isPocketed)      continue;
            if (b.id == ignoredBallId1 ||
                b.id == ignoredBallId2)             continue;

            // project ball centre onto the segment
            float t = ((b.x - start.x) * dx + (b.y - start.y) * dy) / lenSq;
            t = std::clamp(t, 0.0f, 1.0f);

            float cx = start.x + t * dx;
            float cy = start.y + t * dy;

            if (GetDistanceSq(b.x, b.y, cx, cy) < (BALL_RADIUS * BALL_RADIUS))
                return false;                       // blocked
        }
        return true;
    }

    //  Cast an (infinite) ray and return the first non-pocketed ball hit.
    //  `hitDistSq` is distance² from the start point to the collision point.
    Ball* FindFirstHitBall(D2D1_POINT_2F start,
        float        angle,
        float& hitDistSq)
    {
        Ball* hitBall = nullptr;
        float  bestSq = std::numeric_limits<float>::max();
        float  cosA = cosf(angle);
        float  sinA = sinf(angle);

        for (Ball& b : balls)
        {
            if (b.id == 0 || b.isPocketed) continue;         // ignore cue & sunk balls

            float relX = b.x - start.x;
            float relY = b.y - start.y;
            float proj = relX * cosA + relY * sinA;          // distance along the ray

            if (proj <= 0) continue;                         // behind cue

            // closest approach of the ray to the sphere centre
            float closestX = start.x + proj * cosA;
            float closestY = start.y + proj * sinA;
            float dSq = GetDistanceSq(b.x, b.y, closestX, closestY);

            if (dSq <= BALL_RADIUS * BALL_RADIUS)            // intersection
            {
                float back = sqrtf(BALL_RADIUS * BALL_RADIUS - dSq);
                float collDist = proj - back;                // front surface
                float collSq = collDist * collDist;
                if (collSq < bestSq)
                {
                    bestSq = collSq;
                    hitBall = &b;
                }
            }
        }
        hitDistSq = bestSq;
        return hitBall;
    }

    // Basic check for reasonable AI aim angles (optional)
    bool IsValidAIAimAngle(float angle) {
        // Placeholder - could check for NaN or infinity if calculations go wrong
        return isfinite(angle);
    }

    //midi func = start
    void PlayMidiInBackground(HWND hwnd, const TCHAR* midiPath) {
        while (isMusicPlaying) {
            MCI_OPEN_PARMS mciOpen = { 0 };
            mciOpen.lpstrDeviceType = TEXT(""sequencer"");
            mciOpen.lpstrElementName = midiPath;

            if (mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE | MCI_OPEN_ELEMENT, (DWORD_PTR)&mciOpen) == 0) {
                midiDeviceID = mciOpen.wDeviceID;

                MCI_PLAY_PARMS mciPlay = { 0 };
                mciSendCommand(midiDeviceID, MCI_PLAY, 0, (DWORD_PTR)&mciPlay);

                // Wait for playback to complete
                MCI_STATUS_PARMS mciStatus = { 0 };
                mciStatus.dwItem = MCI_STATUS_MODE;

                do {
                    mciSendCommand(midiDeviceID, MCI_STATUS, MCI_STATUS_ITEM, (DWORD_PTR)&mciStatus);
                    Sleep(100); // adjust as needed
                } while (mciStatus.dwReturn == MCI_MODE_PLAY && isMusicPlaying);

                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    void StartMidi(HWND hwnd, const TCHAR* midiPath) {
        if (isMusicPlaying) {
            StopMidi();
        }
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }

    void StopMidi() {
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) musicThread.join();
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }
    }

    /*void PlayGameMusic(HWND hwnd) {
        // Stop any existing playback
        if (isMusicPlaying) {
            isMusicPlaying = false;
            if (musicThread.joinable()) {
                musicThread.join();
            }
            if (midiDeviceID != 0) {
                mciSendCommand(midiDeviceID, MCI_CLOSE, 0, NULL);
                midiDeviceID = 0;
            }
        }

        // Get the path of the executable
        TCHAR exePath[MAX_PATH];
        GetModuleFileName(NULL, exePath, MAX_PATH);

        // Extract the directory path
        TCHAR* lastBackslash = _tcsrchr(exePath, '\\');
        if (lastBackslash != NULL) {
            *(lastBackslash + 1) = '\0';
        }

        // Construct the full path to the MIDI file
        static TCHAR midiPath[MAX_PATH];
        _tcscpy_s(midiPath, MAX_PATH, exePath);
        _tcscat_s(midiPath, MAX_PATH, TEXT(""BSQ.MID""));

        // Start the background playback
        isMusicPlaying = true;
        musicThread = std::thread(PlayMidiInBackground, hwnd, midiPath);
    }*/
    //midi func = end

    // --- Drawing Functions ---

    void OnPaint() {
        HRESULT hr = CreateDeviceResources(); // Ensure resources are valid

        if (SUCCEEDED(hr)) {
            pRenderTarget->BeginDraw();
            DrawScene(pRenderTarget); // Pass render target
            hr = pRenderTarget->EndDraw();

            if (hr == D2DERR_RECREATE_TARGET) {
                DiscardDeviceResources();
                // Optionally request another paint message: InvalidateRect(hwndMain, NULL, FALSE);
                // But the timer loop will trigger redraw anyway.
            }
        }
        // If CreateDeviceResources failed, EndDraw might not be called.
        // Consider handling this more robustly if needed.
    }

    void DrawScene(ID2D1RenderTarget* pRT) {
        if (!pRT) return;

        //pRT->Clear(D2D1::ColorF(D2D1::ColorF::LightGray)); // Background color
        // Set background color to #ffffcd (RGB: 255, 255, 205)
        pRT->Clear(D2D1::ColorF(0.3686f, 0.5333f, 0.3882f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)
        //pRT->Clear(D2D1::ColorF(1.0f, 1.0f, 0.803f)); // Clear with light yellow background NEWCOLOR 1.0f, 1.0f, 0.803f => (0.3686f, 0.5333f, 0.3882f)

        DrawTable(pRT, pFactory);
        DrawPocketSelectionIndicator(pRT); // Draw arrow over selected/called pocket
        DrawBalls(pRT);
        DrawAimingAids(pRT); // Includes cue stick if aiming
        DrawUI(pRT);
        DrawPowerMeter(pRT);
        DrawSpinIndicator(pRT);
        DrawPocketedBallsIndicator(pRT);
        DrawBallInHandIndicator(pRT); // Draw cue ball ghost if placing

         // Draw Game Over Message
        if (currentGameState == GAME_OVER && pTextFormat) {
            ID2D1SolidColorBrush* pBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pBrush);
            if (pBrush) {
                D2D1_RECT_F layoutRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP + TABLE_HEIGHT / 2 - 30, TABLE_RIGHT, TABLE_TOP + TABLE_HEIGHT / 2 + 30);
                pRT->DrawText(
                    gameOverMessage.c_str(),
                    (UINT32)gameOverMessage.length(),
                    pTextFormat, // Use large format maybe?
                    &layoutRect,
                    pBrush
                );
                SafeRelease(&pBrush);
            }
        }

    }

    void DrawTable(ID2D1RenderTarget* pRT, ID2D1Factory* pFactory) {
        ID2D1SolidColorBrush* pBrush = nullptr;

        // === Draw Full Orange Frame (Table Border) ===
        ID2D1SolidColorBrush* pFrameBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.9157f, 0.6157f, 0.2000f), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pFrameBrush); //NEWCOLOR ::Orange (no brackets) => (0.9157, 0.6157, 0.2000)
        if (pFrameBrush) {
            D2D1_RECT_F outerRect = D2D1::RectF(
                TABLE_LEFT - CUSHION_THICKNESS,
                TABLE_TOP - CUSHION_THICKNESS,
                TABLE_RIGHT + CUSHION_THICKNESS,
                TABLE_BOTTOM + CUSHION_THICKNESS
            );
            pRT->FillRectangle(&outerRect, pFrameBrush);
            SafeRelease(&pFrameBrush);
        }

        // Draw Table Bed (Green Felt)
        pRT->CreateSolidColorBrush(TABLE_COLOR, &pBrush);
        if (!pBrush) return;
        D2D1_RECT_F tableRect = D2D1::RectF(TABLE_LEFT, TABLE_TOP, TABLE_RIGHT, TABLE_BOTTOM);
        pRT->FillRectangle(&tableRect, pBrush);
        SafeRelease(&pBrush);

        // ------------------------------------------------------------------
//  Spotlight overlay (soft radial inside a rounded rectangle)
// ------------------------------------------------------------------
        {
            // 2.1  Build a radial gradient brush (edge = base cloth, centre = lighter)
            ID2D1RadialGradientBrush* pSpot = nullptr;
            ID2D1GradientStopCollection* pStops = nullptr;

            D2D1_COLOR_F centreClr = D2D1::ColorF(
                std::min(1.f, TABLE_COLOR.r * 1.60f),   // lighten ~60 %
                std::min(1.f, TABLE_COLOR.g * 1.60f),
                std::min(1.f, TABLE_COLOR.b * 1.60f));

            const D2D1_GRADIENT_STOP gs[3] =
            {
                { 0.0f, D2D1::ColorF(centreClr.r, centreClr.g, centreClr.b, 0.95f) },
                { 0.6f, D2D1::ColorF(TABLE_COLOR.r, TABLE_COLOR.g, TABLE_COLOR.b, 0.55f) },
                { 1.0f, D2D1::ColorF(TABLE_COLOR.r, TABLE_COLOR.g, TABLE_COLOR.b, 0.0f) }
            };
            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                D2D1_RECT_F rc = tableRect;
                const float PAD = 18.0f;                   // inset so corners stay dark
                rc.left += PAD;  rc.top += PAD;
                rc.right -= PAD;  rc.bottom -= PAD;

                // centre point & radii
                D2D1_POINT_2F centre = D2D1::Point2F(
                    (rc.left + rc.right) / 2.0f,
                    (rc.top + rc.bottom) / 2.0f);

                float rx = (rc.right - rc.left) * 0.55f;
                float ry = (rc.bottom - rc.top) * 0.55f;

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        centre,                       // origin
                        D2D1::Point2F(0, 0),          // offset
                        rx, ry);

                pRT->CreateRadialGradientBrush(props, pStops, &pSpot);
                pStops->Release();
            }

            if (pSpot)
            {
                // Use the same rounded rectangle the pocket bar uses for subtle round corners
                const float RADIUS = 20.0f;                       // corner radius
                D2D1_ROUNDED_RECT spotlightRR =
                    D2D1::RoundedRect(tableRect, RADIUS, RADIUS);

                pRT->FillRoundedRectangle(&spotlightRR, pSpot);
                pSpot->Release();
            }
        }

        // Draw Cushions (Red Border)
        pRT->CreateSolidColorBrush(CUSHION_COLOR, &pBrush);
        if (!pBrush) return;
        // Top Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_TOP - CUSHION_THICKNESS, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_TOP), pBrush);
        // Bottom Cushion (split by middle pocket)
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_LEFT + TABLE_WIDTH / 2.f - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT + TABLE_WIDTH / 2.f + HOLE_VISUAL_RADIUS, TABLE_BOTTOM, TABLE_RIGHT - HOLE_VISUAL_RADIUS, TABLE_BOTTOM + CUSHION_THICKNESS), pBrush);
        // Left Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_LEFT - CUSHION_THICKNESS, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_LEFT, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        // Right Cushion
        pRT->FillRectangle(D2D1::RectF(TABLE_RIGHT, TABLE_TOP + HOLE_VISUAL_RADIUS, TABLE_RIGHT + CUSHION_THICKNESS, TABLE_BOTTOM - HOLE_VISUAL_RADIUS), pBrush);
        SafeRelease(&pBrush);


        // Draw Pockets (Black Circles)
        pRT->CreateSolidColorBrush(POCKET_COLOR, &pBrush);
        if (!pBrush) return;
        for (int i = 0; i < 6; ++i) {
            D2D1_ELLIPSE ellipse = D2D1::Ellipse(pocketPositions[i], HOLE_VISUAL_RADIUS, HOLE_VISUAL_RADIUS);
            pRT->FillEllipse(&ellipse, pBrush);
        }
        SafeRelease(&pBrush);

        // Draw Headstring Line (White)
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pBrush); // NEWCOLOR ::White => (0.2784, 0.4549, 0.1843)
        if (!pBrush) return;
        pRT->DrawLine(
            D2D1::Point2F(HEADSTRING_X, TABLE_TOP),
            D2D1::Point2F(HEADSTRING_X, TABLE_BOTTOM),
            pBrush,
            1.0f // Line thickness
        );
        SafeRelease(&pBrush);

        // Draw Semicircle facing West (flat side East)
        // Draw Semicircle facing East (curved side on the East, flat side on the West)
        ID2D1PathGeometry* pGeometry = nullptr;
        HRESULT hr = pFactory->CreatePathGeometry(&pGeometry);
        if (SUCCEEDED(hr) && pGeometry)
        {
            ID2D1GeometrySink* pSink = nullptr;
            hr = pGeometry->Open(&pSink);
            if (SUCCEEDED(hr) && pSink)
            {
                float radius = 60.0f; // Radius for the semicircle
                D2D1_POINT_2F center = D2D1::Point2F(HEADSTRING_X, (TABLE_TOP + TABLE_BOTTOM) / 2.0f);

                // For a semicircle facing East (curved side on the East), use the top and bottom points.
                D2D1_POINT_2F startPoint = D2D1::Point2F(center.x, center.y - radius); // Top point

                pSink->BeginFigure(startPoint, D2D1_FIGURE_BEGIN_HOLLOW);

                D2D1_ARC_SEGMENT arc = {};
                arc.point = D2D1::Point2F(center.x, center.y + radius); // Bottom point
                arc.size = D2D1::SizeF(radius, radius);
                arc.rotationAngle = 0.0f;
                // Use the correct identifier with the extra underscore:
                arc.sweepDirection = D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE;
                arc.arcSize = D2D1_ARC_SIZE_SMALL;

                pSink->AddArc(&arc);
                pSink->EndFigure(D2D1_FIGURE_END_OPEN);
                pSink->Close();
                SafeRelease(&pSink);

                ID2D1SolidColorBrush* pArcBrush = nullptr;
                //pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.3f), &pArcBrush);
                pRT->CreateSolidColorBrush(D2D1::ColorF(0.4235f, 0.5647f, 0.1765f, 1.0f), &pArcBrush);
                if (pArcBrush)
                {
                    pRT->DrawGeometry(pGeometry, pArcBrush, 1.5f);
                    SafeRelease(&pArcBrush);
                }
            }
            SafeRelease(&pGeometry);
        }




    }


    // ----------------------------------------------
    //  Helper : clamp to [0,1] and lighten a colour
    // ----------------------------------------------
    static D2D1_COLOR_F Lighten(const D2D1_COLOR_F& c, float factor = 1.25f)
    {
        return D2D1::ColorF(
            std::min(1.0f, c.r * factor),
            std::min(1.0f, c.g * factor),
            std::min(1.0f, c.b * factor),
            c.a);
    }

    // ------------------------------------------------
    //  NEW  DrawBalls – radial-gradient “spot-light”
    // ------------------------------------------------
    void DrawBalls(ID2D1RenderTarget* pRT)
    {
        if (!pRT) return;

        ID2D1SolidColorBrush* pStripeBrush = nullptr;    // white stripe
        ID2D1SolidColorBrush* pBorderBrush = nullptr;    // black ring
        ID2D1SolidColorBrush * pNumWhite = nullptr; // NEW – white circle
        ID2D1SolidColorBrush * pNumBlack = nullptr; // NEW – digit colour

        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pNumWhite);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNumBlack);

        for (const Ball& b : balls)
        {
            if (b.isPocketed) continue;

            //------------------------------------------
            // Build the radial gradient for THIS ball
            //------------------------------------------
            ID2D1GradientStopCollection* pStops = nullptr;
            ID2D1RadialGradientBrush* pRad = nullptr;

            D2D1_GRADIENT_STOP gs[3];
            gs[0].position = 0.0f;  gs[0].color = D2D1::ColorF(1, 1, 1, 0.95f);     // bright spot
            gs[1].position = 0.35f; gs[1].color = Lighten(b.color);                 // transitional
            gs[2].position = 1.0f;  gs[2].color = b.color;                          // base colour

            pRT->CreateGradientStopCollection(gs, 3, &pStops);

            if (pStops)
            {
                // Place the hot-spot slightly towards top-left to look more 3-D
                D2D1_POINT_2F origin = D2D1::Point2F(b.x - BALL_RADIUS * 0.4f,
                    b.y - BALL_RADIUS * 0.4f);

                D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES props =
                    D2D1::RadialGradientBrushProperties(
                        origin,                        // gradientOrigin
                        D2D1::Point2F(0, 0),           // offset (not used here)
                        BALL_RADIUS * 1.3f,            // radiusX
                        BALL_RADIUS * 1.3f);           // radiusY

                pRT->CreateRadialGradientBrush(props, pStops, &pRad);
                SafeRelease(&pStops);
            }

            //------------------------------------------
            //  Draw the solid or striped ball itself
            //------------------------------------------
            D2D1_ELLIPSE outer = D2D1::Ellipse(
                D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

            if (pRad)  pRT->FillEllipse(&outer, pRad);

            // ----------  Stripe overlay  -------------
            if (b.type == BallType::STRIPE && pStripeBrush)
            {
                // White band
                D2D1_RECT_F stripe = D2D1::RectF(
                    b.x - BALL_RADIUS,
                    b.y - BALL_RADIUS * 0.40f,
                    b.x + BALL_RADIUS,
                    b.y + BALL_RADIUS * 0.40f);
                pRT->FillRectangle(&stripe, pStripeBrush);

                // Inner circle (give stripe area same glossy shading)
                if (pRad)
                {
                    D2D1_ELLIPSE inner = D2D1::Ellipse(
                        D2D1::Point2F(b.x, b.y),
                        BALL_RADIUS * 0.60f,
                        BALL_RADIUS * 0.60f);
                    pRT->FillEllipse(&inner, pRad);
                }
            }

            // --------------------------------------------------------
//  Draw number decal (skip cue ball)
// --------------------------------------------------------
            if (b.id != 0 && pBallNumFormat && pNumWhite && pNumBlack)
            {
                // 1) white circle – slightly smaller on stripes so it fits
                const float decalR = (b.type == BallType::STRIPE) ?
                    BALL_RADIUS * 0.40f : BALL_RADIUS * 0.45f;

                D2D1_ELLIPSE decal = D2D1::Ellipse(
                    D2D1::Point2F(b.x, b.y), decalR, decalR);

                pRT->FillEllipse(&decal, pNumWhite);
                pRT->DrawEllipse(&decal, pNumBlack, 0.8f);   // thin border

                // 2) digit – convert id to printable number
                wchar_t numText[3];
                _snwprintf_s(numText, _TRUNCATE, L""%d"", b.id);

                // layout rectangle exactly the diameter of the decal
                D2D1_RECT_F layout = D2D1::RectF(
                    b.x - decalR, b.y - decalR,
                    b.x + decalR, b.y + decalR);

                pRT->DrawText(numText,
                    (UINT32)wcslen(numText),
                    pBallNumFormat,
                    &layout,
                    pNumBlack);
            }

            // Black border
            if (pBorderBrush)
                pRT->DrawEllipse(&outer, pBorderBrush, 1.5f);

            SafeRelease(&pRad);
        }

        SafeRelease(&pStripeBrush);
        SafeRelease(&pBorderBrush);
        SafeRelease(&pNumWhite);   // NEW
        SafeRelease(&pNumBlack);   // NEW
    }

    /*void DrawBalls(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pStripeBrush = nullptr; // For stripe pattern

        pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBrush); // Placeholder
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);

        if (!pBrush || !pStripeBrush) {
            SafeRelease(&pBrush);
            SafeRelease(&pStripeBrush);
            return;
        }


        for (size_t i = 0; i < balls.size(); ++i) {
            const Ball& b = balls[i];
            if (!b.isPocketed) {
                D2D1_ELLIPSE ellipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS, BALL_RADIUS);

                // Set main ball color
                pBrush->SetColor(b.color);
                pRT->FillEllipse(&ellipse, pBrush);

                // Draw Stripe if applicable
                if (b.type == BallType::STRIPE) {
                    // Draw a white band across the middle (simplified stripe)
                    D2D1_RECT_F stripeRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS * 0.4f, b.x + BALL_RADIUS, b.y + BALL_RADIUS * 0.4f);
                    // Need to clip this rectangle to the ellipse bounds - complex!
                    // Alternative: Draw two colored arcs leaving a white band.
                    // Simplest: Draw a white circle inside, slightly smaller.
                    D2D1_ELLIPSE innerEllipse = D2D1::Ellipse(D2D1::Point2F(b.x, b.y), BALL_RADIUS * 0.6f, BALL_RADIUS * 0.6f);
                    pRT->FillEllipse(innerEllipse, pStripeBrush); // White center part
                    pBrush->SetColor(b.color); // Set back to stripe color
                    pRT->FillEllipse(innerEllipse, pBrush); // Fill again, leaving a ring - No, this isn't right.

                    // Let's try drawing a thick white line across
                    // This doesn't look great. Just drawing solid red for stripes for now.
                }

                // Draw Number (Optional - requires more complex text layout or pre-rendered textures)
                // if (b.id != 0 && pTextFormat) {
                //     std::wstring numStr = std::to_wstring(b.id);
                //     D2D1_RECT_F textRect = D2D1::RectF(b.x - BALL_RADIUS, b.y - BALL_RADIUS, b.x + BALL_RADIUS, b.y + BALL_RADIUS);
                //     ID2D1SolidColorBrush* pNumBrush = nullptr;
                //     D2D1_COLOR_F numCol = (b.type == BallType::SOLID || b.id == 8) ? D2D1::ColorF(D2D1::ColorF::Black) : D2D1::ColorF(D2D1::ColorF::White);
                //     pRT->CreateSolidColorBrush(numCol, &pNumBrush);
                //     // Create a smaller text format...
                //     // pRT->DrawText(numStr.c_str(), numStr.length(), pSmallTextFormat, &textRect, pNumBrush);
                //     SafeRelease(&pNumBrush);
                // }
            }
        }

        SafeRelease(&pBrush);
        SafeRelease(&pStripeBrush);
    }*/


    /*void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Condition check at start (Unchanged)
        //if (currentGameState != PLAYER1_TURN && currentGameState != PLAYER2_TURN &&
            //currentGameState != BREAKING && currentGameState != AIMING)
        //{
            //return;
        //}
            // NEW Condition: Allow drawing if it's a human player's active turn/aiming/breaking,
        // OR if it's AI's turn and it's in AI_THINKING state (calculating) or BREAKING (aiming break).
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING);
        // AI_THINKING state is when AI calculates shot. AIMakeDecision sets cueAngle/shotPower.
        // Also include BREAKING state if it's AI's turn and isOpeningBreakShot for break aim visualization.
            // NEW Condition: AI is displaying its aim
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (!isHumanInteracting && !(isAiVisualizingShot || (currentGameState == AI_THINKING && aiIsDisplayingAim))) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return; // Don't draw if cue ball is gone

        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr; // Brush for reflection line

        // Ensure render target is valid
        if (!pRT) return;

        // Create Brushes and Styles (check for failures)
        HRESULT hr;
        hr = pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        if FAILED(hr) { SafeRelease(&pBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); return; }
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); return; }
        // Create reflection brush (e.g., lighter shade or different color)
        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        if FAILED(hr) { SafeRelease(&pBrush); SafeRelease(&pGhostBrush); SafeRelease(&pCueBrush); SafeRelease(&pReflectBrush); return; }
        // Create a Cyan brush for primary and secondary lines //orig(75.0f / 255.0f, 0.0f, 130.0f / 255.0f);indigoColor
        D2D1::ColorF cyanColor(0.0, 255.0, 255.0, 255.0f);
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(cyanColor, &pCyanBrush);
        if (FAILED(hr)) {
            SafeRelease(&pCyanBrush);
            // handle error if needed
        }
        // Create a Purple brush for primary and secondary lines
        D2D1::ColorF purpleColor(255.0f, 0.0f, 255.0f, 255.0f);
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        hr = pRT->CreateSolidColorBrush(purpleColor, &pPurpleBrush);
        if (FAILED(hr)) {
            SafeRelease(&pPurpleBrush);
            // handle error if needed
        }

        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            hr = pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
            if FAILED(hr) { pDashedStyle = nullptr; }
        }


        // --- Cue Stick Drawing (Unchanged from previous fix) ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = cueAngle + PI;
        float powerOffset = 0.0f;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Show power offset if human is aiming/dragging, or if AI is preparing its shot (AI_THINKING or AI Break)
        if ((isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) || isAiVisualizingShot) { // Use the new condition
            powerOffset = shotPower * 5.0f;
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);


        // --- Projection Line Calculation ---
        float cosA = cosf(cueAngle);
        float sinA = sinf(cueAngle);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT; // Ensure ray is long enough
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);*/

    void DrawAimingAids(ID2D1RenderTarget* pRT) {
        // Determine if aiming aids should be drawn.
        bool isHumanInteracting = (!isPlayer2AI || currentPlayer == 1) &&
            (currentGameState == PLAYER1_TURN || currentGameState == PLAYER2_TURN ||
                currentGameState == BREAKING || currentGameState == AIMING ||
                currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2);

        // FOOLPROOF FIX: This is the new condition to show the AI's aim.
        bool isAiVisualizingShot = (isPlayer2AI && currentPlayer == 2 && aiIsDisplayingAim);

        if (!isHumanInteracting && !isAiVisualizingShot) {
            return;
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall || cueBall->isPocketed) return;

        // --- Brush and Style Creation (No changes here) ---
        ID2D1SolidColorBrush* pBrush = nullptr;
        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        ID2D1StrokeStyle* pDashedStyle = nullptr;
        ID2D1SolidColorBrush* pCueBrush = nullptr;
        ID2D1SolidColorBrush* pReflectBrush = nullptr;
        ID2D1SolidColorBrush* pCyanBrush = nullptr;
        ID2D1SolidColorBrush* pPurpleBrush = nullptr;
        pRT->CreateSolidColorBrush(AIM_LINE_COLOR, &pBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.5f), &pGhostBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(0.6f, 0.4f, 0.2f), &pCueBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::LightCyan, 0.6f), &pReflectBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Cyan), &pCyanBrush);
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Purple), &pPurpleBrush);
        if (pFactory) {
            D2D1_STROKE_STYLE_PROPERTIES strokeProps = D2D1::StrokeStyleProperties();
            strokeProps.dashStyle = D2D1_DASH_STYLE_DASH;
            pFactory->CreateStrokeStyle(&strokeProps, nullptr, 0, &pDashedStyle);
        }
        // --- End Brush Creation ---

        // --- FOOLPROOF FIX: Use the AI's planned angle and power for drawing ---
        float angleToDraw = cueAngle;
        float powerToDraw = shotPower;

        if (isAiVisualizingShot) {
            // When the AI is showing its aim, force the drawing to use its planned shot details.
            angleToDraw = aiPlannedShotDetails.angle;
            powerToDraw = aiPlannedShotDetails.power;
        }
        // --- End AI Aiming Fix ---

        // --- Cue Stick Drawing ---
        const float baseStickLength = 150.0f;
        const float baseStickThickness = 4.0f;
        float stickLength = baseStickLength * 1.4f;
        float stickThickness = baseStickThickness * 1.5f;
        float stickAngle = angleToDraw + PI; // Use the angle we determined
        float powerOffset = 0.0f;
        if ((isAiming || isDraggingStick) || isAiVisualizingShot) {
            powerOffset = powerToDraw * 5.0f; // Use the power we determined
        }
        D2D1_POINT_2F cueStickEnd = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (stickLength + powerOffset), cueBall->y + sinf(stickAngle) * (stickLength + powerOffset));
        D2D1_POINT_2F cueStickTip = D2D1::Point2F(cueBall->x + cosf(stickAngle) * (powerOffset + 5.0f), cueBall->y + sinf(stickAngle) * (powerOffset + 5.0f));
        pRT->DrawLine(cueStickTip, cueStickEnd, pCueBrush, stickThickness);

        // --- Projection Line Calculation ---
        float cosA = cosf(angleToDraw); // Use the angle we determined
        float sinA = sinf(angleToDraw);
        float rayLength = TABLE_WIDTH + TABLE_HEIGHT;
        D2D1_POINT_2F rayStart = D2D1::Point2F(cueBall->x, cueBall->y);
        D2D1_POINT_2F rayEnd = D2D1::Point2F(rayStart.x + cosA * rayLength, rayStart.y + sinA * rayLength);

        // Find the first ball hit by the aiming ray
        Ball* hitBall = nullptr;
        float firstHitDistSq = -1.0f;
        D2D1_POINT_2F ballCollisionPoint = { 0, 0 }; // Point on target ball circumference
        D2D1_POINT_2F ghostBallPosForHit = { 0, 0 }; // Ghost ball pos for the hit ball

        hitBall = FindFirstHitBall(rayStart, cueAngle, firstHitDistSq);
        if (hitBall) {
            // Calculate the point on the target ball's circumference
            float collisionDist = sqrtf(firstHitDistSq);
            ballCollisionPoint = D2D1::Point2F(rayStart.x + cosA * collisionDist, rayStart.y + sinA * collisionDist);
            // Calculate ghost ball position for this specific hit (used for projection consistency)
            ghostBallPosForHit = D2D1::Point2F(hitBall->x - cosA * BALL_RADIUS, hitBall->y - sinA * BALL_RADIUS); // Approx.
        }

        // Find the first rail hit by the aiming ray
        D2D1_POINT_2F railHitPoint = rayEnd; // Default to far end if no rail hit
        float minRailDistSq = rayLength * rayLength;
        int hitRailIndex = -1; // 0:Left, 1:Right, 2:Top, 3:Bottom

        // Define table edge segments for intersection checks
        D2D1_POINT_2F topLeft = D2D1::Point2F(TABLE_LEFT, TABLE_TOP);
        D2D1_POINT_2F topRight = D2D1::Point2F(TABLE_RIGHT, TABLE_TOP);
        D2D1_POINT_2F bottomLeft = D2D1::Point2F(TABLE_LEFT, TABLE_BOTTOM);
        D2D1_POINT_2F bottomRight = D2D1::Point2F(TABLE_RIGHT, TABLE_BOTTOM);

        D2D1_POINT_2F currentIntersection;

        // Check Left Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, bottomLeft, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 0; }
        }
        // Check Right Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topRight, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 1; }
        }
        // Check Top Rail
        if (LineSegmentIntersection(rayStart, rayEnd, topLeft, topRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 2; }
        }
        // Check Bottom Rail
        if (LineSegmentIntersection(rayStart, rayEnd, bottomLeft, bottomRight, currentIntersection)) {
            float distSq = GetDistanceSq(rayStart.x, rayStart.y, currentIntersection.x, currentIntersection.y);
            if (distSq < minRailDistSq) { minRailDistSq = distSq; railHitPoint = currentIntersection; hitRailIndex = 3; }
        }


        // --- Determine final aim line end point ---
        D2D1_POINT_2F finalLineEnd = railHitPoint; // Assume rail hit first
        bool aimingAtRail = true;

        if (hitBall && firstHitDistSq < minRailDistSq) {
            // Ball collision is closer than rail collision
            finalLineEnd = ballCollisionPoint; // End line at the point of contact on the ball
            aimingAtRail = false;
        }

        // --- Draw Primary Aiming Line ---
        pRT->DrawLine(rayStart, finalLineEnd, pBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

        // --- Draw Target Circle/Indicator ---
        D2D1_ELLIPSE targetCircle = D2D1::Ellipse(finalLineEnd, BALL_RADIUS / 2.0f, BALL_RADIUS / 2.0f);
        pRT->DrawEllipse(&targetCircle, pBrush, 1.0f);

        // --- Draw Projection/Reflection Lines ---
        if (!aimingAtRail && hitBall) {
            // Aiming at a ball: Draw Ghost Cue Ball and Target Ball Projection
            D2D1_ELLIPSE ghostCue = D2D1::Ellipse(ballCollisionPoint, BALL_RADIUS, BALL_RADIUS); // Ghost ball at contact point
            pRT->DrawEllipse(ghostCue, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // Calculate target ball projection based on impact line (cue collision point -> target center)
            float targetProjectionAngle = atan2f(hitBall->y - ballCollisionPoint.y, hitBall->x - ballCollisionPoint.x);
            // Clamp angle calculation if distance is tiny
            if (GetDistanceSq(hitBall->x, hitBall->y, ballCollisionPoint.x, ballCollisionPoint.y) < 1.0f) {
                targetProjectionAngle = cueAngle; // Fallback if overlapping
            }

            D2D1_POINT_2F targetStartPoint = D2D1::Point2F(hitBall->x, hitBall->y);
            D2D1_POINT_2F targetProjectionEnd = D2D1::Point2F(
                hitBall->x + cosf(targetProjectionAngle) * 50.0f, // Projection length 50 units
                hitBall->y + sinf(targetProjectionAngle) * 50.0f
            );
            // Draw solid line for target projection
            //pRT->DrawLine(targetStartPoint, targetProjectionEnd, pBrush, 1.0f);

        //new code start

                    // Dual trajectory with edge-aware contact simulation
            D2D1_POINT_2F dir = {
                targetProjectionEnd.x - targetStartPoint.x,
                targetProjectionEnd.y - targetStartPoint.y
            };
            float dirLen = sqrtf(dir.x * dir.x + dir.y * dir.y);
            dir.x /= dirLen;
            dir.y /= dirLen;

            D2D1_POINT_2F perp = { -dir.y, dir.x };

            // Approximate cue ball center by reversing from tip
            D2D1_POINT_2F cueBallCenterForGhostHit = { // Renamed for clarity if you use it elsewhere
                targetStartPoint.x - dir.x * BALL_RADIUS,
                targetStartPoint.y - dir.y * BALL_RADIUS
            };

            // REAL contact-ball center - use your physics object's center:
            // (replace 'objectBallPos' with whatever you actually call it)
            // (targetStartPoint is already hitBall->x, hitBall->y)
            D2D1_POINT_2F contactBallCenter = targetStartPoint; // Corrected: Use the object ball's actual center
            //D2D1_POINT_2F contactBallCenter = D2D1::Point2F(hitBall->x, hitBall->y);

           // The 'offset' calculation below uses 'cueBallCenterForGhostHit' (originally 'cueBallCenter').
           // This will result in 'offset' being 0 because 'cueBallCenterForGhostHit' is defined
           // such that (targetStartPoint - cueBallCenterForGhostHit) is parallel to 'dir',
           // and 'perp' is perpendicular to 'dir'.
           // Consider Change 2 if this 'offset' is not behaving as intended for the secondary line.
            /*float offset = ((targetStartPoint.x - cueBallCenterForGhostHit.x) * perp.x +
                (targetStartPoint.y - cueBallCenterForGhostHit.y) * perp.y);*/
                /*float offset = ((targetStartPoint.x - cueBallCenter.x) * perp.x +
                    (targetStartPoint.y - cueBallCenter.y) * perp.y);
                float absOffset = fabsf(offset);
                float side = (offset >= 0 ? 1.0f : -1.0f);*/

                // Use actual cue ball center for offset calculation if 'offset' is meant to quantify the cut
            D2D1_POINT_2F actualCueBallPhysicalCenter = D2D1::Point2F(cueBall->x, cueBall->y); // This is also rayStart

            // Offset calculation based on actual cue ball position relative to the 'dir' line through targetStartPoint
            float offset = ((targetStartPoint.x - actualCueBallPhysicalCenter.x) * perp.x +
                (targetStartPoint.y - actualCueBallPhysicalCenter.y) * perp.y);
            float absOffset = fabsf(offset);
            float side = (offset >= 0 ? 1.0f : -1.0f);


            // Actual contact point on target ball edge
            D2D1_POINT_2F contactPoint = {
            contactBallCenter.x + perp.x * BALL_RADIUS * side,
            contactBallCenter.y + perp.y * BALL_RADIUS * side
            };

            // Tangent (cut shot) path from contact point
                // Tangent (cut shot) path: from contact point to contact ball center
            D2D1_POINT_2F objectBallDir = {
                contactBallCenter.x - contactPoint.x,
                contactBallCenter.y - contactPoint.y
            };
            float oLen = sqrtf(objectBallDir.x * objectBallDir.x + objectBallDir.y * objectBallDir.y);
            if (oLen != 0.0f) {
                objectBallDir.x /= oLen;
                objectBallDir.y /= oLen;
            }

            const float PRIMARY_LEN = 150.0f; //default=150.0f
            const float SECONDARY_LEN = 150.0f; //default=150.0f
            const float STRAIGHT_EPSILON = BALL_RADIUS * 0.05f;

            D2D1_POINT_2F primaryEnd = {
                targetStartPoint.x + dir.x * PRIMARY_LEN,
                targetStartPoint.y + dir.y * PRIMARY_LEN
            };

            // Secondary line starts from the contact ball's center
            D2D1_POINT_2F secondaryStart = contactBallCenter;
            D2D1_POINT_2F secondaryEnd = {
                secondaryStart.x + objectBallDir.x * SECONDARY_LEN,
                secondaryStart.y + objectBallDir.y * SECONDARY_LEN
            };

            if (absOffset < STRAIGHT_EPSILON)  // straight shot?
            {
                // Straight: secondary behind primary
                        // secondary behind primary {pDashedStyle param at end}
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            else
            {
                // Cut shot: both visible
                        // both visible for cut shot
                pRT->DrawLine(secondaryStart, secondaryEnd, pPurpleBrush, 2.0f);
                //pRT->DrawLine(secondaryStart, secondaryEnd, pGhostBrush, 1.0f);
                pRT->DrawLine(targetStartPoint, primaryEnd, pCyanBrush, 2.0f);
                //pRT->DrawLine(targetStartPoint, primaryEnd, pBrush, 1.0f);
            }
            // End improved trajectory logic

        //new code end

            // -- Cue Ball Path after collision (Optional, requires physics) --
            // Very simplified: Assume cue deflects, angle depends on cut angle.
            // float cutAngle = acosf(cosf(cueAngle - targetProjectionAngle)); // Angle between paths
            // float cueDeflectionAngle = ? // Depends on cutAngle, spin, etc. Hard to predict accurately.
            // D2D1_POINT_2F cueProjectionEnd = ...
            // pRT->DrawLine(ballCollisionPoint, cueProjectionEnd, pGhostBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);

            // --- Accuracy Comment ---
            // Note: The visual accuracy of this projection, especially for cut shots (hitting the ball off-center)
            // or shots with spin, is limited by the simplified physics model. Real pool physics involves
            // collision-induced throw, spin transfer, and cue ball deflection not fully simulated here.
            // The ghost ball method shows the *ideal* line for a center-cue hit without spin.

        }
        else if (aimingAtRail && hitRailIndex != -1) {
            // Aiming at a rail: Draw reflection line
            float reflectAngle = cueAngle;
            // Reflect angle based on which rail was hit
            if (hitRailIndex == 0 || hitRailIndex == 1) { // Left or Right rail
                reflectAngle = PI - cueAngle; // Reflect horizontal component
            }
            else { // Top or Bottom rail
                reflectAngle = -cueAngle; // Reflect vertical component
            }
            // Normalize angle if needed (atan2 usually handles this)
            while (reflectAngle > PI) reflectAngle -= 2 * PI;
            while (reflectAngle <= -PI) reflectAngle += 2 * PI;


            float reflectionLength = 60.0f; // Length of the reflection line
            D2D1_POINT_2F reflectionEnd = D2D1::Point2F(
                finalLineEnd.x + cosf(reflectAngle) * reflectionLength,
                finalLineEnd.y + sinf(reflectAngle) * reflectionLength
            );

            // Draw the reflection line (e.g., using a different color/style)
            pRT->DrawLine(finalLineEnd, reflectionEnd, pReflectBrush, 1.0f, pDashedStyle ? pDashedStyle : NULL);
        }

        // Release resources
        SafeRelease(&pBrush);
        SafeRelease(&pGhostBrush);
        SafeRelease(&pCueBrush);
        SafeRelease(&pReflectBrush); // Release new brush
        SafeRelease(&pCyanBrush);
        SafeRelease(&pPurpleBrush);
        SafeRelease(&pDashedStyle);
    }


    void DrawUI(ID2D1RenderTarget* pRT) {
        if (!pTextFormat || !pLargeTextFormat) return;

        ID2D1SolidColorBrush* pBrush = nullptr;
        pRT->CreateSolidColorBrush(UI_TEXT_COLOR, &pBrush);
        if (!pBrush) return;

        //new code
        // --- Always draw AI's 8?Ball call arrow when it's Player?2's turn and AI has called ---
        //if (isPlayer2AI && currentPlayer == 2 && calledPocketP2 >= 0) {
            // FIX: This condition correctly shows the AI's called pocket arrow.
        if (isPlayer2AI && IsPlayerOnEightBall(2) && calledPocketP2 >= 0) {
            // pocket index that AI called
            int idx = calledPocketP2;
            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    { P.x - 15.0f, P.y - 40.0f },
                    { P.x + 15.0f, P.y - 40.0f },
                    { P.x       , P.y - 10.0f }
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrow);
            }
            // draw “Choose a pocket...” prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""AI has called this pocket"",
                (UINT32)wcslen(L""AI has called this pocket""),
                pTextFormat,
                &txt,
                pBrush
            );
            // note: no return here — we still draw fouls/turn text underneath
        }
        //end new code

        // --- Player Info Area (Top Left/Right) --- (Unchanged)
        float uiTop = TABLE_TOP - 80;
        float uiHeight = 60;
        float p1Left = TABLE_LEFT;
        float p1Width = 150;
        float p2Left = TABLE_RIGHT - p1Width;
        D2D1_RECT_F p1Rect = D2D1::RectF(p1Left, uiTop, p1Left + p1Width, uiTop + uiHeight);
        D2D1_RECT_F p2Rect = D2D1::RectF(p2Left, uiTop, p2Left + p1Width, uiTop + uiHeight);

        // Player 1 Info Text (Unchanged)
        std::wostringstream oss1;
        oss1 << player1Info.name.c_str() << L""\n"";
        if (player1Info.assignedType != BallType::NONE) {
            oss1 << ((player1Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss1 << L"" ["" << player1Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss1 << L""(Undecided)"";
        }
        pRT->DrawText(oss1.str().c_str(), (UINT32)oss1.str().length(), pTextFormat, &p1Rect, pBrush);
        // Draw Player 1 Side Ball
        if (player1Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player1Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p1Rect.right + 10.0f, p1Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player1Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }


        // Player 2 Info Text (Unchanged)
        std::wostringstream oss2;
        oss2 << player2Info.name.c_str() << L""\n"";
        if (player2Info.assignedType != BallType::NONE) {
            oss2 << ((player2Info.assignedType == BallType::SOLID) ? L""Solids (Yellow)"" : L""Stripes (Red)"");
            oss2 << L"" ["" << player2Info.ballsPocketedCount << L""/7]"";
        }
        else {
            oss2 << L""(Undecided)"";
        }
        pRT->DrawText(oss2.str().c_str(), (UINT32)oss2.str().length(), pTextFormat, &p2Rect, pBrush);
        // Draw Player 2 Side Ball
        if (player2Info.assignedType != BallType::NONE)
        {
            ID2D1SolidColorBrush* pBallBrush = nullptr;
            D2D1_COLOR_F ballColor = (player2Info.assignedType == BallType::SOLID) ?
                D2D1::ColorF(1.0f, 1.0f, 0.0f) : D2D1::ColorF(1.0f, 0.0f, 0.0f);
            pRT->CreateSolidColorBrush(ballColor, &pBallBrush);
            if (pBallBrush)
            {
                D2D1_POINT_2F ballCenter = D2D1::Point2F(p2Rect.right + 10.0f, p2Rect.top + 20.0f);
                float radius = 10.0f;
                D2D1_ELLIPSE ball = D2D1::Ellipse(ballCenter, radius, radius);
                pRT->FillEllipse(&ball, pBallBrush);
                SafeRelease(&pBallBrush);
                // Draw border around the ball
                ID2D1SolidColorBrush* pBorderBrush = nullptr;
                pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
                if (pBorderBrush)
                {
                    pRT->DrawEllipse(&ball, pBorderBrush, 1.5f); // thin border
                    SafeRelease(&pBorderBrush);
                }

                // If stripes, draw a stripe band
                if (player2Info.assignedType == BallType::STRIPE)
                {
                    ID2D1SolidColorBrush* pStripeBrush = nullptr;
                    pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White), &pStripeBrush);
                    if (pStripeBrush)
                    {
                        D2D1_RECT_F stripeRect = D2D1::RectF(
                            ballCenter.x - radius,
                            ballCenter.y - 3.0f,
                            ballCenter.x + radius,
                            ballCenter.y + 3.0f
                        );
                        pRT->FillRectangle(&stripeRect, pStripeBrush);
                        SafeRelease(&pStripeBrush);
                    }
                }
            }
        }

        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            D2D1_RECT_F playerBox = (currentPlayer == 1) ? p1Rect : p2Rect;
            arrowBackX = playerBox.left - 25.0f;
            arrowTipX = arrowBackX + arrowSizeBase * 0.75f;

            float notchDepth = 12.0f;  // Increased from 6.0f to make the rectangle longer
            float notchWidth = 10.0f;

            float cx = arrowBackX;
            float cy = arrowCenterY;

            // Define triangle + rectangle tail shape
            D2D1_POINT_2F tip = D2D1::Point2F(arrowTipX, cy);                           // tip
            D2D1_POINT_2F baseTop = D2D1::Point2F(cx, cy - arrowSizeBase / 2.0f);          // triangle top
            D2D1_POINT_2F baseBot = D2D1::Point2F(cx, cy + arrowSizeBase / 2.0f);          // triangle bottom

            // Rectangle coordinates for the tail portion:
            D2D1_POINT_2F r1 = D2D1::Point2F(cx - notchDepth, cy - notchWidth / 2.0f);   // rect top-left
            D2D1_POINT_2F r2 = D2D1::Point2F(cx, cy - notchWidth / 2.0f);                 // rect top-right
            D2D1_POINT_2F r3 = D2D1::Point2F(cx, cy + notchWidth / 2.0f);                 // rect bottom-right
            D2D1_POINT_2F r4 = D2D1::Point2F(cx - notchDepth, cy + notchWidth / 2.0f);    // rect bottom-left

            ID2D1PathGeometry* pPath = nullptr;
            if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
                ID2D1GeometrySink* pSink = nullptr;
                if (SUCCEEDED(pPath->Open(&pSink))) {
                    pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                    pSink->AddLine(baseTop);
                    pSink->AddLine(r2); // transition from triangle into rectangle
                    pSink->AddLine(r1);
                    pSink->AddLine(r4);
                    pSink->AddLine(r3);
                    pSink->AddLine(baseBot);
                    pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                    pSink->Close();
                    SafeRelease(&pSink);
                    pRT->FillGeometry(pPath, pArrowBrush);
                }
                SafeRelease(&pPath);
            }


            SafeRelease(&pArrowBrush);
        }

        //original
    /*
        // --- MODIFIED: Current Turn Arrow (Blue, Bigger, Beside Name) ---
        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
        if (pArrowBrush && currentGameState != GAME_OVER && currentGameState != SHOT_IN_PROGRESS && currentGameState != AI_THINKING) {
            float arrowSizeBase = 32.0f; // Base size for width/height offsets (4x original ~8)
            float arrowCenterY = p1Rect.top + uiHeight / 2.0f; // Center vertically with text box
            float arrowTipX, arrowBackX;

            if (currentPlayer == 1) {
    arrowBackX = p1Rect.left - 25.0f; // Position left of the box
                arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
                // Define points for right-pointing arrow
                //D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
                //D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
                //D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back
                // Enhanced arrow with base rectangle intersection
        float notchDepth = 6.0f; // Depth of square base ""stem""
        float notchWidth = 4.0f; // Thickness of square part

        D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
        D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
        D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY - notchWidth / 2.0f); // Square Left-Top
        D2D1_POINT_2F pt4 = D2D1::Point2F(arrowBackX - notchDepth, arrowCenterY + notchWidth / 2.0f); // Square Left-Bottom
        D2D1_POINT_2F pt5 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back


        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(pt2);
                pSink->AddLine(pt3);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
            }


            //==================else player 2
            else { // Player 2
             // Player 2: Arrow left of P2 box, pointing right (or right of P2 box pointing left?)
             // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    // Let's keep it consistent: Arrow left of the active player's box, pointing right.
    arrowBackX = p2Rect.left - 25.0f; // Position left of the box
    arrowTipX = arrowBackX + arrowSizeBase * 0.75f; // Pointy end extends right
    // Define points for right-pointing arrow
    D2D1_POINT_2F pt1 = D2D1::Point2F(arrowTipX, arrowCenterY); // Tip
    D2D1_POINT_2F pt2 = D2D1::Point2F(arrowBackX, arrowCenterY - arrowSizeBase / 2.0f); // Top-Back
    D2D1_POINT_2F pt3 = D2D1::Point2F(arrowBackX, arrowCenterY + arrowSizeBase / 2.0f); // Bottom-Back

    ID2D1PathGeometry* pPath = nullptr;
    if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
        ID2D1GeometrySink* pSink = nullptr;
        if (SUCCEEDED(pPath->Open(&pSink))) {
            pSink->BeginFigure(pt1, D2D1_FIGURE_BEGIN_FILLED);
            pSink->AddLine(pt2);
            pSink->AddLine(pt3);
            pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
            pSink->Close();
            SafeRelease(&pSink);
            pRT->FillGeometry(pPath, pArrowBrush);
        }
        SafeRelease(&pPath);
    }
            }
            */


            // --- Persistent Blue 8?Ball Call Arrow & Prompt ---
        /*if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
        {
            // determine index (default top?right)
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
        }*/

        // --- Persistent Blue 8?Ball Pocket Arrow & Prompt (once called) ---
    /* if (calledPocketP1 >= 0 || calledPocketP2 >= 0)
    {
        // 1) Determine pocket index
        int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
        // If the other player had called but it's now your turn, still show that call
        if (idx < 0) idx = (currentPlayer == 1 ? calledPocketP2 : calledPocketP1);
        if (idx < 0) idx = 2; // default to top?right if somehow still unset

        // 2) Draw large blue arrow
        ID2D1SolidColorBrush* pArrow = nullptr;
        pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
        if (pArrow) {
            auto P = pocketPositions[idx];
            D2D1_POINT_2F tri[3] = {
                { P.x - 15.0f, P.y - 40.0f },
                { P.x + 15.0f, P.y - 40.0f },
                { P.x       , P.y - 10.0f }
            };
            ID2D1PathGeometry* geom = nullptr;
            pFactory->CreatePathGeometry(&geom);
            ID2D1GeometrySink* sink = nullptr;
            geom->Open(&sink);
            sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
            sink->AddLines(&tri[1], 2);
            sink->EndFigure(D2D1_FIGURE_END_CLOSED);
            sink->Close();
            pRT->FillGeometry(geom, pArrow);
            SafeRelease(&sink);
            SafeRelease(&geom);
            SafeRelease(&pArrow);
        }

        // 3) Draw persistent prompt text
        D2D1_RECT_F txt = D2D1::RectF(
            TABLE_LEFT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
            TABLE_RIGHT,
            TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
        );
        pRT->DrawText(
            L""Choose a pocket..."",
            (UINT32)wcslen(L""Choose a pocket...""),
            pTextFormat,
            &txt,
            pBrush
        );
        // Note: no 'return'; allow foul/turn text to draw beneath if needed
    } */

    // new code ends here

        // --- MODIFIED: Foul Text (Large Red, Bottom Center) ---
        if (foulCommitted && currentGameState != SHOT_IN_PROGRESS) {
            ID2D1SolidColorBrush* pFoulBrush = nullptr;
            pRT->CreateSolidColorBrush(FOUL_TEXT_COLOR, &pFoulBrush);
            if (pFoulBrush && pLargeTextFormat) {
                // Calculate Rect for bottom-middle area
                float foulWidth = 200.0f; // Adjust width as needed
                float foulHeight = 60.0f;
                float foulLeft = TABLE_LEFT + (TABLE_WIDTH / 2.0f) - (foulWidth / 2.0f);
                // Position below the pocketed balls bar
                float foulTop = pocketedBallsBarRect.bottom + 10.0f;
                D2D1_RECT_F foulRect = D2D1::RectF(foulLeft, foulTop, foulLeft + foulWidth, foulTop + foulHeight);

                // --- Set text alignment to center for foul text ---
                pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                pRT->DrawText(L""FOUL!"", 5, pLargeTextFormat, &foulRect, pFoulBrush);

                // --- Restore default alignment for large text if needed elsewhere ---
                // pLargeTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                // pLargeTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);

                SafeRelease(&pFoulBrush);
            }
        }

        // --- Blue Arrow & Prompt for 8?Ball Call (while choosing or after called) ---
        if ((currentGameState == CHOOSING_POCKET_P1
            || currentGameState == CHOOSING_POCKET_P2)
            || (calledPocketP1 >= 0 || calledPocketP2 >= 0))
        {
            // determine index:
            //  - if a call exists, use it
            //  - if still choosing, use hover if any
            // determine index: use only the clicked call; default to top?right if unset
            int idx = (currentPlayer == 1 ? calledPocketP1 : calledPocketP2);
            if (idx < 0) idx = 2;

            // draw large blue arrow
            ID2D1SolidColorBrush* pArrow = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrow);
            if (pArrow) {
                auto P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 15.0f, P.y - 40.0f},
                    {P.x + 15.0f, P.y - 40.0f},
                    {P.x       , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrow);
                SafeRelease(&sink); SafeRelease(&geom); SafeRelease(&pArrow);
            }

            // draw prompt below pockets
            D2D1_RECT_F txt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &txt,
                pBrush
            );
            // do NOT return here; allow foul/turn text to display under the arrow
        }

        // Removed Obsolete
        /*
        // --- 8-Ball Pocket Selection Arrow & Prompt ---
        if (currentGameState == CHOOSING_POCKET_P1 || currentGameState == CHOOSING_POCKET_P2) {
            // Determine which pocket to highlight (default to Top-Right if unset)
            int idx = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
            if (idx < 0) idx = 2;

            // Draw the downward arrow
            ID2D1SolidColorBrush* pArrowBrush = nullptr;
            pRT->CreateSolidColorBrush(TURN_ARROW_COLOR, &pArrowBrush);
            if (pArrowBrush) {
                D2D1_POINT_2F P = pocketPositions[idx];
                D2D1_POINT_2F tri[3] = {
                    {P.x - 10.0f, P.y - 30.0f},
                    {P.x + 10.0f, P.y - 30.0f},
                    {P.x        , P.y - 10.0f}
                };
                ID2D1PathGeometry* geom = nullptr;
                pFactory->CreatePathGeometry(&geom);
                ID2D1GeometrySink* sink = nullptr;
                geom->Open(&sink);
                sink->BeginFigure(tri[0], D2D1_FIGURE_BEGIN_FILLED);
                sink->AddLines(&tri[1], 2);
                sink->EndFigure(D2D1_FIGURE_END_CLOSED);
                sink->Close();
                pRT->FillGeometry(geom, pArrowBrush);
                SafeRelease(&sink);
                SafeRelease(&geom);
                SafeRelease(&pArrowBrush);
            }

            // Draw “Choose a pocket...” text under the table
            D2D1_RECT_F prompt = D2D1::RectF(
                TABLE_LEFT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 5.0f,
                TABLE_RIGHT,
                TABLE_BOTTOM + CUSHION_THICKNESS + 30.0f
            );
            pRT->DrawText(
                L""Choose a pocket..."",
                (UINT32)wcslen(L""Choose a pocket...""),
                pTextFormat,
                &prompt,
                pBrush
            );

            return; // Skip normal turn/foul text
        }
        */


        // Show AI Thinking State (Unchanged from previous step)
        if (currentGameState == AI_THINKING && pTextFormat) {
            ID2D1SolidColorBrush* pThinkingBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Orange), &pThinkingBrush);
            if (pThinkingBrush) {
                D2D1_RECT_F thinkingRect = p2Rect;
                thinkingRect.top += 20; // Offset within P2 box
                // Ensure default text alignment for this
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
                pRT->DrawText(L""Thinking..."", 11, pTextFormat, &thinkingRect, pThinkingBrush);
                SafeRelease(&pThinkingBrush);
            }
        }

        SafeRelease(&pBrush);

        // --- Draw CHEAT MODE label if active ---
        if (cheatModeEnabled) {
            ID2D1SolidColorBrush* pCheatBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Red), &pCheatBrush);
            if (pCheatBrush && pTextFormat) {
                D2D1_RECT_F cheatTextRect = D2D1::RectF(
                    TABLE_LEFT + 10.0f,
                    TABLE_TOP + 10.0f,
                    TABLE_LEFT + 200.0f,
                    TABLE_TOP + 40.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""CHEAT MODE ON"", wcslen(L""CHEAT MODE ON""), pTextFormat, &cheatTextRect, pCheatBrush);
            }
            SafeRelease(&pCheatBrush);
        }
    }

    void DrawPowerMeter(ID2D1RenderTarget* pRT) {
        // Draw Border
        ID2D1SolidColorBrush* pBorderBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pBorderBrush);
        if (!pBorderBrush) return;
        pRT->DrawRectangle(&powerMeterRect, pBorderBrush, 2.0f);
        SafeRelease(&pBorderBrush);

        // Create Gradient Fill
        ID2D1GradientStopCollection* pGradientStops = nullptr;
        ID2D1LinearGradientBrush* pGradientBrush = nullptr;
        D2D1_GRADIENT_STOP gradientStops[4];
        gradientStops[0].position = 0.0f;
        gradientStops[0].color = D2D1::ColorF(D2D1::ColorF::Green);
        gradientStops[1].position = 0.45f;
        gradientStops[1].color = D2D1::ColorF(D2D1::ColorF::Yellow);
        gradientStops[2].position = 0.7f;
        gradientStops[2].color = D2D1::ColorF(D2D1::ColorF::Orange);
        gradientStops[3].position = 1.0f;
        gradientStops[3].color = D2D1::ColorF(D2D1::ColorF::Red);

        pRT->CreateGradientStopCollection(gradientStops, 4, &pGradientStops);
        if (pGradientStops) {
            D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES props = {};
            props.startPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.bottom);
            props.endPoint = D2D1::Point2F(powerMeterRect.left, powerMeterRect.top);
            pRT->CreateLinearGradientBrush(props, pGradientStops, &pGradientBrush);
            SafeRelease(&pGradientStops);
        }

        // Calculate Fill Height
        float fillRatio = 0;
        //if (isAiming && (currentGameState == AIMING || currentGameState == BREAKING)) {
            // Determine if power meter should reflect shot power (human aiming or AI preparing)
        bool humanIsAimingPower = isAiming && (currentGameState == AIMING || currentGameState == BREAKING);
        // NEW Condition: AI is displaying its aim, so show its chosen power
        bool aiIsVisualizingPower = (isPlayer2AI && currentPlayer == 2 &&
            currentGameState == AI_THINKING && aiIsDisplayingAim);

        if (humanIsAimingPower || aiIsVisualizingPower) { // Use the new condition
            fillRatio = shotPower / MAX_SHOT_POWER;
        }
        float fillHeight = (powerMeterRect.bottom - powerMeterRect.top) * fillRatio;
        D2D1_RECT_F fillRect = D2D1::RectF(
            powerMeterRect.left,
            powerMeterRect.bottom - fillHeight,
            powerMeterRect.right,
            powerMeterRect.bottom
        );

        if (pGradientBrush) {
            pRT->FillRectangle(&fillRect, pGradientBrush);
            SafeRelease(&pGradientBrush);
        }

        // Draw scale notches
        ID2D1SolidColorBrush* pNotchBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pNotchBrush);
        if (pNotchBrush) {
            for (int i = 0; i <= 8; ++i) {
                float y = powerMeterRect.top + (powerMeterRect.bottom - powerMeterRect.top) * (i / 8.0f);
                pRT->DrawLine(
                    D2D1::Point2F(powerMeterRect.right + 2.0f, y),
                    D2D1::Point2F(powerMeterRect.right + 8.0f, y),
                    pNotchBrush,
                    1.5f
                );
            }
            SafeRelease(&pNotchBrush);
        }

        // Draw ""Power"" Label Below Meter
        if (pTextFormat) {
            ID2D1SolidColorBrush* pTextBrush = nullptr;
            pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black), &pTextBrush);
            if (pTextBrush) {
                D2D1_RECT_F textRect = D2D1::RectF(
                    powerMeterRect.left - 20.0f,
                    powerMeterRect.bottom + 8.0f,
                    powerMeterRect.right + 20.0f,
                    powerMeterRect.bottom + 38.0f
                );
                pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
                pRT->DrawText(L""Power"", 5, pTextFormat, &textRect, pTextBrush);
                SafeRelease(&pTextBrush);
            }
        }

        // Draw Glow Effect if fully charged or fading out
        static float glowPulse = 0.0f;
        static bool glowIncreasing = true;
        static float glowFadeOut = 0.0f; // NEW: tracks fading out

        if (shotPower >= MAX_SHOT_POWER * 0.99f) {
            // While fully charged, keep pulsing normally
            if (glowIncreasing) {
                glowPulse += 0.02f;
                if (glowPulse >= 1.0f) glowIncreasing = false;
            }
            else {
                glowPulse -= 0.02f;
                if (glowPulse <= 0.0f) glowIncreasing = true;
            }
            glowFadeOut = 1.0f; // Reset fade out to full
        }
        else if (glowFadeOut > 0.0f) {
            // If shot fired, gradually fade out
            glowFadeOut -= 0.02f;
            if (glowFadeOut < 0.0f) glowFadeOut = 0.0f;
        }

        if (glowFadeOut > 0.0f) {
            ID2D1SolidColorBrush* pGlowBrush = nullptr;
            float effectiveOpacity = (0.3f + 0.7f * glowPulse) * glowFadeOut;
            pRT->CreateSolidColorBrush(
                D2D1::ColorF(D2D1::ColorF::Red, effectiveOpacity),
                &pGlowBrush
            );
            if (pGlowBrush) {
                float glowCenterX = (powerMeterRect.left + powerMeterRect.right) / 2.0f;
                float glowCenterY = powerMeterRect.top;
                D2D1_ELLIPSE glowEllipse = D2D1::Ellipse(
                    D2D1::Point2F(glowCenterX, glowCenterY - 10.0f),
                    12.0f + 3.0f * glowPulse,
                    6.0f + 2.0f * glowPulse
                );
                pRT->FillEllipse(&glowEllipse, pGlowBrush);
                SafeRelease(&pGlowBrush);
            }
        }
    }

    void DrawSpinIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pWhiteBrush = nullptr;
        ID2D1SolidColorBrush* pRedBrush = nullptr;

        pRT->CreateSolidColorBrush(CUE_BALL_COLOR, &pWhiteBrush);
        pRT->CreateSolidColorBrush(ENGLISH_DOT_COLOR, &pRedBrush);

        if (!pWhiteBrush || !pRedBrush) {
            SafeRelease(&pWhiteBrush);
            SafeRelease(&pRedBrush);
            return;
        }

        // Draw White Ball Background
        D2D1_ELLIPSE bgEllipse = D2D1::Ellipse(spinIndicatorCenter, spinIndicatorRadius, spinIndicatorRadius);
        pRT->FillEllipse(&bgEllipse, pWhiteBrush);
        pRT->DrawEllipse(&bgEllipse, pRedBrush, 0.5f); // Thin red border


        // Draw Red Dot for Spin Position
        float dotRadius = 4.0f;
        float dotX = spinIndicatorCenter.x + cueSpinX * (spinIndicatorRadius - dotRadius); // Keep dot inside edge
        float dotY = spinIndicatorCenter.y + cueSpinY * (spinIndicatorRadius - dotRadius);
        D2D1_ELLIPSE dotEllipse = D2D1::Ellipse(D2D1::Point2F(dotX, dotY), dotRadius, dotRadius);
        pRT->FillEllipse(&dotEllipse, pRedBrush);

        SafeRelease(&pWhiteBrush);
        SafeRelease(&pRedBrush);
    }


    void DrawPocketedBallsIndicator(ID2D1RenderTarget* pRT) {
        ID2D1SolidColorBrush* pBgBrush = nullptr;
        ID2D1SolidColorBrush* pBallBrush = nullptr;

        // Ensure render target is valid before proceeding
        if (!pRT) return;

        HRESULT hr = pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Black, 0.8f), &pBgBrush); // Semi-transparent black
        if (FAILED(hr)) { SafeRelease(&pBgBrush); return; } // Exit if brush creation fails

        hr = pRT->CreateSolidColorBrush(D2D1::ColorF(0, 0, 0), &pBallBrush); // Placeholder, color will be set per ball
        if (FAILED(hr)) {
            SafeRelease(&pBgBrush);
            SafeRelease(&pBallBrush);
            return; // Exit if brush creation fails
        }

        // Draw the background bar (rounded rect)
        D2D1_ROUNDED_RECT roundedRect = D2D1::RoundedRect(pocketedBallsBarRect, 10.0f, 10.0f); // Corner radius 10
        float baseAlpha = 0.8f;
        float flashBoost = pocketFlashTimer * 0.5f; // Make flash effect boost alpha slightly
        float finalAlpha = std::min(1.0f, baseAlpha + flashBoost);
        pBgBrush->SetOpacity(finalAlpha);
        pRT->FillRoundedRectangle(&roundedRect, pBgBrush);
        pBgBrush->SetOpacity(1.0f); // Reset opacity after drawing

        // --- Draw small circles for pocketed balls inside the bar ---

        // Calculate dimensions based on the bar's height for better scaling
        float barHeight = pocketedBallsBarRect.bottom - pocketedBallsBarRect.top;
        float ballDisplayRadius = barHeight * 0.30f; // Make balls slightly smaller relative to bar height
        float spacing = ballDisplayRadius * 2.2f; // Adjust spacing slightly
        float padding = spacing * 0.75f; // Add padding from the edges
        float center_Y = pocketedBallsBarRect.top + barHeight / 2.0f; // Vertical center

        // Starting X positions with padding
        float currentX_P1 = pocketedBallsBarRect.left + padding;
        float currentX_P2 = pocketedBallsBarRect.right - padding; // Start from right edge minus padding

        int p1DrawnCount = 0;
        int p2DrawnCount = 0;
        const int maxBallsToShow = 7; // Max balls per player in the bar

        for (const auto& b : balls) {
            if (b.isPocketed) {
                // Skip cue ball and 8-ball in this indicator
                if (b.id == 0 || b.id == 8) continue;

                bool isPlayer1Ball = (player1Info.assignedType != BallType::NONE && b.type == player1Info.assignedType);
                bool isPlayer2Ball = (player2Info.assignedType != BallType::NONE && b.type == player2Info.assignedType);

                if (isPlayer1Ball && p1DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P1 balls from left to right
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P1 + p1DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p1DrawnCount++;
                }
                else if (isPlayer2Ball && p2DrawnCount < maxBallsToShow) {
                    pBallBrush->SetColor(b.color);
                    // Draw P2 balls from right to left
                    D2D1_ELLIPSE ballEllipse = D2D1::Ellipse(D2D1::Point2F(currentX_P2 - p2DrawnCount * spacing, center_Y), ballDisplayRadius, ballDisplayRadius);
                    pRT->FillEllipse(&ballEllipse, pBallBrush);
                    p2DrawnCount++;
                }
                // Note: Balls pocketed before assignment or opponent balls are intentionally not shown here.
                // You could add logic here to display them differently if needed (e.g., smaller, grayed out).
            }
        }

        SafeRelease(&pBgBrush);
        SafeRelease(&pBallBrush);
    }

    void DrawBallInHandIndicator(ID2D1RenderTarget* pRT) {
        if (!isDraggingCueBall && (currentGameState != BALL_IN_HAND_P1 && currentGameState != BALL_IN_HAND_P2 && currentGameState != PRE_BREAK_PLACEMENT)) {
            return; // Only show when placing/dragging
        }

        Ball* cueBall = GetCueBall();
        if (!cueBall) return;

        ID2D1SolidColorBrush* pGhostBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::White, 0.6f), &pGhostBrush); // Semi-transparent white

        if (pGhostBrush) {
            D2D1_POINT_2F drawPos;
            if (isDraggingCueBall) {
                drawPos = D2D1::Point2F((float)ptMouse.x, (float)ptMouse.y);
            }
            else {
                // If not dragging but in placement state, show at current ball pos
                drawPos = D2D1::Point2F(cueBall->x, cueBall->y);
            }

            // Check if the placement is valid before drawing differently?
            bool behindHeadstring = (currentGameState == PRE_BREAK_PLACEMENT);
            bool isValid = IsValidCueBallPosition(drawPos.x, drawPos.y, behindHeadstring);

            if (!isValid) {
                // Maybe draw red outline if invalid placement?
                pGhostBrush->SetColor(D2D1::ColorF(D2D1::ColorF::Red, 0.6f));
            }


            D2D1_ELLIPSE ghostEllipse = D2D1::Ellipse(drawPos, BALL_RADIUS, BALL_RADIUS);
            pRT->FillEllipse(&ghostEllipse, pGhostBrush);
            pRT->DrawEllipse(&ghostEllipse, pGhostBrush, 1.0f); // Outline

            SafeRelease(&pGhostBrush);
        }
    }

    void DrawPocketSelectionIndicator(ID2D1RenderTarget* pRT) {
        /*  Never show the arrow while the player is still placing the
        cue-ball (ball-in-hand) – it otherwise hides behind the
        ghost-ball and can lock the UI.                               */

        /* Still skip the opening-break placement,
       but show the arrow during BALL-IN-HAND */
       // ? skip when no active call for the CURRENT shooter
        if ((currentPlayer == 1 && calledPocketP1 < 0) ||
            (currentPlayer == 2 && calledPocketP2 < 0))    return;
        /*if (currentGameState == PRE_BREAK_PLACEMENT)
            return;*/ //new ai-asked-to-disable
            /*if (currentGameState == BALL_IN_HAND_P1 ||
                currentGameState == BALL_IN_HAND_P2 ||
                currentGameState == PRE_BREAK_PLACEMENT)
            {
                return;
            }*/

        int pocketToIndicate = -1;
        // Whenever EITHER player has pocketed their first 7 and has called (human or AI),
        // we forcibly show their arrow—regardless of currentGameState.
        if ((currentPlayer == 1 && player1Info.ballsPocketedCount >= 7 && calledPocketP1 >= 0) ||
            (currentPlayer == 2 && player2Info.ballsPocketedCount >= 7 && calledPocketP2 >= 0))
        {
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        /*// A human player is actively choosing if they are in the CHOOSING_POCKET state.
        bool isHumanChoosing = (currentGameState == CHOOSING_POCKET_P1 || (currentGameState == CHOOSING_POCKET_P2 && !isPlayer2AI));

        if (isHumanChoosing) {
            // When choosing, show the currently selected pocket (which has a default).
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }
        else if (IsPlayerOnEightBall(currentPlayer)) {
            // If it's a normal turn but the player is on the 8-ball, show their called pocket as a reminder.
            pocketToIndicate = (currentPlayer == 1) ? calledPocketP1 : calledPocketP2;
        }*/

        if (pocketToIndicate < 0 || pocketToIndicate > 5) {
            return; // Don't draw if no pocket is selected or relevant.
        }

        ID2D1SolidColorBrush* pArrowBrush = nullptr;
        pRT->CreateSolidColorBrush(D2D1::ColorF(D2D1::ColorF::Yellow, 0.9f), &pArrowBrush);
        if (!pArrowBrush) return;

        // ... The rest of your arrow drawing geometry logic remains exactly the same ...
        // (No changes needed to the points/path drawing, only the logic above)
        D2D1_POINT_2F targetPocketCenter = pocketPositions[pocketToIndicate];
        float arrowHeadSize = HOLE_VISUAL_RADIUS * 0.5f;
        float arrowShaftLength = HOLE_VISUAL_RADIUS * 0.3f;
        float arrowShaftWidth = arrowHeadSize * 0.4f;
        float verticalOffsetFromPocketCenter = HOLE_VISUAL_RADIUS * 1.6f;
        D2D1_POINT_2F tip, baseLeft, baseRight, shaftTopLeft, shaftTopRight, shaftBottomLeft, shaftBottomRight;

        if (targetPocketCenter.y == TABLE_TOP) {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y + verticalOffsetFromPocketCenter + arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y + verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y - arrowShaftLength);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y - arrowShaftLength);
        }
        else {
            tip = D2D1::Point2F(targetPocketCenter.x, targetPocketCenter.y - verticalOffsetFromPocketCenter - arrowHeadSize);
            baseLeft = D2D1::Point2F(targetPocketCenter.x - arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            baseRight = D2D1::Point2F(targetPocketCenter.x + arrowHeadSize / 2.0f, targetPocketCenter.y - verticalOffsetFromPocketCenter);
            shaftTopLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y + arrowShaftLength);
            shaftTopRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y + arrowShaftLength);
            shaftBottomLeft = D2D1::Point2F(targetPocketCenter.x - arrowShaftWidth / 2.0f, baseLeft.y);
            shaftBottomRight = D2D1::Point2F(targetPocketCenter.x + arrowShaftWidth / 2.0f, baseRight.y);
        }

        ID2D1PathGeometry* pPath = nullptr;
        if (SUCCEEDED(pFactory->CreatePathGeometry(&pPath))) {
            ID2D1GeometrySink* pSink = nullptr;
            if (SUCCEEDED(pPath->Open(&pSink))) {
                pSink->BeginFigure(tip, D2D1_FIGURE_BEGIN_FILLED);
                pSink->AddLine(baseLeft); pSink->AddLine(shaftBottomLeft); pSink->AddLine(shaftTopLeft);
                pSink->AddLine(shaftTopRight); pSink->AddLine(shaftBottomRight); pSink->AddLine(baseRight);
                pSink->EndFigure(D2D1_FIGURE_END_CLOSED);
                pSink->Close();
                SafeRelease(&pSink);
                pRT->FillGeometry(pPath, pArrowBrush);
            }
            SafeRelease(&pPath);
        }
        SafeRelease(&pArrowBrush);
    }
```

==++ Here's the full source for (file 2/3 (No OOP-based)) ""resource.h""::: ++==
```resource.h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Yahoo-8Ball-Pool-Clone.rc
//
#define IDI_ICON1                       101
// --- NEW Resource IDs (Define these in your .rc file / resource.h) ---
#define IDD_NEWGAMEDLG 106
#define IDC_RADIO_2P   1003
#define IDC_RADIO_CPU  1005
#define IDC_GROUP_AI   1006
#define IDC_RADIO_EASY 1007
#define IDC_RADIO_MEDIUM 1008
#define IDC_RADIO_HARD 1009
// --- NEW Resource IDs for Opening Break ---
#define IDC_GROUP_BREAK_MODE 1010
#define IDC_RADIO_CPU_BREAK  1011
#define IDC_RADIO_P1_BREAK   1012
#define IDC_RADIO_FLIP_BREAK 1013
// --- NEW Resource ID for Table Color Dropdown ---
#define IDC_COMBO_TABLECOLOR 1014
// Standard IDOK is usually defined, otherwise define it (e.g., #define IDOK 1)

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40002 // Incremented
#define _APS_NEXT_CONTROL_VALUE         1014 // Incremented
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

==++ Here's the full source for (file 3/3 (No OOP-based)) ""Yahoo-8Ball-Pool-Clone.rc""::: ++==
```Yahoo-8Ball-Pool-Clone.rc
// Microsoft Visual C++ generated resource script.
//
#include ""resource.h""

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include ""winres.h""

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
""resource.h\0""
END

2 TEXTINCLUDE
BEGIN
""#include """"winres.h""""\r\n""
""\0""
END

3 TEXTINCLUDE
BEGIN
""\r\n""
""\0""
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    ""D:\\Download\\8Ball_Colored.ico""

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

#include <windows.h> // Needed for control styles like WS_GROUP, BS_AUTORADIOBUTTON etc.

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_NEWGAMEDLG DIALOGEX 0, 0, 220, 185 // Dialog position (x, y) and size (width, height) in Dialog Units (DLUs) - Increased Height
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION ""New 8-Ball Game""
FONT 8, ""MS Shell Dlg"", 400, 0, 0x1 // Standard dialog font
BEGIN
// --- Game Mode Selection ---
// Group Box for Game Mode (Optional visually, but helps structure)
GROUPBOX        ""Game Mode"", IDC_STATIC, 7, 7, 90, 50

// ""2 Player"" Radio Button (First in this group)
CONTROL         ""&2 Player (Human vs Human)"", IDC_RADIO_2P, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 14, 20, 80, 10

// ""Human vs CPU"" Radio Button
CONTROL         ""Human vs &CPU"", IDC_RADIO_CPU, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 14, 35, 70, 10

// --- NEW: Table Color Selection ---
LTEXT           ""Table Color:"", IDC_STATIC, 7, 65, 50, 8
COMBOBOX        IDC_COMBO_TABLECOLOR, 7, 75, 90, 60,
CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP


// --- AI Difficulty Selection (Inside its own Group Box) ---
GROUPBOX        ""AI Difficulty"", IDC_GROUP_AI, 118, 7, 95, 70

// ""Easy"" Radio Button (First in the AI group)
CONTROL         ""&Easy"", IDC_RADIO_EASY, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 20, 60, 10

// ""Medium"" Radio Button
CONTROL         ""&Medium"", IDC_RADIO_MEDIUM, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 35, 60, 10

// ""Hard"" Radio Button
CONTROL         ""&Hard"", IDC_RADIO_HARD, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 50, 60, 10

// --- Opening Break Modes (For Versus CPU Only) ---
GROUPBOX        ""Opening Break Modes:"", IDC_GROUP_BREAK_MODE, 118, 82, 95, 60

// ""CPU Break"" Radio Button (Default for this group)
CONTROL         ""&CPU Break"", IDC_RADIO_CPU_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP, 125, 95, 70, 10

// ""P1 Break"" Radio Button
CONTROL         ""&P1 Break"", IDC_RADIO_P1_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 110, 70, 10

// ""FlipCoin Break"" Radio Button
CONTROL         ""&FlipCoin Break"", IDC_RADIO_FLIP_BREAK, ""Button"",
BS_AUTORADIOBUTTON | WS_TABSTOP, 125, 125, 70, 10


// --- Standard Buttons ---
DEFPUSHBUTTON   ""Start"", IDOK, 55, 160, 50, 14 // Default button (Enter key) - Adjusted Y position
PUSHBUTTON      ""Cancel"", IDCANCEL, 115, 160, 50, 14 // Adjusted Y position
END
```"
9aY2kHrp,Name Monitor,zjford,Lua,Monday 4th of August 2025 05:21:23 AM CDT,"-- Simple script to display a message on a monitor

-- Find the monitor connected to the computer
-- ""top"", ""bottom"", ""left"", ""right"", ""front"", ""back"" are valid sides
local monitor = peripheral.find(""monitor"")

-- Check if a monitor was actually found
if monitor == nil then
  print(""Error: No monitor attached!"")
  return -- Stop the script if no monitor is found
end

-- Clear the monitor of any previous text
monitor.clear()

-- Set the cursor to the top-left corner (position 1, 1)
monitor.setCursorPos(1, 1)

-- Write the message to the monitor
monitor.write(""Haydens Home"")"
vsa2Nw0n,Seplos BMS 2 stk,keldbroe,YAML,Monday 4th of August 2025 04:39:00 AM CDT,"substitutions:
  name: neeybalancers
  device0: balancer1
  device1: balancer2
  device2: balancer3
  device_description: ""Monitor and control a Heltec/NEEY 4A balancer via bluetooth""
  external_components_source: github://syssi/esphome-jk-bms@main
  mac_address: 00:E4:4C:21:D8:35
  mac_address2: 00:E4:4C:21:D3:BB
#  mac_address3: 00:E4:4C:21:D6:0C

esphome:
  name: ${name}
  friendly_name: ""NEEY Batteri 1 og 2""
  comment: ${device_description}
  project:
    name: ""syssi.esphome-jk-bms""
    version: 1.4.0

esp32:
  board: esp32dev
  framework:
    type: esp-idf

external_components:
  - source: ${external_components_source}
    refresh: 0s

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Optional manual IP
#  manual_ip:
#    static_ip: 10.0.0.58
#    gateway: 10.0.0.1
#    subnet: 255.255.255.0

ota:
 - platform: esphome

logger:
  level: DEBUG

# If you don't use Home Assistant please remove this `api` section and uncomment the `mqtt` component!
api:
  encryption:
    key: !secret esphome_encryption_key

# mqtt:
#   broker: !secret mqtt_host
#   username: !secret mqtt_username
#   password: !secret mqtt_password
#   id: mqtt_client

esp32_ble_tracker:
  on_ble_advertise:
    then:
      - lambda: |-
          if (x.get_name().rfind(""GW-"", 0) == 0) {
            ESP_LOGI(""ble_adv"", ""New Heltec/NEEY balancer found"");
            ESP_LOGI(""ble_adv"", ""  Name: %s"", x.get_name().c_str());
            ESP_LOGI(""ble_adv"", ""  MAC address: %s"", x.address_str().c_str());
            ESP_LOGD(""ble_adv"", ""  Advertised service UUIDs:"");
            for (auto uuid : x.get_service_uuids()) {
              ESP_LOGD(""ble_adv"", ""    - %s"", uuid.to_string().c_str());
            }
          }

ble_client:
  - mac_address: ${mac_address}
    id: client0
  - mac_address: ${mac_address2}
    id: client1
#  - mac_address: ${mac_address3}
#    id: client2
  

heltec_balancer_ble:
  - ble_client_id: client0
    throttle: 11s
    id: bms0
  - ble_client_id: client1
    throttle: 10s
    id: bms1
#  - ble_client_id: client2
#    throttle: 8s
#    id: bms2
      
binary_sensor:
  - platform: heltec_balancer_ble
    heltec_balancer_ble_id: bms0
    balancing:
      name: ""${device0} balancing""
    online_status:
      name: ""${device0} online status""
  - platform: heltec_balancer_ble
    heltec_balancer_ble_id: bms1
    balancing:
      name: ""${device1} balancing""
    online_status:
      name: ""${device1} online status""
#  - platform: heltec_balancer_ble
#    heltec_balancer_ble_id: bms2
#    balancing:
#      name: ""${device2} balancing""
#    online_status:
#      name: ""${device2} online status""

button:
  - platform: heltec_balancer_ble
    heltec_balancer_ble_id: bms0
    retrieve_settings:
      name: ""${device0} retrieve settings""
    retrieve_device_info:
      name: ""${device0} retrieve device info""
    retrieve_factory_defaults:
      name: ""${device0} retrieve factory defaults""
  - platform: heltec_balancer_ble
    heltec_balancer_ble_id: bms1
    retrieve_settings:
      name: ""${device1} retrieve settings""
    retrieve_device_info:
      name: ""${device1} retrieve device info""
    retrieve_factory_defaults:
      name: ""${device1} retrieve factory defaults""
#  - platform: heltec_balancer_ble
#    heltec_balancer_ble_id: bms2
#    retrieve_settings:
#      name: ""${device2} retrieve settings""
#    retrieve_device_info:
#      name: ""${device2} retrieve device info""
#    retrieve_factory_defaults:
#      name: ""${device2} retrieve factory defaults""


sensor:

  - platform: heltec_balancer_ble
    heltec_balancer_ble_id: bms0
    min_cell_voltage:
      name: ""${device0} min cell voltage""     
    max_cell_voltage:
      name: ""${device0} max cell voltage""
    min_voltage_cell:
      name: ""${device0} min voltage cell""
    max_voltage_cell:
      name: ""${device0} max voltage cell""
    delta_cell_voltage:
      name: ""${device0} delta cell voltage""
    average_cell_voltage:
      name: ""${device0} average cell voltage""
    cell_voltage_1:
      name: ""${device0} cell voltage 1""
    cell_voltage_2:
      name: ""${device0} cell voltage 2""
    cell_voltage_3:
      name: ""${device0} cell voltage 3""
    cell_voltage_4:
      name: ""${device0} cell voltage 4""
    cell_voltage_5:
      name: ""${device0} cell voltage 5""
    cell_voltage_6:
      name: ""${device0} cell voltage 6""
    cell_voltage_7:
      name: ""${device0} cell voltage 7""
    cell_voltage_8:
      name: ""${device0} cell voltage 8""
    cell_voltage_9:
      name: ""${device0} cell voltage 9""
    cell_voltage_10:
      name: ""${device0} cell voltage 10""
    cell_voltage_11:
      name: ""${device0} cell voltage 11""
    cell_voltage_12:
      name: ""${device0} cell voltage 12""
    cell_voltage_13:
      name: ""${device0} cell voltage 13""
    cell_voltage_14:
      name: ""${device0} cell voltage 14""
    cell_voltage_15:
      name: ""${device0} cell voltage 15""
    cell_voltage_16:
      name: ""${device0} cell voltage 16""
    total_voltage:
      name: ""${device0} total voltage""
    temperature_sensor_1:
      name: ""${device0} temperature sensor 1""
    temperature_sensor_2:
      name: ""${device0} temperature sensor 2""
    total_runtime:
      name: ""${device0} total runtime""
    balancing_current:
      name: ""${device0} balancing current""


  - platform: heltec_balancer_ble
    heltec_balancer_ble_id: bms1
    min_cell_voltage:
      name: ""${device1} min cell voltage""
    max_cell_voltage:
      name: ""${device1} max cell voltage""
    min_voltage_cell:
      name: ""${device1} min voltage cell""
    max_voltage_cell:
      name: ""${device1} max voltage cell""
    delta_cell_voltage:
      name: ""${device1} delta cell voltage""
    average_cell_voltage:
      name: ""${device1} average cell voltage""
    cell_voltage_1:
      name: ""${device1} cell voltage 1""
    cell_voltage_2:
      name: ""${device1} cell voltage 2""
    cell_voltage_3:
      name: ""${device1} cell voltage 3""
    cell_voltage_4:
      name: ""${device1} cell voltage 4""
    cell_voltage_5:
      name: ""${device1} cell voltage 5""
    cell_voltage_6:
      name: ""${device1} cell voltage 6""
    cell_voltage_7:
      name: ""${device1} cell voltage 7""
    cell_voltage_8:
      name: ""${device1} cell voltage 8""
    cell_voltage_9:
      name: ""${device1} cell voltage 9""
    cell_voltage_10:
      name: ""${device1} cell voltage 10""
    cell_voltage_11:
      name: ""${device1} cell voltage 11""
    cell_voltage_12:
      name: ""${device1} cell voltage 12""
    cell_voltage_13:
      name: ""${device1} cell voltage 13""
    cell_voltage_14:
      name: ""${device1} cell voltage 14""
    cell_voltage_15:
      name: ""${device1} cell voltage 15""
    cell_voltage_16:
      name: ""${device1} cell voltage 16""
    total_voltage:
      name: ""${device1} total voltage""
    temperature_sensor_1:
      name: ""${device1} temperature sensor 1""
    temperature_sensor_2:
      name: ""${device1} temperature sensor 2""
    total_runtime:
      name: ""${device1} total runtime""
    balancing_current:
      name: ""${device1} balancing current""


#  - platform: heltec_balancer_ble
#    heltec_balancer_ble_id: bms2
#    min_cell_voltage:
#      name: ""${device2} min cell voltage""
#    max_cell_voltage:
#      name: ""${device2} max cell voltage""
#    min_voltage_cell:
#      name: ""${device2} min voltage cell""
#    max_voltage_cell:
#      name: ""${device2} max voltage cell""
#    delta_cell_voltage:
#      name: ""${device2} delta cell voltage""
#    average_cell_voltage:
#      name: ""${device2} average cell voltage""
#    cell_voltage_1:
#      name: ""${device2} cell voltage 1""
#    cell_voltage_2:
#      name: ""${device2} cell voltage 2""
#    cell_voltage_3:
#      name: ""${device2} cell voltage 3""
#    cell_voltage_4:
#      name: ""${device2} cell voltage 4""
#    cell_voltage_5:
#      name: ""${device2} cell voltage 5""
#    cell_voltage_6:
#      name: ""${device2} cell voltage 6""
#    cell_voltage_7:
#      name: ""${device2} cell voltage 7""
#    cell_voltage_8:
#      name: ""${device2} cell voltage 8""
#    cell_voltage_9:
#      name: ""${device2} cell voltage 9""
#    cell_voltage_10:
#      name: ""${device2} cell voltage 10""
#    cell_voltage_11:
#      name: ""${device2} cell voltage 11""
#    cell_voltage_12:
#      name: ""${device2} cell voltage 12""
#    cell_voltage_13:
#      name: ""${device2} cell voltage 13""
#    cell_voltage_14:
#      name: ""${device2} cell voltage 14""
#    cell_voltage_15:
#      name: ""${device2} cell voltage 15""
#    cell_voltage_16:
#      name: ""${device2} cell voltage 16""
#    total_voltage:
#      name: ""${device2} total voltage""
#    temperature_sensor_1:
#      name: ""${device2} temperature sensor 1""
#    temperature_sensor_2:
#      name: ""${device2} temperature sensor 2""
#    total_runtime:
#      name: ""${device2} total runtime""
#    balancing_current:
#      name: ""${device2} balancing current"""
vEmpadz3,JK BMS - 1 stk,keldbroe,YAML,Monday 4th of August 2025 04:38:32 AM CDT,"substitutions:
  name: ""jkbms-battery-4""
  device_description: ""Monitor and control a JK-BMS via bluetooth""
  external_components_source: github://syssi/esphome-jk-bms@main
  mac_address: C8:47:80:21:22:6C
  # Please use ""JK02_24S"" if you own a old JK-BMS < hardware version 11.0 (hardware version >= 6.0 and < 11.0)
  # Please use ""JK02_32S"" if you own a new JK-BMS >= hardware version 11.0 (f.e. JK-B2A8S20P hw 11.XW, sw 11.26)
  # Please use ""JK04"" if you have some old JK-BMS <= hardware version 3.0 (f.e. JK-B2A16S hw 3.0, sw. 3.3.0)
  protocol_version: JK02_32S

esphome:
  name: ${name}
  friendly_name: ""JK BMS Batteri 4""
  comment: ${device_description}
  min_version: 2024.6.0
  project:
    name: ""syssi.esphome-jk-bms""
    version: 2.1.0

esp32:
  board: esp32dev
  framework:
    type: esp-idf

external_components:
  - source: ${external_components_source}
    refresh: 0s

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

ota:
  platform: esphome
  on_begin:
    then:
      - switch.turn_off: ble_client_switch0
      - logger.log: ""BLE connection suspended for OTA update""

logger:
  level: DEBUG
  logs:
    esp32_ble_tracker: INFO
    esp32_ble_client: INFO

# If you don't use Home Assistant please remove this `api` section and uncomment the `mqtt` component!
api:

# mqtt:
#   broker: !secret mqtt_host
#   username: !secret mqtt_username
#   password: !secret mqtt_password
#   id: mqtt_client

esp32_ble_tracker:
  scan_parameters:
    active: false

ble_client:
  - mac_address: ${mac_address}
    id: client0


jk_bms_ble:
  - ble_client_id: client0
    protocol_version: ${protocol_version}
    throttle: 15s
    id: bms0

binary_sensor:
  - platform: jk_bms_ble
    balancing:
      name: ""${name} balancing""
    charging:
      name: ""${name} charging""
    discharging:
      name: ""${name} discharging""
    heating:
      name: ""${name} heating""
    online_status:
      name: ""${name} online status""

button:
  - platform: jk_bms_ble
    retrieve_settings:
      name: ""${name} retrieve settings""
    retrieve_device_info:
      name: ""${name} retrieve device info""

number:
  - platform: jk_bms_ble
    jk_bms_ble_id: bms0
    balance_trigger_voltage:
      name: ""${name} balance trigger voltage""
    cell_count:
      name: ""${name} cell count""
    total_battery_capacity:
      name: ""${name} total battery capacity""
    cell_voltage_overvoltage_protection:
      name: ""${name} cell voltage overvoltage protection""
    cell_voltage_overvoltage_recovery:
      name: ""${name} cell voltage overvoltage recovery""
    cell_voltage_undervoltage_protection:
      name: ""${name} cell voltage undervoltage protection""
    cell_voltage_undervoltage_recovery:
      name: ""${name} cell voltage undervoltage recovery""
    balance_starting_voltage:
      name: ""${name} balance starting voltage""
    voltage_calibration:
      name: ""${name} voltage calibration""
    current_calibration:
      name: ""${name} current calibration""
    power_off_voltage:
      name: ""${name} power off voltage""
    max_balance_current:
      name: ""${name} max balance current""
    max_charge_current:
      name: ""${name} max charge current""
    max_discharge_current:
      name: ""${name} max discharge current""
    smart_sleep_voltage:
      name: ""${name} smart sleep voltage""
    cell_soc100_voltage:
      name: ""${name} cell soc100 voltage""
    cell_soc0_voltage:
      name: ""${name} cell soc0 voltage""
    cell_request_charge_voltage:
      name: ""${name} cell request charge voltage""
    cell_request_float_voltage:
      name: ""${name} cell request float voltage""
    cell_request_charge_voltage_time:
      name: ""${name} cell request charge voltage time""
    cell_request_float_voltage_time:
      name: ""${name} cell request float voltage time""
    charge_overcurrent_protection_delay:
      name: ""${name} charge overcurrent protection delay""
    charge_overcurrent_protection_recovery_time:
      name: ""${name} charge overcurrent protection recovery time""
    discharge_overcurrent_protection_delay:
      name: ""${name} discharge overcurrent protection delay""
    discharge_overcurrent_protection_recovery_time:
      name: ""${name} discharge overcurrent protection recovery time""
    short_circuit_protection_delay:
      name: ""${name} short circuit protection delay""
    short_circuit_protection_recovery_time:
      name: ""${name} short circuit protection recovery time""
    charge_overtemperature_protection:
      name: ""${name} charge overtemperature protection""
    charge_overtemperature_protection_recovery:
      name: ""${name} charge overtemperature protection recovery""
    discharge_overtemperature_protection:
      name: ""${name} discharge overtemperature protection""
    discharge_overtemperature_protection_recovery:
      name: ""${name} discharge overtemperature protection recovery""
    charge_undertemperature_protection:
      name: ""${name} charge undertemperature protection""
    charge_undertemperature_protection_recovery:
      name: ""${name} charge undertemperature protection recovery""
    power_tube_overtemperature_protection:
      name: ""${name} power tube overtemperature protection""
    power_tube_overtemperature_protection_recovery:
      name: ""${name} power tube overtemperature protection recovery""

sensor:
  - platform: jk_bms_ble
    jk_bms_ble_id: bms0
    min_cell_voltage:
      name: ""${name} min cell voltage""
    max_cell_voltage:
      name: ""${name} max cell voltage""
    min_voltage_cell:
      name: ""${name} min voltage cell""
    max_voltage_cell:
      name: ""${name} max voltage cell""
    delta_cell_voltage:
      name: ""${name} delta cell voltage""
    average_cell_voltage:
      name: ""${name} average cell voltage""
    cell_voltage_1:
      name: ""${name} cell voltage 1""
    cell_voltage_2:
      name: ""${name} cell voltage 2""
    cell_voltage_3:
      name: ""${name} cell voltage 3""
    cell_voltage_4:
      name: ""${name} cell voltage 4""
    cell_voltage_5:
      name: ""${name} cell voltage 5""
    cell_voltage_6:
      name: ""${name} cell voltage 6""
    cell_voltage_7:
      name: ""${name} cell voltage 7""
    cell_voltage_8:
      name: ""${name} cell voltage 8""
    cell_voltage_9:
      name: ""${name} cell voltage 9""
    cell_voltage_10:
      name: ""${name} cell voltage 10""
    cell_voltage_11:
      name: ""${name} cell voltage 11""
    cell_voltage_12:
      name: ""${name} cell voltage 12""
    cell_voltage_13:
      name: ""${name} cell voltage 13""
    cell_voltage_14:
      name: ""${name} cell voltage 14""
    cell_voltage_15:
      name: ""${name} cell voltage 15""
    cell_voltage_16:
      name: ""${name} cell voltage 16""
    cell_resistance_1:
      name: ""${name} cell resistance 1""
    cell_resistance_2:
      name: ""${name} cell resistance 2""
    cell_resistance_3:
      name: ""${name} cell resistance 3""
    cell_resistance_4:
      name: ""${name} cell resistance 4""
    cell_resistance_5:
      name: ""${name} cell resistance 5""
    cell_resistance_6:
      name: ""${name} cell resistance 6""
    cell_resistance_7:
      name: ""${name} cell resistance 7""
    cell_resistance_8:
      name: ""${name} cell resistance 8""
    cell_resistance_9:
      name: ""${name} cell resistance 9""
    cell_resistance_10:
      name: ""${name} cell resistance 10""
    cell_resistance_11:
      name: ""${name} cell resistance 11""
    cell_resistance_12:
      name: ""${name} cell resistance 12""
    cell_resistance_13:
      name: ""${name} cell resistance 13""
    cell_resistance_14:
      name: ""${name} cell resistance 14""
    cell_resistance_15:
      name: ""${name} cell resistance 15""
    cell_resistance_16:
      name: ""${name} cell resistance 16""
    total_voltage:
      name: ""${name} total voltage""
    current:
      name: ""${name} current""
    heating_current:
      name: ""${name} heating current""
    power:
      name: ""${name} power""
    charging_power:
      name: ""${name} charging power""
    discharging_power:
      name: ""${name} discharging power""
    temperature_sensor_1:
      name: ""${name} temperature sensor 1""
    temperature_sensor_2:
      name: ""${name} temperature sensor 2""
    temperature_sensor_3:
      name: ""${name} temperature sensor 3""
    temperature_sensor_4:
      name: ""${name} temperature sensor 4""
    temperature_sensor_5:
      name: ""${name} temperature sensor 5""
    power_tube_temperature:
      name: ""${name} power tube temperature""
    balancing:
      name: ""${name} balancing""
    state_of_charge:
      name: ""${name} state of charge""
    capacity_remaining:
      name: ""${name} capacity remaining""
    total_battery_capacity_setting:
      name: ""${name} total battery capacity setting""
    charging_cycles:
      name: ""${name} charging cycles""
    total_charging_cycle_capacity:
      name: ""${name} total charging cycle capacity""
    total_runtime:
      name: ""${name} total runtime""
    balancing_current:
      name: ""${name} balancing current""
    errors_bitmask:
      name: ""${name} errors bitmask""
    emergency_time_countdown:
      name: ""${name} emergency time countdown""

switch:
  - platform: jk_bms_ble
    charging:
      name: ""${name} charging""
    discharging:
      name: ""${name} discharging""
    balancer:
      name: ""${name} balancer""
    emergency:
      name: ""${name} emergency""
    heating:
      name: ""${name} heating""
    disable_temperature_sensors:
      name: ""${name} disable temperature sensors""
    display_always_on:
      name: ""${name} display always on""
    smart_sleep:
      name: ""${name} smart sleep""
    disable_pcl_module:
      name: ""${name} disable pcl module""
    timed_stored_data:
      name: ""${name} timed stored data""
    charging_float_mode:
      name: ""${name} charging float mode""

  - platform: ble_client
    ble_client_id: client0
    id: ble_client_switch0
    name: ""${name} enable bluetooth connection""

text_sensor:
  - platform: jk_bms_ble
    errors:
      name: ""${name} errors""
    total_runtime_formatted:
      name: ""${name} total runtime formatted"""
jWXAU3N3,scripter application laser freeze gun,momo561,Lua,Monday 4th of August 2025 04:03:12 AM CDT,"-- Text showing when freeze laser tool activated local script
local Players = game:GetService(""Players"")
local LocalPlayer = Players.LocalPlayer
local Backpack = LocalPlayer:WaitForChild(""Backpack"")
local StarterGui = game:GetService(""StarterGui"")
local gui = script.Parent
local textLabel = gui:FindFirstChild(""ShootCUI"")
if not textLabel then
    textLabel = Instance.new(""TextLabel"")
    textLabel.Name = ""ShootCUI""
    textLabel.Size = UDim2.new(0.3, 0, 0.1, 0)
    textLabel.Position = UDim2.new(0.35, 0, 0.4, 0)
    textLabel.BackgroundTransparency = 0.3
    textLabel.BackgroundColor3 = Color3.new(0, 0, 0)
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextScaled = true
    textLabel.Text = ""FIRE!""
    textLabel.Visible = false
    textLabel.Parent = gui
end
-- Helper to show and hide the CUI
local function showCUI()
    textLabel.Visible = true
    task.wait(0.5)
    textLabel.Visible = false
end
-- Listen for tool activation
local function connectTool(tool)
    if tool:IsA(""Tool"") then
        tool.Activated:Connect(function()
            showCUI()
        end)
    end
end
-- Connect to all tools currently in Backpack
for _, tool in Backpack:GetChildren() do
    connectTool(tool)
end
-- Listen for new tools added to Backpack
Backpack.ChildAdded:Connect(function(child)
    connectTool(child)
end)
-- Also listen for tools equipped directly (in case of StarterGear/character respawn)
LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(0.1)
    for _, tool in character:GetChildren() do
        connectTool(tool)
    end
    character.ChildAdded:Connect(function(child)
        connectTool(child)
    end)
end)
-- Freeze player with freeze Gun local script
local Players = game:GetService(""Players"")
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local FreezeEvent = ReplicatedStorage:WaitForChild(""FreezePlayerEvent"")
local ShowFreezeHitText = ReplicatedStorage:WaitForChild(""ShowFreezeHitText"")
local StarterGui = game:GetService(""StarterGui"")
local tool = script.Parent
local player = Players.LocalPlayer
local mouse = nil
tool.Equipped:Connect(function()
	mouse = player:GetMouse()
end)
tool.Activated:Connect(function()
	if not mouse then return end
	local target = mouse.Target
	if target and target.Parent then
		local humanoid = target.Parent:FindFirstChild(""Humanoid"")
		if humanoid and Players:GetPlayerFromCharacter(target.Parent) and Players:GetPlayerFromCharacter(target.Parent) ~= player then
			FreezeEvent:FireServer(target.Parent)
		end
	end
end)
local guiName = ""FreezeHitFeedbackGui""
local messageText = ""You hit a player with your freeze laser!""
local displayTime = 2 -- seconds
-- Create the GUI if it doesn't exist
local function getOrCreateGui()
	local playerGui = player:FindFirstChildOfClass(""PlayerGui"")
	if not playerGui then return nil end
	local gui = playerGui:FindFirstChild(guiName)
	if not gui then
		gui = Instance.new(""ScreenGui"")
		gui.Name = guiName
		gui.ResetOnSpawn = false
		gui.Parent = playerGui
		local label = Instance.new(""TextLabel"")
		label.Name = ""FeedbackLabel""
		label.Size = UDim2.new(0.5, 0, 0.1, 0)
		label.Position = UDim2.new(0.25, 0, 0.2, 0)
		label.BackgroundTransparency = 0.3
		label.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		label.TextColor3 = Color3.fromRGB(0, 200, 255)
		label.Font = Enum.Font.SourceSansBold
		label.TextScaled = true
		label.Text = """"
		label.Visible = false
		label.Parent = gui
	end
	return gui
end
ShowFreezeHitText.OnClientEvent:Connect(function()
	local gui = getOrCreateGui()
	if not gui then return end
	local label = gui:FindFirstChild(""FeedbackLabel"")
	if not label then return end
	label.Text = messageText
	label.Visible = true
	label.TextTransparency = 0
	label.BackgroundTransparency = 0.3
	-- Fade out after displayTime seconds
	spawn(function()
		task.wait(displayTime)
		for i = 0, 1, 0.1 do
			label.TextTransparency = i
			label.BackgroundTransparency = 0.3 + 0.7 * i
			task.wait(0.03)
		end
		label.Visible = false
	end)
	StarterGui:SetCore(""ChatMakeSystemMessage"", {
		Text = ""You hit a player with your freeze laser!"";
		Color = Color3.fromRGB(0, 200, 255);
		Font = Enum.Font.SourceSansBold;
		FontSize = Enum.FontSize.Size24;
	})
end)
-- Freeze player with freeze Gun server script
local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local Players = game:GetService(""Players"")
local FreezeEvent = ReplicatedStorage:WaitForChild(""FreezePlayerEvent"")
local ShowFreezeHitText = ReplicatedStorage:WaitForChild(""ShowFreezeHitText"")
local FREEZE_TIME = 40 -- seconds
local function freezeCharacter(character)
	local humanoid = character:FindFirstChild(""Humanoid"")
	local root = character:FindFirstChild(""HumanoidRootPart"")
	if humanoid and root then
		local oldWalkSpeed = humanoid.WalkSpeed
		local oldJumpPower = humanoid.JumpPower
		humanoid.WalkSpeed = 0
		humanoid.JumpPower = 0
		root.Anchored = true
		task.wait(FREEZE_TIME)
		print(""end of freeze time"")
		humanoid.WalkSpeed = oldWalkSpeed
		humanoid.JumpPower = oldJumpPower
		root.Anchored = false
	end
end
FreezeEvent.OnServerEvent:Connect(function(player, targetCharacter)
	if typeof(targetCharacter) ~= ""Instance"" then return end
	if not targetCharacter:IsDescendantOf(game.Workspace) then return end
	local targetPlayer = Players:GetPlayerFromCharacter(targetCharacter)
	if targetPlayer and targetPlayer ~= player then
		freezeCharacter(targetCharacter)
		-- Notify shooter that they hit a player
		ShowFreezeHitText:FireClient(player)
	end
end)
-- blue laser effect from laser freeze gun
local tool = script.Parent
local handle = tool:FindFirstChild(""Handle"")
-- Settings
local LASER_COLOR = Color3.fromRGB(0, 170, 255)
local LASER_THICKNESS = 0.2
local LASER_DURATION = 0.1
local LASER_TRANSPARENCY = 0.25
local LASER_MATERIAL = Enum.Material.Neon
local LASER_RANGE = 300
local function createLaser(startPos, endPos)
	local laser = Instance.new(""Part"")
	laser.Anchored = true
	laser.CanCollide = false
	laser.Material = LASER_MATERIAL
	laser.Color = LASER_COLOR
	laser.Transparency = LASER_TRANSPARENCY
	laser.Size = Vector3.new(LASER_THICKNESS, LASER_THICKNESS, (endPos - startPos).Magnitude)
	laser.CFrame = CFrame.new(startPos, endPos) * CFrame.new(0, 0, -laser.Size.Z/2)
	laser.Parent = workspace
	task.delay(LASER_DURATION, function()
		if laser then
			laser:Destroy()
		end
	end)
end
local function fireLaser()
	if not handle then return end
	local character = tool.Parent
	local player = game.Players:GetPlayerFromCharacter(character)
	if not player then return end
	local mouse = player:GetMouse()
	local origin = handle.Position
	local direction = (mouse.Hit.p - origin).Unit * LASER_RANGE
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	local result = workspace:Raycast(origin, direction, raycastParams)
	local hitPos = result and result.Position or (origin + direction)
	createLaser(origin, hitPos)
end
tool.Activated:Connect(fireLaser)
-- NPC following player when it get closer 
local PathfindingService = game:GetService(""PathfindingService"")
local Players = game:GetService(""Players"")
local npc = game.Workspace:WaitForChild(""Noob"")
function getNearestPlayerPosition(npcPosition)
	local nearestDistance = 20
	local nearestPosition = nil
	for _, player in Players:GetPlayers() do
		if player.Character and player.Character:FindFirstChild(""HumanoidRootPart"") then
			local playerPos = player.Character.HumanoidRootPart.Position
			local distance = (npcPosition - playerPos).Magnitude
			if distance < nearestDistance then
				nearestDistance = distance
				nearestPosition = playerPos
			else
				for _, player in Players:GetPlayers() do
					print(""Player "",player.Name,"" lost"")
				end			end
		end
	end
	return nearestPosition
end
function moveToPlayer()
	local humanoid = npc:FindFirstChild(""Humanoid"")
	local rootPart = npc:FindFirstChild(""HumanoidRootPart"")
	if not humanoid or not rootPart then return end
	local destination = getNearestPlayerPosition(rootPart.Position)
	if not destination then return end
	local path = PathfindingService:CreatePath({
		AgentRadius = 2,
		AgentHeight = 5,
		AgentCanJump = true,
		AgentJumpHeight = 10,
		AgentMaxSlope = 45,
	})
	local success, errorMessage = pcall(function()
		path:ComputeAsync(rootPart.Position, destination)
	end)
	if success then
		local waypoints = path:GetWaypoints()
		for i, waypoint in waypoints do
			humanoid:MoveTo(waypoint.Position)
			for _, player in Players:GetPlayers() do
				print(""Player "",player.Name,"" detected!"")
			end
			humanoid.MoveToFinished:Wait()
		end
	else
		warn(""Path not computed!"", path.Status, errorMessage)
	end
end
while true do
	moveToPlayer()
	task.wait(2)
end
"
