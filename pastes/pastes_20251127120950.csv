id,title,username,language,date,content
bHEUWHDE,Untitled,NikolOF,Python,Thursday 27th of November 2025 03:01:33 AM CDT,"square_meters = int(input())
price_per_square_meters = 7.61
total_price = price_per_square_meters * square_meters
discount = total_price * 0.18
final_price = total_price - discount


print(f""The final price is: {final_price} lv."")
print(f""The discount is: {discount} lv."")"
hkB3JW0i,P4568 [JLOI2011] 飞行路线,Sunlight9,C++,Thursday 27th of November 2025 02:59:35 AM CDT,"#include <bits/stdc++.h>

using namespace std;

// 定义无穷大常量，用于初始化距离数组
constexpr int inf = 0x3f3f3f3f;

// 定义边的结构体，用于邻接表和优先队列
struct Edge {
    int u, w; // u: 边的目标节点 (target node), w: 边的权值 (cost)
    
    // 重载小于号运算符 <
    // std::priority_queue 默认是大根堆（最大的元素在堆顶）
    // 为了让它变成小根堆（最小权值的边在堆顶），我们需要反转比较逻辑
    // 当当前边的权值 w 大于对方的权值 o.w 时，判定为“真”，使其沉底
    bool operator< (const Edge& o) const {
        return w > o.w;
    }
};

int main() {
    // 关闭输入输出同步，加速 I/O 操作
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m, k, s, t;
    // 输入：城市数 n，航线数 m，免费次数 k，起点 s，终点 t
    cin >> n >> m >> k >> s >> t;
    
    // 坐标偏移处理：题目给出的城市编号是 0 ~ n-1
    // 这里将其统一加 1，变为 1 ~ n，符合部分人的编程习惯（不加也可以，只要统一就行）
    s++; t++;
    
    // 初始化邻接表
    // 分层图共有 k+1 层（第0层到第k层）
    // 总节点数约为 n * (k + 1)，为了防止越界，开大一点点
    vector<vector<Edge> > adj((k + 1) * n + 1);
    
    // 读取 m 条航线信息
    for (int i = 1; i <= m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        u++; v++; // 同样将输入的节点编号加 1
        
        // 1. 建立第 0 层的原始边（完全不使用免费票的情况）
        // 连接 u 和 v，权值为 w
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
        
        // 2. 遍历第 1 层到第 k 层，构建分层图的其余部分
        for (int j = 1; j <= k; ++j) {
            // --- 策略 A：同层移动（不使用免费票） ---
            // 在第 j 层，连接 u 和 v，花费仍然是 w
            // 节点编号映射规则：第 j 层的节点 u 编号为 j * n + u
            adj[j * n + u].push_back({j * n + v, w});
            adj[j * n + v].push_back({j * n + u, w});
            
            // --- 策略 B：跨层移动（使用免费票） ---
            // 从第 j-1 层跨越到第 j 层，花费为 0
            // 这代表：在当前这条航线上使用了 1 次免费机会
            
            // 从 u (第 j-1 层) -> v (第 j 层)，权值 0
            adj[(j - 1) * n + u].push_back({j * n + v, 0});
            
            // 从 v (第 j-1 层) -> u (第 j 层)，权值 0
            adj[(j - 1) * n + v].push_back({j * n + u, 0});
        }
    }
    
    // Dijkstra 算法标准模板
    priority_queue<Edge> q;
    // dist 数组初始化为无穷大
    vector<int> dist((k + 1) * n + 1, inf);
    // vis 数组标记节点是否已确定最短路
    vector<bool> vis((k + 1) * n + 1);
    
    // 起点入队：起点 s 位于第 0 层，距离为 0
    q.push({s, 0});
    dist[s] = 0;
    
    while (!q.empty()) {
        Edge now = q.top();
        q.pop();
        int u = now.u; // 当前节点编号（包含了层级信息）
        
        // 如果该节点已经处理过最优解，跳过
        if (vis[u])
            continue;
        vis[u] = true;
        
        // 遍历所有邻接边
        for (int i = 0; i < adj[u].size(); ++i) {
            int v = adj[u][i].u; // 目标节点
            int w = adj[u][i].w; // 边权
            
            // 松弛操作：如果通过 u 到达 v 的距离更短，则更新
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                q.push({v, dist[v]});
            }
        }
    }
    
    // 统计答案
    // 最终到达终点 t 时，可能使用了 0 次、1 次 ... 或 k 次免费票
    // 这些状态分别对应分层图中的 t, n+t, 2n+t ... k*n+t
    // 取所有可能层级中终点距离的最小值
    int ans = inf;
    for (int i = 0; i <= k; ++i) {
        ans = min(ans, dist[i * n + t]);
    }
    
    cout << ans << ""\n"";
    
    return 0;
}"
DpGxeZ7B,Dijkstra求无向图单源最短路径,Sunlight9,C++,Thursday 27th of November 2025 02:26:16 AM CDT,"#include <bits/stdc++.h>

using namespace std;
// 使用 long long 防止路径总长度超过 int 范围（约 20 亿）
using ll = long long;

// 定义一个极大的数表示“无穷大”。
// 0x3f3f3f3f3f3f3f3f 在 long long 下是一个非常大的数，
// 且两个这样的数相加一般不会溢出，非常适合做最短路的初始值。
constexpr ll inf = 0x3f3f3f3f3f3f3f3f;

// Edge 结构体有两个用途：
// 1. 在邻接表 adj 中：u 表示邻接点编号，w 表示边的权重。
// 2. 在优先队列 q 中：u 表示节点编号，w 表示从起点 s 到 u 的当前最短距离。
struct Edge {
    int u;
    ll w;
    
    // 重载小于号运算符，用于优先队列的排序。
    // C++ 的 priority_queue 默认是“大根堆”（最大值在堆顶）。
    // 我们需要“小根堆”（距离最小的在堆顶），所以这里逻辑反过来：
    // 如果当前 w 大于对方的 w，则认为优先级更低。
    bool operator< (const Edge& o) const {
        return w > o.w;
    }
};

int main() {
    // 关闭输入输出同步流，提高 cin/cout 的读写速度，防止 TLE（超时）
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m, s;
    cin >> n >> m >> s; // 输入点数 n，边数 m，起点 s
    
    // 邻接表存储图，adj[u] 存储的是从 u 出发的所有边
    vector<vector<Edge> > adj(n + 1);
    
    // 读入 m 条边
    for (int i = 1; i <= m; ++i) {
        int u, v;
        ll w;
        cin >> u >> v >> w;
        // 无向图，所以要双向建边
        adj[u].push_back({v, w}); // u -> v 权重 w
        adj[v].push_back({u, w}); // v -> u 权重 w
    }
    
    // 优先队列（小根堆），存储 pair {节点 u, 距离 w}
    // 堆顶永远是当前未确定的点中，距离起点最近的那个点
    priority_queue<Edge> q;
    
    // dist 数组：存储起点 s 到各个点的最短距离，初始化为无穷大
    vector<ll> dist(n + 1, inf);
    
    // vis 数组：标记某个点是否已经确定了最短路（是否被“出队”过）
    vector<bool> vis(n + 1, false);
    
    // 初始状态：起点 s 到自己的距离为 0
    q.push({s, 0});
    dist[s] = 0;
    
    // Dijkstra 主循环
    while (!q.empty()) {
        // 取出堆顶元素（当前距离起点最近的点）
        Edge now = q.top();
        q.pop();
        
        int u = now.u; // 当前节点编号
        
        // 如果该点已经被访问过（即已经确定了最短路），则跳过。
        // 这是因为同一个点可能多次入队（每次发现更短路径都会入队），
        // 只有第一次出队时的距离才是最短的。
        if (vis[u])
            continue;
        
        // 标记该点已确定最短路
        vis[u] = true;
        
        // 遍历 u 的所有邻接点（扫描出边）
        for (int i = 0; i < adj[u].size(); ++i) {
            int v = adj[u][i].u;    // 邻接点 v
            ll w = adj[u][i].w;     // 边 u-v 的权重
            
            // 松弛操作 (Relaxation)：
            // 如果经由 u 到达 v 的距离（dist[u] + w）比当前记录的 dist[v] 更短
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;  // 更新 v 的最短距离
                q.push({v, dist[v]});   // 将更新后的 v 放入队列，以便后续扩展
            }
        }
    }
    
    // 输出从起点 s 到所有点 1~n 的最短距离
    for (int i = 1; i <= n; ++i) {
        cout << dist[i] << "" "";
    }
    cout << ""\n"";
    
    return 0;
}"
CR4rURSu,dfs找所有路径,Sunlight9,C++,Thursday 27th of November 2025 01:32:12 AM CDT,"#include <bits/stdc++.h>
using namespace std;

// 全局变量说明：
// t = 终点
// adj = 邻接表，adj[u] 存储与 u 相邻的所有顶点
// vis = 标记数组，防止路径中重复访问同一顶点（避免走回头路）
// path = 当前 DFS 正在走的路径
// record = 存储所有从 s 到 t 的路径
int t;
vector<vector<int> > adj;
vector<bool> vis;
vector<int> path;
vector<vector<int> > record;

// 深度优先搜索，寻找从 u 到 t 的所有简单路径
void dfs(int u) {

    // 如果当前点 u 就是目标点 t
    // 说明 path 保存了一条完整路径
    if (u == t) {
        record.push_back(path);   // 把当前整条路径保存下来
        return;                   // 返回上一层继续搜索别的路径
    }

    // 枚举从 u 出发的所有邻接点 v
    for (int i = 0; i < adj[u].size(); ++i) {
        int v = adj[u][i];

        // 如果 v 未在当前路径中出现（避免重复）
        if (!vis[v]) {

            // 选择：走向 v
            vis[v] = true;        // 标记 v 已经在当前路径中
            path.push_back(v);    // 把 v 加入路径
            
            dfs(v);               // 递归搜索从 v 出发的所有路径

            // 回溯：撤销选择
            vis[v] = false;       // 取消标记，允许其他路径再次访问 v
            path.pop_back();      // 从当前路径中弹出 v
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, s;
    cin >> n >> m >> s >> t;   // 输入点数、边数、起点 s 和终点 t

    adj.resize(n + 1);         // 邻接表初始化为 n 个点（1 开始编号）
    vis.resize(n + 1);         // 访问标记初始化为 n 个点（默认全为 false）

    // 输入图的边（无向图：双向加入邻接表）
    for (int i = 1; i <= m; ++i) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);   // u → v
        adj[v].push_back(u);   // v → u
    }

    // 初始化 DFS 起点
    path.push_back(s);         // 路径中加入起点
    vis[s] = true;             // 起点标记为已访问
    dfs(s);                    // 从 s 出发进行深度优先搜索

    // 输出所有找到的路径
    for (int i = 0; i < record.size(); ++i) {
        for (int j = 0; j < record[i].size(); ++j) {
            cout << record[i][j] << "" "";
        }
        cout << ""\n"";
    }

    return 0;
}
"
